
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:24:16.026] plan(): Setting new future strategy stack:
[10:24:16.027] List of future strategies:
[10:24:16.027] 1. sequential:
[10:24:16.027]    - args: function (..., envir = parent.frame())
[10:24:16.027]    - tweaked: FALSE
[10:24:16.027]    - call: future::plan("sequential")
[10:24:16.040] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:24:16.143] plan(): Setting new future strategy stack:
[10:24:16.143] List of future strategies:
[10:24:16.143] 1. sequential:
[10:24:16.143]    - args: function (..., envir = parent.frame())
[10:24:16.143]    - tweaked: FALSE
[10:24:16.143]    - call: plan(strategy)
[10:24:16.155] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[10:24:16.160] future_lapply() ...
[10:24:16.166] Number of chunks: 1
[10:24:16.166] getGlobalsAndPackagesXApply() ...
[10:24:16.167]  - future.globals: TRUE
[10:24:16.167] getGlobalsAndPackages() ...
[10:24:16.167] Searching for globals...
[10:24:16.171] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:16.171] Searching for globals ... DONE
[10:24:16.172] Resolving globals: FALSE
[10:24:16.173] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[10:24:16.174] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.174] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.174] - packages: [1] ‘future.apply’
[10:24:16.174] getGlobalsAndPackages() ... DONE
[10:24:16.174]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.174]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.174] Finding globals ... DONE
[10:24:16.174]  - use_args: TRUE
[10:24:16.175]  - Getting '...' globals ...
[10:24:16.175] resolve() on list ...
[10:24:16.175]  recursive: 0
[10:24:16.176]  length: 1
[10:24:16.176]  elements: ‘...’
[10:24:16.176]  length: 0 (resolved future 1)
[10:24:16.176] resolve() on list ... DONE
[10:24:16.176]    - '...' content: [n=0] 
[10:24:16.176] List of 1
[10:24:16.176]  $ ...: list()
[10:24:16.176]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.176]  - attr(*, "where")=List of 1
[10:24:16.176]   ..$ ...:<environment: 0x55b93b987d68> 
[10:24:16.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.176]  - attr(*, "resolved")= logi TRUE
[10:24:16.176]  - attr(*, "total_size")= num NA
[10:24:16.179]  - Getting '...' globals ... DONE
[10:24:16.179] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.179] List of 8
[10:24:16.179]  $ ...future.FUN:function (x, ...)  
[10:24:16.179]  $ x_FUN        :function (x)  
[10:24:16.179]  $ times        : int 1
[10:24:16.179]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.179]  $ stop_if_not  :function (...)  
[10:24:16.179]  $ dim          : NULL
[10:24:16.179]  $ valid_types  : chr "character"
[10:24:16.179]  $ ...          : list()
[10:24:16.179]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.179]  - attr(*, "where")=List of 8
[10:24:16.179]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.179]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.179]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.179]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.179]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.179]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.179]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.179]   ..$ ...          :<environment: 0x55b93b987d68> 
[10:24:16.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.179]  - attr(*, "resolved")= logi FALSE
[10:24:16.179]  - attr(*, "total_size")= num 94208
[10:24:16.186] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.186] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.187] Number of futures (= number of chunks): 1
[10:24:16.187] Launching 1 futures (chunks) ...
[10:24:16.187] Chunk #1 of 1 ...
[10:24:16.187]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.187] getGlobalsAndPackages() ...
[10:24:16.187] Searching for globals...
[10:24:16.188] 
[10:24:16.188] Searching for globals ... DONE
[10:24:16.188] - globals: [0] <none>
[10:24:16.188] getGlobalsAndPackages() ... DONE
[10:24:16.188]    + additional globals found: [n=0] 
[10:24:16.188]    + additional namespaces needed: [n=0] 
[10:24:16.188]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.188]  - seeds: <none>
[10:24:16.188]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.189] getGlobalsAndPackages() ...
[10:24:16.189] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.189] Resolving globals: FALSE
[10:24:16.189] Tweak future expression to call with '...' arguments ...
[10:24:16.189] {
[10:24:16.189]     do.call(function(...) {
[10:24:16.189]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.189]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.189]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.189]             on.exit(options(oopts), add = TRUE)
[10:24:16.189]         }
[10:24:16.189]         {
[10:24:16.189]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.189]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.189]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.189]             })
[10:24:16.189]         }
[10:24:16.189]     }, args = future.call.arguments)
[10:24:16.189] }
[10:24:16.189] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.190] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.190] - packages: [1] ‘future.apply’
[10:24:16.190] getGlobalsAndPackages() ... DONE
[10:24:16.191] run() for ‘Future’ ...
[10:24:16.191] - state: ‘created’
[10:24:16.191] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.191] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.192] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.192]   - Field: ‘label’
[10:24:16.192]   - Field: ‘local’
[10:24:16.192]   - Field: ‘owner’
[10:24:16.192]   - Field: ‘envir’
[10:24:16.192]   - Field: ‘packages’
[10:24:16.192]   - Field: ‘gc’
[10:24:16.192]   - Field: ‘conditions’
[10:24:16.192]   - Field: ‘expr’
[10:24:16.192]   - Field: ‘uuid’
[10:24:16.192]   - Field: ‘seed’
[10:24:16.193]   - Field: ‘version’
[10:24:16.193]   - Field: ‘result’
[10:24:16.193]   - Field: ‘asynchronous’
[10:24:16.193]   - Field: ‘calls’
[10:24:16.193]   - Field: ‘globals’
[10:24:16.193]   - Field: ‘stdout’
[10:24:16.193]   - Field: ‘earlySignal’
[10:24:16.193]   - Field: ‘lazy’
[10:24:16.193]   - Field: ‘state’
[10:24:16.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.193] - Launch lazy future ...
[10:24:16.194] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.194] Packages needed by future strategies (n = 0): <none>
[10:24:16.195] {
[10:24:16.195]     {
[10:24:16.195]         {
[10:24:16.195]             ...future.startTime <- base::Sys.time()
[10:24:16.195]             {
[10:24:16.195]                 {
[10:24:16.195]                   {
[10:24:16.195]                     {
[10:24:16.195]                       base::local({
[10:24:16.195]                         has_future <- base::requireNamespace("future", 
[10:24:16.195]                           quietly = TRUE)
[10:24:16.195]                         if (has_future) {
[10:24:16.195]                           ns <- base::getNamespace("future")
[10:24:16.195]                           version <- ns[[".package"]][["version"]]
[10:24:16.195]                           if (is.null(version)) 
[10:24:16.195]                             version <- utils::packageVersion("future")
[10:24:16.195]                         }
[10:24:16.195]                         else {
[10:24:16.195]                           version <- NULL
[10:24:16.195]                         }
[10:24:16.195]                         if (!has_future || version < "1.8.0") {
[10:24:16.195]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.195]                             "", base::R.version$version.string), 
[10:24:16.195]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.195]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.195]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.195]                               "release", "version")], collapse = " "), 
[10:24:16.195]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.195]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.195]                             info)
[10:24:16.195]                           info <- base::paste(info, collapse = "; ")
[10:24:16.195]                           if (!has_future) {
[10:24:16.195]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.195]                               info)
[10:24:16.195]                           }
[10:24:16.195]                           else {
[10:24:16.195]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.195]                               info, version)
[10:24:16.195]                           }
[10:24:16.195]                           base::stop(msg)
[10:24:16.195]                         }
[10:24:16.195]                       })
[10:24:16.195]                     }
[10:24:16.195]                     base::local({
[10:24:16.195]                       for (pkg in "future.apply") {
[10:24:16.195]                         base::loadNamespace(pkg)
[10:24:16.195]                         base::library(pkg, character.only = TRUE)
[10:24:16.195]                       }
[10:24:16.195]                     })
[10:24:16.195]                   }
[10:24:16.195]                   options(future.plan = NULL)
[10:24:16.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.195]                 }
[10:24:16.195]                 ...future.workdir <- getwd()
[10:24:16.195]             }
[10:24:16.195]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.195]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.195]         }
[10:24:16.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.195]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.195]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.195]             base::names(...future.oldOptions))
[10:24:16.195]     }
[10:24:16.195]     if (FALSE) {
[10:24:16.195]     }
[10:24:16.195]     else {
[10:24:16.195]         if (TRUE) {
[10:24:16.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.195]                 open = "w")
[10:24:16.195]         }
[10:24:16.195]         else {
[10:24:16.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.195]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.195]         }
[10:24:16.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.195]             base::sink(type = "output", split = FALSE)
[10:24:16.195]             base::close(...future.stdout)
[10:24:16.195]         }, add = TRUE)
[10:24:16.195]     }
[10:24:16.195]     ...future.frame <- base::sys.nframe()
[10:24:16.195]     ...future.conditions <- base::list()
[10:24:16.195]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.195]     if (FALSE) {
[10:24:16.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.195]     }
[10:24:16.195]     ...future.result <- base::tryCatch({
[10:24:16.195]         base::withCallingHandlers({
[10:24:16.195]             ...future.value <- base::withVisible(base::local({
[10:24:16.195]                 do.call(function(...) {
[10:24:16.195]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.195]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.195]                     ...future.globals.maxSize)) {
[10:24:16.195]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.195]                     on.exit(options(oopts), add = TRUE)
[10:24:16.195]                   }
[10:24:16.195]                   {
[10:24:16.195]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.195]                       FUN = function(jj) {
[10:24:16.195]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.195]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.195]                       })
[10:24:16.195]                   }
[10:24:16.195]                 }, args = future.call.arguments)
[10:24:16.195]             }))
[10:24:16.195]             future::FutureResult(value = ...future.value$value, 
[10:24:16.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.195]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.195]                     ...future.globalenv.names))
[10:24:16.195]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.195]         }, condition = base::local({
[10:24:16.195]             c <- base::c
[10:24:16.195]             inherits <- base::inherits
[10:24:16.195]             invokeRestart <- base::invokeRestart
[10:24:16.195]             length <- base::length
[10:24:16.195]             list <- base::list
[10:24:16.195]             seq.int <- base::seq.int
[10:24:16.195]             signalCondition <- base::signalCondition
[10:24:16.195]             sys.calls <- base::sys.calls
[10:24:16.195]             `[[` <- base::`[[`
[10:24:16.195]             `+` <- base::`+`
[10:24:16.195]             `<<-` <- base::`<<-`
[10:24:16.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.195]                   3L)]
[10:24:16.195]             }
[10:24:16.195]             function(cond) {
[10:24:16.195]                 is_error <- inherits(cond, "error")
[10:24:16.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.195]                   NULL)
[10:24:16.195]                 if (is_error) {
[10:24:16.195]                   sessionInformation <- function() {
[10:24:16.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.195]                       search = base::search(), system = base::Sys.info())
[10:24:16.195]                   }
[10:24:16.195]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.195]                     cond$call), session = sessionInformation(), 
[10:24:16.195]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.195]                   signalCondition(cond)
[10:24:16.195]                 }
[10:24:16.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.195]                 "immediateCondition"))) {
[10:24:16.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.195]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.195]                   if (TRUE && !signal) {
[10:24:16.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.195]                     {
[10:24:16.195]                       inherits <- base::inherits
[10:24:16.195]                       invokeRestart <- base::invokeRestart
[10:24:16.195]                       is.null <- base::is.null
[10:24:16.195]                       muffled <- FALSE
[10:24:16.195]                       if (inherits(cond, "message")) {
[10:24:16.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.195]                         if (muffled) 
[10:24:16.195]                           invokeRestart("muffleMessage")
[10:24:16.195]                       }
[10:24:16.195]                       else if (inherits(cond, "warning")) {
[10:24:16.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.195]                         if (muffled) 
[10:24:16.195]                           invokeRestart("muffleWarning")
[10:24:16.195]                       }
[10:24:16.195]                       else if (inherits(cond, "condition")) {
[10:24:16.195]                         if (!is.null(pattern)) {
[10:24:16.195]                           computeRestarts <- base::computeRestarts
[10:24:16.195]                           grepl <- base::grepl
[10:24:16.195]                           restarts <- computeRestarts(cond)
[10:24:16.195]                           for (restart in restarts) {
[10:24:16.195]                             name <- restart$name
[10:24:16.195]                             if (is.null(name)) 
[10:24:16.195]                               next
[10:24:16.195]                             if (!grepl(pattern, name)) 
[10:24:16.195]                               next
[10:24:16.195]                             invokeRestart(restart)
[10:24:16.195]                             muffled <- TRUE
[10:24:16.195]                             break
[10:24:16.195]                           }
[10:24:16.195]                         }
[10:24:16.195]                       }
[10:24:16.195]                       invisible(muffled)
[10:24:16.195]                     }
[10:24:16.195]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.195]                   }
[10:24:16.195]                 }
[10:24:16.195]                 else {
[10:24:16.195]                   if (TRUE) {
[10:24:16.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.195]                     {
[10:24:16.195]                       inherits <- base::inherits
[10:24:16.195]                       invokeRestart <- base::invokeRestart
[10:24:16.195]                       is.null <- base::is.null
[10:24:16.195]                       muffled <- FALSE
[10:24:16.195]                       if (inherits(cond, "message")) {
[10:24:16.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.195]                         if (muffled) 
[10:24:16.195]                           invokeRestart("muffleMessage")
[10:24:16.195]                       }
[10:24:16.195]                       else if (inherits(cond, "warning")) {
[10:24:16.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.195]                         if (muffled) 
[10:24:16.195]                           invokeRestart("muffleWarning")
[10:24:16.195]                       }
[10:24:16.195]                       else if (inherits(cond, "condition")) {
[10:24:16.195]                         if (!is.null(pattern)) {
[10:24:16.195]                           computeRestarts <- base::computeRestarts
[10:24:16.195]                           grepl <- base::grepl
[10:24:16.195]                           restarts <- computeRestarts(cond)
[10:24:16.195]                           for (restart in restarts) {
[10:24:16.195]                             name <- restart$name
[10:24:16.195]                             if (is.null(name)) 
[10:24:16.195]                               next
[10:24:16.195]                             if (!grepl(pattern, name)) 
[10:24:16.195]                               next
[10:24:16.195]                             invokeRestart(restart)
[10:24:16.195]                             muffled <- TRUE
[10:24:16.195]                             break
[10:24:16.195]                           }
[10:24:16.195]                         }
[10:24:16.195]                       }
[10:24:16.195]                       invisible(muffled)
[10:24:16.195]                     }
[10:24:16.195]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.195]                   }
[10:24:16.195]                 }
[10:24:16.195]             }
[10:24:16.195]         }))
[10:24:16.195]     }, error = function(ex) {
[10:24:16.195]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.195]                 ...future.rng), started = ...future.startTime, 
[10:24:16.195]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.195]             version = "1.8"), class = "FutureResult")
[10:24:16.195]     }, finally = {
[10:24:16.195]         if (!identical(...future.workdir, getwd())) 
[10:24:16.195]             setwd(...future.workdir)
[10:24:16.195]         {
[10:24:16.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.195]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.195]             }
[10:24:16.195]             base::options(...future.oldOptions)
[10:24:16.195]             if (.Platform$OS.type == "windows") {
[10:24:16.195]                 old_names <- names(...future.oldEnvVars)
[10:24:16.195]                 envs <- base::Sys.getenv()
[10:24:16.195]                 names <- names(envs)
[10:24:16.195]                 common <- intersect(names, old_names)
[10:24:16.195]                 added <- setdiff(names, old_names)
[10:24:16.195]                 removed <- setdiff(old_names, names)
[10:24:16.195]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.195]                   envs[common]]
[10:24:16.195]                 NAMES <- toupper(changed)
[10:24:16.195]                 args <- list()
[10:24:16.195]                 for (kk in seq_along(NAMES)) {
[10:24:16.195]                   name <- changed[[kk]]
[10:24:16.195]                   NAME <- NAMES[[kk]]
[10:24:16.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.195]                     next
[10:24:16.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.195]                 }
[10:24:16.195]                 NAMES <- toupper(added)
[10:24:16.195]                 for (kk in seq_along(NAMES)) {
[10:24:16.195]                   name <- added[[kk]]
[10:24:16.195]                   NAME <- NAMES[[kk]]
[10:24:16.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.195]                     next
[10:24:16.195]                   args[[name]] <- ""
[10:24:16.195]                 }
[10:24:16.195]                 NAMES <- toupper(removed)
[10:24:16.195]                 for (kk in seq_along(NAMES)) {
[10:24:16.195]                   name <- removed[[kk]]
[10:24:16.195]                   NAME <- NAMES[[kk]]
[10:24:16.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.195]                     next
[10:24:16.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.195]                 }
[10:24:16.195]                 if (length(args) > 0) 
[10:24:16.195]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.195]             }
[10:24:16.195]             else {
[10:24:16.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.195]             }
[10:24:16.195]             {
[10:24:16.195]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.195]                   0L) {
[10:24:16.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.195]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.195]                   base::options(opts)
[10:24:16.195]                 }
[10:24:16.195]                 {
[10:24:16.195]                   {
[10:24:16.195]                     NULL
[10:24:16.195]                     RNGkind("Mersenne-Twister")
[10:24:16.195]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.195]                       inherits = FALSE)
[10:24:16.195]                   }
[10:24:16.195]                   options(future.plan = NULL)
[10:24:16.195]                   if (is.na(NA_character_)) 
[10:24:16.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.195]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.195]                   {
[10:24:16.195]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.195]                     if (!future$lazy) 
[10:24:16.195]                       future <- run(future)
[10:24:16.195]                     invisible(future)
[10:24:16.195]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.195]                 }
[10:24:16.195]             }
[10:24:16.195]         }
[10:24:16.195]     })
[10:24:16.195]     if (TRUE) {
[10:24:16.195]         base::sink(type = "output", split = FALSE)
[10:24:16.195]         if (TRUE) {
[10:24:16.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.195]         }
[10:24:16.195]         else {
[10:24:16.195]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.195]         }
[10:24:16.195]         base::close(...future.stdout)
[10:24:16.195]         ...future.stdout <- NULL
[10:24:16.195]     }
[10:24:16.195]     ...future.result$conditions <- ...future.conditions
[10:24:16.195]     ...future.result$finished <- base::Sys.time()
[10:24:16.195]     ...future.result
[10:24:16.195] }
[10:24:16.197] assign_globals() ...
[10:24:16.197] List of 11
[10:24:16.197]  $ ...future.FUN            :function (x, ...)  
[10:24:16.197]  $ x_FUN                    :function (x)  
[10:24:16.197]  $ times                    : int 1
[10:24:16.197]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.197]  $ stop_if_not              :function (...)  
[10:24:16.197]  $ dim                      : NULL
[10:24:16.197]  $ valid_types              : chr "character"
[10:24:16.197]  $ future.call.arguments    : list()
[10:24:16.197]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.197]  $ ...future.elements_ii    :List of 2
[10:24:16.197]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:24:16.197]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[10:24:16.197]  $ ...future.seeds_ii       : NULL
[10:24:16.197]  $ ...future.globals.maxSize: NULL
[10:24:16.197]  - attr(*, "where")=List of 11
[10:24:16.197]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.197]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.197]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.197]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.197]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.197]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.197]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.197]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.197]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.197]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.197]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.197]  - attr(*, "resolved")= logi FALSE
[10:24:16.197]  - attr(*, "total_size")= num 94208
[10:24:16.197]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.197]  - attr(*, "already-done")= logi TRUE
[10:24:16.204] - copied ‘...future.FUN’ to environment
[10:24:16.205] - copied ‘x_FUN’ to environment
[10:24:16.205] - copied ‘times’ to environment
[10:24:16.205] - copied ‘stopf’ to environment
[10:24:16.205] - copied ‘stop_if_not’ to environment
[10:24:16.205] - copied ‘dim’ to environment
[10:24:16.205] - copied ‘valid_types’ to environment
[10:24:16.205] - copied ‘future.call.arguments’ to environment
[10:24:16.205] - copied ‘...future.elements_ii’ to environment
[10:24:16.205] - copied ‘...future.seeds_ii’ to environment
[10:24:16.205] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.206] assign_globals() ... done
[10:24:16.206] plan(): Setting new future strategy stack:
[10:24:16.206] List of future strategies:
[10:24:16.206] 1. sequential:
[10:24:16.206]    - args: function (..., envir = parent.frame())
[10:24:16.206]    - tweaked: FALSE
[10:24:16.206]    - call: NULL
[10:24:16.206] plan(): nbrOfWorkers() = 1
[10:24:16.207] plan(): Setting new future strategy stack:
[10:24:16.208] List of future strategies:
[10:24:16.208] 1. sequential:
[10:24:16.208]    - args: function (..., envir = parent.frame())
[10:24:16.208]    - tweaked: FALSE
[10:24:16.208]    - call: plan(strategy)
[10:24:16.208] plan(): nbrOfWorkers() = 1
[10:24:16.208] SequentialFuture started (and completed)
[10:24:16.209] - Launch lazy future ... done
[10:24:16.209] run() for ‘SequentialFuture’ ... done
[10:24:16.209] Created future:
[10:24:16.209] SequentialFuture:
[10:24:16.209] Label: ‘future_vapply-1’
[10:24:16.209] Expression:
[10:24:16.209] {
[10:24:16.209]     do.call(function(...) {
[10:24:16.209]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.209]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.209]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.209]             on.exit(options(oopts), add = TRUE)
[10:24:16.209]         }
[10:24:16.209]         {
[10:24:16.209]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.209]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.209]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.209]             })
[10:24:16.209]         }
[10:24:16.209]     }, args = future.call.arguments)
[10:24:16.209] }
[10:24:16.209] Lazy evaluation: FALSE
[10:24:16.209] Asynchronous evaluation: FALSE
[10:24:16.209] Local evaluation: TRUE
[10:24:16.209] Environment: R_GlobalEnv
[10:24:16.209] Capture standard output: TRUE
[10:24:16.209] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.209] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.209] Packages: 1 packages (‘future.apply’)
[10:24:16.209] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.209] Resolved: TRUE
[10:24:16.209] Value: 232 bytes of class ‘list’
[10:24:16.209] Early signaling: FALSE
[10:24:16.209] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.209] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.211] Chunk #1 of 1 ... DONE
[10:24:16.211] Launching 1 futures (chunks) ... DONE
[10:24:16.211] Resolving 1 futures (chunks) ...
[10:24:16.211] resolve() on list ...
[10:24:16.211]  recursive: 0
[10:24:16.211]  length: 1
[10:24:16.211] 
[10:24:16.211] resolved() for ‘SequentialFuture’ ...
[10:24:16.211] - state: ‘finished’
[10:24:16.212] - run: TRUE
[10:24:16.212] - result: ‘FutureResult’
[10:24:16.212] resolved() for ‘SequentialFuture’ ... done
[10:24:16.212] Future #1
[10:24:16.214] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.214] - nx: 1
[10:24:16.214] - relay: TRUE
[10:24:16.214] - stdout: TRUE
[10:24:16.214] - signal: TRUE
[10:24:16.214] - resignal: FALSE
[10:24:16.214] - force: TRUE
[10:24:16.214] - relayed: [n=1] FALSE
[10:24:16.214] - queued futures: [n=1] FALSE
[10:24:16.214]  - until=1
[10:24:16.214]  - relaying element #1
[10:24:16.215] - relayed: [n=1] TRUE
[10:24:16.215] - queued futures: [n=1] TRUE
[10:24:16.215] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.215]  length: 0 (resolved future 1)
[10:24:16.215] Relaying remaining futures
[10:24:16.215] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.215] - nx: 1
[10:24:16.215] - relay: TRUE
[10:24:16.215] - stdout: TRUE
[10:24:16.215] - signal: TRUE
[10:24:16.216] - resignal: FALSE
[10:24:16.216] - force: TRUE
[10:24:16.216] - relayed: [n=1] TRUE
[10:24:16.216] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.216] - relayed: [n=1] TRUE
[10:24:16.216] - queued futures: [n=1] TRUE
[10:24:16.216] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.216] resolve() on list ... DONE
[10:24:16.216]  - Number of value chunks collected: 1
[10:24:16.216] Resolving 1 futures (chunks) ... DONE
[10:24:16.217] Reducing values from 1 chunks ...
[10:24:16.217]  - Number of values collected after concatenation: 2
[10:24:16.217]  - Number of values expected: 2
[10:24:16.217] Reducing values from 1 chunks ... DONE
[10:24:16.217] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[10:24:16.218] future_lapply() ...
[10:24:16.220] Number of chunks: 1
[10:24:16.220] getGlobalsAndPackagesXApply() ...
[10:24:16.220]  - future.globals: TRUE
[10:24:16.220] getGlobalsAndPackages() ...
[10:24:16.220] Searching for globals...
[10:24:16.223] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[10:24:16.223] Searching for globals ... DONE
[10:24:16.223] Resolving globals: FALSE
[10:24:16.224] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[10:24:16.225] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.225] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.225] - packages: [1] ‘future.apply’
[10:24:16.225] getGlobalsAndPackages() ... DONE
[10:24:16.225]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.225]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.225] Finding globals ... DONE
[10:24:16.225]  - use_args: TRUE
[10:24:16.225]  - Getting '...' globals ...
[10:24:16.226] resolve() on list ...
[10:24:16.226]  recursive: 0
[10:24:16.226]  length: 1
[10:24:16.226]  elements: ‘...’
[10:24:16.226]  length: 0 (resolved future 1)
[10:24:16.226] resolve() on list ... DONE
[10:24:16.226]    - '...' content: [n=0] 
[10:24:16.226] List of 1
[10:24:16.226]  $ ...: list()
[10:24:16.226]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.226]  - attr(*, "where")=List of 1
[10:24:16.226]   ..$ ...:<environment: 0x55b93c246e30> 
[10:24:16.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.226]  - attr(*, "resolved")= logi TRUE
[10:24:16.226]  - attr(*, "total_size")= num NA
[10:24:16.229]  - Getting '...' globals ... DONE
[10:24:16.229] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.229] List of 8
[10:24:16.229]  $ ...future.FUN:function (x, ...)  
[10:24:16.229]  $ x_FUN        :function (x)  
[10:24:16.229]  $ times        : int 0
[10:24:16.229]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.229]  $ stop_if_not  :function (...)  
[10:24:16.229]  $ dim          : NULL
[10:24:16.229]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:16.229]  $ ...          : list()
[10:24:16.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.229]  - attr(*, "where")=List of 8
[10:24:16.229]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.229]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.229]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.229]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.229]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.229]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.229]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.229]   ..$ ...          :<environment: 0x55b93c246e30> 
[10:24:16.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.229]  - attr(*, "resolved")= logi FALSE
[10:24:16.229]  - attr(*, "total_size")= num 95472
[10:24:16.235] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.235] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.235] Number of futures (= number of chunks): 1
[10:24:16.235] Launching 1 futures (chunks) ...
[10:24:16.236] Chunk #1 of 1 ...
[10:24:16.236]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.236] getGlobalsAndPackages() ...
[10:24:16.236] Searching for globals...
[10:24:16.236] 
[10:24:16.236] Searching for globals ... DONE
[10:24:16.236] - globals: [0] <none>
[10:24:16.236] getGlobalsAndPackages() ... DONE
[10:24:16.236]    + additional globals found: [n=0] 
[10:24:16.237]    + additional namespaces needed: [n=0] 
[10:24:16.237]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.237]  - seeds: <none>
[10:24:16.237]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.237] getGlobalsAndPackages() ...
[10:24:16.237] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.237] Resolving globals: FALSE
[10:24:16.237] Tweak future expression to call with '...' arguments ...
[10:24:16.237] {
[10:24:16.237]     do.call(function(...) {
[10:24:16.237]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.237]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.237]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.237]             on.exit(options(oopts), add = TRUE)
[10:24:16.237]         }
[10:24:16.237]         {
[10:24:16.237]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.237]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.237]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.237]             })
[10:24:16.237]         }
[10:24:16.237]     }, args = future.call.arguments)
[10:24:16.237] }
[10:24:16.238] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.238] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.238] - packages: [1] ‘future.apply’
[10:24:16.238] getGlobalsAndPackages() ... DONE
[10:24:16.238] run() for ‘Future’ ...
[10:24:16.239] - state: ‘created’
[10:24:16.239] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.239] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.239] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.239]   - Field: ‘label’
[10:24:16.239]   - Field: ‘local’
[10:24:16.239]   - Field: ‘owner’
[10:24:16.239]   - Field: ‘envir’
[10:24:16.240]   - Field: ‘packages’
[10:24:16.240]   - Field: ‘gc’
[10:24:16.240]   - Field: ‘conditions’
[10:24:16.240]   - Field: ‘expr’
[10:24:16.240]   - Field: ‘uuid’
[10:24:16.240]   - Field: ‘seed’
[10:24:16.240]   - Field: ‘version’
[10:24:16.240]   - Field: ‘result’
[10:24:16.240]   - Field: ‘asynchronous’
[10:24:16.240]   - Field: ‘calls’
[10:24:16.240]   - Field: ‘globals’
[10:24:16.241]   - Field: ‘stdout’
[10:24:16.241]   - Field: ‘earlySignal’
[10:24:16.241]   - Field: ‘lazy’
[10:24:16.241]   - Field: ‘state’
[10:24:16.241] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.241] - Launch lazy future ...
[10:24:16.241] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.241] Packages needed by future strategies (n = 0): <none>
[10:24:16.242] {
[10:24:16.242]     {
[10:24:16.242]         {
[10:24:16.242]             ...future.startTime <- base::Sys.time()
[10:24:16.242]             {
[10:24:16.242]                 {
[10:24:16.242]                   {
[10:24:16.242]                     {
[10:24:16.242]                       base::local({
[10:24:16.242]                         has_future <- base::requireNamespace("future", 
[10:24:16.242]                           quietly = TRUE)
[10:24:16.242]                         if (has_future) {
[10:24:16.242]                           ns <- base::getNamespace("future")
[10:24:16.242]                           version <- ns[[".package"]][["version"]]
[10:24:16.242]                           if (is.null(version)) 
[10:24:16.242]                             version <- utils::packageVersion("future")
[10:24:16.242]                         }
[10:24:16.242]                         else {
[10:24:16.242]                           version <- NULL
[10:24:16.242]                         }
[10:24:16.242]                         if (!has_future || version < "1.8.0") {
[10:24:16.242]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.242]                             "", base::R.version$version.string), 
[10:24:16.242]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.242]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.242]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.242]                               "release", "version")], collapse = " "), 
[10:24:16.242]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.242]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.242]                             info)
[10:24:16.242]                           info <- base::paste(info, collapse = "; ")
[10:24:16.242]                           if (!has_future) {
[10:24:16.242]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.242]                               info)
[10:24:16.242]                           }
[10:24:16.242]                           else {
[10:24:16.242]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.242]                               info, version)
[10:24:16.242]                           }
[10:24:16.242]                           base::stop(msg)
[10:24:16.242]                         }
[10:24:16.242]                       })
[10:24:16.242]                     }
[10:24:16.242]                     base::local({
[10:24:16.242]                       for (pkg in "future.apply") {
[10:24:16.242]                         base::loadNamespace(pkg)
[10:24:16.242]                         base::library(pkg, character.only = TRUE)
[10:24:16.242]                       }
[10:24:16.242]                     })
[10:24:16.242]                   }
[10:24:16.242]                   options(future.plan = NULL)
[10:24:16.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.242]                 }
[10:24:16.242]                 ...future.workdir <- getwd()
[10:24:16.242]             }
[10:24:16.242]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.242]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.242]         }
[10:24:16.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.242]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.242]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.242]             base::names(...future.oldOptions))
[10:24:16.242]     }
[10:24:16.242]     if (FALSE) {
[10:24:16.242]     }
[10:24:16.242]     else {
[10:24:16.242]         if (TRUE) {
[10:24:16.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.242]                 open = "w")
[10:24:16.242]         }
[10:24:16.242]         else {
[10:24:16.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.242]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.242]         }
[10:24:16.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.242]             base::sink(type = "output", split = FALSE)
[10:24:16.242]             base::close(...future.stdout)
[10:24:16.242]         }, add = TRUE)
[10:24:16.242]     }
[10:24:16.242]     ...future.frame <- base::sys.nframe()
[10:24:16.242]     ...future.conditions <- base::list()
[10:24:16.242]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.242]     if (FALSE) {
[10:24:16.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.242]     }
[10:24:16.242]     ...future.result <- base::tryCatch({
[10:24:16.242]         base::withCallingHandlers({
[10:24:16.242]             ...future.value <- base::withVisible(base::local({
[10:24:16.242]                 do.call(function(...) {
[10:24:16.242]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.242]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.242]                     ...future.globals.maxSize)) {
[10:24:16.242]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.242]                     on.exit(options(oopts), add = TRUE)
[10:24:16.242]                   }
[10:24:16.242]                   {
[10:24:16.242]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.242]                       FUN = function(jj) {
[10:24:16.242]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.242]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.242]                       })
[10:24:16.242]                   }
[10:24:16.242]                 }, args = future.call.arguments)
[10:24:16.242]             }))
[10:24:16.242]             future::FutureResult(value = ...future.value$value, 
[10:24:16.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.242]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.242]                     ...future.globalenv.names))
[10:24:16.242]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.242]         }, condition = base::local({
[10:24:16.242]             c <- base::c
[10:24:16.242]             inherits <- base::inherits
[10:24:16.242]             invokeRestart <- base::invokeRestart
[10:24:16.242]             length <- base::length
[10:24:16.242]             list <- base::list
[10:24:16.242]             seq.int <- base::seq.int
[10:24:16.242]             signalCondition <- base::signalCondition
[10:24:16.242]             sys.calls <- base::sys.calls
[10:24:16.242]             `[[` <- base::`[[`
[10:24:16.242]             `+` <- base::`+`
[10:24:16.242]             `<<-` <- base::`<<-`
[10:24:16.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.242]                   3L)]
[10:24:16.242]             }
[10:24:16.242]             function(cond) {
[10:24:16.242]                 is_error <- inherits(cond, "error")
[10:24:16.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.242]                   NULL)
[10:24:16.242]                 if (is_error) {
[10:24:16.242]                   sessionInformation <- function() {
[10:24:16.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.242]                       search = base::search(), system = base::Sys.info())
[10:24:16.242]                   }
[10:24:16.242]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.242]                     cond$call), session = sessionInformation(), 
[10:24:16.242]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.242]                   signalCondition(cond)
[10:24:16.242]                 }
[10:24:16.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.242]                 "immediateCondition"))) {
[10:24:16.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.242]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.242]                   if (TRUE && !signal) {
[10:24:16.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.242]                     {
[10:24:16.242]                       inherits <- base::inherits
[10:24:16.242]                       invokeRestart <- base::invokeRestart
[10:24:16.242]                       is.null <- base::is.null
[10:24:16.242]                       muffled <- FALSE
[10:24:16.242]                       if (inherits(cond, "message")) {
[10:24:16.242]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.242]                         if (muffled) 
[10:24:16.242]                           invokeRestart("muffleMessage")
[10:24:16.242]                       }
[10:24:16.242]                       else if (inherits(cond, "warning")) {
[10:24:16.242]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.242]                         if (muffled) 
[10:24:16.242]                           invokeRestart("muffleWarning")
[10:24:16.242]                       }
[10:24:16.242]                       else if (inherits(cond, "condition")) {
[10:24:16.242]                         if (!is.null(pattern)) {
[10:24:16.242]                           computeRestarts <- base::computeRestarts
[10:24:16.242]                           grepl <- base::grepl
[10:24:16.242]                           restarts <- computeRestarts(cond)
[10:24:16.242]                           for (restart in restarts) {
[10:24:16.242]                             name <- restart$name
[10:24:16.242]                             if (is.null(name)) 
[10:24:16.242]                               next
[10:24:16.242]                             if (!grepl(pattern, name)) 
[10:24:16.242]                               next
[10:24:16.242]                             invokeRestart(restart)
[10:24:16.242]                             muffled <- TRUE
[10:24:16.242]                             break
[10:24:16.242]                           }
[10:24:16.242]                         }
[10:24:16.242]                       }
[10:24:16.242]                       invisible(muffled)
[10:24:16.242]                     }
[10:24:16.242]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.242]                   }
[10:24:16.242]                 }
[10:24:16.242]                 else {
[10:24:16.242]                   if (TRUE) {
[10:24:16.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.242]                     {
[10:24:16.242]                       inherits <- base::inherits
[10:24:16.242]                       invokeRestart <- base::invokeRestart
[10:24:16.242]                       is.null <- base::is.null
[10:24:16.242]                       muffled <- FALSE
[10:24:16.242]                       if (inherits(cond, "message")) {
[10:24:16.242]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.242]                         if (muffled) 
[10:24:16.242]                           invokeRestart("muffleMessage")
[10:24:16.242]                       }
[10:24:16.242]                       else if (inherits(cond, "warning")) {
[10:24:16.242]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.242]                         if (muffled) 
[10:24:16.242]                           invokeRestart("muffleWarning")
[10:24:16.242]                       }
[10:24:16.242]                       else if (inherits(cond, "condition")) {
[10:24:16.242]                         if (!is.null(pattern)) {
[10:24:16.242]                           computeRestarts <- base::computeRestarts
[10:24:16.242]                           grepl <- base::grepl
[10:24:16.242]                           restarts <- computeRestarts(cond)
[10:24:16.242]                           for (restart in restarts) {
[10:24:16.242]                             name <- restart$name
[10:24:16.242]                             if (is.null(name)) 
[10:24:16.242]                               next
[10:24:16.242]                             if (!grepl(pattern, name)) 
[10:24:16.242]                               next
[10:24:16.242]                             invokeRestart(restart)
[10:24:16.242]                             muffled <- TRUE
[10:24:16.242]                             break
[10:24:16.242]                           }
[10:24:16.242]                         }
[10:24:16.242]                       }
[10:24:16.242]                       invisible(muffled)
[10:24:16.242]                     }
[10:24:16.242]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.242]                   }
[10:24:16.242]                 }
[10:24:16.242]             }
[10:24:16.242]         }))
[10:24:16.242]     }, error = function(ex) {
[10:24:16.242]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.242]                 ...future.rng), started = ...future.startTime, 
[10:24:16.242]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.242]             version = "1.8"), class = "FutureResult")
[10:24:16.242]     }, finally = {
[10:24:16.242]         if (!identical(...future.workdir, getwd())) 
[10:24:16.242]             setwd(...future.workdir)
[10:24:16.242]         {
[10:24:16.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.242]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.242]             }
[10:24:16.242]             base::options(...future.oldOptions)
[10:24:16.242]             if (.Platform$OS.type == "windows") {
[10:24:16.242]                 old_names <- names(...future.oldEnvVars)
[10:24:16.242]                 envs <- base::Sys.getenv()
[10:24:16.242]                 names <- names(envs)
[10:24:16.242]                 common <- intersect(names, old_names)
[10:24:16.242]                 added <- setdiff(names, old_names)
[10:24:16.242]                 removed <- setdiff(old_names, names)
[10:24:16.242]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.242]                   envs[common]]
[10:24:16.242]                 NAMES <- toupper(changed)
[10:24:16.242]                 args <- list()
[10:24:16.242]                 for (kk in seq_along(NAMES)) {
[10:24:16.242]                   name <- changed[[kk]]
[10:24:16.242]                   NAME <- NAMES[[kk]]
[10:24:16.242]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.242]                     next
[10:24:16.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.242]                 }
[10:24:16.242]                 NAMES <- toupper(added)
[10:24:16.242]                 for (kk in seq_along(NAMES)) {
[10:24:16.242]                   name <- added[[kk]]
[10:24:16.242]                   NAME <- NAMES[[kk]]
[10:24:16.242]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.242]                     next
[10:24:16.242]                   args[[name]] <- ""
[10:24:16.242]                 }
[10:24:16.242]                 NAMES <- toupper(removed)
[10:24:16.242]                 for (kk in seq_along(NAMES)) {
[10:24:16.242]                   name <- removed[[kk]]
[10:24:16.242]                   NAME <- NAMES[[kk]]
[10:24:16.242]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.242]                     next
[10:24:16.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.242]                 }
[10:24:16.242]                 if (length(args) > 0) 
[10:24:16.242]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.242]             }
[10:24:16.242]             else {
[10:24:16.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.242]             }
[10:24:16.242]             {
[10:24:16.242]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.242]                   0L) {
[10:24:16.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.242]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.242]                   base::options(opts)
[10:24:16.242]                 }
[10:24:16.242]                 {
[10:24:16.242]                   {
[10:24:16.242]                     NULL
[10:24:16.242]                     RNGkind("Mersenne-Twister")
[10:24:16.242]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.242]                       inherits = FALSE)
[10:24:16.242]                   }
[10:24:16.242]                   options(future.plan = NULL)
[10:24:16.242]                   if (is.na(NA_character_)) 
[10:24:16.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.242]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.242]                   {
[10:24:16.242]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.242]                     if (!future$lazy) 
[10:24:16.242]                       future <- run(future)
[10:24:16.242]                     invisible(future)
[10:24:16.242]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.242]                 }
[10:24:16.242]             }
[10:24:16.242]         }
[10:24:16.242]     })
[10:24:16.242]     if (TRUE) {
[10:24:16.242]         base::sink(type = "output", split = FALSE)
[10:24:16.242]         if (TRUE) {
[10:24:16.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.242]         }
[10:24:16.242]         else {
[10:24:16.242]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.242]         }
[10:24:16.242]         base::close(...future.stdout)
[10:24:16.242]         ...future.stdout <- NULL
[10:24:16.242]     }
[10:24:16.242]     ...future.result$conditions <- ...future.conditions
[10:24:16.242]     ...future.result$finished <- base::Sys.time()
[10:24:16.242]     ...future.result
[10:24:16.242] }
[10:24:16.243] assign_globals() ...
[10:24:16.243] List of 11
[10:24:16.243]  $ ...future.FUN            :function (x, ...)  
[10:24:16.243]  $ x_FUN                    :function (x)  
[10:24:16.243]  $ times                    : int 0
[10:24:16.243]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.243]  $ stop_if_not              :function (...)  
[10:24:16.243]  $ dim                      : NULL
[10:24:16.243]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:16.243]  $ future.call.arguments    : list()
[10:24:16.243]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.243]  $ ...future.elements_ii    :List of 10
[10:24:16.243]   ..$ : int 1
[10:24:16.243]   ..$ : int 2
[10:24:16.243]   ..$ : int 3
[10:24:16.243]   ..$ : int 4
[10:24:16.243]   ..$ : int 5
[10:24:16.243]   ..$ : int 6
[10:24:16.243]   ..$ : int 7
[10:24:16.243]   ..$ : int 8
[10:24:16.243]   ..$ : int 9
[10:24:16.243]   ..$ : int 10
[10:24:16.243]  $ ...future.seeds_ii       : NULL
[10:24:16.243]  $ ...future.globals.maxSize: NULL
[10:24:16.243]  - attr(*, "where")=List of 11
[10:24:16.243]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.243]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.243]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.243]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.243]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.243]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.243]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.243]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.243]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.243]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.243]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.243]  - attr(*, "resolved")= logi FALSE
[10:24:16.243]  - attr(*, "total_size")= num 95472
[10:24:16.243]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.243]  - attr(*, "already-done")= logi TRUE
[10:24:16.253] - copied ‘...future.FUN’ to environment
[10:24:16.253] - reassign environment for ‘x_FUN’
[10:24:16.253] - copied ‘x_FUN’ to environment
[10:24:16.253] - copied ‘times’ to environment
[10:24:16.253] - copied ‘stopf’ to environment
[10:24:16.253] - copied ‘stop_if_not’ to environment
[10:24:16.253] - copied ‘dim’ to environment
[10:24:16.253] - copied ‘valid_types’ to environment
[10:24:16.253] - copied ‘future.call.arguments’ to environment
[10:24:16.254] - copied ‘...future.elements_ii’ to environment
[10:24:16.254] - copied ‘...future.seeds_ii’ to environment
[10:24:16.254] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.254] assign_globals() ... done
[10:24:16.254] plan(): Setting new future strategy stack:
[10:24:16.254] List of future strategies:
[10:24:16.254] 1. sequential:
[10:24:16.254]    - args: function (..., envir = parent.frame())
[10:24:16.254]    - tweaked: FALSE
[10:24:16.254]    - call: NULL
[10:24:16.255] plan(): nbrOfWorkers() = 1
[10:24:16.256] plan(): Setting new future strategy stack:
[10:24:16.256] List of future strategies:
[10:24:16.256] 1. sequential:
[10:24:16.256]    - args: function (..., envir = parent.frame())
[10:24:16.256]    - tweaked: FALSE
[10:24:16.256]    - call: plan(strategy)
[10:24:16.257] plan(): nbrOfWorkers() = 1
[10:24:16.257] SequentialFuture started (and completed)
[10:24:16.257] - Launch lazy future ... done
[10:24:16.257] run() for ‘SequentialFuture’ ... done
[10:24:16.257] Created future:
[10:24:16.257] SequentialFuture:
[10:24:16.257] Label: ‘future_vapply-1’
[10:24:16.257] Expression:
[10:24:16.257] {
[10:24:16.257]     do.call(function(...) {
[10:24:16.257]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.257]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.257]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.257]             on.exit(options(oopts), add = TRUE)
[10:24:16.257]         }
[10:24:16.257]         {
[10:24:16.257]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.257]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.257]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.257]             })
[10:24:16.257]         }
[10:24:16.257]     }, args = future.call.arguments)
[10:24:16.257] }
[10:24:16.257] Lazy evaluation: FALSE
[10:24:16.257] Asynchronous evaluation: FALSE
[10:24:16.257] Local evaluation: TRUE
[10:24:16.257] Environment: R_GlobalEnv
[10:24:16.257] Capture standard output: TRUE
[10:24:16.257] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.257] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.257] Packages: 1 packages (‘future.apply’)
[10:24:16.257] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.257] Resolved: TRUE
[10:24:16.257] Value: 480 bytes of class ‘list’
[10:24:16.257] Early signaling: FALSE
[10:24:16.257] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.257] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.258] Chunk #1 of 1 ... DONE
[10:24:16.258] Launching 1 futures (chunks) ... DONE
[10:24:16.259] Resolving 1 futures (chunks) ...
[10:24:16.259] resolve() on list ...
[10:24:16.259]  recursive: 0
[10:24:16.259]  length: 1
[10:24:16.259] 
[10:24:16.259] resolved() for ‘SequentialFuture’ ...
[10:24:16.259] - state: ‘finished’
[10:24:16.259] - run: TRUE
[10:24:16.259] - result: ‘FutureResult’
[10:24:16.259] resolved() for ‘SequentialFuture’ ... done
[10:24:16.259] Future #1
[10:24:16.260] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.260] - nx: 1
[10:24:16.260] - relay: TRUE
[10:24:16.260] - stdout: TRUE
[10:24:16.260] - signal: TRUE
[10:24:16.260] - resignal: FALSE
[10:24:16.260] - force: TRUE
[10:24:16.260] - relayed: [n=1] FALSE
[10:24:16.260] - queued futures: [n=1] FALSE
[10:24:16.260]  - until=1
[10:24:16.260]  - relaying element #1
[10:24:16.261] - relayed: [n=1] TRUE
[10:24:16.261] - queued futures: [n=1] TRUE
[10:24:16.261] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.261]  length: 0 (resolved future 1)
[10:24:16.261] Relaying remaining futures
[10:24:16.261] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.261] - nx: 1
[10:24:16.261] - relay: TRUE
[10:24:16.261] - stdout: TRUE
[10:24:16.261] - signal: TRUE
[10:24:16.261] - resignal: FALSE
[10:24:16.261] - force: TRUE
[10:24:16.262] - relayed: [n=1] TRUE
[10:24:16.262] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.262] - relayed: [n=1] TRUE
[10:24:16.262] - queued futures: [n=1] TRUE
[10:24:16.262] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.262] resolve() on list ... DONE
[10:24:16.262]  - Number of value chunks collected: 1
[10:24:16.262] Resolving 1 futures (chunks) ... DONE
[10:24:16.262] Reducing values from 1 chunks ...
[10:24:16.262]  - Number of values collected after concatenation: 10
[10:24:16.263]  - Number of values expected: 10
[10:24:16.263] Reducing values from 1 chunks ... DONE
[10:24:16.263] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[10:24:16.264] future_lapply() ...
[10:24:16.265] Number of chunks: 1
[10:24:16.265] getGlobalsAndPackagesXApply() ...
[10:24:16.265]  - future.globals: TRUE
[10:24:16.265] getGlobalsAndPackages() ...
[10:24:16.266] Searching for globals...
[10:24:16.269] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[10:24:16.269] Searching for globals ... DONE
[10:24:16.269] Resolving globals: FALSE
[10:24:16.270] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[10:24:16.270] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.270] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.270] - packages: [1] ‘future.apply’
[10:24:16.270] getGlobalsAndPackages() ... DONE
[10:24:16.271]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.271]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.271] Finding globals ... DONE
[10:24:16.271]  - use_args: TRUE
[10:24:16.271]  - Getting '...' globals ...
[10:24:16.271] resolve() on list ...
[10:24:16.271]  recursive: 0
[10:24:16.271]  length: 1
[10:24:16.271]  elements: ‘...’
[10:24:16.272]  length: 0 (resolved future 1)
[10:24:16.272] resolve() on list ... DONE
[10:24:16.272]    - '...' content: [n=0] 
[10:24:16.272] List of 1
[10:24:16.272]  $ ...: list()
[10:24:16.272]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.272]  - attr(*, "where")=List of 1
[10:24:16.272]   ..$ ...:<environment: 0x55b93c53c7f0> 
[10:24:16.272]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.272]  - attr(*, "resolved")= logi TRUE
[10:24:16.272]  - attr(*, "total_size")= num NA
[10:24:16.274]  - Getting '...' globals ... DONE
[10:24:16.274] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.274] List of 8
[10:24:16.274]  $ ...future.FUN:function (x, ...)  
[10:24:16.274]  $ x_FUN        :function (x)  
[10:24:16.274]  $ times        : int 0
[10:24:16.274]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.274]  $ stop_if_not  :function (...)  
[10:24:16.274]  $ dim          : NULL
[10:24:16.274]  $ valid_types  : chr [1:2] "logical" "integer"
[10:24:16.274]  $ ...          : list()
[10:24:16.274]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.274]  - attr(*, "where")=List of 8
[10:24:16.274]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.274]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.274]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.274]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.274]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.274]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.274]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.274]   ..$ ...          :<environment: 0x55b93c53c7f0> 
[10:24:16.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.274]  - attr(*, "resolved")= logi FALSE
[10:24:16.274]  - attr(*, "total_size")= num 95400
[10:24:16.281] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.281] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.281] Number of futures (= number of chunks): 1
[10:24:16.281] Launching 1 futures (chunks) ...
[10:24:16.281] Chunk #1 of 1 ...
[10:24:16.281]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.281] getGlobalsAndPackages() ...
[10:24:16.281] Searching for globals...
[10:24:16.282] 
[10:24:16.282] Searching for globals ... DONE
[10:24:16.282] - globals: [0] <none>
[10:24:16.282] getGlobalsAndPackages() ... DONE
[10:24:16.282]    + additional globals found: [n=0] 
[10:24:16.282]    + additional namespaces needed: [n=0] 
[10:24:16.282]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.282]  - seeds: <none>
[10:24:16.282]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.282] getGlobalsAndPackages() ...
[10:24:16.282] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.283] Resolving globals: FALSE
[10:24:16.283] Tweak future expression to call with '...' arguments ...
[10:24:16.283] {
[10:24:16.283]     do.call(function(...) {
[10:24:16.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.283]             on.exit(options(oopts), add = TRUE)
[10:24:16.283]         }
[10:24:16.283]         {
[10:24:16.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.283]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.283]             })
[10:24:16.283]         }
[10:24:16.283]     }, args = future.call.arguments)
[10:24:16.283] }
[10:24:16.283] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.283] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.284] - packages: [1] ‘future.apply’
[10:24:16.284] getGlobalsAndPackages() ... DONE
[10:24:16.284] run() for ‘Future’ ...
[10:24:16.284] - state: ‘created’
[10:24:16.284] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.284] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.285] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.285]   - Field: ‘label’
[10:24:16.285]   - Field: ‘local’
[10:24:16.285]   - Field: ‘owner’
[10:24:16.285]   - Field: ‘envir’
[10:24:16.285]   - Field: ‘packages’
[10:24:16.285]   - Field: ‘gc’
[10:24:16.285]   - Field: ‘conditions’
[10:24:16.285]   - Field: ‘expr’
[10:24:16.285]   - Field: ‘uuid’
[10:24:16.285]   - Field: ‘seed’
[10:24:16.286]   - Field: ‘version’
[10:24:16.286]   - Field: ‘result’
[10:24:16.286]   - Field: ‘asynchronous’
[10:24:16.286]   - Field: ‘calls’
[10:24:16.286]   - Field: ‘globals’
[10:24:16.286]   - Field: ‘stdout’
[10:24:16.286]   - Field: ‘earlySignal’
[10:24:16.286]   - Field: ‘lazy’
[10:24:16.286]   - Field: ‘state’
[10:24:16.286] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.286] - Launch lazy future ...
[10:24:16.287] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.287] Packages needed by future strategies (n = 0): <none>
[10:24:16.287] {
[10:24:16.287]     {
[10:24:16.287]         {
[10:24:16.287]             ...future.startTime <- base::Sys.time()
[10:24:16.287]             {
[10:24:16.287]                 {
[10:24:16.287]                   {
[10:24:16.287]                     {
[10:24:16.287]                       base::local({
[10:24:16.287]                         has_future <- base::requireNamespace("future", 
[10:24:16.287]                           quietly = TRUE)
[10:24:16.287]                         if (has_future) {
[10:24:16.287]                           ns <- base::getNamespace("future")
[10:24:16.287]                           version <- ns[[".package"]][["version"]]
[10:24:16.287]                           if (is.null(version)) 
[10:24:16.287]                             version <- utils::packageVersion("future")
[10:24:16.287]                         }
[10:24:16.287]                         else {
[10:24:16.287]                           version <- NULL
[10:24:16.287]                         }
[10:24:16.287]                         if (!has_future || version < "1.8.0") {
[10:24:16.287]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.287]                             "", base::R.version$version.string), 
[10:24:16.287]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.287]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.287]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.287]                               "release", "version")], collapse = " "), 
[10:24:16.287]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.287]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.287]                             info)
[10:24:16.287]                           info <- base::paste(info, collapse = "; ")
[10:24:16.287]                           if (!has_future) {
[10:24:16.287]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.287]                               info)
[10:24:16.287]                           }
[10:24:16.287]                           else {
[10:24:16.287]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.287]                               info, version)
[10:24:16.287]                           }
[10:24:16.287]                           base::stop(msg)
[10:24:16.287]                         }
[10:24:16.287]                       })
[10:24:16.287]                     }
[10:24:16.287]                     base::local({
[10:24:16.287]                       for (pkg in "future.apply") {
[10:24:16.287]                         base::loadNamespace(pkg)
[10:24:16.287]                         base::library(pkg, character.only = TRUE)
[10:24:16.287]                       }
[10:24:16.287]                     })
[10:24:16.287]                   }
[10:24:16.287]                   options(future.plan = NULL)
[10:24:16.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.287]                 }
[10:24:16.287]                 ...future.workdir <- getwd()
[10:24:16.287]             }
[10:24:16.287]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.287]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.287]         }
[10:24:16.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.287]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.287]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.287]             base::names(...future.oldOptions))
[10:24:16.287]     }
[10:24:16.287]     if (FALSE) {
[10:24:16.287]     }
[10:24:16.287]     else {
[10:24:16.287]         if (TRUE) {
[10:24:16.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.287]                 open = "w")
[10:24:16.287]         }
[10:24:16.287]         else {
[10:24:16.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.287]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.287]         }
[10:24:16.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.287]             base::sink(type = "output", split = FALSE)
[10:24:16.287]             base::close(...future.stdout)
[10:24:16.287]         }, add = TRUE)
[10:24:16.287]     }
[10:24:16.287]     ...future.frame <- base::sys.nframe()
[10:24:16.287]     ...future.conditions <- base::list()
[10:24:16.287]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.287]     if (FALSE) {
[10:24:16.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.287]     }
[10:24:16.287]     ...future.result <- base::tryCatch({
[10:24:16.287]         base::withCallingHandlers({
[10:24:16.287]             ...future.value <- base::withVisible(base::local({
[10:24:16.287]                 do.call(function(...) {
[10:24:16.287]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.287]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.287]                     ...future.globals.maxSize)) {
[10:24:16.287]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.287]                     on.exit(options(oopts), add = TRUE)
[10:24:16.287]                   }
[10:24:16.287]                   {
[10:24:16.287]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.287]                       FUN = function(jj) {
[10:24:16.287]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.287]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.287]                       })
[10:24:16.287]                   }
[10:24:16.287]                 }, args = future.call.arguments)
[10:24:16.287]             }))
[10:24:16.287]             future::FutureResult(value = ...future.value$value, 
[10:24:16.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.287]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.287]                     ...future.globalenv.names))
[10:24:16.287]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.287]         }, condition = base::local({
[10:24:16.287]             c <- base::c
[10:24:16.287]             inherits <- base::inherits
[10:24:16.287]             invokeRestart <- base::invokeRestart
[10:24:16.287]             length <- base::length
[10:24:16.287]             list <- base::list
[10:24:16.287]             seq.int <- base::seq.int
[10:24:16.287]             signalCondition <- base::signalCondition
[10:24:16.287]             sys.calls <- base::sys.calls
[10:24:16.287]             `[[` <- base::`[[`
[10:24:16.287]             `+` <- base::`+`
[10:24:16.287]             `<<-` <- base::`<<-`
[10:24:16.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.287]                   3L)]
[10:24:16.287]             }
[10:24:16.287]             function(cond) {
[10:24:16.287]                 is_error <- inherits(cond, "error")
[10:24:16.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.287]                   NULL)
[10:24:16.287]                 if (is_error) {
[10:24:16.287]                   sessionInformation <- function() {
[10:24:16.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.287]                       search = base::search(), system = base::Sys.info())
[10:24:16.287]                   }
[10:24:16.287]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.287]                     cond$call), session = sessionInformation(), 
[10:24:16.287]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.287]                   signalCondition(cond)
[10:24:16.287]                 }
[10:24:16.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.287]                 "immediateCondition"))) {
[10:24:16.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.287]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.287]                   if (TRUE && !signal) {
[10:24:16.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.287]                     {
[10:24:16.287]                       inherits <- base::inherits
[10:24:16.287]                       invokeRestart <- base::invokeRestart
[10:24:16.287]                       is.null <- base::is.null
[10:24:16.287]                       muffled <- FALSE
[10:24:16.287]                       if (inherits(cond, "message")) {
[10:24:16.287]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.287]                         if (muffled) 
[10:24:16.287]                           invokeRestart("muffleMessage")
[10:24:16.287]                       }
[10:24:16.287]                       else if (inherits(cond, "warning")) {
[10:24:16.287]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.287]                         if (muffled) 
[10:24:16.287]                           invokeRestart("muffleWarning")
[10:24:16.287]                       }
[10:24:16.287]                       else if (inherits(cond, "condition")) {
[10:24:16.287]                         if (!is.null(pattern)) {
[10:24:16.287]                           computeRestarts <- base::computeRestarts
[10:24:16.287]                           grepl <- base::grepl
[10:24:16.287]                           restarts <- computeRestarts(cond)
[10:24:16.287]                           for (restart in restarts) {
[10:24:16.287]                             name <- restart$name
[10:24:16.287]                             if (is.null(name)) 
[10:24:16.287]                               next
[10:24:16.287]                             if (!grepl(pattern, name)) 
[10:24:16.287]                               next
[10:24:16.287]                             invokeRestart(restart)
[10:24:16.287]                             muffled <- TRUE
[10:24:16.287]                             break
[10:24:16.287]                           }
[10:24:16.287]                         }
[10:24:16.287]                       }
[10:24:16.287]                       invisible(muffled)
[10:24:16.287]                     }
[10:24:16.287]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.287]                   }
[10:24:16.287]                 }
[10:24:16.287]                 else {
[10:24:16.287]                   if (TRUE) {
[10:24:16.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.287]                     {
[10:24:16.287]                       inherits <- base::inherits
[10:24:16.287]                       invokeRestart <- base::invokeRestart
[10:24:16.287]                       is.null <- base::is.null
[10:24:16.287]                       muffled <- FALSE
[10:24:16.287]                       if (inherits(cond, "message")) {
[10:24:16.287]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.287]                         if (muffled) 
[10:24:16.287]                           invokeRestart("muffleMessage")
[10:24:16.287]                       }
[10:24:16.287]                       else if (inherits(cond, "warning")) {
[10:24:16.287]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.287]                         if (muffled) 
[10:24:16.287]                           invokeRestart("muffleWarning")
[10:24:16.287]                       }
[10:24:16.287]                       else if (inherits(cond, "condition")) {
[10:24:16.287]                         if (!is.null(pattern)) {
[10:24:16.287]                           computeRestarts <- base::computeRestarts
[10:24:16.287]                           grepl <- base::grepl
[10:24:16.287]                           restarts <- computeRestarts(cond)
[10:24:16.287]                           for (restart in restarts) {
[10:24:16.287]                             name <- restart$name
[10:24:16.287]                             if (is.null(name)) 
[10:24:16.287]                               next
[10:24:16.287]                             if (!grepl(pattern, name)) 
[10:24:16.287]                               next
[10:24:16.287]                             invokeRestart(restart)
[10:24:16.287]                             muffled <- TRUE
[10:24:16.287]                             break
[10:24:16.287]                           }
[10:24:16.287]                         }
[10:24:16.287]                       }
[10:24:16.287]                       invisible(muffled)
[10:24:16.287]                     }
[10:24:16.287]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.287]                   }
[10:24:16.287]                 }
[10:24:16.287]             }
[10:24:16.287]         }))
[10:24:16.287]     }, error = function(ex) {
[10:24:16.287]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.287]                 ...future.rng), started = ...future.startTime, 
[10:24:16.287]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.287]             version = "1.8"), class = "FutureResult")
[10:24:16.287]     }, finally = {
[10:24:16.287]         if (!identical(...future.workdir, getwd())) 
[10:24:16.287]             setwd(...future.workdir)
[10:24:16.287]         {
[10:24:16.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.287]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.287]             }
[10:24:16.287]             base::options(...future.oldOptions)
[10:24:16.287]             if (.Platform$OS.type == "windows") {
[10:24:16.287]                 old_names <- names(...future.oldEnvVars)
[10:24:16.287]                 envs <- base::Sys.getenv()
[10:24:16.287]                 names <- names(envs)
[10:24:16.287]                 common <- intersect(names, old_names)
[10:24:16.287]                 added <- setdiff(names, old_names)
[10:24:16.287]                 removed <- setdiff(old_names, names)
[10:24:16.287]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.287]                   envs[common]]
[10:24:16.287]                 NAMES <- toupper(changed)
[10:24:16.287]                 args <- list()
[10:24:16.287]                 for (kk in seq_along(NAMES)) {
[10:24:16.287]                   name <- changed[[kk]]
[10:24:16.287]                   NAME <- NAMES[[kk]]
[10:24:16.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.287]                     next
[10:24:16.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.287]                 }
[10:24:16.287]                 NAMES <- toupper(added)
[10:24:16.287]                 for (kk in seq_along(NAMES)) {
[10:24:16.287]                   name <- added[[kk]]
[10:24:16.287]                   NAME <- NAMES[[kk]]
[10:24:16.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.287]                     next
[10:24:16.287]                   args[[name]] <- ""
[10:24:16.287]                 }
[10:24:16.287]                 NAMES <- toupper(removed)
[10:24:16.287]                 for (kk in seq_along(NAMES)) {
[10:24:16.287]                   name <- removed[[kk]]
[10:24:16.287]                   NAME <- NAMES[[kk]]
[10:24:16.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.287]                     next
[10:24:16.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.287]                 }
[10:24:16.287]                 if (length(args) > 0) 
[10:24:16.287]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.287]             }
[10:24:16.287]             else {
[10:24:16.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.287]             }
[10:24:16.287]             {
[10:24:16.287]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.287]                   0L) {
[10:24:16.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.287]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.287]                   base::options(opts)
[10:24:16.287]                 }
[10:24:16.287]                 {
[10:24:16.287]                   {
[10:24:16.287]                     NULL
[10:24:16.287]                     RNGkind("Mersenne-Twister")
[10:24:16.287]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.287]                       inherits = FALSE)
[10:24:16.287]                   }
[10:24:16.287]                   options(future.plan = NULL)
[10:24:16.287]                   if (is.na(NA_character_)) 
[10:24:16.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.287]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.287]                   {
[10:24:16.287]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.287]                     if (!future$lazy) 
[10:24:16.287]                       future <- run(future)
[10:24:16.287]                     invisible(future)
[10:24:16.287]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.287]                 }
[10:24:16.287]             }
[10:24:16.287]         }
[10:24:16.287]     })
[10:24:16.287]     if (TRUE) {
[10:24:16.287]         base::sink(type = "output", split = FALSE)
[10:24:16.287]         if (TRUE) {
[10:24:16.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.287]         }
[10:24:16.287]         else {
[10:24:16.287]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.287]         }
[10:24:16.287]         base::close(...future.stdout)
[10:24:16.287]         ...future.stdout <- NULL
[10:24:16.287]     }
[10:24:16.287]     ...future.result$conditions <- ...future.conditions
[10:24:16.287]     ...future.result$finished <- base::Sys.time()
[10:24:16.287]     ...future.result
[10:24:16.287] }
[10:24:16.289] assign_globals() ...
[10:24:16.289] List of 11
[10:24:16.289]  $ ...future.FUN            :function (x, ...)  
[10:24:16.289]  $ x_FUN                    :function (x)  
[10:24:16.289]  $ times                    : int 0
[10:24:16.289]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.289]  $ stop_if_not              :function (...)  
[10:24:16.289]  $ dim                      : NULL
[10:24:16.289]  $ valid_types              : chr [1:2] "logical" "integer"
[10:24:16.289]  $ future.call.arguments    : list()
[10:24:16.289]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.289]  $ ...future.elements_ii    :List of 10
[10:24:16.289]   ..$ : int 1
[10:24:16.289]   ..$ : int 2
[10:24:16.289]   ..$ : int 3
[10:24:16.289]   ..$ : int 4
[10:24:16.289]   ..$ : int 5
[10:24:16.289]   ..$ : int 6
[10:24:16.289]   ..$ : int 7
[10:24:16.289]   ..$ : int 8
[10:24:16.289]   ..$ : int 9
[10:24:16.289]   ..$ : int 10
[10:24:16.289]  $ ...future.seeds_ii       : NULL
[10:24:16.289]  $ ...future.globals.maxSize: NULL
[10:24:16.289]  - attr(*, "where")=List of 11
[10:24:16.289]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.289]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.289]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.289]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.289]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.289]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.289]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.289]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.289]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.289]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.289]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.289]  - attr(*, "resolved")= logi FALSE
[10:24:16.289]  - attr(*, "total_size")= num 95400
[10:24:16.289]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.289]  - attr(*, "already-done")= logi TRUE
[10:24:16.299] - copied ‘...future.FUN’ to environment
[10:24:16.299] - reassign environment for ‘x_FUN’
[10:24:16.299] - copied ‘x_FUN’ to environment
[10:24:16.300] - copied ‘times’ to environment
[10:24:16.300] - copied ‘stopf’ to environment
[10:24:16.300] - copied ‘stop_if_not’ to environment
[10:24:16.300] - copied ‘dim’ to environment
[10:24:16.300] - copied ‘valid_types’ to environment
[10:24:16.300] - copied ‘future.call.arguments’ to environment
[10:24:16.300] - copied ‘...future.elements_ii’ to environment
[10:24:16.300] - copied ‘...future.seeds_ii’ to environment
[10:24:16.300] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.300] assign_globals() ... done
[10:24:16.301] plan(): Setting new future strategy stack:
[10:24:16.301] List of future strategies:
[10:24:16.301] 1. sequential:
[10:24:16.301]    - args: function (..., envir = parent.frame())
[10:24:16.301]    - tweaked: FALSE
[10:24:16.301]    - call: NULL
[10:24:16.301] plan(): nbrOfWorkers() = 1
[10:24:16.302] plan(): Setting new future strategy stack:
[10:24:16.302] List of future strategies:
[10:24:16.302] 1. sequential:
[10:24:16.302]    - args: function (..., envir = parent.frame())
[10:24:16.302]    - tweaked: FALSE
[10:24:16.302]    - call: plan(strategy)
[10:24:16.302] plan(): nbrOfWorkers() = 1
[10:24:16.302] SequentialFuture started (and completed)
[10:24:16.303] - Launch lazy future ... done
[10:24:16.303] run() for ‘SequentialFuture’ ... done
[10:24:16.303] Created future:
[10:24:16.303] SequentialFuture:
[10:24:16.303] Label: ‘future_vapply-1’
[10:24:16.303] Expression:
[10:24:16.303] {
[10:24:16.303]     do.call(function(...) {
[10:24:16.303]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.303]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.303]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.303]             on.exit(options(oopts), add = TRUE)
[10:24:16.303]         }
[10:24:16.303]         {
[10:24:16.303]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.303]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.303]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.303]             })
[10:24:16.303]         }
[10:24:16.303]     }, args = future.call.arguments)
[10:24:16.303] }
[10:24:16.303] Lazy evaluation: FALSE
[10:24:16.303] Asynchronous evaluation: FALSE
[10:24:16.303] Local evaluation: TRUE
[10:24:16.303] Environment: R_GlobalEnv
[10:24:16.303] Capture standard output: TRUE
[10:24:16.303] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.303] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.303] Packages: 1 packages (‘future.apply’)
[10:24:16.303] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.303] Resolved: TRUE
[10:24:16.303] Value: 480 bytes of class ‘list’
[10:24:16.303] Early signaling: FALSE
[10:24:16.303] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.303] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.304] Chunk #1 of 1 ... DONE
[10:24:16.304] Launching 1 futures (chunks) ... DONE
[10:24:16.304] Resolving 1 futures (chunks) ...
[10:24:16.304] resolve() on list ...
[10:24:16.304]  recursive: 0
[10:24:16.304]  length: 1
[10:24:16.304] 
[10:24:16.305] resolved() for ‘SequentialFuture’ ...
[10:24:16.305] - state: ‘finished’
[10:24:16.305] - run: TRUE
[10:24:16.305] - result: ‘FutureResult’
[10:24:16.305] resolved() for ‘SequentialFuture’ ... done
[10:24:16.305] Future #1
[10:24:16.305] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.305] - nx: 1
[10:24:16.305] - relay: TRUE
[10:24:16.305] - stdout: TRUE
[10:24:16.306] - signal: TRUE
[10:24:16.306] - resignal: FALSE
[10:24:16.306] - force: TRUE
[10:24:16.306] - relayed: [n=1] FALSE
[10:24:16.306] - queued futures: [n=1] FALSE
[10:24:16.306]  - until=1
[10:24:16.306]  - relaying element #1
[10:24:16.306] - relayed: [n=1] TRUE
[10:24:16.306] - queued futures: [n=1] TRUE
[10:24:16.306] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.306]  length: 0 (resolved future 1)
[10:24:16.307] Relaying remaining futures
[10:24:16.307] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.307] - nx: 1
[10:24:16.307] - relay: TRUE
[10:24:16.307] - stdout: TRUE
[10:24:16.307] - signal: TRUE
[10:24:16.307] - resignal: FALSE
[10:24:16.307] - force: TRUE
[10:24:16.307] - relayed: [n=1] TRUE
[10:24:16.307] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.307] - relayed: [n=1] TRUE
[10:24:16.307] - queued futures: [n=1] TRUE
[10:24:16.308] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.308] resolve() on list ... DONE
[10:24:16.308]  - Number of value chunks collected: 1
[10:24:16.308] Resolving 1 futures (chunks) ... DONE
[10:24:16.308] Reducing values from 1 chunks ...
[10:24:16.308]  - Number of values collected after concatenation: 10
[10:24:16.308]  - Number of values expected: 10
[10:24:16.308] Reducing values from 1 chunks ... DONE
[10:24:16.308] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[10:24:16.309] future_lapply() ...
[10:24:16.311] Number of chunks: 1
[10:24:16.311] getGlobalsAndPackagesXApply() ...
[10:24:16.311]  - future.globals: TRUE
[10:24:16.311] getGlobalsAndPackages() ...
[10:24:16.311] Searching for globals...
[10:24:16.314] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:16.314] Searching for globals ... DONE
[10:24:16.314] Resolving globals: FALSE
[10:24:16.315] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[10:24:16.315] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.315] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.315] - packages: [1] ‘future.apply’
[10:24:16.315] getGlobalsAndPackages() ... DONE
[10:24:16.316]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.316]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.316] Finding globals ... DONE
[10:24:16.316]  - use_args: TRUE
[10:24:16.316]  - Getting '...' globals ...
[10:24:16.316] resolve() on list ...
[10:24:16.316]  recursive: 0
[10:24:16.316]  length: 1
[10:24:16.316]  elements: ‘...’
[10:24:16.317]  length: 0 (resolved future 1)
[10:24:16.317] resolve() on list ... DONE
[10:24:16.317]    - '...' content: [n=0] 
[10:24:16.317] List of 1
[10:24:16.317]  $ ...: list()
[10:24:16.317]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.317]  - attr(*, "where")=List of 1
[10:24:16.317]   ..$ ...:<environment: 0x55b93cc12040> 
[10:24:16.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.317]  - attr(*, "resolved")= logi TRUE
[10:24:16.317]  - attr(*, "total_size")= num NA
[10:24:16.320]  - Getting '...' globals ... DONE
[10:24:16.320] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.320] List of 8
[10:24:16.320]  $ ...future.FUN:function (x, ...)  
[10:24:16.320]  $ x_FUN        :function (x)  
[10:24:16.320]  $ times        : int 1
[10:24:16.320]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.320]  $ stop_if_not  :function (...)  
[10:24:16.320]  $ dim          : NULL
[10:24:16.320]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:16.320]  $ ...          : list()
[10:24:16.320]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.320]  - attr(*, "where")=List of 8
[10:24:16.320]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.320]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.320]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.320]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.320]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.320]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.320]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.320]   ..$ ...          :<environment: 0x55b93cc12040> 
[10:24:16.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.320]  - attr(*, "resolved")= logi FALSE
[10:24:16.320]  - attr(*, "total_size")= num 94336
[10:24:16.325] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.326] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.326] Number of futures (= number of chunks): 1
[10:24:16.326] Launching 1 futures (chunks) ...
[10:24:16.326] Chunk #1 of 1 ...
[10:24:16.326]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.326] getGlobalsAndPackages() ...
[10:24:16.326] Searching for globals...
[10:24:16.326] 
[10:24:16.327] Searching for globals ... DONE
[10:24:16.327] - globals: [0] <none>
[10:24:16.327] getGlobalsAndPackages() ... DONE
[10:24:16.327]    + additional globals found: [n=0] 
[10:24:16.327]    + additional namespaces needed: [n=0] 
[10:24:16.327]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.327]  - seeds: <none>
[10:24:16.327]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.327] getGlobalsAndPackages() ...
[10:24:16.327] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.327] Resolving globals: FALSE
[10:24:16.328] Tweak future expression to call with '...' arguments ...
[10:24:16.328] {
[10:24:16.328]     do.call(function(...) {
[10:24:16.328]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.328]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.328]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.328]             on.exit(options(oopts), add = TRUE)
[10:24:16.328]         }
[10:24:16.328]         {
[10:24:16.328]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.328]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.328]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.328]             })
[10:24:16.328]         }
[10:24:16.328]     }, args = future.call.arguments)
[10:24:16.328] }
[10:24:16.328] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.328] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.329] - packages: [1] ‘future.apply’
[10:24:16.329] getGlobalsAndPackages() ... DONE
[10:24:16.329] run() for ‘Future’ ...
[10:24:16.329] - state: ‘created’
[10:24:16.329] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.329] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.329] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.330]   - Field: ‘label’
[10:24:16.330]   - Field: ‘local’
[10:24:16.330]   - Field: ‘owner’
[10:24:16.330]   - Field: ‘envir’
[10:24:16.330]   - Field: ‘packages’
[10:24:16.330]   - Field: ‘gc’
[10:24:16.330]   - Field: ‘conditions’
[10:24:16.330]   - Field: ‘expr’
[10:24:16.330]   - Field: ‘uuid’
[10:24:16.330]   - Field: ‘seed’
[10:24:16.330]   - Field: ‘version’
[10:24:16.331]   - Field: ‘result’
[10:24:16.331]   - Field: ‘asynchronous’
[10:24:16.331]   - Field: ‘calls’
[10:24:16.331]   - Field: ‘globals’
[10:24:16.331]   - Field: ‘stdout’
[10:24:16.331]   - Field: ‘earlySignal’
[10:24:16.331]   - Field: ‘lazy’
[10:24:16.331]   - Field: ‘state’
[10:24:16.331] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.331] - Launch lazy future ...
[10:24:16.331] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.332] Packages needed by future strategies (n = 0): <none>
[10:24:16.332] {
[10:24:16.332]     {
[10:24:16.332]         {
[10:24:16.332]             ...future.startTime <- base::Sys.time()
[10:24:16.332]             {
[10:24:16.332]                 {
[10:24:16.332]                   {
[10:24:16.332]                     {
[10:24:16.332]                       base::local({
[10:24:16.332]                         has_future <- base::requireNamespace("future", 
[10:24:16.332]                           quietly = TRUE)
[10:24:16.332]                         if (has_future) {
[10:24:16.332]                           ns <- base::getNamespace("future")
[10:24:16.332]                           version <- ns[[".package"]][["version"]]
[10:24:16.332]                           if (is.null(version)) 
[10:24:16.332]                             version <- utils::packageVersion("future")
[10:24:16.332]                         }
[10:24:16.332]                         else {
[10:24:16.332]                           version <- NULL
[10:24:16.332]                         }
[10:24:16.332]                         if (!has_future || version < "1.8.0") {
[10:24:16.332]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.332]                             "", base::R.version$version.string), 
[10:24:16.332]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.332]                               "release", "version")], collapse = " "), 
[10:24:16.332]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.332]                             info)
[10:24:16.332]                           info <- base::paste(info, collapse = "; ")
[10:24:16.332]                           if (!has_future) {
[10:24:16.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.332]                               info)
[10:24:16.332]                           }
[10:24:16.332]                           else {
[10:24:16.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.332]                               info, version)
[10:24:16.332]                           }
[10:24:16.332]                           base::stop(msg)
[10:24:16.332]                         }
[10:24:16.332]                       })
[10:24:16.332]                     }
[10:24:16.332]                     base::local({
[10:24:16.332]                       for (pkg in "future.apply") {
[10:24:16.332]                         base::loadNamespace(pkg)
[10:24:16.332]                         base::library(pkg, character.only = TRUE)
[10:24:16.332]                       }
[10:24:16.332]                     })
[10:24:16.332]                   }
[10:24:16.332]                   options(future.plan = NULL)
[10:24:16.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.332]                 }
[10:24:16.332]                 ...future.workdir <- getwd()
[10:24:16.332]             }
[10:24:16.332]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.332]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.332]         }
[10:24:16.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.332]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.332]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.332]             base::names(...future.oldOptions))
[10:24:16.332]     }
[10:24:16.332]     if (FALSE) {
[10:24:16.332]     }
[10:24:16.332]     else {
[10:24:16.332]         if (TRUE) {
[10:24:16.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.332]                 open = "w")
[10:24:16.332]         }
[10:24:16.332]         else {
[10:24:16.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.332]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.332]         }
[10:24:16.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.332]             base::sink(type = "output", split = FALSE)
[10:24:16.332]             base::close(...future.stdout)
[10:24:16.332]         }, add = TRUE)
[10:24:16.332]     }
[10:24:16.332]     ...future.frame <- base::sys.nframe()
[10:24:16.332]     ...future.conditions <- base::list()
[10:24:16.332]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.332]     if (FALSE) {
[10:24:16.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.332]     }
[10:24:16.332]     ...future.result <- base::tryCatch({
[10:24:16.332]         base::withCallingHandlers({
[10:24:16.332]             ...future.value <- base::withVisible(base::local({
[10:24:16.332]                 do.call(function(...) {
[10:24:16.332]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.332]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.332]                     ...future.globals.maxSize)) {
[10:24:16.332]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.332]                     on.exit(options(oopts), add = TRUE)
[10:24:16.332]                   }
[10:24:16.332]                   {
[10:24:16.332]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.332]                       FUN = function(jj) {
[10:24:16.332]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.332]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.332]                       })
[10:24:16.332]                   }
[10:24:16.332]                 }, args = future.call.arguments)
[10:24:16.332]             }))
[10:24:16.332]             future::FutureResult(value = ...future.value$value, 
[10:24:16.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.332]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.332]                     ...future.globalenv.names))
[10:24:16.332]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.332]         }, condition = base::local({
[10:24:16.332]             c <- base::c
[10:24:16.332]             inherits <- base::inherits
[10:24:16.332]             invokeRestart <- base::invokeRestart
[10:24:16.332]             length <- base::length
[10:24:16.332]             list <- base::list
[10:24:16.332]             seq.int <- base::seq.int
[10:24:16.332]             signalCondition <- base::signalCondition
[10:24:16.332]             sys.calls <- base::sys.calls
[10:24:16.332]             `[[` <- base::`[[`
[10:24:16.332]             `+` <- base::`+`
[10:24:16.332]             `<<-` <- base::`<<-`
[10:24:16.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.332]                   3L)]
[10:24:16.332]             }
[10:24:16.332]             function(cond) {
[10:24:16.332]                 is_error <- inherits(cond, "error")
[10:24:16.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.332]                   NULL)
[10:24:16.332]                 if (is_error) {
[10:24:16.332]                   sessionInformation <- function() {
[10:24:16.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.332]                       search = base::search(), system = base::Sys.info())
[10:24:16.332]                   }
[10:24:16.332]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.332]                     cond$call), session = sessionInformation(), 
[10:24:16.332]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.332]                   signalCondition(cond)
[10:24:16.332]                 }
[10:24:16.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.332]                 "immediateCondition"))) {
[10:24:16.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.332]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.332]                   if (TRUE && !signal) {
[10:24:16.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.332]                     {
[10:24:16.332]                       inherits <- base::inherits
[10:24:16.332]                       invokeRestart <- base::invokeRestart
[10:24:16.332]                       is.null <- base::is.null
[10:24:16.332]                       muffled <- FALSE
[10:24:16.332]                       if (inherits(cond, "message")) {
[10:24:16.332]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.332]                         if (muffled) 
[10:24:16.332]                           invokeRestart("muffleMessage")
[10:24:16.332]                       }
[10:24:16.332]                       else if (inherits(cond, "warning")) {
[10:24:16.332]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.332]                         if (muffled) 
[10:24:16.332]                           invokeRestart("muffleWarning")
[10:24:16.332]                       }
[10:24:16.332]                       else if (inherits(cond, "condition")) {
[10:24:16.332]                         if (!is.null(pattern)) {
[10:24:16.332]                           computeRestarts <- base::computeRestarts
[10:24:16.332]                           grepl <- base::grepl
[10:24:16.332]                           restarts <- computeRestarts(cond)
[10:24:16.332]                           for (restart in restarts) {
[10:24:16.332]                             name <- restart$name
[10:24:16.332]                             if (is.null(name)) 
[10:24:16.332]                               next
[10:24:16.332]                             if (!grepl(pattern, name)) 
[10:24:16.332]                               next
[10:24:16.332]                             invokeRestart(restart)
[10:24:16.332]                             muffled <- TRUE
[10:24:16.332]                             break
[10:24:16.332]                           }
[10:24:16.332]                         }
[10:24:16.332]                       }
[10:24:16.332]                       invisible(muffled)
[10:24:16.332]                     }
[10:24:16.332]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.332]                   }
[10:24:16.332]                 }
[10:24:16.332]                 else {
[10:24:16.332]                   if (TRUE) {
[10:24:16.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.332]                     {
[10:24:16.332]                       inherits <- base::inherits
[10:24:16.332]                       invokeRestart <- base::invokeRestart
[10:24:16.332]                       is.null <- base::is.null
[10:24:16.332]                       muffled <- FALSE
[10:24:16.332]                       if (inherits(cond, "message")) {
[10:24:16.332]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.332]                         if (muffled) 
[10:24:16.332]                           invokeRestart("muffleMessage")
[10:24:16.332]                       }
[10:24:16.332]                       else if (inherits(cond, "warning")) {
[10:24:16.332]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.332]                         if (muffled) 
[10:24:16.332]                           invokeRestart("muffleWarning")
[10:24:16.332]                       }
[10:24:16.332]                       else if (inherits(cond, "condition")) {
[10:24:16.332]                         if (!is.null(pattern)) {
[10:24:16.332]                           computeRestarts <- base::computeRestarts
[10:24:16.332]                           grepl <- base::grepl
[10:24:16.332]                           restarts <- computeRestarts(cond)
[10:24:16.332]                           for (restart in restarts) {
[10:24:16.332]                             name <- restart$name
[10:24:16.332]                             if (is.null(name)) 
[10:24:16.332]                               next
[10:24:16.332]                             if (!grepl(pattern, name)) 
[10:24:16.332]                               next
[10:24:16.332]                             invokeRestart(restart)
[10:24:16.332]                             muffled <- TRUE
[10:24:16.332]                             break
[10:24:16.332]                           }
[10:24:16.332]                         }
[10:24:16.332]                       }
[10:24:16.332]                       invisible(muffled)
[10:24:16.332]                     }
[10:24:16.332]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.332]                   }
[10:24:16.332]                 }
[10:24:16.332]             }
[10:24:16.332]         }))
[10:24:16.332]     }, error = function(ex) {
[10:24:16.332]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.332]                 ...future.rng), started = ...future.startTime, 
[10:24:16.332]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.332]             version = "1.8"), class = "FutureResult")
[10:24:16.332]     }, finally = {
[10:24:16.332]         if (!identical(...future.workdir, getwd())) 
[10:24:16.332]             setwd(...future.workdir)
[10:24:16.332]         {
[10:24:16.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.332]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.332]             }
[10:24:16.332]             base::options(...future.oldOptions)
[10:24:16.332]             if (.Platform$OS.type == "windows") {
[10:24:16.332]                 old_names <- names(...future.oldEnvVars)
[10:24:16.332]                 envs <- base::Sys.getenv()
[10:24:16.332]                 names <- names(envs)
[10:24:16.332]                 common <- intersect(names, old_names)
[10:24:16.332]                 added <- setdiff(names, old_names)
[10:24:16.332]                 removed <- setdiff(old_names, names)
[10:24:16.332]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.332]                   envs[common]]
[10:24:16.332]                 NAMES <- toupper(changed)
[10:24:16.332]                 args <- list()
[10:24:16.332]                 for (kk in seq_along(NAMES)) {
[10:24:16.332]                   name <- changed[[kk]]
[10:24:16.332]                   NAME <- NAMES[[kk]]
[10:24:16.332]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.332]                     next
[10:24:16.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.332]                 }
[10:24:16.332]                 NAMES <- toupper(added)
[10:24:16.332]                 for (kk in seq_along(NAMES)) {
[10:24:16.332]                   name <- added[[kk]]
[10:24:16.332]                   NAME <- NAMES[[kk]]
[10:24:16.332]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.332]                     next
[10:24:16.332]                   args[[name]] <- ""
[10:24:16.332]                 }
[10:24:16.332]                 NAMES <- toupper(removed)
[10:24:16.332]                 for (kk in seq_along(NAMES)) {
[10:24:16.332]                   name <- removed[[kk]]
[10:24:16.332]                   NAME <- NAMES[[kk]]
[10:24:16.332]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.332]                     next
[10:24:16.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.332]                 }
[10:24:16.332]                 if (length(args) > 0) 
[10:24:16.332]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.332]             }
[10:24:16.332]             else {
[10:24:16.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.332]             }
[10:24:16.332]             {
[10:24:16.332]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.332]                   0L) {
[10:24:16.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.332]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.332]                   base::options(opts)
[10:24:16.332]                 }
[10:24:16.332]                 {
[10:24:16.332]                   {
[10:24:16.332]                     NULL
[10:24:16.332]                     RNGkind("Mersenne-Twister")
[10:24:16.332]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.332]                       inherits = FALSE)
[10:24:16.332]                   }
[10:24:16.332]                   options(future.plan = NULL)
[10:24:16.332]                   if (is.na(NA_character_)) 
[10:24:16.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.332]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.332]                   {
[10:24:16.332]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.332]                     if (!future$lazy) 
[10:24:16.332]                       future <- run(future)
[10:24:16.332]                     invisible(future)
[10:24:16.332]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.332]                 }
[10:24:16.332]             }
[10:24:16.332]         }
[10:24:16.332]     })
[10:24:16.332]     if (TRUE) {
[10:24:16.332]         base::sink(type = "output", split = FALSE)
[10:24:16.332]         if (TRUE) {
[10:24:16.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.332]         }
[10:24:16.332]         else {
[10:24:16.332]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.332]         }
[10:24:16.332]         base::close(...future.stdout)
[10:24:16.332]         ...future.stdout <- NULL
[10:24:16.332]     }
[10:24:16.332]     ...future.result$conditions <- ...future.conditions
[10:24:16.332]     ...future.result$finished <- base::Sys.time()
[10:24:16.332]     ...future.result
[10:24:16.332] }
[10:24:16.334] assign_globals() ...
[10:24:16.334] List of 11
[10:24:16.334]  $ ...future.FUN            :function (x, ...)  
[10:24:16.334]  $ x_FUN                    :function (x)  
[10:24:16.334]  $ times                    : int 1
[10:24:16.334]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.334]  $ stop_if_not              :function (...)  
[10:24:16.334]  $ dim                      : NULL
[10:24:16.334]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:16.334]  $ future.call.arguments    : list()
[10:24:16.334]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.334]  $ ...future.elements_ii    :List of 10
[10:24:16.334]   ..$ : int 1
[10:24:16.334]   ..$ : int 2
[10:24:16.334]   ..$ : int 3
[10:24:16.334]   ..$ : int 4
[10:24:16.334]   ..$ : int 5
[10:24:16.334]   ..$ : int 6
[10:24:16.334]   ..$ : int 7
[10:24:16.334]   ..$ : int 8
[10:24:16.334]   ..$ : int 9
[10:24:16.334]   ..$ : int 10
[10:24:16.334]  $ ...future.seeds_ii       : NULL
[10:24:16.334]  $ ...future.globals.maxSize: NULL
[10:24:16.334]  - attr(*, "where")=List of 11
[10:24:16.334]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.334]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.334]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.334]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.334]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.334]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.334]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.334]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.334]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.334]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.334]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.334]  - attr(*, "resolved")= logi FALSE
[10:24:16.334]  - attr(*, "total_size")= num 94336
[10:24:16.334]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.334]  - attr(*, "already-done")= logi TRUE
[10:24:16.344] - copied ‘...future.FUN’ to environment
[10:24:16.344] - copied ‘x_FUN’ to environment
[10:24:16.344] - copied ‘times’ to environment
[10:24:16.344] - copied ‘stopf’ to environment
[10:24:16.345] - copied ‘stop_if_not’ to environment
[10:24:16.345] - copied ‘dim’ to environment
[10:24:16.345] - copied ‘valid_types’ to environment
[10:24:16.345] - copied ‘future.call.arguments’ to environment
[10:24:16.345] - copied ‘...future.elements_ii’ to environment
[10:24:16.345] - copied ‘...future.seeds_ii’ to environment
[10:24:16.345] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.345] assign_globals() ... done
[10:24:16.345] plan(): Setting new future strategy stack:
[10:24:16.346] List of future strategies:
[10:24:16.346] 1. sequential:
[10:24:16.346]    - args: function (..., envir = parent.frame())
[10:24:16.346]    - tweaked: FALSE
[10:24:16.346]    - call: NULL
[10:24:16.346] plan(): nbrOfWorkers() = 1
[10:24:16.347] plan(): Setting new future strategy stack:
[10:24:16.347] List of future strategies:
[10:24:16.347] 1. sequential:
[10:24:16.347]    - args: function (..., envir = parent.frame())
[10:24:16.347]    - tweaked: FALSE
[10:24:16.347]    - call: plan(strategy)
[10:24:16.347] plan(): nbrOfWorkers() = 1
[10:24:16.347] SequentialFuture started (and completed)
[10:24:16.347] - Launch lazy future ... done
[10:24:16.347] run() for ‘SequentialFuture’ ... done
[10:24:16.348] Created future:
[10:24:16.348] SequentialFuture:
[10:24:16.348] Label: ‘future_vapply-1’
[10:24:16.348] Expression:
[10:24:16.348] {
[10:24:16.348]     do.call(function(...) {
[10:24:16.348]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.348]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.348]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.348]             on.exit(options(oopts), add = TRUE)
[10:24:16.348]         }
[10:24:16.348]         {
[10:24:16.348]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.348]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.348]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.348]             })
[10:24:16.348]         }
[10:24:16.348]     }, args = future.call.arguments)
[10:24:16.348] }
[10:24:16.348] Lazy evaluation: FALSE
[10:24:16.348] Asynchronous evaluation: FALSE
[10:24:16.348] Local evaluation: TRUE
[10:24:16.348] Environment: R_GlobalEnv
[10:24:16.348] Capture standard output: TRUE
[10:24:16.348] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.348] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.348] Packages: 1 packages (‘future.apply’)
[10:24:16.348] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.348] Resolved: TRUE
[10:24:16.348] Value: 560 bytes of class ‘list’
[10:24:16.348] Early signaling: FALSE
[10:24:16.348] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.348] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.349] Chunk #1 of 1 ... DONE
[10:24:16.349] Launching 1 futures (chunks) ... DONE
[10:24:16.349] Resolving 1 futures (chunks) ...
[10:24:16.349] resolve() on list ...
[10:24:16.349]  recursive: 0
[10:24:16.349]  length: 1
[10:24:16.349] 
[10:24:16.349] resolved() for ‘SequentialFuture’ ...
[10:24:16.349] - state: ‘finished’
[10:24:16.350] - run: TRUE
[10:24:16.350] - result: ‘FutureResult’
[10:24:16.350] resolved() for ‘SequentialFuture’ ... done
[10:24:16.350] Future #1
[10:24:16.350] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.350] - nx: 1
[10:24:16.350] - relay: TRUE
[10:24:16.350] - stdout: TRUE
[10:24:16.350] - signal: TRUE
[10:24:16.350] - resignal: FALSE
[10:24:16.350] - force: TRUE
[10:24:16.351] - relayed: [n=1] FALSE
[10:24:16.351] - queued futures: [n=1] FALSE
[10:24:16.351]  - until=1
[10:24:16.351]  - relaying element #1
[10:24:16.351] - relayed: [n=1] TRUE
[10:24:16.351] - queued futures: [n=1] TRUE
[10:24:16.351] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.351]  length: 0 (resolved future 1)
[10:24:16.351] Relaying remaining futures
[10:24:16.351] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.352] - nx: 1
[10:24:16.352] - relay: TRUE
[10:24:16.352] - stdout: TRUE
[10:24:16.352] - signal: TRUE
[10:24:16.352] - resignal: FALSE
[10:24:16.352] - force: TRUE
[10:24:16.352] - relayed: [n=1] TRUE
[10:24:16.352] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.352] - relayed: [n=1] TRUE
[10:24:16.352] - queued futures: [n=1] TRUE
[10:24:16.352] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.352] resolve() on list ... DONE
[10:24:16.353]  - Number of value chunks collected: 1
[10:24:16.353] Resolving 1 futures (chunks) ... DONE
[10:24:16.353] Reducing values from 1 chunks ...
[10:24:16.353]  - Number of values collected after concatenation: 10
[10:24:16.353]  - Number of values expected: 10
[10:24:16.353] Reducing values from 1 chunks ... DONE
[10:24:16.353] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[10:24:16.354] future_lapply() ...
[10:24:16.355] Number of chunks: 1
[10:24:16.355] getGlobalsAndPackagesXApply() ...
[10:24:16.356]  - future.globals: TRUE
[10:24:16.356] getGlobalsAndPackages() ...
[10:24:16.356] Searching for globals...
[10:24:16.360] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[10:24:16.360] Searching for globals ... DONE
[10:24:16.360] Resolving globals: FALSE
[10:24:16.361] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[10:24:16.361] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.361] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.362] - packages: [1] ‘future.apply’
[10:24:16.362] getGlobalsAndPackages() ... DONE
[10:24:16.362]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.362]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.362] Finding globals ... DONE
[10:24:16.362]  - use_args: TRUE
[10:24:16.362]  - Getting '...' globals ...
[10:24:16.362] resolve() on list ...
[10:24:16.362]  recursive: 0
[10:24:16.363]  length: 1
[10:24:16.363]  elements: ‘...’
[10:24:16.363]  length: 0 (resolved future 1)
[10:24:16.363] resolve() on list ... DONE
[10:24:16.363]    - '...' content: [n=0] 
[10:24:16.363] List of 1
[10:24:16.363]  $ ...: list()
[10:24:16.363]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.363]  - attr(*, "where")=List of 1
[10:24:16.363]   ..$ ...:<environment: 0x55b93ce7a450> 
[10:24:16.363]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.363]  - attr(*, "resolved")= logi TRUE
[10:24:16.363]  - attr(*, "total_size")= num NA
[10:24:16.365]  - Getting '...' globals ... DONE
[10:24:16.366] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.366] List of 8
[10:24:16.366]  $ ...future.FUN:function (x, ...)  
[10:24:16.366]  $ x_FUN        :function (x)  
[10:24:16.366]  $ times        : int 2
[10:24:16.366]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.366]  $ stop_if_not  :function (...)  
[10:24:16.366]  $ dim          : NULL
[10:24:16.366]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:16.366]  $ ...          : list()
[10:24:16.366]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.366]  - attr(*, "where")=List of 8
[10:24:16.366]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.366]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.366]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.366]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.366]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.366]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.366]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.366]   ..$ ...          :<environment: 0x55b93ce7a450> 
[10:24:16.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.366]  - attr(*, "resolved")= logi FALSE
[10:24:16.366]  - attr(*, "total_size")= num 96456
[10:24:16.371] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.371] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.371] Number of futures (= number of chunks): 1
[10:24:16.371] Launching 1 futures (chunks) ...
[10:24:16.371] Chunk #1 of 1 ...
[10:24:16.371]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.371] getGlobalsAndPackages() ...
[10:24:16.371] Searching for globals...
[10:24:16.372] 
[10:24:16.372] Searching for globals ... DONE
[10:24:16.372] - globals: [0] <none>
[10:24:16.372] getGlobalsAndPackages() ... DONE
[10:24:16.372]    + additional globals found: [n=0] 
[10:24:16.372]    + additional namespaces needed: [n=0] 
[10:24:16.372]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.372]  - seeds: <none>
[10:24:16.372]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.372] getGlobalsAndPackages() ...
[10:24:16.373] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.373] Resolving globals: FALSE
[10:24:16.373] Tweak future expression to call with '...' arguments ...
[10:24:16.373] {
[10:24:16.373]     do.call(function(...) {
[10:24:16.373]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.373]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.373]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.373]             on.exit(options(oopts), add = TRUE)
[10:24:16.373]         }
[10:24:16.373]         {
[10:24:16.373]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.373]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.373]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.373]             })
[10:24:16.373]         }
[10:24:16.373]     }, args = future.call.arguments)
[10:24:16.373] }
[10:24:16.373] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.374] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.374] - packages: [1] ‘future.apply’
[10:24:16.374] getGlobalsAndPackages() ... DONE
[10:24:16.374] run() for ‘Future’ ...
[10:24:16.374] - state: ‘created’
[10:24:16.374] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.374] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.375] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.375]   - Field: ‘label’
[10:24:16.375]   - Field: ‘local’
[10:24:16.375]   - Field: ‘owner’
[10:24:16.375]   - Field: ‘envir’
[10:24:16.375]   - Field: ‘packages’
[10:24:16.375]   - Field: ‘gc’
[10:24:16.375]   - Field: ‘conditions’
[10:24:16.375]   - Field: ‘expr’
[10:24:16.375]   - Field: ‘uuid’
[10:24:16.376]   - Field: ‘seed’
[10:24:16.376]   - Field: ‘version’
[10:24:16.376]   - Field: ‘result’
[10:24:16.376]   - Field: ‘asynchronous’
[10:24:16.376]   - Field: ‘calls’
[10:24:16.376]   - Field: ‘globals’
[10:24:16.376]   - Field: ‘stdout’
[10:24:16.376]   - Field: ‘earlySignal’
[10:24:16.376]   - Field: ‘lazy’
[10:24:16.376]   - Field: ‘state’
[10:24:16.376] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.376] - Launch lazy future ...
[10:24:16.377] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.377] Packages needed by future strategies (n = 0): <none>
[10:24:16.377] {
[10:24:16.377]     {
[10:24:16.377]         {
[10:24:16.377]             ...future.startTime <- base::Sys.time()
[10:24:16.377]             {
[10:24:16.377]                 {
[10:24:16.377]                   {
[10:24:16.377]                     {
[10:24:16.377]                       base::local({
[10:24:16.377]                         has_future <- base::requireNamespace("future", 
[10:24:16.377]                           quietly = TRUE)
[10:24:16.377]                         if (has_future) {
[10:24:16.377]                           ns <- base::getNamespace("future")
[10:24:16.377]                           version <- ns[[".package"]][["version"]]
[10:24:16.377]                           if (is.null(version)) 
[10:24:16.377]                             version <- utils::packageVersion("future")
[10:24:16.377]                         }
[10:24:16.377]                         else {
[10:24:16.377]                           version <- NULL
[10:24:16.377]                         }
[10:24:16.377]                         if (!has_future || version < "1.8.0") {
[10:24:16.377]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.377]                             "", base::R.version$version.string), 
[10:24:16.377]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.377]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.377]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.377]                               "release", "version")], collapse = " "), 
[10:24:16.377]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.377]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.377]                             info)
[10:24:16.377]                           info <- base::paste(info, collapse = "; ")
[10:24:16.377]                           if (!has_future) {
[10:24:16.377]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.377]                               info)
[10:24:16.377]                           }
[10:24:16.377]                           else {
[10:24:16.377]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.377]                               info, version)
[10:24:16.377]                           }
[10:24:16.377]                           base::stop(msg)
[10:24:16.377]                         }
[10:24:16.377]                       })
[10:24:16.377]                     }
[10:24:16.377]                     base::local({
[10:24:16.377]                       for (pkg in "future.apply") {
[10:24:16.377]                         base::loadNamespace(pkg)
[10:24:16.377]                         base::library(pkg, character.only = TRUE)
[10:24:16.377]                       }
[10:24:16.377]                     })
[10:24:16.377]                   }
[10:24:16.377]                   options(future.plan = NULL)
[10:24:16.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.377]                 }
[10:24:16.377]                 ...future.workdir <- getwd()
[10:24:16.377]             }
[10:24:16.377]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.377]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.377]         }
[10:24:16.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.377]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.377]             base::names(...future.oldOptions))
[10:24:16.377]     }
[10:24:16.377]     if (FALSE) {
[10:24:16.377]     }
[10:24:16.377]     else {
[10:24:16.377]         if (TRUE) {
[10:24:16.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.377]                 open = "w")
[10:24:16.377]         }
[10:24:16.377]         else {
[10:24:16.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.377]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.377]         }
[10:24:16.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.377]             base::sink(type = "output", split = FALSE)
[10:24:16.377]             base::close(...future.stdout)
[10:24:16.377]         }, add = TRUE)
[10:24:16.377]     }
[10:24:16.377]     ...future.frame <- base::sys.nframe()
[10:24:16.377]     ...future.conditions <- base::list()
[10:24:16.377]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.377]     if (FALSE) {
[10:24:16.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.377]     }
[10:24:16.377]     ...future.result <- base::tryCatch({
[10:24:16.377]         base::withCallingHandlers({
[10:24:16.377]             ...future.value <- base::withVisible(base::local({
[10:24:16.377]                 do.call(function(...) {
[10:24:16.377]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.377]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.377]                     ...future.globals.maxSize)) {
[10:24:16.377]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.377]                     on.exit(options(oopts), add = TRUE)
[10:24:16.377]                   }
[10:24:16.377]                   {
[10:24:16.377]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.377]                       FUN = function(jj) {
[10:24:16.377]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.377]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.377]                       })
[10:24:16.377]                   }
[10:24:16.377]                 }, args = future.call.arguments)
[10:24:16.377]             }))
[10:24:16.377]             future::FutureResult(value = ...future.value$value, 
[10:24:16.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.377]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.377]                     ...future.globalenv.names))
[10:24:16.377]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.377]         }, condition = base::local({
[10:24:16.377]             c <- base::c
[10:24:16.377]             inherits <- base::inherits
[10:24:16.377]             invokeRestart <- base::invokeRestart
[10:24:16.377]             length <- base::length
[10:24:16.377]             list <- base::list
[10:24:16.377]             seq.int <- base::seq.int
[10:24:16.377]             signalCondition <- base::signalCondition
[10:24:16.377]             sys.calls <- base::sys.calls
[10:24:16.377]             `[[` <- base::`[[`
[10:24:16.377]             `+` <- base::`+`
[10:24:16.377]             `<<-` <- base::`<<-`
[10:24:16.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.377]                   3L)]
[10:24:16.377]             }
[10:24:16.377]             function(cond) {
[10:24:16.377]                 is_error <- inherits(cond, "error")
[10:24:16.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.377]                   NULL)
[10:24:16.377]                 if (is_error) {
[10:24:16.377]                   sessionInformation <- function() {
[10:24:16.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.377]                       search = base::search(), system = base::Sys.info())
[10:24:16.377]                   }
[10:24:16.377]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.377]                     cond$call), session = sessionInformation(), 
[10:24:16.377]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.377]                   signalCondition(cond)
[10:24:16.377]                 }
[10:24:16.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.377]                 "immediateCondition"))) {
[10:24:16.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.377]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.377]                   if (TRUE && !signal) {
[10:24:16.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.377]                     {
[10:24:16.377]                       inherits <- base::inherits
[10:24:16.377]                       invokeRestart <- base::invokeRestart
[10:24:16.377]                       is.null <- base::is.null
[10:24:16.377]                       muffled <- FALSE
[10:24:16.377]                       if (inherits(cond, "message")) {
[10:24:16.377]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.377]                         if (muffled) 
[10:24:16.377]                           invokeRestart("muffleMessage")
[10:24:16.377]                       }
[10:24:16.377]                       else if (inherits(cond, "warning")) {
[10:24:16.377]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.377]                         if (muffled) 
[10:24:16.377]                           invokeRestart("muffleWarning")
[10:24:16.377]                       }
[10:24:16.377]                       else if (inherits(cond, "condition")) {
[10:24:16.377]                         if (!is.null(pattern)) {
[10:24:16.377]                           computeRestarts <- base::computeRestarts
[10:24:16.377]                           grepl <- base::grepl
[10:24:16.377]                           restarts <- computeRestarts(cond)
[10:24:16.377]                           for (restart in restarts) {
[10:24:16.377]                             name <- restart$name
[10:24:16.377]                             if (is.null(name)) 
[10:24:16.377]                               next
[10:24:16.377]                             if (!grepl(pattern, name)) 
[10:24:16.377]                               next
[10:24:16.377]                             invokeRestart(restart)
[10:24:16.377]                             muffled <- TRUE
[10:24:16.377]                             break
[10:24:16.377]                           }
[10:24:16.377]                         }
[10:24:16.377]                       }
[10:24:16.377]                       invisible(muffled)
[10:24:16.377]                     }
[10:24:16.377]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.377]                   }
[10:24:16.377]                 }
[10:24:16.377]                 else {
[10:24:16.377]                   if (TRUE) {
[10:24:16.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.377]                     {
[10:24:16.377]                       inherits <- base::inherits
[10:24:16.377]                       invokeRestart <- base::invokeRestart
[10:24:16.377]                       is.null <- base::is.null
[10:24:16.377]                       muffled <- FALSE
[10:24:16.377]                       if (inherits(cond, "message")) {
[10:24:16.377]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.377]                         if (muffled) 
[10:24:16.377]                           invokeRestart("muffleMessage")
[10:24:16.377]                       }
[10:24:16.377]                       else if (inherits(cond, "warning")) {
[10:24:16.377]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.377]                         if (muffled) 
[10:24:16.377]                           invokeRestart("muffleWarning")
[10:24:16.377]                       }
[10:24:16.377]                       else if (inherits(cond, "condition")) {
[10:24:16.377]                         if (!is.null(pattern)) {
[10:24:16.377]                           computeRestarts <- base::computeRestarts
[10:24:16.377]                           grepl <- base::grepl
[10:24:16.377]                           restarts <- computeRestarts(cond)
[10:24:16.377]                           for (restart in restarts) {
[10:24:16.377]                             name <- restart$name
[10:24:16.377]                             if (is.null(name)) 
[10:24:16.377]                               next
[10:24:16.377]                             if (!grepl(pattern, name)) 
[10:24:16.377]                               next
[10:24:16.377]                             invokeRestart(restart)
[10:24:16.377]                             muffled <- TRUE
[10:24:16.377]                             break
[10:24:16.377]                           }
[10:24:16.377]                         }
[10:24:16.377]                       }
[10:24:16.377]                       invisible(muffled)
[10:24:16.377]                     }
[10:24:16.377]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.377]                   }
[10:24:16.377]                 }
[10:24:16.377]             }
[10:24:16.377]         }))
[10:24:16.377]     }, error = function(ex) {
[10:24:16.377]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.377]                 ...future.rng), started = ...future.startTime, 
[10:24:16.377]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.377]             version = "1.8"), class = "FutureResult")
[10:24:16.377]     }, finally = {
[10:24:16.377]         if (!identical(...future.workdir, getwd())) 
[10:24:16.377]             setwd(...future.workdir)
[10:24:16.377]         {
[10:24:16.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.377]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.377]             }
[10:24:16.377]             base::options(...future.oldOptions)
[10:24:16.377]             if (.Platform$OS.type == "windows") {
[10:24:16.377]                 old_names <- names(...future.oldEnvVars)
[10:24:16.377]                 envs <- base::Sys.getenv()
[10:24:16.377]                 names <- names(envs)
[10:24:16.377]                 common <- intersect(names, old_names)
[10:24:16.377]                 added <- setdiff(names, old_names)
[10:24:16.377]                 removed <- setdiff(old_names, names)
[10:24:16.377]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.377]                   envs[common]]
[10:24:16.377]                 NAMES <- toupper(changed)
[10:24:16.377]                 args <- list()
[10:24:16.377]                 for (kk in seq_along(NAMES)) {
[10:24:16.377]                   name <- changed[[kk]]
[10:24:16.377]                   NAME <- NAMES[[kk]]
[10:24:16.377]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.377]                     next
[10:24:16.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.377]                 }
[10:24:16.377]                 NAMES <- toupper(added)
[10:24:16.377]                 for (kk in seq_along(NAMES)) {
[10:24:16.377]                   name <- added[[kk]]
[10:24:16.377]                   NAME <- NAMES[[kk]]
[10:24:16.377]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.377]                     next
[10:24:16.377]                   args[[name]] <- ""
[10:24:16.377]                 }
[10:24:16.377]                 NAMES <- toupper(removed)
[10:24:16.377]                 for (kk in seq_along(NAMES)) {
[10:24:16.377]                   name <- removed[[kk]]
[10:24:16.377]                   NAME <- NAMES[[kk]]
[10:24:16.377]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.377]                     next
[10:24:16.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.377]                 }
[10:24:16.377]                 if (length(args) > 0) 
[10:24:16.377]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.377]             }
[10:24:16.377]             else {
[10:24:16.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.377]             }
[10:24:16.377]             {
[10:24:16.377]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.377]                   0L) {
[10:24:16.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.377]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.377]                   base::options(opts)
[10:24:16.377]                 }
[10:24:16.377]                 {
[10:24:16.377]                   {
[10:24:16.377]                     NULL
[10:24:16.377]                     RNGkind("Mersenne-Twister")
[10:24:16.377]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.377]                       inherits = FALSE)
[10:24:16.377]                   }
[10:24:16.377]                   options(future.plan = NULL)
[10:24:16.377]                   if (is.na(NA_character_)) 
[10:24:16.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.377]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.377]                   {
[10:24:16.377]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.377]                     if (!future$lazy) 
[10:24:16.377]                       future <- run(future)
[10:24:16.377]                     invisible(future)
[10:24:16.377]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.377]                 }
[10:24:16.377]             }
[10:24:16.377]         }
[10:24:16.377]     })
[10:24:16.377]     if (TRUE) {
[10:24:16.377]         base::sink(type = "output", split = FALSE)
[10:24:16.377]         if (TRUE) {
[10:24:16.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.377]         }
[10:24:16.377]         else {
[10:24:16.377]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.377]         }
[10:24:16.377]         base::close(...future.stdout)
[10:24:16.377]         ...future.stdout <- NULL
[10:24:16.377]     }
[10:24:16.377]     ...future.result$conditions <- ...future.conditions
[10:24:16.377]     ...future.result$finished <- base::Sys.time()
[10:24:16.377]     ...future.result
[10:24:16.377] }
[10:24:16.379] assign_globals() ...
[10:24:16.379] List of 11
[10:24:16.379]  $ ...future.FUN            :function (x, ...)  
[10:24:16.379]  $ x_FUN                    :function (x)  
[10:24:16.379]  $ times                    : int 2
[10:24:16.379]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.379]  $ stop_if_not              :function (...)  
[10:24:16.379]  $ dim                      : NULL
[10:24:16.379]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:16.379]  $ future.call.arguments    : list()
[10:24:16.379]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.379]  $ ...future.elements_ii    :List of 10
[10:24:16.379]   ..$ : int 1
[10:24:16.379]   ..$ : int 2
[10:24:16.379]   ..$ : int 3
[10:24:16.379]   ..$ : int 4
[10:24:16.379]   ..$ : int 5
[10:24:16.379]   ..$ : int 6
[10:24:16.379]   ..$ : int 7
[10:24:16.379]   ..$ : int 8
[10:24:16.379]   ..$ : int 9
[10:24:16.379]   ..$ : int 10
[10:24:16.379]  $ ...future.seeds_ii       : NULL
[10:24:16.379]  $ ...future.globals.maxSize: NULL
[10:24:16.379]  - attr(*, "where")=List of 11
[10:24:16.379]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.379]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.379]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.379]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.379]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.379]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.379]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.379]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.379]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.379]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.379]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.379]  - attr(*, "resolved")= logi FALSE
[10:24:16.379]  - attr(*, "total_size")= num 96456
[10:24:16.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.379]  - attr(*, "already-done")= logi TRUE
[10:24:16.389] - copied ‘...future.FUN’ to environment
[10:24:16.389] - reassign environment for ‘x_FUN’
[10:24:16.389] - copied ‘x_FUN’ to environment
[10:24:16.389] - copied ‘times’ to environment
[10:24:16.389] - copied ‘stopf’ to environment
[10:24:16.390] - copied ‘stop_if_not’ to environment
[10:24:16.390] - copied ‘dim’ to environment
[10:24:16.390] - copied ‘valid_types’ to environment
[10:24:16.390] - copied ‘future.call.arguments’ to environment
[10:24:16.390] - copied ‘...future.elements_ii’ to environment
[10:24:16.390] - copied ‘...future.seeds_ii’ to environment
[10:24:16.390] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.390] assign_globals() ... done
[10:24:16.391] plan(): Setting new future strategy stack:
[10:24:16.391] List of future strategies:
[10:24:16.391] 1. sequential:
[10:24:16.391]    - args: function (..., envir = parent.frame())
[10:24:16.391]    - tweaked: FALSE
[10:24:16.391]    - call: NULL
[10:24:16.391] plan(): nbrOfWorkers() = 1
[10:24:16.392] plan(): Setting new future strategy stack:
[10:24:16.392] List of future strategies:
[10:24:16.392] 1. sequential:
[10:24:16.392]    - args: function (..., envir = parent.frame())
[10:24:16.392]    - tweaked: FALSE
[10:24:16.392]    - call: plan(strategy)
[10:24:16.392] plan(): nbrOfWorkers() = 1
[10:24:16.392] SequentialFuture started (and completed)
[10:24:16.392] - Launch lazy future ... done
[10:24:16.392] run() for ‘SequentialFuture’ ... done
[10:24:16.393] Created future:
[10:24:16.393] SequentialFuture:
[10:24:16.393] Label: ‘future_vapply-1’
[10:24:16.393] Expression:
[10:24:16.393] {
[10:24:16.393]     do.call(function(...) {
[10:24:16.393]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.393]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.393]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.393]             on.exit(options(oopts), add = TRUE)
[10:24:16.393]         }
[10:24:16.393]         {
[10:24:16.393]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.393]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.393]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.393]             })
[10:24:16.393]         }
[10:24:16.393]     }, args = future.call.arguments)
[10:24:16.393] }
[10:24:16.393] Lazy evaluation: FALSE
[10:24:16.393] Asynchronous evaluation: FALSE
[10:24:16.393] Local evaluation: TRUE
[10:24:16.393] Environment: R_GlobalEnv
[10:24:16.393] Capture standard output: TRUE
[10:24:16.393] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.393] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.393] Packages: 1 packages (‘future.apply’)
[10:24:16.393] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.393] Resolved: TRUE
[10:24:16.393] Value: 640 bytes of class ‘list’
[10:24:16.393] Early signaling: FALSE
[10:24:16.393] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.393] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.394] Chunk #1 of 1 ... DONE
[10:24:16.394] Launching 1 futures (chunks) ... DONE
[10:24:16.394] Resolving 1 futures (chunks) ...
[10:24:16.394] resolve() on list ...
[10:24:16.394]  recursive: 0
[10:24:16.394]  length: 1
[10:24:16.394] 
[10:24:16.394] resolved() for ‘SequentialFuture’ ...
[10:24:16.395] - state: ‘finished’
[10:24:16.395] - run: TRUE
[10:24:16.395] - result: ‘FutureResult’
[10:24:16.395] resolved() for ‘SequentialFuture’ ... done
[10:24:16.395] Future #1
[10:24:16.395] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.395] - nx: 1
[10:24:16.395] - relay: TRUE
[10:24:16.395] - stdout: TRUE
[10:24:16.395] - signal: TRUE
[10:24:16.395] - resignal: FALSE
[10:24:16.395] - force: TRUE
[10:24:16.396] - relayed: [n=1] FALSE
[10:24:16.396] - queued futures: [n=1] FALSE
[10:24:16.396]  - until=1
[10:24:16.396]  - relaying element #1
[10:24:16.396] - relayed: [n=1] TRUE
[10:24:16.396] - queued futures: [n=1] TRUE
[10:24:16.396] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.396]  length: 0 (resolved future 1)
[10:24:16.396] Relaying remaining futures
[10:24:16.396] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.397] - nx: 1
[10:24:16.397] - relay: TRUE
[10:24:16.397] - stdout: TRUE
[10:24:16.397] - signal: TRUE
[10:24:16.397] - resignal: FALSE
[10:24:16.397] - force: TRUE
[10:24:16.397] - relayed: [n=1] TRUE
[10:24:16.397] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.397] - relayed: [n=1] TRUE
[10:24:16.397] - queued futures: [n=1] TRUE
[10:24:16.397] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.398] resolve() on list ... DONE
[10:24:16.398]  - Number of value chunks collected: 1
[10:24:16.398] Resolving 1 futures (chunks) ... DONE
[10:24:16.398] Reducing values from 1 chunks ...
[10:24:16.398]  - Number of values collected after concatenation: 10
[10:24:16.398]  - Number of values expected: 10
[10:24:16.398] Reducing values from 1 chunks ... DONE
[10:24:16.398] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:24:16.399] future_lapply() ...
[10:24:16.402] Number of chunks: 1
[10:24:16.402] getGlobalsAndPackagesXApply() ...
[10:24:16.402]  - future.globals: TRUE
[10:24:16.402] getGlobalsAndPackages() ...
[10:24:16.402] Searching for globals...
[10:24:16.405] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:24:16.405] Searching for globals ... DONE
[10:24:16.405] Resolving globals: FALSE
[10:24:16.406] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[10:24:16.407] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.407] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.407] - packages: [1] ‘future.apply’
[10:24:16.407] getGlobalsAndPackages() ... DONE
[10:24:16.407]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.407]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.407] Finding globals ... DONE
[10:24:16.407]  - use_args: TRUE
[10:24:16.407]  - Getting '...' globals ...
[10:24:16.408] resolve() on list ...
[10:24:16.408]  recursive: 0
[10:24:16.408]  length: 1
[10:24:16.408]  elements: ‘...’
[10:24:16.408]  length: 0 (resolved future 1)
[10:24:16.408] resolve() on list ... DONE
[10:24:16.408]    - '...' content: [n=0] 
[10:24:16.408] List of 1
[10:24:16.408]  $ ...: list()
[10:24:16.408]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.408]  - attr(*, "where")=List of 1
[10:24:16.408]   ..$ ...:<environment: 0x55b93d2c2040> 
[10:24:16.408]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.408]  - attr(*, "resolved")= logi TRUE
[10:24:16.408]  - attr(*, "total_size")= num NA
[10:24:16.411]  - Getting '...' globals ... DONE
[10:24:16.411] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.411] List of 8
[10:24:16.411]  $ ...future.FUN:function (x, ...)  
[10:24:16.411]  $ x_FUN        :function (x)  
[10:24:16.411]  $ times        : int 4
[10:24:16.411]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.411]  $ stop_if_not  :function (...)  
[10:24:16.411]  $ dim          : int [1:2] 2 2
[10:24:16.411]  $ valid_types  : chr [1:2] "logical" "integer"
[10:24:16.411]  $ ...          : list()
[10:24:16.411]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.411]  - attr(*, "where")=List of 8
[10:24:16.411]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.411]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.411]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.411]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.411]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.411]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.411]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.411]   ..$ ...          :<environment: 0x55b93d2c2040> 
[10:24:16.411]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.411]  - attr(*, "resolved")= logi FALSE
[10:24:16.411]  - attr(*, "total_size")= num 97232
[10:24:16.416] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.416] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.417] Number of futures (= number of chunks): 1
[10:24:16.417] Launching 1 futures (chunks) ...
[10:24:16.417] Chunk #1 of 1 ...
[10:24:16.417]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.417] getGlobalsAndPackages() ...
[10:24:16.417] Searching for globals...
[10:24:16.417] 
[10:24:16.417] Searching for globals ... DONE
[10:24:16.417] - globals: [0] <none>
[10:24:16.418] getGlobalsAndPackages() ... DONE
[10:24:16.418]    + additional globals found: [n=0] 
[10:24:16.418]    + additional namespaces needed: [n=0] 
[10:24:16.418]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.418]  - seeds: <none>
[10:24:16.418]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.418] getGlobalsAndPackages() ...
[10:24:16.418] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.419] Resolving globals: FALSE
[10:24:16.419] Tweak future expression to call with '...' arguments ...
[10:24:16.419] {
[10:24:16.419]     do.call(function(...) {
[10:24:16.419]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.419]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.419]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.419]             on.exit(options(oopts), add = TRUE)
[10:24:16.419]         }
[10:24:16.419]         {
[10:24:16.419]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.419]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.419]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.419]             })
[10:24:16.419]         }
[10:24:16.419]     }, args = future.call.arguments)
[10:24:16.419] }
[10:24:16.420] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.420] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.420] - packages: [1] ‘future.apply’
[10:24:16.420] getGlobalsAndPackages() ... DONE
[10:24:16.421] run() for ‘Future’ ...
[10:24:16.421] - state: ‘created’
[10:24:16.421] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.421] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.421] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.421]   - Field: ‘label’
[10:24:16.421]   - Field: ‘local’
[10:24:16.421]   - Field: ‘owner’
[10:24:16.422]   - Field: ‘envir’
[10:24:16.422]   - Field: ‘packages’
[10:24:16.422]   - Field: ‘gc’
[10:24:16.422]   - Field: ‘conditions’
[10:24:16.422]   - Field: ‘expr’
[10:24:16.422]   - Field: ‘uuid’
[10:24:16.422]   - Field: ‘seed’
[10:24:16.422]   - Field: ‘version’
[10:24:16.422]   - Field: ‘result’
[10:24:16.422]   - Field: ‘asynchronous’
[10:24:16.423]   - Field: ‘calls’
[10:24:16.423]   - Field: ‘globals’
[10:24:16.423]   - Field: ‘stdout’
[10:24:16.423]   - Field: ‘earlySignal’
[10:24:16.423]   - Field: ‘lazy’
[10:24:16.423]   - Field: ‘state’
[10:24:16.423] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.423] - Launch lazy future ...
[10:24:16.423] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.423] Packages needed by future strategies (n = 0): <none>
[10:24:16.424] {
[10:24:16.424]     {
[10:24:16.424]         {
[10:24:16.424]             ...future.startTime <- base::Sys.time()
[10:24:16.424]             {
[10:24:16.424]                 {
[10:24:16.424]                   {
[10:24:16.424]                     {
[10:24:16.424]                       base::local({
[10:24:16.424]                         has_future <- base::requireNamespace("future", 
[10:24:16.424]                           quietly = TRUE)
[10:24:16.424]                         if (has_future) {
[10:24:16.424]                           ns <- base::getNamespace("future")
[10:24:16.424]                           version <- ns[[".package"]][["version"]]
[10:24:16.424]                           if (is.null(version)) 
[10:24:16.424]                             version <- utils::packageVersion("future")
[10:24:16.424]                         }
[10:24:16.424]                         else {
[10:24:16.424]                           version <- NULL
[10:24:16.424]                         }
[10:24:16.424]                         if (!has_future || version < "1.8.0") {
[10:24:16.424]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.424]                             "", base::R.version$version.string), 
[10:24:16.424]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.424]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.424]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.424]                               "release", "version")], collapse = " "), 
[10:24:16.424]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.424]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.424]                             info)
[10:24:16.424]                           info <- base::paste(info, collapse = "; ")
[10:24:16.424]                           if (!has_future) {
[10:24:16.424]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.424]                               info)
[10:24:16.424]                           }
[10:24:16.424]                           else {
[10:24:16.424]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.424]                               info, version)
[10:24:16.424]                           }
[10:24:16.424]                           base::stop(msg)
[10:24:16.424]                         }
[10:24:16.424]                       })
[10:24:16.424]                     }
[10:24:16.424]                     base::local({
[10:24:16.424]                       for (pkg in "future.apply") {
[10:24:16.424]                         base::loadNamespace(pkg)
[10:24:16.424]                         base::library(pkg, character.only = TRUE)
[10:24:16.424]                       }
[10:24:16.424]                     })
[10:24:16.424]                   }
[10:24:16.424]                   options(future.plan = NULL)
[10:24:16.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.424]                 }
[10:24:16.424]                 ...future.workdir <- getwd()
[10:24:16.424]             }
[10:24:16.424]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.424]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.424]         }
[10:24:16.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.424]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.424]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.424]             base::names(...future.oldOptions))
[10:24:16.424]     }
[10:24:16.424]     if (FALSE) {
[10:24:16.424]     }
[10:24:16.424]     else {
[10:24:16.424]         if (TRUE) {
[10:24:16.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.424]                 open = "w")
[10:24:16.424]         }
[10:24:16.424]         else {
[10:24:16.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.424]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.424]         }
[10:24:16.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.424]             base::sink(type = "output", split = FALSE)
[10:24:16.424]             base::close(...future.stdout)
[10:24:16.424]         }, add = TRUE)
[10:24:16.424]     }
[10:24:16.424]     ...future.frame <- base::sys.nframe()
[10:24:16.424]     ...future.conditions <- base::list()
[10:24:16.424]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.424]     if (FALSE) {
[10:24:16.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.424]     }
[10:24:16.424]     ...future.result <- base::tryCatch({
[10:24:16.424]         base::withCallingHandlers({
[10:24:16.424]             ...future.value <- base::withVisible(base::local({
[10:24:16.424]                 do.call(function(...) {
[10:24:16.424]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.424]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.424]                     ...future.globals.maxSize)) {
[10:24:16.424]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.424]                     on.exit(options(oopts), add = TRUE)
[10:24:16.424]                   }
[10:24:16.424]                   {
[10:24:16.424]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.424]                       FUN = function(jj) {
[10:24:16.424]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.424]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.424]                       })
[10:24:16.424]                   }
[10:24:16.424]                 }, args = future.call.arguments)
[10:24:16.424]             }))
[10:24:16.424]             future::FutureResult(value = ...future.value$value, 
[10:24:16.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.424]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.424]                     ...future.globalenv.names))
[10:24:16.424]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.424]         }, condition = base::local({
[10:24:16.424]             c <- base::c
[10:24:16.424]             inherits <- base::inherits
[10:24:16.424]             invokeRestart <- base::invokeRestart
[10:24:16.424]             length <- base::length
[10:24:16.424]             list <- base::list
[10:24:16.424]             seq.int <- base::seq.int
[10:24:16.424]             signalCondition <- base::signalCondition
[10:24:16.424]             sys.calls <- base::sys.calls
[10:24:16.424]             `[[` <- base::`[[`
[10:24:16.424]             `+` <- base::`+`
[10:24:16.424]             `<<-` <- base::`<<-`
[10:24:16.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.424]                   3L)]
[10:24:16.424]             }
[10:24:16.424]             function(cond) {
[10:24:16.424]                 is_error <- inherits(cond, "error")
[10:24:16.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.424]                   NULL)
[10:24:16.424]                 if (is_error) {
[10:24:16.424]                   sessionInformation <- function() {
[10:24:16.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.424]                       search = base::search(), system = base::Sys.info())
[10:24:16.424]                   }
[10:24:16.424]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.424]                     cond$call), session = sessionInformation(), 
[10:24:16.424]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.424]                   signalCondition(cond)
[10:24:16.424]                 }
[10:24:16.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.424]                 "immediateCondition"))) {
[10:24:16.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.424]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.424]                   if (TRUE && !signal) {
[10:24:16.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.424]                     {
[10:24:16.424]                       inherits <- base::inherits
[10:24:16.424]                       invokeRestart <- base::invokeRestart
[10:24:16.424]                       is.null <- base::is.null
[10:24:16.424]                       muffled <- FALSE
[10:24:16.424]                       if (inherits(cond, "message")) {
[10:24:16.424]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.424]                         if (muffled) 
[10:24:16.424]                           invokeRestart("muffleMessage")
[10:24:16.424]                       }
[10:24:16.424]                       else if (inherits(cond, "warning")) {
[10:24:16.424]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.424]                         if (muffled) 
[10:24:16.424]                           invokeRestart("muffleWarning")
[10:24:16.424]                       }
[10:24:16.424]                       else if (inherits(cond, "condition")) {
[10:24:16.424]                         if (!is.null(pattern)) {
[10:24:16.424]                           computeRestarts <- base::computeRestarts
[10:24:16.424]                           grepl <- base::grepl
[10:24:16.424]                           restarts <- computeRestarts(cond)
[10:24:16.424]                           for (restart in restarts) {
[10:24:16.424]                             name <- restart$name
[10:24:16.424]                             if (is.null(name)) 
[10:24:16.424]                               next
[10:24:16.424]                             if (!grepl(pattern, name)) 
[10:24:16.424]                               next
[10:24:16.424]                             invokeRestart(restart)
[10:24:16.424]                             muffled <- TRUE
[10:24:16.424]                             break
[10:24:16.424]                           }
[10:24:16.424]                         }
[10:24:16.424]                       }
[10:24:16.424]                       invisible(muffled)
[10:24:16.424]                     }
[10:24:16.424]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.424]                   }
[10:24:16.424]                 }
[10:24:16.424]                 else {
[10:24:16.424]                   if (TRUE) {
[10:24:16.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.424]                     {
[10:24:16.424]                       inherits <- base::inherits
[10:24:16.424]                       invokeRestart <- base::invokeRestart
[10:24:16.424]                       is.null <- base::is.null
[10:24:16.424]                       muffled <- FALSE
[10:24:16.424]                       if (inherits(cond, "message")) {
[10:24:16.424]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.424]                         if (muffled) 
[10:24:16.424]                           invokeRestart("muffleMessage")
[10:24:16.424]                       }
[10:24:16.424]                       else if (inherits(cond, "warning")) {
[10:24:16.424]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.424]                         if (muffled) 
[10:24:16.424]                           invokeRestart("muffleWarning")
[10:24:16.424]                       }
[10:24:16.424]                       else if (inherits(cond, "condition")) {
[10:24:16.424]                         if (!is.null(pattern)) {
[10:24:16.424]                           computeRestarts <- base::computeRestarts
[10:24:16.424]                           grepl <- base::grepl
[10:24:16.424]                           restarts <- computeRestarts(cond)
[10:24:16.424]                           for (restart in restarts) {
[10:24:16.424]                             name <- restart$name
[10:24:16.424]                             if (is.null(name)) 
[10:24:16.424]                               next
[10:24:16.424]                             if (!grepl(pattern, name)) 
[10:24:16.424]                               next
[10:24:16.424]                             invokeRestart(restart)
[10:24:16.424]                             muffled <- TRUE
[10:24:16.424]                             break
[10:24:16.424]                           }
[10:24:16.424]                         }
[10:24:16.424]                       }
[10:24:16.424]                       invisible(muffled)
[10:24:16.424]                     }
[10:24:16.424]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.424]                   }
[10:24:16.424]                 }
[10:24:16.424]             }
[10:24:16.424]         }))
[10:24:16.424]     }, error = function(ex) {
[10:24:16.424]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.424]                 ...future.rng), started = ...future.startTime, 
[10:24:16.424]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.424]             version = "1.8"), class = "FutureResult")
[10:24:16.424]     }, finally = {
[10:24:16.424]         if (!identical(...future.workdir, getwd())) 
[10:24:16.424]             setwd(...future.workdir)
[10:24:16.424]         {
[10:24:16.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.424]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.424]             }
[10:24:16.424]             base::options(...future.oldOptions)
[10:24:16.424]             if (.Platform$OS.type == "windows") {
[10:24:16.424]                 old_names <- names(...future.oldEnvVars)
[10:24:16.424]                 envs <- base::Sys.getenv()
[10:24:16.424]                 names <- names(envs)
[10:24:16.424]                 common <- intersect(names, old_names)
[10:24:16.424]                 added <- setdiff(names, old_names)
[10:24:16.424]                 removed <- setdiff(old_names, names)
[10:24:16.424]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.424]                   envs[common]]
[10:24:16.424]                 NAMES <- toupper(changed)
[10:24:16.424]                 args <- list()
[10:24:16.424]                 for (kk in seq_along(NAMES)) {
[10:24:16.424]                   name <- changed[[kk]]
[10:24:16.424]                   NAME <- NAMES[[kk]]
[10:24:16.424]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.424]                     next
[10:24:16.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.424]                 }
[10:24:16.424]                 NAMES <- toupper(added)
[10:24:16.424]                 for (kk in seq_along(NAMES)) {
[10:24:16.424]                   name <- added[[kk]]
[10:24:16.424]                   NAME <- NAMES[[kk]]
[10:24:16.424]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.424]                     next
[10:24:16.424]                   args[[name]] <- ""
[10:24:16.424]                 }
[10:24:16.424]                 NAMES <- toupper(removed)
[10:24:16.424]                 for (kk in seq_along(NAMES)) {
[10:24:16.424]                   name <- removed[[kk]]
[10:24:16.424]                   NAME <- NAMES[[kk]]
[10:24:16.424]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.424]                     next
[10:24:16.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.424]                 }
[10:24:16.424]                 if (length(args) > 0) 
[10:24:16.424]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.424]             }
[10:24:16.424]             else {
[10:24:16.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.424]             }
[10:24:16.424]             {
[10:24:16.424]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.424]                   0L) {
[10:24:16.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.424]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.424]                   base::options(opts)
[10:24:16.424]                 }
[10:24:16.424]                 {
[10:24:16.424]                   {
[10:24:16.424]                     NULL
[10:24:16.424]                     RNGkind("Mersenne-Twister")
[10:24:16.424]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.424]                       inherits = FALSE)
[10:24:16.424]                   }
[10:24:16.424]                   options(future.plan = NULL)
[10:24:16.424]                   if (is.na(NA_character_)) 
[10:24:16.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.424]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.424]                   {
[10:24:16.424]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.424]                     if (!future$lazy) 
[10:24:16.424]                       future <- run(future)
[10:24:16.424]                     invisible(future)
[10:24:16.424]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.424]                 }
[10:24:16.424]             }
[10:24:16.424]         }
[10:24:16.424]     })
[10:24:16.424]     if (TRUE) {
[10:24:16.424]         base::sink(type = "output", split = FALSE)
[10:24:16.424]         if (TRUE) {
[10:24:16.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.424]         }
[10:24:16.424]         else {
[10:24:16.424]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.424]         }
[10:24:16.424]         base::close(...future.stdout)
[10:24:16.424]         ...future.stdout <- NULL
[10:24:16.424]     }
[10:24:16.424]     ...future.result$conditions <- ...future.conditions
[10:24:16.424]     ...future.result$finished <- base::Sys.time()
[10:24:16.424]     ...future.result
[10:24:16.424] }
[10:24:16.426] assign_globals() ...
[10:24:16.426] List of 11
[10:24:16.426]  $ ...future.FUN            :function (x, ...)  
[10:24:16.426]  $ x_FUN                    :function (x)  
[10:24:16.426]  $ times                    : int 4
[10:24:16.426]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.426]  $ stop_if_not              :function (...)  
[10:24:16.426]  $ dim                      : int [1:2] 2 2
[10:24:16.426]  $ valid_types              : chr [1:2] "logical" "integer"
[10:24:16.426]  $ future.call.arguments    : list()
[10:24:16.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.426]  $ ...future.elements_ii    :List of 10
[10:24:16.426]   ..$ : int 1
[10:24:16.426]   ..$ : int 2
[10:24:16.426]   ..$ : int 3
[10:24:16.426]   ..$ : int 4
[10:24:16.426]   ..$ : int 5
[10:24:16.426]   ..$ : int 6
[10:24:16.426]   ..$ : int 7
[10:24:16.426]   ..$ : int 8
[10:24:16.426]   ..$ : int 9
[10:24:16.426]   ..$ : int 10
[10:24:16.426]  $ ...future.seeds_ii       : NULL
[10:24:16.426]  $ ...future.globals.maxSize: NULL
[10:24:16.426]  - attr(*, "where")=List of 11
[10:24:16.426]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.426]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.426]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.426]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.426]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.426]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.426]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.426]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.426]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.426]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.426]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.426]  - attr(*, "resolved")= logi FALSE
[10:24:16.426]  - attr(*, "total_size")= num 97232
[10:24:16.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.426]  - attr(*, "already-done")= logi TRUE
[10:24:16.435] - copied ‘...future.FUN’ to environment
[10:24:16.435] - reassign environment for ‘x_FUN’
[10:24:16.435] - copied ‘x_FUN’ to environment
[10:24:16.436] - copied ‘times’ to environment
[10:24:16.436] - copied ‘stopf’ to environment
[10:24:16.436] - copied ‘stop_if_not’ to environment
[10:24:16.436] - copied ‘dim’ to environment
[10:24:16.436] - copied ‘valid_types’ to environment
[10:24:16.436] - copied ‘future.call.arguments’ to environment
[10:24:16.436] - copied ‘...future.elements_ii’ to environment
[10:24:16.436] - copied ‘...future.seeds_ii’ to environment
[10:24:16.436] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.436] assign_globals() ... done
[10:24:16.437] plan(): Setting new future strategy stack:
[10:24:16.437] List of future strategies:
[10:24:16.437] 1. sequential:
[10:24:16.437]    - args: function (..., envir = parent.frame())
[10:24:16.437]    - tweaked: FALSE
[10:24:16.437]    - call: NULL
[10:24:16.437] plan(): nbrOfWorkers() = 1
[10:24:16.438] plan(): Setting new future strategy stack:
[10:24:16.438] List of future strategies:
[10:24:16.438] 1. sequential:
[10:24:16.438]    - args: function (..., envir = parent.frame())
[10:24:16.438]    - tweaked: FALSE
[10:24:16.438]    - call: plan(strategy)
[10:24:16.438] plan(): nbrOfWorkers() = 1
[10:24:16.439] SequentialFuture started (and completed)
[10:24:16.439] - Launch lazy future ... done
[10:24:16.439] run() for ‘SequentialFuture’ ... done
[10:24:16.439] Created future:
[10:24:16.439] SequentialFuture:
[10:24:16.439] Label: ‘future_vapply-1’
[10:24:16.439] Expression:
[10:24:16.439] {
[10:24:16.439]     do.call(function(...) {
[10:24:16.439]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.439]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.439]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.439]             on.exit(options(oopts), add = TRUE)
[10:24:16.439]         }
[10:24:16.439]         {
[10:24:16.439]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.439]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.439]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.439]             })
[10:24:16.439]         }
[10:24:16.439]     }, args = future.call.arguments)
[10:24:16.439] }
[10:24:16.439] Lazy evaluation: FALSE
[10:24:16.439] Asynchronous evaluation: FALSE
[10:24:16.439] Local evaluation: TRUE
[10:24:16.439] Environment: R_GlobalEnv
[10:24:16.439] Capture standard output: TRUE
[10:24:16.439] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.439] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.439] Packages: 1 packages (‘future.apply’)
[10:24:16.439] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.439] Resolved: TRUE
[10:24:16.439] Value: 2.27 KiB of class ‘list’
[10:24:16.439] Early signaling: FALSE
[10:24:16.439] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.439] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.441] Chunk #1 of 1 ... DONE
[10:24:16.441] Launching 1 futures (chunks) ... DONE
[10:24:16.441] Resolving 1 futures (chunks) ...
[10:24:16.442] resolve() on list ...
[10:24:16.442]  recursive: 0
[10:24:16.442]  length: 1
[10:24:16.442] 
[10:24:16.442] resolved() for ‘SequentialFuture’ ...
[10:24:16.442] - state: ‘finished’
[10:24:16.442] - run: TRUE
[10:24:16.442] - result: ‘FutureResult’
[10:24:16.442] resolved() for ‘SequentialFuture’ ... done
[10:24:16.442] Future #1
[10:24:16.442] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.443] - nx: 1
[10:24:16.443] - relay: TRUE
[10:24:16.443] - stdout: TRUE
[10:24:16.443] - signal: TRUE
[10:24:16.443] - resignal: FALSE
[10:24:16.443] - force: TRUE
[10:24:16.443] - relayed: [n=1] FALSE
[10:24:16.443] - queued futures: [n=1] FALSE
[10:24:16.443]  - until=1
[10:24:16.443]  - relaying element #1
[10:24:16.443] - relayed: [n=1] TRUE
[10:24:16.444] - queued futures: [n=1] TRUE
[10:24:16.444] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.444]  length: 0 (resolved future 1)
[10:24:16.444] Relaying remaining futures
[10:24:16.444] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.444] - nx: 1
[10:24:16.444] - relay: TRUE
[10:24:16.444] - stdout: TRUE
[10:24:16.444] - signal: TRUE
[10:24:16.444] - resignal: FALSE
[10:24:16.444] - force: TRUE
[10:24:16.444] - relayed: [n=1] TRUE
[10:24:16.445] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.445] - relayed: [n=1] TRUE
[10:24:16.445] - queued futures: [n=1] TRUE
[10:24:16.445] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.445] resolve() on list ... DONE
[10:24:16.445]  - Number of value chunks collected: 1
[10:24:16.445] Resolving 1 futures (chunks) ... DONE
[10:24:16.445] Reducing values from 1 chunks ...
[10:24:16.445]  - Number of values collected after concatenation: 10
[10:24:16.445]  - Number of values expected: 10
[10:24:16.446] Reducing values from 1 chunks ... DONE
[10:24:16.446] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:24:16.446] future_lapply() ...
[10:24:16.448] Number of chunks: 1
[10:24:16.448] getGlobalsAndPackagesXApply() ...
[10:24:16.448]  - future.globals: TRUE
[10:24:16.448] getGlobalsAndPackages() ...
[10:24:16.448] Searching for globals...
[10:24:16.452] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:24:16.452] Searching for globals ... DONE
[10:24:16.452] Resolving globals: FALSE
[10:24:16.453] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[10:24:16.453] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.453] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.453] - packages: [1] ‘future.apply’
[10:24:16.453] getGlobalsAndPackages() ... DONE
[10:24:16.453]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.454]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.454] Finding globals ... DONE
[10:24:16.454]  - use_args: TRUE
[10:24:16.454]  - Getting '...' globals ...
[10:24:16.454] resolve() on list ...
[10:24:16.454]  recursive: 0
[10:24:16.454]  length: 1
[10:24:16.454]  elements: ‘...’
[10:24:16.454]  length: 0 (resolved future 1)
[10:24:16.455] resolve() on list ... DONE
[10:24:16.455]    - '...' content: [n=0] 
[10:24:16.455] List of 1
[10:24:16.455]  $ ...: list()
[10:24:16.455]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.455]  - attr(*, "where")=List of 1
[10:24:16.455]   ..$ ...:<environment: 0x55b93b6a3358> 
[10:24:16.455]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.455]  - attr(*, "resolved")= logi TRUE
[10:24:16.455]  - attr(*, "total_size")= num NA
[10:24:16.457]  - Getting '...' globals ... DONE
[10:24:16.457] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.457] List of 8
[10:24:16.457]  $ ...future.FUN:function (x, ...)  
[10:24:16.457]  $ x_FUN        :function (x)  
[10:24:16.457]  $ times        : int 4
[10:24:16.457]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.457]  $ stop_if_not  :function (...)  
[10:24:16.457]  $ dim          : int [1:2] 2 2
[10:24:16.457]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:16.457]  $ ...          : list()
[10:24:16.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.457]  - attr(*, "where")=List of 8
[10:24:16.457]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.457]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.457]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.457]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.457]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.457]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.457]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.457]   ..$ ...          :<environment: 0x55b93b6a3358> 
[10:24:16.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.457]  - attr(*, "resolved")= logi FALSE
[10:24:16.457]  - attr(*, "total_size")= num 97304
[10:24:16.463] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.464] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.464] Number of futures (= number of chunks): 1
[10:24:16.464] Launching 1 futures (chunks) ...
[10:24:16.464] Chunk #1 of 1 ...
[10:24:16.464]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.464] getGlobalsAndPackages() ...
[10:24:16.464] Searching for globals...
[10:24:16.464] 
[10:24:16.465] Searching for globals ... DONE
[10:24:16.465] - globals: [0] <none>
[10:24:16.465] getGlobalsAndPackages() ... DONE
[10:24:16.465]    + additional globals found: [n=0] 
[10:24:16.465]    + additional namespaces needed: [n=0] 
[10:24:16.465]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.465]  - seeds: <none>
[10:24:16.465]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.465] getGlobalsAndPackages() ...
[10:24:16.465] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.465] Resolving globals: FALSE
[10:24:16.466] Tweak future expression to call with '...' arguments ...
[10:24:16.466] {
[10:24:16.466]     do.call(function(...) {
[10:24:16.466]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.466]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.466]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.466]             on.exit(options(oopts), add = TRUE)
[10:24:16.466]         }
[10:24:16.466]         {
[10:24:16.466]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.466]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.466]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.466]             })
[10:24:16.466]         }
[10:24:16.466]     }, args = future.call.arguments)
[10:24:16.466] }
[10:24:16.466] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.466] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.466] - packages: [1] ‘future.apply’
[10:24:16.467] getGlobalsAndPackages() ... DONE
[10:24:16.467] run() for ‘Future’ ...
[10:24:16.467] - state: ‘created’
[10:24:16.467] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.467] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.467] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.468]   - Field: ‘label’
[10:24:16.468]   - Field: ‘local’
[10:24:16.468]   - Field: ‘owner’
[10:24:16.468]   - Field: ‘envir’
[10:24:16.468]   - Field: ‘packages’
[10:24:16.468]   - Field: ‘gc’
[10:24:16.468]   - Field: ‘conditions’
[10:24:16.468]   - Field: ‘expr’
[10:24:16.468]   - Field: ‘uuid’
[10:24:16.468]   - Field: ‘seed’
[10:24:16.468]   - Field: ‘version’
[10:24:16.469]   - Field: ‘result’
[10:24:16.469]   - Field: ‘asynchronous’
[10:24:16.469]   - Field: ‘calls’
[10:24:16.469]   - Field: ‘globals’
[10:24:16.469]   - Field: ‘stdout’
[10:24:16.469]   - Field: ‘earlySignal’
[10:24:16.469]   - Field: ‘lazy’
[10:24:16.469]   - Field: ‘state’
[10:24:16.469] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.469] - Launch lazy future ...
[10:24:16.469] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.470] Packages needed by future strategies (n = 0): <none>
[10:24:16.470] {
[10:24:16.470]     {
[10:24:16.470]         {
[10:24:16.470]             ...future.startTime <- base::Sys.time()
[10:24:16.470]             {
[10:24:16.470]                 {
[10:24:16.470]                   {
[10:24:16.470]                     {
[10:24:16.470]                       base::local({
[10:24:16.470]                         has_future <- base::requireNamespace("future", 
[10:24:16.470]                           quietly = TRUE)
[10:24:16.470]                         if (has_future) {
[10:24:16.470]                           ns <- base::getNamespace("future")
[10:24:16.470]                           version <- ns[[".package"]][["version"]]
[10:24:16.470]                           if (is.null(version)) 
[10:24:16.470]                             version <- utils::packageVersion("future")
[10:24:16.470]                         }
[10:24:16.470]                         else {
[10:24:16.470]                           version <- NULL
[10:24:16.470]                         }
[10:24:16.470]                         if (!has_future || version < "1.8.0") {
[10:24:16.470]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.470]                             "", base::R.version$version.string), 
[10:24:16.470]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.470]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.470]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.470]                               "release", "version")], collapse = " "), 
[10:24:16.470]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.470]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.470]                             info)
[10:24:16.470]                           info <- base::paste(info, collapse = "; ")
[10:24:16.470]                           if (!has_future) {
[10:24:16.470]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.470]                               info)
[10:24:16.470]                           }
[10:24:16.470]                           else {
[10:24:16.470]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.470]                               info, version)
[10:24:16.470]                           }
[10:24:16.470]                           base::stop(msg)
[10:24:16.470]                         }
[10:24:16.470]                       })
[10:24:16.470]                     }
[10:24:16.470]                     base::local({
[10:24:16.470]                       for (pkg in "future.apply") {
[10:24:16.470]                         base::loadNamespace(pkg)
[10:24:16.470]                         base::library(pkg, character.only = TRUE)
[10:24:16.470]                       }
[10:24:16.470]                     })
[10:24:16.470]                   }
[10:24:16.470]                   options(future.plan = NULL)
[10:24:16.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.470]                 }
[10:24:16.470]                 ...future.workdir <- getwd()
[10:24:16.470]             }
[10:24:16.470]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.470]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.470]         }
[10:24:16.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.470]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.470]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.470]             base::names(...future.oldOptions))
[10:24:16.470]     }
[10:24:16.470]     if (FALSE) {
[10:24:16.470]     }
[10:24:16.470]     else {
[10:24:16.470]         if (TRUE) {
[10:24:16.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.470]                 open = "w")
[10:24:16.470]         }
[10:24:16.470]         else {
[10:24:16.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.470]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.470]         }
[10:24:16.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.470]             base::sink(type = "output", split = FALSE)
[10:24:16.470]             base::close(...future.stdout)
[10:24:16.470]         }, add = TRUE)
[10:24:16.470]     }
[10:24:16.470]     ...future.frame <- base::sys.nframe()
[10:24:16.470]     ...future.conditions <- base::list()
[10:24:16.470]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.470]     if (FALSE) {
[10:24:16.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.470]     }
[10:24:16.470]     ...future.result <- base::tryCatch({
[10:24:16.470]         base::withCallingHandlers({
[10:24:16.470]             ...future.value <- base::withVisible(base::local({
[10:24:16.470]                 do.call(function(...) {
[10:24:16.470]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.470]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.470]                     ...future.globals.maxSize)) {
[10:24:16.470]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.470]                     on.exit(options(oopts), add = TRUE)
[10:24:16.470]                   }
[10:24:16.470]                   {
[10:24:16.470]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.470]                       FUN = function(jj) {
[10:24:16.470]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.470]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.470]                       })
[10:24:16.470]                   }
[10:24:16.470]                 }, args = future.call.arguments)
[10:24:16.470]             }))
[10:24:16.470]             future::FutureResult(value = ...future.value$value, 
[10:24:16.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.470]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.470]                     ...future.globalenv.names))
[10:24:16.470]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.470]         }, condition = base::local({
[10:24:16.470]             c <- base::c
[10:24:16.470]             inherits <- base::inherits
[10:24:16.470]             invokeRestart <- base::invokeRestart
[10:24:16.470]             length <- base::length
[10:24:16.470]             list <- base::list
[10:24:16.470]             seq.int <- base::seq.int
[10:24:16.470]             signalCondition <- base::signalCondition
[10:24:16.470]             sys.calls <- base::sys.calls
[10:24:16.470]             `[[` <- base::`[[`
[10:24:16.470]             `+` <- base::`+`
[10:24:16.470]             `<<-` <- base::`<<-`
[10:24:16.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.470]                   3L)]
[10:24:16.470]             }
[10:24:16.470]             function(cond) {
[10:24:16.470]                 is_error <- inherits(cond, "error")
[10:24:16.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.470]                   NULL)
[10:24:16.470]                 if (is_error) {
[10:24:16.470]                   sessionInformation <- function() {
[10:24:16.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.470]                       search = base::search(), system = base::Sys.info())
[10:24:16.470]                   }
[10:24:16.470]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.470]                     cond$call), session = sessionInformation(), 
[10:24:16.470]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.470]                   signalCondition(cond)
[10:24:16.470]                 }
[10:24:16.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.470]                 "immediateCondition"))) {
[10:24:16.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.470]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.470]                   if (TRUE && !signal) {
[10:24:16.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.470]                     {
[10:24:16.470]                       inherits <- base::inherits
[10:24:16.470]                       invokeRestart <- base::invokeRestart
[10:24:16.470]                       is.null <- base::is.null
[10:24:16.470]                       muffled <- FALSE
[10:24:16.470]                       if (inherits(cond, "message")) {
[10:24:16.470]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.470]                         if (muffled) 
[10:24:16.470]                           invokeRestart("muffleMessage")
[10:24:16.470]                       }
[10:24:16.470]                       else if (inherits(cond, "warning")) {
[10:24:16.470]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.470]                         if (muffled) 
[10:24:16.470]                           invokeRestart("muffleWarning")
[10:24:16.470]                       }
[10:24:16.470]                       else if (inherits(cond, "condition")) {
[10:24:16.470]                         if (!is.null(pattern)) {
[10:24:16.470]                           computeRestarts <- base::computeRestarts
[10:24:16.470]                           grepl <- base::grepl
[10:24:16.470]                           restarts <- computeRestarts(cond)
[10:24:16.470]                           for (restart in restarts) {
[10:24:16.470]                             name <- restart$name
[10:24:16.470]                             if (is.null(name)) 
[10:24:16.470]                               next
[10:24:16.470]                             if (!grepl(pattern, name)) 
[10:24:16.470]                               next
[10:24:16.470]                             invokeRestart(restart)
[10:24:16.470]                             muffled <- TRUE
[10:24:16.470]                             break
[10:24:16.470]                           }
[10:24:16.470]                         }
[10:24:16.470]                       }
[10:24:16.470]                       invisible(muffled)
[10:24:16.470]                     }
[10:24:16.470]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.470]                   }
[10:24:16.470]                 }
[10:24:16.470]                 else {
[10:24:16.470]                   if (TRUE) {
[10:24:16.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.470]                     {
[10:24:16.470]                       inherits <- base::inherits
[10:24:16.470]                       invokeRestart <- base::invokeRestart
[10:24:16.470]                       is.null <- base::is.null
[10:24:16.470]                       muffled <- FALSE
[10:24:16.470]                       if (inherits(cond, "message")) {
[10:24:16.470]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.470]                         if (muffled) 
[10:24:16.470]                           invokeRestart("muffleMessage")
[10:24:16.470]                       }
[10:24:16.470]                       else if (inherits(cond, "warning")) {
[10:24:16.470]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.470]                         if (muffled) 
[10:24:16.470]                           invokeRestart("muffleWarning")
[10:24:16.470]                       }
[10:24:16.470]                       else if (inherits(cond, "condition")) {
[10:24:16.470]                         if (!is.null(pattern)) {
[10:24:16.470]                           computeRestarts <- base::computeRestarts
[10:24:16.470]                           grepl <- base::grepl
[10:24:16.470]                           restarts <- computeRestarts(cond)
[10:24:16.470]                           for (restart in restarts) {
[10:24:16.470]                             name <- restart$name
[10:24:16.470]                             if (is.null(name)) 
[10:24:16.470]                               next
[10:24:16.470]                             if (!grepl(pattern, name)) 
[10:24:16.470]                               next
[10:24:16.470]                             invokeRestart(restart)
[10:24:16.470]                             muffled <- TRUE
[10:24:16.470]                             break
[10:24:16.470]                           }
[10:24:16.470]                         }
[10:24:16.470]                       }
[10:24:16.470]                       invisible(muffled)
[10:24:16.470]                     }
[10:24:16.470]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.470]                   }
[10:24:16.470]                 }
[10:24:16.470]             }
[10:24:16.470]         }))
[10:24:16.470]     }, error = function(ex) {
[10:24:16.470]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.470]                 ...future.rng), started = ...future.startTime, 
[10:24:16.470]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.470]             version = "1.8"), class = "FutureResult")
[10:24:16.470]     }, finally = {
[10:24:16.470]         if (!identical(...future.workdir, getwd())) 
[10:24:16.470]             setwd(...future.workdir)
[10:24:16.470]         {
[10:24:16.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.470]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.470]             }
[10:24:16.470]             base::options(...future.oldOptions)
[10:24:16.470]             if (.Platform$OS.type == "windows") {
[10:24:16.470]                 old_names <- names(...future.oldEnvVars)
[10:24:16.470]                 envs <- base::Sys.getenv()
[10:24:16.470]                 names <- names(envs)
[10:24:16.470]                 common <- intersect(names, old_names)
[10:24:16.470]                 added <- setdiff(names, old_names)
[10:24:16.470]                 removed <- setdiff(old_names, names)
[10:24:16.470]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.470]                   envs[common]]
[10:24:16.470]                 NAMES <- toupper(changed)
[10:24:16.470]                 args <- list()
[10:24:16.470]                 for (kk in seq_along(NAMES)) {
[10:24:16.470]                   name <- changed[[kk]]
[10:24:16.470]                   NAME <- NAMES[[kk]]
[10:24:16.470]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.470]                     next
[10:24:16.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.470]                 }
[10:24:16.470]                 NAMES <- toupper(added)
[10:24:16.470]                 for (kk in seq_along(NAMES)) {
[10:24:16.470]                   name <- added[[kk]]
[10:24:16.470]                   NAME <- NAMES[[kk]]
[10:24:16.470]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.470]                     next
[10:24:16.470]                   args[[name]] <- ""
[10:24:16.470]                 }
[10:24:16.470]                 NAMES <- toupper(removed)
[10:24:16.470]                 for (kk in seq_along(NAMES)) {
[10:24:16.470]                   name <- removed[[kk]]
[10:24:16.470]                   NAME <- NAMES[[kk]]
[10:24:16.470]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.470]                     next
[10:24:16.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.470]                 }
[10:24:16.470]                 if (length(args) > 0) 
[10:24:16.470]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.470]             }
[10:24:16.470]             else {
[10:24:16.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.470]             }
[10:24:16.470]             {
[10:24:16.470]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.470]                   0L) {
[10:24:16.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.470]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.470]                   base::options(opts)
[10:24:16.470]                 }
[10:24:16.470]                 {
[10:24:16.470]                   {
[10:24:16.470]                     NULL
[10:24:16.470]                     RNGkind("Mersenne-Twister")
[10:24:16.470]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.470]                       inherits = FALSE)
[10:24:16.470]                   }
[10:24:16.470]                   options(future.plan = NULL)
[10:24:16.470]                   if (is.na(NA_character_)) 
[10:24:16.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.470]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.470]                   {
[10:24:16.470]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.470]                     if (!future$lazy) 
[10:24:16.470]                       future <- run(future)
[10:24:16.470]                     invisible(future)
[10:24:16.470]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.470]                 }
[10:24:16.470]             }
[10:24:16.470]         }
[10:24:16.470]     })
[10:24:16.470]     if (TRUE) {
[10:24:16.470]         base::sink(type = "output", split = FALSE)
[10:24:16.470]         if (TRUE) {
[10:24:16.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.470]         }
[10:24:16.470]         else {
[10:24:16.470]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.470]         }
[10:24:16.470]         base::close(...future.stdout)
[10:24:16.470]         ...future.stdout <- NULL
[10:24:16.470]     }
[10:24:16.470]     ...future.result$conditions <- ...future.conditions
[10:24:16.470]     ...future.result$finished <- base::Sys.time()
[10:24:16.470]     ...future.result
[10:24:16.470] }
[10:24:16.472] assign_globals() ...
[10:24:16.472] List of 11
[10:24:16.472]  $ ...future.FUN            :function (x, ...)  
[10:24:16.472]  $ x_FUN                    :function (x)  
[10:24:16.472]  $ times                    : int 4
[10:24:16.472]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.472]  $ stop_if_not              :function (...)  
[10:24:16.472]  $ dim                      : int [1:2] 2 2
[10:24:16.472]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:16.472]  $ future.call.arguments    : list()
[10:24:16.472]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.472]  $ ...future.elements_ii    :List of 10
[10:24:16.472]   ..$ : int 1
[10:24:16.472]   ..$ : int 2
[10:24:16.472]   ..$ : int 3
[10:24:16.472]   ..$ : int 4
[10:24:16.472]   ..$ : int 5
[10:24:16.472]   ..$ : int 6
[10:24:16.472]   ..$ : int 7
[10:24:16.472]   ..$ : int 8
[10:24:16.472]   ..$ : int 9
[10:24:16.472]   ..$ : int 10
[10:24:16.472]  $ ...future.seeds_ii       : NULL
[10:24:16.472]  $ ...future.globals.maxSize: NULL
[10:24:16.472]  - attr(*, "where")=List of 11
[10:24:16.472]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.472]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.472]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.472]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.472]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.472]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.472]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.472]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.472]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.472]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.472]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.472]  - attr(*, "resolved")= logi FALSE
[10:24:16.472]  - attr(*, "total_size")= num 97304
[10:24:16.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.472]  - attr(*, "already-done")= logi TRUE
[10:24:16.504] - copied ‘...future.FUN’ to environment
[10:24:16.505] - reassign environment for ‘x_FUN’
[10:24:16.505] - copied ‘x_FUN’ to environment
[10:24:16.505] - copied ‘times’ to environment
[10:24:16.505] - copied ‘stopf’ to environment
[10:24:16.505] - copied ‘stop_if_not’ to environment
[10:24:16.505] - copied ‘dim’ to environment
[10:24:16.505] - copied ‘valid_types’ to environment
[10:24:16.505] - copied ‘future.call.arguments’ to environment
[10:24:16.505] - copied ‘...future.elements_ii’ to environment
[10:24:16.505] - copied ‘...future.seeds_ii’ to environment
[10:24:16.506] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.506] assign_globals() ... done
[10:24:16.506] plan(): Setting new future strategy stack:
[10:24:16.506] List of future strategies:
[10:24:16.506] 1. sequential:
[10:24:16.506]    - args: function (..., envir = parent.frame())
[10:24:16.506]    - tweaked: FALSE
[10:24:16.506]    - call: NULL
[10:24:16.506] plan(): nbrOfWorkers() = 1
[10:24:16.507] plan(): Setting new future strategy stack:
[10:24:16.507] List of future strategies:
[10:24:16.507] 1. sequential:
[10:24:16.507]    - args: function (..., envir = parent.frame())
[10:24:16.507]    - tweaked: FALSE
[10:24:16.507]    - call: plan(strategy)
[10:24:16.508] plan(): nbrOfWorkers() = 1
[10:24:16.508] SequentialFuture started (and completed)
[10:24:16.508] - Launch lazy future ... done
[10:24:16.508] run() for ‘SequentialFuture’ ... done
[10:24:16.508] Created future:
[10:24:16.508] SequentialFuture:
[10:24:16.508] Label: ‘future_vapply-1’
[10:24:16.508] Expression:
[10:24:16.508] {
[10:24:16.508]     do.call(function(...) {
[10:24:16.508]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.508]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.508]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.508]             on.exit(options(oopts), add = TRUE)
[10:24:16.508]         }
[10:24:16.508]         {
[10:24:16.508]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.508]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.508]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.508]             })
[10:24:16.508]         }
[10:24:16.508]     }, args = future.call.arguments)
[10:24:16.508] }
[10:24:16.508] Lazy evaluation: FALSE
[10:24:16.508] Asynchronous evaluation: FALSE
[10:24:16.508] Local evaluation: TRUE
[10:24:16.508] Environment: R_GlobalEnv
[10:24:16.508] Capture standard output: TRUE
[10:24:16.508] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.508] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.508] Packages: 1 packages (‘future.apply’)
[10:24:16.508] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.508] Resolved: TRUE
[10:24:16.508] Value: 2.27 KiB of class ‘list’
[10:24:16.508] Early signaling: FALSE
[10:24:16.508] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.508] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.509] Chunk #1 of 1 ... DONE
[10:24:16.510] Launching 1 futures (chunks) ... DONE
[10:24:16.510] Resolving 1 futures (chunks) ...
[10:24:16.510] resolve() on list ...
[10:24:16.510]  recursive: 0
[10:24:16.510]  length: 1
[10:24:16.510] 
[10:24:16.510] resolved() for ‘SequentialFuture’ ...
[10:24:16.510] - state: ‘finished’
[10:24:16.510] - run: TRUE
[10:24:16.510] - result: ‘FutureResult’
[10:24:16.511] resolved() for ‘SequentialFuture’ ... done
[10:24:16.511] Future #1
[10:24:16.511] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.511] - nx: 1
[10:24:16.511] - relay: TRUE
[10:24:16.511] - stdout: TRUE
[10:24:16.511] - signal: TRUE
[10:24:16.511] - resignal: FALSE
[10:24:16.511] - force: TRUE
[10:24:16.511] - relayed: [n=1] FALSE
[10:24:16.511] - queued futures: [n=1] FALSE
[10:24:16.512]  - until=1
[10:24:16.512]  - relaying element #1
[10:24:16.512] - relayed: [n=1] TRUE
[10:24:16.512] - queued futures: [n=1] TRUE
[10:24:16.512] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.512]  length: 0 (resolved future 1)
[10:24:16.512] Relaying remaining futures
[10:24:16.512] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.512] - nx: 1
[10:24:16.512] - relay: TRUE
[10:24:16.513] - stdout: TRUE
[10:24:16.513] - signal: TRUE
[10:24:16.513] - resignal: FALSE
[10:24:16.513] - force: TRUE
[10:24:16.513] - relayed: [n=1] TRUE
[10:24:16.513] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.513] - relayed: [n=1] TRUE
[10:24:16.513] - queued futures: [n=1] TRUE
[10:24:16.513] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.513] resolve() on list ... DONE
[10:24:16.513]  - Number of value chunks collected: 1
[10:24:16.514] Resolving 1 futures (chunks) ... DONE
[10:24:16.514] Reducing values from 1 chunks ...
[10:24:16.514]  - Number of values collected after concatenation: 10
[10:24:16.514]  - Number of values expected: 10
[10:24:16.514] Reducing values from 1 chunks ... DONE
[10:24:16.514] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[10:24:16.516] future_lapply() ...
[10:24:16.518] Number of chunks: 1
[10:24:16.518] getGlobalsAndPackagesXApply() ...
[10:24:16.518]  - future.globals: TRUE
[10:24:16.518] getGlobalsAndPackages() ...
[10:24:16.518] Searching for globals...
[10:24:16.521] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[10:24:16.522] Searching for globals ... DONE
[10:24:16.522] Resolving globals: FALSE
[10:24:16.523] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[10:24:16.523] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.523] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.523] - packages: [1] ‘future.apply’
[10:24:16.523] getGlobalsAndPackages() ... DONE
[10:24:16.523]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.524]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.524] Finding globals ... DONE
[10:24:16.524]  - use_args: TRUE
[10:24:16.525]  - Getting '...' globals ...
[10:24:16.525] resolve() on list ...
[10:24:16.525]  recursive: 0
[10:24:16.525]  length: 1
[10:24:16.525]  elements: ‘...’
[10:24:16.525]  length: 0 (resolved future 1)
[10:24:16.525] resolve() on list ... DONE
[10:24:16.526]    - '...' content: [n=0] 
[10:24:16.526] List of 1
[10:24:16.526]  $ ...: list()
[10:24:16.526]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.526]  - attr(*, "where")=List of 1
[10:24:16.526]   ..$ ...:<environment: 0x55b93cce53c0> 
[10:24:16.526]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.526]  - attr(*, "resolved")= logi TRUE
[10:24:16.526]  - attr(*, "total_size")= num NA
[10:24:16.528]  - Getting '...' globals ... DONE
[10:24:16.528] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.528] List of 8
[10:24:16.528]  $ ...future.FUN:function (x, ...)  
[10:24:16.528]  $ x_FUN        :function (x)  
[10:24:16.528]  $ times        : int 4
[10:24:16.528]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.528]  $ stop_if_not  :function (...)  
[10:24:16.528]  $ dim          : int [1:2] 2 2
[10:24:16.528]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:16.528]  $ ...          : list()
[10:24:16.528]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.528]  - attr(*, "where")=List of 8
[10:24:16.528]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.528]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.528]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.528]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.528]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.528]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.528]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.528]   ..$ ...          :<environment: 0x55b93cce53c0> 
[10:24:16.528]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.528]  - attr(*, "resolved")= logi FALSE
[10:24:16.528]  - attr(*, "total_size")= num 105552
[10:24:16.534] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.534] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.534] Number of futures (= number of chunks): 1
[10:24:16.534] Launching 1 futures (chunks) ...
[10:24:16.534] Chunk #1 of 1 ...
[10:24:16.534]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.534] getGlobalsAndPackages() ...
[10:24:16.534] Searching for globals...
[10:24:16.535] 
[10:24:16.535] Searching for globals ... DONE
[10:24:16.535] - globals: [0] <none>
[10:24:16.535] getGlobalsAndPackages() ... DONE
[10:24:16.535]    + additional globals found: [n=0] 
[10:24:16.535]    + additional namespaces needed: [n=0] 
[10:24:16.535]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.535]  - seeds: <none>
[10:24:16.535]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.535] getGlobalsAndPackages() ...
[10:24:16.535] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.536] Resolving globals: FALSE
[10:24:16.536] Tweak future expression to call with '...' arguments ...
[10:24:16.536] {
[10:24:16.536]     do.call(function(...) {
[10:24:16.536]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.536]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.536]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.536]             on.exit(options(oopts), add = TRUE)
[10:24:16.536]         }
[10:24:16.536]         {
[10:24:16.536]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.536]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.536]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.536]             })
[10:24:16.536]         }
[10:24:16.536]     }, args = future.call.arguments)
[10:24:16.536] }
[10:24:16.536] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.537] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.537] - packages: [1] ‘future.apply’
[10:24:16.537] getGlobalsAndPackages() ... DONE
[10:24:16.537] run() for ‘Future’ ...
[10:24:16.537] - state: ‘created’
[10:24:16.537] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.538] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.538] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.538]   - Field: ‘label’
[10:24:16.538]   - Field: ‘local’
[10:24:16.538]   - Field: ‘owner’
[10:24:16.538]   - Field: ‘envir’
[10:24:16.538]   - Field: ‘packages’
[10:24:16.538]   - Field: ‘gc’
[10:24:16.538]   - Field: ‘conditions’
[10:24:16.538]   - Field: ‘expr’
[10:24:16.538]   - Field: ‘uuid’
[10:24:16.539]   - Field: ‘seed’
[10:24:16.539]   - Field: ‘version’
[10:24:16.539]   - Field: ‘result’
[10:24:16.539]   - Field: ‘asynchronous’
[10:24:16.539]   - Field: ‘calls’
[10:24:16.539]   - Field: ‘globals’
[10:24:16.539]   - Field: ‘stdout’
[10:24:16.539]   - Field: ‘earlySignal’
[10:24:16.539]   - Field: ‘lazy’
[10:24:16.539]   - Field: ‘state’
[10:24:16.539] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.540] - Launch lazy future ...
[10:24:16.540] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.540] Packages needed by future strategies (n = 0): <none>
[10:24:16.540] {
[10:24:16.540]     {
[10:24:16.540]         {
[10:24:16.540]             ...future.startTime <- base::Sys.time()
[10:24:16.540]             {
[10:24:16.540]                 {
[10:24:16.540]                   {
[10:24:16.540]                     {
[10:24:16.540]                       base::local({
[10:24:16.540]                         has_future <- base::requireNamespace("future", 
[10:24:16.540]                           quietly = TRUE)
[10:24:16.540]                         if (has_future) {
[10:24:16.540]                           ns <- base::getNamespace("future")
[10:24:16.540]                           version <- ns[[".package"]][["version"]]
[10:24:16.540]                           if (is.null(version)) 
[10:24:16.540]                             version <- utils::packageVersion("future")
[10:24:16.540]                         }
[10:24:16.540]                         else {
[10:24:16.540]                           version <- NULL
[10:24:16.540]                         }
[10:24:16.540]                         if (!has_future || version < "1.8.0") {
[10:24:16.540]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.540]                             "", base::R.version$version.string), 
[10:24:16.540]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.540]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.540]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.540]                               "release", "version")], collapse = " "), 
[10:24:16.540]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.540]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.540]                             info)
[10:24:16.540]                           info <- base::paste(info, collapse = "; ")
[10:24:16.540]                           if (!has_future) {
[10:24:16.540]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.540]                               info)
[10:24:16.540]                           }
[10:24:16.540]                           else {
[10:24:16.540]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.540]                               info, version)
[10:24:16.540]                           }
[10:24:16.540]                           base::stop(msg)
[10:24:16.540]                         }
[10:24:16.540]                       })
[10:24:16.540]                     }
[10:24:16.540]                     base::local({
[10:24:16.540]                       for (pkg in "future.apply") {
[10:24:16.540]                         base::loadNamespace(pkg)
[10:24:16.540]                         base::library(pkg, character.only = TRUE)
[10:24:16.540]                       }
[10:24:16.540]                     })
[10:24:16.540]                   }
[10:24:16.540]                   options(future.plan = NULL)
[10:24:16.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.540]                 }
[10:24:16.540]                 ...future.workdir <- getwd()
[10:24:16.540]             }
[10:24:16.540]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.540]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.540]         }
[10:24:16.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.540]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.540]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.540]             base::names(...future.oldOptions))
[10:24:16.540]     }
[10:24:16.540]     if (FALSE) {
[10:24:16.540]     }
[10:24:16.540]     else {
[10:24:16.540]         if (TRUE) {
[10:24:16.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.540]                 open = "w")
[10:24:16.540]         }
[10:24:16.540]         else {
[10:24:16.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.540]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.540]         }
[10:24:16.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.540]             base::sink(type = "output", split = FALSE)
[10:24:16.540]             base::close(...future.stdout)
[10:24:16.540]         }, add = TRUE)
[10:24:16.540]     }
[10:24:16.540]     ...future.frame <- base::sys.nframe()
[10:24:16.540]     ...future.conditions <- base::list()
[10:24:16.540]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.540]     if (FALSE) {
[10:24:16.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.540]     }
[10:24:16.540]     ...future.result <- base::tryCatch({
[10:24:16.540]         base::withCallingHandlers({
[10:24:16.540]             ...future.value <- base::withVisible(base::local({
[10:24:16.540]                 do.call(function(...) {
[10:24:16.540]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.540]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.540]                     ...future.globals.maxSize)) {
[10:24:16.540]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.540]                     on.exit(options(oopts), add = TRUE)
[10:24:16.540]                   }
[10:24:16.540]                   {
[10:24:16.540]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.540]                       FUN = function(jj) {
[10:24:16.540]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.540]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.540]                       })
[10:24:16.540]                   }
[10:24:16.540]                 }, args = future.call.arguments)
[10:24:16.540]             }))
[10:24:16.540]             future::FutureResult(value = ...future.value$value, 
[10:24:16.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.540]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.540]                     ...future.globalenv.names))
[10:24:16.540]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.540]         }, condition = base::local({
[10:24:16.540]             c <- base::c
[10:24:16.540]             inherits <- base::inherits
[10:24:16.540]             invokeRestart <- base::invokeRestart
[10:24:16.540]             length <- base::length
[10:24:16.540]             list <- base::list
[10:24:16.540]             seq.int <- base::seq.int
[10:24:16.540]             signalCondition <- base::signalCondition
[10:24:16.540]             sys.calls <- base::sys.calls
[10:24:16.540]             `[[` <- base::`[[`
[10:24:16.540]             `+` <- base::`+`
[10:24:16.540]             `<<-` <- base::`<<-`
[10:24:16.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.540]                   3L)]
[10:24:16.540]             }
[10:24:16.540]             function(cond) {
[10:24:16.540]                 is_error <- inherits(cond, "error")
[10:24:16.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.540]                   NULL)
[10:24:16.540]                 if (is_error) {
[10:24:16.540]                   sessionInformation <- function() {
[10:24:16.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.540]                       search = base::search(), system = base::Sys.info())
[10:24:16.540]                   }
[10:24:16.540]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.540]                     cond$call), session = sessionInformation(), 
[10:24:16.540]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.540]                   signalCondition(cond)
[10:24:16.540]                 }
[10:24:16.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.540]                 "immediateCondition"))) {
[10:24:16.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.540]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.540]                   if (TRUE && !signal) {
[10:24:16.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.540]                     {
[10:24:16.540]                       inherits <- base::inherits
[10:24:16.540]                       invokeRestart <- base::invokeRestart
[10:24:16.540]                       is.null <- base::is.null
[10:24:16.540]                       muffled <- FALSE
[10:24:16.540]                       if (inherits(cond, "message")) {
[10:24:16.540]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.540]                         if (muffled) 
[10:24:16.540]                           invokeRestart("muffleMessage")
[10:24:16.540]                       }
[10:24:16.540]                       else if (inherits(cond, "warning")) {
[10:24:16.540]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.540]                         if (muffled) 
[10:24:16.540]                           invokeRestart("muffleWarning")
[10:24:16.540]                       }
[10:24:16.540]                       else if (inherits(cond, "condition")) {
[10:24:16.540]                         if (!is.null(pattern)) {
[10:24:16.540]                           computeRestarts <- base::computeRestarts
[10:24:16.540]                           grepl <- base::grepl
[10:24:16.540]                           restarts <- computeRestarts(cond)
[10:24:16.540]                           for (restart in restarts) {
[10:24:16.540]                             name <- restart$name
[10:24:16.540]                             if (is.null(name)) 
[10:24:16.540]                               next
[10:24:16.540]                             if (!grepl(pattern, name)) 
[10:24:16.540]                               next
[10:24:16.540]                             invokeRestart(restart)
[10:24:16.540]                             muffled <- TRUE
[10:24:16.540]                             break
[10:24:16.540]                           }
[10:24:16.540]                         }
[10:24:16.540]                       }
[10:24:16.540]                       invisible(muffled)
[10:24:16.540]                     }
[10:24:16.540]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.540]                   }
[10:24:16.540]                 }
[10:24:16.540]                 else {
[10:24:16.540]                   if (TRUE) {
[10:24:16.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.540]                     {
[10:24:16.540]                       inherits <- base::inherits
[10:24:16.540]                       invokeRestart <- base::invokeRestart
[10:24:16.540]                       is.null <- base::is.null
[10:24:16.540]                       muffled <- FALSE
[10:24:16.540]                       if (inherits(cond, "message")) {
[10:24:16.540]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.540]                         if (muffled) 
[10:24:16.540]                           invokeRestart("muffleMessage")
[10:24:16.540]                       }
[10:24:16.540]                       else if (inherits(cond, "warning")) {
[10:24:16.540]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.540]                         if (muffled) 
[10:24:16.540]                           invokeRestart("muffleWarning")
[10:24:16.540]                       }
[10:24:16.540]                       else if (inherits(cond, "condition")) {
[10:24:16.540]                         if (!is.null(pattern)) {
[10:24:16.540]                           computeRestarts <- base::computeRestarts
[10:24:16.540]                           grepl <- base::grepl
[10:24:16.540]                           restarts <- computeRestarts(cond)
[10:24:16.540]                           for (restart in restarts) {
[10:24:16.540]                             name <- restart$name
[10:24:16.540]                             if (is.null(name)) 
[10:24:16.540]                               next
[10:24:16.540]                             if (!grepl(pattern, name)) 
[10:24:16.540]                               next
[10:24:16.540]                             invokeRestart(restart)
[10:24:16.540]                             muffled <- TRUE
[10:24:16.540]                             break
[10:24:16.540]                           }
[10:24:16.540]                         }
[10:24:16.540]                       }
[10:24:16.540]                       invisible(muffled)
[10:24:16.540]                     }
[10:24:16.540]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.540]                   }
[10:24:16.540]                 }
[10:24:16.540]             }
[10:24:16.540]         }))
[10:24:16.540]     }, error = function(ex) {
[10:24:16.540]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.540]                 ...future.rng), started = ...future.startTime, 
[10:24:16.540]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.540]             version = "1.8"), class = "FutureResult")
[10:24:16.540]     }, finally = {
[10:24:16.540]         if (!identical(...future.workdir, getwd())) 
[10:24:16.540]             setwd(...future.workdir)
[10:24:16.540]         {
[10:24:16.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.540]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.540]             }
[10:24:16.540]             base::options(...future.oldOptions)
[10:24:16.540]             if (.Platform$OS.type == "windows") {
[10:24:16.540]                 old_names <- names(...future.oldEnvVars)
[10:24:16.540]                 envs <- base::Sys.getenv()
[10:24:16.540]                 names <- names(envs)
[10:24:16.540]                 common <- intersect(names, old_names)
[10:24:16.540]                 added <- setdiff(names, old_names)
[10:24:16.540]                 removed <- setdiff(old_names, names)
[10:24:16.540]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.540]                   envs[common]]
[10:24:16.540]                 NAMES <- toupper(changed)
[10:24:16.540]                 args <- list()
[10:24:16.540]                 for (kk in seq_along(NAMES)) {
[10:24:16.540]                   name <- changed[[kk]]
[10:24:16.540]                   NAME <- NAMES[[kk]]
[10:24:16.540]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.540]                     next
[10:24:16.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.540]                 }
[10:24:16.540]                 NAMES <- toupper(added)
[10:24:16.540]                 for (kk in seq_along(NAMES)) {
[10:24:16.540]                   name <- added[[kk]]
[10:24:16.540]                   NAME <- NAMES[[kk]]
[10:24:16.540]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.540]                     next
[10:24:16.540]                   args[[name]] <- ""
[10:24:16.540]                 }
[10:24:16.540]                 NAMES <- toupper(removed)
[10:24:16.540]                 for (kk in seq_along(NAMES)) {
[10:24:16.540]                   name <- removed[[kk]]
[10:24:16.540]                   NAME <- NAMES[[kk]]
[10:24:16.540]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.540]                     next
[10:24:16.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.540]                 }
[10:24:16.540]                 if (length(args) > 0) 
[10:24:16.540]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.540]             }
[10:24:16.540]             else {
[10:24:16.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.540]             }
[10:24:16.540]             {
[10:24:16.540]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.540]                   0L) {
[10:24:16.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.540]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.540]                   base::options(opts)
[10:24:16.540]                 }
[10:24:16.540]                 {
[10:24:16.540]                   {
[10:24:16.540]                     NULL
[10:24:16.540]                     RNGkind("Mersenne-Twister")
[10:24:16.540]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.540]                       inherits = FALSE)
[10:24:16.540]                   }
[10:24:16.540]                   options(future.plan = NULL)
[10:24:16.540]                   if (is.na(NA_character_)) 
[10:24:16.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.540]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.540]                   {
[10:24:16.540]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.540]                     if (!future$lazy) 
[10:24:16.540]                       future <- run(future)
[10:24:16.540]                     invisible(future)
[10:24:16.540]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.540]                 }
[10:24:16.540]             }
[10:24:16.540]         }
[10:24:16.540]     })
[10:24:16.540]     if (TRUE) {
[10:24:16.540]         base::sink(type = "output", split = FALSE)
[10:24:16.540]         if (TRUE) {
[10:24:16.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.540]         }
[10:24:16.540]         else {
[10:24:16.540]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.540]         }
[10:24:16.540]         base::close(...future.stdout)
[10:24:16.540]         ...future.stdout <- NULL
[10:24:16.540]     }
[10:24:16.540]     ...future.result$conditions <- ...future.conditions
[10:24:16.540]     ...future.result$finished <- base::Sys.time()
[10:24:16.540]     ...future.result
[10:24:16.540] }
[10:24:16.542] assign_globals() ...
[10:24:16.542] List of 11
[10:24:16.542]  $ ...future.FUN            :function (x, ...)  
[10:24:16.542]  $ x_FUN                    :function (x)  
[10:24:16.542]  $ times                    : int 4
[10:24:16.542]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.542]  $ stop_if_not              :function (...)  
[10:24:16.542]  $ dim                      : int [1:2] 2 2
[10:24:16.542]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:16.542]  $ future.call.arguments    : list()
[10:24:16.542]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.542]  $ ...future.elements_ii    :List of 10
[10:24:16.542]   ..$ : int 1
[10:24:16.542]   ..$ : int 2
[10:24:16.542]   ..$ : int 3
[10:24:16.542]   ..$ : int 4
[10:24:16.542]   ..$ : int 5
[10:24:16.542]   ..$ : int 6
[10:24:16.542]   ..$ : int 7
[10:24:16.542]   ..$ : int 8
[10:24:16.542]   ..$ : int 9
[10:24:16.542]   ..$ : int 10
[10:24:16.542]  $ ...future.seeds_ii       : NULL
[10:24:16.542]  $ ...future.globals.maxSize: NULL
[10:24:16.542]  - attr(*, "where")=List of 11
[10:24:16.542]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.542]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.542]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.542]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.542]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.542]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.542]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.542]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.542]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.542]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.542]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.542]  - attr(*, "resolved")= logi FALSE
[10:24:16.542]  - attr(*, "total_size")= num 105552
[10:24:16.542]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.542]  - attr(*, "already-done")= logi TRUE
[10:24:16.553] - copied ‘...future.FUN’ to environment
[10:24:16.553] - reassign environment for ‘x_FUN’
[10:24:16.553] - copied ‘x_FUN’ to environment
[10:24:16.553] - copied ‘times’ to environment
[10:24:16.553] - copied ‘stopf’ to environment
[10:24:16.553] - copied ‘stop_if_not’ to environment
[10:24:16.553] - copied ‘dim’ to environment
[10:24:16.553] - copied ‘valid_types’ to environment
[10:24:16.553] - copied ‘future.call.arguments’ to environment
[10:24:16.553] - copied ‘...future.elements_ii’ to environment
[10:24:16.554] - copied ‘...future.seeds_ii’ to environment
[10:24:16.554] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.554] assign_globals() ... done
[10:24:16.554] plan(): Setting new future strategy stack:
[10:24:16.554] List of future strategies:
[10:24:16.554] 1. sequential:
[10:24:16.554]    - args: function (..., envir = parent.frame())
[10:24:16.554]    - tweaked: FALSE
[10:24:16.554]    - call: NULL
[10:24:16.554] plan(): nbrOfWorkers() = 1
[10:24:16.555] plan(): Setting new future strategy stack:
[10:24:16.555] List of future strategies:
[10:24:16.555] 1. sequential:
[10:24:16.555]    - args: function (..., envir = parent.frame())
[10:24:16.555]    - tweaked: FALSE
[10:24:16.555]    - call: plan(strategy)
[10:24:16.556] plan(): nbrOfWorkers() = 1
[10:24:16.556] SequentialFuture started (and completed)
[10:24:16.556] - Launch lazy future ... done
[10:24:16.556] run() for ‘SequentialFuture’ ... done
[10:24:16.556] Created future:
[10:24:16.556] SequentialFuture:
[10:24:16.556] Label: ‘future_vapply-1’
[10:24:16.556] Expression:
[10:24:16.556] {
[10:24:16.556]     do.call(function(...) {
[10:24:16.556]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.556]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.556]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.556]             on.exit(options(oopts), add = TRUE)
[10:24:16.556]         }
[10:24:16.556]         {
[10:24:16.556]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.556]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.556]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.556]             })
[10:24:16.556]         }
[10:24:16.556]     }, args = future.call.arguments)
[10:24:16.556] }
[10:24:16.556] Lazy evaluation: FALSE
[10:24:16.556] Asynchronous evaluation: FALSE
[10:24:16.556] Local evaluation: TRUE
[10:24:16.556] Environment: R_GlobalEnv
[10:24:16.556] Capture standard output: TRUE
[10:24:16.556] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.556] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.556] Packages: 1 packages (‘future.apply’)
[10:24:16.556] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.556] Resolved: TRUE
[10:24:16.556] Value: 7.42 KiB of class ‘list’
[10:24:16.556] Early signaling: FALSE
[10:24:16.556] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.556] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.557] Chunk #1 of 1 ... DONE
[10:24:16.557] Launching 1 futures (chunks) ... DONE
[10:24:16.557] Resolving 1 futures (chunks) ...
[10:24:16.558] resolve() on list ...
[10:24:16.558]  recursive: 0
[10:24:16.558]  length: 1
[10:24:16.558] 
[10:24:16.558] resolved() for ‘SequentialFuture’ ...
[10:24:16.558] - state: ‘finished’
[10:24:16.558] - run: TRUE
[10:24:16.558] - result: ‘FutureResult’
[10:24:16.558] resolved() for ‘SequentialFuture’ ... done
[10:24:16.558] Future #1
[10:24:16.559] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.559] - nx: 1
[10:24:16.559] - relay: TRUE
[10:24:16.559] - stdout: TRUE
[10:24:16.559] - signal: TRUE
[10:24:16.559] - resignal: FALSE
[10:24:16.559] - force: TRUE
[10:24:16.559] - relayed: [n=1] FALSE
[10:24:16.559] - queued futures: [n=1] FALSE
[10:24:16.559]  - until=1
[10:24:16.559]  - relaying element #1
[10:24:16.560] - relayed: [n=1] TRUE
[10:24:16.560] - queued futures: [n=1] TRUE
[10:24:16.560] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.560]  length: 0 (resolved future 1)
[10:24:16.560] Relaying remaining futures
[10:24:16.560] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.560] - nx: 1
[10:24:16.560] - relay: TRUE
[10:24:16.560] - stdout: TRUE
[10:24:16.560] - signal: TRUE
[10:24:16.560] - resignal: FALSE
[10:24:16.560] - force: TRUE
[10:24:16.560] - relayed: [n=1] TRUE
[10:24:16.561] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.561] - relayed: [n=1] TRUE
[10:24:16.561] - queued futures: [n=1] TRUE
[10:24:16.561] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.561] resolve() on list ... DONE
[10:24:16.561]  - Number of value chunks collected: 1
[10:24:16.561] Resolving 1 futures (chunks) ... DONE
[10:24:16.561] Reducing values from 1 chunks ...
[10:24:16.561]  - Number of values collected after concatenation: 10
[10:24:16.561]  - Number of values expected: 10
[10:24:16.562] Reducing values from 1 chunks ... DONE
[10:24:16.562] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[10:24:16.565] future_lapply() ...
[10:24:16.567] Number of chunks: 1
[10:24:16.567] getGlobalsAndPackagesXApply() ...
[10:24:16.567]  - future.globals: TRUE
[10:24:16.567] getGlobalsAndPackages() ...
[10:24:16.567] Searching for globals...
[10:24:16.571] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[10:24:16.572] Searching for globals ... DONE
[10:24:16.572] Resolving globals: FALSE
[10:24:16.572] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[10:24:16.573] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.573] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.573] - packages: [2] ‘stats’, ‘future.apply’
[10:24:16.573] getGlobalsAndPackages() ... DONE
[10:24:16.573]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.573]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:24:16.573] Finding globals ... DONE
[10:24:16.574]  - use_args: TRUE
[10:24:16.574]  - Getting '...' globals ...
[10:24:16.574] resolve() on list ...
[10:24:16.574]  recursive: 0
[10:24:16.574]  length: 1
[10:24:16.574]  elements: ‘...’
[10:24:16.574]  length: 0 (resolved future 1)
[10:24:16.574] resolve() on list ... DONE
[10:24:16.574]    - '...' content: [n=0] 
[10:24:16.575] List of 1
[10:24:16.575]  $ ...: list()
[10:24:16.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.575]  - attr(*, "where")=List of 1
[10:24:16.575]   ..$ ...:<environment: 0x55b93cf77c10> 
[10:24:16.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.575]  - attr(*, "resolved")= logi TRUE
[10:24:16.575]  - attr(*, "total_size")= num NA
[10:24:16.577]  - Getting '...' globals ... DONE
[10:24:16.577] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.577] List of 8
[10:24:16.577]  $ ...future.FUN:function (x, ...)  
[10:24:16.577]  $ x_FUN        :function (x, ...)  
[10:24:16.577]  $ times        : int 5
[10:24:16.577]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.577]  $ stop_if_not  :function (...)  
[10:24:16.577]  $ dim          : NULL
[10:24:16.577]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:16.577]  $ ...          : list()
[10:24:16.577]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.577]  - attr(*, "where")=List of 8
[10:24:16.577]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.577]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.577]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.577]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.577]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.577]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.577]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.577]   ..$ ...          :<environment: 0x55b93cf77c10> 
[10:24:16.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.577]  - attr(*, "resolved")= logi FALSE
[10:24:16.577]  - attr(*, "total_size")= num 95528
[10:24:16.582] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:24:16.582] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.582] Number of futures (= number of chunks): 1
[10:24:16.583] Launching 1 futures (chunks) ...
[10:24:16.583] Chunk #1 of 1 ...
[10:24:16.583]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.583] getGlobalsAndPackages() ...
[10:24:16.583] Searching for globals...
[10:24:16.583] 
[10:24:16.583] Searching for globals ... DONE
[10:24:16.583] - globals: [0] <none>
[10:24:16.583] getGlobalsAndPackages() ... DONE
[10:24:16.584]    + additional globals found: [n=0] 
[10:24:16.584]    + additional namespaces needed: [n=0] 
[10:24:16.584]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.584]  - seeds: <none>
[10:24:16.584]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.584] getGlobalsAndPackages() ...
[10:24:16.584] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.584] Resolving globals: FALSE
[10:24:16.584] Tweak future expression to call with '...' arguments ...
[10:24:16.584] {
[10:24:16.584]     do.call(function(...) {
[10:24:16.584]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.584]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.584]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.584]             on.exit(options(oopts), add = TRUE)
[10:24:16.584]         }
[10:24:16.584]         {
[10:24:16.584]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.584]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.584]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.584]             })
[10:24:16.584]         }
[10:24:16.584]     }, args = future.call.arguments)
[10:24:16.584] }
[10:24:16.585] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.585] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.585] - packages: [2] ‘stats’, ‘future.apply’
[10:24:16.585] getGlobalsAndPackages() ... DONE
[10:24:16.586] run() for ‘Future’ ...
[10:24:16.586] - state: ‘created’
[10:24:16.586] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.586] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.586] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.586]   - Field: ‘label’
[10:24:16.586]   - Field: ‘local’
[10:24:16.586]   - Field: ‘owner’
[10:24:16.587]   - Field: ‘envir’
[10:24:16.587]   - Field: ‘packages’
[10:24:16.587]   - Field: ‘gc’
[10:24:16.587]   - Field: ‘conditions’
[10:24:16.587]   - Field: ‘expr’
[10:24:16.587]   - Field: ‘uuid’
[10:24:16.587]   - Field: ‘seed’
[10:24:16.587]   - Field: ‘version’
[10:24:16.587]   - Field: ‘result’
[10:24:16.587]   - Field: ‘asynchronous’
[10:24:16.587]   - Field: ‘calls’
[10:24:16.587]   - Field: ‘globals’
[10:24:16.588]   - Field: ‘stdout’
[10:24:16.588]   - Field: ‘earlySignal’
[10:24:16.588]   - Field: ‘lazy’
[10:24:16.588]   - Field: ‘state’
[10:24:16.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.588] - Launch lazy future ...
[10:24:16.588] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:24:16.588] Packages needed by future strategies (n = 0): <none>
[10:24:16.589] {
[10:24:16.589]     {
[10:24:16.589]         {
[10:24:16.589]             ...future.startTime <- base::Sys.time()
[10:24:16.589]             {
[10:24:16.589]                 {
[10:24:16.589]                   {
[10:24:16.589]                     {
[10:24:16.589]                       base::local({
[10:24:16.589]                         has_future <- base::requireNamespace("future", 
[10:24:16.589]                           quietly = TRUE)
[10:24:16.589]                         if (has_future) {
[10:24:16.589]                           ns <- base::getNamespace("future")
[10:24:16.589]                           version <- ns[[".package"]][["version"]]
[10:24:16.589]                           if (is.null(version)) 
[10:24:16.589]                             version <- utils::packageVersion("future")
[10:24:16.589]                         }
[10:24:16.589]                         else {
[10:24:16.589]                           version <- NULL
[10:24:16.589]                         }
[10:24:16.589]                         if (!has_future || version < "1.8.0") {
[10:24:16.589]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.589]                             "", base::R.version$version.string), 
[10:24:16.589]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.589]                               "release", "version")], collapse = " "), 
[10:24:16.589]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.589]                             info)
[10:24:16.589]                           info <- base::paste(info, collapse = "; ")
[10:24:16.589]                           if (!has_future) {
[10:24:16.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.589]                               info)
[10:24:16.589]                           }
[10:24:16.589]                           else {
[10:24:16.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.589]                               info, version)
[10:24:16.589]                           }
[10:24:16.589]                           base::stop(msg)
[10:24:16.589]                         }
[10:24:16.589]                       })
[10:24:16.589]                     }
[10:24:16.589]                     base::local({
[10:24:16.589]                       for (pkg in c("stats", "future.apply")) {
[10:24:16.589]                         base::loadNamespace(pkg)
[10:24:16.589]                         base::library(pkg, character.only = TRUE)
[10:24:16.589]                       }
[10:24:16.589]                     })
[10:24:16.589]                   }
[10:24:16.589]                   options(future.plan = NULL)
[10:24:16.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.589]                 }
[10:24:16.589]                 ...future.workdir <- getwd()
[10:24:16.589]             }
[10:24:16.589]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.589]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.589]         }
[10:24:16.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.589]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.589]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.589]             base::names(...future.oldOptions))
[10:24:16.589]     }
[10:24:16.589]     if (FALSE) {
[10:24:16.589]     }
[10:24:16.589]     else {
[10:24:16.589]         if (TRUE) {
[10:24:16.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.589]                 open = "w")
[10:24:16.589]         }
[10:24:16.589]         else {
[10:24:16.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.589]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.589]         }
[10:24:16.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.589]             base::sink(type = "output", split = FALSE)
[10:24:16.589]             base::close(...future.stdout)
[10:24:16.589]         }, add = TRUE)
[10:24:16.589]     }
[10:24:16.589]     ...future.frame <- base::sys.nframe()
[10:24:16.589]     ...future.conditions <- base::list()
[10:24:16.589]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.589]     if (FALSE) {
[10:24:16.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.589]     }
[10:24:16.589]     ...future.result <- base::tryCatch({
[10:24:16.589]         base::withCallingHandlers({
[10:24:16.589]             ...future.value <- base::withVisible(base::local({
[10:24:16.589]                 do.call(function(...) {
[10:24:16.589]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.589]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.589]                     ...future.globals.maxSize)) {
[10:24:16.589]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.589]                     on.exit(options(oopts), add = TRUE)
[10:24:16.589]                   }
[10:24:16.589]                   {
[10:24:16.589]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.589]                       FUN = function(jj) {
[10:24:16.589]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.589]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.589]                       })
[10:24:16.589]                   }
[10:24:16.589]                 }, args = future.call.arguments)
[10:24:16.589]             }))
[10:24:16.589]             future::FutureResult(value = ...future.value$value, 
[10:24:16.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.589]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.589]                     ...future.globalenv.names))
[10:24:16.589]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.589]         }, condition = base::local({
[10:24:16.589]             c <- base::c
[10:24:16.589]             inherits <- base::inherits
[10:24:16.589]             invokeRestart <- base::invokeRestart
[10:24:16.589]             length <- base::length
[10:24:16.589]             list <- base::list
[10:24:16.589]             seq.int <- base::seq.int
[10:24:16.589]             signalCondition <- base::signalCondition
[10:24:16.589]             sys.calls <- base::sys.calls
[10:24:16.589]             `[[` <- base::`[[`
[10:24:16.589]             `+` <- base::`+`
[10:24:16.589]             `<<-` <- base::`<<-`
[10:24:16.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.589]                   3L)]
[10:24:16.589]             }
[10:24:16.589]             function(cond) {
[10:24:16.589]                 is_error <- inherits(cond, "error")
[10:24:16.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.589]                   NULL)
[10:24:16.589]                 if (is_error) {
[10:24:16.589]                   sessionInformation <- function() {
[10:24:16.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.589]                       search = base::search(), system = base::Sys.info())
[10:24:16.589]                   }
[10:24:16.589]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.589]                     cond$call), session = sessionInformation(), 
[10:24:16.589]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.589]                   signalCondition(cond)
[10:24:16.589]                 }
[10:24:16.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.589]                 "immediateCondition"))) {
[10:24:16.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.589]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.589]                   if (TRUE && !signal) {
[10:24:16.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.589]                     {
[10:24:16.589]                       inherits <- base::inherits
[10:24:16.589]                       invokeRestart <- base::invokeRestart
[10:24:16.589]                       is.null <- base::is.null
[10:24:16.589]                       muffled <- FALSE
[10:24:16.589]                       if (inherits(cond, "message")) {
[10:24:16.589]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.589]                         if (muffled) 
[10:24:16.589]                           invokeRestart("muffleMessage")
[10:24:16.589]                       }
[10:24:16.589]                       else if (inherits(cond, "warning")) {
[10:24:16.589]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.589]                         if (muffled) 
[10:24:16.589]                           invokeRestart("muffleWarning")
[10:24:16.589]                       }
[10:24:16.589]                       else if (inherits(cond, "condition")) {
[10:24:16.589]                         if (!is.null(pattern)) {
[10:24:16.589]                           computeRestarts <- base::computeRestarts
[10:24:16.589]                           grepl <- base::grepl
[10:24:16.589]                           restarts <- computeRestarts(cond)
[10:24:16.589]                           for (restart in restarts) {
[10:24:16.589]                             name <- restart$name
[10:24:16.589]                             if (is.null(name)) 
[10:24:16.589]                               next
[10:24:16.589]                             if (!grepl(pattern, name)) 
[10:24:16.589]                               next
[10:24:16.589]                             invokeRestart(restart)
[10:24:16.589]                             muffled <- TRUE
[10:24:16.589]                             break
[10:24:16.589]                           }
[10:24:16.589]                         }
[10:24:16.589]                       }
[10:24:16.589]                       invisible(muffled)
[10:24:16.589]                     }
[10:24:16.589]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.589]                   }
[10:24:16.589]                 }
[10:24:16.589]                 else {
[10:24:16.589]                   if (TRUE) {
[10:24:16.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.589]                     {
[10:24:16.589]                       inherits <- base::inherits
[10:24:16.589]                       invokeRestart <- base::invokeRestart
[10:24:16.589]                       is.null <- base::is.null
[10:24:16.589]                       muffled <- FALSE
[10:24:16.589]                       if (inherits(cond, "message")) {
[10:24:16.589]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.589]                         if (muffled) 
[10:24:16.589]                           invokeRestart("muffleMessage")
[10:24:16.589]                       }
[10:24:16.589]                       else if (inherits(cond, "warning")) {
[10:24:16.589]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.589]                         if (muffled) 
[10:24:16.589]                           invokeRestart("muffleWarning")
[10:24:16.589]                       }
[10:24:16.589]                       else if (inherits(cond, "condition")) {
[10:24:16.589]                         if (!is.null(pattern)) {
[10:24:16.589]                           computeRestarts <- base::computeRestarts
[10:24:16.589]                           grepl <- base::grepl
[10:24:16.589]                           restarts <- computeRestarts(cond)
[10:24:16.589]                           for (restart in restarts) {
[10:24:16.589]                             name <- restart$name
[10:24:16.589]                             if (is.null(name)) 
[10:24:16.589]                               next
[10:24:16.589]                             if (!grepl(pattern, name)) 
[10:24:16.589]                               next
[10:24:16.589]                             invokeRestart(restart)
[10:24:16.589]                             muffled <- TRUE
[10:24:16.589]                             break
[10:24:16.589]                           }
[10:24:16.589]                         }
[10:24:16.589]                       }
[10:24:16.589]                       invisible(muffled)
[10:24:16.589]                     }
[10:24:16.589]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.589]                   }
[10:24:16.589]                 }
[10:24:16.589]             }
[10:24:16.589]         }))
[10:24:16.589]     }, error = function(ex) {
[10:24:16.589]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.589]                 ...future.rng), started = ...future.startTime, 
[10:24:16.589]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.589]             version = "1.8"), class = "FutureResult")
[10:24:16.589]     }, finally = {
[10:24:16.589]         if (!identical(...future.workdir, getwd())) 
[10:24:16.589]             setwd(...future.workdir)
[10:24:16.589]         {
[10:24:16.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.589]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.589]             }
[10:24:16.589]             base::options(...future.oldOptions)
[10:24:16.589]             if (.Platform$OS.type == "windows") {
[10:24:16.589]                 old_names <- names(...future.oldEnvVars)
[10:24:16.589]                 envs <- base::Sys.getenv()
[10:24:16.589]                 names <- names(envs)
[10:24:16.589]                 common <- intersect(names, old_names)
[10:24:16.589]                 added <- setdiff(names, old_names)
[10:24:16.589]                 removed <- setdiff(old_names, names)
[10:24:16.589]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.589]                   envs[common]]
[10:24:16.589]                 NAMES <- toupper(changed)
[10:24:16.589]                 args <- list()
[10:24:16.589]                 for (kk in seq_along(NAMES)) {
[10:24:16.589]                   name <- changed[[kk]]
[10:24:16.589]                   NAME <- NAMES[[kk]]
[10:24:16.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.589]                     next
[10:24:16.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.589]                 }
[10:24:16.589]                 NAMES <- toupper(added)
[10:24:16.589]                 for (kk in seq_along(NAMES)) {
[10:24:16.589]                   name <- added[[kk]]
[10:24:16.589]                   NAME <- NAMES[[kk]]
[10:24:16.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.589]                     next
[10:24:16.589]                   args[[name]] <- ""
[10:24:16.589]                 }
[10:24:16.589]                 NAMES <- toupper(removed)
[10:24:16.589]                 for (kk in seq_along(NAMES)) {
[10:24:16.589]                   name <- removed[[kk]]
[10:24:16.589]                   NAME <- NAMES[[kk]]
[10:24:16.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.589]                     next
[10:24:16.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.589]                 }
[10:24:16.589]                 if (length(args) > 0) 
[10:24:16.589]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.589]             }
[10:24:16.589]             else {
[10:24:16.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.589]             }
[10:24:16.589]             {
[10:24:16.589]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.589]                   0L) {
[10:24:16.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.589]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.589]                   base::options(opts)
[10:24:16.589]                 }
[10:24:16.589]                 {
[10:24:16.589]                   {
[10:24:16.589]                     NULL
[10:24:16.589]                     RNGkind("Mersenne-Twister")
[10:24:16.589]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.589]                       inherits = FALSE)
[10:24:16.589]                   }
[10:24:16.589]                   options(future.plan = NULL)
[10:24:16.589]                   if (is.na(NA_character_)) 
[10:24:16.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.589]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.589]                   {
[10:24:16.589]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.589]                     if (!future$lazy) 
[10:24:16.589]                       future <- run(future)
[10:24:16.589]                     invisible(future)
[10:24:16.589]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.589]                 }
[10:24:16.589]             }
[10:24:16.589]         }
[10:24:16.589]     })
[10:24:16.589]     if (TRUE) {
[10:24:16.589]         base::sink(type = "output", split = FALSE)
[10:24:16.589]         if (TRUE) {
[10:24:16.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.589]         }
[10:24:16.589]         else {
[10:24:16.589]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.589]         }
[10:24:16.589]         base::close(...future.stdout)
[10:24:16.589]         ...future.stdout <- NULL
[10:24:16.589]     }
[10:24:16.589]     ...future.result$conditions <- ...future.conditions
[10:24:16.589]     ...future.result$finished <- base::Sys.time()
[10:24:16.589]     ...future.result
[10:24:16.589] }
[10:24:16.591] assign_globals() ...
[10:24:16.591] List of 11
[10:24:16.591]  $ ...future.FUN            :function (x, ...)  
[10:24:16.591]  $ x_FUN                    :function (x, ...)  
[10:24:16.591]  $ times                    : int 5
[10:24:16.591]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.591]  $ stop_if_not              :function (...)  
[10:24:16.591]  $ dim                      : NULL
[10:24:16.591]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:16.591]  $ future.call.arguments    : list()
[10:24:16.591]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.591]  $ ...future.elements_ii    :List of 3
[10:24:16.591]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:24:16.591]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:24:16.591]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:24:16.591]  $ ...future.seeds_ii       : NULL
[10:24:16.591]  $ ...future.globals.maxSize: NULL
[10:24:16.591]  - attr(*, "where")=List of 11
[10:24:16.591]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.591]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.591]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.591]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.591]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.591]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.591]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.591]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.591]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.591]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.591]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.591]  - attr(*, "resolved")= logi FALSE
[10:24:16.591]  - attr(*, "total_size")= num 95528
[10:24:16.591]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.591]  - attr(*, "already-done")= logi TRUE
[10:24:16.599] - copied ‘...future.FUN’ to environment
[10:24:16.599] - copied ‘x_FUN’ to environment
[10:24:16.599] - copied ‘times’ to environment
[10:24:16.599] - copied ‘stopf’ to environment
[10:24:16.599] - copied ‘stop_if_not’ to environment
[10:24:16.600] - copied ‘dim’ to environment
[10:24:16.600] - copied ‘valid_types’ to environment
[10:24:16.600] - copied ‘future.call.arguments’ to environment
[10:24:16.600] - copied ‘...future.elements_ii’ to environment
[10:24:16.600] - copied ‘...future.seeds_ii’ to environment
[10:24:16.600] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.600] assign_globals() ... done
[10:24:16.601] plan(): Setting new future strategy stack:
[10:24:16.601] List of future strategies:
[10:24:16.601] 1. sequential:
[10:24:16.601]    - args: function (..., envir = parent.frame())
[10:24:16.601]    - tweaked: FALSE
[10:24:16.601]    - call: NULL
[10:24:16.601] plan(): nbrOfWorkers() = 1
[10:24:16.602] plan(): Setting new future strategy stack:
[10:24:16.602] List of future strategies:
[10:24:16.602] 1. sequential:
[10:24:16.602]    - args: function (..., envir = parent.frame())
[10:24:16.602]    - tweaked: FALSE
[10:24:16.602]    - call: plan(strategy)
[10:24:16.603] plan(): nbrOfWorkers() = 1
[10:24:16.603] SequentialFuture started (and completed)
[10:24:16.603] - Launch lazy future ... done
[10:24:16.603] run() for ‘SequentialFuture’ ... done
[10:24:16.603] Created future:
[10:24:16.603] SequentialFuture:
[10:24:16.603] Label: ‘future_vapply-1’
[10:24:16.603] Expression:
[10:24:16.603] {
[10:24:16.603]     do.call(function(...) {
[10:24:16.603]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.603]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.603]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.603]             on.exit(options(oopts), add = TRUE)
[10:24:16.603]         }
[10:24:16.603]         {
[10:24:16.603]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.603]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.603]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.603]             })
[10:24:16.603]         }
[10:24:16.603]     }, args = future.call.arguments)
[10:24:16.603] }
[10:24:16.603] Lazy evaluation: FALSE
[10:24:16.603] Asynchronous evaluation: FALSE
[10:24:16.603] Local evaluation: TRUE
[10:24:16.603] Environment: R_GlobalEnv
[10:24:16.603] Capture standard output: TRUE
[10:24:16.603] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.603] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.603] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:24:16.603] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.603] Resolved: TRUE
[10:24:16.603] Value: 1.71 KiB of class ‘list’
[10:24:16.603] Early signaling: FALSE
[10:24:16.603] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.603] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.604] Chunk #1 of 1 ... DONE
[10:24:16.604] Launching 1 futures (chunks) ... DONE
[10:24:16.604] Resolving 1 futures (chunks) ...
[10:24:16.604] resolve() on list ...
[10:24:16.605]  recursive: 0
[10:24:16.605]  length: 1
[10:24:16.605] 
[10:24:16.605] resolved() for ‘SequentialFuture’ ...
[10:24:16.605] - state: ‘finished’
[10:24:16.605] - run: TRUE
[10:24:16.605] - result: ‘FutureResult’
[10:24:16.605] resolved() for ‘SequentialFuture’ ... done
[10:24:16.605] Future #1
[10:24:16.605] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.606] - nx: 1
[10:24:16.606] - relay: TRUE
[10:24:16.606] - stdout: TRUE
[10:24:16.606] - signal: TRUE
[10:24:16.606] - resignal: FALSE
[10:24:16.606] - force: TRUE
[10:24:16.606] - relayed: [n=1] FALSE
[10:24:16.606] - queued futures: [n=1] FALSE
[10:24:16.606]  - until=1
[10:24:16.606]  - relaying element #1
[10:24:16.606] - relayed: [n=1] TRUE
[10:24:16.607] - queued futures: [n=1] TRUE
[10:24:16.607] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.607]  length: 0 (resolved future 1)
[10:24:16.607] Relaying remaining futures
[10:24:16.607] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.607] - nx: 1
[10:24:16.607] - relay: TRUE
[10:24:16.607] - stdout: TRUE
[10:24:16.607] - signal: TRUE
[10:24:16.607] - resignal: FALSE
[10:24:16.607] - force: TRUE
[10:24:16.607] - relayed: [n=1] TRUE
[10:24:16.608] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.608] - relayed: [n=1] TRUE
[10:24:16.608] - queued futures: [n=1] TRUE
[10:24:16.608] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.608] resolve() on list ... DONE
[10:24:16.608]  - Number of value chunks collected: 1
[10:24:16.608] Resolving 1 futures (chunks) ... DONE
[10:24:16.608] Reducing values from 1 chunks ...
[10:24:16.608]  - Number of values collected after concatenation: 3
[10:24:16.608]  - Number of values expected: 3
[10:24:16.608] Reducing values from 1 chunks ... DONE
[10:24:16.609] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[10:24:16.610] future_lapply() ...
[10:24:16.615] Number of chunks: 1
[10:24:16.615] getGlobalsAndPackagesXApply() ...
[10:24:16.615]  - future.globals: TRUE
[10:24:16.615] getGlobalsAndPackages() ...
[10:24:16.615] Searching for globals...
[10:24:16.620] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:24:16.620] Searching for globals ... DONE
[10:24:16.620] Resolving globals: FALSE
[10:24:16.621] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[10:24:16.621] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[10:24:16.621] - globals: [1] ‘FUN’
[10:24:16.621] - packages: [1] ‘stats’
[10:24:16.621] getGlobalsAndPackages() ... DONE
[10:24:16.621]  - globals found/used: [n=1] ‘FUN’
[10:24:16.621]  - needed namespaces: [n=1] ‘stats’
[10:24:16.622] Finding globals ... DONE
[10:24:16.622]  - use_args: TRUE
[10:24:16.622]  - Getting '...' globals ...
[10:24:16.622] resolve() on list ...
[10:24:16.622]  recursive: 0
[10:24:16.622]  length: 1
[10:24:16.622]  elements: ‘...’
[10:24:16.622]  length: 0 (resolved future 1)
[10:24:16.622] resolve() on list ... DONE
[10:24:16.623]    - '...' content: [n=0] 
[10:24:16.623] List of 1
[10:24:16.623]  $ ...: list()
[10:24:16.623]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.623]  - attr(*, "where")=List of 1
[10:24:16.623]   ..$ ...:<environment: 0x55b93d219050> 
[10:24:16.623]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.623]  - attr(*, "resolved")= logi TRUE
[10:24:16.623]  - attr(*, "total_size")= num NA
[10:24:16.625]  - Getting '...' globals ... DONE
[10:24:16.625] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:16.625] List of 2
[10:24:16.625]  $ ...future.FUN:function (x, na.rm = TRUE)  
[10:24:16.625]  $ ...          : list()
[10:24:16.625]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.625]  - attr(*, "where")=List of 2
[10:24:16.625]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.625]   ..$ ...          :<environment: 0x55b93d219050> 
[10:24:16.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.625]  - attr(*, "resolved")= logi FALSE
[10:24:16.625]  - attr(*, "total_size")= num 46960
[10:24:16.628] Packages to be attached in all futures: [n=1] ‘stats’
[10:24:16.628] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.628] Number of futures (= number of chunks): 1
[10:24:16.628] Launching 1 futures (chunks) ...
[10:24:16.628] Chunk #1 of 1 ...
[10:24:16.628]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.628] getGlobalsAndPackages() ...
[10:24:16.628] Searching for globals...
[10:24:16.629] 
[10:24:16.629] Searching for globals ... DONE
[10:24:16.629] - globals: [0] <none>
[10:24:16.629] getGlobalsAndPackages() ... DONE
[10:24:16.629]    + additional globals found: [n=0] 
[10:24:16.629]    + additional namespaces needed: [n=0] 
[10:24:16.629]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.629]  - seeds: <none>
[10:24:16.629]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.629] getGlobalsAndPackages() ...
[10:24:16.630] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.630] Resolving globals: FALSE
[10:24:16.630] Tweak future expression to call with '...' arguments ...
[10:24:16.630] {
[10:24:16.630]     do.call(function(...) {
[10:24:16.630]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.630]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.630]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.630]             on.exit(options(oopts), add = TRUE)
[10:24:16.630]         }
[10:24:16.630]         {
[10:24:16.630]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.630]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.630]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.630]             })
[10:24:16.630]         }
[10:24:16.630]     }, args = future.call.arguments)
[10:24:16.630] }
[10:24:16.630] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.631] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.631] - packages: [1] ‘stats’
[10:24:16.631] getGlobalsAndPackages() ... DONE
[10:24:16.632] run() for ‘Future’ ...
[10:24:16.632] - state: ‘created’
[10:24:16.632] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.632] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.632]   - Field: ‘label’
[10:24:16.632]   - Field: ‘local’
[10:24:16.633]   - Field: ‘owner’
[10:24:16.633]   - Field: ‘envir’
[10:24:16.633]   - Field: ‘packages’
[10:24:16.633]   - Field: ‘gc’
[10:24:16.633]   - Field: ‘conditions’
[10:24:16.633]   - Field: ‘expr’
[10:24:16.633]   - Field: ‘uuid’
[10:24:16.633]   - Field: ‘seed’
[10:24:16.633]   - Field: ‘version’
[10:24:16.633]   - Field: ‘result’
[10:24:16.634]   - Field: ‘asynchronous’
[10:24:16.634]   - Field: ‘calls’
[10:24:16.634]   - Field: ‘globals’
[10:24:16.634]   - Field: ‘stdout’
[10:24:16.634]   - Field: ‘earlySignal’
[10:24:16.634]   - Field: ‘lazy’
[10:24:16.634]   - Field: ‘state’
[10:24:16.634] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.634] - Launch lazy future ...
[10:24:16.634] Packages needed by the future expression (n = 1): ‘stats’
[10:24:16.635] Packages needed by future strategies (n = 0): <none>
[10:24:16.635] {
[10:24:16.635]     {
[10:24:16.635]         {
[10:24:16.635]             ...future.startTime <- base::Sys.time()
[10:24:16.635]             {
[10:24:16.635]                 {
[10:24:16.635]                   {
[10:24:16.635]                     {
[10:24:16.635]                       base::local({
[10:24:16.635]                         has_future <- base::requireNamespace("future", 
[10:24:16.635]                           quietly = TRUE)
[10:24:16.635]                         if (has_future) {
[10:24:16.635]                           ns <- base::getNamespace("future")
[10:24:16.635]                           version <- ns[[".package"]][["version"]]
[10:24:16.635]                           if (is.null(version)) 
[10:24:16.635]                             version <- utils::packageVersion("future")
[10:24:16.635]                         }
[10:24:16.635]                         else {
[10:24:16.635]                           version <- NULL
[10:24:16.635]                         }
[10:24:16.635]                         if (!has_future || version < "1.8.0") {
[10:24:16.635]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.635]                             "", base::R.version$version.string), 
[10:24:16.635]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.635]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.635]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.635]                               "release", "version")], collapse = " "), 
[10:24:16.635]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.635]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.635]                             info)
[10:24:16.635]                           info <- base::paste(info, collapse = "; ")
[10:24:16.635]                           if (!has_future) {
[10:24:16.635]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.635]                               info)
[10:24:16.635]                           }
[10:24:16.635]                           else {
[10:24:16.635]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.635]                               info, version)
[10:24:16.635]                           }
[10:24:16.635]                           base::stop(msg)
[10:24:16.635]                         }
[10:24:16.635]                       })
[10:24:16.635]                     }
[10:24:16.635]                     base::local({
[10:24:16.635]                       for (pkg in "stats") {
[10:24:16.635]                         base::loadNamespace(pkg)
[10:24:16.635]                         base::library(pkg, character.only = TRUE)
[10:24:16.635]                       }
[10:24:16.635]                     })
[10:24:16.635]                   }
[10:24:16.635]                   options(future.plan = NULL)
[10:24:16.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.635]                 }
[10:24:16.635]                 ...future.workdir <- getwd()
[10:24:16.635]             }
[10:24:16.635]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.635]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.635]         }
[10:24:16.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.635]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.635]             base::names(...future.oldOptions))
[10:24:16.635]     }
[10:24:16.635]     if (FALSE) {
[10:24:16.635]     }
[10:24:16.635]     else {
[10:24:16.635]         if (TRUE) {
[10:24:16.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.635]                 open = "w")
[10:24:16.635]         }
[10:24:16.635]         else {
[10:24:16.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.635]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.635]         }
[10:24:16.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.635]             base::sink(type = "output", split = FALSE)
[10:24:16.635]             base::close(...future.stdout)
[10:24:16.635]         }, add = TRUE)
[10:24:16.635]     }
[10:24:16.635]     ...future.frame <- base::sys.nframe()
[10:24:16.635]     ...future.conditions <- base::list()
[10:24:16.635]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.635]     if (FALSE) {
[10:24:16.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.635]     }
[10:24:16.635]     ...future.result <- base::tryCatch({
[10:24:16.635]         base::withCallingHandlers({
[10:24:16.635]             ...future.value <- base::withVisible(base::local({
[10:24:16.635]                 do.call(function(...) {
[10:24:16.635]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.635]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.635]                     ...future.globals.maxSize)) {
[10:24:16.635]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.635]                     on.exit(options(oopts), add = TRUE)
[10:24:16.635]                   }
[10:24:16.635]                   {
[10:24:16.635]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.635]                       FUN = function(jj) {
[10:24:16.635]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.635]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.635]                       })
[10:24:16.635]                   }
[10:24:16.635]                 }, args = future.call.arguments)
[10:24:16.635]             }))
[10:24:16.635]             future::FutureResult(value = ...future.value$value, 
[10:24:16.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.635]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.635]                     ...future.globalenv.names))
[10:24:16.635]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.635]         }, condition = base::local({
[10:24:16.635]             c <- base::c
[10:24:16.635]             inherits <- base::inherits
[10:24:16.635]             invokeRestart <- base::invokeRestart
[10:24:16.635]             length <- base::length
[10:24:16.635]             list <- base::list
[10:24:16.635]             seq.int <- base::seq.int
[10:24:16.635]             signalCondition <- base::signalCondition
[10:24:16.635]             sys.calls <- base::sys.calls
[10:24:16.635]             `[[` <- base::`[[`
[10:24:16.635]             `+` <- base::`+`
[10:24:16.635]             `<<-` <- base::`<<-`
[10:24:16.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.635]                   3L)]
[10:24:16.635]             }
[10:24:16.635]             function(cond) {
[10:24:16.635]                 is_error <- inherits(cond, "error")
[10:24:16.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.635]                   NULL)
[10:24:16.635]                 if (is_error) {
[10:24:16.635]                   sessionInformation <- function() {
[10:24:16.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.635]                       search = base::search(), system = base::Sys.info())
[10:24:16.635]                   }
[10:24:16.635]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.635]                     cond$call), session = sessionInformation(), 
[10:24:16.635]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.635]                   signalCondition(cond)
[10:24:16.635]                 }
[10:24:16.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.635]                 "immediateCondition"))) {
[10:24:16.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.635]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.635]                   if (TRUE && !signal) {
[10:24:16.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.635]                     {
[10:24:16.635]                       inherits <- base::inherits
[10:24:16.635]                       invokeRestart <- base::invokeRestart
[10:24:16.635]                       is.null <- base::is.null
[10:24:16.635]                       muffled <- FALSE
[10:24:16.635]                       if (inherits(cond, "message")) {
[10:24:16.635]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.635]                         if (muffled) 
[10:24:16.635]                           invokeRestart("muffleMessage")
[10:24:16.635]                       }
[10:24:16.635]                       else if (inherits(cond, "warning")) {
[10:24:16.635]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.635]                         if (muffled) 
[10:24:16.635]                           invokeRestart("muffleWarning")
[10:24:16.635]                       }
[10:24:16.635]                       else if (inherits(cond, "condition")) {
[10:24:16.635]                         if (!is.null(pattern)) {
[10:24:16.635]                           computeRestarts <- base::computeRestarts
[10:24:16.635]                           grepl <- base::grepl
[10:24:16.635]                           restarts <- computeRestarts(cond)
[10:24:16.635]                           for (restart in restarts) {
[10:24:16.635]                             name <- restart$name
[10:24:16.635]                             if (is.null(name)) 
[10:24:16.635]                               next
[10:24:16.635]                             if (!grepl(pattern, name)) 
[10:24:16.635]                               next
[10:24:16.635]                             invokeRestart(restart)
[10:24:16.635]                             muffled <- TRUE
[10:24:16.635]                             break
[10:24:16.635]                           }
[10:24:16.635]                         }
[10:24:16.635]                       }
[10:24:16.635]                       invisible(muffled)
[10:24:16.635]                     }
[10:24:16.635]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.635]                   }
[10:24:16.635]                 }
[10:24:16.635]                 else {
[10:24:16.635]                   if (TRUE) {
[10:24:16.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.635]                     {
[10:24:16.635]                       inherits <- base::inherits
[10:24:16.635]                       invokeRestart <- base::invokeRestart
[10:24:16.635]                       is.null <- base::is.null
[10:24:16.635]                       muffled <- FALSE
[10:24:16.635]                       if (inherits(cond, "message")) {
[10:24:16.635]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.635]                         if (muffled) 
[10:24:16.635]                           invokeRestart("muffleMessage")
[10:24:16.635]                       }
[10:24:16.635]                       else if (inherits(cond, "warning")) {
[10:24:16.635]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.635]                         if (muffled) 
[10:24:16.635]                           invokeRestart("muffleWarning")
[10:24:16.635]                       }
[10:24:16.635]                       else if (inherits(cond, "condition")) {
[10:24:16.635]                         if (!is.null(pattern)) {
[10:24:16.635]                           computeRestarts <- base::computeRestarts
[10:24:16.635]                           grepl <- base::grepl
[10:24:16.635]                           restarts <- computeRestarts(cond)
[10:24:16.635]                           for (restart in restarts) {
[10:24:16.635]                             name <- restart$name
[10:24:16.635]                             if (is.null(name)) 
[10:24:16.635]                               next
[10:24:16.635]                             if (!grepl(pattern, name)) 
[10:24:16.635]                               next
[10:24:16.635]                             invokeRestart(restart)
[10:24:16.635]                             muffled <- TRUE
[10:24:16.635]                             break
[10:24:16.635]                           }
[10:24:16.635]                         }
[10:24:16.635]                       }
[10:24:16.635]                       invisible(muffled)
[10:24:16.635]                     }
[10:24:16.635]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.635]                   }
[10:24:16.635]                 }
[10:24:16.635]             }
[10:24:16.635]         }))
[10:24:16.635]     }, error = function(ex) {
[10:24:16.635]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.635]                 ...future.rng), started = ...future.startTime, 
[10:24:16.635]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.635]             version = "1.8"), class = "FutureResult")
[10:24:16.635]     }, finally = {
[10:24:16.635]         if (!identical(...future.workdir, getwd())) 
[10:24:16.635]             setwd(...future.workdir)
[10:24:16.635]         {
[10:24:16.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.635]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.635]             }
[10:24:16.635]             base::options(...future.oldOptions)
[10:24:16.635]             if (.Platform$OS.type == "windows") {
[10:24:16.635]                 old_names <- names(...future.oldEnvVars)
[10:24:16.635]                 envs <- base::Sys.getenv()
[10:24:16.635]                 names <- names(envs)
[10:24:16.635]                 common <- intersect(names, old_names)
[10:24:16.635]                 added <- setdiff(names, old_names)
[10:24:16.635]                 removed <- setdiff(old_names, names)
[10:24:16.635]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.635]                   envs[common]]
[10:24:16.635]                 NAMES <- toupper(changed)
[10:24:16.635]                 args <- list()
[10:24:16.635]                 for (kk in seq_along(NAMES)) {
[10:24:16.635]                   name <- changed[[kk]]
[10:24:16.635]                   NAME <- NAMES[[kk]]
[10:24:16.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.635]                     next
[10:24:16.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.635]                 }
[10:24:16.635]                 NAMES <- toupper(added)
[10:24:16.635]                 for (kk in seq_along(NAMES)) {
[10:24:16.635]                   name <- added[[kk]]
[10:24:16.635]                   NAME <- NAMES[[kk]]
[10:24:16.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.635]                     next
[10:24:16.635]                   args[[name]] <- ""
[10:24:16.635]                 }
[10:24:16.635]                 NAMES <- toupper(removed)
[10:24:16.635]                 for (kk in seq_along(NAMES)) {
[10:24:16.635]                   name <- removed[[kk]]
[10:24:16.635]                   NAME <- NAMES[[kk]]
[10:24:16.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.635]                     next
[10:24:16.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.635]                 }
[10:24:16.635]                 if (length(args) > 0) 
[10:24:16.635]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.635]             }
[10:24:16.635]             else {
[10:24:16.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.635]             }
[10:24:16.635]             {
[10:24:16.635]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.635]                   0L) {
[10:24:16.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.635]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.635]                   base::options(opts)
[10:24:16.635]                 }
[10:24:16.635]                 {
[10:24:16.635]                   {
[10:24:16.635]                     NULL
[10:24:16.635]                     RNGkind("Mersenne-Twister")
[10:24:16.635]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.635]                       inherits = FALSE)
[10:24:16.635]                   }
[10:24:16.635]                   options(future.plan = NULL)
[10:24:16.635]                   if (is.na(NA_character_)) 
[10:24:16.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.635]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.635]                   {
[10:24:16.635]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.635]                     if (!future$lazy) 
[10:24:16.635]                       future <- run(future)
[10:24:16.635]                     invisible(future)
[10:24:16.635]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.635]                 }
[10:24:16.635]             }
[10:24:16.635]         }
[10:24:16.635]     })
[10:24:16.635]     if (TRUE) {
[10:24:16.635]         base::sink(type = "output", split = FALSE)
[10:24:16.635]         if (TRUE) {
[10:24:16.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.635]         }
[10:24:16.635]         else {
[10:24:16.635]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.635]         }
[10:24:16.635]         base::close(...future.stdout)
[10:24:16.635]         ...future.stdout <- NULL
[10:24:16.635]     }
[10:24:16.635]     ...future.result$conditions <- ...future.conditions
[10:24:16.635]     ...future.result$finished <- base::Sys.time()
[10:24:16.635]     ...future.result
[10:24:16.635] }
[10:24:16.637] assign_globals() ...
[10:24:16.637] List of 5
[10:24:16.637]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[10:24:16.637]  $ future.call.arguments    : list()
[10:24:16.637]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.637]  $ ...future.elements_ii    :List of 7
[10:24:16.637]   ..$ : int [1:3] 1 2 3
[10:24:16.637]   ..$ : int [1:4] 1 2 3 4
[10:24:16.637]   ..$ : int [1:5] 1 2 3 4 5
[10:24:16.637]   ..$ : int [1:6] 1 2 3 4 5 6
[10:24:16.637]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:24:16.637]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:24:16.637]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:24:16.637]  $ ...future.seeds_ii       : NULL
[10:24:16.637]  $ ...future.globals.maxSize: NULL
[10:24:16.637]  - attr(*, "where")=List of 5
[10:24:16.637]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.637]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.637]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.637]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.637]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.637]  - attr(*, "resolved")= logi FALSE
[10:24:16.637]  - attr(*, "total_size")= num 46960
[10:24:16.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.637]  - attr(*, "already-done")= logi TRUE
[10:24:16.643] - copied ‘...future.FUN’ to environment
[10:24:16.643] - copied ‘future.call.arguments’ to environment
[10:24:16.643] - copied ‘...future.elements_ii’ to environment
[10:24:16.643] - copied ‘...future.seeds_ii’ to environment
[10:24:16.643] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.643] assign_globals() ... done
[10:24:16.644] plan(): Setting new future strategy stack:
[10:24:16.644] List of future strategies:
[10:24:16.644] 1. sequential:
[10:24:16.644]    - args: function (..., envir = parent.frame())
[10:24:16.644]    - tweaked: FALSE
[10:24:16.644]    - call: NULL
[10:24:16.644] plan(): nbrOfWorkers() = 1
[10:24:16.645] plan(): Setting new future strategy stack:
[10:24:16.645] List of future strategies:
[10:24:16.645] 1. sequential:
[10:24:16.645]    - args: function (..., envir = parent.frame())
[10:24:16.645]    - tweaked: FALSE
[10:24:16.645]    - call: plan(strategy)
[10:24:16.645] plan(): nbrOfWorkers() = 1
[10:24:16.645] SequentialFuture started (and completed)
[10:24:16.645] - Launch lazy future ... done
[10:24:16.646] run() for ‘SequentialFuture’ ... done
[10:24:16.646] Created future:
[10:24:16.646] SequentialFuture:
[10:24:16.646] Label: ‘future_sapply-1’
[10:24:16.646] Expression:
[10:24:16.646] {
[10:24:16.646]     do.call(function(...) {
[10:24:16.646]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.646]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.646]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.646]             on.exit(options(oopts), add = TRUE)
[10:24:16.646]         }
[10:24:16.646]         {
[10:24:16.646]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.646]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.646]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.646]             })
[10:24:16.646]         }
[10:24:16.646]     }, args = future.call.arguments)
[10:24:16.646] }
[10:24:16.646] Lazy evaluation: FALSE
[10:24:16.646] Asynchronous evaluation: FALSE
[10:24:16.646] Local evaluation: TRUE
[10:24:16.646] Environment: R_GlobalEnv
[10:24:16.646] Capture standard output: TRUE
[10:24:16.646] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.646] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:16.646] Packages: 1 packages (‘stats’)
[10:24:16.646] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.646] Resolved: TRUE
[10:24:16.646] Value: 672 bytes of class ‘list’
[10:24:16.646] Early signaling: FALSE
[10:24:16.646] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.646] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.647] Chunk #1 of 1 ... DONE
[10:24:16.647] Launching 1 futures (chunks) ... DONE
[10:24:16.647] Resolving 1 futures (chunks) ...
[10:24:16.647] resolve() on list ...
[10:24:16.647]  recursive: 0
[10:24:16.647]  length: 1
[10:24:16.647] 
[10:24:16.647] resolved() for ‘SequentialFuture’ ...
[10:24:16.647] - state: ‘finished’
[10:24:16.648] - run: TRUE
[10:24:16.648] - result: ‘FutureResult’
[10:24:16.648] resolved() for ‘SequentialFuture’ ... done
[10:24:16.648] Future #1
[10:24:16.648] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.648] - nx: 1
[10:24:16.648] - relay: TRUE
[10:24:16.648] - stdout: TRUE
[10:24:16.648] - signal: TRUE
[10:24:16.648] - resignal: FALSE
[10:24:16.648] - force: TRUE
[10:24:16.648] - relayed: [n=1] FALSE
[10:24:16.649] - queued futures: [n=1] FALSE
[10:24:16.649]  - until=1
[10:24:16.649]  - relaying element #1
[10:24:16.649] - relayed: [n=1] TRUE
[10:24:16.649] - queued futures: [n=1] TRUE
[10:24:16.649] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.649]  length: 0 (resolved future 1)
[10:24:16.649] Relaying remaining futures
[10:24:16.649] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.649] - nx: 1
[10:24:16.650] - relay: TRUE
[10:24:16.650] - stdout: TRUE
[10:24:16.650] - signal: TRUE
[10:24:16.650] - resignal: FALSE
[10:24:16.650] - force: TRUE
[10:24:16.650] - relayed: [n=1] TRUE
[10:24:16.650] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.650] - relayed: [n=1] TRUE
[10:24:16.650] - queued futures: [n=1] TRUE
[10:24:16.650] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.650] resolve() on list ... DONE
[10:24:16.651]  - Number of value chunks collected: 1
[10:24:16.651] Resolving 1 futures (chunks) ... DONE
[10:24:16.651] Reducing values from 1 chunks ...
[10:24:16.651]  - Number of values collected after concatenation: 7
[10:24:16.651]  - Number of values expected: 7
[10:24:16.651] Reducing values from 1 chunks ... DONE
[10:24:16.651] future_lapply() ... DONE
[10:24:16.651] future_lapply() ...
[10:24:16.654] Number of chunks: 1
[10:24:16.654] getGlobalsAndPackagesXApply() ...
[10:24:16.654]  - future.globals: TRUE
[10:24:16.654] getGlobalsAndPackages() ...
[10:24:16.654] Searching for globals...
[10:24:16.661] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:24:16.661] Searching for globals ... DONE
[10:24:16.661] Resolving globals: FALSE
[10:24:16.663] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[10:24:16.663] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[10:24:16.663] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.663] - packages: [2] ‘stats’, ‘future.apply’
[10:24:16.663] getGlobalsAndPackages() ... DONE
[10:24:16.663]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.663]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:24:16.664] Finding globals ... DONE
[10:24:16.664]  - use_args: TRUE
[10:24:16.664]  - Getting '...' globals ...
[10:24:16.664] resolve() on list ...
[10:24:16.664]  recursive: 0
[10:24:16.664]  length: 1
[10:24:16.664]  elements: ‘...’
[10:24:16.664]  length: 0 (resolved future 1)
[10:24:16.664] resolve() on list ... DONE
[10:24:16.665]    - '...' content: [n=0] 
[10:24:16.665] List of 1
[10:24:16.665]  $ ...: list()
[10:24:16.665]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.665]  - attr(*, "where")=List of 1
[10:24:16.665]   ..$ ...:<environment: 0x55b93d225280> 
[10:24:16.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.665]  - attr(*, "resolved")= logi TRUE
[10:24:16.665]  - attr(*, "total_size")= num NA
[10:24:16.667]  - Getting '...' globals ... DONE
[10:24:16.667] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.667] List of 8
[10:24:16.667]  $ ...future.FUN:function (x, ...)  
[10:24:16.667]  $ x_FUN        :function (x, na.rm = TRUE)  
[10:24:16.667]  $ times        : int 5
[10:24:16.667]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.667]  $ stop_if_not  :function (...)  
[10:24:16.667]  $ dim          : NULL
[10:24:16.667]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:16.667]  $ ...          : list()
[10:24:16.667]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.667]  - attr(*, "where")=List of 8
[10:24:16.667]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.667]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.667]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.667]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.667]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.667]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.667]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.667]   ..$ ...          :<environment: 0x55b93d225280> 
[10:24:16.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.667]  - attr(*, "resolved")= logi FALSE
[10:24:16.667]  - attr(*, "total_size")= num 141240
[10:24:16.673] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:24:16.673] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.674] Number of futures (= number of chunks): 1
[10:24:16.674] Launching 1 futures (chunks) ...
[10:24:16.674] Chunk #1 of 1 ...
[10:24:16.674]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.674] getGlobalsAndPackages() ...
[10:24:16.674] Searching for globals...
[10:24:16.674] 
[10:24:16.674] Searching for globals ... DONE
[10:24:16.674] - globals: [0] <none>
[10:24:16.675] getGlobalsAndPackages() ... DONE
[10:24:16.675]    + additional globals found: [n=0] 
[10:24:16.675]    + additional namespaces needed: [n=0] 
[10:24:16.675]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.675]  - seeds: <none>
[10:24:16.675]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.675] getGlobalsAndPackages() ...
[10:24:16.675] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.675] Resolving globals: FALSE
[10:24:16.675] Tweak future expression to call with '...' arguments ...
[10:24:16.676] {
[10:24:16.676]     do.call(function(...) {
[10:24:16.676]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.676]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.676]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.676]             on.exit(options(oopts), add = TRUE)
[10:24:16.676]         }
[10:24:16.676]         {
[10:24:16.676]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.676]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.676]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.676]             })
[10:24:16.676]         }
[10:24:16.676]     }, args = future.call.arguments)
[10:24:16.676] }
[10:24:16.676] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.676] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.676] - packages: [2] ‘stats’, ‘future.apply’
[10:24:16.676] getGlobalsAndPackages() ... DONE
[10:24:16.677] run() for ‘Future’ ...
[10:24:16.677] - state: ‘created’
[10:24:16.677] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.677] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.677] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.677]   - Field: ‘label’
[10:24:16.678]   - Field: ‘local’
[10:24:16.678]   - Field: ‘owner’
[10:24:16.678]   - Field: ‘envir’
[10:24:16.678]   - Field: ‘packages’
[10:24:16.678]   - Field: ‘gc’
[10:24:16.678]   - Field: ‘conditions’
[10:24:16.678]   - Field: ‘expr’
[10:24:16.678]   - Field: ‘uuid’
[10:24:16.678]   - Field: ‘seed’
[10:24:16.678]   - Field: ‘version’
[10:24:16.678]   - Field: ‘result’
[10:24:16.679]   - Field: ‘asynchronous’
[10:24:16.679]   - Field: ‘calls’
[10:24:16.679]   - Field: ‘globals’
[10:24:16.679]   - Field: ‘stdout’
[10:24:16.679]   - Field: ‘earlySignal’
[10:24:16.679]   - Field: ‘lazy’
[10:24:16.679]   - Field: ‘state’
[10:24:16.679] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.679] - Launch lazy future ...
[10:24:16.679] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:24:16.679] Packages needed by future strategies (n = 0): <none>
[10:24:16.680] {
[10:24:16.680]     {
[10:24:16.680]         {
[10:24:16.680]             ...future.startTime <- base::Sys.time()
[10:24:16.680]             {
[10:24:16.680]                 {
[10:24:16.680]                   {
[10:24:16.680]                     {
[10:24:16.680]                       base::local({
[10:24:16.680]                         has_future <- base::requireNamespace("future", 
[10:24:16.680]                           quietly = TRUE)
[10:24:16.680]                         if (has_future) {
[10:24:16.680]                           ns <- base::getNamespace("future")
[10:24:16.680]                           version <- ns[[".package"]][["version"]]
[10:24:16.680]                           if (is.null(version)) 
[10:24:16.680]                             version <- utils::packageVersion("future")
[10:24:16.680]                         }
[10:24:16.680]                         else {
[10:24:16.680]                           version <- NULL
[10:24:16.680]                         }
[10:24:16.680]                         if (!has_future || version < "1.8.0") {
[10:24:16.680]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.680]                             "", base::R.version$version.string), 
[10:24:16.680]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.680]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.680]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.680]                               "release", "version")], collapse = " "), 
[10:24:16.680]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.680]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.680]                             info)
[10:24:16.680]                           info <- base::paste(info, collapse = "; ")
[10:24:16.680]                           if (!has_future) {
[10:24:16.680]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.680]                               info)
[10:24:16.680]                           }
[10:24:16.680]                           else {
[10:24:16.680]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.680]                               info, version)
[10:24:16.680]                           }
[10:24:16.680]                           base::stop(msg)
[10:24:16.680]                         }
[10:24:16.680]                       })
[10:24:16.680]                     }
[10:24:16.680]                     base::local({
[10:24:16.680]                       for (pkg in c("stats", "future.apply")) {
[10:24:16.680]                         base::loadNamespace(pkg)
[10:24:16.680]                         base::library(pkg, character.only = TRUE)
[10:24:16.680]                       }
[10:24:16.680]                     })
[10:24:16.680]                   }
[10:24:16.680]                   options(future.plan = NULL)
[10:24:16.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.680]                 }
[10:24:16.680]                 ...future.workdir <- getwd()
[10:24:16.680]             }
[10:24:16.680]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.680]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.680]         }
[10:24:16.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.680]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.680]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.680]             base::names(...future.oldOptions))
[10:24:16.680]     }
[10:24:16.680]     if (FALSE) {
[10:24:16.680]     }
[10:24:16.680]     else {
[10:24:16.680]         if (TRUE) {
[10:24:16.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.680]                 open = "w")
[10:24:16.680]         }
[10:24:16.680]         else {
[10:24:16.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.680]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.680]         }
[10:24:16.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.680]             base::sink(type = "output", split = FALSE)
[10:24:16.680]             base::close(...future.stdout)
[10:24:16.680]         }, add = TRUE)
[10:24:16.680]     }
[10:24:16.680]     ...future.frame <- base::sys.nframe()
[10:24:16.680]     ...future.conditions <- base::list()
[10:24:16.680]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.680]     if (FALSE) {
[10:24:16.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.680]     }
[10:24:16.680]     ...future.result <- base::tryCatch({
[10:24:16.680]         base::withCallingHandlers({
[10:24:16.680]             ...future.value <- base::withVisible(base::local({
[10:24:16.680]                 do.call(function(...) {
[10:24:16.680]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.680]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.680]                     ...future.globals.maxSize)) {
[10:24:16.680]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.680]                     on.exit(options(oopts), add = TRUE)
[10:24:16.680]                   }
[10:24:16.680]                   {
[10:24:16.680]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.680]                       FUN = function(jj) {
[10:24:16.680]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.680]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.680]                       })
[10:24:16.680]                   }
[10:24:16.680]                 }, args = future.call.arguments)
[10:24:16.680]             }))
[10:24:16.680]             future::FutureResult(value = ...future.value$value, 
[10:24:16.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.680]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.680]                     ...future.globalenv.names))
[10:24:16.680]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.680]         }, condition = base::local({
[10:24:16.680]             c <- base::c
[10:24:16.680]             inherits <- base::inherits
[10:24:16.680]             invokeRestart <- base::invokeRestart
[10:24:16.680]             length <- base::length
[10:24:16.680]             list <- base::list
[10:24:16.680]             seq.int <- base::seq.int
[10:24:16.680]             signalCondition <- base::signalCondition
[10:24:16.680]             sys.calls <- base::sys.calls
[10:24:16.680]             `[[` <- base::`[[`
[10:24:16.680]             `+` <- base::`+`
[10:24:16.680]             `<<-` <- base::`<<-`
[10:24:16.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.680]                   3L)]
[10:24:16.680]             }
[10:24:16.680]             function(cond) {
[10:24:16.680]                 is_error <- inherits(cond, "error")
[10:24:16.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.680]                   NULL)
[10:24:16.680]                 if (is_error) {
[10:24:16.680]                   sessionInformation <- function() {
[10:24:16.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.680]                       search = base::search(), system = base::Sys.info())
[10:24:16.680]                   }
[10:24:16.680]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.680]                     cond$call), session = sessionInformation(), 
[10:24:16.680]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.680]                   signalCondition(cond)
[10:24:16.680]                 }
[10:24:16.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.680]                 "immediateCondition"))) {
[10:24:16.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.680]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.680]                   if (TRUE && !signal) {
[10:24:16.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.680]                     {
[10:24:16.680]                       inherits <- base::inherits
[10:24:16.680]                       invokeRestart <- base::invokeRestart
[10:24:16.680]                       is.null <- base::is.null
[10:24:16.680]                       muffled <- FALSE
[10:24:16.680]                       if (inherits(cond, "message")) {
[10:24:16.680]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.680]                         if (muffled) 
[10:24:16.680]                           invokeRestart("muffleMessage")
[10:24:16.680]                       }
[10:24:16.680]                       else if (inherits(cond, "warning")) {
[10:24:16.680]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.680]                         if (muffled) 
[10:24:16.680]                           invokeRestart("muffleWarning")
[10:24:16.680]                       }
[10:24:16.680]                       else if (inherits(cond, "condition")) {
[10:24:16.680]                         if (!is.null(pattern)) {
[10:24:16.680]                           computeRestarts <- base::computeRestarts
[10:24:16.680]                           grepl <- base::grepl
[10:24:16.680]                           restarts <- computeRestarts(cond)
[10:24:16.680]                           for (restart in restarts) {
[10:24:16.680]                             name <- restart$name
[10:24:16.680]                             if (is.null(name)) 
[10:24:16.680]                               next
[10:24:16.680]                             if (!grepl(pattern, name)) 
[10:24:16.680]                               next
[10:24:16.680]                             invokeRestart(restart)
[10:24:16.680]                             muffled <- TRUE
[10:24:16.680]                             break
[10:24:16.680]                           }
[10:24:16.680]                         }
[10:24:16.680]                       }
[10:24:16.680]                       invisible(muffled)
[10:24:16.680]                     }
[10:24:16.680]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.680]                   }
[10:24:16.680]                 }
[10:24:16.680]                 else {
[10:24:16.680]                   if (TRUE) {
[10:24:16.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.680]                     {
[10:24:16.680]                       inherits <- base::inherits
[10:24:16.680]                       invokeRestart <- base::invokeRestart
[10:24:16.680]                       is.null <- base::is.null
[10:24:16.680]                       muffled <- FALSE
[10:24:16.680]                       if (inherits(cond, "message")) {
[10:24:16.680]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.680]                         if (muffled) 
[10:24:16.680]                           invokeRestart("muffleMessage")
[10:24:16.680]                       }
[10:24:16.680]                       else if (inherits(cond, "warning")) {
[10:24:16.680]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.680]                         if (muffled) 
[10:24:16.680]                           invokeRestart("muffleWarning")
[10:24:16.680]                       }
[10:24:16.680]                       else if (inherits(cond, "condition")) {
[10:24:16.680]                         if (!is.null(pattern)) {
[10:24:16.680]                           computeRestarts <- base::computeRestarts
[10:24:16.680]                           grepl <- base::grepl
[10:24:16.680]                           restarts <- computeRestarts(cond)
[10:24:16.680]                           for (restart in restarts) {
[10:24:16.680]                             name <- restart$name
[10:24:16.680]                             if (is.null(name)) 
[10:24:16.680]                               next
[10:24:16.680]                             if (!grepl(pattern, name)) 
[10:24:16.680]                               next
[10:24:16.680]                             invokeRestart(restart)
[10:24:16.680]                             muffled <- TRUE
[10:24:16.680]                             break
[10:24:16.680]                           }
[10:24:16.680]                         }
[10:24:16.680]                       }
[10:24:16.680]                       invisible(muffled)
[10:24:16.680]                     }
[10:24:16.680]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.680]                   }
[10:24:16.680]                 }
[10:24:16.680]             }
[10:24:16.680]         }))
[10:24:16.680]     }, error = function(ex) {
[10:24:16.680]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.680]                 ...future.rng), started = ...future.startTime, 
[10:24:16.680]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.680]             version = "1.8"), class = "FutureResult")
[10:24:16.680]     }, finally = {
[10:24:16.680]         if (!identical(...future.workdir, getwd())) 
[10:24:16.680]             setwd(...future.workdir)
[10:24:16.680]         {
[10:24:16.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.680]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.680]             }
[10:24:16.680]             base::options(...future.oldOptions)
[10:24:16.680]             if (.Platform$OS.type == "windows") {
[10:24:16.680]                 old_names <- names(...future.oldEnvVars)
[10:24:16.680]                 envs <- base::Sys.getenv()
[10:24:16.680]                 names <- names(envs)
[10:24:16.680]                 common <- intersect(names, old_names)
[10:24:16.680]                 added <- setdiff(names, old_names)
[10:24:16.680]                 removed <- setdiff(old_names, names)
[10:24:16.680]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.680]                   envs[common]]
[10:24:16.680]                 NAMES <- toupper(changed)
[10:24:16.680]                 args <- list()
[10:24:16.680]                 for (kk in seq_along(NAMES)) {
[10:24:16.680]                   name <- changed[[kk]]
[10:24:16.680]                   NAME <- NAMES[[kk]]
[10:24:16.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.680]                     next
[10:24:16.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.680]                 }
[10:24:16.680]                 NAMES <- toupper(added)
[10:24:16.680]                 for (kk in seq_along(NAMES)) {
[10:24:16.680]                   name <- added[[kk]]
[10:24:16.680]                   NAME <- NAMES[[kk]]
[10:24:16.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.680]                     next
[10:24:16.680]                   args[[name]] <- ""
[10:24:16.680]                 }
[10:24:16.680]                 NAMES <- toupper(removed)
[10:24:16.680]                 for (kk in seq_along(NAMES)) {
[10:24:16.680]                   name <- removed[[kk]]
[10:24:16.680]                   NAME <- NAMES[[kk]]
[10:24:16.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.680]                     next
[10:24:16.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.680]                 }
[10:24:16.680]                 if (length(args) > 0) 
[10:24:16.680]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.680]             }
[10:24:16.680]             else {
[10:24:16.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.680]             }
[10:24:16.680]             {
[10:24:16.680]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.680]                   0L) {
[10:24:16.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.680]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.680]                   base::options(opts)
[10:24:16.680]                 }
[10:24:16.680]                 {
[10:24:16.680]                   {
[10:24:16.680]                     NULL
[10:24:16.680]                     RNGkind("Mersenne-Twister")
[10:24:16.680]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.680]                       inherits = FALSE)
[10:24:16.680]                   }
[10:24:16.680]                   options(future.plan = NULL)
[10:24:16.680]                   if (is.na(NA_character_)) 
[10:24:16.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.680]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.680]                   {
[10:24:16.680]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.680]                     if (!future$lazy) 
[10:24:16.680]                       future <- run(future)
[10:24:16.680]                     invisible(future)
[10:24:16.680]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.680]                 }
[10:24:16.680]             }
[10:24:16.680]         }
[10:24:16.680]     })
[10:24:16.680]     if (TRUE) {
[10:24:16.680]         base::sink(type = "output", split = FALSE)
[10:24:16.680]         if (TRUE) {
[10:24:16.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.680]         }
[10:24:16.680]         else {
[10:24:16.680]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.680]         }
[10:24:16.680]         base::close(...future.stdout)
[10:24:16.680]         ...future.stdout <- NULL
[10:24:16.680]     }
[10:24:16.680]     ...future.result$conditions <- ...future.conditions
[10:24:16.680]     ...future.result$finished <- base::Sys.time()
[10:24:16.680]     ...future.result
[10:24:16.680] }
[10:24:16.682] assign_globals() ...
[10:24:16.682] List of 11
[10:24:16.682]  $ ...future.FUN            :function (x, ...)  
[10:24:16.682]  $ x_FUN                    :function (x, na.rm = TRUE)  
[10:24:16.682]  $ times                    : int 5
[10:24:16.682]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.682]  $ stop_if_not              :function (...)  
[10:24:16.682]  $ dim                      : NULL
[10:24:16.682]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:16.682]  $ future.call.arguments    : list()
[10:24:16.682]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.682]  $ ...future.elements_ii    :List of 7
[10:24:16.682]   ..$ : int [1:3] 1 2 3
[10:24:16.682]   ..$ : int [1:4] 1 2 3 4
[10:24:16.682]   ..$ : int [1:5] 1 2 3 4 5
[10:24:16.682]   ..$ : int [1:6] 1 2 3 4 5 6
[10:24:16.682]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:24:16.682]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:24:16.682]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:24:16.682]  $ ...future.seeds_ii       : NULL
[10:24:16.682]  $ ...future.globals.maxSize: NULL
[10:24:16.682]  - attr(*, "where")=List of 11
[10:24:16.682]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.682]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.682]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.682]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.682]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.682]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.682]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.682]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.682]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.682]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.682]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.682]  - attr(*, "resolved")= logi FALSE
[10:24:16.682]  - attr(*, "total_size")= num 141240
[10:24:16.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.682]  - attr(*, "already-done")= logi TRUE
[10:24:16.690] - copied ‘...future.FUN’ to environment
[10:24:16.690] - copied ‘x_FUN’ to environment
[10:24:16.691] - copied ‘times’ to environment
[10:24:16.691] - copied ‘stopf’ to environment
[10:24:16.691] - copied ‘stop_if_not’ to environment
[10:24:16.691] - copied ‘dim’ to environment
[10:24:16.691] - copied ‘valid_types’ to environment
[10:24:16.691] - copied ‘future.call.arguments’ to environment
[10:24:16.691] - copied ‘...future.elements_ii’ to environment
[10:24:16.691] - copied ‘...future.seeds_ii’ to environment
[10:24:16.691] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.691] assign_globals() ... done
[10:24:16.692] plan(): Setting new future strategy stack:
[10:24:16.693] List of future strategies:
[10:24:16.693] 1. sequential:
[10:24:16.693]    - args: function (..., envir = parent.frame())
[10:24:16.693]    - tweaked: FALSE
[10:24:16.693]    - call: NULL
[10:24:16.693] plan(): nbrOfWorkers() = 1
[10:24:16.694] plan(): Setting new future strategy stack:
[10:24:16.694] List of future strategies:
[10:24:16.694] 1. sequential:
[10:24:16.694]    - args: function (..., envir = parent.frame())
[10:24:16.694]    - tweaked: FALSE
[10:24:16.694]    - call: plan(strategy)
[10:24:16.694] plan(): nbrOfWorkers() = 1
[10:24:16.695] SequentialFuture started (and completed)
[10:24:16.695] - Launch lazy future ... done
[10:24:16.695] run() for ‘SequentialFuture’ ... done
[10:24:16.695] Created future:
[10:24:16.695] SequentialFuture:
[10:24:16.695] Label: ‘future_vapply-1’
[10:24:16.695] Expression:
[10:24:16.695] {
[10:24:16.695]     do.call(function(...) {
[10:24:16.695]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.695]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.695]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.695]             on.exit(options(oopts), add = TRUE)
[10:24:16.695]         }
[10:24:16.695]         {
[10:24:16.695]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.695]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.695]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.695]             })
[10:24:16.695]         }
[10:24:16.695]     }, args = future.call.arguments)
[10:24:16.695] }
[10:24:16.695] Lazy evaluation: FALSE
[10:24:16.695] Asynchronous evaluation: FALSE
[10:24:16.695] Local evaluation: TRUE
[10:24:16.695] Environment: R_GlobalEnv
[10:24:16.695] Capture standard output: TRUE
[10:24:16.695] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.695] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.695] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:24:16.695] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.695] Resolved: TRUE
[10:24:16.695] Value: 672 bytes of class ‘list’
[10:24:16.695] Early signaling: FALSE
[10:24:16.695] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.695] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.696] Chunk #1 of 1 ... DONE
[10:24:16.696] Launching 1 futures (chunks) ... DONE
[10:24:16.696] Resolving 1 futures (chunks) ...
[10:24:16.696] resolve() on list ...
[10:24:16.696]  recursive: 0
[10:24:16.696]  length: 1
[10:24:16.697] 
[10:24:16.697] resolved() for ‘SequentialFuture’ ...
[10:24:16.697] - state: ‘finished’
[10:24:16.697] - run: TRUE
[10:24:16.697] - result: ‘FutureResult’
[10:24:16.697] resolved() for ‘SequentialFuture’ ... done
[10:24:16.697] Future #1
[10:24:16.697] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.697] - nx: 1
[10:24:16.697] - relay: TRUE
[10:24:16.698] - stdout: TRUE
[10:24:16.698] - signal: TRUE
[10:24:16.698] - resignal: FALSE
[10:24:16.698] - force: TRUE
[10:24:16.698] - relayed: [n=1] FALSE
[10:24:16.698] - queued futures: [n=1] FALSE
[10:24:16.698]  - until=1
[10:24:16.698]  - relaying element #1
[10:24:16.698] - relayed: [n=1] TRUE
[10:24:16.698] - queued futures: [n=1] TRUE
[10:24:16.698] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.699]  length: 0 (resolved future 1)
[10:24:16.699] Relaying remaining futures
[10:24:16.699] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.699] - nx: 1
[10:24:16.699] - relay: TRUE
[10:24:16.699] - stdout: TRUE
[10:24:16.699] - signal: TRUE
[10:24:16.699] - resignal: FALSE
[10:24:16.699] - force: TRUE
[10:24:16.699] - relayed: [n=1] TRUE
[10:24:16.699] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.699] - relayed: [n=1] TRUE
[10:24:16.700] - queued futures: [n=1] TRUE
[10:24:16.700] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.700] resolve() on list ... DONE
[10:24:16.700]  - Number of value chunks collected: 1
[10:24:16.700] Resolving 1 futures (chunks) ... DONE
[10:24:16.700] Reducing values from 1 chunks ...
[10:24:16.700]  - Number of values collected after concatenation: 7
[10:24:16.700]  - Number of values expected: 7
[10:24:16.700] Reducing values from 1 chunks ... DONE
[10:24:16.700] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[10:24:16.702] future_lapply() ...
[10:24:16.702] Number of chunks: 1
[10:24:16.703] getGlobalsAndPackagesXApply() ...
[10:24:16.703]  - future.globals: TRUE
[10:24:16.703] getGlobalsAndPackages() ...
[10:24:16.703] Searching for globals...
[10:24:16.704] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[10:24:16.704] Searching for globals ... DONE
[10:24:16.704] Resolving globals: FALSE
[10:24:16.704] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[10:24:16.705] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[10:24:16.705] - globals: [1] ‘FUN’
[10:24:16.705] 
[10:24:16.705] getGlobalsAndPackages() ... DONE
[10:24:16.705]  - globals found/used: [n=1] ‘FUN’
[10:24:16.705]  - needed namespaces: [n=0] 
[10:24:16.705] Finding globals ... DONE
[10:24:16.705]  - use_args: TRUE
[10:24:16.706]  - Getting '...' globals ...
[10:24:16.706] resolve() on list ...
[10:24:16.706]  recursive: 0
[10:24:16.706]  length: 1
[10:24:16.706]  elements: ‘...’
[10:24:16.706]  length: 0 (resolved future 1)
[10:24:16.706] resolve() on list ... DONE
[10:24:16.706]    - '...' content: [n=1] ‘y’
[10:24:16.706] List of 1
[10:24:16.706]  $ ...:List of 1
[10:24:16.706]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:16.706]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.706]  - attr(*, "where")=List of 1
[10:24:16.706]   ..$ ...:<environment: 0x55b93c50d298> 
[10:24:16.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.706]  - attr(*, "resolved")= logi TRUE
[10:24:16.706]  - attr(*, "total_size")= num NA
[10:24:16.709]  - Getting '...' globals ... DONE
[10:24:16.709] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:16.709] List of 2
[10:24:16.709]  $ ...future.FUN:function (x, y)  
[10:24:16.709]  $ ...          :List of 1
[10:24:16.709]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:16.709]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.709]  - attr(*, "where")=List of 2
[10:24:16.709]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.709]   ..$ ...          :<environment: 0x55b93c50d298> 
[10:24:16.709]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.709]  - attr(*, "resolved")= logi FALSE
[10:24:16.709]  - attr(*, "total_size")= num 4264
[10:24:16.712] Packages to be attached in all futures: [n=0] 
[10:24:16.712] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.713] Number of futures (= number of chunks): 1
[10:24:16.714] Launching 1 futures (chunks) ...
[10:24:16.714] Chunk #1 of 1 ...
[10:24:16.714]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.714] getGlobalsAndPackages() ...
[10:24:16.714] Searching for globals...
[10:24:16.714] 
[10:24:16.714] Searching for globals ... DONE
[10:24:16.714] - globals: [0] <none>
[10:24:16.714] getGlobalsAndPackages() ... DONE
[10:24:16.715]    + additional globals found: [n=0] 
[10:24:16.715]    + additional namespaces needed: [n=0] 
[10:24:16.715]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.715]  - seeds: <none>
[10:24:16.715]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.715] getGlobalsAndPackages() ...
[10:24:16.715] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.715] Resolving globals: FALSE
[10:24:16.715] Tweak future expression to call with '...' arguments ...
[10:24:16.715] {
[10:24:16.715]     do.call(function(...) {
[10:24:16.715]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.715]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.715]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.715]             on.exit(options(oopts), add = TRUE)
[10:24:16.715]         }
[10:24:16.715]         {
[10:24:16.715]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.715]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.715]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.715]             })
[10:24:16.715]         }
[10:24:16.715]     }, args = future.call.arguments)
[10:24:16.715] }
[10:24:16.716] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.716] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.716] 
[10:24:16.716] getGlobalsAndPackages() ... DONE
[10:24:16.716] run() for ‘Future’ ...
[10:24:16.717] - state: ‘created’
[10:24:16.717] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.717] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.717]   - Field: ‘label’
[10:24:16.717]   - Field: ‘local’
[10:24:16.717]   - Field: ‘owner’
[10:24:16.717]   - Field: ‘envir’
[10:24:16.718]   - Field: ‘packages’
[10:24:16.718]   - Field: ‘gc’
[10:24:16.718]   - Field: ‘conditions’
[10:24:16.718]   - Field: ‘expr’
[10:24:16.718]   - Field: ‘uuid’
[10:24:16.718]   - Field: ‘seed’
[10:24:16.718]   - Field: ‘version’
[10:24:16.718]   - Field: ‘result’
[10:24:16.718]   - Field: ‘asynchronous’
[10:24:16.718]   - Field: ‘calls’
[10:24:16.718]   - Field: ‘globals’
[10:24:16.719]   - Field: ‘stdout’
[10:24:16.719]   - Field: ‘earlySignal’
[10:24:16.719]   - Field: ‘lazy’
[10:24:16.719]   - Field: ‘state’
[10:24:16.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.719] - Launch lazy future ...
[10:24:16.719] Packages needed by the future expression (n = 0): <none>
[10:24:16.719] Packages needed by future strategies (n = 0): <none>
[10:24:16.720] {
[10:24:16.720]     {
[10:24:16.720]         {
[10:24:16.720]             ...future.startTime <- base::Sys.time()
[10:24:16.720]             {
[10:24:16.720]                 {
[10:24:16.720]                   {
[10:24:16.720]                     base::local({
[10:24:16.720]                       has_future <- base::requireNamespace("future", 
[10:24:16.720]                         quietly = TRUE)
[10:24:16.720]                       if (has_future) {
[10:24:16.720]                         ns <- base::getNamespace("future")
[10:24:16.720]                         version <- ns[[".package"]][["version"]]
[10:24:16.720]                         if (is.null(version)) 
[10:24:16.720]                           version <- utils::packageVersion("future")
[10:24:16.720]                       }
[10:24:16.720]                       else {
[10:24:16.720]                         version <- NULL
[10:24:16.720]                       }
[10:24:16.720]                       if (!has_future || version < "1.8.0") {
[10:24:16.720]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.720]                           "", base::R.version$version.string), 
[10:24:16.720]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:16.720]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.720]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.720]                             "release", "version")], collapse = " "), 
[10:24:16.720]                           hostname = base::Sys.info()[["nodename"]])
[10:24:16.720]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.720]                           info)
[10:24:16.720]                         info <- base::paste(info, collapse = "; ")
[10:24:16.720]                         if (!has_future) {
[10:24:16.720]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.720]                             info)
[10:24:16.720]                         }
[10:24:16.720]                         else {
[10:24:16.720]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.720]                             info, version)
[10:24:16.720]                         }
[10:24:16.720]                         base::stop(msg)
[10:24:16.720]                       }
[10:24:16.720]                     })
[10:24:16.720]                   }
[10:24:16.720]                   options(future.plan = NULL)
[10:24:16.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.720]                 }
[10:24:16.720]                 ...future.workdir <- getwd()
[10:24:16.720]             }
[10:24:16.720]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.720]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.720]         }
[10:24:16.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.720]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.720]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.720]             base::names(...future.oldOptions))
[10:24:16.720]     }
[10:24:16.720]     if (FALSE) {
[10:24:16.720]     }
[10:24:16.720]     else {
[10:24:16.720]         if (TRUE) {
[10:24:16.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.720]                 open = "w")
[10:24:16.720]         }
[10:24:16.720]         else {
[10:24:16.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.720]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.720]         }
[10:24:16.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.720]             base::sink(type = "output", split = FALSE)
[10:24:16.720]             base::close(...future.stdout)
[10:24:16.720]         }, add = TRUE)
[10:24:16.720]     }
[10:24:16.720]     ...future.frame <- base::sys.nframe()
[10:24:16.720]     ...future.conditions <- base::list()
[10:24:16.720]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.720]     if (FALSE) {
[10:24:16.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.720]     }
[10:24:16.720]     ...future.result <- base::tryCatch({
[10:24:16.720]         base::withCallingHandlers({
[10:24:16.720]             ...future.value <- base::withVisible(base::local({
[10:24:16.720]                 do.call(function(...) {
[10:24:16.720]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.720]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.720]                     ...future.globals.maxSize)) {
[10:24:16.720]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.720]                     on.exit(options(oopts), add = TRUE)
[10:24:16.720]                   }
[10:24:16.720]                   {
[10:24:16.720]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.720]                       FUN = function(jj) {
[10:24:16.720]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.720]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.720]                       })
[10:24:16.720]                   }
[10:24:16.720]                 }, args = future.call.arguments)
[10:24:16.720]             }))
[10:24:16.720]             future::FutureResult(value = ...future.value$value, 
[10:24:16.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.720]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.720]                     ...future.globalenv.names))
[10:24:16.720]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.720]         }, condition = base::local({
[10:24:16.720]             c <- base::c
[10:24:16.720]             inherits <- base::inherits
[10:24:16.720]             invokeRestart <- base::invokeRestart
[10:24:16.720]             length <- base::length
[10:24:16.720]             list <- base::list
[10:24:16.720]             seq.int <- base::seq.int
[10:24:16.720]             signalCondition <- base::signalCondition
[10:24:16.720]             sys.calls <- base::sys.calls
[10:24:16.720]             `[[` <- base::`[[`
[10:24:16.720]             `+` <- base::`+`
[10:24:16.720]             `<<-` <- base::`<<-`
[10:24:16.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.720]                   3L)]
[10:24:16.720]             }
[10:24:16.720]             function(cond) {
[10:24:16.720]                 is_error <- inherits(cond, "error")
[10:24:16.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.720]                   NULL)
[10:24:16.720]                 if (is_error) {
[10:24:16.720]                   sessionInformation <- function() {
[10:24:16.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.720]                       search = base::search(), system = base::Sys.info())
[10:24:16.720]                   }
[10:24:16.720]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.720]                     cond$call), session = sessionInformation(), 
[10:24:16.720]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.720]                   signalCondition(cond)
[10:24:16.720]                 }
[10:24:16.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.720]                 "immediateCondition"))) {
[10:24:16.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.720]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.720]                   if (TRUE && !signal) {
[10:24:16.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.720]                     {
[10:24:16.720]                       inherits <- base::inherits
[10:24:16.720]                       invokeRestart <- base::invokeRestart
[10:24:16.720]                       is.null <- base::is.null
[10:24:16.720]                       muffled <- FALSE
[10:24:16.720]                       if (inherits(cond, "message")) {
[10:24:16.720]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.720]                         if (muffled) 
[10:24:16.720]                           invokeRestart("muffleMessage")
[10:24:16.720]                       }
[10:24:16.720]                       else if (inherits(cond, "warning")) {
[10:24:16.720]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.720]                         if (muffled) 
[10:24:16.720]                           invokeRestart("muffleWarning")
[10:24:16.720]                       }
[10:24:16.720]                       else if (inherits(cond, "condition")) {
[10:24:16.720]                         if (!is.null(pattern)) {
[10:24:16.720]                           computeRestarts <- base::computeRestarts
[10:24:16.720]                           grepl <- base::grepl
[10:24:16.720]                           restarts <- computeRestarts(cond)
[10:24:16.720]                           for (restart in restarts) {
[10:24:16.720]                             name <- restart$name
[10:24:16.720]                             if (is.null(name)) 
[10:24:16.720]                               next
[10:24:16.720]                             if (!grepl(pattern, name)) 
[10:24:16.720]                               next
[10:24:16.720]                             invokeRestart(restart)
[10:24:16.720]                             muffled <- TRUE
[10:24:16.720]                             break
[10:24:16.720]                           }
[10:24:16.720]                         }
[10:24:16.720]                       }
[10:24:16.720]                       invisible(muffled)
[10:24:16.720]                     }
[10:24:16.720]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.720]                   }
[10:24:16.720]                 }
[10:24:16.720]                 else {
[10:24:16.720]                   if (TRUE) {
[10:24:16.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.720]                     {
[10:24:16.720]                       inherits <- base::inherits
[10:24:16.720]                       invokeRestart <- base::invokeRestart
[10:24:16.720]                       is.null <- base::is.null
[10:24:16.720]                       muffled <- FALSE
[10:24:16.720]                       if (inherits(cond, "message")) {
[10:24:16.720]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.720]                         if (muffled) 
[10:24:16.720]                           invokeRestart("muffleMessage")
[10:24:16.720]                       }
[10:24:16.720]                       else if (inherits(cond, "warning")) {
[10:24:16.720]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.720]                         if (muffled) 
[10:24:16.720]                           invokeRestart("muffleWarning")
[10:24:16.720]                       }
[10:24:16.720]                       else if (inherits(cond, "condition")) {
[10:24:16.720]                         if (!is.null(pattern)) {
[10:24:16.720]                           computeRestarts <- base::computeRestarts
[10:24:16.720]                           grepl <- base::grepl
[10:24:16.720]                           restarts <- computeRestarts(cond)
[10:24:16.720]                           for (restart in restarts) {
[10:24:16.720]                             name <- restart$name
[10:24:16.720]                             if (is.null(name)) 
[10:24:16.720]                               next
[10:24:16.720]                             if (!grepl(pattern, name)) 
[10:24:16.720]                               next
[10:24:16.720]                             invokeRestart(restart)
[10:24:16.720]                             muffled <- TRUE
[10:24:16.720]                             break
[10:24:16.720]                           }
[10:24:16.720]                         }
[10:24:16.720]                       }
[10:24:16.720]                       invisible(muffled)
[10:24:16.720]                     }
[10:24:16.720]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.720]                   }
[10:24:16.720]                 }
[10:24:16.720]             }
[10:24:16.720]         }))
[10:24:16.720]     }, error = function(ex) {
[10:24:16.720]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.720]                 ...future.rng), started = ...future.startTime, 
[10:24:16.720]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.720]             version = "1.8"), class = "FutureResult")
[10:24:16.720]     }, finally = {
[10:24:16.720]         if (!identical(...future.workdir, getwd())) 
[10:24:16.720]             setwd(...future.workdir)
[10:24:16.720]         {
[10:24:16.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.720]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.720]             }
[10:24:16.720]             base::options(...future.oldOptions)
[10:24:16.720]             if (.Platform$OS.type == "windows") {
[10:24:16.720]                 old_names <- names(...future.oldEnvVars)
[10:24:16.720]                 envs <- base::Sys.getenv()
[10:24:16.720]                 names <- names(envs)
[10:24:16.720]                 common <- intersect(names, old_names)
[10:24:16.720]                 added <- setdiff(names, old_names)
[10:24:16.720]                 removed <- setdiff(old_names, names)
[10:24:16.720]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.720]                   envs[common]]
[10:24:16.720]                 NAMES <- toupper(changed)
[10:24:16.720]                 args <- list()
[10:24:16.720]                 for (kk in seq_along(NAMES)) {
[10:24:16.720]                   name <- changed[[kk]]
[10:24:16.720]                   NAME <- NAMES[[kk]]
[10:24:16.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.720]                     next
[10:24:16.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.720]                 }
[10:24:16.720]                 NAMES <- toupper(added)
[10:24:16.720]                 for (kk in seq_along(NAMES)) {
[10:24:16.720]                   name <- added[[kk]]
[10:24:16.720]                   NAME <- NAMES[[kk]]
[10:24:16.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.720]                     next
[10:24:16.720]                   args[[name]] <- ""
[10:24:16.720]                 }
[10:24:16.720]                 NAMES <- toupper(removed)
[10:24:16.720]                 for (kk in seq_along(NAMES)) {
[10:24:16.720]                   name <- removed[[kk]]
[10:24:16.720]                   NAME <- NAMES[[kk]]
[10:24:16.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.720]                     next
[10:24:16.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.720]                 }
[10:24:16.720]                 if (length(args) > 0) 
[10:24:16.720]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.720]             }
[10:24:16.720]             else {
[10:24:16.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.720]             }
[10:24:16.720]             {
[10:24:16.720]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.720]                   0L) {
[10:24:16.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.720]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.720]                   base::options(opts)
[10:24:16.720]                 }
[10:24:16.720]                 {
[10:24:16.720]                   {
[10:24:16.720]                     NULL
[10:24:16.720]                     RNGkind("Mersenne-Twister")
[10:24:16.720]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.720]                       inherits = FALSE)
[10:24:16.720]                   }
[10:24:16.720]                   options(future.plan = NULL)
[10:24:16.720]                   if (is.na(NA_character_)) 
[10:24:16.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.720]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.720]                   {
[10:24:16.720]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.720]                     if (!future$lazy) 
[10:24:16.720]                       future <- run(future)
[10:24:16.720]                     invisible(future)
[10:24:16.720]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.720]                 }
[10:24:16.720]             }
[10:24:16.720]         }
[10:24:16.720]     })
[10:24:16.720]     if (TRUE) {
[10:24:16.720]         base::sink(type = "output", split = FALSE)
[10:24:16.720]         if (TRUE) {
[10:24:16.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.720]         }
[10:24:16.720]         else {
[10:24:16.720]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.720]         }
[10:24:16.720]         base::close(...future.stdout)
[10:24:16.720]         ...future.stdout <- NULL
[10:24:16.720]     }
[10:24:16.720]     ...future.result$conditions <- ...future.conditions
[10:24:16.720]     ...future.result$finished <- base::Sys.time()
[10:24:16.720]     ...future.result
[10:24:16.720] }
[10:24:16.721] assign_globals() ...
[10:24:16.722] List of 5
[10:24:16.722]  $ ...future.FUN            :function (x, y)  
[10:24:16.722]  $ future.call.arguments    :List of 1
[10:24:16.722]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:16.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.722]  $ ...future.elements_ii    :List of 4
[10:24:16.722]   ..$ A: num 50
[10:24:16.722]   ..$ B: num 60
[10:24:16.722]   ..$ C: num 70
[10:24:16.722]   ..$ D: num 80
[10:24:16.722]  $ ...future.seeds_ii       : NULL
[10:24:16.722]  $ ...future.globals.maxSize: NULL
[10:24:16.722]  - attr(*, "where")=List of 5
[10:24:16.722]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.722]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.722]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.722]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.722]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.722]  - attr(*, "resolved")= logi FALSE
[10:24:16.722]  - attr(*, "total_size")= num 4264
[10:24:16.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.722]  - attr(*, "already-done")= logi TRUE
[10:24:16.727] - reassign environment for ‘...future.FUN’
[10:24:16.727] - copied ‘...future.FUN’ to environment
[10:24:16.727] - copied ‘future.call.arguments’ to environment
[10:24:16.727] - copied ‘...future.elements_ii’ to environment
[10:24:16.728] - copied ‘...future.seeds_ii’ to environment
[10:24:16.728] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.728] assign_globals() ... done
[10:24:16.728] plan(): Setting new future strategy stack:
[10:24:16.728] List of future strategies:
[10:24:16.728] 1. sequential:
[10:24:16.728]    - args: function (..., envir = parent.frame())
[10:24:16.728]    - tweaked: FALSE
[10:24:16.728]    - call: NULL
[10:24:16.728] plan(): nbrOfWorkers() = 1
[10:24:16.729] plan(): Setting new future strategy stack:
[10:24:16.729] List of future strategies:
[10:24:16.729] 1. sequential:
[10:24:16.729]    - args: function (..., envir = parent.frame())
[10:24:16.729]    - tweaked: FALSE
[10:24:16.729]    - call: plan(strategy)
[10:24:16.729] plan(): nbrOfWorkers() = 1
[10:24:16.730] SequentialFuture started (and completed)
[10:24:16.730] - Launch lazy future ... done
[10:24:16.730] run() for ‘SequentialFuture’ ... done
[10:24:16.730] Created future:
[10:24:16.730] SequentialFuture:
[10:24:16.730] Label: ‘future_sapply-1’
[10:24:16.730] Expression:
[10:24:16.730] {
[10:24:16.730]     do.call(function(...) {
[10:24:16.730]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.730]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.730]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.730]             on.exit(options(oopts), add = TRUE)
[10:24:16.730]         }
[10:24:16.730]         {
[10:24:16.730]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.730]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.730]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.730]             })
[10:24:16.730]         }
[10:24:16.730]     }, args = future.call.arguments)
[10:24:16.730] }
[10:24:16.730] Lazy evaluation: FALSE
[10:24:16.730] Asynchronous evaluation: FALSE
[10:24:16.730] Local evaluation: TRUE
[10:24:16.730] Environment: R_GlobalEnv
[10:24:16.730] Capture standard output: TRUE
[10:24:16.730] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.730] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:16.730] Packages: <none>
[10:24:16.730] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.730] Resolved: TRUE
[10:24:16.730] Value: 1.34 KiB of class ‘list’
[10:24:16.730] Early signaling: FALSE
[10:24:16.730] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.730] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.731] Chunk #1 of 1 ... DONE
[10:24:16.731] Launching 1 futures (chunks) ... DONE
[10:24:16.731] Resolving 1 futures (chunks) ...
[10:24:16.731] resolve() on list ...
[10:24:16.731]  recursive: 0
[10:24:16.731]  length: 1
[10:24:16.732] 
[10:24:16.732] resolved() for ‘SequentialFuture’ ...
[10:24:16.732] - state: ‘finished’
[10:24:16.732] - run: TRUE
[10:24:16.732] - result: ‘FutureResult’
[10:24:16.732] resolved() for ‘SequentialFuture’ ... done
[10:24:16.732] Future #1
[10:24:16.732] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.732] - nx: 1
[10:24:16.732] - relay: TRUE
[10:24:16.732] - stdout: TRUE
[10:24:16.733] - signal: TRUE
[10:24:16.733] - resignal: FALSE
[10:24:16.733] - force: TRUE
[10:24:16.733] - relayed: [n=1] FALSE
[10:24:16.733] - queued futures: [n=1] FALSE
[10:24:16.733]  - until=1
[10:24:16.733]  - relaying element #1
[10:24:16.733] - relayed: [n=1] TRUE
[10:24:16.733] - queued futures: [n=1] TRUE
[10:24:16.733] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.734]  length: 0 (resolved future 1)
[10:24:16.734] Relaying remaining futures
[10:24:16.734] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.734] - nx: 1
[10:24:16.734] - relay: TRUE
[10:24:16.734] - stdout: TRUE
[10:24:16.734] - signal: TRUE
[10:24:16.734] - resignal: FALSE
[10:24:16.734] - force: TRUE
[10:24:16.734] - relayed: [n=1] TRUE
[10:24:16.734] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.734] - relayed: [n=1] TRUE
[10:24:16.735] - queued futures: [n=1] TRUE
[10:24:16.735] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.736] resolve() on list ... DONE
[10:24:16.736]  - Number of value chunks collected: 1
[10:24:16.736] Resolving 1 futures (chunks) ... DONE
[10:24:16.736] Reducing values from 1 chunks ...
[10:24:16.736]  - Number of values collected after concatenation: 4
[10:24:16.736]  - Number of values expected: 4
[10:24:16.736] Reducing values from 1 chunks ... DONE
[10:24:16.736] future_lapply() ... DONE
[10:24:16.737] future_lapply() ...
[10:24:16.738] Number of chunks: 1
[10:24:16.738] getGlobalsAndPackagesXApply() ...
[10:24:16.738]  - future.globals: TRUE
[10:24:16.739] getGlobalsAndPackages() ...
[10:24:16.739] Searching for globals...
[10:24:16.742] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[10:24:16.742] Searching for globals ... DONE
[10:24:16.742] Resolving globals: FALSE
[10:24:16.743] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[10:24:16.743] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.744] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.744] - packages: [1] ‘future.apply’
[10:24:16.744] getGlobalsAndPackages() ... DONE
[10:24:16.744]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.744]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.744] Finding globals ... DONE
[10:24:16.744]  - use_args: TRUE
[10:24:16.744]  - Getting '...' globals ...
[10:24:16.744] resolve() on list ...
[10:24:16.745]  recursive: 0
[10:24:16.745]  length: 1
[10:24:16.745]  elements: ‘...’
[10:24:16.745]  length: 0 (resolved future 1)
[10:24:16.745] resolve() on list ... DONE
[10:24:16.745]    - '...' content: [n=1] ‘y’
[10:24:16.745] List of 1
[10:24:16.745]  $ ...:List of 1
[10:24:16.745]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:16.745]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.745]  - attr(*, "where")=List of 1
[10:24:16.745]   ..$ ...:<environment: 0x55b93cd76590> 
[10:24:16.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.745]  - attr(*, "resolved")= logi TRUE
[10:24:16.745]  - attr(*, "total_size")= num NA
[10:24:16.748]  - Getting '...' globals ... DONE
[10:24:16.748] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.748] List of 8
[10:24:16.748]  $ ...future.FUN:function (x, ...)  
[10:24:16.748]  $ x_FUN        :function (x, y)  
[10:24:16.748]  $ times        : int 15
[10:24:16.748]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.748]  $ stop_if_not  :function (...)  
[10:24:16.748]  $ dim          : int [1:2] 3 5
[10:24:16.748]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:16.748]  $ ...          :List of 1
[10:24:16.748]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:16.748]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.748]  - attr(*, "where")=List of 8
[10:24:16.748]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.748]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.748]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.748]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.748]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.748]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.748]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.748]   ..$ ...          :<environment: 0x55b93cd76590> 
[10:24:16.748]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.748]  - attr(*, "resolved")= logi FALSE
[10:24:16.748]  - attr(*, "total_size")= num 98600
[10:24:16.754] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.755] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.755] Number of futures (= number of chunks): 1
[10:24:16.755] Launching 1 futures (chunks) ...
[10:24:16.755] Chunk #1 of 1 ...
[10:24:16.755]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.755] getGlobalsAndPackages() ...
[10:24:16.755] Searching for globals...
[10:24:16.755] 
[10:24:16.756] Searching for globals ... DONE
[10:24:16.756] - globals: [0] <none>
[10:24:16.756] getGlobalsAndPackages() ... DONE
[10:24:16.756]    + additional globals found: [n=0] 
[10:24:16.756]    + additional namespaces needed: [n=0] 
[10:24:16.756]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.756]  - seeds: <none>
[10:24:16.756]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.756] getGlobalsAndPackages() ...
[10:24:16.756] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.757] Resolving globals: FALSE
[10:24:16.757] Tweak future expression to call with '...' arguments ...
[10:24:16.757] {
[10:24:16.757]     do.call(function(...) {
[10:24:16.757]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.757]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.757]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.757]             on.exit(options(oopts), add = TRUE)
[10:24:16.757]         }
[10:24:16.757]         {
[10:24:16.757]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.757]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.757]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.757]             })
[10:24:16.757]         }
[10:24:16.757]     }, args = future.call.arguments)
[10:24:16.757] }
[10:24:16.757] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.757] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.758] - packages: [1] ‘future.apply’
[10:24:16.758] getGlobalsAndPackages() ... DONE
[10:24:16.758] run() for ‘Future’ ...
[10:24:16.758] - state: ‘created’
[10:24:16.758] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.758] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.759] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.759]   - Field: ‘label’
[10:24:16.759]   - Field: ‘local’
[10:24:16.759]   - Field: ‘owner’
[10:24:16.759]   - Field: ‘envir’
[10:24:16.759]   - Field: ‘packages’
[10:24:16.759]   - Field: ‘gc’
[10:24:16.759]   - Field: ‘conditions’
[10:24:16.759]   - Field: ‘expr’
[10:24:16.759]   - Field: ‘uuid’
[10:24:16.759]   - Field: ‘seed’
[10:24:16.759]   - Field: ‘version’
[10:24:16.760]   - Field: ‘result’
[10:24:16.760]   - Field: ‘asynchronous’
[10:24:16.760]   - Field: ‘calls’
[10:24:16.760]   - Field: ‘globals’
[10:24:16.760]   - Field: ‘stdout’
[10:24:16.760]   - Field: ‘earlySignal’
[10:24:16.760]   - Field: ‘lazy’
[10:24:16.760]   - Field: ‘state’
[10:24:16.760] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.760] - Launch lazy future ...
[10:24:16.761] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.761] Packages needed by future strategies (n = 0): <none>
[10:24:16.761] {
[10:24:16.761]     {
[10:24:16.761]         {
[10:24:16.761]             ...future.startTime <- base::Sys.time()
[10:24:16.761]             {
[10:24:16.761]                 {
[10:24:16.761]                   {
[10:24:16.761]                     {
[10:24:16.761]                       base::local({
[10:24:16.761]                         has_future <- base::requireNamespace("future", 
[10:24:16.761]                           quietly = TRUE)
[10:24:16.761]                         if (has_future) {
[10:24:16.761]                           ns <- base::getNamespace("future")
[10:24:16.761]                           version <- ns[[".package"]][["version"]]
[10:24:16.761]                           if (is.null(version)) 
[10:24:16.761]                             version <- utils::packageVersion("future")
[10:24:16.761]                         }
[10:24:16.761]                         else {
[10:24:16.761]                           version <- NULL
[10:24:16.761]                         }
[10:24:16.761]                         if (!has_future || version < "1.8.0") {
[10:24:16.761]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.761]                             "", base::R.version$version.string), 
[10:24:16.761]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.761]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.761]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.761]                               "release", "version")], collapse = " "), 
[10:24:16.761]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.761]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.761]                             info)
[10:24:16.761]                           info <- base::paste(info, collapse = "; ")
[10:24:16.761]                           if (!has_future) {
[10:24:16.761]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.761]                               info)
[10:24:16.761]                           }
[10:24:16.761]                           else {
[10:24:16.761]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.761]                               info, version)
[10:24:16.761]                           }
[10:24:16.761]                           base::stop(msg)
[10:24:16.761]                         }
[10:24:16.761]                       })
[10:24:16.761]                     }
[10:24:16.761]                     base::local({
[10:24:16.761]                       for (pkg in "future.apply") {
[10:24:16.761]                         base::loadNamespace(pkg)
[10:24:16.761]                         base::library(pkg, character.only = TRUE)
[10:24:16.761]                       }
[10:24:16.761]                     })
[10:24:16.761]                   }
[10:24:16.761]                   options(future.plan = NULL)
[10:24:16.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.761]                 }
[10:24:16.761]                 ...future.workdir <- getwd()
[10:24:16.761]             }
[10:24:16.761]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.761]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.761]         }
[10:24:16.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.761]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.761]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.761]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.761]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.761]             base::names(...future.oldOptions))
[10:24:16.761]     }
[10:24:16.761]     if (FALSE) {
[10:24:16.761]     }
[10:24:16.761]     else {
[10:24:16.761]         if (TRUE) {
[10:24:16.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.761]                 open = "w")
[10:24:16.761]         }
[10:24:16.761]         else {
[10:24:16.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.761]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.761]         }
[10:24:16.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.761]             base::sink(type = "output", split = FALSE)
[10:24:16.761]             base::close(...future.stdout)
[10:24:16.761]         }, add = TRUE)
[10:24:16.761]     }
[10:24:16.761]     ...future.frame <- base::sys.nframe()
[10:24:16.761]     ...future.conditions <- base::list()
[10:24:16.761]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.761]     if (FALSE) {
[10:24:16.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.761]     }
[10:24:16.761]     ...future.result <- base::tryCatch({
[10:24:16.761]         base::withCallingHandlers({
[10:24:16.761]             ...future.value <- base::withVisible(base::local({
[10:24:16.761]                 do.call(function(...) {
[10:24:16.761]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.761]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.761]                     ...future.globals.maxSize)) {
[10:24:16.761]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.761]                     on.exit(options(oopts), add = TRUE)
[10:24:16.761]                   }
[10:24:16.761]                   {
[10:24:16.761]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.761]                       FUN = function(jj) {
[10:24:16.761]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.761]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.761]                       })
[10:24:16.761]                   }
[10:24:16.761]                 }, args = future.call.arguments)
[10:24:16.761]             }))
[10:24:16.761]             future::FutureResult(value = ...future.value$value, 
[10:24:16.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.761]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.761]                     ...future.globalenv.names))
[10:24:16.761]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.761]         }, condition = base::local({
[10:24:16.761]             c <- base::c
[10:24:16.761]             inherits <- base::inherits
[10:24:16.761]             invokeRestart <- base::invokeRestart
[10:24:16.761]             length <- base::length
[10:24:16.761]             list <- base::list
[10:24:16.761]             seq.int <- base::seq.int
[10:24:16.761]             signalCondition <- base::signalCondition
[10:24:16.761]             sys.calls <- base::sys.calls
[10:24:16.761]             `[[` <- base::`[[`
[10:24:16.761]             `+` <- base::`+`
[10:24:16.761]             `<<-` <- base::`<<-`
[10:24:16.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.761]                   3L)]
[10:24:16.761]             }
[10:24:16.761]             function(cond) {
[10:24:16.761]                 is_error <- inherits(cond, "error")
[10:24:16.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.761]                   NULL)
[10:24:16.761]                 if (is_error) {
[10:24:16.761]                   sessionInformation <- function() {
[10:24:16.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.761]                       search = base::search(), system = base::Sys.info())
[10:24:16.761]                   }
[10:24:16.761]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.761]                     cond$call), session = sessionInformation(), 
[10:24:16.761]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.761]                   signalCondition(cond)
[10:24:16.761]                 }
[10:24:16.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.761]                 "immediateCondition"))) {
[10:24:16.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.761]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.761]                   if (TRUE && !signal) {
[10:24:16.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.761]                     {
[10:24:16.761]                       inherits <- base::inherits
[10:24:16.761]                       invokeRestart <- base::invokeRestart
[10:24:16.761]                       is.null <- base::is.null
[10:24:16.761]                       muffled <- FALSE
[10:24:16.761]                       if (inherits(cond, "message")) {
[10:24:16.761]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.761]                         if (muffled) 
[10:24:16.761]                           invokeRestart("muffleMessage")
[10:24:16.761]                       }
[10:24:16.761]                       else if (inherits(cond, "warning")) {
[10:24:16.761]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.761]                         if (muffled) 
[10:24:16.761]                           invokeRestart("muffleWarning")
[10:24:16.761]                       }
[10:24:16.761]                       else if (inherits(cond, "condition")) {
[10:24:16.761]                         if (!is.null(pattern)) {
[10:24:16.761]                           computeRestarts <- base::computeRestarts
[10:24:16.761]                           grepl <- base::grepl
[10:24:16.761]                           restarts <- computeRestarts(cond)
[10:24:16.761]                           for (restart in restarts) {
[10:24:16.761]                             name <- restart$name
[10:24:16.761]                             if (is.null(name)) 
[10:24:16.761]                               next
[10:24:16.761]                             if (!grepl(pattern, name)) 
[10:24:16.761]                               next
[10:24:16.761]                             invokeRestart(restart)
[10:24:16.761]                             muffled <- TRUE
[10:24:16.761]                             break
[10:24:16.761]                           }
[10:24:16.761]                         }
[10:24:16.761]                       }
[10:24:16.761]                       invisible(muffled)
[10:24:16.761]                     }
[10:24:16.761]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.761]                   }
[10:24:16.761]                 }
[10:24:16.761]                 else {
[10:24:16.761]                   if (TRUE) {
[10:24:16.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.761]                     {
[10:24:16.761]                       inherits <- base::inherits
[10:24:16.761]                       invokeRestart <- base::invokeRestart
[10:24:16.761]                       is.null <- base::is.null
[10:24:16.761]                       muffled <- FALSE
[10:24:16.761]                       if (inherits(cond, "message")) {
[10:24:16.761]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.761]                         if (muffled) 
[10:24:16.761]                           invokeRestart("muffleMessage")
[10:24:16.761]                       }
[10:24:16.761]                       else if (inherits(cond, "warning")) {
[10:24:16.761]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.761]                         if (muffled) 
[10:24:16.761]                           invokeRestart("muffleWarning")
[10:24:16.761]                       }
[10:24:16.761]                       else if (inherits(cond, "condition")) {
[10:24:16.761]                         if (!is.null(pattern)) {
[10:24:16.761]                           computeRestarts <- base::computeRestarts
[10:24:16.761]                           grepl <- base::grepl
[10:24:16.761]                           restarts <- computeRestarts(cond)
[10:24:16.761]                           for (restart in restarts) {
[10:24:16.761]                             name <- restart$name
[10:24:16.761]                             if (is.null(name)) 
[10:24:16.761]                               next
[10:24:16.761]                             if (!grepl(pattern, name)) 
[10:24:16.761]                               next
[10:24:16.761]                             invokeRestart(restart)
[10:24:16.761]                             muffled <- TRUE
[10:24:16.761]                             break
[10:24:16.761]                           }
[10:24:16.761]                         }
[10:24:16.761]                       }
[10:24:16.761]                       invisible(muffled)
[10:24:16.761]                     }
[10:24:16.761]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.761]                   }
[10:24:16.761]                 }
[10:24:16.761]             }
[10:24:16.761]         }))
[10:24:16.761]     }, error = function(ex) {
[10:24:16.761]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.761]                 ...future.rng), started = ...future.startTime, 
[10:24:16.761]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.761]             version = "1.8"), class = "FutureResult")
[10:24:16.761]     }, finally = {
[10:24:16.761]         if (!identical(...future.workdir, getwd())) 
[10:24:16.761]             setwd(...future.workdir)
[10:24:16.761]         {
[10:24:16.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.761]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.761]             }
[10:24:16.761]             base::options(...future.oldOptions)
[10:24:16.761]             if (.Platform$OS.type == "windows") {
[10:24:16.761]                 old_names <- names(...future.oldEnvVars)
[10:24:16.761]                 envs <- base::Sys.getenv()
[10:24:16.761]                 names <- names(envs)
[10:24:16.761]                 common <- intersect(names, old_names)
[10:24:16.761]                 added <- setdiff(names, old_names)
[10:24:16.761]                 removed <- setdiff(old_names, names)
[10:24:16.761]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.761]                   envs[common]]
[10:24:16.761]                 NAMES <- toupper(changed)
[10:24:16.761]                 args <- list()
[10:24:16.761]                 for (kk in seq_along(NAMES)) {
[10:24:16.761]                   name <- changed[[kk]]
[10:24:16.761]                   NAME <- NAMES[[kk]]
[10:24:16.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.761]                     next
[10:24:16.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.761]                 }
[10:24:16.761]                 NAMES <- toupper(added)
[10:24:16.761]                 for (kk in seq_along(NAMES)) {
[10:24:16.761]                   name <- added[[kk]]
[10:24:16.761]                   NAME <- NAMES[[kk]]
[10:24:16.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.761]                     next
[10:24:16.761]                   args[[name]] <- ""
[10:24:16.761]                 }
[10:24:16.761]                 NAMES <- toupper(removed)
[10:24:16.761]                 for (kk in seq_along(NAMES)) {
[10:24:16.761]                   name <- removed[[kk]]
[10:24:16.761]                   NAME <- NAMES[[kk]]
[10:24:16.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.761]                     next
[10:24:16.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.761]                 }
[10:24:16.761]                 if (length(args) > 0) 
[10:24:16.761]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.761]             }
[10:24:16.761]             else {
[10:24:16.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.761]             }
[10:24:16.761]             {
[10:24:16.761]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.761]                   0L) {
[10:24:16.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.761]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.761]                   base::options(opts)
[10:24:16.761]                 }
[10:24:16.761]                 {
[10:24:16.761]                   {
[10:24:16.761]                     NULL
[10:24:16.761]                     RNGkind("Mersenne-Twister")
[10:24:16.761]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.761]                       inherits = FALSE)
[10:24:16.761]                   }
[10:24:16.761]                   options(future.plan = NULL)
[10:24:16.761]                   if (is.na(NA_character_)) 
[10:24:16.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.761]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.761]                   {
[10:24:16.761]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.761]                     if (!future$lazy) 
[10:24:16.761]                       future <- run(future)
[10:24:16.761]                     invisible(future)
[10:24:16.761]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.761]                 }
[10:24:16.761]             }
[10:24:16.761]         }
[10:24:16.761]     })
[10:24:16.761]     if (TRUE) {
[10:24:16.761]         base::sink(type = "output", split = FALSE)
[10:24:16.761]         if (TRUE) {
[10:24:16.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.761]         }
[10:24:16.761]         else {
[10:24:16.761]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.761]         }
[10:24:16.761]         base::close(...future.stdout)
[10:24:16.761]         ...future.stdout <- NULL
[10:24:16.761]     }
[10:24:16.761]     ...future.result$conditions <- ...future.conditions
[10:24:16.761]     ...future.result$finished <- base::Sys.time()
[10:24:16.761]     ...future.result
[10:24:16.761] }
[10:24:16.763] assign_globals() ...
[10:24:16.763] List of 11
[10:24:16.763]  $ ...future.FUN            :function (x, ...)  
[10:24:16.763]  $ x_FUN                    :function (x, y)  
[10:24:16.763]  $ times                    : int 15
[10:24:16.763]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.763]  $ stop_if_not              :function (...)  
[10:24:16.763]  $ dim                      : int [1:2] 3 5
[10:24:16.763]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:16.763]  $ future.call.arguments    :List of 1
[10:24:16.763]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:16.763]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.763]  $ ...future.elements_ii    :List of 4
[10:24:16.763]   ..$ A: num 50
[10:24:16.763]   ..$ B: num 60
[10:24:16.763]   ..$ C: num 70
[10:24:16.763]   ..$ D: num 80
[10:24:16.763]  $ ...future.seeds_ii       : NULL
[10:24:16.763]  $ ...future.globals.maxSize: NULL
[10:24:16.763]  - attr(*, "where")=List of 11
[10:24:16.763]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.763]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.763]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.763]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.763]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.763]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.763]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.763]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.763]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.763]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.763]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.763]  - attr(*, "resolved")= logi FALSE
[10:24:16.763]  - attr(*, "total_size")= num 98600
[10:24:16.763]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.763]  - attr(*, "already-done")= logi TRUE
[10:24:16.771] - copied ‘...future.FUN’ to environment
[10:24:16.771] - reassign environment for ‘x_FUN’
[10:24:16.771] - copied ‘x_FUN’ to environment
[10:24:16.772] - copied ‘times’ to environment
[10:24:16.772] - copied ‘stopf’ to environment
[10:24:16.772] - copied ‘stop_if_not’ to environment
[10:24:16.772] - copied ‘dim’ to environment
[10:24:16.772] - copied ‘valid_types’ to environment
[10:24:16.772] - copied ‘future.call.arguments’ to environment
[10:24:16.772] - copied ‘...future.elements_ii’ to environment
[10:24:16.772] - copied ‘...future.seeds_ii’ to environment
[10:24:16.772] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.772] assign_globals() ... done
[10:24:16.773] plan(): Setting new future strategy stack:
[10:24:16.773] List of future strategies:
[10:24:16.773] 1. sequential:
[10:24:16.773]    - args: function (..., envir = parent.frame())
[10:24:16.773]    - tweaked: FALSE
[10:24:16.773]    - call: NULL
[10:24:16.773] plan(): nbrOfWorkers() = 1
[10:24:16.774] plan(): Setting new future strategy stack:
[10:24:16.774] List of future strategies:
[10:24:16.774] 1. sequential:
[10:24:16.774]    - args: function (..., envir = parent.frame())
[10:24:16.774]    - tweaked: FALSE
[10:24:16.774]    - call: plan(strategy)
[10:24:16.774] plan(): nbrOfWorkers() = 1
[10:24:16.775] SequentialFuture started (and completed)
[10:24:16.775] - Launch lazy future ... done
[10:24:16.776] run() for ‘SequentialFuture’ ... done
[10:24:16.776] Created future:
[10:24:16.776] SequentialFuture:
[10:24:16.776] Label: ‘future_vapply-1’
[10:24:16.776] Expression:
[10:24:16.776] {
[10:24:16.776]     do.call(function(...) {
[10:24:16.776]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.776]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.776]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.776]             on.exit(options(oopts), add = TRUE)
[10:24:16.776]         }
[10:24:16.776]         {
[10:24:16.776]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.776]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.776]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.776]             })
[10:24:16.776]         }
[10:24:16.776]     }, args = future.call.arguments)
[10:24:16.776] }
[10:24:16.776] Lazy evaluation: FALSE
[10:24:16.776] Asynchronous evaluation: FALSE
[10:24:16.776] Local evaluation: TRUE
[10:24:16.776] Environment: R_GlobalEnv
[10:24:16.776] Capture standard output: TRUE
[10:24:16.776] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.776] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.776] Packages: 1 packages (‘future.apply’)
[10:24:16.776] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.776] Resolved: TRUE
[10:24:16.776] Value: 1.34 KiB of class ‘list’
[10:24:16.776] Early signaling: FALSE
[10:24:16.776] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.776] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.777] Chunk #1 of 1 ... DONE
[10:24:16.777] Launching 1 futures (chunks) ... DONE
[10:24:16.777] Resolving 1 futures (chunks) ...
[10:24:16.777] resolve() on list ...
[10:24:16.777]  recursive: 0
[10:24:16.777]  length: 1
[10:24:16.778] 
[10:24:16.778] resolved() for ‘SequentialFuture’ ...
[10:24:16.778] - state: ‘finished’
[10:24:16.778] - run: TRUE
[10:24:16.778] - result: ‘FutureResult’
[10:24:16.778] resolved() for ‘SequentialFuture’ ... done
[10:24:16.778] Future #1
[10:24:16.778] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.778] - nx: 1
[10:24:16.778] - relay: TRUE
[10:24:16.778] - stdout: TRUE
[10:24:16.779] - signal: TRUE
[10:24:16.779] - resignal: FALSE
[10:24:16.779] - force: TRUE
[10:24:16.779] - relayed: [n=1] FALSE
[10:24:16.779] - queued futures: [n=1] FALSE
[10:24:16.779]  - until=1
[10:24:16.779]  - relaying element #1
[10:24:16.779] - relayed: [n=1] TRUE
[10:24:16.779] - queued futures: [n=1] TRUE
[10:24:16.779] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.780]  length: 0 (resolved future 1)
[10:24:16.780] Relaying remaining futures
[10:24:16.780] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.780] - nx: 1
[10:24:16.780] - relay: TRUE
[10:24:16.780] - stdout: TRUE
[10:24:16.780] - signal: TRUE
[10:24:16.780] - resignal: FALSE
[10:24:16.780] - force: TRUE
[10:24:16.780] - relayed: [n=1] TRUE
[10:24:16.780] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.780] - relayed: [n=1] TRUE
[10:24:16.781] - queued futures: [n=1] TRUE
[10:24:16.781] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.781] resolve() on list ... DONE
[10:24:16.781]  - Number of value chunks collected: 1
[10:24:16.781] Resolving 1 futures (chunks) ... DONE
[10:24:16.781] Reducing values from 1 chunks ...
[10:24:16.781]  - Number of values collected after concatenation: 4
[10:24:16.781]  - Number of values expected: 4
[10:24:16.781] Reducing values from 1 chunks ... DONE
[10:24:16.781] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[10:24:16.783] future_lapply() ...
[10:24:16.785] Number of chunks: 1
[10:24:16.785] getGlobalsAndPackagesXApply() ...
[10:24:16.785]  - future.globals: TRUE
[10:24:16.785] getGlobalsAndPackages() ...
[10:24:16.785] Searching for globals...
[10:24:16.788] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:16.788] Searching for globals ... DONE
[10:24:16.788] Resolving globals: FALSE
[10:24:16.789] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[10:24:16.789] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.789] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.789] - packages: [1] ‘future.apply’
[10:24:16.789] getGlobalsAndPackages() ... DONE
[10:24:16.790]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.790]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.790] Finding globals ... DONE
[10:24:16.790]  - use_args: TRUE
[10:24:16.790]  - Getting '...' globals ...
[10:24:16.790] resolve() on list ...
[10:24:16.790]  recursive: 0
[10:24:16.790]  length: 1
[10:24:16.790]  elements: ‘...’
[10:24:16.791]  length: 0 (resolved future 1)
[10:24:16.791] resolve() on list ... DONE
[10:24:16.791]    - '...' content: [n=0] 
[10:24:16.791] List of 1
[10:24:16.791]  $ ...: list()
[10:24:16.791]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.791]  - attr(*, "where")=List of 1
[10:24:16.791]   ..$ ...:<environment: 0x55b93b7e7450> 
[10:24:16.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.791]  - attr(*, "resolved")= logi TRUE
[10:24:16.791]  - attr(*, "total_size")= num NA
[10:24:16.793]  - Getting '...' globals ... DONE
[10:24:16.793] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.794] List of 8
[10:24:16.794]  $ ...future.FUN:function (x, ...)  
[10:24:16.794]  $ x_FUN        :function (x)  
[10:24:16.794]  $ times        : int 1
[10:24:16.794]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.794]  $ stop_if_not  :function (...)  
[10:24:16.794]  $ dim          : NULL
[10:24:16.794]  $ valid_types  : chr "logical"
[10:24:16.794]  $ ...          : list()
[10:24:16.794]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.794]  - attr(*, "where")=List of 8
[10:24:16.794]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.794]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.794]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.794]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.794]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.794]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.794]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.794]   ..$ ...          :<environment: 0x55b93b7e7450> 
[10:24:16.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.794]  - attr(*, "resolved")= logi FALSE
[10:24:16.794]  - attr(*, "total_size")= num 94200
[10:24:16.800] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.800] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.800] Number of futures (= number of chunks): 1
[10:24:16.800] Launching 1 futures (chunks) ...
[10:24:16.800] Chunk #1 of 1 ...
[10:24:16.800]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.800] getGlobalsAndPackages() ...
[10:24:16.800] Searching for globals...
[10:24:16.801] 
[10:24:16.801] Searching for globals ... DONE
[10:24:16.801] - globals: [0] <none>
[10:24:16.801] getGlobalsAndPackages() ... DONE
[10:24:16.801]    + additional globals found: [n=0] 
[10:24:16.801]    + additional namespaces needed: [n=0] 
[10:24:16.801]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.801]  - seeds: <none>
[10:24:16.801]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.802] getGlobalsAndPackages() ...
[10:24:16.802] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.802] Resolving globals: FALSE
[10:24:16.802] Tweak future expression to call with '...' arguments ...
[10:24:16.802] {
[10:24:16.802]     do.call(function(...) {
[10:24:16.802]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.802]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.802]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.802]             on.exit(options(oopts), add = TRUE)
[10:24:16.802]         }
[10:24:16.802]         {
[10:24:16.802]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.802]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.802]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.802]             })
[10:24:16.802]         }
[10:24:16.802]     }, args = future.call.arguments)
[10:24:16.802] }
[10:24:16.802] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.803] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.803] - packages: [1] ‘future.apply’
[10:24:16.803] getGlobalsAndPackages() ... DONE
[10:24:16.803] run() for ‘Future’ ...
[10:24:16.803] - state: ‘created’
[10:24:16.803] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.804] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.804] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.804]   - Field: ‘label’
[10:24:16.804]   - Field: ‘local’
[10:24:16.804]   - Field: ‘owner’
[10:24:16.804]   - Field: ‘envir’
[10:24:16.804]   - Field: ‘packages’
[10:24:16.804]   - Field: ‘gc’
[10:24:16.804]   - Field: ‘conditions’
[10:24:16.804]   - Field: ‘expr’
[10:24:16.805]   - Field: ‘uuid’
[10:24:16.805]   - Field: ‘seed’
[10:24:16.805]   - Field: ‘version’
[10:24:16.805]   - Field: ‘result’
[10:24:16.805]   - Field: ‘asynchronous’
[10:24:16.805]   - Field: ‘calls’
[10:24:16.805]   - Field: ‘globals’
[10:24:16.805]   - Field: ‘stdout’
[10:24:16.805]   - Field: ‘earlySignal’
[10:24:16.805]   - Field: ‘lazy’
[10:24:16.805]   - Field: ‘state’
[10:24:16.806] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.806] - Launch lazy future ...
[10:24:16.806] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.806] Packages needed by future strategies (n = 0): <none>
[10:24:16.806] {
[10:24:16.806]     {
[10:24:16.806]         {
[10:24:16.806]             ...future.startTime <- base::Sys.time()
[10:24:16.806]             {
[10:24:16.806]                 {
[10:24:16.806]                   {
[10:24:16.806]                     {
[10:24:16.806]                       base::local({
[10:24:16.806]                         has_future <- base::requireNamespace("future", 
[10:24:16.806]                           quietly = TRUE)
[10:24:16.806]                         if (has_future) {
[10:24:16.806]                           ns <- base::getNamespace("future")
[10:24:16.806]                           version <- ns[[".package"]][["version"]]
[10:24:16.806]                           if (is.null(version)) 
[10:24:16.806]                             version <- utils::packageVersion("future")
[10:24:16.806]                         }
[10:24:16.806]                         else {
[10:24:16.806]                           version <- NULL
[10:24:16.806]                         }
[10:24:16.806]                         if (!has_future || version < "1.8.0") {
[10:24:16.806]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.806]                             "", base::R.version$version.string), 
[10:24:16.806]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.806]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.806]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.806]                               "release", "version")], collapse = " "), 
[10:24:16.806]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.806]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.806]                             info)
[10:24:16.806]                           info <- base::paste(info, collapse = "; ")
[10:24:16.806]                           if (!has_future) {
[10:24:16.806]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.806]                               info)
[10:24:16.806]                           }
[10:24:16.806]                           else {
[10:24:16.806]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.806]                               info, version)
[10:24:16.806]                           }
[10:24:16.806]                           base::stop(msg)
[10:24:16.806]                         }
[10:24:16.806]                       })
[10:24:16.806]                     }
[10:24:16.806]                     base::local({
[10:24:16.806]                       for (pkg in "future.apply") {
[10:24:16.806]                         base::loadNamespace(pkg)
[10:24:16.806]                         base::library(pkg, character.only = TRUE)
[10:24:16.806]                       }
[10:24:16.806]                     })
[10:24:16.806]                   }
[10:24:16.806]                   options(future.plan = NULL)
[10:24:16.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.806]                 }
[10:24:16.806]                 ...future.workdir <- getwd()
[10:24:16.806]             }
[10:24:16.806]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.806]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.806]         }
[10:24:16.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.806]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.806]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.806]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.806]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.806]             base::names(...future.oldOptions))
[10:24:16.806]     }
[10:24:16.806]     if (FALSE) {
[10:24:16.806]     }
[10:24:16.806]     else {
[10:24:16.806]         if (TRUE) {
[10:24:16.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.806]                 open = "w")
[10:24:16.806]         }
[10:24:16.806]         else {
[10:24:16.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.806]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.806]         }
[10:24:16.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.806]             base::sink(type = "output", split = FALSE)
[10:24:16.806]             base::close(...future.stdout)
[10:24:16.806]         }, add = TRUE)
[10:24:16.806]     }
[10:24:16.806]     ...future.frame <- base::sys.nframe()
[10:24:16.806]     ...future.conditions <- base::list()
[10:24:16.806]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.806]     if (FALSE) {
[10:24:16.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.806]     }
[10:24:16.806]     ...future.result <- base::tryCatch({
[10:24:16.806]         base::withCallingHandlers({
[10:24:16.806]             ...future.value <- base::withVisible(base::local({
[10:24:16.806]                 do.call(function(...) {
[10:24:16.806]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.806]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.806]                     ...future.globals.maxSize)) {
[10:24:16.806]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.806]                     on.exit(options(oopts), add = TRUE)
[10:24:16.806]                   }
[10:24:16.806]                   {
[10:24:16.806]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.806]                       FUN = function(jj) {
[10:24:16.806]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.806]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.806]                       })
[10:24:16.806]                   }
[10:24:16.806]                 }, args = future.call.arguments)
[10:24:16.806]             }))
[10:24:16.806]             future::FutureResult(value = ...future.value$value, 
[10:24:16.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.806]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.806]                     ...future.globalenv.names))
[10:24:16.806]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.806]         }, condition = base::local({
[10:24:16.806]             c <- base::c
[10:24:16.806]             inherits <- base::inherits
[10:24:16.806]             invokeRestart <- base::invokeRestart
[10:24:16.806]             length <- base::length
[10:24:16.806]             list <- base::list
[10:24:16.806]             seq.int <- base::seq.int
[10:24:16.806]             signalCondition <- base::signalCondition
[10:24:16.806]             sys.calls <- base::sys.calls
[10:24:16.806]             `[[` <- base::`[[`
[10:24:16.806]             `+` <- base::`+`
[10:24:16.806]             `<<-` <- base::`<<-`
[10:24:16.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.806]                   3L)]
[10:24:16.806]             }
[10:24:16.806]             function(cond) {
[10:24:16.806]                 is_error <- inherits(cond, "error")
[10:24:16.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.806]                   NULL)
[10:24:16.806]                 if (is_error) {
[10:24:16.806]                   sessionInformation <- function() {
[10:24:16.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.806]                       search = base::search(), system = base::Sys.info())
[10:24:16.806]                   }
[10:24:16.806]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.806]                     cond$call), session = sessionInformation(), 
[10:24:16.806]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.806]                   signalCondition(cond)
[10:24:16.806]                 }
[10:24:16.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.806]                 "immediateCondition"))) {
[10:24:16.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.806]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.806]                   if (TRUE && !signal) {
[10:24:16.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.806]                     {
[10:24:16.806]                       inherits <- base::inherits
[10:24:16.806]                       invokeRestart <- base::invokeRestart
[10:24:16.806]                       is.null <- base::is.null
[10:24:16.806]                       muffled <- FALSE
[10:24:16.806]                       if (inherits(cond, "message")) {
[10:24:16.806]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.806]                         if (muffled) 
[10:24:16.806]                           invokeRestart("muffleMessage")
[10:24:16.806]                       }
[10:24:16.806]                       else if (inherits(cond, "warning")) {
[10:24:16.806]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.806]                         if (muffled) 
[10:24:16.806]                           invokeRestart("muffleWarning")
[10:24:16.806]                       }
[10:24:16.806]                       else if (inherits(cond, "condition")) {
[10:24:16.806]                         if (!is.null(pattern)) {
[10:24:16.806]                           computeRestarts <- base::computeRestarts
[10:24:16.806]                           grepl <- base::grepl
[10:24:16.806]                           restarts <- computeRestarts(cond)
[10:24:16.806]                           for (restart in restarts) {
[10:24:16.806]                             name <- restart$name
[10:24:16.806]                             if (is.null(name)) 
[10:24:16.806]                               next
[10:24:16.806]                             if (!grepl(pattern, name)) 
[10:24:16.806]                               next
[10:24:16.806]                             invokeRestart(restart)
[10:24:16.806]                             muffled <- TRUE
[10:24:16.806]                             break
[10:24:16.806]                           }
[10:24:16.806]                         }
[10:24:16.806]                       }
[10:24:16.806]                       invisible(muffled)
[10:24:16.806]                     }
[10:24:16.806]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.806]                   }
[10:24:16.806]                 }
[10:24:16.806]                 else {
[10:24:16.806]                   if (TRUE) {
[10:24:16.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.806]                     {
[10:24:16.806]                       inherits <- base::inherits
[10:24:16.806]                       invokeRestart <- base::invokeRestart
[10:24:16.806]                       is.null <- base::is.null
[10:24:16.806]                       muffled <- FALSE
[10:24:16.806]                       if (inherits(cond, "message")) {
[10:24:16.806]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.806]                         if (muffled) 
[10:24:16.806]                           invokeRestart("muffleMessage")
[10:24:16.806]                       }
[10:24:16.806]                       else if (inherits(cond, "warning")) {
[10:24:16.806]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.806]                         if (muffled) 
[10:24:16.806]                           invokeRestart("muffleWarning")
[10:24:16.806]                       }
[10:24:16.806]                       else if (inherits(cond, "condition")) {
[10:24:16.806]                         if (!is.null(pattern)) {
[10:24:16.806]                           computeRestarts <- base::computeRestarts
[10:24:16.806]                           grepl <- base::grepl
[10:24:16.806]                           restarts <- computeRestarts(cond)
[10:24:16.806]                           for (restart in restarts) {
[10:24:16.806]                             name <- restart$name
[10:24:16.806]                             if (is.null(name)) 
[10:24:16.806]                               next
[10:24:16.806]                             if (!grepl(pattern, name)) 
[10:24:16.806]                               next
[10:24:16.806]                             invokeRestart(restart)
[10:24:16.806]                             muffled <- TRUE
[10:24:16.806]                             break
[10:24:16.806]                           }
[10:24:16.806]                         }
[10:24:16.806]                       }
[10:24:16.806]                       invisible(muffled)
[10:24:16.806]                     }
[10:24:16.806]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.806]                   }
[10:24:16.806]                 }
[10:24:16.806]             }
[10:24:16.806]         }))
[10:24:16.806]     }, error = function(ex) {
[10:24:16.806]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.806]                 ...future.rng), started = ...future.startTime, 
[10:24:16.806]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.806]             version = "1.8"), class = "FutureResult")
[10:24:16.806]     }, finally = {
[10:24:16.806]         if (!identical(...future.workdir, getwd())) 
[10:24:16.806]             setwd(...future.workdir)
[10:24:16.806]         {
[10:24:16.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.806]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.806]             }
[10:24:16.806]             base::options(...future.oldOptions)
[10:24:16.806]             if (.Platform$OS.type == "windows") {
[10:24:16.806]                 old_names <- names(...future.oldEnvVars)
[10:24:16.806]                 envs <- base::Sys.getenv()
[10:24:16.806]                 names <- names(envs)
[10:24:16.806]                 common <- intersect(names, old_names)
[10:24:16.806]                 added <- setdiff(names, old_names)
[10:24:16.806]                 removed <- setdiff(old_names, names)
[10:24:16.806]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.806]                   envs[common]]
[10:24:16.806]                 NAMES <- toupper(changed)
[10:24:16.806]                 args <- list()
[10:24:16.806]                 for (kk in seq_along(NAMES)) {
[10:24:16.806]                   name <- changed[[kk]]
[10:24:16.806]                   NAME <- NAMES[[kk]]
[10:24:16.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.806]                     next
[10:24:16.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.806]                 }
[10:24:16.806]                 NAMES <- toupper(added)
[10:24:16.806]                 for (kk in seq_along(NAMES)) {
[10:24:16.806]                   name <- added[[kk]]
[10:24:16.806]                   NAME <- NAMES[[kk]]
[10:24:16.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.806]                     next
[10:24:16.806]                   args[[name]] <- ""
[10:24:16.806]                 }
[10:24:16.806]                 NAMES <- toupper(removed)
[10:24:16.806]                 for (kk in seq_along(NAMES)) {
[10:24:16.806]                   name <- removed[[kk]]
[10:24:16.806]                   NAME <- NAMES[[kk]]
[10:24:16.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.806]                     next
[10:24:16.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.806]                 }
[10:24:16.806]                 if (length(args) > 0) 
[10:24:16.806]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.806]             }
[10:24:16.806]             else {
[10:24:16.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.806]             }
[10:24:16.806]             {
[10:24:16.806]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.806]                   0L) {
[10:24:16.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.806]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.806]                   base::options(opts)
[10:24:16.806]                 }
[10:24:16.806]                 {
[10:24:16.806]                   {
[10:24:16.806]                     NULL
[10:24:16.806]                     RNGkind("Mersenne-Twister")
[10:24:16.806]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.806]                       inherits = FALSE)
[10:24:16.806]                   }
[10:24:16.806]                   options(future.plan = NULL)
[10:24:16.806]                   if (is.na(NA_character_)) 
[10:24:16.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.806]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.806]                   {
[10:24:16.806]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.806]                     if (!future$lazy) 
[10:24:16.806]                       future <- run(future)
[10:24:16.806]                     invisible(future)
[10:24:16.806]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.806]                 }
[10:24:16.806]             }
[10:24:16.806]         }
[10:24:16.806]     })
[10:24:16.806]     if (TRUE) {
[10:24:16.806]         base::sink(type = "output", split = FALSE)
[10:24:16.806]         if (TRUE) {
[10:24:16.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.806]         }
[10:24:16.806]         else {
[10:24:16.806]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.806]         }
[10:24:16.806]         base::close(...future.stdout)
[10:24:16.806]         ...future.stdout <- NULL
[10:24:16.806]     }
[10:24:16.806]     ...future.result$conditions <- ...future.conditions
[10:24:16.806]     ...future.result$finished <- base::Sys.time()
[10:24:16.806]     ...future.result
[10:24:16.806] }
[10:24:16.808] assign_globals() ...
[10:24:16.808] List of 11
[10:24:16.808]  $ ...future.FUN            :function (x, ...)  
[10:24:16.808]  $ x_FUN                    :function (x)  
[10:24:16.808]  $ times                    : int 1
[10:24:16.808]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.808]  $ stop_if_not              :function (...)  
[10:24:16.808]  $ dim                      : NULL
[10:24:16.808]  $ valid_types              : chr "logical"
[10:24:16.808]  $ future.call.arguments    : list()
[10:24:16.808]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.808]  $ ...future.elements_ii    :List of 11
[10:24:16.808]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[10:24:16.808]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[10:24:16.808]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[10:24:16.808]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[10:24:16.808]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[10:24:16.808]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[10:24:16.808]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[10:24:16.808]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[10:24:16.808]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[10:24:16.808]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[10:24:16.808]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[10:24:16.808]  $ ...future.seeds_ii       : NULL
[10:24:16.808]  $ ...future.globals.maxSize: NULL
[10:24:16.808]  - attr(*, "where")=List of 11
[10:24:16.808]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.808]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.808]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.808]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.808]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.808]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.808]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.808]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.808]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.808]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.808]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.808]  - attr(*, "resolved")= logi FALSE
[10:24:16.808]  - attr(*, "total_size")= num 94200
[10:24:16.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.808]  - attr(*, "already-done")= logi TRUE
[10:24:16.819] - copied ‘...future.FUN’ to environment
[10:24:16.819] - copied ‘x_FUN’ to environment
[10:24:16.819] - copied ‘times’ to environment
[10:24:16.820] - copied ‘stopf’ to environment
[10:24:16.820] - copied ‘stop_if_not’ to environment
[10:24:16.820] - copied ‘dim’ to environment
[10:24:16.820] - copied ‘valid_types’ to environment
[10:24:16.820] - copied ‘future.call.arguments’ to environment
[10:24:16.820] - copied ‘...future.elements_ii’ to environment
[10:24:16.820] - copied ‘...future.seeds_ii’ to environment
[10:24:16.820] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.820] assign_globals() ... done
[10:24:16.821] plan(): Setting new future strategy stack:
[10:24:16.821] List of future strategies:
[10:24:16.821] 1. sequential:
[10:24:16.821]    - args: function (..., envir = parent.frame())
[10:24:16.821]    - tweaked: FALSE
[10:24:16.821]    - call: NULL
[10:24:16.821] plan(): nbrOfWorkers() = 1
[10:24:16.822] plan(): Setting new future strategy stack:
[10:24:16.822] List of future strategies:
[10:24:16.822] 1. sequential:
[10:24:16.822]    - args: function (..., envir = parent.frame())
[10:24:16.822]    - tweaked: FALSE
[10:24:16.822]    - call: plan(strategy)
[10:24:16.822] plan(): nbrOfWorkers() = 1
[10:24:16.822] SequentialFuture started (and completed)
[10:24:16.823] - Launch lazy future ... done
[10:24:16.823] run() for ‘SequentialFuture’ ... done
[10:24:16.823] Created future:
[10:24:16.823] SequentialFuture:
[10:24:16.823] Label: ‘future_vapply-1’
[10:24:16.823] Expression:
[10:24:16.823] {
[10:24:16.823]     do.call(function(...) {
[10:24:16.823]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.823]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.823]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.823]             on.exit(options(oopts), add = TRUE)
[10:24:16.823]         }
[10:24:16.823]         {
[10:24:16.823]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.823]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.823]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.823]             })
[10:24:16.823]         }
[10:24:16.823]     }, args = future.call.arguments)
[10:24:16.823] }
[10:24:16.823] Lazy evaluation: FALSE
[10:24:16.823] Asynchronous evaluation: FALSE
[10:24:16.823] Local evaluation: TRUE
[10:24:16.823] Environment: R_GlobalEnv
[10:24:16.823] Capture standard output: TRUE
[10:24:16.823] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.823] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.823] Packages: 1 packages (‘future.apply’)
[10:24:16.823] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.823] Resolved: TRUE
[10:24:16.823] Value: 616 bytes of class ‘list’
[10:24:16.823] Early signaling: FALSE
[10:24:16.823] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.823] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.824] Chunk #1 of 1 ... DONE
[10:24:16.824] Launching 1 futures (chunks) ... DONE
[10:24:16.824] Resolving 1 futures (chunks) ...
[10:24:16.824] resolve() on list ...
[10:24:16.824]  recursive: 0
[10:24:16.824]  length: 1
[10:24:16.825] 
[10:24:16.825] resolved() for ‘SequentialFuture’ ...
[10:24:16.825] - state: ‘finished’
[10:24:16.825] - run: TRUE
[10:24:16.825] - result: ‘FutureResult’
[10:24:16.825] resolved() for ‘SequentialFuture’ ... done
[10:24:16.825] Future #1
[10:24:16.825] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.825] - nx: 1
[10:24:16.825] - relay: TRUE
[10:24:16.825] - stdout: TRUE
[10:24:16.826] - signal: TRUE
[10:24:16.826] - resignal: FALSE
[10:24:16.826] - force: TRUE
[10:24:16.826] - relayed: [n=1] FALSE
[10:24:16.826] - queued futures: [n=1] FALSE
[10:24:16.826]  - until=1
[10:24:16.826]  - relaying element #1
[10:24:16.826] - relayed: [n=1] TRUE
[10:24:16.826] - queued futures: [n=1] TRUE
[10:24:16.826] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.827]  length: 0 (resolved future 1)
[10:24:16.827] Relaying remaining futures
[10:24:16.827] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.827] - nx: 1
[10:24:16.827] - relay: TRUE
[10:24:16.827] - stdout: TRUE
[10:24:16.827] - signal: TRUE
[10:24:16.827] - resignal: FALSE
[10:24:16.827] - force: TRUE
[10:24:16.827] - relayed: [n=1] TRUE
[10:24:16.827] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.827] - relayed: [n=1] TRUE
[10:24:16.828] - queued futures: [n=1] TRUE
[10:24:16.828] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.828] resolve() on list ... DONE
[10:24:16.828]  - Number of value chunks collected: 1
[10:24:16.828] Resolving 1 futures (chunks) ... DONE
[10:24:16.828] Reducing values from 1 chunks ...
[10:24:16.828]  - Number of values collected after concatenation: 11
[10:24:16.828]  - Number of values expected: 11
[10:24:16.828] Reducing values from 1 chunks ... DONE
[10:24:16.828] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[10:24:16.829] future_lapply() ...
[10:24:16.831] Number of chunks: 1
[10:24:16.831] getGlobalsAndPackagesXApply() ...
[10:24:16.831]  - future.globals: TRUE
[10:24:16.831] getGlobalsAndPackages() ...
[10:24:16.831] Searching for globals...
[10:24:16.834] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:16.834] Searching for globals ... DONE
[10:24:16.834] Resolving globals: FALSE
[10:24:16.836] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[10:24:16.836] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.836] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.836] - packages: [1] ‘future.apply’
[10:24:16.836] getGlobalsAndPackages() ... DONE
[10:24:16.836]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.837]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.837] Finding globals ... DONE
[10:24:16.837]  - use_args: TRUE
[10:24:16.837]  - Getting '...' globals ...
[10:24:16.837] resolve() on list ...
[10:24:16.837]  recursive: 0
[10:24:16.837]  length: 1
[10:24:16.837]  elements: ‘...’
[10:24:16.838]  length: 0 (resolved future 1)
[10:24:16.838] resolve() on list ... DONE
[10:24:16.838]    - '...' content: [n=0] 
[10:24:16.838] List of 1
[10:24:16.838]  $ ...: list()
[10:24:16.838]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.838]  - attr(*, "where")=List of 1
[10:24:16.838]   ..$ ...:<environment: 0x55b93cd29e80> 
[10:24:16.838]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.838]  - attr(*, "resolved")= logi TRUE
[10:24:16.838]  - attr(*, "total_size")= num NA
[10:24:16.840]  - Getting '...' globals ... DONE
[10:24:16.840] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.840] List of 8
[10:24:16.840]  $ ...future.FUN:function (x, ...)  
[10:24:16.840]  $ x_FUN        :function (x)  
[10:24:16.840]  $ times        : int 1
[10:24:16.840]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.840]  $ stop_if_not  :function (...)  
[10:24:16.840]  $ dim          : NULL
[10:24:16.840]  $ valid_types  : chr [1:2] "logical" "integer"
[10:24:16.840]  $ ...          : list()
[10:24:16.840]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.840]  - attr(*, "where")=List of 8
[10:24:16.840]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.840]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.840]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.840]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.840]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.840]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.840]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.840]   ..$ ...          :<environment: 0x55b93cd29e80> 
[10:24:16.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.840]  - attr(*, "resolved")= logi FALSE
[10:24:16.840]  - attr(*, "total_size")= num 94264
[10:24:16.845] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.845] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.846] Number of futures (= number of chunks): 1
[10:24:16.846] Launching 1 futures (chunks) ...
[10:24:16.846] Chunk #1 of 1 ...
[10:24:16.846]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.846] getGlobalsAndPackages() ...
[10:24:16.846] Searching for globals...
[10:24:16.846] 
[10:24:16.846] Searching for globals ... DONE
[10:24:16.847] - globals: [0] <none>
[10:24:16.847] getGlobalsAndPackages() ... DONE
[10:24:16.847]    + additional globals found: [n=0] 
[10:24:16.847]    + additional namespaces needed: [n=0] 
[10:24:16.847]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.847]  - seeds: <none>
[10:24:16.847]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.847] getGlobalsAndPackages() ...
[10:24:16.847] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.847] Resolving globals: FALSE
[10:24:16.847] Tweak future expression to call with '...' arguments ...
[10:24:16.848] {
[10:24:16.848]     do.call(function(...) {
[10:24:16.848]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.848]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.848]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.848]             on.exit(options(oopts), add = TRUE)
[10:24:16.848]         }
[10:24:16.848]         {
[10:24:16.848]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.848]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.848]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.848]             })
[10:24:16.848]         }
[10:24:16.848]     }, args = future.call.arguments)
[10:24:16.848] }
[10:24:16.848] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.848] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.848] - packages: [1] ‘future.apply’
[10:24:16.848] getGlobalsAndPackages() ... DONE
[10:24:16.849] run() for ‘Future’ ...
[10:24:16.849] - state: ‘created’
[10:24:16.849] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.849] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.849] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.849]   - Field: ‘label’
[10:24:16.850]   - Field: ‘local’
[10:24:16.850]   - Field: ‘owner’
[10:24:16.850]   - Field: ‘envir’
[10:24:16.850]   - Field: ‘packages’
[10:24:16.850]   - Field: ‘gc’
[10:24:16.850]   - Field: ‘conditions’
[10:24:16.850]   - Field: ‘expr’
[10:24:16.850]   - Field: ‘uuid’
[10:24:16.850]   - Field: ‘seed’
[10:24:16.850]   - Field: ‘version’
[10:24:16.850]   - Field: ‘result’
[10:24:16.850]   - Field: ‘asynchronous’
[10:24:16.851]   - Field: ‘calls’
[10:24:16.851]   - Field: ‘globals’
[10:24:16.851]   - Field: ‘stdout’
[10:24:16.851]   - Field: ‘earlySignal’
[10:24:16.851]   - Field: ‘lazy’
[10:24:16.851]   - Field: ‘state’
[10:24:16.851] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.851] - Launch lazy future ...
[10:24:16.851] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.851] Packages needed by future strategies (n = 0): <none>
[10:24:16.852] {
[10:24:16.852]     {
[10:24:16.852]         {
[10:24:16.852]             ...future.startTime <- base::Sys.time()
[10:24:16.852]             {
[10:24:16.852]                 {
[10:24:16.852]                   {
[10:24:16.852]                     {
[10:24:16.852]                       base::local({
[10:24:16.852]                         has_future <- base::requireNamespace("future", 
[10:24:16.852]                           quietly = TRUE)
[10:24:16.852]                         if (has_future) {
[10:24:16.852]                           ns <- base::getNamespace("future")
[10:24:16.852]                           version <- ns[[".package"]][["version"]]
[10:24:16.852]                           if (is.null(version)) 
[10:24:16.852]                             version <- utils::packageVersion("future")
[10:24:16.852]                         }
[10:24:16.852]                         else {
[10:24:16.852]                           version <- NULL
[10:24:16.852]                         }
[10:24:16.852]                         if (!has_future || version < "1.8.0") {
[10:24:16.852]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.852]                             "", base::R.version$version.string), 
[10:24:16.852]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.852]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.852]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.852]                               "release", "version")], collapse = " "), 
[10:24:16.852]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.852]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.852]                             info)
[10:24:16.852]                           info <- base::paste(info, collapse = "; ")
[10:24:16.852]                           if (!has_future) {
[10:24:16.852]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.852]                               info)
[10:24:16.852]                           }
[10:24:16.852]                           else {
[10:24:16.852]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.852]                               info, version)
[10:24:16.852]                           }
[10:24:16.852]                           base::stop(msg)
[10:24:16.852]                         }
[10:24:16.852]                       })
[10:24:16.852]                     }
[10:24:16.852]                     base::local({
[10:24:16.852]                       for (pkg in "future.apply") {
[10:24:16.852]                         base::loadNamespace(pkg)
[10:24:16.852]                         base::library(pkg, character.only = TRUE)
[10:24:16.852]                       }
[10:24:16.852]                     })
[10:24:16.852]                   }
[10:24:16.852]                   options(future.plan = NULL)
[10:24:16.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.852]                 }
[10:24:16.852]                 ...future.workdir <- getwd()
[10:24:16.852]             }
[10:24:16.852]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.852]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.852]         }
[10:24:16.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.852]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.852]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.852]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.852]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.852]             base::names(...future.oldOptions))
[10:24:16.852]     }
[10:24:16.852]     if (FALSE) {
[10:24:16.852]     }
[10:24:16.852]     else {
[10:24:16.852]         if (TRUE) {
[10:24:16.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.852]                 open = "w")
[10:24:16.852]         }
[10:24:16.852]         else {
[10:24:16.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.852]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.852]         }
[10:24:16.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.852]             base::sink(type = "output", split = FALSE)
[10:24:16.852]             base::close(...future.stdout)
[10:24:16.852]         }, add = TRUE)
[10:24:16.852]     }
[10:24:16.852]     ...future.frame <- base::sys.nframe()
[10:24:16.852]     ...future.conditions <- base::list()
[10:24:16.852]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.852]     if (FALSE) {
[10:24:16.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.852]     }
[10:24:16.852]     ...future.result <- base::tryCatch({
[10:24:16.852]         base::withCallingHandlers({
[10:24:16.852]             ...future.value <- base::withVisible(base::local({
[10:24:16.852]                 do.call(function(...) {
[10:24:16.852]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.852]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.852]                     ...future.globals.maxSize)) {
[10:24:16.852]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.852]                     on.exit(options(oopts), add = TRUE)
[10:24:16.852]                   }
[10:24:16.852]                   {
[10:24:16.852]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.852]                       FUN = function(jj) {
[10:24:16.852]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.852]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.852]                       })
[10:24:16.852]                   }
[10:24:16.852]                 }, args = future.call.arguments)
[10:24:16.852]             }))
[10:24:16.852]             future::FutureResult(value = ...future.value$value, 
[10:24:16.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.852]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.852]                     ...future.globalenv.names))
[10:24:16.852]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.852]         }, condition = base::local({
[10:24:16.852]             c <- base::c
[10:24:16.852]             inherits <- base::inherits
[10:24:16.852]             invokeRestart <- base::invokeRestart
[10:24:16.852]             length <- base::length
[10:24:16.852]             list <- base::list
[10:24:16.852]             seq.int <- base::seq.int
[10:24:16.852]             signalCondition <- base::signalCondition
[10:24:16.852]             sys.calls <- base::sys.calls
[10:24:16.852]             `[[` <- base::`[[`
[10:24:16.852]             `+` <- base::`+`
[10:24:16.852]             `<<-` <- base::`<<-`
[10:24:16.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.852]                   3L)]
[10:24:16.852]             }
[10:24:16.852]             function(cond) {
[10:24:16.852]                 is_error <- inherits(cond, "error")
[10:24:16.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.852]                   NULL)
[10:24:16.852]                 if (is_error) {
[10:24:16.852]                   sessionInformation <- function() {
[10:24:16.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.852]                       search = base::search(), system = base::Sys.info())
[10:24:16.852]                   }
[10:24:16.852]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.852]                     cond$call), session = sessionInformation(), 
[10:24:16.852]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.852]                   signalCondition(cond)
[10:24:16.852]                 }
[10:24:16.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.852]                 "immediateCondition"))) {
[10:24:16.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.852]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.852]                   if (TRUE && !signal) {
[10:24:16.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.852]                     {
[10:24:16.852]                       inherits <- base::inherits
[10:24:16.852]                       invokeRestart <- base::invokeRestart
[10:24:16.852]                       is.null <- base::is.null
[10:24:16.852]                       muffled <- FALSE
[10:24:16.852]                       if (inherits(cond, "message")) {
[10:24:16.852]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.852]                         if (muffled) 
[10:24:16.852]                           invokeRestart("muffleMessage")
[10:24:16.852]                       }
[10:24:16.852]                       else if (inherits(cond, "warning")) {
[10:24:16.852]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.852]                         if (muffled) 
[10:24:16.852]                           invokeRestart("muffleWarning")
[10:24:16.852]                       }
[10:24:16.852]                       else if (inherits(cond, "condition")) {
[10:24:16.852]                         if (!is.null(pattern)) {
[10:24:16.852]                           computeRestarts <- base::computeRestarts
[10:24:16.852]                           grepl <- base::grepl
[10:24:16.852]                           restarts <- computeRestarts(cond)
[10:24:16.852]                           for (restart in restarts) {
[10:24:16.852]                             name <- restart$name
[10:24:16.852]                             if (is.null(name)) 
[10:24:16.852]                               next
[10:24:16.852]                             if (!grepl(pattern, name)) 
[10:24:16.852]                               next
[10:24:16.852]                             invokeRestart(restart)
[10:24:16.852]                             muffled <- TRUE
[10:24:16.852]                             break
[10:24:16.852]                           }
[10:24:16.852]                         }
[10:24:16.852]                       }
[10:24:16.852]                       invisible(muffled)
[10:24:16.852]                     }
[10:24:16.852]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.852]                   }
[10:24:16.852]                 }
[10:24:16.852]                 else {
[10:24:16.852]                   if (TRUE) {
[10:24:16.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.852]                     {
[10:24:16.852]                       inherits <- base::inherits
[10:24:16.852]                       invokeRestart <- base::invokeRestart
[10:24:16.852]                       is.null <- base::is.null
[10:24:16.852]                       muffled <- FALSE
[10:24:16.852]                       if (inherits(cond, "message")) {
[10:24:16.852]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.852]                         if (muffled) 
[10:24:16.852]                           invokeRestart("muffleMessage")
[10:24:16.852]                       }
[10:24:16.852]                       else if (inherits(cond, "warning")) {
[10:24:16.852]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.852]                         if (muffled) 
[10:24:16.852]                           invokeRestart("muffleWarning")
[10:24:16.852]                       }
[10:24:16.852]                       else if (inherits(cond, "condition")) {
[10:24:16.852]                         if (!is.null(pattern)) {
[10:24:16.852]                           computeRestarts <- base::computeRestarts
[10:24:16.852]                           grepl <- base::grepl
[10:24:16.852]                           restarts <- computeRestarts(cond)
[10:24:16.852]                           for (restart in restarts) {
[10:24:16.852]                             name <- restart$name
[10:24:16.852]                             if (is.null(name)) 
[10:24:16.852]                               next
[10:24:16.852]                             if (!grepl(pattern, name)) 
[10:24:16.852]                               next
[10:24:16.852]                             invokeRestart(restart)
[10:24:16.852]                             muffled <- TRUE
[10:24:16.852]                             break
[10:24:16.852]                           }
[10:24:16.852]                         }
[10:24:16.852]                       }
[10:24:16.852]                       invisible(muffled)
[10:24:16.852]                     }
[10:24:16.852]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.852]                   }
[10:24:16.852]                 }
[10:24:16.852]             }
[10:24:16.852]         }))
[10:24:16.852]     }, error = function(ex) {
[10:24:16.852]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.852]                 ...future.rng), started = ...future.startTime, 
[10:24:16.852]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.852]             version = "1.8"), class = "FutureResult")
[10:24:16.852]     }, finally = {
[10:24:16.852]         if (!identical(...future.workdir, getwd())) 
[10:24:16.852]             setwd(...future.workdir)
[10:24:16.852]         {
[10:24:16.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.852]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.852]             }
[10:24:16.852]             base::options(...future.oldOptions)
[10:24:16.852]             if (.Platform$OS.type == "windows") {
[10:24:16.852]                 old_names <- names(...future.oldEnvVars)
[10:24:16.852]                 envs <- base::Sys.getenv()
[10:24:16.852]                 names <- names(envs)
[10:24:16.852]                 common <- intersect(names, old_names)
[10:24:16.852]                 added <- setdiff(names, old_names)
[10:24:16.852]                 removed <- setdiff(old_names, names)
[10:24:16.852]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.852]                   envs[common]]
[10:24:16.852]                 NAMES <- toupper(changed)
[10:24:16.852]                 args <- list()
[10:24:16.852]                 for (kk in seq_along(NAMES)) {
[10:24:16.852]                   name <- changed[[kk]]
[10:24:16.852]                   NAME <- NAMES[[kk]]
[10:24:16.852]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.852]                     next
[10:24:16.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.852]                 }
[10:24:16.852]                 NAMES <- toupper(added)
[10:24:16.852]                 for (kk in seq_along(NAMES)) {
[10:24:16.852]                   name <- added[[kk]]
[10:24:16.852]                   NAME <- NAMES[[kk]]
[10:24:16.852]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.852]                     next
[10:24:16.852]                   args[[name]] <- ""
[10:24:16.852]                 }
[10:24:16.852]                 NAMES <- toupper(removed)
[10:24:16.852]                 for (kk in seq_along(NAMES)) {
[10:24:16.852]                   name <- removed[[kk]]
[10:24:16.852]                   NAME <- NAMES[[kk]]
[10:24:16.852]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.852]                     next
[10:24:16.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.852]                 }
[10:24:16.852]                 if (length(args) > 0) 
[10:24:16.852]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.852]             }
[10:24:16.852]             else {
[10:24:16.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.852]             }
[10:24:16.852]             {
[10:24:16.852]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.852]                   0L) {
[10:24:16.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.852]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.852]                   base::options(opts)
[10:24:16.852]                 }
[10:24:16.852]                 {
[10:24:16.852]                   {
[10:24:16.852]                     NULL
[10:24:16.852]                     RNGkind("Mersenne-Twister")
[10:24:16.852]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.852]                       inherits = FALSE)
[10:24:16.852]                   }
[10:24:16.852]                   options(future.plan = NULL)
[10:24:16.852]                   if (is.na(NA_character_)) 
[10:24:16.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.852]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.852]                   {
[10:24:16.852]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.852]                     if (!future$lazy) 
[10:24:16.852]                       future <- run(future)
[10:24:16.852]                     invisible(future)
[10:24:16.852]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.852]                 }
[10:24:16.852]             }
[10:24:16.852]         }
[10:24:16.852]     })
[10:24:16.852]     if (TRUE) {
[10:24:16.852]         base::sink(type = "output", split = FALSE)
[10:24:16.852]         if (TRUE) {
[10:24:16.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.852]         }
[10:24:16.852]         else {
[10:24:16.852]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.852]         }
[10:24:16.852]         base::close(...future.stdout)
[10:24:16.852]         ...future.stdout <- NULL
[10:24:16.852]     }
[10:24:16.852]     ...future.result$conditions <- ...future.conditions
[10:24:16.852]     ...future.result$finished <- base::Sys.time()
[10:24:16.852]     ...future.result
[10:24:16.852] }
[10:24:16.854] assign_globals() ...
[10:24:16.854] List of 11
[10:24:16.854]  $ ...future.FUN            :function (x, ...)  
[10:24:16.854]  $ x_FUN                    :function (x)  
[10:24:16.854]  $ times                    : int 1
[10:24:16.854]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.854]  $ stop_if_not              :function (...)  
[10:24:16.854]  $ dim                      : NULL
[10:24:16.854]  $ valid_types              : chr [1:2] "logical" "integer"
[10:24:16.854]  $ future.call.arguments    : list()
[10:24:16.854]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.854]  $ ...future.elements_ii    :List of 3
[10:24:16.854]   ..$ a: num 1
[10:24:16.854]   ..$ b: num 2
[10:24:16.854]   ..$ c: num 3
[10:24:16.854]  $ ...future.seeds_ii       : NULL
[10:24:16.854]  $ ...future.globals.maxSize: NULL
[10:24:16.854]  - attr(*, "where")=List of 11
[10:24:16.854]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.854]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.854]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.854]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.854]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.854]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.854]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.854]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.854]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.854]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.854]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.854]  - attr(*, "resolved")= logi FALSE
[10:24:16.854]  - attr(*, "total_size")= num 94264
[10:24:16.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.854]  - attr(*, "already-done")= logi TRUE
[10:24:16.862] - copied ‘...future.FUN’ to environment
[10:24:16.862] - copied ‘x_FUN’ to environment
[10:24:16.862] - copied ‘times’ to environment
[10:24:16.862] - copied ‘stopf’ to environment
[10:24:16.862] - copied ‘stop_if_not’ to environment
[10:24:16.863] - copied ‘dim’ to environment
[10:24:16.863] - copied ‘valid_types’ to environment
[10:24:16.863] - copied ‘future.call.arguments’ to environment
[10:24:16.863] - copied ‘...future.elements_ii’ to environment
[10:24:16.863] - copied ‘...future.seeds_ii’ to environment
[10:24:16.863] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.863] assign_globals() ... done
[10:24:16.863] plan(): Setting new future strategy stack:
[10:24:16.864] List of future strategies:
[10:24:16.864] 1. sequential:
[10:24:16.864]    - args: function (..., envir = parent.frame())
[10:24:16.864]    - tweaked: FALSE
[10:24:16.864]    - call: NULL
[10:24:16.864] plan(): nbrOfWorkers() = 1
[10:24:16.865] plan(): Setting new future strategy stack:
[10:24:16.865] List of future strategies:
[10:24:16.865] 1. sequential:
[10:24:16.865]    - args: function (..., envir = parent.frame())
[10:24:16.865]    - tweaked: FALSE
[10:24:16.865]    - call: plan(strategy)
[10:24:16.865] plan(): nbrOfWorkers() = 1
[10:24:16.865] SequentialFuture started (and completed)
[10:24:16.865] - Launch lazy future ... done
[10:24:16.865] run() for ‘SequentialFuture’ ... done
[10:24:16.865] Created future:
[10:24:16.866] SequentialFuture:
[10:24:16.866] Label: ‘future_vapply-1’
[10:24:16.866] Expression:
[10:24:16.866] {
[10:24:16.866]     do.call(function(...) {
[10:24:16.866]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.866]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.866]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.866]             on.exit(options(oopts), add = TRUE)
[10:24:16.866]         }
[10:24:16.866]         {
[10:24:16.866]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.866]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.866]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.866]             })
[10:24:16.866]         }
[10:24:16.866]     }, args = future.call.arguments)
[10:24:16.866] }
[10:24:16.866] Lazy evaluation: FALSE
[10:24:16.866] Asynchronous evaluation: FALSE
[10:24:16.866] Local evaluation: TRUE
[10:24:16.866] Environment: R_GlobalEnv
[10:24:16.866] Capture standard output: TRUE
[10:24:16.866] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.866] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.866] Packages: 1 packages (‘future.apply’)
[10:24:16.866] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.866] Resolved: TRUE
[10:24:16.866] Value: 168 bytes of class ‘list’
[10:24:16.866] Early signaling: FALSE
[10:24:16.866] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.866] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.867] Chunk #1 of 1 ... DONE
[10:24:16.867] Launching 1 futures (chunks) ... DONE
[10:24:16.867] Resolving 1 futures (chunks) ...
[10:24:16.867] resolve() on list ...
[10:24:16.867]  recursive: 0
[10:24:16.867]  length: 1
[10:24:16.867] 
[10:24:16.867] resolved() for ‘SequentialFuture’ ...
[10:24:16.867] - state: ‘finished’
[10:24:16.867] - run: TRUE
[10:24:16.867] - result: ‘FutureResult’
[10:24:16.868] resolved() for ‘SequentialFuture’ ... done
[10:24:16.868] Future #1
[10:24:16.868] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.868] - nx: 1
[10:24:16.868] - relay: TRUE
[10:24:16.868] - stdout: TRUE
[10:24:16.868] - signal: TRUE
[10:24:16.868] - resignal: FALSE
[10:24:16.868] - force: TRUE
[10:24:16.868] - relayed: [n=1] FALSE
[10:24:16.868] - queued futures: [n=1] FALSE
[10:24:16.869]  - until=1
[10:24:16.869]  - relaying element #1
[10:24:16.869] - relayed: [n=1] TRUE
[10:24:16.869] - queued futures: [n=1] TRUE
[10:24:16.869] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.869]  length: 0 (resolved future 1)
[10:24:16.869] Relaying remaining futures
[10:24:16.869] signalConditionsASAP(NULL, pos=0) ...
[10:24:16.869] - nx: 1
[10:24:16.869] - relay: TRUE
[10:24:16.869] - stdout: TRUE
[10:24:16.870] - signal: TRUE
[10:24:16.870] - resignal: FALSE
[10:24:16.870] - force: TRUE
[10:24:16.870] - relayed: [n=1] TRUE
[10:24:16.870] - queued futures: [n=1] TRUE
 - flush all
[10:24:16.870] - relayed: [n=1] TRUE
[10:24:16.870] - queued futures: [n=1] TRUE
[10:24:16.870] signalConditionsASAP(NULL, pos=0) ... done
[10:24:16.870] resolve() on list ... DONE
[10:24:16.870]  - Number of value chunks collected: 1
[10:24:16.870] Resolving 1 futures (chunks) ... DONE
[10:24:16.871] Reducing values from 1 chunks ...
[10:24:16.871]  - Number of values collected after concatenation: 3
[10:24:16.871]  - Number of values expected: 3
[10:24:16.871] Reducing values from 1 chunks ... DONE
[10:24:16.871] future_lapply() ... DONE
- exceptions ...
[10:24:16.871] future_lapply() ...
[10:24:16.873] Number of chunks: 1
[10:24:16.873] getGlobalsAndPackagesXApply() ...
[10:24:16.873]  - future.globals: TRUE
[10:24:16.873] getGlobalsAndPackages() ...
[10:24:16.873] Searching for globals...
[10:24:16.877] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:16.877] Searching for globals ... DONE
[10:24:16.877] Resolving globals: FALSE
[10:24:16.878] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[10:24:16.879] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.879] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.879] - packages: [1] ‘future.apply’
[10:24:16.879] getGlobalsAndPackages() ... DONE
[10:24:16.879]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.879]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.879] Finding globals ... DONE
[10:24:16.879]  - use_args: TRUE
[10:24:16.879]  - Getting '...' globals ...
[10:24:16.880] resolve() on list ...
[10:24:16.880]  recursive: 0
[10:24:16.880]  length: 1
[10:24:16.880]  elements: ‘...’
[10:24:16.880]  length: 0 (resolved future 1)
[10:24:16.880] resolve() on list ... DONE
[10:24:16.880]    - '...' content: [n=0] 
[10:24:16.880] List of 1
[10:24:16.880]  $ ...: list()
[10:24:16.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.880]  - attr(*, "where")=List of 1
[10:24:16.880]   ..$ ...:<environment: 0x55b93cfeec30> 
[10:24:16.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.880]  - attr(*, "resolved")= logi TRUE
[10:24:16.880]  - attr(*, "total_size")= num NA
[10:24:16.883]  - Getting '...' globals ... DONE
[10:24:16.883] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.883] List of 8
[10:24:16.883]  $ ...future.FUN:function (x, ...)  
[10:24:16.883]  $ x_FUN        :function (x)  
[10:24:16.883]  $ times        : int 2
[10:24:16.883]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.883]  $ stop_if_not  :function (...)  
[10:24:16.883]  $ dim          : NULL
[10:24:16.883]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:16.883]  $ ...          : list()
[10:24:16.883]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.883]  - attr(*, "where")=List of 8
[10:24:16.883]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.883]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.883]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.883]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.883]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.883]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.883]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.883]   ..$ ...          :<environment: 0x55b93cfeec30> 
[10:24:16.883]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.883]  - attr(*, "resolved")= logi FALSE
[10:24:16.883]  - attr(*, "total_size")= num 95128
[10:24:16.888] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.888] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.888] Number of futures (= number of chunks): 1
[10:24:16.888] Launching 1 futures (chunks) ...
[10:24:16.889] Chunk #1 of 1 ...
[10:24:16.889]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.889] getGlobalsAndPackages() ...
[10:24:16.889] Searching for globals...
[10:24:16.889] 
[10:24:16.889] Searching for globals ... DONE
[10:24:16.889] - globals: [0] <none>
[10:24:16.889] getGlobalsAndPackages() ... DONE
[10:24:16.889]    + additional globals found: [n=0] 
[10:24:16.890]    + additional namespaces needed: [n=0] 
[10:24:16.890]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.890]  - seeds: <none>
[10:24:16.890]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.890] getGlobalsAndPackages() ...
[10:24:16.890] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.890] Resolving globals: FALSE
[10:24:16.890] Tweak future expression to call with '...' arguments ...
[10:24:16.890] {
[10:24:16.890]     do.call(function(...) {
[10:24:16.890]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.890]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.890]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.890]             on.exit(options(oopts), add = TRUE)
[10:24:16.890]         }
[10:24:16.890]         {
[10:24:16.890]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.890]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.890]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.890]             })
[10:24:16.890]         }
[10:24:16.890]     }, args = future.call.arguments)
[10:24:16.890] }
[10:24:16.891] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.891] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.891] - packages: [1] ‘future.apply’
[10:24:16.891] getGlobalsAndPackages() ... DONE
[10:24:16.892] run() for ‘Future’ ...
[10:24:16.892] - state: ‘created’
[10:24:16.892] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:16.893] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.893] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:16.893]   - Field: ‘label’
[10:24:16.893]   - Field: ‘local’
[10:24:16.893]   - Field: ‘owner’
[10:24:16.893]   - Field: ‘envir’
[10:24:16.894]   - Field: ‘packages’
[10:24:16.894]   - Field: ‘gc’
[10:24:16.894]   - Field: ‘conditions’
[10:24:16.894]   - Field: ‘expr’
[10:24:16.894]   - Field: ‘uuid’
[10:24:16.894]   - Field: ‘seed’
[10:24:16.894]   - Field: ‘version’
[10:24:16.894]   - Field: ‘result’
[10:24:16.894]   - Field: ‘asynchronous’
[10:24:16.894]   - Field: ‘calls’
[10:24:16.894]   - Field: ‘globals’
[10:24:16.894]   - Field: ‘stdout’
[10:24:16.895]   - Field: ‘earlySignal’
[10:24:16.895]   - Field: ‘lazy’
[10:24:16.895]   - Field: ‘state’
[10:24:16.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:16.895] - Launch lazy future ...
[10:24:16.895] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.895] Packages needed by future strategies (n = 0): <none>
[10:24:16.896] {
[10:24:16.896]     {
[10:24:16.896]         {
[10:24:16.896]             ...future.startTime <- base::Sys.time()
[10:24:16.896]             {
[10:24:16.896]                 {
[10:24:16.896]                   {
[10:24:16.896]                     {
[10:24:16.896]                       base::local({
[10:24:16.896]                         has_future <- base::requireNamespace("future", 
[10:24:16.896]                           quietly = TRUE)
[10:24:16.896]                         if (has_future) {
[10:24:16.896]                           ns <- base::getNamespace("future")
[10:24:16.896]                           version <- ns[[".package"]][["version"]]
[10:24:16.896]                           if (is.null(version)) 
[10:24:16.896]                             version <- utils::packageVersion("future")
[10:24:16.896]                         }
[10:24:16.896]                         else {
[10:24:16.896]                           version <- NULL
[10:24:16.896]                         }
[10:24:16.896]                         if (!has_future || version < "1.8.0") {
[10:24:16.896]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.896]                             "", base::R.version$version.string), 
[10:24:16.896]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:16.896]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:16.896]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.896]                               "release", "version")], collapse = " "), 
[10:24:16.896]                             hostname = base::Sys.info()[["nodename"]])
[10:24:16.896]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.896]                             info)
[10:24:16.896]                           info <- base::paste(info, collapse = "; ")
[10:24:16.896]                           if (!has_future) {
[10:24:16.896]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.896]                               info)
[10:24:16.896]                           }
[10:24:16.896]                           else {
[10:24:16.896]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.896]                               info, version)
[10:24:16.896]                           }
[10:24:16.896]                           base::stop(msg)
[10:24:16.896]                         }
[10:24:16.896]                       })
[10:24:16.896]                     }
[10:24:16.896]                     base::local({
[10:24:16.896]                       for (pkg in "future.apply") {
[10:24:16.896]                         base::loadNamespace(pkg)
[10:24:16.896]                         base::library(pkg, character.only = TRUE)
[10:24:16.896]                       }
[10:24:16.896]                     })
[10:24:16.896]                   }
[10:24:16.896]                   options(future.plan = NULL)
[10:24:16.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.896]                 }
[10:24:16.896]                 ...future.workdir <- getwd()
[10:24:16.896]             }
[10:24:16.896]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.896]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.896]         }
[10:24:16.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.896]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:16.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.896]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.896]             base::names(...future.oldOptions))
[10:24:16.896]     }
[10:24:16.896]     if (FALSE) {
[10:24:16.896]     }
[10:24:16.896]     else {
[10:24:16.896]         if (TRUE) {
[10:24:16.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.896]                 open = "w")
[10:24:16.896]         }
[10:24:16.896]         else {
[10:24:16.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.896]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.896]         }
[10:24:16.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.896]             base::sink(type = "output", split = FALSE)
[10:24:16.896]             base::close(...future.stdout)
[10:24:16.896]         }, add = TRUE)
[10:24:16.896]     }
[10:24:16.896]     ...future.frame <- base::sys.nframe()
[10:24:16.896]     ...future.conditions <- base::list()
[10:24:16.896]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.896]     if (FALSE) {
[10:24:16.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.896]     }
[10:24:16.896]     ...future.result <- base::tryCatch({
[10:24:16.896]         base::withCallingHandlers({
[10:24:16.896]             ...future.value <- base::withVisible(base::local({
[10:24:16.896]                 do.call(function(...) {
[10:24:16.896]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.896]                   if (!identical(...future.globals.maxSize.org, 
[10:24:16.896]                     ...future.globals.maxSize)) {
[10:24:16.896]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.896]                     on.exit(options(oopts), add = TRUE)
[10:24:16.896]                   }
[10:24:16.896]                   {
[10:24:16.896]                     lapply(seq_along(...future.elements_ii), 
[10:24:16.896]                       FUN = function(jj) {
[10:24:16.896]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.896]                         ...future.FUN(...future.X_jj, ...)
[10:24:16.896]                       })
[10:24:16.896]                   }
[10:24:16.896]                 }, args = future.call.arguments)
[10:24:16.896]             }))
[10:24:16.896]             future::FutureResult(value = ...future.value$value, 
[10:24:16.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.896]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.896]                     ...future.globalenv.names))
[10:24:16.896]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.896]         }, condition = base::local({
[10:24:16.896]             c <- base::c
[10:24:16.896]             inherits <- base::inherits
[10:24:16.896]             invokeRestart <- base::invokeRestart
[10:24:16.896]             length <- base::length
[10:24:16.896]             list <- base::list
[10:24:16.896]             seq.int <- base::seq.int
[10:24:16.896]             signalCondition <- base::signalCondition
[10:24:16.896]             sys.calls <- base::sys.calls
[10:24:16.896]             `[[` <- base::`[[`
[10:24:16.896]             `+` <- base::`+`
[10:24:16.896]             `<<-` <- base::`<<-`
[10:24:16.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.896]                   3L)]
[10:24:16.896]             }
[10:24:16.896]             function(cond) {
[10:24:16.896]                 is_error <- inherits(cond, "error")
[10:24:16.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.896]                   NULL)
[10:24:16.896]                 if (is_error) {
[10:24:16.896]                   sessionInformation <- function() {
[10:24:16.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.896]                       search = base::search(), system = base::Sys.info())
[10:24:16.896]                   }
[10:24:16.896]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.896]                     cond$call), session = sessionInformation(), 
[10:24:16.896]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.896]                   signalCondition(cond)
[10:24:16.896]                 }
[10:24:16.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.896]                 "immediateCondition"))) {
[10:24:16.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.896]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.896]                   if (TRUE && !signal) {
[10:24:16.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.896]                     {
[10:24:16.896]                       inherits <- base::inherits
[10:24:16.896]                       invokeRestart <- base::invokeRestart
[10:24:16.896]                       is.null <- base::is.null
[10:24:16.896]                       muffled <- FALSE
[10:24:16.896]                       if (inherits(cond, "message")) {
[10:24:16.896]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.896]                         if (muffled) 
[10:24:16.896]                           invokeRestart("muffleMessage")
[10:24:16.896]                       }
[10:24:16.896]                       else if (inherits(cond, "warning")) {
[10:24:16.896]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.896]                         if (muffled) 
[10:24:16.896]                           invokeRestart("muffleWarning")
[10:24:16.896]                       }
[10:24:16.896]                       else if (inherits(cond, "condition")) {
[10:24:16.896]                         if (!is.null(pattern)) {
[10:24:16.896]                           computeRestarts <- base::computeRestarts
[10:24:16.896]                           grepl <- base::grepl
[10:24:16.896]                           restarts <- computeRestarts(cond)
[10:24:16.896]                           for (restart in restarts) {
[10:24:16.896]                             name <- restart$name
[10:24:16.896]                             if (is.null(name)) 
[10:24:16.896]                               next
[10:24:16.896]                             if (!grepl(pattern, name)) 
[10:24:16.896]                               next
[10:24:16.896]                             invokeRestart(restart)
[10:24:16.896]                             muffled <- TRUE
[10:24:16.896]                             break
[10:24:16.896]                           }
[10:24:16.896]                         }
[10:24:16.896]                       }
[10:24:16.896]                       invisible(muffled)
[10:24:16.896]                     }
[10:24:16.896]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.896]                   }
[10:24:16.896]                 }
[10:24:16.896]                 else {
[10:24:16.896]                   if (TRUE) {
[10:24:16.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.896]                     {
[10:24:16.896]                       inherits <- base::inherits
[10:24:16.896]                       invokeRestart <- base::invokeRestart
[10:24:16.896]                       is.null <- base::is.null
[10:24:16.896]                       muffled <- FALSE
[10:24:16.896]                       if (inherits(cond, "message")) {
[10:24:16.896]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.896]                         if (muffled) 
[10:24:16.896]                           invokeRestart("muffleMessage")
[10:24:16.896]                       }
[10:24:16.896]                       else if (inherits(cond, "warning")) {
[10:24:16.896]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.896]                         if (muffled) 
[10:24:16.896]                           invokeRestart("muffleWarning")
[10:24:16.896]                       }
[10:24:16.896]                       else if (inherits(cond, "condition")) {
[10:24:16.896]                         if (!is.null(pattern)) {
[10:24:16.896]                           computeRestarts <- base::computeRestarts
[10:24:16.896]                           grepl <- base::grepl
[10:24:16.896]                           restarts <- computeRestarts(cond)
[10:24:16.896]                           for (restart in restarts) {
[10:24:16.896]                             name <- restart$name
[10:24:16.896]                             if (is.null(name)) 
[10:24:16.896]                               next
[10:24:16.896]                             if (!grepl(pattern, name)) 
[10:24:16.896]                               next
[10:24:16.896]                             invokeRestart(restart)
[10:24:16.896]                             muffled <- TRUE
[10:24:16.896]                             break
[10:24:16.896]                           }
[10:24:16.896]                         }
[10:24:16.896]                       }
[10:24:16.896]                       invisible(muffled)
[10:24:16.896]                     }
[10:24:16.896]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.896]                   }
[10:24:16.896]                 }
[10:24:16.896]             }
[10:24:16.896]         }))
[10:24:16.896]     }, error = function(ex) {
[10:24:16.896]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.896]                 ...future.rng), started = ...future.startTime, 
[10:24:16.896]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.896]             version = "1.8"), class = "FutureResult")
[10:24:16.896]     }, finally = {
[10:24:16.896]         if (!identical(...future.workdir, getwd())) 
[10:24:16.896]             setwd(...future.workdir)
[10:24:16.896]         {
[10:24:16.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.896]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.896]             }
[10:24:16.896]             base::options(...future.oldOptions)
[10:24:16.896]             if (.Platform$OS.type == "windows") {
[10:24:16.896]                 old_names <- names(...future.oldEnvVars)
[10:24:16.896]                 envs <- base::Sys.getenv()
[10:24:16.896]                 names <- names(envs)
[10:24:16.896]                 common <- intersect(names, old_names)
[10:24:16.896]                 added <- setdiff(names, old_names)
[10:24:16.896]                 removed <- setdiff(old_names, names)
[10:24:16.896]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.896]                   envs[common]]
[10:24:16.896]                 NAMES <- toupper(changed)
[10:24:16.896]                 args <- list()
[10:24:16.896]                 for (kk in seq_along(NAMES)) {
[10:24:16.896]                   name <- changed[[kk]]
[10:24:16.896]                   NAME <- NAMES[[kk]]
[10:24:16.896]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.896]                     next
[10:24:16.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.896]                 }
[10:24:16.896]                 NAMES <- toupper(added)
[10:24:16.896]                 for (kk in seq_along(NAMES)) {
[10:24:16.896]                   name <- added[[kk]]
[10:24:16.896]                   NAME <- NAMES[[kk]]
[10:24:16.896]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.896]                     next
[10:24:16.896]                   args[[name]] <- ""
[10:24:16.896]                 }
[10:24:16.896]                 NAMES <- toupper(removed)
[10:24:16.896]                 for (kk in seq_along(NAMES)) {
[10:24:16.896]                   name <- removed[[kk]]
[10:24:16.896]                   NAME <- NAMES[[kk]]
[10:24:16.896]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.896]                     next
[10:24:16.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.896]                 }
[10:24:16.896]                 if (length(args) > 0) 
[10:24:16.896]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.896]             }
[10:24:16.896]             else {
[10:24:16.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.896]             }
[10:24:16.896]             {
[10:24:16.896]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.896]                   0L) {
[10:24:16.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.896]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.896]                   base::options(opts)
[10:24:16.896]                 }
[10:24:16.896]                 {
[10:24:16.896]                   {
[10:24:16.896]                     NULL
[10:24:16.896]                     RNGkind("Mersenne-Twister")
[10:24:16.896]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:16.896]                       inherits = FALSE)
[10:24:16.896]                   }
[10:24:16.896]                   options(future.plan = NULL)
[10:24:16.896]                   if (is.na(NA_character_)) 
[10:24:16.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.896]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:16.896]                   {
[10:24:16.896]                     future <- SequentialFuture(..., envir = envir)
[10:24:16.896]                     if (!future$lazy) 
[10:24:16.896]                       future <- run(future)
[10:24:16.896]                     invisible(future)
[10:24:16.896]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.896]                 }
[10:24:16.896]             }
[10:24:16.896]         }
[10:24:16.896]     })
[10:24:16.896]     if (TRUE) {
[10:24:16.896]         base::sink(type = "output", split = FALSE)
[10:24:16.896]         if (TRUE) {
[10:24:16.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.896]         }
[10:24:16.896]         else {
[10:24:16.896]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.896]         }
[10:24:16.896]         base::close(...future.stdout)
[10:24:16.896]         ...future.stdout <- NULL
[10:24:16.896]     }
[10:24:16.896]     ...future.result$conditions <- ...future.conditions
[10:24:16.896]     ...future.result$finished <- base::Sys.time()
[10:24:16.896]     ...future.result
[10:24:16.896] }
[10:24:16.897] assign_globals() ...
[10:24:16.897] List of 11
[10:24:16.897]  $ ...future.FUN            :function (x, ...)  
[10:24:16.897]  $ x_FUN                    :function (x)  
[10:24:16.897]  $ times                    : int 2
[10:24:16.897]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.897]  $ stop_if_not              :function (...)  
[10:24:16.897]  $ dim                      : NULL
[10:24:16.897]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:16.897]  $ future.call.arguments    : list()
[10:24:16.897]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.897]  $ ...future.elements_ii    :List of 3
[10:24:16.897]   ..$ : int 1
[10:24:16.897]   ..$ : int 2
[10:24:16.897]   ..$ : int 3
[10:24:16.897]  $ ...future.seeds_ii       : NULL
[10:24:16.897]  $ ...future.globals.maxSize: NULL
[10:24:16.897]  - attr(*, "where")=List of 11
[10:24:16.897]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.897]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.897]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.897]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.897]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.897]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.897]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.897]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.897]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.897]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.897]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.897]  - attr(*, "resolved")= logi FALSE
[10:24:16.897]  - attr(*, "total_size")= num 95128
[10:24:16.897]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.897]  - attr(*, "already-done")= logi TRUE
[10:24:16.905] - copied ‘...future.FUN’ to environment
[10:24:16.905] - copied ‘x_FUN’ to environment
[10:24:16.905] - copied ‘times’ to environment
[10:24:16.905] - copied ‘stopf’ to environment
[10:24:16.905] - copied ‘stop_if_not’ to environment
[10:24:16.905] - copied ‘dim’ to environment
[10:24:16.905] - copied ‘valid_types’ to environment
[10:24:16.906] - copied ‘future.call.arguments’ to environment
[10:24:16.906] - copied ‘...future.elements_ii’ to environment
[10:24:16.906] - copied ‘...future.seeds_ii’ to environment
[10:24:16.906] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.906] assign_globals() ... done
[10:24:16.906] plan(): Setting new future strategy stack:
[10:24:16.906] List of future strategies:
[10:24:16.906] 1. sequential:
[10:24:16.906]    - args: function (..., envir = parent.frame())
[10:24:16.906]    - tweaked: FALSE
[10:24:16.906]    - call: NULL
[10:24:16.907] plan(): nbrOfWorkers() = 1
[10:24:16.908] plan(): Setting new future strategy stack:
[10:24:16.908] List of future strategies:
[10:24:16.908] 1. sequential:
[10:24:16.908]    - args: function (..., envir = parent.frame())
[10:24:16.908]    - tweaked: FALSE
[10:24:16.908]    - call: plan(strategy)
[10:24:16.908] plan(): nbrOfWorkers() = 1
[10:24:16.908] SequentialFuture started (and completed)
[10:24:16.909] signalConditions() ...
[10:24:16.909]  - include = ‘immediateCondition’
[10:24:16.909]  - exclude = 
[10:24:16.909]  - resignal = FALSE
[10:24:16.909]  - Number of conditions: 1
[10:24:16.909] signalConditions() ... done
[10:24:16.909] - Launch lazy future ... done
[10:24:16.910] run() for ‘SequentialFuture’ ... done
[10:24:16.910] Created future:
[10:24:16.910] SequentialFuture:
[10:24:16.910] Label: ‘future_vapply-1’
[10:24:16.910] Expression:
[10:24:16.910] {
[10:24:16.910]     do.call(function(...) {
[10:24:16.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.910]             on.exit(options(oopts), add = TRUE)
[10:24:16.910]         }
[10:24:16.910]         {
[10:24:16.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.910]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.910]             })
[10:24:16.910]         }
[10:24:16.910]     }, args = future.call.arguments)
[10:24:16.910] }
[10:24:16.910] Lazy evaluation: FALSE
[10:24:16.910] Asynchronous evaluation: FALSE
[10:24:16.910] Local evaluation: TRUE
[10:24:16.910] Environment: R_GlobalEnv
[10:24:16.910] Capture standard output: TRUE
[10:24:16.910] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.910] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.910] Packages: 1 packages (‘future.apply’)
[10:24:16.910] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.910] Resolved: TRUE
[10:24:16.910] Value: 0 bytes of class ‘NULL’
[10:24:16.910] Conditions captured: [n=1] ‘simpleError’
[10:24:16.910] Early signaling: FALSE
[10:24:16.910] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.910] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:16.911] Chunk #1 of 1 ... DONE
[10:24:16.912] Launching 1 futures (chunks) ... DONE
[10:24:16.912] Resolving 1 futures (chunks) ...
[10:24:16.912] resolve() on list ...
[10:24:16.912]  recursive: 0
[10:24:16.912]  length: 1
[10:24:16.912] 
[10:24:16.912] resolved() for ‘SequentialFuture’ ...
[10:24:16.912] - state: ‘finished’
[10:24:16.913] - run: TRUE
[10:24:16.913] - result: ‘FutureResult’
[10:24:16.913] resolved() for ‘SequentialFuture’ ... done
[10:24:16.913] Future #1
[10:24:16.913] signalConditions() ...
[10:24:16.913]  - include = ‘immediateCondition’
[10:24:16.913]  - exclude = 
[10:24:16.913]  - resignal = FALSE
[10:24:16.914]  - Number of conditions: 1
[10:24:16.914] signalConditions() ... done
[10:24:16.914] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:16.914] - nx: 1
[10:24:16.914] - relay: TRUE
[10:24:16.914] - stdout: TRUE
[10:24:16.914] - signal: TRUE
[10:24:16.915] - resignal: FALSE
[10:24:16.916] - force: TRUE
[10:24:16.916] - relayed: [n=1] FALSE
[10:24:16.916] - queued futures: [n=1] FALSE
[10:24:16.916]  - until=1
[10:24:16.916]  - relaying element #1
[10:24:16.916] signalConditions() ...
[10:24:16.916]  - include = ‘immediateCondition’
[10:24:16.916]  - exclude = 
[10:24:16.916]  - resignal = FALSE
[10:24:16.916]  - Number of conditions: 1
[10:24:16.917] signalConditions() ... done
[10:24:16.917] signalConditions() ...
[10:24:16.917]  - include = ‘immediateCondition’
[10:24:16.917]  - exclude = 
[10:24:16.917]  - resignal = FALSE
[10:24:16.917]  - Number of conditions: 1
[10:24:16.917] signalConditions() ... done
[10:24:16.917] signalConditions() ...
[10:24:16.917]  - include = ‘condition’
[10:24:16.918]  - exclude = ‘immediateCondition’
[10:24:16.918]  - resignal = TRUE
[10:24:16.918]  - Number of conditions: 1
[10:24:16.918]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:24:16.918] signalConditions() ... done
[10:24:16.918] - relayed: [n=1] FALSE
[10:24:16.918] - queued futures: [n=1] TRUE
[10:24:16.918] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:16.918] plan(): Setting new future strategy stack:
[10:24:16.918] List of future strategies:
[10:24:16.918] 1. sequential:
[10:24:16.918]    - args: function (..., envir = parent.frame())
[10:24:16.918]    - tweaked: FALSE
[10:24:16.918]    - call: plan(sequential)
[10:24:16.919] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:24:16.919] plan(): Setting new future strategy stack:
[10:24:16.919] List of future strategies:
[10:24:16.919] 1. multicore:
[10:24:16.919]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:16.919]    - tweaked: FALSE
[10:24:16.919]    - call: plan(strategy)
[10:24:16.923] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[10:24:16.925] future_lapply() ...
[10:24:16.931] Number of chunks: 2
[10:24:16.931] getGlobalsAndPackagesXApply() ...
[10:24:16.931]  - future.globals: TRUE
[10:24:16.931] getGlobalsAndPackages() ...
[10:24:16.931] Searching for globals...
[10:24:16.934] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:16.934] Searching for globals ... DONE
[10:24:16.934] Resolving globals: FALSE
[10:24:16.935] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[10:24:16.935] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:16.935] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.936] - packages: [1] ‘future.apply’
[10:24:16.936] getGlobalsAndPackages() ... DONE
[10:24:16.936]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:16.936]  - needed namespaces: [n=1] ‘future.apply’
[10:24:16.936] Finding globals ... DONE
[10:24:16.936]  - use_args: TRUE
[10:24:16.936]  - Getting '...' globals ...
[10:24:16.936] resolve() on list ...
[10:24:16.937]  recursive: 0
[10:24:16.937]  length: 1
[10:24:16.937]  elements: ‘...’
[10:24:16.937]  length: 0 (resolved future 1)
[10:24:16.937] resolve() on list ... DONE
[10:24:16.937]    - '...' content: [n=0] 
[10:24:16.937] List of 1
[10:24:16.937]  $ ...: list()
[10:24:16.937]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.937]  - attr(*, "where")=List of 1
[10:24:16.937]   ..$ ...:<environment: 0x55b93b8a67e0> 
[10:24:16.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.937]  - attr(*, "resolved")= logi TRUE
[10:24:16.937]  - attr(*, "total_size")= num NA
[10:24:16.942]  - Getting '...' globals ... DONE
[10:24:16.942] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:16.942] List of 8
[10:24:16.942]  $ ...future.FUN:function (x, ...)  
[10:24:16.942]  $ x_FUN        :function (x)  
[10:24:16.942]  $ times        : int 1
[10:24:16.942]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.942]  $ stop_if_not  :function (...)  
[10:24:16.942]  $ dim          : NULL
[10:24:16.942]  $ valid_types  : chr "character"
[10:24:16.942]  $ ...          : list()
[10:24:16.942]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.942]  - attr(*, "where")=List of 8
[10:24:16.942]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:16.942]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:16.942]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:16.942]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:16.942]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:16.942]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:16.942]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:16.942]   ..$ ...          :<environment: 0x55b93b8a67e0> 
[10:24:16.942]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.942]  - attr(*, "resolved")= logi FALSE
[10:24:16.942]  - attr(*, "total_size")= num 94208
[10:24:16.948] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:16.948] getGlobalsAndPackagesXApply() ... DONE
[10:24:16.948] Number of futures (= number of chunks): 2
[10:24:16.948] Launching 2 futures (chunks) ...
[10:24:16.948] Chunk #1 of 2 ...
[10:24:16.948]  - Finding globals in 'X' for chunk #1 ...
[10:24:16.949] getGlobalsAndPackages() ...
[10:24:16.949] Searching for globals...
[10:24:16.949] 
[10:24:16.949] Searching for globals ... DONE
[10:24:16.949] - globals: [0] <none>
[10:24:16.949] getGlobalsAndPackages() ... DONE
[10:24:16.949]    + additional globals found: [n=0] 
[10:24:16.949]    + additional namespaces needed: [n=0] 
[10:24:16.949]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:16.950]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:16.950]  - seeds: <none>
[10:24:16.950]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.950] getGlobalsAndPackages() ...
[10:24:16.950] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.950] Resolving globals: FALSE
[10:24:16.950] Tweak future expression to call with '...' arguments ...
[10:24:16.950] {
[10:24:16.950]     do.call(function(...) {
[10:24:16.950]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.950]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.950]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.950]             on.exit(options(oopts), add = TRUE)
[10:24:16.950]         }
[10:24:16.950]         {
[10:24:16.950]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.950]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.950]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.950]             })
[10:24:16.950]         }
[10:24:16.950]     }, args = future.call.arguments)
[10:24:16.950] }
[10:24:16.951] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.951] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.951] - packages: [1] ‘future.apply’
[10:24:16.951] getGlobalsAndPackages() ... DONE
[10:24:16.952] run() for ‘Future’ ...
[10:24:16.952] - state: ‘created’
[10:24:16.952] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:16.955] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:16.955] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:16.956]   - Field: ‘label’
[10:24:16.956]   - Field: ‘local’
[10:24:16.956]   - Field: ‘owner’
[10:24:16.956]   - Field: ‘envir’
[10:24:16.956]   - Field: ‘workers’
[10:24:16.956]   - Field: ‘packages’
[10:24:16.956]   - Field: ‘gc’
[10:24:16.956]   - Field: ‘job’
[10:24:16.956]   - Field: ‘conditions’
[10:24:16.956]   - Field: ‘expr’
[10:24:16.957]   - Field: ‘uuid’
[10:24:16.957]   - Field: ‘seed’
[10:24:16.957]   - Field: ‘version’
[10:24:16.957]   - Field: ‘result’
[10:24:16.957]   - Field: ‘asynchronous’
[10:24:16.957]   - Field: ‘calls’
[10:24:16.957]   - Field: ‘globals’
[10:24:16.957]   - Field: ‘stdout’
[10:24:16.957]   - Field: ‘earlySignal’
[10:24:16.957]   - Field: ‘lazy’
[10:24:16.957]   - Field: ‘state’
[10:24:16.958] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:16.958] - Launch lazy future ...
[10:24:16.959] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:16.959] Packages needed by future strategies (n = 0): <none>
[10:24:16.959] {
[10:24:16.959]     {
[10:24:16.959]         {
[10:24:16.959]             ...future.startTime <- base::Sys.time()
[10:24:16.959]             {
[10:24:16.959]                 {
[10:24:16.959]                   {
[10:24:16.959]                     {
[10:24:16.959]                       {
[10:24:16.959]                         base::local({
[10:24:16.959]                           has_future <- base::requireNamespace("future", 
[10:24:16.959]                             quietly = TRUE)
[10:24:16.959]                           if (has_future) {
[10:24:16.959]                             ns <- base::getNamespace("future")
[10:24:16.959]                             version <- ns[[".package"]][["version"]]
[10:24:16.959]                             if (is.null(version)) 
[10:24:16.959]                               version <- utils::packageVersion("future")
[10:24:16.959]                           }
[10:24:16.959]                           else {
[10:24:16.959]                             version <- NULL
[10:24:16.959]                           }
[10:24:16.959]                           if (!has_future || version < "1.8.0") {
[10:24:16.959]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:16.959]                               "", base::R.version$version.string), 
[10:24:16.959]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:16.959]                                 base::R.version$platform, 8 * 
[10:24:16.959]                                   base::.Machine$sizeof.pointer), 
[10:24:16.959]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:16.959]                                 "release", "version")], collapse = " "), 
[10:24:16.959]                               hostname = base::Sys.info()[["nodename"]])
[10:24:16.959]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:16.959]                               info)
[10:24:16.959]                             info <- base::paste(info, collapse = "; ")
[10:24:16.959]                             if (!has_future) {
[10:24:16.959]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:16.959]                                 info)
[10:24:16.959]                             }
[10:24:16.959]                             else {
[10:24:16.959]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:16.959]                                 info, version)
[10:24:16.959]                             }
[10:24:16.959]                             base::stop(msg)
[10:24:16.959]                           }
[10:24:16.959]                         })
[10:24:16.959]                       }
[10:24:16.959]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:16.959]                       base::options(mc.cores = 1L)
[10:24:16.959]                     }
[10:24:16.959]                     base::local({
[10:24:16.959]                       for (pkg in "future.apply") {
[10:24:16.959]                         base::loadNamespace(pkg)
[10:24:16.959]                         base::library(pkg, character.only = TRUE)
[10:24:16.959]                       }
[10:24:16.959]                     })
[10:24:16.959]                   }
[10:24:16.959]                   options(future.plan = NULL)
[10:24:16.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:16.959]                 }
[10:24:16.959]                 ...future.workdir <- getwd()
[10:24:16.959]             }
[10:24:16.959]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:16.959]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:16.959]         }
[10:24:16.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:16.959]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:16.959]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:16.959]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:16.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:16.959]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:16.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:16.959]             base::names(...future.oldOptions))
[10:24:16.959]     }
[10:24:16.959]     if (FALSE) {
[10:24:16.959]     }
[10:24:16.959]     else {
[10:24:16.959]         if (TRUE) {
[10:24:16.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:16.959]                 open = "w")
[10:24:16.959]         }
[10:24:16.959]         else {
[10:24:16.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:16.959]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:16.959]         }
[10:24:16.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:16.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:16.959]             base::sink(type = "output", split = FALSE)
[10:24:16.959]             base::close(...future.stdout)
[10:24:16.959]         }, add = TRUE)
[10:24:16.959]     }
[10:24:16.959]     ...future.frame <- base::sys.nframe()
[10:24:16.959]     ...future.conditions <- base::list()
[10:24:16.959]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:16.959]     if (FALSE) {
[10:24:16.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:16.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:16.959]     }
[10:24:16.959]     ...future.result <- base::tryCatch({
[10:24:16.959]         base::withCallingHandlers({
[10:24:16.959]             ...future.value <- base::withVisible(base::local({
[10:24:16.959]                 withCallingHandlers({
[10:24:16.959]                   {
[10:24:16.959]                     do.call(function(...) {
[10:24:16.959]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.959]                       if (!identical(...future.globals.maxSize.org, 
[10:24:16.959]                         ...future.globals.maxSize)) {
[10:24:16.959]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.959]                         on.exit(options(oopts), add = TRUE)
[10:24:16.959]                       }
[10:24:16.959]                       {
[10:24:16.959]                         lapply(seq_along(...future.elements_ii), 
[10:24:16.959]                           FUN = function(jj) {
[10:24:16.959]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.959]                             ...future.FUN(...future.X_jj, ...)
[10:24:16.959]                           })
[10:24:16.959]                       }
[10:24:16.959]                     }, args = future.call.arguments)
[10:24:16.959]                   }
[10:24:16.959]                 }, immediateCondition = function(cond) {
[10:24:16.959]                   save_rds <- function (object, pathname, ...) 
[10:24:16.959]                   {
[10:24:16.959]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:16.959]                     if (file_test("-f", pathname_tmp)) {
[10:24:16.959]                       fi_tmp <- file.info(pathname_tmp)
[10:24:16.959]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:16.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:16.959]                         fi_tmp[["mtime"]])
[10:24:16.959]                     }
[10:24:16.959]                     tryCatch({
[10:24:16.959]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:16.959]                     }, error = function(ex) {
[10:24:16.959]                       msg <- conditionMessage(ex)
[10:24:16.959]                       fi_tmp <- file.info(pathname_tmp)
[10:24:16.959]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:16.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:16.959]                         fi_tmp[["mtime"]], msg)
[10:24:16.959]                       ex$message <- msg
[10:24:16.959]                       stop(ex)
[10:24:16.959]                     })
[10:24:16.959]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:16.959]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:16.959]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:16.959]                       fi_tmp <- file.info(pathname_tmp)
[10:24:16.959]                       fi <- file.info(pathname)
[10:24:16.959]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:16.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:16.959]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:16.959]                         fi[["size"]], fi[["mtime"]])
[10:24:16.959]                       stop(msg)
[10:24:16.959]                     }
[10:24:16.959]                     invisible(pathname)
[10:24:16.959]                   }
[10:24:16.959]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:16.959]                     rootPath = tempdir()) 
[10:24:16.959]                   {
[10:24:16.959]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:16.959]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:16.959]                       tmpdir = path, fileext = ".rds")
[10:24:16.959]                     save_rds(obj, file)
[10:24:16.959]                   }
[10:24:16.959]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:16.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.959]                   {
[10:24:16.959]                     inherits <- base::inherits
[10:24:16.959]                     invokeRestart <- base::invokeRestart
[10:24:16.959]                     is.null <- base::is.null
[10:24:16.959]                     muffled <- FALSE
[10:24:16.959]                     if (inherits(cond, "message")) {
[10:24:16.959]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:16.959]                       if (muffled) 
[10:24:16.959]                         invokeRestart("muffleMessage")
[10:24:16.959]                     }
[10:24:16.959]                     else if (inherits(cond, "warning")) {
[10:24:16.959]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:16.959]                       if (muffled) 
[10:24:16.959]                         invokeRestart("muffleWarning")
[10:24:16.959]                     }
[10:24:16.959]                     else if (inherits(cond, "condition")) {
[10:24:16.959]                       if (!is.null(pattern)) {
[10:24:16.959]                         computeRestarts <- base::computeRestarts
[10:24:16.959]                         grepl <- base::grepl
[10:24:16.959]                         restarts <- computeRestarts(cond)
[10:24:16.959]                         for (restart in restarts) {
[10:24:16.959]                           name <- restart$name
[10:24:16.959]                           if (is.null(name)) 
[10:24:16.959]                             next
[10:24:16.959]                           if (!grepl(pattern, name)) 
[10:24:16.959]                             next
[10:24:16.959]                           invokeRestart(restart)
[10:24:16.959]                           muffled <- TRUE
[10:24:16.959]                           break
[10:24:16.959]                         }
[10:24:16.959]                       }
[10:24:16.959]                     }
[10:24:16.959]                     invisible(muffled)
[10:24:16.959]                   }
[10:24:16.959]                   muffleCondition(cond)
[10:24:16.959]                 })
[10:24:16.959]             }))
[10:24:16.959]             future::FutureResult(value = ...future.value$value, 
[10:24:16.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.959]                   ...future.rng), globalenv = if (FALSE) 
[10:24:16.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:16.959]                     ...future.globalenv.names))
[10:24:16.959]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:16.959]         }, condition = base::local({
[10:24:16.959]             c <- base::c
[10:24:16.959]             inherits <- base::inherits
[10:24:16.959]             invokeRestart <- base::invokeRestart
[10:24:16.959]             length <- base::length
[10:24:16.959]             list <- base::list
[10:24:16.959]             seq.int <- base::seq.int
[10:24:16.959]             signalCondition <- base::signalCondition
[10:24:16.959]             sys.calls <- base::sys.calls
[10:24:16.959]             `[[` <- base::`[[`
[10:24:16.959]             `+` <- base::`+`
[10:24:16.959]             `<<-` <- base::`<<-`
[10:24:16.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:16.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:16.959]                   3L)]
[10:24:16.959]             }
[10:24:16.959]             function(cond) {
[10:24:16.959]                 is_error <- inherits(cond, "error")
[10:24:16.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:16.959]                   NULL)
[10:24:16.959]                 if (is_error) {
[10:24:16.959]                   sessionInformation <- function() {
[10:24:16.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:16.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:16.959]                       search = base::search(), system = base::Sys.info())
[10:24:16.959]                   }
[10:24:16.959]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:16.959]                     cond$call), session = sessionInformation(), 
[10:24:16.959]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:16.959]                   signalCondition(cond)
[10:24:16.959]                 }
[10:24:16.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:16.959]                 "immediateCondition"))) {
[10:24:16.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:16.959]                   ...future.conditions[[length(...future.conditions) + 
[10:24:16.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:16.959]                   if (TRUE && !signal) {
[10:24:16.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.959]                     {
[10:24:16.959]                       inherits <- base::inherits
[10:24:16.959]                       invokeRestart <- base::invokeRestart
[10:24:16.959]                       is.null <- base::is.null
[10:24:16.959]                       muffled <- FALSE
[10:24:16.959]                       if (inherits(cond, "message")) {
[10:24:16.959]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.959]                         if (muffled) 
[10:24:16.959]                           invokeRestart("muffleMessage")
[10:24:16.959]                       }
[10:24:16.959]                       else if (inherits(cond, "warning")) {
[10:24:16.959]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.959]                         if (muffled) 
[10:24:16.959]                           invokeRestart("muffleWarning")
[10:24:16.959]                       }
[10:24:16.959]                       else if (inherits(cond, "condition")) {
[10:24:16.959]                         if (!is.null(pattern)) {
[10:24:16.959]                           computeRestarts <- base::computeRestarts
[10:24:16.959]                           grepl <- base::grepl
[10:24:16.959]                           restarts <- computeRestarts(cond)
[10:24:16.959]                           for (restart in restarts) {
[10:24:16.959]                             name <- restart$name
[10:24:16.959]                             if (is.null(name)) 
[10:24:16.959]                               next
[10:24:16.959]                             if (!grepl(pattern, name)) 
[10:24:16.959]                               next
[10:24:16.959]                             invokeRestart(restart)
[10:24:16.959]                             muffled <- TRUE
[10:24:16.959]                             break
[10:24:16.959]                           }
[10:24:16.959]                         }
[10:24:16.959]                       }
[10:24:16.959]                       invisible(muffled)
[10:24:16.959]                     }
[10:24:16.959]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.959]                   }
[10:24:16.959]                 }
[10:24:16.959]                 else {
[10:24:16.959]                   if (TRUE) {
[10:24:16.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:16.959]                     {
[10:24:16.959]                       inherits <- base::inherits
[10:24:16.959]                       invokeRestart <- base::invokeRestart
[10:24:16.959]                       is.null <- base::is.null
[10:24:16.959]                       muffled <- FALSE
[10:24:16.959]                       if (inherits(cond, "message")) {
[10:24:16.959]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:16.959]                         if (muffled) 
[10:24:16.959]                           invokeRestart("muffleMessage")
[10:24:16.959]                       }
[10:24:16.959]                       else if (inherits(cond, "warning")) {
[10:24:16.959]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:16.959]                         if (muffled) 
[10:24:16.959]                           invokeRestart("muffleWarning")
[10:24:16.959]                       }
[10:24:16.959]                       else if (inherits(cond, "condition")) {
[10:24:16.959]                         if (!is.null(pattern)) {
[10:24:16.959]                           computeRestarts <- base::computeRestarts
[10:24:16.959]                           grepl <- base::grepl
[10:24:16.959]                           restarts <- computeRestarts(cond)
[10:24:16.959]                           for (restart in restarts) {
[10:24:16.959]                             name <- restart$name
[10:24:16.959]                             if (is.null(name)) 
[10:24:16.959]                               next
[10:24:16.959]                             if (!grepl(pattern, name)) 
[10:24:16.959]                               next
[10:24:16.959]                             invokeRestart(restart)
[10:24:16.959]                             muffled <- TRUE
[10:24:16.959]                             break
[10:24:16.959]                           }
[10:24:16.959]                         }
[10:24:16.959]                       }
[10:24:16.959]                       invisible(muffled)
[10:24:16.959]                     }
[10:24:16.959]                     muffleCondition(cond, pattern = "^muffle")
[10:24:16.959]                   }
[10:24:16.959]                 }
[10:24:16.959]             }
[10:24:16.959]         }))
[10:24:16.959]     }, error = function(ex) {
[10:24:16.959]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:16.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:16.959]                 ...future.rng), started = ...future.startTime, 
[10:24:16.959]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:16.959]             version = "1.8"), class = "FutureResult")
[10:24:16.959]     }, finally = {
[10:24:16.959]         if (!identical(...future.workdir, getwd())) 
[10:24:16.959]             setwd(...future.workdir)
[10:24:16.959]         {
[10:24:16.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:16.959]                 ...future.oldOptions$nwarnings <- NULL
[10:24:16.959]             }
[10:24:16.959]             base::options(...future.oldOptions)
[10:24:16.959]             if (.Platform$OS.type == "windows") {
[10:24:16.959]                 old_names <- names(...future.oldEnvVars)
[10:24:16.959]                 envs <- base::Sys.getenv()
[10:24:16.959]                 names <- names(envs)
[10:24:16.959]                 common <- intersect(names, old_names)
[10:24:16.959]                 added <- setdiff(names, old_names)
[10:24:16.959]                 removed <- setdiff(old_names, names)
[10:24:16.959]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:16.959]                   envs[common]]
[10:24:16.959]                 NAMES <- toupper(changed)
[10:24:16.959]                 args <- list()
[10:24:16.959]                 for (kk in seq_along(NAMES)) {
[10:24:16.959]                   name <- changed[[kk]]
[10:24:16.959]                   NAME <- NAMES[[kk]]
[10:24:16.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.959]                     next
[10:24:16.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.959]                 }
[10:24:16.959]                 NAMES <- toupper(added)
[10:24:16.959]                 for (kk in seq_along(NAMES)) {
[10:24:16.959]                   name <- added[[kk]]
[10:24:16.959]                   NAME <- NAMES[[kk]]
[10:24:16.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.959]                     next
[10:24:16.959]                   args[[name]] <- ""
[10:24:16.959]                 }
[10:24:16.959]                 NAMES <- toupper(removed)
[10:24:16.959]                 for (kk in seq_along(NAMES)) {
[10:24:16.959]                   name <- removed[[kk]]
[10:24:16.959]                   NAME <- NAMES[[kk]]
[10:24:16.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:16.959]                     next
[10:24:16.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:16.959]                 }
[10:24:16.959]                 if (length(args) > 0) 
[10:24:16.959]                   base::do.call(base::Sys.setenv, args = args)
[10:24:16.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:16.959]             }
[10:24:16.959]             else {
[10:24:16.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:16.959]             }
[10:24:16.959]             {
[10:24:16.959]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:16.959]                   0L) {
[10:24:16.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:16.959]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:16.959]                   base::options(opts)
[10:24:16.959]                 }
[10:24:16.959]                 {
[10:24:16.959]                   {
[10:24:16.959]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:16.959]                     NULL
[10:24:16.959]                   }
[10:24:16.959]                   options(future.plan = NULL)
[10:24:16.959]                   if (is.na(NA_character_)) 
[10:24:16.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:16.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:16.959]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:16.959]                     envir = parent.frame()) 
[10:24:16.959]                   {
[10:24:16.959]                     default_workers <- missing(workers)
[10:24:16.959]                     if (is.function(workers)) 
[10:24:16.959]                       workers <- workers()
[10:24:16.959]                     workers <- structure(as.integer(workers), 
[10:24:16.959]                       class = class(workers))
[10:24:16.959]                     stop_if_not(is.finite(workers), workers >= 
[10:24:16.959]                       1L)
[10:24:16.959]                     if ((workers == 1L && !inherits(workers, 
[10:24:16.959]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:16.959]                       if (default_workers) 
[10:24:16.959]                         supportsMulticore(warn = TRUE)
[10:24:16.959]                       return(sequential(..., envir = envir))
[10:24:16.959]                     }
[10:24:16.959]                     oopts <- options(mc.cores = workers)
[10:24:16.959]                     on.exit(options(oopts))
[10:24:16.959]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:16.959]                       envir = envir)
[10:24:16.959]                     if (!future$lazy) 
[10:24:16.959]                       future <- run(future)
[10:24:16.959]                     invisible(future)
[10:24:16.959]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:16.959]                 }
[10:24:16.959]             }
[10:24:16.959]         }
[10:24:16.959]     })
[10:24:16.959]     if (TRUE) {
[10:24:16.959]         base::sink(type = "output", split = FALSE)
[10:24:16.959]         if (TRUE) {
[10:24:16.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:16.959]         }
[10:24:16.959]         else {
[10:24:16.959]             ...future.result["stdout"] <- base::list(NULL)
[10:24:16.959]         }
[10:24:16.959]         base::close(...future.stdout)
[10:24:16.959]         ...future.stdout <- NULL
[10:24:16.959]     }
[10:24:16.959]     ...future.result$conditions <- ...future.conditions
[10:24:16.959]     ...future.result$finished <- base::Sys.time()
[10:24:16.959]     ...future.result
[10:24:16.959] }
[10:24:16.962] assign_globals() ...
[10:24:16.962] List of 11
[10:24:16.962]  $ ...future.FUN            :function (x, ...)  
[10:24:16.962]  $ x_FUN                    :function (x)  
[10:24:16.962]  $ times                    : int 1
[10:24:16.962]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:16.962]  $ stop_if_not              :function (...)  
[10:24:16.962]  $ dim                      : NULL
[10:24:16.962]  $ valid_types              : chr "character"
[10:24:16.962]  $ future.call.arguments    : list()
[10:24:16.962]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:16.962]  $ ...future.elements_ii    :List of 1
[10:24:16.962]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:24:16.962]  $ ...future.seeds_ii       : NULL
[10:24:16.962]  $ ...future.globals.maxSize: NULL
[10:24:16.962]  - attr(*, "where")=List of 11
[10:24:16.962]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:16.962]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:16.962]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:16.962]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:16.962]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:16.962]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:16.962]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:16.962]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:16.962]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:16.962]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:16.962]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:16.962]  - attr(*, "resolved")= logi FALSE
[10:24:16.962]  - attr(*, "total_size")= num 94208
[10:24:16.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:16.962]  - attr(*, "already-done")= logi TRUE
[10:24:16.970] - copied ‘...future.FUN’ to environment
[10:24:16.970] - copied ‘x_FUN’ to environment
[10:24:16.970] - copied ‘times’ to environment
[10:24:16.971] - copied ‘stopf’ to environment
[10:24:16.971] - copied ‘stop_if_not’ to environment
[10:24:16.971] - copied ‘dim’ to environment
[10:24:16.971] - copied ‘valid_types’ to environment
[10:24:16.971] - copied ‘future.call.arguments’ to environment
[10:24:16.971] - copied ‘...future.elements_ii’ to environment
[10:24:16.971] - copied ‘...future.seeds_ii’ to environment
[10:24:16.971] - copied ‘...future.globals.maxSize’ to environment
[10:24:16.971] assign_globals() ... done
[10:24:16.972] requestCore(): workers = 2
[10:24:16.975] MulticoreFuture started
[10:24:16.975] - Launch lazy future ... done
[10:24:16.976] run() for ‘MulticoreFuture’ ... done
[10:24:16.976] plan(): Setting new future strategy stack:
[10:24:16.976] Created future:
[10:24:16.976] List of future strategies:
[10:24:16.976] 1. sequential:
[10:24:16.976]    - args: function (..., envir = parent.frame())
[10:24:16.976]    - tweaked: FALSE
[10:24:16.976]    - call: NULL
[10:24:16.977] plan(): nbrOfWorkers() = 1
[10:24:16.980] plan(): Setting new future strategy stack:
[10:24:16.980] List of future strategies:
[10:24:16.980] 1. multicore:
[10:24:16.980]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:16.980]    - tweaked: FALSE
[10:24:16.980]    - call: plan(strategy)
[10:24:16.986] plan(): nbrOfWorkers() = 2
[10:24:16.976] MulticoreFuture:
[10:24:16.976] Label: ‘future_vapply-1’
[10:24:16.976] Expression:
[10:24:16.976] {
[10:24:16.976]     do.call(function(...) {
[10:24:16.976]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.976]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.976]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.976]             on.exit(options(oopts), add = TRUE)
[10:24:16.976]         }
[10:24:16.976]         {
[10:24:16.976]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.976]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.976]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.976]             })
[10:24:16.976]         }
[10:24:16.976]     }, args = future.call.arguments)
[10:24:16.976] }
[10:24:16.976] Lazy evaluation: FALSE
[10:24:16.976] Asynchronous evaluation: TRUE
[10:24:16.976] Local evaluation: TRUE
[10:24:16.976] Environment: R_GlobalEnv
[10:24:16.976] Capture standard output: TRUE
[10:24:16.976] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:16.976] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:16.976] Packages: 1 packages (‘future.apply’)
[10:24:16.976] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:16.976] Resolved: TRUE
[10:24:16.976] Value: <not collected>
[10:24:16.976] Conditions captured: <none>
[10:24:16.976] Early signaling: FALSE
[10:24:16.976] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:16.976] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:16.987] Chunk #1 of 2 ... DONE
[10:24:16.988] Chunk #2 of 2 ...
[10:24:16.988]  - Finding globals in 'X' for chunk #2 ...
[10:24:16.988] getGlobalsAndPackages() ...
[10:24:16.988] Searching for globals...
[10:24:16.989] 
[10:24:16.989] Searching for globals ... DONE
[10:24:16.989] - globals: [0] <none>
[10:24:16.989] getGlobalsAndPackages() ... DONE
[10:24:16.989]    + additional globals found: [n=0] 
[10:24:16.989]    + additional namespaces needed: [n=0] 
[10:24:16.990]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:16.990]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:16.990]  - seeds: <none>
[10:24:16.990]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.990] getGlobalsAndPackages() ...
[10:24:16.990] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.991] Resolving globals: FALSE
[10:24:16.991] Tweak future expression to call with '...' arguments ...
[10:24:16.991] {
[10:24:16.991]     do.call(function(...) {
[10:24:16.991]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:16.991]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:16.991]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:16.991]             on.exit(options(oopts), add = TRUE)
[10:24:16.991]         }
[10:24:16.991]         {
[10:24:16.991]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:16.991]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:16.991]                 ...future.FUN(...future.X_jj, ...)
[10:24:16.991]             })
[10:24:16.991]         }
[10:24:16.991]     }, args = future.call.arguments)
[10:24:16.991] }
[10:24:16.991] Tweak future expression to call with '...' arguments ... DONE
[10:24:16.992] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:16.992] - packages: [1] ‘future.apply’
[10:24:16.993] getGlobalsAndPackages() ... DONE
[10:24:16.993] run() for ‘Future’ ...
[10:24:16.993] - state: ‘created’
[10:24:16.994] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:16.998] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:16.998] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:16.998]   - Field: ‘label’
[10:24:16.999]   - Field: ‘local’
[10:24:16.999]   - Field: ‘owner’
[10:24:16.999]   - Field: ‘envir’
[10:24:16.999]   - Field: ‘workers’
[10:24:16.999]   - Field: ‘packages’
[10:24:16.999]   - Field: ‘gc’
[10:24:17.000]   - Field: ‘job’
[10:24:17.000]   - Field: ‘conditions’
[10:24:17.000]   - Field: ‘expr’
[10:24:17.000]   - Field: ‘uuid’
[10:24:17.000]   - Field: ‘seed’
[10:24:17.000]   - Field: ‘version’
[10:24:17.000]   - Field: ‘result’
[10:24:17.001]   - Field: ‘asynchronous’
[10:24:17.001]   - Field: ‘calls’
[10:24:17.001]   - Field: ‘globals’
[10:24:17.001]   - Field: ‘stdout’
[10:24:17.001]   - Field: ‘earlySignal’
[10:24:17.001]   - Field: ‘lazy’
[10:24:17.001]   - Field: ‘state’
[10:24:17.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.002] - Launch lazy future ...
[10:24:17.002] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.002] Packages needed by future strategies (n = 0): <none>
[10:24:17.003] {
[10:24:17.003]     {
[10:24:17.003]         {
[10:24:17.003]             ...future.startTime <- base::Sys.time()
[10:24:17.003]             {
[10:24:17.003]                 {
[10:24:17.003]                   {
[10:24:17.003]                     {
[10:24:17.003]                       {
[10:24:17.003]                         base::local({
[10:24:17.003]                           has_future <- base::requireNamespace("future", 
[10:24:17.003]                             quietly = TRUE)
[10:24:17.003]                           if (has_future) {
[10:24:17.003]                             ns <- base::getNamespace("future")
[10:24:17.003]                             version <- ns[[".package"]][["version"]]
[10:24:17.003]                             if (is.null(version)) 
[10:24:17.003]                               version <- utils::packageVersion("future")
[10:24:17.003]                           }
[10:24:17.003]                           else {
[10:24:17.003]                             version <- NULL
[10:24:17.003]                           }
[10:24:17.003]                           if (!has_future || version < "1.8.0") {
[10:24:17.003]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.003]                               "", base::R.version$version.string), 
[10:24:17.003]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.003]                                 base::R.version$platform, 8 * 
[10:24:17.003]                                   base::.Machine$sizeof.pointer), 
[10:24:17.003]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.003]                                 "release", "version")], collapse = " "), 
[10:24:17.003]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.003]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.003]                               info)
[10:24:17.003]                             info <- base::paste(info, collapse = "; ")
[10:24:17.003]                             if (!has_future) {
[10:24:17.003]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.003]                                 info)
[10:24:17.003]                             }
[10:24:17.003]                             else {
[10:24:17.003]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.003]                                 info, version)
[10:24:17.003]                             }
[10:24:17.003]                             base::stop(msg)
[10:24:17.003]                           }
[10:24:17.003]                         })
[10:24:17.003]                       }
[10:24:17.003]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.003]                       base::options(mc.cores = 1L)
[10:24:17.003]                     }
[10:24:17.003]                     base::local({
[10:24:17.003]                       for (pkg in "future.apply") {
[10:24:17.003]                         base::loadNamespace(pkg)
[10:24:17.003]                         base::library(pkg, character.only = TRUE)
[10:24:17.003]                       }
[10:24:17.003]                     })
[10:24:17.003]                   }
[10:24:17.003]                   options(future.plan = NULL)
[10:24:17.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.003]                 }
[10:24:17.003]                 ...future.workdir <- getwd()
[10:24:17.003]             }
[10:24:17.003]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.003]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.003]         }
[10:24:17.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.003]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.003]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.003]             base::names(...future.oldOptions))
[10:24:17.003]     }
[10:24:17.003]     if (FALSE) {
[10:24:17.003]     }
[10:24:17.003]     else {
[10:24:17.003]         if (TRUE) {
[10:24:17.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.003]                 open = "w")
[10:24:17.003]         }
[10:24:17.003]         else {
[10:24:17.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.003]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.003]         }
[10:24:17.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.003]             base::sink(type = "output", split = FALSE)
[10:24:17.003]             base::close(...future.stdout)
[10:24:17.003]         }, add = TRUE)
[10:24:17.003]     }
[10:24:17.003]     ...future.frame <- base::sys.nframe()
[10:24:17.003]     ...future.conditions <- base::list()
[10:24:17.003]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.003]     if (FALSE) {
[10:24:17.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.003]     }
[10:24:17.003]     ...future.result <- base::tryCatch({
[10:24:17.003]         base::withCallingHandlers({
[10:24:17.003]             ...future.value <- base::withVisible(base::local({
[10:24:17.003]                 withCallingHandlers({
[10:24:17.003]                   {
[10:24:17.003]                     do.call(function(...) {
[10:24:17.003]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.003]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.003]                         ...future.globals.maxSize)) {
[10:24:17.003]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.003]                         on.exit(options(oopts), add = TRUE)
[10:24:17.003]                       }
[10:24:17.003]                       {
[10:24:17.003]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.003]                           FUN = function(jj) {
[10:24:17.003]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.003]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.003]                           })
[10:24:17.003]                       }
[10:24:17.003]                     }, args = future.call.arguments)
[10:24:17.003]                   }
[10:24:17.003]                 }, immediateCondition = function(cond) {
[10:24:17.003]                   save_rds <- function (object, pathname, ...) 
[10:24:17.003]                   {
[10:24:17.003]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.003]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.003]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.003]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.003]                         fi_tmp[["mtime"]])
[10:24:17.003]                     }
[10:24:17.003]                     tryCatch({
[10:24:17.003]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.003]                     }, error = function(ex) {
[10:24:17.003]                       msg <- conditionMessage(ex)
[10:24:17.003]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.003]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.003]                         fi_tmp[["mtime"]], msg)
[10:24:17.003]                       ex$message <- msg
[10:24:17.003]                       stop(ex)
[10:24:17.003]                     })
[10:24:17.003]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.003]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.003]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.003]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.003]                       fi <- file.info(pathname)
[10:24:17.003]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.003]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.003]                         fi[["size"]], fi[["mtime"]])
[10:24:17.003]                       stop(msg)
[10:24:17.003]                     }
[10:24:17.003]                     invisible(pathname)
[10:24:17.003]                   }
[10:24:17.003]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.003]                     rootPath = tempdir()) 
[10:24:17.003]                   {
[10:24:17.003]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.003]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.003]                       tmpdir = path, fileext = ".rds")
[10:24:17.003]                     save_rds(obj, file)
[10:24:17.003]                   }
[10:24:17.003]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.003]                   {
[10:24:17.003]                     inherits <- base::inherits
[10:24:17.003]                     invokeRestart <- base::invokeRestart
[10:24:17.003]                     is.null <- base::is.null
[10:24:17.003]                     muffled <- FALSE
[10:24:17.003]                     if (inherits(cond, "message")) {
[10:24:17.003]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.003]                       if (muffled) 
[10:24:17.003]                         invokeRestart("muffleMessage")
[10:24:17.003]                     }
[10:24:17.003]                     else if (inherits(cond, "warning")) {
[10:24:17.003]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.003]                       if (muffled) 
[10:24:17.003]                         invokeRestart("muffleWarning")
[10:24:17.003]                     }
[10:24:17.003]                     else if (inherits(cond, "condition")) {
[10:24:17.003]                       if (!is.null(pattern)) {
[10:24:17.003]                         computeRestarts <- base::computeRestarts
[10:24:17.003]                         grepl <- base::grepl
[10:24:17.003]                         restarts <- computeRestarts(cond)
[10:24:17.003]                         for (restart in restarts) {
[10:24:17.003]                           name <- restart$name
[10:24:17.003]                           if (is.null(name)) 
[10:24:17.003]                             next
[10:24:17.003]                           if (!grepl(pattern, name)) 
[10:24:17.003]                             next
[10:24:17.003]                           invokeRestart(restart)
[10:24:17.003]                           muffled <- TRUE
[10:24:17.003]                           break
[10:24:17.003]                         }
[10:24:17.003]                       }
[10:24:17.003]                     }
[10:24:17.003]                     invisible(muffled)
[10:24:17.003]                   }
[10:24:17.003]                   muffleCondition(cond)
[10:24:17.003]                 })
[10:24:17.003]             }))
[10:24:17.003]             future::FutureResult(value = ...future.value$value, 
[10:24:17.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.003]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.003]                     ...future.globalenv.names))
[10:24:17.003]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.003]         }, condition = base::local({
[10:24:17.003]             c <- base::c
[10:24:17.003]             inherits <- base::inherits
[10:24:17.003]             invokeRestart <- base::invokeRestart
[10:24:17.003]             length <- base::length
[10:24:17.003]             list <- base::list
[10:24:17.003]             seq.int <- base::seq.int
[10:24:17.003]             signalCondition <- base::signalCondition
[10:24:17.003]             sys.calls <- base::sys.calls
[10:24:17.003]             `[[` <- base::`[[`
[10:24:17.003]             `+` <- base::`+`
[10:24:17.003]             `<<-` <- base::`<<-`
[10:24:17.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.003]                   3L)]
[10:24:17.003]             }
[10:24:17.003]             function(cond) {
[10:24:17.003]                 is_error <- inherits(cond, "error")
[10:24:17.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.003]                   NULL)
[10:24:17.003]                 if (is_error) {
[10:24:17.003]                   sessionInformation <- function() {
[10:24:17.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.003]                       search = base::search(), system = base::Sys.info())
[10:24:17.003]                   }
[10:24:17.003]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.003]                     cond$call), session = sessionInformation(), 
[10:24:17.003]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.003]                   signalCondition(cond)
[10:24:17.003]                 }
[10:24:17.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.003]                 "immediateCondition"))) {
[10:24:17.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.003]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.003]                   if (TRUE && !signal) {
[10:24:17.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.003]                     {
[10:24:17.003]                       inherits <- base::inherits
[10:24:17.003]                       invokeRestart <- base::invokeRestart
[10:24:17.003]                       is.null <- base::is.null
[10:24:17.003]                       muffled <- FALSE
[10:24:17.003]                       if (inherits(cond, "message")) {
[10:24:17.003]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.003]                         if (muffled) 
[10:24:17.003]                           invokeRestart("muffleMessage")
[10:24:17.003]                       }
[10:24:17.003]                       else if (inherits(cond, "warning")) {
[10:24:17.003]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.003]                         if (muffled) 
[10:24:17.003]                           invokeRestart("muffleWarning")
[10:24:17.003]                       }
[10:24:17.003]                       else if (inherits(cond, "condition")) {
[10:24:17.003]                         if (!is.null(pattern)) {
[10:24:17.003]                           computeRestarts <- base::computeRestarts
[10:24:17.003]                           grepl <- base::grepl
[10:24:17.003]                           restarts <- computeRestarts(cond)
[10:24:17.003]                           for (restart in restarts) {
[10:24:17.003]                             name <- restart$name
[10:24:17.003]                             if (is.null(name)) 
[10:24:17.003]                               next
[10:24:17.003]                             if (!grepl(pattern, name)) 
[10:24:17.003]                               next
[10:24:17.003]                             invokeRestart(restart)
[10:24:17.003]                             muffled <- TRUE
[10:24:17.003]                             break
[10:24:17.003]                           }
[10:24:17.003]                         }
[10:24:17.003]                       }
[10:24:17.003]                       invisible(muffled)
[10:24:17.003]                     }
[10:24:17.003]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.003]                   }
[10:24:17.003]                 }
[10:24:17.003]                 else {
[10:24:17.003]                   if (TRUE) {
[10:24:17.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.003]                     {
[10:24:17.003]                       inherits <- base::inherits
[10:24:17.003]                       invokeRestart <- base::invokeRestart
[10:24:17.003]                       is.null <- base::is.null
[10:24:17.003]                       muffled <- FALSE
[10:24:17.003]                       if (inherits(cond, "message")) {
[10:24:17.003]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.003]                         if (muffled) 
[10:24:17.003]                           invokeRestart("muffleMessage")
[10:24:17.003]                       }
[10:24:17.003]                       else if (inherits(cond, "warning")) {
[10:24:17.003]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.003]                         if (muffled) 
[10:24:17.003]                           invokeRestart("muffleWarning")
[10:24:17.003]                       }
[10:24:17.003]                       else if (inherits(cond, "condition")) {
[10:24:17.003]                         if (!is.null(pattern)) {
[10:24:17.003]                           computeRestarts <- base::computeRestarts
[10:24:17.003]                           grepl <- base::grepl
[10:24:17.003]                           restarts <- computeRestarts(cond)
[10:24:17.003]                           for (restart in restarts) {
[10:24:17.003]                             name <- restart$name
[10:24:17.003]                             if (is.null(name)) 
[10:24:17.003]                               next
[10:24:17.003]                             if (!grepl(pattern, name)) 
[10:24:17.003]                               next
[10:24:17.003]                             invokeRestart(restart)
[10:24:17.003]                             muffled <- TRUE
[10:24:17.003]                             break
[10:24:17.003]                           }
[10:24:17.003]                         }
[10:24:17.003]                       }
[10:24:17.003]                       invisible(muffled)
[10:24:17.003]                     }
[10:24:17.003]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.003]                   }
[10:24:17.003]                 }
[10:24:17.003]             }
[10:24:17.003]         }))
[10:24:17.003]     }, error = function(ex) {
[10:24:17.003]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.003]                 ...future.rng), started = ...future.startTime, 
[10:24:17.003]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.003]             version = "1.8"), class = "FutureResult")
[10:24:17.003]     }, finally = {
[10:24:17.003]         if (!identical(...future.workdir, getwd())) 
[10:24:17.003]             setwd(...future.workdir)
[10:24:17.003]         {
[10:24:17.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.003]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.003]             }
[10:24:17.003]             base::options(...future.oldOptions)
[10:24:17.003]             if (.Platform$OS.type == "windows") {
[10:24:17.003]                 old_names <- names(...future.oldEnvVars)
[10:24:17.003]                 envs <- base::Sys.getenv()
[10:24:17.003]                 names <- names(envs)
[10:24:17.003]                 common <- intersect(names, old_names)
[10:24:17.003]                 added <- setdiff(names, old_names)
[10:24:17.003]                 removed <- setdiff(old_names, names)
[10:24:17.003]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.003]                   envs[common]]
[10:24:17.003]                 NAMES <- toupper(changed)
[10:24:17.003]                 args <- list()
[10:24:17.003]                 for (kk in seq_along(NAMES)) {
[10:24:17.003]                   name <- changed[[kk]]
[10:24:17.003]                   NAME <- NAMES[[kk]]
[10:24:17.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.003]                     next
[10:24:17.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.003]                 }
[10:24:17.003]                 NAMES <- toupper(added)
[10:24:17.003]                 for (kk in seq_along(NAMES)) {
[10:24:17.003]                   name <- added[[kk]]
[10:24:17.003]                   NAME <- NAMES[[kk]]
[10:24:17.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.003]                     next
[10:24:17.003]                   args[[name]] <- ""
[10:24:17.003]                 }
[10:24:17.003]                 NAMES <- toupper(removed)
[10:24:17.003]                 for (kk in seq_along(NAMES)) {
[10:24:17.003]                   name <- removed[[kk]]
[10:24:17.003]                   NAME <- NAMES[[kk]]
[10:24:17.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.003]                     next
[10:24:17.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.003]                 }
[10:24:17.003]                 if (length(args) > 0) 
[10:24:17.003]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.003]             }
[10:24:17.003]             else {
[10:24:17.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.003]             }
[10:24:17.003]             {
[10:24:17.003]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.003]                   0L) {
[10:24:17.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.003]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.003]                   base::options(opts)
[10:24:17.003]                 }
[10:24:17.003]                 {
[10:24:17.003]                   {
[10:24:17.003]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.003]                     NULL
[10:24:17.003]                   }
[10:24:17.003]                   options(future.plan = NULL)
[10:24:17.003]                   if (is.na(NA_character_)) 
[10:24:17.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.003]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.003]                     envir = parent.frame()) 
[10:24:17.003]                   {
[10:24:17.003]                     default_workers <- missing(workers)
[10:24:17.003]                     if (is.function(workers)) 
[10:24:17.003]                       workers <- workers()
[10:24:17.003]                     workers <- structure(as.integer(workers), 
[10:24:17.003]                       class = class(workers))
[10:24:17.003]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.003]                       1L)
[10:24:17.003]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.003]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.003]                       if (default_workers) 
[10:24:17.003]                         supportsMulticore(warn = TRUE)
[10:24:17.003]                       return(sequential(..., envir = envir))
[10:24:17.003]                     }
[10:24:17.003]                     oopts <- options(mc.cores = workers)
[10:24:17.003]                     on.exit(options(oopts))
[10:24:17.003]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.003]                       envir = envir)
[10:24:17.003]                     if (!future$lazy) 
[10:24:17.003]                       future <- run(future)
[10:24:17.003]                     invisible(future)
[10:24:17.003]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.003]                 }
[10:24:17.003]             }
[10:24:17.003]         }
[10:24:17.003]     })
[10:24:17.003]     if (TRUE) {
[10:24:17.003]         base::sink(type = "output", split = FALSE)
[10:24:17.003]         if (TRUE) {
[10:24:17.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.003]         }
[10:24:17.003]         else {
[10:24:17.003]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.003]         }
[10:24:17.003]         base::close(...future.stdout)
[10:24:17.003]         ...future.stdout <- NULL
[10:24:17.003]     }
[10:24:17.003]     ...future.result$conditions <- ...future.conditions
[10:24:17.003]     ...future.result$finished <- base::Sys.time()
[10:24:17.003]     ...future.result
[10:24:17.003] }
[10:24:17.007] assign_globals() ...
[10:24:17.007] List of 11
[10:24:17.007]  $ ...future.FUN            :function (x, ...)  
[10:24:17.007]  $ x_FUN                    :function (x)  
[10:24:17.007]  $ times                    : int 1
[10:24:17.007]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.007]  $ stop_if_not              :function (...)  
[10:24:17.007]  $ dim                      : NULL
[10:24:17.007]  $ valid_types              : chr "character"
[10:24:17.007]  $ future.call.arguments    : list()
[10:24:17.007]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.007]  $ ...future.elements_ii    :List of 1
[10:24:17.007]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[10:24:17.007]  $ ...future.seeds_ii       : NULL
[10:24:17.007]  $ ...future.globals.maxSize: NULL
[10:24:17.007]  - attr(*, "where")=List of 11
[10:24:17.007]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.007]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.007]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.007]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.007]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.007]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.007]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.007]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.007]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.007]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.007]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.007]  - attr(*, "resolved")= logi FALSE
[10:24:17.007]  - attr(*, "total_size")= num 94208
[10:24:17.007]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.007]  - attr(*, "already-done")= logi TRUE
[10:24:17.021] - copied ‘...future.FUN’ to environment
[10:24:17.021] - copied ‘x_FUN’ to environment
[10:24:17.021] - copied ‘times’ to environment
[10:24:17.021] - copied ‘stopf’ to environment
[10:24:17.022] - copied ‘stop_if_not’ to environment
[10:24:17.022] - copied ‘dim’ to environment
[10:24:17.022] - copied ‘valid_types’ to environment
[10:24:17.022] - copied ‘future.call.arguments’ to environment
[10:24:17.022] - copied ‘...future.elements_ii’ to environment
[10:24:17.022] - copied ‘...future.seeds_ii’ to environment
[10:24:17.022] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.022] assign_globals() ... done
[10:24:17.023] requestCore(): workers = 2
[10:24:17.028] MulticoreFuture started
[10:24:17.028] - Launch lazy future ... done
[10:24:17.028] run() for ‘MulticoreFuture’ ... done
[10:24:17.029] Created future:
[10:24:17.029] plan(): Setting new future strategy stack:
[10:24:17.029] List of future strategies:
[10:24:17.029] 1. sequential:
[10:24:17.029]    - args: function (..., envir = parent.frame())
[10:24:17.029]    - tweaked: FALSE
[10:24:17.029]    - call: NULL
[10:24:17.030] plan(): nbrOfWorkers() = 1
[10:24:17.032] plan(): Setting new future strategy stack:
[10:24:17.032] List of future strategies:
[10:24:17.032] 1. multicore:
[10:24:17.032]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.032]    - tweaked: FALSE
[10:24:17.032]    - call: plan(strategy)
[10:24:17.038] plan(): nbrOfWorkers() = 2
[10:24:17.029] MulticoreFuture:
[10:24:17.029] Label: ‘future_vapply-2’
[10:24:17.029] Expression:
[10:24:17.029] {
[10:24:17.029]     do.call(function(...) {
[10:24:17.029]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.029]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.029]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.029]             on.exit(options(oopts), add = TRUE)
[10:24:17.029]         }
[10:24:17.029]         {
[10:24:17.029]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.029]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.029]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.029]             })
[10:24:17.029]         }
[10:24:17.029]     }, args = future.call.arguments)
[10:24:17.029] }
[10:24:17.029] Lazy evaluation: FALSE
[10:24:17.029] Asynchronous evaluation: TRUE
[10:24:17.029] Local evaluation: TRUE
[10:24:17.029] Environment: R_GlobalEnv
[10:24:17.029] Capture standard output: TRUE
[10:24:17.029] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.029] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.029] Packages: 1 packages (‘future.apply’)
[10:24:17.029] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.029] Resolved: TRUE
[10:24:17.029] Value: <not collected>
[10:24:17.029] Conditions captured: <none>
[10:24:17.029] Early signaling: FALSE
[10:24:17.029] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.029] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.039] Chunk #2 of 2 ... DONE
[10:24:17.039] Launching 2 futures (chunks) ... DONE
[10:24:17.039] Resolving 2 futures (chunks) ...
[10:24:17.039] resolve() on list ...
[10:24:17.039]  recursive: 0
[10:24:17.040]  length: 2
[10:24:17.040] 
[10:24:17.040] Future #1
[10:24:17.041] result() for MulticoreFuture ...
[10:24:17.043] result() for MulticoreFuture ...
[10:24:17.043] result() for MulticoreFuture ... done
[10:24:17.043] result() for MulticoreFuture ... done
[10:24:17.043] result() for MulticoreFuture ...
[10:24:17.043] result() for MulticoreFuture ... done
[10:24:17.044] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:17.044] - nx: 2
[10:24:17.044] - relay: TRUE
[10:24:17.044] - stdout: TRUE
[10:24:17.044] - signal: TRUE
[10:24:17.044] - resignal: FALSE
[10:24:17.044] - force: TRUE
[10:24:17.045] - relayed: [n=2] FALSE, FALSE
[10:24:17.045] - queued futures: [n=2] FALSE, FALSE
[10:24:17.045]  - until=1
[10:24:17.045]  - relaying element #1
[10:24:17.045] result() for MulticoreFuture ...
[10:24:17.045] result() for MulticoreFuture ... done
[10:24:17.045] result() for MulticoreFuture ...
[10:24:17.046] result() for MulticoreFuture ... done
[10:24:17.046] result() for MulticoreFuture ...
[10:24:17.046] result() for MulticoreFuture ... done
[10:24:17.046] result() for MulticoreFuture ...
[10:24:17.046] result() for MulticoreFuture ... done
[10:24:17.046] - relayed: [n=2] TRUE, FALSE
[10:24:17.047] - queued futures: [n=2] TRUE, FALSE
[10:24:17.047] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:17.047]  length: 1 (resolved future 1)
[10:24:17.047] Future #2
[10:24:17.047] result() for MulticoreFuture ...
[10:24:17.048] result() for MulticoreFuture ...
[10:24:17.048] result() for MulticoreFuture ... done
[10:24:17.048] result() for MulticoreFuture ... done
[10:24:17.048] result() for MulticoreFuture ...
[10:24:17.049] result() for MulticoreFuture ... done
[10:24:17.049] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:17.049] - nx: 2
[10:24:17.049] - relay: TRUE
[10:24:17.049] - stdout: TRUE
[10:24:17.049] - signal: TRUE
[10:24:17.049] - resignal: FALSE
[10:24:17.050] - force: TRUE
[10:24:17.050] - relayed: [n=2] TRUE, FALSE
[10:24:17.050] - queued futures: [n=2] TRUE, FALSE
[10:24:17.050]  - until=2
[10:24:17.050]  - relaying element #2
[10:24:17.050] result() for MulticoreFuture ...
[10:24:17.050] result() for MulticoreFuture ... done
[10:24:17.050] result() for MulticoreFuture ...
[10:24:17.050] result() for MulticoreFuture ... done
[10:24:17.051] result() for MulticoreFuture ...
[10:24:17.051] result() for MulticoreFuture ... done
[10:24:17.051] result() for MulticoreFuture ...
[10:24:17.051] result() for MulticoreFuture ... done
[10:24:17.051] - relayed: [n=2] TRUE, TRUE
[10:24:17.051] - queued futures: [n=2] TRUE, TRUE
[10:24:17.051] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:17.051]  length: 0 (resolved future 2)
[10:24:17.052] Relaying remaining futures
[10:24:17.052] signalConditionsASAP(NULL, pos=0) ...
[10:24:17.052] - nx: 2
[10:24:17.052] - relay: TRUE
[10:24:17.052] - stdout: TRUE
[10:24:17.052] - signal: TRUE
[10:24:17.052] - resignal: FALSE
[10:24:17.052] - force: TRUE
[10:24:17.052] - relayed: [n=2] TRUE, TRUE
[10:24:17.052] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:17.053] - relayed: [n=2] TRUE, TRUE
[10:24:17.053] - queued futures: [n=2] TRUE, TRUE
[10:24:17.053] signalConditionsASAP(NULL, pos=0) ... done
[10:24:17.053] resolve() on list ... DONE
[10:24:17.053] result() for MulticoreFuture ...
[10:24:17.053] result() for MulticoreFuture ... done
[10:24:17.053] result() for MulticoreFuture ...
[10:24:17.053] result() for MulticoreFuture ... done
[10:24:17.054] result() for MulticoreFuture ...
[10:24:17.054] result() for MulticoreFuture ... done
[10:24:17.054] result() for MulticoreFuture ...
[10:24:17.054] result() for MulticoreFuture ... done
[10:24:17.054]  - Number of value chunks collected: 2
[10:24:17.054] Resolving 2 futures (chunks) ... DONE
[10:24:17.054] Reducing values from 2 chunks ...
[10:24:17.054]  - Number of values collected after concatenation: 2
[10:24:17.054]  - Number of values expected: 2
[10:24:17.055] Reducing values from 2 chunks ... DONE
[10:24:17.055] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[10:24:17.056] future_lapply() ...
[10:24:17.065] Number of chunks: 2
[10:24:17.066] getGlobalsAndPackagesXApply() ...
[10:24:17.066]  - future.globals: TRUE
[10:24:17.066] getGlobalsAndPackages() ...
[10:24:17.066] Searching for globals...
[10:24:17.070] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[10:24:17.071] Searching for globals ... DONE
[10:24:17.071] Resolving globals: FALSE
[10:24:17.072] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[10:24:17.072] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:17.072] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.072] - packages: [1] ‘future.apply’
[10:24:17.073] getGlobalsAndPackages() ... DONE
[10:24:17.073]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.073]  - needed namespaces: [n=1] ‘future.apply’
[10:24:17.073] Finding globals ... DONE
[10:24:17.073]  - use_args: TRUE
[10:24:17.073]  - Getting '...' globals ...
[10:24:17.073] resolve() on list ...
[10:24:17.073]  recursive: 0
[10:24:17.074]  length: 1
[10:24:17.074]  elements: ‘...’
[10:24:17.074]  length: 0 (resolved future 1)
[10:24:17.074] resolve() on list ... DONE
[10:24:17.074]    - '...' content: [n=0] 
[10:24:17.074] List of 1
[10:24:17.074]  $ ...: list()
[10:24:17.074]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.074]  - attr(*, "where")=List of 1
[10:24:17.074]   ..$ ...:<environment: 0x55b93d0eb320> 
[10:24:17.074]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.074]  - attr(*, "resolved")= logi TRUE
[10:24:17.074]  - attr(*, "total_size")= num NA
[10:24:17.077]  - Getting '...' globals ... DONE
[10:24:17.077] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:17.077] List of 8
[10:24:17.077]  $ ...future.FUN:function (x, ...)  
[10:24:17.077]  $ x_FUN        :function (x)  
[10:24:17.077]  $ times        : int 0
[10:24:17.077]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.077]  $ stop_if_not  :function (...)  
[10:24:17.077]  $ dim          : NULL
[10:24:17.077]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:17.077]  $ ...          : list()
[10:24:17.077]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.077]  - attr(*, "where")=List of 8
[10:24:17.077]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:17.077]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:17.077]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:17.077]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:17.077]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:17.077]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:17.077]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:17.077]   ..$ ...          :<environment: 0x55b93d0eb320> 
[10:24:17.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.077]  - attr(*, "resolved")= logi FALSE
[10:24:17.077]  - attr(*, "total_size")= num 95472
[10:24:17.082] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:17.083] getGlobalsAndPackagesXApply() ... DONE
[10:24:17.084] Number of futures (= number of chunks): 2
[10:24:17.084] Launching 2 futures (chunks) ...
[10:24:17.084] Chunk #1 of 2 ...
[10:24:17.084]  - Finding globals in 'X' for chunk #1 ...
[10:24:17.085] getGlobalsAndPackages() ...
[10:24:17.085] Searching for globals...
[10:24:17.085] 
[10:24:17.085] Searching for globals ... DONE
[10:24:17.085] - globals: [0] <none>
[10:24:17.085] getGlobalsAndPackages() ... DONE
[10:24:17.085]    + additional globals found: [n=0] 
[10:24:17.085]    + additional namespaces needed: [n=0] 
[10:24:17.086]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:17.086]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.086]  - seeds: <none>
[10:24:17.086]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.086] getGlobalsAndPackages() ...
[10:24:17.086] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.086] Resolving globals: FALSE
[10:24:17.086] Tweak future expression to call with '...' arguments ...
[10:24:17.086] {
[10:24:17.086]     do.call(function(...) {
[10:24:17.086]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.086]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.086]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.086]             on.exit(options(oopts), add = TRUE)
[10:24:17.086]         }
[10:24:17.086]         {
[10:24:17.086]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.086]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.086]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.086]             })
[10:24:17.086]         }
[10:24:17.086]     }, args = future.call.arguments)
[10:24:17.086] }
[10:24:17.087] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.087] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.087] - packages: [1] ‘future.apply’
[10:24:17.087] getGlobalsAndPackages() ... DONE
[10:24:17.088] run() for ‘Future’ ...
[10:24:17.088] - state: ‘created’
[10:24:17.088] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.092] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.092] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.092]   - Field: ‘label’
[10:24:17.092]   - Field: ‘local’
[10:24:17.092]   - Field: ‘owner’
[10:24:17.092]   - Field: ‘envir’
[10:24:17.092]   - Field: ‘workers’
[10:24:17.092]   - Field: ‘packages’
[10:24:17.092]   - Field: ‘gc’
[10:24:17.093]   - Field: ‘job’
[10:24:17.093]   - Field: ‘conditions’
[10:24:17.093]   - Field: ‘expr’
[10:24:17.093]   - Field: ‘uuid’
[10:24:17.093]   - Field: ‘seed’
[10:24:17.093]   - Field: ‘version’
[10:24:17.093]   - Field: ‘result’
[10:24:17.093]   - Field: ‘asynchronous’
[10:24:17.093]   - Field: ‘calls’
[10:24:17.093]   - Field: ‘globals’
[10:24:17.093]   - Field: ‘stdout’
[10:24:17.094]   - Field: ‘earlySignal’
[10:24:17.094]   - Field: ‘lazy’
[10:24:17.094]   - Field: ‘state’
[10:24:17.094] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.094] - Launch lazy future ...
[10:24:17.094] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.094] Packages needed by future strategies (n = 0): <none>
[10:24:17.095] {
[10:24:17.095]     {
[10:24:17.095]         {
[10:24:17.095]             ...future.startTime <- base::Sys.time()
[10:24:17.095]             {
[10:24:17.095]                 {
[10:24:17.095]                   {
[10:24:17.095]                     {
[10:24:17.095]                       {
[10:24:17.095]                         base::local({
[10:24:17.095]                           has_future <- base::requireNamespace("future", 
[10:24:17.095]                             quietly = TRUE)
[10:24:17.095]                           if (has_future) {
[10:24:17.095]                             ns <- base::getNamespace("future")
[10:24:17.095]                             version <- ns[[".package"]][["version"]]
[10:24:17.095]                             if (is.null(version)) 
[10:24:17.095]                               version <- utils::packageVersion("future")
[10:24:17.095]                           }
[10:24:17.095]                           else {
[10:24:17.095]                             version <- NULL
[10:24:17.095]                           }
[10:24:17.095]                           if (!has_future || version < "1.8.0") {
[10:24:17.095]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.095]                               "", base::R.version$version.string), 
[10:24:17.095]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.095]                                 base::R.version$platform, 8 * 
[10:24:17.095]                                   base::.Machine$sizeof.pointer), 
[10:24:17.095]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.095]                                 "release", "version")], collapse = " "), 
[10:24:17.095]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.095]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.095]                               info)
[10:24:17.095]                             info <- base::paste(info, collapse = "; ")
[10:24:17.095]                             if (!has_future) {
[10:24:17.095]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.095]                                 info)
[10:24:17.095]                             }
[10:24:17.095]                             else {
[10:24:17.095]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.095]                                 info, version)
[10:24:17.095]                             }
[10:24:17.095]                             base::stop(msg)
[10:24:17.095]                           }
[10:24:17.095]                         })
[10:24:17.095]                       }
[10:24:17.095]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.095]                       base::options(mc.cores = 1L)
[10:24:17.095]                     }
[10:24:17.095]                     base::local({
[10:24:17.095]                       for (pkg in "future.apply") {
[10:24:17.095]                         base::loadNamespace(pkg)
[10:24:17.095]                         base::library(pkg, character.only = TRUE)
[10:24:17.095]                       }
[10:24:17.095]                     })
[10:24:17.095]                   }
[10:24:17.095]                   options(future.plan = NULL)
[10:24:17.095]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.095]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.095]                 }
[10:24:17.095]                 ...future.workdir <- getwd()
[10:24:17.095]             }
[10:24:17.095]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.095]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.095]         }
[10:24:17.095]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.095]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.095]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.095]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.095]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.095]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.095]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.095]             base::names(...future.oldOptions))
[10:24:17.095]     }
[10:24:17.095]     if (FALSE) {
[10:24:17.095]     }
[10:24:17.095]     else {
[10:24:17.095]         if (TRUE) {
[10:24:17.095]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.095]                 open = "w")
[10:24:17.095]         }
[10:24:17.095]         else {
[10:24:17.095]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.095]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.095]         }
[10:24:17.095]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.095]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.095]             base::sink(type = "output", split = FALSE)
[10:24:17.095]             base::close(...future.stdout)
[10:24:17.095]         }, add = TRUE)
[10:24:17.095]     }
[10:24:17.095]     ...future.frame <- base::sys.nframe()
[10:24:17.095]     ...future.conditions <- base::list()
[10:24:17.095]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.095]     if (FALSE) {
[10:24:17.095]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.095]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.095]     }
[10:24:17.095]     ...future.result <- base::tryCatch({
[10:24:17.095]         base::withCallingHandlers({
[10:24:17.095]             ...future.value <- base::withVisible(base::local({
[10:24:17.095]                 withCallingHandlers({
[10:24:17.095]                   {
[10:24:17.095]                     do.call(function(...) {
[10:24:17.095]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.095]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.095]                         ...future.globals.maxSize)) {
[10:24:17.095]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.095]                         on.exit(options(oopts), add = TRUE)
[10:24:17.095]                       }
[10:24:17.095]                       {
[10:24:17.095]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.095]                           FUN = function(jj) {
[10:24:17.095]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.095]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.095]                           })
[10:24:17.095]                       }
[10:24:17.095]                     }, args = future.call.arguments)
[10:24:17.095]                   }
[10:24:17.095]                 }, immediateCondition = function(cond) {
[10:24:17.095]                   save_rds <- function (object, pathname, ...) 
[10:24:17.095]                   {
[10:24:17.095]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.095]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.095]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.095]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.095]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.095]                         fi_tmp[["mtime"]])
[10:24:17.095]                     }
[10:24:17.095]                     tryCatch({
[10:24:17.095]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.095]                     }, error = function(ex) {
[10:24:17.095]                       msg <- conditionMessage(ex)
[10:24:17.095]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.095]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.095]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.095]                         fi_tmp[["mtime"]], msg)
[10:24:17.095]                       ex$message <- msg
[10:24:17.095]                       stop(ex)
[10:24:17.095]                     })
[10:24:17.095]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.095]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.095]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.095]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.095]                       fi <- file.info(pathname)
[10:24:17.095]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.095]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.095]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.095]                         fi[["size"]], fi[["mtime"]])
[10:24:17.095]                       stop(msg)
[10:24:17.095]                     }
[10:24:17.095]                     invisible(pathname)
[10:24:17.095]                   }
[10:24:17.095]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.095]                     rootPath = tempdir()) 
[10:24:17.095]                   {
[10:24:17.095]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.095]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.095]                       tmpdir = path, fileext = ".rds")
[10:24:17.095]                     save_rds(obj, file)
[10:24:17.095]                   }
[10:24:17.095]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.095]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.095]                   {
[10:24:17.095]                     inherits <- base::inherits
[10:24:17.095]                     invokeRestart <- base::invokeRestart
[10:24:17.095]                     is.null <- base::is.null
[10:24:17.095]                     muffled <- FALSE
[10:24:17.095]                     if (inherits(cond, "message")) {
[10:24:17.095]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.095]                       if (muffled) 
[10:24:17.095]                         invokeRestart("muffleMessage")
[10:24:17.095]                     }
[10:24:17.095]                     else if (inherits(cond, "warning")) {
[10:24:17.095]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.095]                       if (muffled) 
[10:24:17.095]                         invokeRestart("muffleWarning")
[10:24:17.095]                     }
[10:24:17.095]                     else if (inherits(cond, "condition")) {
[10:24:17.095]                       if (!is.null(pattern)) {
[10:24:17.095]                         computeRestarts <- base::computeRestarts
[10:24:17.095]                         grepl <- base::grepl
[10:24:17.095]                         restarts <- computeRestarts(cond)
[10:24:17.095]                         for (restart in restarts) {
[10:24:17.095]                           name <- restart$name
[10:24:17.095]                           if (is.null(name)) 
[10:24:17.095]                             next
[10:24:17.095]                           if (!grepl(pattern, name)) 
[10:24:17.095]                             next
[10:24:17.095]                           invokeRestart(restart)
[10:24:17.095]                           muffled <- TRUE
[10:24:17.095]                           break
[10:24:17.095]                         }
[10:24:17.095]                       }
[10:24:17.095]                     }
[10:24:17.095]                     invisible(muffled)
[10:24:17.095]                   }
[10:24:17.095]                   muffleCondition(cond)
[10:24:17.095]                 })
[10:24:17.095]             }))
[10:24:17.095]             future::FutureResult(value = ...future.value$value, 
[10:24:17.095]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.095]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.095]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.095]                     ...future.globalenv.names))
[10:24:17.095]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.095]         }, condition = base::local({
[10:24:17.095]             c <- base::c
[10:24:17.095]             inherits <- base::inherits
[10:24:17.095]             invokeRestart <- base::invokeRestart
[10:24:17.095]             length <- base::length
[10:24:17.095]             list <- base::list
[10:24:17.095]             seq.int <- base::seq.int
[10:24:17.095]             signalCondition <- base::signalCondition
[10:24:17.095]             sys.calls <- base::sys.calls
[10:24:17.095]             `[[` <- base::`[[`
[10:24:17.095]             `+` <- base::`+`
[10:24:17.095]             `<<-` <- base::`<<-`
[10:24:17.095]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.095]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.095]                   3L)]
[10:24:17.095]             }
[10:24:17.095]             function(cond) {
[10:24:17.095]                 is_error <- inherits(cond, "error")
[10:24:17.095]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.095]                   NULL)
[10:24:17.095]                 if (is_error) {
[10:24:17.095]                   sessionInformation <- function() {
[10:24:17.095]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.095]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.095]                       search = base::search(), system = base::Sys.info())
[10:24:17.095]                   }
[10:24:17.095]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.095]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.095]                     cond$call), session = sessionInformation(), 
[10:24:17.095]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.095]                   signalCondition(cond)
[10:24:17.095]                 }
[10:24:17.095]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.095]                 "immediateCondition"))) {
[10:24:17.095]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.095]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.095]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.095]                   if (TRUE && !signal) {
[10:24:17.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.095]                     {
[10:24:17.095]                       inherits <- base::inherits
[10:24:17.095]                       invokeRestart <- base::invokeRestart
[10:24:17.095]                       is.null <- base::is.null
[10:24:17.095]                       muffled <- FALSE
[10:24:17.095]                       if (inherits(cond, "message")) {
[10:24:17.095]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.095]                         if (muffled) 
[10:24:17.095]                           invokeRestart("muffleMessage")
[10:24:17.095]                       }
[10:24:17.095]                       else if (inherits(cond, "warning")) {
[10:24:17.095]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.095]                         if (muffled) 
[10:24:17.095]                           invokeRestart("muffleWarning")
[10:24:17.095]                       }
[10:24:17.095]                       else if (inherits(cond, "condition")) {
[10:24:17.095]                         if (!is.null(pattern)) {
[10:24:17.095]                           computeRestarts <- base::computeRestarts
[10:24:17.095]                           grepl <- base::grepl
[10:24:17.095]                           restarts <- computeRestarts(cond)
[10:24:17.095]                           for (restart in restarts) {
[10:24:17.095]                             name <- restart$name
[10:24:17.095]                             if (is.null(name)) 
[10:24:17.095]                               next
[10:24:17.095]                             if (!grepl(pattern, name)) 
[10:24:17.095]                               next
[10:24:17.095]                             invokeRestart(restart)
[10:24:17.095]                             muffled <- TRUE
[10:24:17.095]                             break
[10:24:17.095]                           }
[10:24:17.095]                         }
[10:24:17.095]                       }
[10:24:17.095]                       invisible(muffled)
[10:24:17.095]                     }
[10:24:17.095]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.095]                   }
[10:24:17.095]                 }
[10:24:17.095]                 else {
[10:24:17.095]                   if (TRUE) {
[10:24:17.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.095]                     {
[10:24:17.095]                       inherits <- base::inherits
[10:24:17.095]                       invokeRestart <- base::invokeRestart
[10:24:17.095]                       is.null <- base::is.null
[10:24:17.095]                       muffled <- FALSE
[10:24:17.095]                       if (inherits(cond, "message")) {
[10:24:17.095]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.095]                         if (muffled) 
[10:24:17.095]                           invokeRestart("muffleMessage")
[10:24:17.095]                       }
[10:24:17.095]                       else if (inherits(cond, "warning")) {
[10:24:17.095]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.095]                         if (muffled) 
[10:24:17.095]                           invokeRestart("muffleWarning")
[10:24:17.095]                       }
[10:24:17.095]                       else if (inherits(cond, "condition")) {
[10:24:17.095]                         if (!is.null(pattern)) {
[10:24:17.095]                           computeRestarts <- base::computeRestarts
[10:24:17.095]                           grepl <- base::grepl
[10:24:17.095]                           restarts <- computeRestarts(cond)
[10:24:17.095]                           for (restart in restarts) {
[10:24:17.095]                             name <- restart$name
[10:24:17.095]                             if (is.null(name)) 
[10:24:17.095]                               next
[10:24:17.095]                             if (!grepl(pattern, name)) 
[10:24:17.095]                               next
[10:24:17.095]                             invokeRestart(restart)
[10:24:17.095]                             muffled <- TRUE
[10:24:17.095]                             break
[10:24:17.095]                           }
[10:24:17.095]                         }
[10:24:17.095]                       }
[10:24:17.095]                       invisible(muffled)
[10:24:17.095]                     }
[10:24:17.095]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.095]                   }
[10:24:17.095]                 }
[10:24:17.095]             }
[10:24:17.095]         }))
[10:24:17.095]     }, error = function(ex) {
[10:24:17.095]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.095]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.095]                 ...future.rng), started = ...future.startTime, 
[10:24:17.095]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.095]             version = "1.8"), class = "FutureResult")
[10:24:17.095]     }, finally = {
[10:24:17.095]         if (!identical(...future.workdir, getwd())) 
[10:24:17.095]             setwd(...future.workdir)
[10:24:17.095]         {
[10:24:17.095]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.095]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.095]             }
[10:24:17.095]             base::options(...future.oldOptions)
[10:24:17.095]             if (.Platform$OS.type == "windows") {
[10:24:17.095]                 old_names <- names(...future.oldEnvVars)
[10:24:17.095]                 envs <- base::Sys.getenv()
[10:24:17.095]                 names <- names(envs)
[10:24:17.095]                 common <- intersect(names, old_names)
[10:24:17.095]                 added <- setdiff(names, old_names)
[10:24:17.095]                 removed <- setdiff(old_names, names)
[10:24:17.095]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.095]                   envs[common]]
[10:24:17.095]                 NAMES <- toupper(changed)
[10:24:17.095]                 args <- list()
[10:24:17.095]                 for (kk in seq_along(NAMES)) {
[10:24:17.095]                   name <- changed[[kk]]
[10:24:17.095]                   NAME <- NAMES[[kk]]
[10:24:17.095]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.095]                     next
[10:24:17.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.095]                 }
[10:24:17.095]                 NAMES <- toupper(added)
[10:24:17.095]                 for (kk in seq_along(NAMES)) {
[10:24:17.095]                   name <- added[[kk]]
[10:24:17.095]                   NAME <- NAMES[[kk]]
[10:24:17.095]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.095]                     next
[10:24:17.095]                   args[[name]] <- ""
[10:24:17.095]                 }
[10:24:17.095]                 NAMES <- toupper(removed)
[10:24:17.095]                 for (kk in seq_along(NAMES)) {
[10:24:17.095]                   name <- removed[[kk]]
[10:24:17.095]                   NAME <- NAMES[[kk]]
[10:24:17.095]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.095]                     next
[10:24:17.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.095]                 }
[10:24:17.095]                 if (length(args) > 0) 
[10:24:17.095]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.095]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.095]             }
[10:24:17.095]             else {
[10:24:17.095]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.095]             }
[10:24:17.095]             {
[10:24:17.095]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.095]                   0L) {
[10:24:17.095]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.095]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.095]                   base::options(opts)
[10:24:17.095]                 }
[10:24:17.095]                 {
[10:24:17.095]                   {
[10:24:17.095]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.095]                     NULL
[10:24:17.095]                   }
[10:24:17.095]                   options(future.plan = NULL)
[10:24:17.095]                   if (is.na(NA_character_)) 
[10:24:17.095]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.095]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.095]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.095]                     envir = parent.frame()) 
[10:24:17.095]                   {
[10:24:17.095]                     default_workers <- missing(workers)
[10:24:17.095]                     if (is.function(workers)) 
[10:24:17.095]                       workers <- workers()
[10:24:17.095]                     workers <- structure(as.integer(workers), 
[10:24:17.095]                       class = class(workers))
[10:24:17.095]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.095]                       1L)
[10:24:17.095]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.095]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.095]                       if (default_workers) 
[10:24:17.095]                         supportsMulticore(warn = TRUE)
[10:24:17.095]                       return(sequential(..., envir = envir))
[10:24:17.095]                     }
[10:24:17.095]                     oopts <- options(mc.cores = workers)
[10:24:17.095]                     on.exit(options(oopts))
[10:24:17.095]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.095]                       envir = envir)
[10:24:17.095]                     if (!future$lazy) 
[10:24:17.095]                       future <- run(future)
[10:24:17.095]                     invisible(future)
[10:24:17.095]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.095]                 }
[10:24:17.095]             }
[10:24:17.095]         }
[10:24:17.095]     })
[10:24:17.095]     if (TRUE) {
[10:24:17.095]         base::sink(type = "output", split = FALSE)
[10:24:17.095]         if (TRUE) {
[10:24:17.095]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.095]         }
[10:24:17.095]         else {
[10:24:17.095]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.095]         }
[10:24:17.095]         base::close(...future.stdout)
[10:24:17.095]         ...future.stdout <- NULL
[10:24:17.095]     }
[10:24:17.095]     ...future.result$conditions <- ...future.conditions
[10:24:17.095]     ...future.result$finished <- base::Sys.time()
[10:24:17.095]     ...future.result
[10:24:17.095] }
[10:24:17.097] assign_globals() ...
[10:24:17.098] List of 11
[10:24:17.098]  $ ...future.FUN            :function (x, ...)  
[10:24:17.098]  $ x_FUN                    :function (x)  
[10:24:17.098]  $ times                    : int 0
[10:24:17.098]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.098]  $ stop_if_not              :function (...)  
[10:24:17.098]  $ dim                      : NULL
[10:24:17.098]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:17.098]  $ future.call.arguments    : list()
[10:24:17.098]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.098]  $ ...future.elements_ii    :List of 5
[10:24:17.098]   ..$ : int 1
[10:24:17.098]   ..$ : int 2
[10:24:17.098]   ..$ : int 3
[10:24:17.098]   ..$ : int 4
[10:24:17.098]   ..$ : int 5
[10:24:17.098]  $ ...future.seeds_ii       : NULL
[10:24:17.098]  $ ...future.globals.maxSize: NULL
[10:24:17.098]  - attr(*, "where")=List of 11
[10:24:17.098]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.098]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.098]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.098]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.098]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.098]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.098]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.098]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.098]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.098]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.098]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.098]  - attr(*, "resolved")= logi FALSE
[10:24:17.098]  - attr(*, "total_size")= num 95472
[10:24:17.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.098]  - attr(*, "already-done")= logi TRUE
[10:24:17.106] - copied ‘...future.FUN’ to environment
[10:24:17.106] - reassign environment for ‘x_FUN’
[10:24:17.106] - copied ‘x_FUN’ to environment
[10:24:17.106] - copied ‘times’ to environment
[10:24:17.106] - copied ‘stopf’ to environment
[10:24:17.106] - copied ‘stop_if_not’ to environment
[10:24:17.106] - copied ‘dim’ to environment
[10:24:17.106] - copied ‘valid_types’ to environment
[10:24:17.106] - copied ‘future.call.arguments’ to environment
[10:24:17.107] - copied ‘...future.elements_ii’ to environment
[10:24:17.107] - copied ‘...future.seeds_ii’ to environment
[10:24:17.107] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.107] assign_globals() ... done
[10:24:17.107] requestCore(): workers = 2
[10:24:17.110] MulticoreFuture started
[10:24:17.111] - Launch lazy future ... done
[10:24:17.112] run() for ‘MulticoreFuture’ ... done
[10:24:17.112] Created future:
[10:24:17.113] plan(): Setting new future strategy stack:
[10:24:17.113] List of future strategies:
[10:24:17.113] 1. sequential:
[10:24:17.113]    - args: function (..., envir = parent.frame())
[10:24:17.113]    - tweaked: FALSE
[10:24:17.113]    - call: NULL
[10:24:17.115] plan(): nbrOfWorkers() = 1
[10:24:17.117] plan(): Setting new future strategy stack:
[10:24:17.118] List of future strategies:
[10:24:17.118] 1. multicore:
[10:24:17.118]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.118]    - tweaked: FALSE
[10:24:17.118]    - call: plan(strategy)
[10:24:17.124] plan(): nbrOfWorkers() = 2
[10:24:17.113] MulticoreFuture:
[10:24:17.113] Label: ‘future_vapply-1’
[10:24:17.113] Expression:
[10:24:17.113] {
[10:24:17.113]     do.call(function(...) {
[10:24:17.113]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.113]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.113]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.113]             on.exit(options(oopts), add = TRUE)
[10:24:17.113]         }
[10:24:17.113]         {
[10:24:17.113]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.113]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.113]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.113]             })
[10:24:17.113]         }
[10:24:17.113]     }, args = future.call.arguments)
[10:24:17.113] }
[10:24:17.113] Lazy evaluation: FALSE
[10:24:17.113] Asynchronous evaluation: TRUE
[10:24:17.113] Local evaluation: TRUE
[10:24:17.113] Environment: R_GlobalEnv
[10:24:17.113] Capture standard output: TRUE
[10:24:17.113] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.113] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.113] Packages: 1 packages (‘future.apply’)
[10:24:17.113] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.113] Resolved: TRUE
[10:24:17.113] Value: <not collected>
[10:24:17.113] Conditions captured: <none>
[10:24:17.113] Early signaling: FALSE
[10:24:17.113] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.113] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.125] Chunk #1 of 2 ... DONE
[10:24:17.126] Chunk #2 of 2 ...
[10:24:17.126]  - Finding globals in 'X' for chunk #2 ...
[10:24:17.126] getGlobalsAndPackages() ...
[10:24:17.126] Searching for globals...
[10:24:17.127] 
[10:24:17.127] Searching for globals ... DONE
[10:24:17.127] - globals: [0] <none>
[10:24:17.127] getGlobalsAndPackages() ... DONE
[10:24:17.128]    + additional globals found: [n=0] 
[10:24:17.128]    + additional namespaces needed: [n=0] 
[10:24:17.128]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:17.128]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.128]  - seeds: <none>
[10:24:17.129]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.129] getGlobalsAndPackages() ...
[10:24:17.129] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.130] Resolving globals: FALSE
[10:24:17.130] Tweak future expression to call with '...' arguments ...
[10:24:17.130] {
[10:24:17.130]     do.call(function(...) {
[10:24:17.130]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.130]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.130]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.130]             on.exit(options(oopts), add = TRUE)
[10:24:17.130]         }
[10:24:17.130]         {
[10:24:17.130]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.130]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.130]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.130]             })
[10:24:17.130]         }
[10:24:17.130]     }, args = future.call.arguments)
[10:24:17.130] }
[10:24:17.130] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.131] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.132] - packages: [1] ‘future.apply’
[10:24:17.132] getGlobalsAndPackages() ... DONE
[10:24:17.132] run() for ‘Future’ ...
[10:24:17.132] - state: ‘created’
[10:24:17.133] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.137] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.138] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.138]   - Field: ‘label’
[10:24:17.138]   - Field: ‘local’
[10:24:17.138]   - Field: ‘owner’
[10:24:17.138]   - Field: ‘envir’
[10:24:17.138]   - Field: ‘workers’
[10:24:17.139]   - Field: ‘packages’
[10:24:17.139]   - Field: ‘gc’
[10:24:17.139]   - Field: ‘job’
[10:24:17.139]   - Field: ‘conditions’
[10:24:17.139]   - Field: ‘expr’
[10:24:17.139]   - Field: ‘uuid’
[10:24:17.139]   - Field: ‘seed’
[10:24:17.140]   - Field: ‘version’
[10:24:17.140]   - Field: ‘result’
[10:24:17.140]   - Field: ‘asynchronous’
[10:24:17.140]   - Field: ‘calls’
[10:24:17.140]   - Field: ‘globals’
[10:24:17.140]   - Field: ‘stdout’
[10:24:17.140]   - Field: ‘earlySignal’
[10:24:17.140]   - Field: ‘lazy’
[10:24:17.141]   - Field: ‘state’
[10:24:17.141] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.141] - Launch lazy future ...
[10:24:17.141] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.141] Packages needed by future strategies (n = 0): <none>
[10:24:17.142] {
[10:24:17.142]     {
[10:24:17.142]         {
[10:24:17.142]             ...future.startTime <- base::Sys.time()
[10:24:17.142]             {
[10:24:17.142]                 {
[10:24:17.142]                   {
[10:24:17.142]                     {
[10:24:17.142]                       {
[10:24:17.142]                         base::local({
[10:24:17.142]                           has_future <- base::requireNamespace("future", 
[10:24:17.142]                             quietly = TRUE)
[10:24:17.142]                           if (has_future) {
[10:24:17.142]                             ns <- base::getNamespace("future")
[10:24:17.142]                             version <- ns[[".package"]][["version"]]
[10:24:17.142]                             if (is.null(version)) 
[10:24:17.142]                               version <- utils::packageVersion("future")
[10:24:17.142]                           }
[10:24:17.142]                           else {
[10:24:17.142]                             version <- NULL
[10:24:17.142]                           }
[10:24:17.142]                           if (!has_future || version < "1.8.0") {
[10:24:17.142]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.142]                               "", base::R.version$version.string), 
[10:24:17.142]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.142]                                 base::R.version$platform, 8 * 
[10:24:17.142]                                   base::.Machine$sizeof.pointer), 
[10:24:17.142]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.142]                                 "release", "version")], collapse = " "), 
[10:24:17.142]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.142]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.142]                               info)
[10:24:17.142]                             info <- base::paste(info, collapse = "; ")
[10:24:17.142]                             if (!has_future) {
[10:24:17.142]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.142]                                 info)
[10:24:17.142]                             }
[10:24:17.142]                             else {
[10:24:17.142]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.142]                                 info, version)
[10:24:17.142]                             }
[10:24:17.142]                             base::stop(msg)
[10:24:17.142]                           }
[10:24:17.142]                         })
[10:24:17.142]                       }
[10:24:17.142]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.142]                       base::options(mc.cores = 1L)
[10:24:17.142]                     }
[10:24:17.142]                     base::local({
[10:24:17.142]                       for (pkg in "future.apply") {
[10:24:17.142]                         base::loadNamespace(pkg)
[10:24:17.142]                         base::library(pkg, character.only = TRUE)
[10:24:17.142]                       }
[10:24:17.142]                     })
[10:24:17.142]                   }
[10:24:17.142]                   options(future.plan = NULL)
[10:24:17.142]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.142]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.142]                 }
[10:24:17.142]                 ...future.workdir <- getwd()
[10:24:17.142]             }
[10:24:17.142]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.142]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.142]         }
[10:24:17.142]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.142]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.142]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.142]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.142]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.142]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.142]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.142]             base::names(...future.oldOptions))
[10:24:17.142]     }
[10:24:17.142]     if (FALSE) {
[10:24:17.142]     }
[10:24:17.142]     else {
[10:24:17.142]         if (TRUE) {
[10:24:17.142]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.142]                 open = "w")
[10:24:17.142]         }
[10:24:17.142]         else {
[10:24:17.142]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.142]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.142]         }
[10:24:17.142]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.142]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.142]             base::sink(type = "output", split = FALSE)
[10:24:17.142]             base::close(...future.stdout)
[10:24:17.142]         }, add = TRUE)
[10:24:17.142]     }
[10:24:17.142]     ...future.frame <- base::sys.nframe()
[10:24:17.142]     ...future.conditions <- base::list()
[10:24:17.142]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.142]     if (FALSE) {
[10:24:17.142]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.142]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.142]     }
[10:24:17.142]     ...future.result <- base::tryCatch({
[10:24:17.142]         base::withCallingHandlers({
[10:24:17.142]             ...future.value <- base::withVisible(base::local({
[10:24:17.142]                 withCallingHandlers({
[10:24:17.142]                   {
[10:24:17.142]                     do.call(function(...) {
[10:24:17.142]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.142]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.142]                         ...future.globals.maxSize)) {
[10:24:17.142]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.142]                         on.exit(options(oopts), add = TRUE)
[10:24:17.142]                       }
[10:24:17.142]                       {
[10:24:17.142]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.142]                           FUN = function(jj) {
[10:24:17.142]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.142]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.142]                           })
[10:24:17.142]                       }
[10:24:17.142]                     }, args = future.call.arguments)
[10:24:17.142]                   }
[10:24:17.142]                 }, immediateCondition = function(cond) {
[10:24:17.142]                   save_rds <- function (object, pathname, ...) 
[10:24:17.142]                   {
[10:24:17.142]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.142]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.142]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.142]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.142]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.142]                         fi_tmp[["mtime"]])
[10:24:17.142]                     }
[10:24:17.142]                     tryCatch({
[10:24:17.142]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.142]                     }, error = function(ex) {
[10:24:17.142]                       msg <- conditionMessage(ex)
[10:24:17.142]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.142]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.142]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.142]                         fi_tmp[["mtime"]], msg)
[10:24:17.142]                       ex$message <- msg
[10:24:17.142]                       stop(ex)
[10:24:17.142]                     })
[10:24:17.142]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.142]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.142]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.142]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.142]                       fi <- file.info(pathname)
[10:24:17.142]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.142]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.142]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.142]                         fi[["size"]], fi[["mtime"]])
[10:24:17.142]                       stop(msg)
[10:24:17.142]                     }
[10:24:17.142]                     invisible(pathname)
[10:24:17.142]                   }
[10:24:17.142]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.142]                     rootPath = tempdir()) 
[10:24:17.142]                   {
[10:24:17.142]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.142]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.142]                       tmpdir = path, fileext = ".rds")
[10:24:17.142]                     save_rds(obj, file)
[10:24:17.142]                   }
[10:24:17.142]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.142]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.142]                   {
[10:24:17.142]                     inherits <- base::inherits
[10:24:17.142]                     invokeRestart <- base::invokeRestart
[10:24:17.142]                     is.null <- base::is.null
[10:24:17.142]                     muffled <- FALSE
[10:24:17.142]                     if (inherits(cond, "message")) {
[10:24:17.142]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.142]                       if (muffled) 
[10:24:17.142]                         invokeRestart("muffleMessage")
[10:24:17.142]                     }
[10:24:17.142]                     else if (inherits(cond, "warning")) {
[10:24:17.142]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.142]                       if (muffled) 
[10:24:17.142]                         invokeRestart("muffleWarning")
[10:24:17.142]                     }
[10:24:17.142]                     else if (inherits(cond, "condition")) {
[10:24:17.142]                       if (!is.null(pattern)) {
[10:24:17.142]                         computeRestarts <- base::computeRestarts
[10:24:17.142]                         grepl <- base::grepl
[10:24:17.142]                         restarts <- computeRestarts(cond)
[10:24:17.142]                         for (restart in restarts) {
[10:24:17.142]                           name <- restart$name
[10:24:17.142]                           if (is.null(name)) 
[10:24:17.142]                             next
[10:24:17.142]                           if (!grepl(pattern, name)) 
[10:24:17.142]                             next
[10:24:17.142]                           invokeRestart(restart)
[10:24:17.142]                           muffled <- TRUE
[10:24:17.142]                           break
[10:24:17.142]                         }
[10:24:17.142]                       }
[10:24:17.142]                     }
[10:24:17.142]                     invisible(muffled)
[10:24:17.142]                   }
[10:24:17.142]                   muffleCondition(cond)
[10:24:17.142]                 })
[10:24:17.142]             }))
[10:24:17.142]             future::FutureResult(value = ...future.value$value, 
[10:24:17.142]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.142]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.142]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.142]                     ...future.globalenv.names))
[10:24:17.142]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.142]         }, condition = base::local({
[10:24:17.142]             c <- base::c
[10:24:17.142]             inherits <- base::inherits
[10:24:17.142]             invokeRestart <- base::invokeRestart
[10:24:17.142]             length <- base::length
[10:24:17.142]             list <- base::list
[10:24:17.142]             seq.int <- base::seq.int
[10:24:17.142]             signalCondition <- base::signalCondition
[10:24:17.142]             sys.calls <- base::sys.calls
[10:24:17.142]             `[[` <- base::`[[`
[10:24:17.142]             `+` <- base::`+`
[10:24:17.142]             `<<-` <- base::`<<-`
[10:24:17.142]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.142]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.142]                   3L)]
[10:24:17.142]             }
[10:24:17.142]             function(cond) {
[10:24:17.142]                 is_error <- inherits(cond, "error")
[10:24:17.142]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.142]                   NULL)
[10:24:17.142]                 if (is_error) {
[10:24:17.142]                   sessionInformation <- function() {
[10:24:17.142]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.142]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.142]                       search = base::search(), system = base::Sys.info())
[10:24:17.142]                   }
[10:24:17.142]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.142]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.142]                     cond$call), session = sessionInformation(), 
[10:24:17.142]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.142]                   signalCondition(cond)
[10:24:17.142]                 }
[10:24:17.142]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.142]                 "immediateCondition"))) {
[10:24:17.142]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.142]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.142]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.142]                   if (TRUE && !signal) {
[10:24:17.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.142]                     {
[10:24:17.142]                       inherits <- base::inherits
[10:24:17.142]                       invokeRestart <- base::invokeRestart
[10:24:17.142]                       is.null <- base::is.null
[10:24:17.142]                       muffled <- FALSE
[10:24:17.142]                       if (inherits(cond, "message")) {
[10:24:17.142]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.142]                         if (muffled) 
[10:24:17.142]                           invokeRestart("muffleMessage")
[10:24:17.142]                       }
[10:24:17.142]                       else if (inherits(cond, "warning")) {
[10:24:17.142]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.142]                         if (muffled) 
[10:24:17.142]                           invokeRestart("muffleWarning")
[10:24:17.142]                       }
[10:24:17.142]                       else if (inherits(cond, "condition")) {
[10:24:17.142]                         if (!is.null(pattern)) {
[10:24:17.142]                           computeRestarts <- base::computeRestarts
[10:24:17.142]                           grepl <- base::grepl
[10:24:17.142]                           restarts <- computeRestarts(cond)
[10:24:17.142]                           for (restart in restarts) {
[10:24:17.142]                             name <- restart$name
[10:24:17.142]                             if (is.null(name)) 
[10:24:17.142]                               next
[10:24:17.142]                             if (!grepl(pattern, name)) 
[10:24:17.142]                               next
[10:24:17.142]                             invokeRestart(restart)
[10:24:17.142]                             muffled <- TRUE
[10:24:17.142]                             break
[10:24:17.142]                           }
[10:24:17.142]                         }
[10:24:17.142]                       }
[10:24:17.142]                       invisible(muffled)
[10:24:17.142]                     }
[10:24:17.142]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.142]                   }
[10:24:17.142]                 }
[10:24:17.142]                 else {
[10:24:17.142]                   if (TRUE) {
[10:24:17.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.142]                     {
[10:24:17.142]                       inherits <- base::inherits
[10:24:17.142]                       invokeRestart <- base::invokeRestart
[10:24:17.142]                       is.null <- base::is.null
[10:24:17.142]                       muffled <- FALSE
[10:24:17.142]                       if (inherits(cond, "message")) {
[10:24:17.142]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.142]                         if (muffled) 
[10:24:17.142]                           invokeRestart("muffleMessage")
[10:24:17.142]                       }
[10:24:17.142]                       else if (inherits(cond, "warning")) {
[10:24:17.142]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.142]                         if (muffled) 
[10:24:17.142]                           invokeRestart("muffleWarning")
[10:24:17.142]                       }
[10:24:17.142]                       else if (inherits(cond, "condition")) {
[10:24:17.142]                         if (!is.null(pattern)) {
[10:24:17.142]                           computeRestarts <- base::computeRestarts
[10:24:17.142]                           grepl <- base::grepl
[10:24:17.142]                           restarts <- computeRestarts(cond)
[10:24:17.142]                           for (restart in restarts) {
[10:24:17.142]                             name <- restart$name
[10:24:17.142]                             if (is.null(name)) 
[10:24:17.142]                               next
[10:24:17.142]                             if (!grepl(pattern, name)) 
[10:24:17.142]                               next
[10:24:17.142]                             invokeRestart(restart)
[10:24:17.142]                             muffled <- TRUE
[10:24:17.142]                             break
[10:24:17.142]                           }
[10:24:17.142]                         }
[10:24:17.142]                       }
[10:24:17.142]                       invisible(muffled)
[10:24:17.142]                     }
[10:24:17.142]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.142]                   }
[10:24:17.142]                 }
[10:24:17.142]             }
[10:24:17.142]         }))
[10:24:17.142]     }, error = function(ex) {
[10:24:17.142]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.142]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.142]                 ...future.rng), started = ...future.startTime, 
[10:24:17.142]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.142]             version = "1.8"), class = "FutureResult")
[10:24:17.142]     }, finally = {
[10:24:17.142]         if (!identical(...future.workdir, getwd())) 
[10:24:17.142]             setwd(...future.workdir)
[10:24:17.142]         {
[10:24:17.142]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.142]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.142]             }
[10:24:17.142]             base::options(...future.oldOptions)
[10:24:17.142]             if (.Platform$OS.type == "windows") {
[10:24:17.142]                 old_names <- names(...future.oldEnvVars)
[10:24:17.142]                 envs <- base::Sys.getenv()
[10:24:17.142]                 names <- names(envs)
[10:24:17.142]                 common <- intersect(names, old_names)
[10:24:17.142]                 added <- setdiff(names, old_names)
[10:24:17.142]                 removed <- setdiff(old_names, names)
[10:24:17.142]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.142]                   envs[common]]
[10:24:17.142]                 NAMES <- toupper(changed)
[10:24:17.142]                 args <- list()
[10:24:17.142]                 for (kk in seq_along(NAMES)) {
[10:24:17.142]                   name <- changed[[kk]]
[10:24:17.142]                   NAME <- NAMES[[kk]]
[10:24:17.142]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.142]                     next
[10:24:17.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.142]                 }
[10:24:17.142]                 NAMES <- toupper(added)
[10:24:17.142]                 for (kk in seq_along(NAMES)) {
[10:24:17.142]                   name <- added[[kk]]
[10:24:17.142]                   NAME <- NAMES[[kk]]
[10:24:17.142]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.142]                     next
[10:24:17.142]                   args[[name]] <- ""
[10:24:17.142]                 }
[10:24:17.142]                 NAMES <- toupper(removed)
[10:24:17.142]                 for (kk in seq_along(NAMES)) {
[10:24:17.142]                   name <- removed[[kk]]
[10:24:17.142]                   NAME <- NAMES[[kk]]
[10:24:17.142]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.142]                     next
[10:24:17.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.142]                 }
[10:24:17.142]                 if (length(args) > 0) 
[10:24:17.142]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.142]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.142]             }
[10:24:17.142]             else {
[10:24:17.142]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.142]             }
[10:24:17.142]             {
[10:24:17.142]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.142]                   0L) {
[10:24:17.142]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.142]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.142]                   base::options(opts)
[10:24:17.142]                 }
[10:24:17.142]                 {
[10:24:17.142]                   {
[10:24:17.142]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.142]                     NULL
[10:24:17.142]                   }
[10:24:17.142]                   options(future.plan = NULL)
[10:24:17.142]                   if (is.na(NA_character_)) 
[10:24:17.142]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.142]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.142]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.142]                     envir = parent.frame()) 
[10:24:17.142]                   {
[10:24:17.142]                     default_workers <- missing(workers)
[10:24:17.142]                     if (is.function(workers)) 
[10:24:17.142]                       workers <- workers()
[10:24:17.142]                     workers <- structure(as.integer(workers), 
[10:24:17.142]                       class = class(workers))
[10:24:17.142]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.142]                       1L)
[10:24:17.142]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.142]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.142]                       if (default_workers) 
[10:24:17.142]                         supportsMulticore(warn = TRUE)
[10:24:17.142]                       return(sequential(..., envir = envir))
[10:24:17.142]                     }
[10:24:17.142]                     oopts <- options(mc.cores = workers)
[10:24:17.142]                     on.exit(options(oopts))
[10:24:17.142]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.142]                       envir = envir)
[10:24:17.142]                     if (!future$lazy) 
[10:24:17.142]                       future <- run(future)
[10:24:17.142]                     invisible(future)
[10:24:17.142]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.142]                 }
[10:24:17.142]             }
[10:24:17.142]         }
[10:24:17.142]     })
[10:24:17.142]     if (TRUE) {
[10:24:17.142]         base::sink(type = "output", split = FALSE)
[10:24:17.142]         if (TRUE) {
[10:24:17.142]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.142]         }
[10:24:17.142]         else {
[10:24:17.142]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.142]         }
[10:24:17.142]         base::close(...future.stdout)
[10:24:17.142]         ...future.stdout <- NULL
[10:24:17.142]     }
[10:24:17.142]     ...future.result$conditions <- ...future.conditions
[10:24:17.142]     ...future.result$finished <- base::Sys.time()
[10:24:17.142]     ...future.result
[10:24:17.142] }
[10:24:17.145] assign_globals() ...
[10:24:17.145] List of 11
[10:24:17.145]  $ ...future.FUN            :function (x, ...)  
[10:24:17.145]  $ x_FUN                    :function (x)  
[10:24:17.145]  $ times                    : int 0
[10:24:17.145]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.145]  $ stop_if_not              :function (...)  
[10:24:17.145]  $ dim                      : NULL
[10:24:17.145]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:17.145]  $ future.call.arguments    : list()
[10:24:17.145]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.145]  $ ...future.elements_ii    :List of 5
[10:24:17.145]   ..$ : int 6
[10:24:17.145]   ..$ : int 7
[10:24:17.145]   ..$ : int 8
[10:24:17.145]   ..$ : int 9
[10:24:17.145]   ..$ : int 10
[10:24:17.145]  $ ...future.seeds_ii       : NULL
[10:24:17.145]  $ ...future.globals.maxSize: NULL
[10:24:17.145]  - attr(*, "where")=List of 11
[10:24:17.145]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.145]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.145]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.145]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.145]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.145]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.145]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.145]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.145]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.145]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.145]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.145]  - attr(*, "resolved")= logi FALSE
[10:24:17.145]  - attr(*, "total_size")= num 95472
[10:24:17.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.145]  - attr(*, "already-done")= logi TRUE
[10:24:17.156] - copied ‘...future.FUN’ to environment
[10:24:17.158] - reassign environment for ‘x_FUN’
[10:24:17.158] - copied ‘x_FUN’ to environment
[10:24:17.158] - copied ‘times’ to environment
[10:24:17.158] - copied ‘stopf’ to environment
[10:24:17.158] - copied ‘stop_if_not’ to environment
[10:24:17.158] - copied ‘dim’ to environment
[10:24:17.159] - copied ‘valid_types’ to environment
[10:24:17.159] - copied ‘future.call.arguments’ to environment
[10:24:17.159] - copied ‘...future.elements_ii’ to environment
[10:24:17.159] - copied ‘...future.seeds_ii’ to environment
[10:24:17.159] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.159] assign_globals() ... done
[10:24:17.159] requestCore(): workers = 2
[10:24:17.162] MulticoreFuture started
[10:24:17.162] - Launch lazy future ... done
[10:24:17.163] run() for ‘MulticoreFuture’ ... done
[10:24:17.164] Created future:
[10:24:17.164] plan(): Setting new future strategy stack:
[10:24:17.164] List of future strategies:
[10:24:17.164] 1. sequential:
[10:24:17.164]    - args: function (..., envir = parent.frame())
[10:24:17.164]    - tweaked: FALSE
[10:24:17.164]    - call: NULL
[10:24:17.165] plan(): nbrOfWorkers() = 1
[10:24:17.168] plan(): Setting new future strategy stack:
[10:24:17.168] List of future strategies:
[10:24:17.168] 1. multicore:
[10:24:17.168]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.168]    - tweaked: FALSE
[10:24:17.168]    - call: plan(strategy)
[10:24:17.174] plan(): nbrOfWorkers() = 2
[10:24:17.164] MulticoreFuture:
[10:24:17.164] Label: ‘future_vapply-2’
[10:24:17.164] Expression:
[10:24:17.164] {
[10:24:17.164]     do.call(function(...) {
[10:24:17.164]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.164]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.164]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.164]             on.exit(options(oopts), add = TRUE)
[10:24:17.164]         }
[10:24:17.164]         {
[10:24:17.164]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.164]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.164]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.164]             })
[10:24:17.164]         }
[10:24:17.164]     }, args = future.call.arguments)
[10:24:17.164] }
[10:24:17.164] Lazy evaluation: FALSE
[10:24:17.164] Asynchronous evaluation: TRUE
[10:24:17.164] Local evaluation: TRUE
[10:24:17.164] Environment: R_GlobalEnv
[10:24:17.164] Capture standard output: TRUE
[10:24:17.164] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.164] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.164] Packages: 1 packages (‘future.apply’)
[10:24:17.164] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.164] Resolved: TRUE
[10:24:17.164] Value: <not collected>
[10:24:17.164] Conditions captured: <none>
[10:24:17.164] Early signaling: FALSE
[10:24:17.164] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.164] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.175] Chunk #2 of 2 ... DONE
[10:24:17.175] Launching 2 futures (chunks) ... DONE
[10:24:17.176] Resolving 2 futures (chunks) ...
[10:24:17.176] resolve() on list ...
[10:24:17.176]  recursive: 0
[10:24:17.176]  length: 2
[10:24:17.176] 
[10:24:17.177] Future #1
[10:24:17.177] result() for MulticoreFuture ...
[10:24:17.178] result() for MulticoreFuture ...
[10:24:17.178] result() for MulticoreFuture ... done
[10:24:17.178] result() for MulticoreFuture ... done
[10:24:17.178] result() for MulticoreFuture ...
[10:24:17.178] result() for MulticoreFuture ... done
[10:24:17.179] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:17.179] - nx: 2
[10:24:17.179] - relay: TRUE
[10:24:17.179] - stdout: TRUE
[10:24:17.179] - signal: TRUE
[10:24:17.180] - resignal: FALSE
[10:24:17.180] - force: TRUE
[10:24:17.180] - relayed: [n=2] FALSE, FALSE
[10:24:17.180] - queued futures: [n=2] FALSE, FALSE
[10:24:17.180]  - until=1
[10:24:17.181]  - relaying element #1
[10:24:17.181] result() for MulticoreFuture ...
[10:24:17.181] result() for MulticoreFuture ... done
[10:24:17.181] result() for MulticoreFuture ...
[10:24:17.181] result() for MulticoreFuture ... done
[10:24:17.182] result() for MulticoreFuture ...
[10:24:17.182] result() for MulticoreFuture ... done
[10:24:17.182] result() for MulticoreFuture ...
[10:24:17.182] result() for MulticoreFuture ... done
[10:24:17.182] - relayed: [n=2] TRUE, FALSE
[10:24:17.182] - queued futures: [n=2] TRUE, FALSE
[10:24:17.183] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:17.183]  length: 1 (resolved future 1)
[10:24:17.183] Future #2
[10:24:17.183] result() for MulticoreFuture ...
[10:24:17.184] result() for MulticoreFuture ...
[10:24:17.184] result() for MulticoreFuture ... done
[10:24:17.184] result() for MulticoreFuture ... done
[10:24:17.184] result() for MulticoreFuture ...
[10:24:17.184] result() for MulticoreFuture ... done
[10:24:17.185] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:17.185] - nx: 2
[10:24:17.185] - relay: TRUE
[10:24:17.185] - stdout: TRUE
[10:24:17.185] - signal: TRUE
[10:24:17.185] - resignal: FALSE
[10:24:17.185] - force: TRUE
[10:24:17.185] - relayed: [n=2] TRUE, FALSE
[10:24:17.186] - queued futures: [n=2] TRUE, FALSE
[10:24:17.186]  - until=2
[10:24:17.186]  - relaying element #2
[10:24:17.186] result() for MulticoreFuture ...
[10:24:17.186] result() for MulticoreFuture ... done
[10:24:17.186] result() for MulticoreFuture ...
[10:24:17.186] result() for MulticoreFuture ... done
[10:24:17.186] result() for MulticoreFuture ...
[10:24:17.187] result() for MulticoreFuture ... done
[10:24:17.187] result() for MulticoreFuture ...
[10:24:17.187] result() for MulticoreFuture ... done
[10:24:17.187] - relayed: [n=2] TRUE, TRUE
[10:24:17.187] - queued futures: [n=2] TRUE, TRUE
[10:24:17.187] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:17.187]  length: 0 (resolved future 2)
[10:24:17.187] Relaying remaining futures
[10:24:17.187] signalConditionsASAP(NULL, pos=0) ...
[10:24:17.187] - nx: 2
[10:24:17.188] - relay: TRUE
[10:24:17.188] - stdout: TRUE
[10:24:17.188] - signal: TRUE
[10:24:17.188] - resignal: FALSE
[10:24:17.188] - force: TRUE
[10:24:17.188] - relayed: [n=2] TRUE, TRUE
[10:24:17.188] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:17.188] - relayed: [n=2] TRUE, TRUE
[10:24:17.188] - queued futures: [n=2] TRUE, TRUE
[10:24:17.189] signalConditionsASAP(NULL, pos=0) ... done
[10:24:17.189] resolve() on list ... DONE
[10:24:17.189] result() for MulticoreFuture ...
[10:24:17.189] result() for MulticoreFuture ... done
[10:24:17.189] result() for MulticoreFuture ...
[10:24:17.189] result() for MulticoreFuture ... done
[10:24:17.189] result() for MulticoreFuture ...
[10:24:17.189] result() for MulticoreFuture ... done
[10:24:17.189] result() for MulticoreFuture ...
[10:24:17.190] result() for MulticoreFuture ... done
[10:24:17.190]  - Number of value chunks collected: 2
[10:24:17.190] Resolving 2 futures (chunks) ... DONE
[10:24:17.190] Reducing values from 2 chunks ...
[10:24:17.190]  - Number of values collected after concatenation: 10
[10:24:17.190]  - Number of values expected: 10
[10:24:17.190] Reducing values from 2 chunks ... DONE
[10:24:17.190] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[10:24:17.191] future_lapply() ...
[10:24:17.197] Number of chunks: 2
[10:24:17.197] getGlobalsAndPackagesXApply() ...
[10:24:17.197]  - future.globals: TRUE
[10:24:17.198] getGlobalsAndPackages() ...
[10:24:17.198] Searching for globals...
[10:24:17.204] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[10:24:17.204] Searching for globals ... DONE
[10:24:17.204] Resolving globals: FALSE
[10:24:17.205] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[10:24:17.205] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:17.205] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.206] - packages: [1] ‘future.apply’
[10:24:17.206] getGlobalsAndPackages() ... DONE
[10:24:17.206]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.206]  - needed namespaces: [n=1] ‘future.apply’
[10:24:17.206] Finding globals ... DONE
[10:24:17.206]  - use_args: TRUE
[10:24:17.206]  - Getting '...' globals ...
[10:24:17.207] resolve() on list ...
[10:24:17.207]  recursive: 0
[10:24:17.207]  length: 1
[10:24:17.207]  elements: ‘...’
[10:24:17.207]  length: 0 (resolved future 1)
[10:24:17.207] resolve() on list ... DONE
[10:24:17.207]    - '...' content: [n=0] 
[10:24:17.207] List of 1
[10:24:17.207]  $ ...: list()
[10:24:17.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.207]  - attr(*, "where")=List of 1
[10:24:17.207]   ..$ ...:<environment: 0x55b93cc23d08> 
[10:24:17.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.207]  - attr(*, "resolved")= logi TRUE
[10:24:17.207]  - attr(*, "total_size")= num NA
[10:24:17.210]  - Getting '...' globals ... DONE
[10:24:17.210] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:17.210] List of 8
[10:24:17.210]  $ ...future.FUN:function (x, ...)  
[10:24:17.210]  $ x_FUN        :function (x)  
[10:24:17.210]  $ times        : int 0
[10:24:17.210]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.210]  $ stop_if_not  :function (...)  
[10:24:17.210]  $ dim          : NULL
[10:24:17.210]  $ valid_types  : chr [1:2] "logical" "integer"
[10:24:17.210]  $ ...          : list()
[10:24:17.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.210]  - attr(*, "where")=List of 8
[10:24:17.210]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:17.210]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:17.210]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:17.210]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:17.210]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:17.210]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:17.210]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:17.210]   ..$ ...          :<environment: 0x55b93cc23d08> 
[10:24:17.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.210]  - attr(*, "resolved")= logi FALSE
[10:24:17.210]  - attr(*, "total_size")= num 95400
[10:24:17.215] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:17.216] getGlobalsAndPackagesXApply() ... DONE
[10:24:17.216] Number of futures (= number of chunks): 2
[10:24:17.216] Launching 2 futures (chunks) ...
[10:24:17.216] Chunk #1 of 2 ...
[10:24:17.216]  - Finding globals in 'X' for chunk #1 ...
[10:24:17.216] getGlobalsAndPackages() ...
[10:24:17.216] Searching for globals...
[10:24:17.217] 
[10:24:17.217] Searching for globals ... DONE
[10:24:17.217] - globals: [0] <none>
[10:24:17.217] getGlobalsAndPackages() ... DONE
[10:24:17.217]    + additional globals found: [n=0] 
[10:24:17.217]    + additional namespaces needed: [n=0] 
[10:24:17.217]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:17.217]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.217]  - seeds: <none>
[10:24:17.217]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.218] getGlobalsAndPackages() ...
[10:24:17.218] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.218] Resolving globals: FALSE
[10:24:17.218] Tweak future expression to call with '...' arguments ...
[10:24:17.218] {
[10:24:17.218]     do.call(function(...) {
[10:24:17.218]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.218]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.218]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.218]             on.exit(options(oopts), add = TRUE)
[10:24:17.218]         }
[10:24:17.218]         {
[10:24:17.218]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.218]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.218]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.218]             })
[10:24:17.218]         }
[10:24:17.218]     }, args = future.call.arguments)
[10:24:17.218] }
[10:24:17.218] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.219] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.219] - packages: [1] ‘future.apply’
[10:24:17.219] getGlobalsAndPackages() ... DONE
[10:24:17.219] run() for ‘Future’ ...
[10:24:17.219] - state: ‘created’
[10:24:17.220] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.223] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.223] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.225]   - Field: ‘label’
[10:24:17.225]   - Field: ‘local’
[10:24:17.225]   - Field: ‘owner’
[10:24:17.225]   - Field: ‘envir’
[10:24:17.225]   - Field: ‘workers’
[10:24:17.225]   - Field: ‘packages’
[10:24:17.225]   - Field: ‘gc’
[10:24:17.225]   - Field: ‘job’
[10:24:17.226]   - Field: ‘conditions’
[10:24:17.226]   - Field: ‘expr’
[10:24:17.226]   - Field: ‘uuid’
[10:24:17.226]   - Field: ‘seed’
[10:24:17.226]   - Field: ‘version’
[10:24:17.226]   - Field: ‘result’
[10:24:17.226]   - Field: ‘asynchronous’
[10:24:17.226]   - Field: ‘calls’
[10:24:17.226]   - Field: ‘globals’
[10:24:17.226]   - Field: ‘stdout’
[10:24:17.227]   - Field: ‘earlySignal’
[10:24:17.227]   - Field: ‘lazy’
[10:24:17.227]   - Field: ‘state’
[10:24:17.227] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.227] - Launch lazy future ...
[10:24:17.227] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.227] Packages needed by future strategies (n = 0): <none>
[10:24:17.228] {
[10:24:17.228]     {
[10:24:17.228]         {
[10:24:17.228]             ...future.startTime <- base::Sys.time()
[10:24:17.228]             {
[10:24:17.228]                 {
[10:24:17.228]                   {
[10:24:17.228]                     {
[10:24:17.228]                       {
[10:24:17.228]                         base::local({
[10:24:17.228]                           has_future <- base::requireNamespace("future", 
[10:24:17.228]                             quietly = TRUE)
[10:24:17.228]                           if (has_future) {
[10:24:17.228]                             ns <- base::getNamespace("future")
[10:24:17.228]                             version <- ns[[".package"]][["version"]]
[10:24:17.228]                             if (is.null(version)) 
[10:24:17.228]                               version <- utils::packageVersion("future")
[10:24:17.228]                           }
[10:24:17.228]                           else {
[10:24:17.228]                             version <- NULL
[10:24:17.228]                           }
[10:24:17.228]                           if (!has_future || version < "1.8.0") {
[10:24:17.228]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.228]                               "", base::R.version$version.string), 
[10:24:17.228]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.228]                                 base::R.version$platform, 8 * 
[10:24:17.228]                                   base::.Machine$sizeof.pointer), 
[10:24:17.228]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.228]                                 "release", "version")], collapse = " "), 
[10:24:17.228]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.228]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.228]                               info)
[10:24:17.228]                             info <- base::paste(info, collapse = "; ")
[10:24:17.228]                             if (!has_future) {
[10:24:17.228]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.228]                                 info)
[10:24:17.228]                             }
[10:24:17.228]                             else {
[10:24:17.228]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.228]                                 info, version)
[10:24:17.228]                             }
[10:24:17.228]                             base::stop(msg)
[10:24:17.228]                           }
[10:24:17.228]                         })
[10:24:17.228]                       }
[10:24:17.228]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.228]                       base::options(mc.cores = 1L)
[10:24:17.228]                     }
[10:24:17.228]                     base::local({
[10:24:17.228]                       for (pkg in "future.apply") {
[10:24:17.228]                         base::loadNamespace(pkg)
[10:24:17.228]                         base::library(pkg, character.only = TRUE)
[10:24:17.228]                       }
[10:24:17.228]                     })
[10:24:17.228]                   }
[10:24:17.228]                   options(future.plan = NULL)
[10:24:17.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.228]                 }
[10:24:17.228]                 ...future.workdir <- getwd()
[10:24:17.228]             }
[10:24:17.228]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.228]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.228]         }
[10:24:17.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.228]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.228]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.228]             base::names(...future.oldOptions))
[10:24:17.228]     }
[10:24:17.228]     if (FALSE) {
[10:24:17.228]     }
[10:24:17.228]     else {
[10:24:17.228]         if (TRUE) {
[10:24:17.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.228]                 open = "w")
[10:24:17.228]         }
[10:24:17.228]         else {
[10:24:17.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.228]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.228]         }
[10:24:17.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.228]             base::sink(type = "output", split = FALSE)
[10:24:17.228]             base::close(...future.stdout)
[10:24:17.228]         }, add = TRUE)
[10:24:17.228]     }
[10:24:17.228]     ...future.frame <- base::sys.nframe()
[10:24:17.228]     ...future.conditions <- base::list()
[10:24:17.228]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.228]     if (FALSE) {
[10:24:17.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.228]     }
[10:24:17.228]     ...future.result <- base::tryCatch({
[10:24:17.228]         base::withCallingHandlers({
[10:24:17.228]             ...future.value <- base::withVisible(base::local({
[10:24:17.228]                 withCallingHandlers({
[10:24:17.228]                   {
[10:24:17.228]                     do.call(function(...) {
[10:24:17.228]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.228]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.228]                         ...future.globals.maxSize)) {
[10:24:17.228]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.228]                         on.exit(options(oopts), add = TRUE)
[10:24:17.228]                       }
[10:24:17.228]                       {
[10:24:17.228]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.228]                           FUN = function(jj) {
[10:24:17.228]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.228]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.228]                           })
[10:24:17.228]                       }
[10:24:17.228]                     }, args = future.call.arguments)
[10:24:17.228]                   }
[10:24:17.228]                 }, immediateCondition = function(cond) {
[10:24:17.228]                   save_rds <- function (object, pathname, ...) 
[10:24:17.228]                   {
[10:24:17.228]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.228]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.228]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.228]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.228]                         fi_tmp[["mtime"]])
[10:24:17.228]                     }
[10:24:17.228]                     tryCatch({
[10:24:17.228]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.228]                     }, error = function(ex) {
[10:24:17.228]                       msg <- conditionMessage(ex)
[10:24:17.228]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.228]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.228]                         fi_tmp[["mtime"]], msg)
[10:24:17.228]                       ex$message <- msg
[10:24:17.228]                       stop(ex)
[10:24:17.228]                     })
[10:24:17.228]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.228]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.228]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.228]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.228]                       fi <- file.info(pathname)
[10:24:17.228]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.228]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.228]                         fi[["size"]], fi[["mtime"]])
[10:24:17.228]                       stop(msg)
[10:24:17.228]                     }
[10:24:17.228]                     invisible(pathname)
[10:24:17.228]                   }
[10:24:17.228]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.228]                     rootPath = tempdir()) 
[10:24:17.228]                   {
[10:24:17.228]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.228]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.228]                       tmpdir = path, fileext = ".rds")
[10:24:17.228]                     save_rds(obj, file)
[10:24:17.228]                   }
[10:24:17.228]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.228]                   {
[10:24:17.228]                     inherits <- base::inherits
[10:24:17.228]                     invokeRestart <- base::invokeRestart
[10:24:17.228]                     is.null <- base::is.null
[10:24:17.228]                     muffled <- FALSE
[10:24:17.228]                     if (inherits(cond, "message")) {
[10:24:17.228]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.228]                       if (muffled) 
[10:24:17.228]                         invokeRestart("muffleMessage")
[10:24:17.228]                     }
[10:24:17.228]                     else if (inherits(cond, "warning")) {
[10:24:17.228]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.228]                       if (muffled) 
[10:24:17.228]                         invokeRestart("muffleWarning")
[10:24:17.228]                     }
[10:24:17.228]                     else if (inherits(cond, "condition")) {
[10:24:17.228]                       if (!is.null(pattern)) {
[10:24:17.228]                         computeRestarts <- base::computeRestarts
[10:24:17.228]                         grepl <- base::grepl
[10:24:17.228]                         restarts <- computeRestarts(cond)
[10:24:17.228]                         for (restart in restarts) {
[10:24:17.228]                           name <- restart$name
[10:24:17.228]                           if (is.null(name)) 
[10:24:17.228]                             next
[10:24:17.228]                           if (!grepl(pattern, name)) 
[10:24:17.228]                             next
[10:24:17.228]                           invokeRestart(restart)
[10:24:17.228]                           muffled <- TRUE
[10:24:17.228]                           break
[10:24:17.228]                         }
[10:24:17.228]                       }
[10:24:17.228]                     }
[10:24:17.228]                     invisible(muffled)
[10:24:17.228]                   }
[10:24:17.228]                   muffleCondition(cond)
[10:24:17.228]                 })
[10:24:17.228]             }))
[10:24:17.228]             future::FutureResult(value = ...future.value$value, 
[10:24:17.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.228]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.228]                     ...future.globalenv.names))
[10:24:17.228]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.228]         }, condition = base::local({
[10:24:17.228]             c <- base::c
[10:24:17.228]             inherits <- base::inherits
[10:24:17.228]             invokeRestart <- base::invokeRestart
[10:24:17.228]             length <- base::length
[10:24:17.228]             list <- base::list
[10:24:17.228]             seq.int <- base::seq.int
[10:24:17.228]             signalCondition <- base::signalCondition
[10:24:17.228]             sys.calls <- base::sys.calls
[10:24:17.228]             `[[` <- base::`[[`
[10:24:17.228]             `+` <- base::`+`
[10:24:17.228]             `<<-` <- base::`<<-`
[10:24:17.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.228]                   3L)]
[10:24:17.228]             }
[10:24:17.228]             function(cond) {
[10:24:17.228]                 is_error <- inherits(cond, "error")
[10:24:17.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.228]                   NULL)
[10:24:17.228]                 if (is_error) {
[10:24:17.228]                   sessionInformation <- function() {
[10:24:17.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.228]                       search = base::search(), system = base::Sys.info())
[10:24:17.228]                   }
[10:24:17.228]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.228]                     cond$call), session = sessionInformation(), 
[10:24:17.228]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.228]                   signalCondition(cond)
[10:24:17.228]                 }
[10:24:17.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.228]                 "immediateCondition"))) {
[10:24:17.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.228]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.228]                   if (TRUE && !signal) {
[10:24:17.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.228]                     {
[10:24:17.228]                       inherits <- base::inherits
[10:24:17.228]                       invokeRestart <- base::invokeRestart
[10:24:17.228]                       is.null <- base::is.null
[10:24:17.228]                       muffled <- FALSE
[10:24:17.228]                       if (inherits(cond, "message")) {
[10:24:17.228]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.228]                         if (muffled) 
[10:24:17.228]                           invokeRestart("muffleMessage")
[10:24:17.228]                       }
[10:24:17.228]                       else if (inherits(cond, "warning")) {
[10:24:17.228]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.228]                         if (muffled) 
[10:24:17.228]                           invokeRestart("muffleWarning")
[10:24:17.228]                       }
[10:24:17.228]                       else if (inherits(cond, "condition")) {
[10:24:17.228]                         if (!is.null(pattern)) {
[10:24:17.228]                           computeRestarts <- base::computeRestarts
[10:24:17.228]                           grepl <- base::grepl
[10:24:17.228]                           restarts <- computeRestarts(cond)
[10:24:17.228]                           for (restart in restarts) {
[10:24:17.228]                             name <- restart$name
[10:24:17.228]                             if (is.null(name)) 
[10:24:17.228]                               next
[10:24:17.228]                             if (!grepl(pattern, name)) 
[10:24:17.228]                               next
[10:24:17.228]                             invokeRestart(restart)
[10:24:17.228]                             muffled <- TRUE
[10:24:17.228]                             break
[10:24:17.228]                           }
[10:24:17.228]                         }
[10:24:17.228]                       }
[10:24:17.228]                       invisible(muffled)
[10:24:17.228]                     }
[10:24:17.228]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.228]                   }
[10:24:17.228]                 }
[10:24:17.228]                 else {
[10:24:17.228]                   if (TRUE) {
[10:24:17.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.228]                     {
[10:24:17.228]                       inherits <- base::inherits
[10:24:17.228]                       invokeRestart <- base::invokeRestart
[10:24:17.228]                       is.null <- base::is.null
[10:24:17.228]                       muffled <- FALSE
[10:24:17.228]                       if (inherits(cond, "message")) {
[10:24:17.228]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.228]                         if (muffled) 
[10:24:17.228]                           invokeRestart("muffleMessage")
[10:24:17.228]                       }
[10:24:17.228]                       else if (inherits(cond, "warning")) {
[10:24:17.228]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.228]                         if (muffled) 
[10:24:17.228]                           invokeRestart("muffleWarning")
[10:24:17.228]                       }
[10:24:17.228]                       else if (inherits(cond, "condition")) {
[10:24:17.228]                         if (!is.null(pattern)) {
[10:24:17.228]                           computeRestarts <- base::computeRestarts
[10:24:17.228]                           grepl <- base::grepl
[10:24:17.228]                           restarts <- computeRestarts(cond)
[10:24:17.228]                           for (restart in restarts) {
[10:24:17.228]                             name <- restart$name
[10:24:17.228]                             if (is.null(name)) 
[10:24:17.228]                               next
[10:24:17.228]                             if (!grepl(pattern, name)) 
[10:24:17.228]                               next
[10:24:17.228]                             invokeRestart(restart)
[10:24:17.228]                             muffled <- TRUE
[10:24:17.228]                             break
[10:24:17.228]                           }
[10:24:17.228]                         }
[10:24:17.228]                       }
[10:24:17.228]                       invisible(muffled)
[10:24:17.228]                     }
[10:24:17.228]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.228]                   }
[10:24:17.228]                 }
[10:24:17.228]             }
[10:24:17.228]         }))
[10:24:17.228]     }, error = function(ex) {
[10:24:17.228]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.228]                 ...future.rng), started = ...future.startTime, 
[10:24:17.228]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.228]             version = "1.8"), class = "FutureResult")
[10:24:17.228]     }, finally = {
[10:24:17.228]         if (!identical(...future.workdir, getwd())) 
[10:24:17.228]             setwd(...future.workdir)
[10:24:17.228]         {
[10:24:17.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.228]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.228]             }
[10:24:17.228]             base::options(...future.oldOptions)
[10:24:17.228]             if (.Platform$OS.type == "windows") {
[10:24:17.228]                 old_names <- names(...future.oldEnvVars)
[10:24:17.228]                 envs <- base::Sys.getenv()
[10:24:17.228]                 names <- names(envs)
[10:24:17.228]                 common <- intersect(names, old_names)
[10:24:17.228]                 added <- setdiff(names, old_names)
[10:24:17.228]                 removed <- setdiff(old_names, names)
[10:24:17.228]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.228]                   envs[common]]
[10:24:17.228]                 NAMES <- toupper(changed)
[10:24:17.228]                 args <- list()
[10:24:17.228]                 for (kk in seq_along(NAMES)) {
[10:24:17.228]                   name <- changed[[kk]]
[10:24:17.228]                   NAME <- NAMES[[kk]]
[10:24:17.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.228]                     next
[10:24:17.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.228]                 }
[10:24:17.228]                 NAMES <- toupper(added)
[10:24:17.228]                 for (kk in seq_along(NAMES)) {
[10:24:17.228]                   name <- added[[kk]]
[10:24:17.228]                   NAME <- NAMES[[kk]]
[10:24:17.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.228]                     next
[10:24:17.228]                   args[[name]] <- ""
[10:24:17.228]                 }
[10:24:17.228]                 NAMES <- toupper(removed)
[10:24:17.228]                 for (kk in seq_along(NAMES)) {
[10:24:17.228]                   name <- removed[[kk]]
[10:24:17.228]                   NAME <- NAMES[[kk]]
[10:24:17.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.228]                     next
[10:24:17.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.228]                 }
[10:24:17.228]                 if (length(args) > 0) 
[10:24:17.228]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.228]             }
[10:24:17.228]             else {
[10:24:17.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.228]             }
[10:24:17.228]             {
[10:24:17.228]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.228]                   0L) {
[10:24:17.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.228]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.228]                   base::options(opts)
[10:24:17.228]                 }
[10:24:17.228]                 {
[10:24:17.228]                   {
[10:24:17.228]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.228]                     NULL
[10:24:17.228]                   }
[10:24:17.228]                   options(future.plan = NULL)
[10:24:17.228]                   if (is.na(NA_character_)) 
[10:24:17.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.228]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.228]                     envir = parent.frame()) 
[10:24:17.228]                   {
[10:24:17.228]                     default_workers <- missing(workers)
[10:24:17.228]                     if (is.function(workers)) 
[10:24:17.228]                       workers <- workers()
[10:24:17.228]                     workers <- structure(as.integer(workers), 
[10:24:17.228]                       class = class(workers))
[10:24:17.228]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.228]                       1L)
[10:24:17.228]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.228]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.228]                       if (default_workers) 
[10:24:17.228]                         supportsMulticore(warn = TRUE)
[10:24:17.228]                       return(sequential(..., envir = envir))
[10:24:17.228]                     }
[10:24:17.228]                     oopts <- options(mc.cores = workers)
[10:24:17.228]                     on.exit(options(oopts))
[10:24:17.228]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.228]                       envir = envir)
[10:24:17.228]                     if (!future$lazy) 
[10:24:17.228]                       future <- run(future)
[10:24:17.228]                     invisible(future)
[10:24:17.228]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.228]                 }
[10:24:17.228]             }
[10:24:17.228]         }
[10:24:17.228]     })
[10:24:17.228]     if (TRUE) {
[10:24:17.228]         base::sink(type = "output", split = FALSE)
[10:24:17.228]         if (TRUE) {
[10:24:17.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.228]         }
[10:24:17.228]         else {
[10:24:17.228]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.228]         }
[10:24:17.228]         base::close(...future.stdout)
[10:24:17.228]         ...future.stdout <- NULL
[10:24:17.228]     }
[10:24:17.228]     ...future.result$conditions <- ...future.conditions
[10:24:17.228]     ...future.result$finished <- base::Sys.time()
[10:24:17.228]     ...future.result
[10:24:17.228] }
[10:24:17.230] assign_globals() ...
[10:24:17.231] List of 11
[10:24:17.231]  $ ...future.FUN            :function (x, ...)  
[10:24:17.231]  $ x_FUN                    :function (x)  
[10:24:17.231]  $ times                    : int 0
[10:24:17.231]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.231]  $ stop_if_not              :function (...)  
[10:24:17.231]  $ dim                      : NULL
[10:24:17.231]  $ valid_types              : chr [1:2] "logical" "integer"
[10:24:17.231]  $ future.call.arguments    : list()
[10:24:17.231]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.231]  $ ...future.elements_ii    :List of 5
[10:24:17.231]   ..$ : int 1
[10:24:17.231]   ..$ : int 2
[10:24:17.231]   ..$ : int 3
[10:24:17.231]   ..$ : int 4
[10:24:17.231]   ..$ : int 5
[10:24:17.231]  $ ...future.seeds_ii       : NULL
[10:24:17.231]  $ ...future.globals.maxSize: NULL
[10:24:17.231]  - attr(*, "where")=List of 11
[10:24:17.231]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.231]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.231]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.231]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.231]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.231]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.231]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.231]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.231]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.231]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.231]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.231]  - attr(*, "resolved")= logi FALSE
[10:24:17.231]  - attr(*, "total_size")= num 95400
[10:24:17.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.231]  - attr(*, "already-done")= logi TRUE
[10:24:17.239] - copied ‘...future.FUN’ to environment
[10:24:17.239] - reassign environment for ‘x_FUN’
[10:24:17.239] - copied ‘x_FUN’ to environment
[10:24:17.239] - copied ‘times’ to environment
[10:24:17.239] - copied ‘stopf’ to environment
[10:24:17.239] - copied ‘stop_if_not’ to environment
[10:24:17.239] - copied ‘dim’ to environment
[10:24:17.239] - copied ‘valid_types’ to environment
[10:24:17.240] - copied ‘future.call.arguments’ to environment
[10:24:17.240] - copied ‘...future.elements_ii’ to environment
[10:24:17.240] - copied ‘...future.seeds_ii’ to environment
[10:24:17.240] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.240] assign_globals() ... done
[10:24:17.240] requestCore(): workers = 2
[10:24:17.242] MulticoreFuture started
[10:24:17.243] - Launch lazy future ... done
[10:24:17.243] run() for ‘MulticoreFuture’ ... done
[10:24:17.243] Created future:
[10:24:17.244] plan(): Setting new future strategy stack:
[10:24:17.244] List of future strategies:
[10:24:17.244] 1. sequential:
[10:24:17.244]    - args: function (..., envir = parent.frame())
[10:24:17.244]    - tweaked: FALSE
[10:24:17.244]    - call: NULL
[10:24:17.245] plan(): nbrOfWorkers() = 1
[10:24:17.247] plan(): Setting new future strategy stack:
[10:24:17.247] List of future strategies:
[10:24:17.247] 1. multicore:
[10:24:17.247]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.247]    - tweaked: FALSE
[10:24:17.247]    - call: plan(strategy)
[10:24:17.252] plan(): nbrOfWorkers() = 2
[10:24:17.243] MulticoreFuture:
[10:24:17.243] Label: ‘future_vapply-1’
[10:24:17.243] Expression:
[10:24:17.243] {
[10:24:17.243]     do.call(function(...) {
[10:24:17.243]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.243]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.243]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.243]             on.exit(options(oopts), add = TRUE)
[10:24:17.243]         }
[10:24:17.243]         {
[10:24:17.243]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.243]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.243]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.243]             })
[10:24:17.243]         }
[10:24:17.243]     }, args = future.call.arguments)
[10:24:17.243] }
[10:24:17.243] Lazy evaluation: FALSE
[10:24:17.243] Asynchronous evaluation: TRUE
[10:24:17.243] Local evaluation: TRUE
[10:24:17.243] Environment: R_GlobalEnv
[10:24:17.243] Capture standard output: TRUE
[10:24:17.243] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.243] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.243] Packages: 1 packages (‘future.apply’)
[10:24:17.243] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.243] Resolved: TRUE
[10:24:17.243] Value: <not collected>
[10:24:17.243] Conditions captured: <none>
[10:24:17.243] Early signaling: FALSE
[10:24:17.243] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.243] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.253] Chunk #1 of 2 ... DONE
[10:24:17.253] Chunk #2 of 2 ...
[10:24:17.253]  - Finding globals in 'X' for chunk #2 ...
[10:24:17.254] getGlobalsAndPackages() ...
[10:24:17.254] Searching for globals...
[10:24:17.254] 
[10:24:17.254] Searching for globals ... DONE
[10:24:17.254] - globals: [0] <none>
[10:24:17.255] getGlobalsAndPackages() ... DONE
[10:24:17.255]    + additional globals found: [n=0] 
[10:24:17.255]    + additional namespaces needed: [n=0] 
[10:24:17.255]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:17.255]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.255]  - seeds: <none>
[10:24:17.255]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.256] getGlobalsAndPackages() ...
[10:24:17.256] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.256] Resolving globals: FALSE
[10:24:17.256] Tweak future expression to call with '...' arguments ...
[10:24:17.256] {
[10:24:17.256]     do.call(function(...) {
[10:24:17.256]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.256]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.256]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.256]             on.exit(options(oopts), add = TRUE)
[10:24:17.256]         }
[10:24:17.256]         {
[10:24:17.256]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.256]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.256]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.256]             })
[10:24:17.256]         }
[10:24:17.256]     }, args = future.call.arguments)
[10:24:17.256] }
[10:24:17.257] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.258] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.258] - packages: [1] ‘future.apply’
[10:24:17.261] getGlobalsAndPackages() ... DONE
[10:24:17.262] run() for ‘Future’ ...
[10:24:17.262] - state: ‘created’
[10:24:17.263] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.269] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.269] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.270]   - Field: ‘label’
[10:24:17.270]   - Field: ‘local’
[10:24:17.270]   - Field: ‘owner’
[10:24:17.270]   - Field: ‘envir’
[10:24:17.271]   - Field: ‘workers’
[10:24:17.271]   - Field: ‘packages’
[10:24:17.271]   - Field: ‘gc’
[10:24:17.271]   - Field: ‘job’
[10:24:17.272]   - Field: ‘conditions’
[10:24:17.272]   - Field: ‘expr’
[10:24:17.272]   - Field: ‘uuid’
[10:24:17.272]   - Field: ‘seed’
[10:24:17.272]   - Field: ‘version’
[10:24:17.273]   - Field: ‘result’
[10:24:17.273]   - Field: ‘asynchronous’
[10:24:17.273]   - Field: ‘calls’
[10:24:17.273]   - Field: ‘globals’
[10:24:17.273]   - Field: ‘stdout’
[10:24:17.273]   - Field: ‘earlySignal’
[10:24:17.274]   - Field: ‘lazy’
[10:24:17.274]   - Field: ‘state’
[10:24:17.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.274] - Launch lazy future ...
[10:24:17.274] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.275] Packages needed by future strategies (n = 0): <none>
[10:24:17.276] {
[10:24:17.276]     {
[10:24:17.276]         {
[10:24:17.276]             ...future.startTime <- base::Sys.time()
[10:24:17.276]             {
[10:24:17.276]                 {
[10:24:17.276]                   {
[10:24:17.276]                     {
[10:24:17.276]                       {
[10:24:17.276]                         base::local({
[10:24:17.276]                           has_future <- base::requireNamespace("future", 
[10:24:17.276]                             quietly = TRUE)
[10:24:17.276]                           if (has_future) {
[10:24:17.276]                             ns <- base::getNamespace("future")
[10:24:17.276]                             version <- ns[[".package"]][["version"]]
[10:24:17.276]                             if (is.null(version)) 
[10:24:17.276]                               version <- utils::packageVersion("future")
[10:24:17.276]                           }
[10:24:17.276]                           else {
[10:24:17.276]                             version <- NULL
[10:24:17.276]                           }
[10:24:17.276]                           if (!has_future || version < "1.8.0") {
[10:24:17.276]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.276]                               "", base::R.version$version.string), 
[10:24:17.276]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.276]                                 base::R.version$platform, 8 * 
[10:24:17.276]                                   base::.Machine$sizeof.pointer), 
[10:24:17.276]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.276]                                 "release", "version")], collapse = " "), 
[10:24:17.276]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.276]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.276]                               info)
[10:24:17.276]                             info <- base::paste(info, collapse = "; ")
[10:24:17.276]                             if (!has_future) {
[10:24:17.276]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.276]                                 info)
[10:24:17.276]                             }
[10:24:17.276]                             else {
[10:24:17.276]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.276]                                 info, version)
[10:24:17.276]                             }
[10:24:17.276]                             base::stop(msg)
[10:24:17.276]                           }
[10:24:17.276]                         })
[10:24:17.276]                       }
[10:24:17.276]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.276]                       base::options(mc.cores = 1L)
[10:24:17.276]                     }
[10:24:17.276]                     base::local({
[10:24:17.276]                       for (pkg in "future.apply") {
[10:24:17.276]                         base::loadNamespace(pkg)
[10:24:17.276]                         base::library(pkg, character.only = TRUE)
[10:24:17.276]                       }
[10:24:17.276]                     })
[10:24:17.276]                   }
[10:24:17.276]                   options(future.plan = NULL)
[10:24:17.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.276]                 }
[10:24:17.276]                 ...future.workdir <- getwd()
[10:24:17.276]             }
[10:24:17.276]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.276]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.276]         }
[10:24:17.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.276]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.276]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.276]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.276]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.276]             base::names(...future.oldOptions))
[10:24:17.276]     }
[10:24:17.276]     if (FALSE) {
[10:24:17.276]     }
[10:24:17.276]     else {
[10:24:17.276]         if (TRUE) {
[10:24:17.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.276]                 open = "w")
[10:24:17.276]         }
[10:24:17.276]         else {
[10:24:17.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.276]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.276]         }
[10:24:17.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.276]             base::sink(type = "output", split = FALSE)
[10:24:17.276]             base::close(...future.stdout)
[10:24:17.276]         }, add = TRUE)
[10:24:17.276]     }
[10:24:17.276]     ...future.frame <- base::sys.nframe()
[10:24:17.276]     ...future.conditions <- base::list()
[10:24:17.276]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.276]     if (FALSE) {
[10:24:17.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.276]     }
[10:24:17.276]     ...future.result <- base::tryCatch({
[10:24:17.276]         base::withCallingHandlers({
[10:24:17.276]             ...future.value <- base::withVisible(base::local({
[10:24:17.276]                 withCallingHandlers({
[10:24:17.276]                   {
[10:24:17.276]                     do.call(function(...) {
[10:24:17.276]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.276]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.276]                         ...future.globals.maxSize)) {
[10:24:17.276]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.276]                         on.exit(options(oopts), add = TRUE)
[10:24:17.276]                       }
[10:24:17.276]                       {
[10:24:17.276]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.276]                           FUN = function(jj) {
[10:24:17.276]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.276]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.276]                           })
[10:24:17.276]                       }
[10:24:17.276]                     }, args = future.call.arguments)
[10:24:17.276]                   }
[10:24:17.276]                 }, immediateCondition = function(cond) {
[10:24:17.276]                   save_rds <- function (object, pathname, ...) 
[10:24:17.276]                   {
[10:24:17.276]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.276]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.276]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.276]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.276]                         fi_tmp[["mtime"]])
[10:24:17.276]                     }
[10:24:17.276]                     tryCatch({
[10:24:17.276]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.276]                     }, error = function(ex) {
[10:24:17.276]                       msg <- conditionMessage(ex)
[10:24:17.276]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.276]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.276]                         fi_tmp[["mtime"]], msg)
[10:24:17.276]                       ex$message <- msg
[10:24:17.276]                       stop(ex)
[10:24:17.276]                     })
[10:24:17.276]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.276]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.276]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.276]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.276]                       fi <- file.info(pathname)
[10:24:17.276]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.276]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.276]                         fi[["size"]], fi[["mtime"]])
[10:24:17.276]                       stop(msg)
[10:24:17.276]                     }
[10:24:17.276]                     invisible(pathname)
[10:24:17.276]                   }
[10:24:17.276]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.276]                     rootPath = tempdir()) 
[10:24:17.276]                   {
[10:24:17.276]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.276]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.276]                       tmpdir = path, fileext = ".rds")
[10:24:17.276]                     save_rds(obj, file)
[10:24:17.276]                   }
[10:24:17.276]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.276]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.276]                   {
[10:24:17.276]                     inherits <- base::inherits
[10:24:17.276]                     invokeRestart <- base::invokeRestart
[10:24:17.276]                     is.null <- base::is.null
[10:24:17.276]                     muffled <- FALSE
[10:24:17.276]                     if (inherits(cond, "message")) {
[10:24:17.276]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.276]                       if (muffled) 
[10:24:17.276]                         invokeRestart("muffleMessage")
[10:24:17.276]                     }
[10:24:17.276]                     else if (inherits(cond, "warning")) {
[10:24:17.276]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.276]                       if (muffled) 
[10:24:17.276]                         invokeRestart("muffleWarning")
[10:24:17.276]                     }
[10:24:17.276]                     else if (inherits(cond, "condition")) {
[10:24:17.276]                       if (!is.null(pattern)) {
[10:24:17.276]                         computeRestarts <- base::computeRestarts
[10:24:17.276]                         grepl <- base::grepl
[10:24:17.276]                         restarts <- computeRestarts(cond)
[10:24:17.276]                         for (restart in restarts) {
[10:24:17.276]                           name <- restart$name
[10:24:17.276]                           if (is.null(name)) 
[10:24:17.276]                             next
[10:24:17.276]                           if (!grepl(pattern, name)) 
[10:24:17.276]                             next
[10:24:17.276]                           invokeRestart(restart)
[10:24:17.276]                           muffled <- TRUE
[10:24:17.276]                           break
[10:24:17.276]                         }
[10:24:17.276]                       }
[10:24:17.276]                     }
[10:24:17.276]                     invisible(muffled)
[10:24:17.276]                   }
[10:24:17.276]                   muffleCondition(cond)
[10:24:17.276]                 })
[10:24:17.276]             }))
[10:24:17.276]             future::FutureResult(value = ...future.value$value, 
[10:24:17.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.276]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.276]                     ...future.globalenv.names))
[10:24:17.276]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.276]         }, condition = base::local({
[10:24:17.276]             c <- base::c
[10:24:17.276]             inherits <- base::inherits
[10:24:17.276]             invokeRestart <- base::invokeRestart
[10:24:17.276]             length <- base::length
[10:24:17.276]             list <- base::list
[10:24:17.276]             seq.int <- base::seq.int
[10:24:17.276]             signalCondition <- base::signalCondition
[10:24:17.276]             sys.calls <- base::sys.calls
[10:24:17.276]             `[[` <- base::`[[`
[10:24:17.276]             `+` <- base::`+`
[10:24:17.276]             `<<-` <- base::`<<-`
[10:24:17.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.276]                   3L)]
[10:24:17.276]             }
[10:24:17.276]             function(cond) {
[10:24:17.276]                 is_error <- inherits(cond, "error")
[10:24:17.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.276]                   NULL)
[10:24:17.276]                 if (is_error) {
[10:24:17.276]                   sessionInformation <- function() {
[10:24:17.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.276]                       search = base::search(), system = base::Sys.info())
[10:24:17.276]                   }
[10:24:17.276]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.276]                     cond$call), session = sessionInformation(), 
[10:24:17.276]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.276]                   signalCondition(cond)
[10:24:17.276]                 }
[10:24:17.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.276]                 "immediateCondition"))) {
[10:24:17.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.276]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.276]                   if (TRUE && !signal) {
[10:24:17.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.276]                     {
[10:24:17.276]                       inherits <- base::inherits
[10:24:17.276]                       invokeRestart <- base::invokeRestart
[10:24:17.276]                       is.null <- base::is.null
[10:24:17.276]                       muffled <- FALSE
[10:24:17.276]                       if (inherits(cond, "message")) {
[10:24:17.276]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.276]                         if (muffled) 
[10:24:17.276]                           invokeRestart("muffleMessage")
[10:24:17.276]                       }
[10:24:17.276]                       else if (inherits(cond, "warning")) {
[10:24:17.276]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.276]                         if (muffled) 
[10:24:17.276]                           invokeRestart("muffleWarning")
[10:24:17.276]                       }
[10:24:17.276]                       else if (inherits(cond, "condition")) {
[10:24:17.276]                         if (!is.null(pattern)) {
[10:24:17.276]                           computeRestarts <- base::computeRestarts
[10:24:17.276]                           grepl <- base::grepl
[10:24:17.276]                           restarts <- computeRestarts(cond)
[10:24:17.276]                           for (restart in restarts) {
[10:24:17.276]                             name <- restart$name
[10:24:17.276]                             if (is.null(name)) 
[10:24:17.276]                               next
[10:24:17.276]                             if (!grepl(pattern, name)) 
[10:24:17.276]                               next
[10:24:17.276]                             invokeRestart(restart)
[10:24:17.276]                             muffled <- TRUE
[10:24:17.276]                             break
[10:24:17.276]                           }
[10:24:17.276]                         }
[10:24:17.276]                       }
[10:24:17.276]                       invisible(muffled)
[10:24:17.276]                     }
[10:24:17.276]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.276]                   }
[10:24:17.276]                 }
[10:24:17.276]                 else {
[10:24:17.276]                   if (TRUE) {
[10:24:17.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.276]                     {
[10:24:17.276]                       inherits <- base::inherits
[10:24:17.276]                       invokeRestart <- base::invokeRestart
[10:24:17.276]                       is.null <- base::is.null
[10:24:17.276]                       muffled <- FALSE
[10:24:17.276]                       if (inherits(cond, "message")) {
[10:24:17.276]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.276]                         if (muffled) 
[10:24:17.276]                           invokeRestart("muffleMessage")
[10:24:17.276]                       }
[10:24:17.276]                       else if (inherits(cond, "warning")) {
[10:24:17.276]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.276]                         if (muffled) 
[10:24:17.276]                           invokeRestart("muffleWarning")
[10:24:17.276]                       }
[10:24:17.276]                       else if (inherits(cond, "condition")) {
[10:24:17.276]                         if (!is.null(pattern)) {
[10:24:17.276]                           computeRestarts <- base::computeRestarts
[10:24:17.276]                           grepl <- base::grepl
[10:24:17.276]                           restarts <- computeRestarts(cond)
[10:24:17.276]                           for (restart in restarts) {
[10:24:17.276]                             name <- restart$name
[10:24:17.276]                             if (is.null(name)) 
[10:24:17.276]                               next
[10:24:17.276]                             if (!grepl(pattern, name)) 
[10:24:17.276]                               next
[10:24:17.276]                             invokeRestart(restart)
[10:24:17.276]                             muffled <- TRUE
[10:24:17.276]                             break
[10:24:17.276]                           }
[10:24:17.276]                         }
[10:24:17.276]                       }
[10:24:17.276]                       invisible(muffled)
[10:24:17.276]                     }
[10:24:17.276]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.276]                   }
[10:24:17.276]                 }
[10:24:17.276]             }
[10:24:17.276]         }))
[10:24:17.276]     }, error = function(ex) {
[10:24:17.276]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.276]                 ...future.rng), started = ...future.startTime, 
[10:24:17.276]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.276]             version = "1.8"), class = "FutureResult")
[10:24:17.276]     }, finally = {
[10:24:17.276]         if (!identical(...future.workdir, getwd())) 
[10:24:17.276]             setwd(...future.workdir)
[10:24:17.276]         {
[10:24:17.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.276]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.276]             }
[10:24:17.276]             base::options(...future.oldOptions)
[10:24:17.276]             if (.Platform$OS.type == "windows") {
[10:24:17.276]                 old_names <- names(...future.oldEnvVars)
[10:24:17.276]                 envs <- base::Sys.getenv()
[10:24:17.276]                 names <- names(envs)
[10:24:17.276]                 common <- intersect(names, old_names)
[10:24:17.276]                 added <- setdiff(names, old_names)
[10:24:17.276]                 removed <- setdiff(old_names, names)
[10:24:17.276]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.276]                   envs[common]]
[10:24:17.276]                 NAMES <- toupper(changed)
[10:24:17.276]                 args <- list()
[10:24:17.276]                 for (kk in seq_along(NAMES)) {
[10:24:17.276]                   name <- changed[[kk]]
[10:24:17.276]                   NAME <- NAMES[[kk]]
[10:24:17.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.276]                     next
[10:24:17.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.276]                 }
[10:24:17.276]                 NAMES <- toupper(added)
[10:24:17.276]                 for (kk in seq_along(NAMES)) {
[10:24:17.276]                   name <- added[[kk]]
[10:24:17.276]                   NAME <- NAMES[[kk]]
[10:24:17.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.276]                     next
[10:24:17.276]                   args[[name]] <- ""
[10:24:17.276]                 }
[10:24:17.276]                 NAMES <- toupper(removed)
[10:24:17.276]                 for (kk in seq_along(NAMES)) {
[10:24:17.276]                   name <- removed[[kk]]
[10:24:17.276]                   NAME <- NAMES[[kk]]
[10:24:17.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.276]                     next
[10:24:17.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.276]                 }
[10:24:17.276]                 if (length(args) > 0) 
[10:24:17.276]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.276]             }
[10:24:17.276]             else {
[10:24:17.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.276]             }
[10:24:17.276]             {
[10:24:17.276]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.276]                   0L) {
[10:24:17.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.276]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.276]                   base::options(opts)
[10:24:17.276]                 }
[10:24:17.276]                 {
[10:24:17.276]                   {
[10:24:17.276]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.276]                     NULL
[10:24:17.276]                   }
[10:24:17.276]                   options(future.plan = NULL)
[10:24:17.276]                   if (is.na(NA_character_)) 
[10:24:17.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.276]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.276]                     envir = parent.frame()) 
[10:24:17.276]                   {
[10:24:17.276]                     default_workers <- missing(workers)
[10:24:17.276]                     if (is.function(workers)) 
[10:24:17.276]                       workers <- workers()
[10:24:17.276]                     workers <- structure(as.integer(workers), 
[10:24:17.276]                       class = class(workers))
[10:24:17.276]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.276]                       1L)
[10:24:17.276]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.276]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.276]                       if (default_workers) 
[10:24:17.276]                         supportsMulticore(warn = TRUE)
[10:24:17.276]                       return(sequential(..., envir = envir))
[10:24:17.276]                     }
[10:24:17.276]                     oopts <- options(mc.cores = workers)
[10:24:17.276]                     on.exit(options(oopts))
[10:24:17.276]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.276]                       envir = envir)
[10:24:17.276]                     if (!future$lazy) 
[10:24:17.276]                       future <- run(future)
[10:24:17.276]                     invisible(future)
[10:24:17.276]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.276]                 }
[10:24:17.276]             }
[10:24:17.276]         }
[10:24:17.276]     })
[10:24:17.276]     if (TRUE) {
[10:24:17.276]         base::sink(type = "output", split = FALSE)
[10:24:17.276]         if (TRUE) {
[10:24:17.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.276]         }
[10:24:17.276]         else {
[10:24:17.276]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.276]         }
[10:24:17.276]         base::close(...future.stdout)
[10:24:17.276]         ...future.stdout <- NULL
[10:24:17.276]     }
[10:24:17.276]     ...future.result$conditions <- ...future.conditions
[10:24:17.276]     ...future.result$finished <- base::Sys.time()
[10:24:17.276]     ...future.result
[10:24:17.276] }
[10:24:17.278] assign_globals() ...
[10:24:17.279] List of 11
[10:24:17.279]  $ ...future.FUN            :function (x, ...)  
[10:24:17.279]  $ x_FUN                    :function (x)  
[10:24:17.279]  $ times                    : int 0
[10:24:17.279]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.279]  $ stop_if_not              :function (...)  
[10:24:17.279]  $ dim                      : NULL
[10:24:17.279]  $ valid_types              : chr [1:2] "logical" "integer"
[10:24:17.279]  $ future.call.arguments    : list()
[10:24:17.279]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.279]  $ ...future.elements_ii    :List of 5
[10:24:17.279]   ..$ : int 6
[10:24:17.279]   ..$ : int 7
[10:24:17.279]   ..$ : int 8
[10:24:17.279]   ..$ : int 9
[10:24:17.279]   ..$ : int 10
[10:24:17.279]  $ ...future.seeds_ii       : NULL
[10:24:17.279]  $ ...future.globals.maxSize: NULL
[10:24:17.279]  - attr(*, "where")=List of 11
[10:24:17.279]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.279]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.279]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.279]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.279]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.279]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.279]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.279]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.279]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.279]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.279]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.279]  - attr(*, "resolved")= logi FALSE
[10:24:17.279]  - attr(*, "total_size")= num 95400
[10:24:17.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.279]  - attr(*, "already-done")= logi TRUE
[10:24:17.290] - copied ‘...future.FUN’ to environment
[10:24:17.290] - reassign environment for ‘x_FUN’
[10:24:17.290] - copied ‘x_FUN’ to environment
[10:24:17.290] - copied ‘times’ to environment
[10:24:17.290] - copied ‘stopf’ to environment
[10:24:17.290] - copied ‘stop_if_not’ to environment
[10:24:17.290] - copied ‘dim’ to environment
[10:24:17.290] - copied ‘valid_types’ to environment
[10:24:17.291] - copied ‘future.call.arguments’ to environment
[10:24:17.291] - copied ‘...future.elements_ii’ to environment
[10:24:17.291] - copied ‘...future.seeds_ii’ to environment
[10:24:17.291] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.291] assign_globals() ... done
[10:24:17.291] requestCore(): workers = 2
[10:24:17.293] MulticoreFuture started
[10:24:17.294] - Launch lazy future ... done
[10:24:17.294] run() for ‘MulticoreFuture’ ... done
[10:24:17.294] Created future:
[10:24:17.295] plan(): Setting new future strategy stack:
[10:24:17.295] List of future strategies:
[10:24:17.295] 1. sequential:
[10:24:17.295]    - args: function (..., envir = parent.frame())
[10:24:17.295]    - tweaked: FALSE
[10:24:17.295]    - call: NULL
[10:24:17.296] plan(): nbrOfWorkers() = 1
[10:24:17.298] plan(): Setting new future strategy stack:
[10:24:17.298] List of future strategies:
[10:24:17.298] 1. multicore:
[10:24:17.298]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.298]    - tweaked: FALSE
[10:24:17.298]    - call: plan(strategy)
[10:24:17.294] MulticoreFuture:
[10:24:17.294] Label: ‘future_vapply-2’
[10:24:17.294] Expression:
[10:24:17.294] {
[10:24:17.294]     do.call(function(...) {
[10:24:17.294]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.294]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.294]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.294]             on.exit(options(oopts), add = TRUE)
[10:24:17.294]         }
[10:24:17.294]         {
[10:24:17.294]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.294]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.294]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.294]             })
[10:24:17.294]         }
[10:24:17.294]     }, args = future.call.arguments)
[10:24:17.294] }
[10:24:17.294] Lazy evaluation: FALSE
[10:24:17.294] Asynchronous evaluation: TRUE
[10:24:17.294] Local evaluation: TRUE
[10:24:17.294] Environment: R_GlobalEnv
[10:24:17.294] Capture standard output: TRUE
[10:24:17.294] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.294] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.294] Packages: 1 packages (‘future.apply’)
[10:24:17.294] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.294] Resolved: FALSE
[10:24:17.294] Value: <not collected>
[10:24:17.294] Conditions captured: <none>
[10:24:17.294] Early signaling: FALSE
[10:24:17.294] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.294] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.307] Chunk #2 of 2 ... DONE
[10:24:17.308] Launching 2 futures (chunks) ... DONE
[10:24:17.307] plan(): nbrOfWorkers() = 2
[10:24:17.308] Resolving 2 futures (chunks) ...
[10:24:17.308] resolve() on list ...
[10:24:17.308]  recursive: 0
[10:24:17.308]  length: 2
[10:24:17.308] 
[10:24:17.309] Future #1
[10:24:17.311] result() for MulticoreFuture ...
[10:24:17.312] result() for MulticoreFuture ...
[10:24:17.312] result() for MulticoreFuture ... done
[10:24:17.313] result() for MulticoreFuture ... done
[10:24:17.313] result() for MulticoreFuture ...
[10:24:17.314] result() for MulticoreFuture ... done
[10:24:17.314] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:17.315] - nx: 2
[10:24:17.315] - relay: TRUE
[10:24:17.315] - stdout: TRUE
[10:24:17.316] - signal: TRUE
[10:24:17.316] - resignal: FALSE
[10:24:17.316] - force: TRUE
[10:24:17.317] - relayed: [n=2] FALSE, FALSE
[10:24:17.317] - queued futures: [n=2] FALSE, FALSE
[10:24:17.317]  - until=1
[10:24:17.318]  - relaying element #1
[10:24:17.318] result() for MulticoreFuture ...
[10:24:17.318] result() for MulticoreFuture ... done
[10:24:17.318] result() for MulticoreFuture ...
[10:24:17.319] result() for MulticoreFuture ... done
[10:24:17.319] result() for MulticoreFuture ...
[10:24:17.319] result() for MulticoreFuture ... done
[10:24:17.319] result() for MulticoreFuture ...
[10:24:17.320] result() for MulticoreFuture ... done
[10:24:17.320] - relayed: [n=2] TRUE, FALSE
[10:24:17.320] - queued futures: [n=2] TRUE, FALSE
[10:24:17.320] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:17.320]  length: 1 (resolved future 1)
[10:24:17.321] Future #2
[10:24:17.321] result() for MulticoreFuture ...
[10:24:17.322] result() for MulticoreFuture ...
[10:24:17.322] result() for MulticoreFuture ... done
[10:24:17.322] result() for MulticoreFuture ... done
[10:24:17.322] result() for MulticoreFuture ...
[10:24:17.322] result() for MulticoreFuture ... done
[10:24:17.323] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:17.323] - nx: 2
[10:24:17.323] - relay: TRUE
[10:24:17.323] - stdout: TRUE
[10:24:17.323] - signal: TRUE
[10:24:17.323] - resignal: FALSE
[10:24:17.323] - force: TRUE
[10:24:17.323] - relayed: [n=2] TRUE, FALSE
[10:24:17.324] - queued futures: [n=2] TRUE, FALSE
[10:24:17.324]  - until=2
[10:24:17.324]  - relaying element #2
[10:24:17.324] result() for MulticoreFuture ...
[10:24:17.324] result() for MulticoreFuture ... done
[10:24:17.324] result() for MulticoreFuture ...
[10:24:17.324] result() for MulticoreFuture ... done
[10:24:17.325] result() for MulticoreFuture ...
[10:24:17.325] result() for MulticoreFuture ... done
[10:24:17.325] result() for MulticoreFuture ...
[10:24:17.325] result() for MulticoreFuture ... done
[10:24:17.325] - relayed: [n=2] TRUE, TRUE
[10:24:17.325] - queued futures: [n=2] TRUE, TRUE
[10:24:17.325] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:17.325]  length: 0 (resolved future 2)
[10:24:17.326] Relaying remaining futures
[10:24:17.326] signalConditionsASAP(NULL, pos=0) ...
[10:24:17.326] - nx: 2
[10:24:17.326] - relay: TRUE
[10:24:17.326] - stdout: TRUE
[10:24:17.326] - signal: TRUE
[10:24:17.326] - resignal: FALSE
[10:24:17.326] - force: TRUE
[10:24:17.326] - relayed: [n=2] TRUE, TRUE
[10:24:17.326] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:17.327] - relayed: [n=2] TRUE, TRUE
[10:24:17.327] - queued futures: [n=2] TRUE, TRUE
[10:24:17.327] signalConditionsASAP(NULL, pos=0) ... done
[10:24:17.327] resolve() on list ... DONE
[10:24:17.327] result() for MulticoreFuture ...
[10:24:17.327] result() for MulticoreFuture ... done
[10:24:17.327] result() for MulticoreFuture ...
[10:24:17.327] result() for MulticoreFuture ... done
[10:24:17.327] result() for MulticoreFuture ...
[10:24:17.328] result() for MulticoreFuture ... done
[10:24:17.328] result() for MulticoreFuture ...
[10:24:17.328] result() for MulticoreFuture ... done
[10:24:17.328]  - Number of value chunks collected: 2
[10:24:17.328] Resolving 2 futures (chunks) ... DONE
[10:24:17.328] Reducing values from 2 chunks ...
[10:24:17.328]  - Number of values collected after concatenation: 10
[10:24:17.328]  - Number of values expected: 10
[10:24:17.328] Reducing values from 2 chunks ... DONE
[10:24:17.329] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[10:24:17.330] future_lapply() ...
[10:24:17.335] Number of chunks: 2
[10:24:17.336] getGlobalsAndPackagesXApply() ...
[10:24:17.336]  - future.globals: TRUE
[10:24:17.336] getGlobalsAndPackages() ...
[10:24:17.336] Searching for globals...
[10:24:17.339] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:17.339] Searching for globals ... DONE
[10:24:17.339] Resolving globals: FALSE
[10:24:17.340] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[10:24:17.341] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:17.341] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.341] - packages: [1] ‘future.apply’
[10:24:17.341] getGlobalsAndPackages() ... DONE
[10:24:17.341]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.341]  - needed namespaces: [n=1] ‘future.apply’
[10:24:17.341] Finding globals ... DONE
[10:24:17.342]  - use_args: TRUE
[10:24:17.343]  - Getting '...' globals ...
[10:24:17.343] resolve() on list ...
[10:24:17.344]  recursive: 0
[10:24:17.344]  length: 1
[10:24:17.344]  elements: ‘...’
[10:24:17.344]  length: 0 (resolved future 1)
[10:24:17.344] resolve() on list ... DONE
[10:24:17.344]    - '...' content: [n=0] 
[10:24:17.344] List of 1
[10:24:17.344]  $ ...: list()
[10:24:17.344]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.344]  - attr(*, "where")=List of 1
[10:24:17.344]   ..$ ...:<environment: 0x55b93c4cb810> 
[10:24:17.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.344]  - attr(*, "resolved")= logi TRUE
[10:24:17.344]  - attr(*, "total_size")= num NA
[10:24:17.347]  - Getting '...' globals ... DONE
[10:24:17.347] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:17.347] List of 8
[10:24:17.347]  $ ...future.FUN:function (x, ...)  
[10:24:17.347]  $ x_FUN        :function (x)  
[10:24:17.347]  $ times        : int 1
[10:24:17.347]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.347]  $ stop_if_not  :function (...)  
[10:24:17.347]  $ dim          : NULL
[10:24:17.347]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:17.347]  $ ...          : list()
[10:24:17.347]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.347]  - attr(*, "where")=List of 8
[10:24:17.347]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:17.347]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:17.347]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:17.347]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:17.347]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:17.347]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:17.347]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:17.347]   ..$ ...          :<environment: 0x55b93c4cb810> 
[10:24:17.347]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.347]  - attr(*, "resolved")= logi FALSE
[10:24:17.347]  - attr(*, "total_size")= num 94336
[10:24:17.353] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:17.353] getGlobalsAndPackagesXApply() ... DONE
[10:24:17.353] Number of futures (= number of chunks): 2
[10:24:17.353] Launching 2 futures (chunks) ...
[10:24:17.353] Chunk #1 of 2 ...
[10:24:17.353]  - Finding globals in 'X' for chunk #1 ...
[10:24:17.353] getGlobalsAndPackages() ...
[10:24:17.353] Searching for globals...
[10:24:17.354] 
[10:24:17.354] Searching for globals ... DONE
[10:24:17.354] - globals: [0] <none>
[10:24:17.354] getGlobalsAndPackages() ... DONE
[10:24:17.354]    + additional globals found: [n=0] 
[10:24:17.354]    + additional namespaces needed: [n=0] 
[10:24:17.354]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:17.354]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.354]  - seeds: <none>
[10:24:17.354]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.355] getGlobalsAndPackages() ...
[10:24:17.355] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.355] Resolving globals: FALSE
[10:24:17.355] Tweak future expression to call with '...' arguments ...
[10:24:17.355] {
[10:24:17.355]     do.call(function(...) {
[10:24:17.355]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.355]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.355]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.355]             on.exit(options(oopts), add = TRUE)
[10:24:17.355]         }
[10:24:17.355]         {
[10:24:17.355]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.355]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.355]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.355]             })
[10:24:17.355]         }
[10:24:17.355]     }, args = future.call.arguments)
[10:24:17.355] }
[10:24:17.355] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.356] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.356] - packages: [1] ‘future.apply’
[10:24:17.356] getGlobalsAndPackages() ... DONE
[10:24:17.356] run() for ‘Future’ ...
[10:24:17.356] - state: ‘created’
[10:24:17.357] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.360] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.360] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.360]   - Field: ‘label’
[10:24:17.360]   - Field: ‘local’
[10:24:17.361]   - Field: ‘owner’
[10:24:17.361]   - Field: ‘envir’
[10:24:17.361]   - Field: ‘workers’
[10:24:17.361]   - Field: ‘packages’
[10:24:17.361]   - Field: ‘gc’
[10:24:17.361]   - Field: ‘job’
[10:24:17.361]   - Field: ‘conditions’
[10:24:17.361]   - Field: ‘expr’
[10:24:17.361]   - Field: ‘uuid’
[10:24:17.361]   - Field: ‘seed’
[10:24:17.362]   - Field: ‘version’
[10:24:17.362]   - Field: ‘result’
[10:24:17.362]   - Field: ‘asynchronous’
[10:24:17.362]   - Field: ‘calls’
[10:24:17.362]   - Field: ‘globals’
[10:24:17.362]   - Field: ‘stdout’
[10:24:17.362]   - Field: ‘earlySignal’
[10:24:17.362]   - Field: ‘lazy’
[10:24:17.362]   - Field: ‘state’
[10:24:17.362] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.362] - Launch lazy future ...
[10:24:17.363] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.363] Packages needed by future strategies (n = 0): <none>
[10:24:17.363] {
[10:24:17.363]     {
[10:24:17.363]         {
[10:24:17.363]             ...future.startTime <- base::Sys.time()
[10:24:17.363]             {
[10:24:17.363]                 {
[10:24:17.363]                   {
[10:24:17.363]                     {
[10:24:17.363]                       {
[10:24:17.363]                         base::local({
[10:24:17.363]                           has_future <- base::requireNamespace("future", 
[10:24:17.363]                             quietly = TRUE)
[10:24:17.363]                           if (has_future) {
[10:24:17.363]                             ns <- base::getNamespace("future")
[10:24:17.363]                             version <- ns[[".package"]][["version"]]
[10:24:17.363]                             if (is.null(version)) 
[10:24:17.363]                               version <- utils::packageVersion("future")
[10:24:17.363]                           }
[10:24:17.363]                           else {
[10:24:17.363]                             version <- NULL
[10:24:17.363]                           }
[10:24:17.363]                           if (!has_future || version < "1.8.0") {
[10:24:17.363]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.363]                               "", base::R.version$version.string), 
[10:24:17.363]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.363]                                 base::R.version$platform, 8 * 
[10:24:17.363]                                   base::.Machine$sizeof.pointer), 
[10:24:17.363]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.363]                                 "release", "version")], collapse = " "), 
[10:24:17.363]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.363]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.363]                               info)
[10:24:17.363]                             info <- base::paste(info, collapse = "; ")
[10:24:17.363]                             if (!has_future) {
[10:24:17.363]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.363]                                 info)
[10:24:17.363]                             }
[10:24:17.363]                             else {
[10:24:17.363]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.363]                                 info, version)
[10:24:17.363]                             }
[10:24:17.363]                             base::stop(msg)
[10:24:17.363]                           }
[10:24:17.363]                         })
[10:24:17.363]                       }
[10:24:17.363]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.363]                       base::options(mc.cores = 1L)
[10:24:17.363]                     }
[10:24:17.363]                     base::local({
[10:24:17.363]                       for (pkg in "future.apply") {
[10:24:17.363]                         base::loadNamespace(pkg)
[10:24:17.363]                         base::library(pkg, character.only = TRUE)
[10:24:17.363]                       }
[10:24:17.363]                     })
[10:24:17.363]                   }
[10:24:17.363]                   options(future.plan = NULL)
[10:24:17.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.363]                 }
[10:24:17.363]                 ...future.workdir <- getwd()
[10:24:17.363]             }
[10:24:17.363]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.363]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.363]         }
[10:24:17.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.363]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.363]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.363]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.363]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.363]             base::names(...future.oldOptions))
[10:24:17.363]     }
[10:24:17.363]     if (FALSE) {
[10:24:17.363]     }
[10:24:17.363]     else {
[10:24:17.363]         if (TRUE) {
[10:24:17.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.363]                 open = "w")
[10:24:17.363]         }
[10:24:17.363]         else {
[10:24:17.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.363]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.363]         }
[10:24:17.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.363]             base::sink(type = "output", split = FALSE)
[10:24:17.363]             base::close(...future.stdout)
[10:24:17.363]         }, add = TRUE)
[10:24:17.363]     }
[10:24:17.363]     ...future.frame <- base::sys.nframe()
[10:24:17.363]     ...future.conditions <- base::list()
[10:24:17.363]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.363]     if (FALSE) {
[10:24:17.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.363]     }
[10:24:17.363]     ...future.result <- base::tryCatch({
[10:24:17.363]         base::withCallingHandlers({
[10:24:17.363]             ...future.value <- base::withVisible(base::local({
[10:24:17.363]                 withCallingHandlers({
[10:24:17.363]                   {
[10:24:17.363]                     do.call(function(...) {
[10:24:17.363]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.363]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.363]                         ...future.globals.maxSize)) {
[10:24:17.363]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.363]                         on.exit(options(oopts), add = TRUE)
[10:24:17.363]                       }
[10:24:17.363]                       {
[10:24:17.363]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.363]                           FUN = function(jj) {
[10:24:17.363]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.363]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.363]                           })
[10:24:17.363]                       }
[10:24:17.363]                     }, args = future.call.arguments)
[10:24:17.363]                   }
[10:24:17.363]                 }, immediateCondition = function(cond) {
[10:24:17.363]                   save_rds <- function (object, pathname, ...) 
[10:24:17.363]                   {
[10:24:17.363]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.363]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.363]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.363]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.363]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.363]                         fi_tmp[["mtime"]])
[10:24:17.363]                     }
[10:24:17.363]                     tryCatch({
[10:24:17.363]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.363]                     }, error = function(ex) {
[10:24:17.363]                       msg <- conditionMessage(ex)
[10:24:17.363]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.363]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.363]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.363]                         fi_tmp[["mtime"]], msg)
[10:24:17.363]                       ex$message <- msg
[10:24:17.363]                       stop(ex)
[10:24:17.363]                     })
[10:24:17.363]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.363]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.363]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.363]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.363]                       fi <- file.info(pathname)
[10:24:17.363]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.363]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.363]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.363]                         fi[["size"]], fi[["mtime"]])
[10:24:17.363]                       stop(msg)
[10:24:17.363]                     }
[10:24:17.363]                     invisible(pathname)
[10:24:17.363]                   }
[10:24:17.363]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.363]                     rootPath = tempdir()) 
[10:24:17.363]                   {
[10:24:17.363]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.363]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.363]                       tmpdir = path, fileext = ".rds")
[10:24:17.363]                     save_rds(obj, file)
[10:24:17.363]                   }
[10:24:17.363]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.363]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.363]                   {
[10:24:17.363]                     inherits <- base::inherits
[10:24:17.363]                     invokeRestart <- base::invokeRestart
[10:24:17.363]                     is.null <- base::is.null
[10:24:17.363]                     muffled <- FALSE
[10:24:17.363]                     if (inherits(cond, "message")) {
[10:24:17.363]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.363]                       if (muffled) 
[10:24:17.363]                         invokeRestart("muffleMessage")
[10:24:17.363]                     }
[10:24:17.363]                     else if (inherits(cond, "warning")) {
[10:24:17.363]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.363]                       if (muffled) 
[10:24:17.363]                         invokeRestart("muffleWarning")
[10:24:17.363]                     }
[10:24:17.363]                     else if (inherits(cond, "condition")) {
[10:24:17.363]                       if (!is.null(pattern)) {
[10:24:17.363]                         computeRestarts <- base::computeRestarts
[10:24:17.363]                         grepl <- base::grepl
[10:24:17.363]                         restarts <- computeRestarts(cond)
[10:24:17.363]                         for (restart in restarts) {
[10:24:17.363]                           name <- restart$name
[10:24:17.363]                           if (is.null(name)) 
[10:24:17.363]                             next
[10:24:17.363]                           if (!grepl(pattern, name)) 
[10:24:17.363]                             next
[10:24:17.363]                           invokeRestart(restart)
[10:24:17.363]                           muffled <- TRUE
[10:24:17.363]                           break
[10:24:17.363]                         }
[10:24:17.363]                       }
[10:24:17.363]                     }
[10:24:17.363]                     invisible(muffled)
[10:24:17.363]                   }
[10:24:17.363]                   muffleCondition(cond)
[10:24:17.363]                 })
[10:24:17.363]             }))
[10:24:17.363]             future::FutureResult(value = ...future.value$value, 
[10:24:17.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.363]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.363]                     ...future.globalenv.names))
[10:24:17.363]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.363]         }, condition = base::local({
[10:24:17.363]             c <- base::c
[10:24:17.363]             inherits <- base::inherits
[10:24:17.363]             invokeRestart <- base::invokeRestart
[10:24:17.363]             length <- base::length
[10:24:17.363]             list <- base::list
[10:24:17.363]             seq.int <- base::seq.int
[10:24:17.363]             signalCondition <- base::signalCondition
[10:24:17.363]             sys.calls <- base::sys.calls
[10:24:17.363]             `[[` <- base::`[[`
[10:24:17.363]             `+` <- base::`+`
[10:24:17.363]             `<<-` <- base::`<<-`
[10:24:17.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.363]                   3L)]
[10:24:17.363]             }
[10:24:17.363]             function(cond) {
[10:24:17.363]                 is_error <- inherits(cond, "error")
[10:24:17.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.363]                   NULL)
[10:24:17.363]                 if (is_error) {
[10:24:17.363]                   sessionInformation <- function() {
[10:24:17.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.363]                       search = base::search(), system = base::Sys.info())
[10:24:17.363]                   }
[10:24:17.363]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.363]                     cond$call), session = sessionInformation(), 
[10:24:17.363]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.363]                   signalCondition(cond)
[10:24:17.363]                 }
[10:24:17.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.363]                 "immediateCondition"))) {
[10:24:17.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.363]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.363]                   if (TRUE && !signal) {
[10:24:17.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.363]                     {
[10:24:17.363]                       inherits <- base::inherits
[10:24:17.363]                       invokeRestart <- base::invokeRestart
[10:24:17.363]                       is.null <- base::is.null
[10:24:17.363]                       muffled <- FALSE
[10:24:17.363]                       if (inherits(cond, "message")) {
[10:24:17.363]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.363]                         if (muffled) 
[10:24:17.363]                           invokeRestart("muffleMessage")
[10:24:17.363]                       }
[10:24:17.363]                       else if (inherits(cond, "warning")) {
[10:24:17.363]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.363]                         if (muffled) 
[10:24:17.363]                           invokeRestart("muffleWarning")
[10:24:17.363]                       }
[10:24:17.363]                       else if (inherits(cond, "condition")) {
[10:24:17.363]                         if (!is.null(pattern)) {
[10:24:17.363]                           computeRestarts <- base::computeRestarts
[10:24:17.363]                           grepl <- base::grepl
[10:24:17.363]                           restarts <- computeRestarts(cond)
[10:24:17.363]                           for (restart in restarts) {
[10:24:17.363]                             name <- restart$name
[10:24:17.363]                             if (is.null(name)) 
[10:24:17.363]                               next
[10:24:17.363]                             if (!grepl(pattern, name)) 
[10:24:17.363]                               next
[10:24:17.363]                             invokeRestart(restart)
[10:24:17.363]                             muffled <- TRUE
[10:24:17.363]                             break
[10:24:17.363]                           }
[10:24:17.363]                         }
[10:24:17.363]                       }
[10:24:17.363]                       invisible(muffled)
[10:24:17.363]                     }
[10:24:17.363]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.363]                   }
[10:24:17.363]                 }
[10:24:17.363]                 else {
[10:24:17.363]                   if (TRUE) {
[10:24:17.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.363]                     {
[10:24:17.363]                       inherits <- base::inherits
[10:24:17.363]                       invokeRestart <- base::invokeRestart
[10:24:17.363]                       is.null <- base::is.null
[10:24:17.363]                       muffled <- FALSE
[10:24:17.363]                       if (inherits(cond, "message")) {
[10:24:17.363]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.363]                         if (muffled) 
[10:24:17.363]                           invokeRestart("muffleMessage")
[10:24:17.363]                       }
[10:24:17.363]                       else if (inherits(cond, "warning")) {
[10:24:17.363]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.363]                         if (muffled) 
[10:24:17.363]                           invokeRestart("muffleWarning")
[10:24:17.363]                       }
[10:24:17.363]                       else if (inherits(cond, "condition")) {
[10:24:17.363]                         if (!is.null(pattern)) {
[10:24:17.363]                           computeRestarts <- base::computeRestarts
[10:24:17.363]                           grepl <- base::grepl
[10:24:17.363]                           restarts <- computeRestarts(cond)
[10:24:17.363]                           for (restart in restarts) {
[10:24:17.363]                             name <- restart$name
[10:24:17.363]                             if (is.null(name)) 
[10:24:17.363]                               next
[10:24:17.363]                             if (!grepl(pattern, name)) 
[10:24:17.363]                               next
[10:24:17.363]                             invokeRestart(restart)
[10:24:17.363]                             muffled <- TRUE
[10:24:17.363]                             break
[10:24:17.363]                           }
[10:24:17.363]                         }
[10:24:17.363]                       }
[10:24:17.363]                       invisible(muffled)
[10:24:17.363]                     }
[10:24:17.363]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.363]                   }
[10:24:17.363]                 }
[10:24:17.363]             }
[10:24:17.363]         }))
[10:24:17.363]     }, error = function(ex) {
[10:24:17.363]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.363]                 ...future.rng), started = ...future.startTime, 
[10:24:17.363]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.363]             version = "1.8"), class = "FutureResult")
[10:24:17.363]     }, finally = {
[10:24:17.363]         if (!identical(...future.workdir, getwd())) 
[10:24:17.363]             setwd(...future.workdir)
[10:24:17.363]         {
[10:24:17.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.363]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.363]             }
[10:24:17.363]             base::options(...future.oldOptions)
[10:24:17.363]             if (.Platform$OS.type == "windows") {
[10:24:17.363]                 old_names <- names(...future.oldEnvVars)
[10:24:17.363]                 envs <- base::Sys.getenv()
[10:24:17.363]                 names <- names(envs)
[10:24:17.363]                 common <- intersect(names, old_names)
[10:24:17.363]                 added <- setdiff(names, old_names)
[10:24:17.363]                 removed <- setdiff(old_names, names)
[10:24:17.363]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.363]                   envs[common]]
[10:24:17.363]                 NAMES <- toupper(changed)
[10:24:17.363]                 args <- list()
[10:24:17.363]                 for (kk in seq_along(NAMES)) {
[10:24:17.363]                   name <- changed[[kk]]
[10:24:17.363]                   NAME <- NAMES[[kk]]
[10:24:17.363]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.363]                     next
[10:24:17.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.363]                 }
[10:24:17.363]                 NAMES <- toupper(added)
[10:24:17.363]                 for (kk in seq_along(NAMES)) {
[10:24:17.363]                   name <- added[[kk]]
[10:24:17.363]                   NAME <- NAMES[[kk]]
[10:24:17.363]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.363]                     next
[10:24:17.363]                   args[[name]] <- ""
[10:24:17.363]                 }
[10:24:17.363]                 NAMES <- toupper(removed)
[10:24:17.363]                 for (kk in seq_along(NAMES)) {
[10:24:17.363]                   name <- removed[[kk]]
[10:24:17.363]                   NAME <- NAMES[[kk]]
[10:24:17.363]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.363]                     next
[10:24:17.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.363]                 }
[10:24:17.363]                 if (length(args) > 0) 
[10:24:17.363]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.363]             }
[10:24:17.363]             else {
[10:24:17.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.363]             }
[10:24:17.363]             {
[10:24:17.363]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.363]                   0L) {
[10:24:17.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.363]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.363]                   base::options(opts)
[10:24:17.363]                 }
[10:24:17.363]                 {
[10:24:17.363]                   {
[10:24:17.363]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.363]                     NULL
[10:24:17.363]                   }
[10:24:17.363]                   options(future.plan = NULL)
[10:24:17.363]                   if (is.na(NA_character_)) 
[10:24:17.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.363]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.363]                     envir = parent.frame()) 
[10:24:17.363]                   {
[10:24:17.363]                     default_workers <- missing(workers)
[10:24:17.363]                     if (is.function(workers)) 
[10:24:17.363]                       workers <- workers()
[10:24:17.363]                     workers <- structure(as.integer(workers), 
[10:24:17.363]                       class = class(workers))
[10:24:17.363]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.363]                       1L)
[10:24:17.363]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.363]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.363]                       if (default_workers) 
[10:24:17.363]                         supportsMulticore(warn = TRUE)
[10:24:17.363]                       return(sequential(..., envir = envir))
[10:24:17.363]                     }
[10:24:17.363]                     oopts <- options(mc.cores = workers)
[10:24:17.363]                     on.exit(options(oopts))
[10:24:17.363]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.363]                       envir = envir)
[10:24:17.363]                     if (!future$lazy) 
[10:24:17.363]                       future <- run(future)
[10:24:17.363]                     invisible(future)
[10:24:17.363]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.363]                 }
[10:24:17.363]             }
[10:24:17.363]         }
[10:24:17.363]     })
[10:24:17.363]     if (TRUE) {
[10:24:17.363]         base::sink(type = "output", split = FALSE)
[10:24:17.363]         if (TRUE) {
[10:24:17.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.363]         }
[10:24:17.363]         else {
[10:24:17.363]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.363]         }
[10:24:17.363]         base::close(...future.stdout)
[10:24:17.363]         ...future.stdout <- NULL
[10:24:17.363]     }
[10:24:17.363]     ...future.result$conditions <- ...future.conditions
[10:24:17.363]     ...future.result$finished <- base::Sys.time()
[10:24:17.363]     ...future.result
[10:24:17.363] }
[10:24:17.366] assign_globals() ...
[10:24:17.366] List of 11
[10:24:17.366]  $ ...future.FUN            :function (x, ...)  
[10:24:17.366]  $ x_FUN                    :function (x)  
[10:24:17.366]  $ times                    : int 1
[10:24:17.366]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.366]  $ stop_if_not              :function (...)  
[10:24:17.366]  $ dim                      : NULL
[10:24:17.366]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:17.366]  $ future.call.arguments    : list()
[10:24:17.366]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.366]  $ ...future.elements_ii    :List of 5
[10:24:17.366]   ..$ : int 1
[10:24:17.366]   ..$ : int 2
[10:24:17.366]   ..$ : int 3
[10:24:17.366]   ..$ : int 4
[10:24:17.366]   ..$ : int 5
[10:24:17.366]  $ ...future.seeds_ii       : NULL
[10:24:17.366]  $ ...future.globals.maxSize: NULL
[10:24:17.366]  - attr(*, "where")=List of 11
[10:24:17.366]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.366]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.366]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.366]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.366]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.366]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.366]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.366]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.366]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.366]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.366]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.366]  - attr(*, "resolved")= logi FALSE
[10:24:17.366]  - attr(*, "total_size")= num 94336
[10:24:17.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.366]  - attr(*, "already-done")= logi TRUE
[10:24:17.376] - copied ‘...future.FUN’ to environment
[10:24:17.376] - copied ‘x_FUN’ to environment
[10:24:17.376] - copied ‘times’ to environment
[10:24:17.376] - copied ‘stopf’ to environment
[10:24:17.376] - copied ‘stop_if_not’ to environment
[10:24:17.376] - copied ‘dim’ to environment
[10:24:17.376] - copied ‘valid_types’ to environment
[10:24:17.376] - copied ‘future.call.arguments’ to environment
[10:24:17.376] - copied ‘...future.elements_ii’ to environment
[10:24:17.377] - copied ‘...future.seeds_ii’ to environment
[10:24:17.377] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.377] assign_globals() ... done
[10:24:17.377] requestCore(): workers = 2
[10:24:17.379] MulticoreFuture started
[10:24:17.379] - Launch lazy future ... done
[10:24:17.380] run() for ‘MulticoreFuture’ ... done
[10:24:17.380] Created future:
[10:24:17.380] plan(): Setting new future strategy stack:
[10:24:17.381] List of future strategies:
[10:24:17.381] 1. sequential:
[10:24:17.381]    - args: function (..., envir = parent.frame())
[10:24:17.381]    - tweaked: FALSE
[10:24:17.381]    - call: NULL
[10:24:17.381] plan(): nbrOfWorkers() = 1
[10:24:17.383] plan(): Setting new future strategy stack:
[10:24:17.384] List of future strategies:
[10:24:17.384] 1. multicore:
[10:24:17.384]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.384]    - tweaked: FALSE
[10:24:17.384]    - call: plan(strategy)
[10:24:17.389] plan(): nbrOfWorkers() = 2
[10:24:17.380] MulticoreFuture:
[10:24:17.380] Label: ‘future_vapply-1’
[10:24:17.380] Expression:
[10:24:17.380] {
[10:24:17.380]     do.call(function(...) {
[10:24:17.380]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.380]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.380]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.380]             on.exit(options(oopts), add = TRUE)
[10:24:17.380]         }
[10:24:17.380]         {
[10:24:17.380]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.380]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.380]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.380]             })
[10:24:17.380]         }
[10:24:17.380]     }, args = future.call.arguments)
[10:24:17.380] }
[10:24:17.380] Lazy evaluation: FALSE
[10:24:17.380] Asynchronous evaluation: TRUE
[10:24:17.380] Local evaluation: TRUE
[10:24:17.380] Environment: R_GlobalEnv
[10:24:17.380] Capture standard output: TRUE
[10:24:17.380] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.380] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.380] Packages: 1 packages (‘future.apply’)
[10:24:17.380] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.380] Resolved: TRUE
[10:24:17.380] Value: <not collected>
[10:24:17.380] Conditions captured: <none>
[10:24:17.380] Early signaling: FALSE
[10:24:17.380] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.380] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.390] Chunk #1 of 2 ... DONE
[10:24:17.390] Chunk #2 of 2 ...
[10:24:17.390]  - Finding globals in 'X' for chunk #2 ...
[10:24:17.390] getGlobalsAndPackages() ...
[10:24:17.391] Searching for globals...
[10:24:17.391] 
[10:24:17.391] Searching for globals ... DONE
[10:24:17.391] - globals: [0] <none>
[10:24:17.391] getGlobalsAndPackages() ... DONE
[10:24:17.392]    + additional globals found: [n=0] 
[10:24:17.392]    + additional namespaces needed: [n=0] 
[10:24:17.392]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:17.392]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.392]  - seeds: <none>
[10:24:17.392]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.392] getGlobalsAndPackages() ...
[10:24:17.393] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.393] Resolving globals: FALSE
[10:24:17.393] Tweak future expression to call with '...' arguments ...
[10:24:17.393] {
[10:24:17.393]     do.call(function(...) {
[10:24:17.393]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.393]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.393]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.393]             on.exit(options(oopts), add = TRUE)
[10:24:17.393]         }
[10:24:17.393]         {
[10:24:17.393]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.393]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.393]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.393]             })
[10:24:17.393]         }
[10:24:17.393]     }, args = future.call.arguments)
[10:24:17.393] }
[10:24:17.394] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.394] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.395] - packages: [1] ‘future.apply’
[10:24:17.395] getGlobalsAndPackages() ... DONE
[10:24:17.395] run() for ‘Future’ ...
[10:24:17.395] - state: ‘created’
[10:24:17.396] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.400] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.401]   - Field: ‘label’
[10:24:17.401]   - Field: ‘local’
[10:24:17.401]   - Field: ‘owner’
[10:24:17.401]   - Field: ‘envir’
[10:24:17.401]   - Field: ‘workers’
[10:24:17.401]   - Field: ‘packages’
[10:24:17.401]   - Field: ‘gc’
[10:24:17.402]   - Field: ‘job’
[10:24:17.402]   - Field: ‘conditions’
[10:24:17.402]   - Field: ‘expr’
[10:24:17.402]   - Field: ‘uuid’
[10:24:17.402]   - Field: ‘seed’
[10:24:17.402]   - Field: ‘version’
[10:24:17.402]   - Field: ‘result’
[10:24:17.405]   - Field: ‘asynchronous’
[10:24:17.405]   - Field: ‘calls’
[10:24:17.405]   - Field: ‘globals’
[10:24:17.406]   - Field: ‘stdout’
[10:24:17.406]   - Field: ‘earlySignal’
[10:24:17.406]   - Field: ‘lazy’
[10:24:17.407]   - Field: ‘state’
[10:24:17.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.407] - Launch lazy future ...
[10:24:17.408] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.408] Packages needed by future strategies (n = 0): <none>
[10:24:17.410] {
[10:24:17.410]     {
[10:24:17.410]         {
[10:24:17.410]             ...future.startTime <- base::Sys.time()
[10:24:17.410]             {
[10:24:17.410]                 {
[10:24:17.410]                   {
[10:24:17.410]                     {
[10:24:17.410]                       {
[10:24:17.410]                         base::local({
[10:24:17.410]                           has_future <- base::requireNamespace("future", 
[10:24:17.410]                             quietly = TRUE)
[10:24:17.410]                           if (has_future) {
[10:24:17.410]                             ns <- base::getNamespace("future")
[10:24:17.410]                             version <- ns[[".package"]][["version"]]
[10:24:17.410]                             if (is.null(version)) 
[10:24:17.410]                               version <- utils::packageVersion("future")
[10:24:17.410]                           }
[10:24:17.410]                           else {
[10:24:17.410]                             version <- NULL
[10:24:17.410]                           }
[10:24:17.410]                           if (!has_future || version < "1.8.0") {
[10:24:17.410]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.410]                               "", base::R.version$version.string), 
[10:24:17.410]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.410]                                 base::R.version$platform, 8 * 
[10:24:17.410]                                   base::.Machine$sizeof.pointer), 
[10:24:17.410]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.410]                                 "release", "version")], collapse = " "), 
[10:24:17.410]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.410]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.410]                               info)
[10:24:17.410]                             info <- base::paste(info, collapse = "; ")
[10:24:17.410]                             if (!has_future) {
[10:24:17.410]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.410]                                 info)
[10:24:17.410]                             }
[10:24:17.410]                             else {
[10:24:17.410]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.410]                                 info, version)
[10:24:17.410]                             }
[10:24:17.410]                             base::stop(msg)
[10:24:17.410]                           }
[10:24:17.410]                         })
[10:24:17.410]                       }
[10:24:17.410]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.410]                       base::options(mc.cores = 1L)
[10:24:17.410]                     }
[10:24:17.410]                     base::local({
[10:24:17.410]                       for (pkg in "future.apply") {
[10:24:17.410]                         base::loadNamespace(pkg)
[10:24:17.410]                         base::library(pkg, character.only = TRUE)
[10:24:17.410]                       }
[10:24:17.410]                     })
[10:24:17.410]                   }
[10:24:17.410]                   options(future.plan = NULL)
[10:24:17.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.410]                 }
[10:24:17.410]                 ...future.workdir <- getwd()
[10:24:17.410]             }
[10:24:17.410]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.410]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.410]         }
[10:24:17.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.410]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.410]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.410]             base::names(...future.oldOptions))
[10:24:17.410]     }
[10:24:17.410]     if (FALSE) {
[10:24:17.410]     }
[10:24:17.410]     else {
[10:24:17.410]         if (TRUE) {
[10:24:17.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.410]                 open = "w")
[10:24:17.410]         }
[10:24:17.410]         else {
[10:24:17.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.410]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.410]         }
[10:24:17.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.410]             base::sink(type = "output", split = FALSE)
[10:24:17.410]             base::close(...future.stdout)
[10:24:17.410]         }, add = TRUE)
[10:24:17.410]     }
[10:24:17.410]     ...future.frame <- base::sys.nframe()
[10:24:17.410]     ...future.conditions <- base::list()
[10:24:17.410]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.410]     if (FALSE) {
[10:24:17.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.410]     }
[10:24:17.410]     ...future.result <- base::tryCatch({
[10:24:17.410]         base::withCallingHandlers({
[10:24:17.410]             ...future.value <- base::withVisible(base::local({
[10:24:17.410]                 withCallingHandlers({
[10:24:17.410]                   {
[10:24:17.410]                     do.call(function(...) {
[10:24:17.410]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.410]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.410]                         ...future.globals.maxSize)) {
[10:24:17.410]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.410]                         on.exit(options(oopts), add = TRUE)
[10:24:17.410]                       }
[10:24:17.410]                       {
[10:24:17.410]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.410]                           FUN = function(jj) {
[10:24:17.410]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.410]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.410]                           })
[10:24:17.410]                       }
[10:24:17.410]                     }, args = future.call.arguments)
[10:24:17.410]                   }
[10:24:17.410]                 }, immediateCondition = function(cond) {
[10:24:17.410]                   save_rds <- function (object, pathname, ...) 
[10:24:17.410]                   {
[10:24:17.410]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.410]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.410]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.410]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.410]                         fi_tmp[["mtime"]])
[10:24:17.410]                     }
[10:24:17.410]                     tryCatch({
[10:24:17.410]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.410]                     }, error = function(ex) {
[10:24:17.410]                       msg <- conditionMessage(ex)
[10:24:17.410]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.410]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.410]                         fi_tmp[["mtime"]], msg)
[10:24:17.410]                       ex$message <- msg
[10:24:17.410]                       stop(ex)
[10:24:17.410]                     })
[10:24:17.410]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.410]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.410]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.410]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.410]                       fi <- file.info(pathname)
[10:24:17.410]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.410]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.410]                         fi[["size"]], fi[["mtime"]])
[10:24:17.410]                       stop(msg)
[10:24:17.410]                     }
[10:24:17.410]                     invisible(pathname)
[10:24:17.410]                   }
[10:24:17.410]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.410]                     rootPath = tempdir()) 
[10:24:17.410]                   {
[10:24:17.410]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.410]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.410]                       tmpdir = path, fileext = ".rds")
[10:24:17.410]                     save_rds(obj, file)
[10:24:17.410]                   }
[10:24:17.410]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.410]                   {
[10:24:17.410]                     inherits <- base::inherits
[10:24:17.410]                     invokeRestart <- base::invokeRestart
[10:24:17.410]                     is.null <- base::is.null
[10:24:17.410]                     muffled <- FALSE
[10:24:17.410]                     if (inherits(cond, "message")) {
[10:24:17.410]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.410]                       if (muffled) 
[10:24:17.410]                         invokeRestart("muffleMessage")
[10:24:17.410]                     }
[10:24:17.410]                     else if (inherits(cond, "warning")) {
[10:24:17.410]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.410]                       if (muffled) 
[10:24:17.410]                         invokeRestart("muffleWarning")
[10:24:17.410]                     }
[10:24:17.410]                     else if (inherits(cond, "condition")) {
[10:24:17.410]                       if (!is.null(pattern)) {
[10:24:17.410]                         computeRestarts <- base::computeRestarts
[10:24:17.410]                         grepl <- base::grepl
[10:24:17.410]                         restarts <- computeRestarts(cond)
[10:24:17.410]                         for (restart in restarts) {
[10:24:17.410]                           name <- restart$name
[10:24:17.410]                           if (is.null(name)) 
[10:24:17.410]                             next
[10:24:17.410]                           if (!grepl(pattern, name)) 
[10:24:17.410]                             next
[10:24:17.410]                           invokeRestart(restart)
[10:24:17.410]                           muffled <- TRUE
[10:24:17.410]                           break
[10:24:17.410]                         }
[10:24:17.410]                       }
[10:24:17.410]                     }
[10:24:17.410]                     invisible(muffled)
[10:24:17.410]                   }
[10:24:17.410]                   muffleCondition(cond)
[10:24:17.410]                 })
[10:24:17.410]             }))
[10:24:17.410]             future::FutureResult(value = ...future.value$value, 
[10:24:17.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.410]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.410]                     ...future.globalenv.names))
[10:24:17.410]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.410]         }, condition = base::local({
[10:24:17.410]             c <- base::c
[10:24:17.410]             inherits <- base::inherits
[10:24:17.410]             invokeRestart <- base::invokeRestart
[10:24:17.410]             length <- base::length
[10:24:17.410]             list <- base::list
[10:24:17.410]             seq.int <- base::seq.int
[10:24:17.410]             signalCondition <- base::signalCondition
[10:24:17.410]             sys.calls <- base::sys.calls
[10:24:17.410]             `[[` <- base::`[[`
[10:24:17.410]             `+` <- base::`+`
[10:24:17.410]             `<<-` <- base::`<<-`
[10:24:17.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.410]                   3L)]
[10:24:17.410]             }
[10:24:17.410]             function(cond) {
[10:24:17.410]                 is_error <- inherits(cond, "error")
[10:24:17.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.410]                   NULL)
[10:24:17.410]                 if (is_error) {
[10:24:17.410]                   sessionInformation <- function() {
[10:24:17.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.410]                       search = base::search(), system = base::Sys.info())
[10:24:17.410]                   }
[10:24:17.410]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.410]                     cond$call), session = sessionInformation(), 
[10:24:17.410]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.410]                   signalCondition(cond)
[10:24:17.410]                 }
[10:24:17.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.410]                 "immediateCondition"))) {
[10:24:17.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.410]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.410]                   if (TRUE && !signal) {
[10:24:17.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.410]                     {
[10:24:17.410]                       inherits <- base::inherits
[10:24:17.410]                       invokeRestart <- base::invokeRestart
[10:24:17.410]                       is.null <- base::is.null
[10:24:17.410]                       muffled <- FALSE
[10:24:17.410]                       if (inherits(cond, "message")) {
[10:24:17.410]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.410]                         if (muffled) 
[10:24:17.410]                           invokeRestart("muffleMessage")
[10:24:17.410]                       }
[10:24:17.410]                       else if (inherits(cond, "warning")) {
[10:24:17.410]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.410]                         if (muffled) 
[10:24:17.410]                           invokeRestart("muffleWarning")
[10:24:17.410]                       }
[10:24:17.410]                       else if (inherits(cond, "condition")) {
[10:24:17.410]                         if (!is.null(pattern)) {
[10:24:17.410]                           computeRestarts <- base::computeRestarts
[10:24:17.410]                           grepl <- base::grepl
[10:24:17.410]                           restarts <- computeRestarts(cond)
[10:24:17.410]                           for (restart in restarts) {
[10:24:17.410]                             name <- restart$name
[10:24:17.410]                             if (is.null(name)) 
[10:24:17.410]                               next
[10:24:17.410]                             if (!grepl(pattern, name)) 
[10:24:17.410]                               next
[10:24:17.410]                             invokeRestart(restart)
[10:24:17.410]                             muffled <- TRUE
[10:24:17.410]                             break
[10:24:17.410]                           }
[10:24:17.410]                         }
[10:24:17.410]                       }
[10:24:17.410]                       invisible(muffled)
[10:24:17.410]                     }
[10:24:17.410]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.410]                   }
[10:24:17.410]                 }
[10:24:17.410]                 else {
[10:24:17.410]                   if (TRUE) {
[10:24:17.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.410]                     {
[10:24:17.410]                       inherits <- base::inherits
[10:24:17.410]                       invokeRestart <- base::invokeRestart
[10:24:17.410]                       is.null <- base::is.null
[10:24:17.410]                       muffled <- FALSE
[10:24:17.410]                       if (inherits(cond, "message")) {
[10:24:17.410]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.410]                         if (muffled) 
[10:24:17.410]                           invokeRestart("muffleMessage")
[10:24:17.410]                       }
[10:24:17.410]                       else if (inherits(cond, "warning")) {
[10:24:17.410]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.410]                         if (muffled) 
[10:24:17.410]                           invokeRestart("muffleWarning")
[10:24:17.410]                       }
[10:24:17.410]                       else if (inherits(cond, "condition")) {
[10:24:17.410]                         if (!is.null(pattern)) {
[10:24:17.410]                           computeRestarts <- base::computeRestarts
[10:24:17.410]                           grepl <- base::grepl
[10:24:17.410]                           restarts <- computeRestarts(cond)
[10:24:17.410]                           for (restart in restarts) {
[10:24:17.410]                             name <- restart$name
[10:24:17.410]                             if (is.null(name)) 
[10:24:17.410]                               next
[10:24:17.410]                             if (!grepl(pattern, name)) 
[10:24:17.410]                               next
[10:24:17.410]                             invokeRestart(restart)
[10:24:17.410]                             muffled <- TRUE
[10:24:17.410]                             break
[10:24:17.410]                           }
[10:24:17.410]                         }
[10:24:17.410]                       }
[10:24:17.410]                       invisible(muffled)
[10:24:17.410]                     }
[10:24:17.410]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.410]                   }
[10:24:17.410]                 }
[10:24:17.410]             }
[10:24:17.410]         }))
[10:24:17.410]     }, error = function(ex) {
[10:24:17.410]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.410]                 ...future.rng), started = ...future.startTime, 
[10:24:17.410]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.410]             version = "1.8"), class = "FutureResult")
[10:24:17.410]     }, finally = {
[10:24:17.410]         if (!identical(...future.workdir, getwd())) 
[10:24:17.410]             setwd(...future.workdir)
[10:24:17.410]         {
[10:24:17.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.410]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.410]             }
[10:24:17.410]             base::options(...future.oldOptions)
[10:24:17.410]             if (.Platform$OS.type == "windows") {
[10:24:17.410]                 old_names <- names(...future.oldEnvVars)
[10:24:17.410]                 envs <- base::Sys.getenv()
[10:24:17.410]                 names <- names(envs)
[10:24:17.410]                 common <- intersect(names, old_names)
[10:24:17.410]                 added <- setdiff(names, old_names)
[10:24:17.410]                 removed <- setdiff(old_names, names)
[10:24:17.410]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.410]                   envs[common]]
[10:24:17.410]                 NAMES <- toupper(changed)
[10:24:17.410]                 args <- list()
[10:24:17.410]                 for (kk in seq_along(NAMES)) {
[10:24:17.410]                   name <- changed[[kk]]
[10:24:17.410]                   NAME <- NAMES[[kk]]
[10:24:17.410]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.410]                     next
[10:24:17.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.410]                 }
[10:24:17.410]                 NAMES <- toupper(added)
[10:24:17.410]                 for (kk in seq_along(NAMES)) {
[10:24:17.410]                   name <- added[[kk]]
[10:24:17.410]                   NAME <- NAMES[[kk]]
[10:24:17.410]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.410]                     next
[10:24:17.410]                   args[[name]] <- ""
[10:24:17.410]                 }
[10:24:17.410]                 NAMES <- toupper(removed)
[10:24:17.410]                 for (kk in seq_along(NAMES)) {
[10:24:17.410]                   name <- removed[[kk]]
[10:24:17.410]                   NAME <- NAMES[[kk]]
[10:24:17.410]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.410]                     next
[10:24:17.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.410]                 }
[10:24:17.410]                 if (length(args) > 0) 
[10:24:17.410]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.410]             }
[10:24:17.410]             else {
[10:24:17.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.410]             }
[10:24:17.410]             {
[10:24:17.410]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.410]                   0L) {
[10:24:17.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.410]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.410]                   base::options(opts)
[10:24:17.410]                 }
[10:24:17.410]                 {
[10:24:17.410]                   {
[10:24:17.410]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.410]                     NULL
[10:24:17.410]                   }
[10:24:17.410]                   options(future.plan = NULL)
[10:24:17.410]                   if (is.na(NA_character_)) 
[10:24:17.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.410]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.410]                     envir = parent.frame()) 
[10:24:17.410]                   {
[10:24:17.410]                     default_workers <- missing(workers)
[10:24:17.410]                     if (is.function(workers)) 
[10:24:17.410]                       workers <- workers()
[10:24:17.410]                     workers <- structure(as.integer(workers), 
[10:24:17.410]                       class = class(workers))
[10:24:17.410]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.410]                       1L)
[10:24:17.410]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.410]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.410]                       if (default_workers) 
[10:24:17.410]                         supportsMulticore(warn = TRUE)
[10:24:17.410]                       return(sequential(..., envir = envir))
[10:24:17.410]                     }
[10:24:17.410]                     oopts <- options(mc.cores = workers)
[10:24:17.410]                     on.exit(options(oopts))
[10:24:17.410]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.410]                       envir = envir)
[10:24:17.410]                     if (!future$lazy) 
[10:24:17.410]                       future <- run(future)
[10:24:17.410]                     invisible(future)
[10:24:17.410]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.410]                 }
[10:24:17.410]             }
[10:24:17.410]         }
[10:24:17.410]     })
[10:24:17.410]     if (TRUE) {
[10:24:17.410]         base::sink(type = "output", split = FALSE)
[10:24:17.410]         if (TRUE) {
[10:24:17.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.410]         }
[10:24:17.410]         else {
[10:24:17.410]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.410]         }
[10:24:17.410]         base::close(...future.stdout)
[10:24:17.410]         ...future.stdout <- NULL
[10:24:17.410]     }
[10:24:17.410]     ...future.result$conditions <- ...future.conditions
[10:24:17.410]     ...future.result$finished <- base::Sys.time()
[10:24:17.410]     ...future.result
[10:24:17.410] }
[10:24:17.413] assign_globals() ...
[10:24:17.414] List of 11
[10:24:17.414]  $ ...future.FUN            :function (x, ...)  
[10:24:17.414]  $ x_FUN                    :function (x)  
[10:24:17.414]  $ times                    : int 1
[10:24:17.414]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.414]  $ stop_if_not              :function (...)  
[10:24:17.414]  $ dim                      : NULL
[10:24:17.414]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:17.414]  $ future.call.arguments    : list()
[10:24:17.414]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.414]  $ ...future.elements_ii    :List of 5
[10:24:17.414]   ..$ : int 6
[10:24:17.414]   ..$ : int 7
[10:24:17.414]   ..$ : int 8
[10:24:17.414]   ..$ : int 9
[10:24:17.414]   ..$ : int 10
[10:24:17.414]  $ ...future.seeds_ii       : NULL
[10:24:17.414]  $ ...future.globals.maxSize: NULL
[10:24:17.414]  - attr(*, "where")=List of 11
[10:24:17.414]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.414]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.414]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.414]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.414]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.414]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.414]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.414]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.414]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.414]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.414]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.414]  - attr(*, "resolved")= logi FALSE
[10:24:17.414]  - attr(*, "total_size")= num 94336
[10:24:17.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.414]  - attr(*, "already-done")= logi TRUE
[10:24:17.427] - copied ‘...future.FUN’ to environment
[10:24:17.427] - copied ‘x_FUN’ to environment
[10:24:17.427] - copied ‘times’ to environment
[10:24:17.427] - copied ‘stopf’ to environment
[10:24:17.427] - copied ‘stop_if_not’ to environment
[10:24:17.427] - copied ‘dim’ to environment
[10:24:17.427] - copied ‘valid_types’ to environment
[10:24:17.427] - copied ‘future.call.arguments’ to environment
[10:24:17.427] - copied ‘...future.elements_ii’ to environment
[10:24:17.427] - copied ‘...future.seeds_ii’ to environment
[10:24:17.428] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.428] assign_globals() ... done
[10:24:17.428] requestCore(): workers = 2
[10:24:17.430] MulticoreFuture started
[10:24:17.430] - Launch lazy future ... done
[10:24:17.430] run() for ‘MulticoreFuture’ ... done
[10:24:17.431] Created future:
[10:24:17.431] plan(): Setting new future strategy stack:
[10:24:17.432] List of future strategies:
[10:24:17.432] 1. sequential:
[10:24:17.432]    - args: function (..., envir = parent.frame())
[10:24:17.432]    - tweaked: FALSE
[10:24:17.432]    - call: NULL
[10:24:17.432] plan(): nbrOfWorkers() = 1
[10:24:17.435] plan(): Setting new future strategy stack:
[10:24:17.435] List of future strategies:
[10:24:17.435] 1. multicore:
[10:24:17.435]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.435]    - tweaked: FALSE
[10:24:17.435]    - call: plan(strategy)
[10:24:17.440] plan(): nbrOfWorkers() = 2
[10:24:17.431] MulticoreFuture:
[10:24:17.431] Label: ‘future_vapply-2’
[10:24:17.431] Expression:
[10:24:17.431] {
[10:24:17.431]     do.call(function(...) {
[10:24:17.431]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.431]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.431]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.431]             on.exit(options(oopts), add = TRUE)
[10:24:17.431]         }
[10:24:17.431]         {
[10:24:17.431]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.431]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.431]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.431]             })
[10:24:17.431]         }
[10:24:17.431]     }, args = future.call.arguments)
[10:24:17.431] }
[10:24:17.431] Lazy evaluation: FALSE
[10:24:17.431] Asynchronous evaluation: TRUE
[10:24:17.431] Local evaluation: TRUE
[10:24:17.431] Environment: R_GlobalEnv
[10:24:17.431] Capture standard output: TRUE
[10:24:17.431] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.431] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.431] Packages: 1 packages (‘future.apply’)
[10:24:17.431] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.431] Resolved: TRUE
[10:24:17.431] Value: <not collected>
[10:24:17.431] Conditions captured: <none>
[10:24:17.431] Early signaling: FALSE
[10:24:17.431] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.431] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.441] Chunk #2 of 2 ... DONE
[10:24:17.441] Launching 2 futures (chunks) ... DONE
[10:24:17.441] Resolving 2 futures (chunks) ...
[10:24:17.441] resolve() on list ...
[10:24:17.441]  recursive: 0
[10:24:17.442]  length: 2
[10:24:17.442] 
[10:24:17.442] Future #1
[10:24:17.442] result() for MulticoreFuture ...
[10:24:17.443] result() for MulticoreFuture ...
[10:24:17.443] result() for MulticoreFuture ... done
[10:24:17.443] result() for MulticoreFuture ... done
[10:24:17.444] result() for MulticoreFuture ...
[10:24:17.444] result() for MulticoreFuture ... done
[10:24:17.444] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:17.444] - nx: 2
[10:24:17.444] - relay: TRUE
[10:24:17.444] - stdout: TRUE
[10:24:17.444] - signal: TRUE
[10:24:17.445] - resignal: FALSE
[10:24:17.445] - force: TRUE
[10:24:17.445] - relayed: [n=2] FALSE, FALSE
[10:24:17.445] - queued futures: [n=2] FALSE, FALSE
[10:24:17.445]  - until=1
[10:24:17.445]  - relaying element #1
[10:24:17.445] result() for MulticoreFuture ...
[10:24:17.446] result() for MulticoreFuture ... done
[10:24:17.446] result() for MulticoreFuture ...
[10:24:17.446] result() for MulticoreFuture ... done
[10:24:17.446] result() for MulticoreFuture ...
[10:24:17.446] result() for MulticoreFuture ... done
[10:24:17.446] result() for MulticoreFuture ...
[10:24:17.447] result() for MulticoreFuture ... done
[10:24:17.447] - relayed: [n=2] TRUE, FALSE
[10:24:17.447] - queued futures: [n=2] TRUE, FALSE
[10:24:17.447] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:17.450]  length: 1 (resolved future 1)
[10:24:17.451] Future #2
[10:24:17.451] result() for MulticoreFuture ...
[10:24:17.453] result() for MulticoreFuture ...
[10:24:17.453] result() for MulticoreFuture ... done
[10:24:17.453] result() for MulticoreFuture ... done
[10:24:17.454] result() for MulticoreFuture ...
[10:24:17.454] result() for MulticoreFuture ... done
[10:24:17.454] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:17.454] - nx: 2
[10:24:17.455] - relay: TRUE
[10:24:17.455] - stdout: TRUE
[10:24:17.455] - signal: TRUE
[10:24:17.455] - resignal: FALSE
[10:24:17.455] - force: TRUE
[10:24:17.455] - relayed: [n=2] TRUE, FALSE
[10:24:17.455] - queued futures: [n=2] TRUE, FALSE
[10:24:17.456]  - until=2
[10:24:17.456]  - relaying element #2
[10:24:17.456] result() for MulticoreFuture ...
[10:24:17.456] result() for MulticoreFuture ... done
[10:24:17.456] result() for MulticoreFuture ...
[10:24:17.456] result() for MulticoreFuture ... done
[10:24:17.457] result() for MulticoreFuture ...
[10:24:17.457] result() for MulticoreFuture ... done
[10:24:17.457] result() for MulticoreFuture ...
[10:24:17.457] result() for MulticoreFuture ... done
[10:24:17.457] - relayed: [n=2] TRUE, TRUE
[10:24:17.457] - queued futures: [n=2] TRUE, TRUE
[10:24:17.458] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:17.458]  length: 0 (resolved future 2)
[10:24:17.458] Relaying remaining futures
[10:24:17.458] signalConditionsASAP(NULL, pos=0) ...
[10:24:17.458] - nx: 2
[10:24:17.458] - relay: TRUE
[10:24:17.458] - stdout: TRUE
[10:24:17.458] - signal: TRUE
[10:24:17.458] - resignal: FALSE
[10:24:17.459] - force: TRUE
[10:24:17.459] - relayed: [n=2] TRUE, TRUE
[10:24:17.459] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:17.459] - relayed: [n=2] TRUE, TRUE
[10:24:17.459] - queued futures: [n=2] TRUE, TRUE
[10:24:17.459] signalConditionsASAP(NULL, pos=0) ... done
[10:24:17.459] resolve() on list ... DONE
[10:24:17.459] result() for MulticoreFuture ...
[10:24:17.460] result() for MulticoreFuture ... done
[10:24:17.460] result() for MulticoreFuture ...
[10:24:17.460] result() for MulticoreFuture ... done
[10:24:17.460] result() for MulticoreFuture ...
[10:24:17.460] result() for MulticoreFuture ... done
[10:24:17.460] result() for MulticoreFuture ...
[10:24:17.460] result() for MulticoreFuture ... done
[10:24:17.460]  - Number of value chunks collected: 2
[10:24:17.461] Resolving 2 futures (chunks) ... DONE
[10:24:17.461] Reducing values from 2 chunks ...
[10:24:17.461]  - Number of values collected after concatenation: 10
[10:24:17.461]  - Number of values expected: 10
[10:24:17.461] Reducing values from 2 chunks ... DONE
[10:24:17.461] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[10:24:17.462] future_lapply() ...
[10:24:17.468] Number of chunks: 2
[10:24:17.468] getGlobalsAndPackagesXApply() ...
[10:24:17.468]  - future.globals: TRUE
[10:24:17.468] getGlobalsAndPackages() ...
[10:24:17.468] Searching for globals...
[10:24:17.472] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[10:24:17.472] Searching for globals ... DONE
[10:24:17.473] Resolving globals: FALSE
[10:24:17.473] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[10:24:17.474] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:17.474] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.474] - packages: [1] ‘future.apply’
[10:24:17.474] getGlobalsAndPackages() ... DONE
[10:24:17.474]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.475]  - needed namespaces: [n=1] ‘future.apply’
[10:24:17.475] Finding globals ... DONE
[10:24:17.475]  - use_args: TRUE
[10:24:17.475]  - Getting '...' globals ...
[10:24:17.475] resolve() on list ...
[10:24:17.475]  recursive: 0
[10:24:17.475]  length: 1
[10:24:17.475]  elements: ‘...’
[10:24:17.476]  length: 0 (resolved future 1)
[10:24:17.476] resolve() on list ... DONE
[10:24:17.476]    - '...' content: [n=0] 
[10:24:17.476] List of 1
[10:24:17.476]  $ ...: list()
[10:24:17.476]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.476]  - attr(*, "where")=List of 1
[10:24:17.476]   ..$ ...:<environment: 0x55b93b388130> 
[10:24:17.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.476]  - attr(*, "resolved")= logi TRUE
[10:24:17.476]  - attr(*, "total_size")= num NA
[10:24:17.480]  - Getting '...' globals ... DONE
[10:24:17.480] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:17.480] List of 8
[10:24:17.480]  $ ...future.FUN:function (x, ...)  
[10:24:17.480]  $ x_FUN        :function (x)  
[10:24:17.480]  $ times        : int 2
[10:24:17.480]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.480]  $ stop_if_not  :function (...)  
[10:24:17.480]  $ dim          : NULL
[10:24:17.480]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:17.480]  $ ...          : list()
[10:24:17.480]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.480]  - attr(*, "where")=List of 8
[10:24:17.480]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:17.480]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:17.480]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:17.480]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:17.480]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:17.480]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:17.480]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:17.480]   ..$ ...          :<environment: 0x55b93b388130> 
[10:24:17.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.480]  - attr(*, "resolved")= logi FALSE
[10:24:17.480]  - attr(*, "total_size")= num 96456
[10:24:17.486] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:17.486] getGlobalsAndPackagesXApply() ... DONE
[10:24:17.486] Number of futures (= number of chunks): 2
[10:24:17.486] Launching 2 futures (chunks) ...
[10:24:17.486] Chunk #1 of 2 ...
[10:24:17.486]  - Finding globals in 'X' for chunk #1 ...
[10:24:17.487] getGlobalsAndPackages() ...
[10:24:17.487] Searching for globals...
[10:24:17.487] 
[10:24:17.487] Searching for globals ... DONE
[10:24:17.487] - globals: [0] <none>
[10:24:17.487] getGlobalsAndPackages() ... DONE
[10:24:17.487]    + additional globals found: [n=0] 
[10:24:17.487]    + additional namespaces needed: [n=0] 
[10:24:17.487]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:17.488]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.488]  - seeds: <none>
[10:24:17.488]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.488] getGlobalsAndPackages() ...
[10:24:17.488] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.488] Resolving globals: FALSE
[10:24:17.488] Tweak future expression to call with '...' arguments ...
[10:24:17.488] {
[10:24:17.488]     do.call(function(...) {
[10:24:17.488]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.488]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.488]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.488]             on.exit(options(oopts), add = TRUE)
[10:24:17.488]         }
[10:24:17.488]         {
[10:24:17.488]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.488]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.488]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.488]             })
[10:24:17.488]         }
[10:24:17.488]     }, args = future.call.arguments)
[10:24:17.488] }
[10:24:17.489] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.489] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.489] - packages: [1] ‘future.apply’
[10:24:17.489] getGlobalsAndPackages() ... DONE
[10:24:17.490] run() for ‘Future’ ...
[10:24:17.490] - state: ‘created’
[10:24:17.490] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.493] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.493] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.493]   - Field: ‘label’
[10:24:17.494]   - Field: ‘local’
[10:24:17.494]   - Field: ‘owner’
[10:24:17.494]   - Field: ‘envir’
[10:24:17.494]   - Field: ‘workers’
[10:24:17.494]   - Field: ‘packages’
[10:24:17.494]   - Field: ‘gc’
[10:24:17.494]   - Field: ‘job’
[10:24:17.494]   - Field: ‘conditions’
[10:24:17.494]   - Field: ‘expr’
[10:24:17.494]   - Field: ‘uuid’
[10:24:17.495]   - Field: ‘seed’
[10:24:17.495]   - Field: ‘version’
[10:24:17.495]   - Field: ‘result’
[10:24:17.495]   - Field: ‘asynchronous’
[10:24:17.495]   - Field: ‘calls’
[10:24:17.495]   - Field: ‘globals’
[10:24:17.495]   - Field: ‘stdout’
[10:24:17.495]   - Field: ‘earlySignal’
[10:24:17.495]   - Field: ‘lazy’
[10:24:17.495]   - Field: ‘state’
[10:24:17.495] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.496] - Launch lazy future ...
[10:24:17.496] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.496] Packages needed by future strategies (n = 0): <none>
[10:24:17.496] {
[10:24:17.496]     {
[10:24:17.496]         {
[10:24:17.496]             ...future.startTime <- base::Sys.time()
[10:24:17.496]             {
[10:24:17.496]                 {
[10:24:17.496]                   {
[10:24:17.496]                     {
[10:24:17.496]                       {
[10:24:17.496]                         base::local({
[10:24:17.496]                           has_future <- base::requireNamespace("future", 
[10:24:17.496]                             quietly = TRUE)
[10:24:17.496]                           if (has_future) {
[10:24:17.496]                             ns <- base::getNamespace("future")
[10:24:17.496]                             version <- ns[[".package"]][["version"]]
[10:24:17.496]                             if (is.null(version)) 
[10:24:17.496]                               version <- utils::packageVersion("future")
[10:24:17.496]                           }
[10:24:17.496]                           else {
[10:24:17.496]                             version <- NULL
[10:24:17.496]                           }
[10:24:17.496]                           if (!has_future || version < "1.8.0") {
[10:24:17.496]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.496]                               "", base::R.version$version.string), 
[10:24:17.496]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.496]                                 base::R.version$platform, 8 * 
[10:24:17.496]                                   base::.Machine$sizeof.pointer), 
[10:24:17.496]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.496]                                 "release", "version")], collapse = " "), 
[10:24:17.496]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.496]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.496]                               info)
[10:24:17.496]                             info <- base::paste(info, collapse = "; ")
[10:24:17.496]                             if (!has_future) {
[10:24:17.496]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.496]                                 info)
[10:24:17.496]                             }
[10:24:17.496]                             else {
[10:24:17.496]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.496]                                 info, version)
[10:24:17.496]                             }
[10:24:17.496]                             base::stop(msg)
[10:24:17.496]                           }
[10:24:17.496]                         })
[10:24:17.496]                       }
[10:24:17.496]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.496]                       base::options(mc.cores = 1L)
[10:24:17.496]                     }
[10:24:17.496]                     base::local({
[10:24:17.496]                       for (pkg in "future.apply") {
[10:24:17.496]                         base::loadNamespace(pkg)
[10:24:17.496]                         base::library(pkg, character.only = TRUE)
[10:24:17.496]                       }
[10:24:17.496]                     })
[10:24:17.496]                   }
[10:24:17.496]                   options(future.plan = NULL)
[10:24:17.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.496]                 }
[10:24:17.496]                 ...future.workdir <- getwd()
[10:24:17.496]             }
[10:24:17.496]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.496]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.496]         }
[10:24:17.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.496]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.496]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.496]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.496]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.496]             base::names(...future.oldOptions))
[10:24:17.496]     }
[10:24:17.496]     if (FALSE) {
[10:24:17.496]     }
[10:24:17.496]     else {
[10:24:17.496]         if (TRUE) {
[10:24:17.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.496]                 open = "w")
[10:24:17.496]         }
[10:24:17.496]         else {
[10:24:17.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.496]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.496]         }
[10:24:17.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.496]             base::sink(type = "output", split = FALSE)
[10:24:17.496]             base::close(...future.stdout)
[10:24:17.496]         }, add = TRUE)
[10:24:17.496]     }
[10:24:17.496]     ...future.frame <- base::sys.nframe()
[10:24:17.496]     ...future.conditions <- base::list()
[10:24:17.496]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.496]     if (FALSE) {
[10:24:17.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.496]     }
[10:24:17.496]     ...future.result <- base::tryCatch({
[10:24:17.496]         base::withCallingHandlers({
[10:24:17.496]             ...future.value <- base::withVisible(base::local({
[10:24:17.496]                 withCallingHandlers({
[10:24:17.496]                   {
[10:24:17.496]                     do.call(function(...) {
[10:24:17.496]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.496]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.496]                         ...future.globals.maxSize)) {
[10:24:17.496]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.496]                         on.exit(options(oopts), add = TRUE)
[10:24:17.496]                       }
[10:24:17.496]                       {
[10:24:17.496]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.496]                           FUN = function(jj) {
[10:24:17.496]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.496]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.496]                           })
[10:24:17.496]                       }
[10:24:17.496]                     }, args = future.call.arguments)
[10:24:17.496]                   }
[10:24:17.496]                 }, immediateCondition = function(cond) {
[10:24:17.496]                   save_rds <- function (object, pathname, ...) 
[10:24:17.496]                   {
[10:24:17.496]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.496]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.496]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.496]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.496]                         fi_tmp[["mtime"]])
[10:24:17.496]                     }
[10:24:17.496]                     tryCatch({
[10:24:17.496]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.496]                     }, error = function(ex) {
[10:24:17.496]                       msg <- conditionMessage(ex)
[10:24:17.496]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.496]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.496]                         fi_tmp[["mtime"]], msg)
[10:24:17.496]                       ex$message <- msg
[10:24:17.496]                       stop(ex)
[10:24:17.496]                     })
[10:24:17.496]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.496]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.496]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.496]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.496]                       fi <- file.info(pathname)
[10:24:17.496]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.496]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.496]                         fi[["size"]], fi[["mtime"]])
[10:24:17.496]                       stop(msg)
[10:24:17.496]                     }
[10:24:17.496]                     invisible(pathname)
[10:24:17.496]                   }
[10:24:17.496]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.496]                     rootPath = tempdir()) 
[10:24:17.496]                   {
[10:24:17.496]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.496]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.496]                       tmpdir = path, fileext = ".rds")
[10:24:17.496]                     save_rds(obj, file)
[10:24:17.496]                   }
[10:24:17.496]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.496]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.496]                   {
[10:24:17.496]                     inherits <- base::inherits
[10:24:17.496]                     invokeRestart <- base::invokeRestart
[10:24:17.496]                     is.null <- base::is.null
[10:24:17.496]                     muffled <- FALSE
[10:24:17.496]                     if (inherits(cond, "message")) {
[10:24:17.496]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.496]                       if (muffled) 
[10:24:17.496]                         invokeRestart("muffleMessage")
[10:24:17.496]                     }
[10:24:17.496]                     else if (inherits(cond, "warning")) {
[10:24:17.496]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.496]                       if (muffled) 
[10:24:17.496]                         invokeRestart("muffleWarning")
[10:24:17.496]                     }
[10:24:17.496]                     else if (inherits(cond, "condition")) {
[10:24:17.496]                       if (!is.null(pattern)) {
[10:24:17.496]                         computeRestarts <- base::computeRestarts
[10:24:17.496]                         grepl <- base::grepl
[10:24:17.496]                         restarts <- computeRestarts(cond)
[10:24:17.496]                         for (restart in restarts) {
[10:24:17.496]                           name <- restart$name
[10:24:17.496]                           if (is.null(name)) 
[10:24:17.496]                             next
[10:24:17.496]                           if (!grepl(pattern, name)) 
[10:24:17.496]                             next
[10:24:17.496]                           invokeRestart(restart)
[10:24:17.496]                           muffled <- TRUE
[10:24:17.496]                           break
[10:24:17.496]                         }
[10:24:17.496]                       }
[10:24:17.496]                     }
[10:24:17.496]                     invisible(muffled)
[10:24:17.496]                   }
[10:24:17.496]                   muffleCondition(cond)
[10:24:17.496]                 })
[10:24:17.496]             }))
[10:24:17.496]             future::FutureResult(value = ...future.value$value, 
[10:24:17.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.496]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.496]                     ...future.globalenv.names))
[10:24:17.496]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.496]         }, condition = base::local({
[10:24:17.496]             c <- base::c
[10:24:17.496]             inherits <- base::inherits
[10:24:17.496]             invokeRestart <- base::invokeRestart
[10:24:17.496]             length <- base::length
[10:24:17.496]             list <- base::list
[10:24:17.496]             seq.int <- base::seq.int
[10:24:17.496]             signalCondition <- base::signalCondition
[10:24:17.496]             sys.calls <- base::sys.calls
[10:24:17.496]             `[[` <- base::`[[`
[10:24:17.496]             `+` <- base::`+`
[10:24:17.496]             `<<-` <- base::`<<-`
[10:24:17.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.496]                   3L)]
[10:24:17.496]             }
[10:24:17.496]             function(cond) {
[10:24:17.496]                 is_error <- inherits(cond, "error")
[10:24:17.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.496]                   NULL)
[10:24:17.496]                 if (is_error) {
[10:24:17.496]                   sessionInformation <- function() {
[10:24:17.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.496]                       search = base::search(), system = base::Sys.info())
[10:24:17.496]                   }
[10:24:17.496]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.496]                     cond$call), session = sessionInformation(), 
[10:24:17.496]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.496]                   signalCondition(cond)
[10:24:17.496]                 }
[10:24:17.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.496]                 "immediateCondition"))) {
[10:24:17.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.496]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.496]                   if (TRUE && !signal) {
[10:24:17.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.496]                     {
[10:24:17.496]                       inherits <- base::inherits
[10:24:17.496]                       invokeRestart <- base::invokeRestart
[10:24:17.496]                       is.null <- base::is.null
[10:24:17.496]                       muffled <- FALSE
[10:24:17.496]                       if (inherits(cond, "message")) {
[10:24:17.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.496]                         if (muffled) 
[10:24:17.496]                           invokeRestart("muffleMessage")
[10:24:17.496]                       }
[10:24:17.496]                       else if (inherits(cond, "warning")) {
[10:24:17.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.496]                         if (muffled) 
[10:24:17.496]                           invokeRestart("muffleWarning")
[10:24:17.496]                       }
[10:24:17.496]                       else if (inherits(cond, "condition")) {
[10:24:17.496]                         if (!is.null(pattern)) {
[10:24:17.496]                           computeRestarts <- base::computeRestarts
[10:24:17.496]                           grepl <- base::grepl
[10:24:17.496]                           restarts <- computeRestarts(cond)
[10:24:17.496]                           for (restart in restarts) {
[10:24:17.496]                             name <- restart$name
[10:24:17.496]                             if (is.null(name)) 
[10:24:17.496]                               next
[10:24:17.496]                             if (!grepl(pattern, name)) 
[10:24:17.496]                               next
[10:24:17.496]                             invokeRestart(restart)
[10:24:17.496]                             muffled <- TRUE
[10:24:17.496]                             break
[10:24:17.496]                           }
[10:24:17.496]                         }
[10:24:17.496]                       }
[10:24:17.496]                       invisible(muffled)
[10:24:17.496]                     }
[10:24:17.496]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.496]                   }
[10:24:17.496]                 }
[10:24:17.496]                 else {
[10:24:17.496]                   if (TRUE) {
[10:24:17.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.496]                     {
[10:24:17.496]                       inherits <- base::inherits
[10:24:17.496]                       invokeRestart <- base::invokeRestart
[10:24:17.496]                       is.null <- base::is.null
[10:24:17.496]                       muffled <- FALSE
[10:24:17.496]                       if (inherits(cond, "message")) {
[10:24:17.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.496]                         if (muffled) 
[10:24:17.496]                           invokeRestart("muffleMessage")
[10:24:17.496]                       }
[10:24:17.496]                       else if (inherits(cond, "warning")) {
[10:24:17.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.496]                         if (muffled) 
[10:24:17.496]                           invokeRestart("muffleWarning")
[10:24:17.496]                       }
[10:24:17.496]                       else if (inherits(cond, "condition")) {
[10:24:17.496]                         if (!is.null(pattern)) {
[10:24:17.496]                           computeRestarts <- base::computeRestarts
[10:24:17.496]                           grepl <- base::grepl
[10:24:17.496]                           restarts <- computeRestarts(cond)
[10:24:17.496]                           for (restart in restarts) {
[10:24:17.496]                             name <- restart$name
[10:24:17.496]                             if (is.null(name)) 
[10:24:17.496]                               next
[10:24:17.496]                             if (!grepl(pattern, name)) 
[10:24:17.496]                               next
[10:24:17.496]                             invokeRestart(restart)
[10:24:17.496]                             muffled <- TRUE
[10:24:17.496]                             break
[10:24:17.496]                           }
[10:24:17.496]                         }
[10:24:17.496]                       }
[10:24:17.496]                       invisible(muffled)
[10:24:17.496]                     }
[10:24:17.496]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.496]                   }
[10:24:17.496]                 }
[10:24:17.496]             }
[10:24:17.496]         }))
[10:24:17.496]     }, error = function(ex) {
[10:24:17.496]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.496]                 ...future.rng), started = ...future.startTime, 
[10:24:17.496]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.496]             version = "1.8"), class = "FutureResult")
[10:24:17.496]     }, finally = {
[10:24:17.496]         if (!identical(...future.workdir, getwd())) 
[10:24:17.496]             setwd(...future.workdir)
[10:24:17.496]         {
[10:24:17.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.496]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.496]             }
[10:24:17.496]             base::options(...future.oldOptions)
[10:24:17.496]             if (.Platform$OS.type == "windows") {
[10:24:17.496]                 old_names <- names(...future.oldEnvVars)
[10:24:17.496]                 envs <- base::Sys.getenv()
[10:24:17.496]                 names <- names(envs)
[10:24:17.496]                 common <- intersect(names, old_names)
[10:24:17.496]                 added <- setdiff(names, old_names)
[10:24:17.496]                 removed <- setdiff(old_names, names)
[10:24:17.496]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.496]                   envs[common]]
[10:24:17.496]                 NAMES <- toupper(changed)
[10:24:17.496]                 args <- list()
[10:24:17.496]                 for (kk in seq_along(NAMES)) {
[10:24:17.496]                   name <- changed[[kk]]
[10:24:17.496]                   NAME <- NAMES[[kk]]
[10:24:17.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.496]                     next
[10:24:17.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.496]                 }
[10:24:17.496]                 NAMES <- toupper(added)
[10:24:17.496]                 for (kk in seq_along(NAMES)) {
[10:24:17.496]                   name <- added[[kk]]
[10:24:17.496]                   NAME <- NAMES[[kk]]
[10:24:17.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.496]                     next
[10:24:17.496]                   args[[name]] <- ""
[10:24:17.496]                 }
[10:24:17.496]                 NAMES <- toupper(removed)
[10:24:17.496]                 for (kk in seq_along(NAMES)) {
[10:24:17.496]                   name <- removed[[kk]]
[10:24:17.496]                   NAME <- NAMES[[kk]]
[10:24:17.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.496]                     next
[10:24:17.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.496]                 }
[10:24:17.496]                 if (length(args) > 0) 
[10:24:17.496]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.496]             }
[10:24:17.496]             else {
[10:24:17.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.496]             }
[10:24:17.496]             {
[10:24:17.496]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.496]                   0L) {
[10:24:17.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.496]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.496]                   base::options(opts)
[10:24:17.496]                 }
[10:24:17.496]                 {
[10:24:17.496]                   {
[10:24:17.496]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.496]                     NULL
[10:24:17.496]                   }
[10:24:17.496]                   options(future.plan = NULL)
[10:24:17.496]                   if (is.na(NA_character_)) 
[10:24:17.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.496]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.496]                     envir = parent.frame()) 
[10:24:17.496]                   {
[10:24:17.496]                     default_workers <- missing(workers)
[10:24:17.496]                     if (is.function(workers)) 
[10:24:17.496]                       workers <- workers()
[10:24:17.496]                     workers <- structure(as.integer(workers), 
[10:24:17.496]                       class = class(workers))
[10:24:17.496]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.496]                       1L)
[10:24:17.496]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.496]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.496]                       if (default_workers) 
[10:24:17.496]                         supportsMulticore(warn = TRUE)
[10:24:17.496]                       return(sequential(..., envir = envir))
[10:24:17.496]                     }
[10:24:17.496]                     oopts <- options(mc.cores = workers)
[10:24:17.496]                     on.exit(options(oopts))
[10:24:17.496]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.496]                       envir = envir)
[10:24:17.496]                     if (!future$lazy) 
[10:24:17.496]                       future <- run(future)
[10:24:17.496]                     invisible(future)
[10:24:17.496]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.496]                 }
[10:24:17.496]             }
[10:24:17.496]         }
[10:24:17.496]     })
[10:24:17.496]     if (TRUE) {
[10:24:17.496]         base::sink(type = "output", split = FALSE)
[10:24:17.496]         if (TRUE) {
[10:24:17.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.496]         }
[10:24:17.496]         else {
[10:24:17.496]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.496]         }
[10:24:17.496]         base::close(...future.stdout)
[10:24:17.496]         ...future.stdout <- NULL
[10:24:17.496]     }
[10:24:17.496]     ...future.result$conditions <- ...future.conditions
[10:24:17.496]     ...future.result$finished <- base::Sys.time()
[10:24:17.496]     ...future.result
[10:24:17.496] }
[10:24:17.499] assign_globals() ...
[10:24:17.499] List of 11
[10:24:17.499]  $ ...future.FUN            :function (x, ...)  
[10:24:17.499]  $ x_FUN                    :function (x)  
[10:24:17.499]  $ times                    : int 2
[10:24:17.499]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.499]  $ stop_if_not              :function (...)  
[10:24:17.499]  $ dim                      : NULL
[10:24:17.499]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:17.499]  $ future.call.arguments    : list()
[10:24:17.499]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.499]  $ ...future.elements_ii    :List of 5
[10:24:17.499]   ..$ : int 1
[10:24:17.499]   ..$ : int 2
[10:24:17.499]   ..$ : int 3
[10:24:17.499]   ..$ : int 4
[10:24:17.499]   ..$ : int 5
[10:24:17.499]  $ ...future.seeds_ii       : NULL
[10:24:17.499]  $ ...future.globals.maxSize: NULL
[10:24:17.499]  - attr(*, "where")=List of 11
[10:24:17.499]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.499]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.499]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.499]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.499]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.499]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.499]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.499]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.499]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.499]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.499]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.499]  - attr(*, "resolved")= logi FALSE
[10:24:17.499]  - attr(*, "total_size")= num 96456
[10:24:17.499]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.499]  - attr(*, "already-done")= logi TRUE
[10:24:17.509] - copied ‘...future.FUN’ to environment
[10:24:17.509] - reassign environment for ‘x_FUN’
[10:24:17.509] - copied ‘x_FUN’ to environment
[10:24:17.509] - copied ‘times’ to environment
[10:24:17.509] - copied ‘stopf’ to environment
[10:24:17.509] - copied ‘stop_if_not’ to environment
[10:24:17.509] - copied ‘dim’ to environment
[10:24:17.509] - copied ‘valid_types’ to environment
[10:24:17.510] - copied ‘future.call.arguments’ to environment
[10:24:17.510] - copied ‘...future.elements_ii’ to environment
[10:24:17.510] - copied ‘...future.seeds_ii’ to environment
[10:24:17.510] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.510] assign_globals() ... done
[10:24:17.510] requestCore(): workers = 2
[10:24:17.512] MulticoreFuture started
[10:24:17.513] - Launch lazy future ... done
[10:24:17.513] run() for ‘MulticoreFuture’ ... done
[10:24:17.513] Created future:
[10:24:17.514] plan(): Setting new future strategy stack:
[10:24:17.514] List of future strategies:
[10:24:17.514] 1. sequential:
[10:24:17.514]    - args: function (..., envir = parent.frame())
[10:24:17.514]    - tweaked: FALSE
[10:24:17.514]    - call: NULL
[10:24:17.515] plan(): nbrOfWorkers() = 1
[10:24:17.517] plan(): Setting new future strategy stack:
[10:24:17.517] List of future strategies:
[10:24:17.517] 1. multicore:
[10:24:17.517]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.517]    - tweaked: FALSE
[10:24:17.517]    - call: plan(strategy)
[10:24:17.522] plan(): nbrOfWorkers() = 2
[10:24:17.513] MulticoreFuture:
[10:24:17.513] Label: ‘future_vapply-1’
[10:24:17.513] Expression:
[10:24:17.513] {
[10:24:17.513]     do.call(function(...) {
[10:24:17.513]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.513]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.513]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.513]             on.exit(options(oopts), add = TRUE)
[10:24:17.513]         }
[10:24:17.513]         {
[10:24:17.513]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.513]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.513]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.513]             })
[10:24:17.513]         }
[10:24:17.513]     }, args = future.call.arguments)
[10:24:17.513] }
[10:24:17.513] Lazy evaluation: FALSE
[10:24:17.513] Asynchronous evaluation: TRUE
[10:24:17.513] Local evaluation: TRUE
[10:24:17.513] Environment: R_GlobalEnv
[10:24:17.513] Capture standard output: TRUE
[10:24:17.513] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.513] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.513] Packages: 1 packages (‘future.apply’)
[10:24:17.513] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.513] Resolved: TRUE
[10:24:17.513] Value: <not collected>
[10:24:17.513] Conditions captured: <none>
[10:24:17.513] Early signaling: FALSE
[10:24:17.513] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.513] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.523] Chunk #1 of 2 ... DONE
[10:24:17.523] Chunk #2 of 2 ...
[10:24:17.523]  - Finding globals in 'X' for chunk #2 ...
[10:24:17.523] getGlobalsAndPackages() ...
[10:24:17.524] Searching for globals...
[10:24:17.524] 
[10:24:17.524] Searching for globals ... DONE
[10:24:17.524] - globals: [0] <none>
[10:24:17.524] getGlobalsAndPackages() ... DONE
[10:24:17.525]    + additional globals found: [n=0] 
[10:24:17.525]    + additional namespaces needed: [n=0] 
[10:24:17.525]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:17.525]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.525]  - seeds: <none>
[10:24:17.525]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.525] getGlobalsAndPackages() ...
[10:24:17.526] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.526] Resolving globals: FALSE
[10:24:17.526] Tweak future expression to call with '...' arguments ...
[10:24:17.526] {
[10:24:17.526]     do.call(function(...) {
[10:24:17.526]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.526]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.526]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.526]             on.exit(options(oopts), add = TRUE)
[10:24:17.526]         }
[10:24:17.526]         {
[10:24:17.526]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.526]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.526]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.526]             })
[10:24:17.526]         }
[10:24:17.526]     }, args = future.call.arguments)
[10:24:17.526] }
[10:24:17.527] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.527] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.528] - packages: [1] ‘future.apply’
[10:24:17.528] getGlobalsAndPackages() ... DONE
[10:24:17.528] run() for ‘Future’ ...
[10:24:17.529] - state: ‘created’
[10:24:17.529] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.533] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.533] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.534]   - Field: ‘label’
[10:24:17.534]   - Field: ‘local’
[10:24:17.534]   - Field: ‘owner’
[10:24:17.534]   - Field: ‘envir’
[10:24:17.534]   - Field: ‘workers’
[10:24:17.534]   - Field: ‘packages’
[10:24:17.535]   - Field: ‘gc’
[10:24:17.535]   - Field: ‘job’
[10:24:17.535]   - Field: ‘conditions’
[10:24:17.535]   - Field: ‘expr’
[10:24:17.535]   - Field: ‘uuid’
[10:24:17.535]   - Field: ‘seed’
[10:24:17.535]   - Field: ‘version’
[10:24:17.536]   - Field: ‘result’
[10:24:17.536]   - Field: ‘asynchronous’
[10:24:17.536]   - Field: ‘calls’
[10:24:17.536]   - Field: ‘globals’
[10:24:17.536]   - Field: ‘stdout’
[10:24:17.536]   - Field: ‘earlySignal’
[10:24:17.536]   - Field: ‘lazy’
[10:24:17.537]   - Field: ‘state’
[10:24:17.537] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.539] - Launch lazy future ...
[10:24:17.540] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.540] Packages needed by future strategies (n = 0): <none>
[10:24:17.542] {
[10:24:17.542]     {
[10:24:17.542]         {
[10:24:17.542]             ...future.startTime <- base::Sys.time()
[10:24:17.542]             {
[10:24:17.542]                 {
[10:24:17.542]                   {
[10:24:17.542]                     {
[10:24:17.542]                       {
[10:24:17.542]                         base::local({
[10:24:17.542]                           has_future <- base::requireNamespace("future", 
[10:24:17.542]                             quietly = TRUE)
[10:24:17.542]                           if (has_future) {
[10:24:17.542]                             ns <- base::getNamespace("future")
[10:24:17.542]                             version <- ns[[".package"]][["version"]]
[10:24:17.542]                             if (is.null(version)) 
[10:24:17.542]                               version <- utils::packageVersion("future")
[10:24:17.542]                           }
[10:24:17.542]                           else {
[10:24:17.542]                             version <- NULL
[10:24:17.542]                           }
[10:24:17.542]                           if (!has_future || version < "1.8.0") {
[10:24:17.542]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.542]                               "", base::R.version$version.string), 
[10:24:17.542]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.542]                                 base::R.version$platform, 8 * 
[10:24:17.542]                                   base::.Machine$sizeof.pointer), 
[10:24:17.542]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.542]                                 "release", "version")], collapse = " "), 
[10:24:17.542]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.542]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.542]                               info)
[10:24:17.542]                             info <- base::paste(info, collapse = "; ")
[10:24:17.542]                             if (!has_future) {
[10:24:17.542]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.542]                                 info)
[10:24:17.542]                             }
[10:24:17.542]                             else {
[10:24:17.542]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.542]                                 info, version)
[10:24:17.542]                             }
[10:24:17.542]                             base::stop(msg)
[10:24:17.542]                           }
[10:24:17.542]                         })
[10:24:17.542]                       }
[10:24:17.542]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.542]                       base::options(mc.cores = 1L)
[10:24:17.542]                     }
[10:24:17.542]                     base::local({
[10:24:17.542]                       for (pkg in "future.apply") {
[10:24:17.542]                         base::loadNamespace(pkg)
[10:24:17.542]                         base::library(pkg, character.only = TRUE)
[10:24:17.542]                       }
[10:24:17.542]                     })
[10:24:17.542]                   }
[10:24:17.542]                   options(future.plan = NULL)
[10:24:17.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.542]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.542]                 }
[10:24:17.542]                 ...future.workdir <- getwd()
[10:24:17.542]             }
[10:24:17.542]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.542]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.542]         }
[10:24:17.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.542]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.542]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.542]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.542]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.542]             base::names(...future.oldOptions))
[10:24:17.542]     }
[10:24:17.542]     if (FALSE) {
[10:24:17.542]     }
[10:24:17.542]     else {
[10:24:17.542]         if (TRUE) {
[10:24:17.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.542]                 open = "w")
[10:24:17.542]         }
[10:24:17.542]         else {
[10:24:17.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.542]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.542]         }
[10:24:17.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.542]             base::sink(type = "output", split = FALSE)
[10:24:17.542]             base::close(...future.stdout)
[10:24:17.542]         }, add = TRUE)
[10:24:17.542]     }
[10:24:17.542]     ...future.frame <- base::sys.nframe()
[10:24:17.542]     ...future.conditions <- base::list()
[10:24:17.542]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.542]     if (FALSE) {
[10:24:17.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.542]     }
[10:24:17.542]     ...future.result <- base::tryCatch({
[10:24:17.542]         base::withCallingHandlers({
[10:24:17.542]             ...future.value <- base::withVisible(base::local({
[10:24:17.542]                 withCallingHandlers({
[10:24:17.542]                   {
[10:24:17.542]                     do.call(function(...) {
[10:24:17.542]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.542]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.542]                         ...future.globals.maxSize)) {
[10:24:17.542]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.542]                         on.exit(options(oopts), add = TRUE)
[10:24:17.542]                       }
[10:24:17.542]                       {
[10:24:17.542]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.542]                           FUN = function(jj) {
[10:24:17.542]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.542]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.542]                           })
[10:24:17.542]                       }
[10:24:17.542]                     }, args = future.call.arguments)
[10:24:17.542]                   }
[10:24:17.542]                 }, immediateCondition = function(cond) {
[10:24:17.542]                   save_rds <- function (object, pathname, ...) 
[10:24:17.542]                   {
[10:24:17.542]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.542]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.542]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.542]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.542]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.542]                         fi_tmp[["mtime"]])
[10:24:17.542]                     }
[10:24:17.542]                     tryCatch({
[10:24:17.542]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.542]                     }, error = function(ex) {
[10:24:17.542]                       msg <- conditionMessage(ex)
[10:24:17.542]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.542]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.542]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.542]                         fi_tmp[["mtime"]], msg)
[10:24:17.542]                       ex$message <- msg
[10:24:17.542]                       stop(ex)
[10:24:17.542]                     })
[10:24:17.542]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.542]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.542]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.542]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.542]                       fi <- file.info(pathname)
[10:24:17.542]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.542]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.542]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.542]                         fi[["size"]], fi[["mtime"]])
[10:24:17.542]                       stop(msg)
[10:24:17.542]                     }
[10:24:17.542]                     invisible(pathname)
[10:24:17.542]                   }
[10:24:17.542]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.542]                     rootPath = tempdir()) 
[10:24:17.542]                   {
[10:24:17.542]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.542]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.542]                       tmpdir = path, fileext = ".rds")
[10:24:17.542]                     save_rds(obj, file)
[10:24:17.542]                   }
[10:24:17.542]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.542]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.542]                   {
[10:24:17.542]                     inherits <- base::inherits
[10:24:17.542]                     invokeRestart <- base::invokeRestart
[10:24:17.542]                     is.null <- base::is.null
[10:24:17.542]                     muffled <- FALSE
[10:24:17.542]                     if (inherits(cond, "message")) {
[10:24:17.542]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.542]                       if (muffled) 
[10:24:17.542]                         invokeRestart("muffleMessage")
[10:24:17.542]                     }
[10:24:17.542]                     else if (inherits(cond, "warning")) {
[10:24:17.542]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.542]                       if (muffled) 
[10:24:17.542]                         invokeRestart("muffleWarning")
[10:24:17.542]                     }
[10:24:17.542]                     else if (inherits(cond, "condition")) {
[10:24:17.542]                       if (!is.null(pattern)) {
[10:24:17.542]                         computeRestarts <- base::computeRestarts
[10:24:17.542]                         grepl <- base::grepl
[10:24:17.542]                         restarts <- computeRestarts(cond)
[10:24:17.542]                         for (restart in restarts) {
[10:24:17.542]                           name <- restart$name
[10:24:17.542]                           if (is.null(name)) 
[10:24:17.542]                             next
[10:24:17.542]                           if (!grepl(pattern, name)) 
[10:24:17.542]                             next
[10:24:17.542]                           invokeRestart(restart)
[10:24:17.542]                           muffled <- TRUE
[10:24:17.542]                           break
[10:24:17.542]                         }
[10:24:17.542]                       }
[10:24:17.542]                     }
[10:24:17.542]                     invisible(muffled)
[10:24:17.542]                   }
[10:24:17.542]                   muffleCondition(cond)
[10:24:17.542]                 })
[10:24:17.542]             }))
[10:24:17.542]             future::FutureResult(value = ...future.value$value, 
[10:24:17.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.542]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.542]                     ...future.globalenv.names))
[10:24:17.542]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.542]         }, condition = base::local({
[10:24:17.542]             c <- base::c
[10:24:17.542]             inherits <- base::inherits
[10:24:17.542]             invokeRestart <- base::invokeRestart
[10:24:17.542]             length <- base::length
[10:24:17.542]             list <- base::list
[10:24:17.542]             seq.int <- base::seq.int
[10:24:17.542]             signalCondition <- base::signalCondition
[10:24:17.542]             sys.calls <- base::sys.calls
[10:24:17.542]             `[[` <- base::`[[`
[10:24:17.542]             `+` <- base::`+`
[10:24:17.542]             `<<-` <- base::`<<-`
[10:24:17.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.542]                   3L)]
[10:24:17.542]             }
[10:24:17.542]             function(cond) {
[10:24:17.542]                 is_error <- inherits(cond, "error")
[10:24:17.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.542]                   NULL)
[10:24:17.542]                 if (is_error) {
[10:24:17.542]                   sessionInformation <- function() {
[10:24:17.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.542]                       search = base::search(), system = base::Sys.info())
[10:24:17.542]                   }
[10:24:17.542]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.542]                     cond$call), session = sessionInformation(), 
[10:24:17.542]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.542]                   signalCondition(cond)
[10:24:17.542]                 }
[10:24:17.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.542]                 "immediateCondition"))) {
[10:24:17.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.542]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.542]                   if (TRUE && !signal) {
[10:24:17.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.542]                     {
[10:24:17.542]                       inherits <- base::inherits
[10:24:17.542]                       invokeRestart <- base::invokeRestart
[10:24:17.542]                       is.null <- base::is.null
[10:24:17.542]                       muffled <- FALSE
[10:24:17.542]                       if (inherits(cond, "message")) {
[10:24:17.542]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.542]                         if (muffled) 
[10:24:17.542]                           invokeRestart("muffleMessage")
[10:24:17.542]                       }
[10:24:17.542]                       else if (inherits(cond, "warning")) {
[10:24:17.542]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.542]                         if (muffled) 
[10:24:17.542]                           invokeRestart("muffleWarning")
[10:24:17.542]                       }
[10:24:17.542]                       else if (inherits(cond, "condition")) {
[10:24:17.542]                         if (!is.null(pattern)) {
[10:24:17.542]                           computeRestarts <- base::computeRestarts
[10:24:17.542]                           grepl <- base::grepl
[10:24:17.542]                           restarts <- computeRestarts(cond)
[10:24:17.542]                           for (restart in restarts) {
[10:24:17.542]                             name <- restart$name
[10:24:17.542]                             if (is.null(name)) 
[10:24:17.542]                               next
[10:24:17.542]                             if (!grepl(pattern, name)) 
[10:24:17.542]                               next
[10:24:17.542]                             invokeRestart(restart)
[10:24:17.542]                             muffled <- TRUE
[10:24:17.542]                             break
[10:24:17.542]                           }
[10:24:17.542]                         }
[10:24:17.542]                       }
[10:24:17.542]                       invisible(muffled)
[10:24:17.542]                     }
[10:24:17.542]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.542]                   }
[10:24:17.542]                 }
[10:24:17.542]                 else {
[10:24:17.542]                   if (TRUE) {
[10:24:17.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.542]                     {
[10:24:17.542]                       inherits <- base::inherits
[10:24:17.542]                       invokeRestart <- base::invokeRestart
[10:24:17.542]                       is.null <- base::is.null
[10:24:17.542]                       muffled <- FALSE
[10:24:17.542]                       if (inherits(cond, "message")) {
[10:24:17.542]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.542]                         if (muffled) 
[10:24:17.542]                           invokeRestart("muffleMessage")
[10:24:17.542]                       }
[10:24:17.542]                       else if (inherits(cond, "warning")) {
[10:24:17.542]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.542]                         if (muffled) 
[10:24:17.542]                           invokeRestart("muffleWarning")
[10:24:17.542]                       }
[10:24:17.542]                       else if (inherits(cond, "condition")) {
[10:24:17.542]                         if (!is.null(pattern)) {
[10:24:17.542]                           computeRestarts <- base::computeRestarts
[10:24:17.542]                           grepl <- base::grepl
[10:24:17.542]                           restarts <- computeRestarts(cond)
[10:24:17.542]                           for (restart in restarts) {
[10:24:17.542]                             name <- restart$name
[10:24:17.542]                             if (is.null(name)) 
[10:24:17.542]                               next
[10:24:17.542]                             if (!grepl(pattern, name)) 
[10:24:17.542]                               next
[10:24:17.542]                             invokeRestart(restart)
[10:24:17.542]                             muffled <- TRUE
[10:24:17.542]                             break
[10:24:17.542]                           }
[10:24:17.542]                         }
[10:24:17.542]                       }
[10:24:17.542]                       invisible(muffled)
[10:24:17.542]                     }
[10:24:17.542]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.542]                   }
[10:24:17.542]                 }
[10:24:17.542]             }
[10:24:17.542]         }))
[10:24:17.542]     }, error = function(ex) {
[10:24:17.542]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.542]                 ...future.rng), started = ...future.startTime, 
[10:24:17.542]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.542]             version = "1.8"), class = "FutureResult")
[10:24:17.542]     }, finally = {
[10:24:17.542]         if (!identical(...future.workdir, getwd())) 
[10:24:17.542]             setwd(...future.workdir)
[10:24:17.542]         {
[10:24:17.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.542]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.542]             }
[10:24:17.542]             base::options(...future.oldOptions)
[10:24:17.542]             if (.Platform$OS.type == "windows") {
[10:24:17.542]                 old_names <- names(...future.oldEnvVars)
[10:24:17.542]                 envs <- base::Sys.getenv()
[10:24:17.542]                 names <- names(envs)
[10:24:17.542]                 common <- intersect(names, old_names)
[10:24:17.542]                 added <- setdiff(names, old_names)
[10:24:17.542]                 removed <- setdiff(old_names, names)
[10:24:17.542]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.542]                   envs[common]]
[10:24:17.542]                 NAMES <- toupper(changed)
[10:24:17.542]                 args <- list()
[10:24:17.542]                 for (kk in seq_along(NAMES)) {
[10:24:17.542]                   name <- changed[[kk]]
[10:24:17.542]                   NAME <- NAMES[[kk]]
[10:24:17.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.542]                     next
[10:24:17.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.542]                 }
[10:24:17.542]                 NAMES <- toupper(added)
[10:24:17.542]                 for (kk in seq_along(NAMES)) {
[10:24:17.542]                   name <- added[[kk]]
[10:24:17.542]                   NAME <- NAMES[[kk]]
[10:24:17.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.542]                     next
[10:24:17.542]                   args[[name]] <- ""
[10:24:17.542]                 }
[10:24:17.542]                 NAMES <- toupper(removed)
[10:24:17.542]                 for (kk in seq_along(NAMES)) {
[10:24:17.542]                   name <- removed[[kk]]
[10:24:17.542]                   NAME <- NAMES[[kk]]
[10:24:17.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.542]                     next
[10:24:17.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.542]                 }
[10:24:17.542]                 if (length(args) > 0) 
[10:24:17.542]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.542]             }
[10:24:17.542]             else {
[10:24:17.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.542]             }
[10:24:17.542]             {
[10:24:17.542]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.542]                   0L) {
[10:24:17.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.542]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.542]                   base::options(opts)
[10:24:17.542]                 }
[10:24:17.542]                 {
[10:24:17.542]                   {
[10:24:17.542]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.542]                     NULL
[10:24:17.542]                   }
[10:24:17.542]                   options(future.plan = NULL)
[10:24:17.542]                   if (is.na(NA_character_)) 
[10:24:17.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.542]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.542]                     envir = parent.frame()) 
[10:24:17.542]                   {
[10:24:17.542]                     default_workers <- missing(workers)
[10:24:17.542]                     if (is.function(workers)) 
[10:24:17.542]                       workers <- workers()
[10:24:17.542]                     workers <- structure(as.integer(workers), 
[10:24:17.542]                       class = class(workers))
[10:24:17.542]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.542]                       1L)
[10:24:17.542]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.542]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.542]                       if (default_workers) 
[10:24:17.542]                         supportsMulticore(warn = TRUE)
[10:24:17.542]                       return(sequential(..., envir = envir))
[10:24:17.542]                     }
[10:24:17.542]                     oopts <- options(mc.cores = workers)
[10:24:17.542]                     on.exit(options(oopts))
[10:24:17.542]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.542]                       envir = envir)
[10:24:17.542]                     if (!future$lazy) 
[10:24:17.542]                       future <- run(future)
[10:24:17.542]                     invisible(future)
[10:24:17.542]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.542]                 }
[10:24:17.542]             }
[10:24:17.542]         }
[10:24:17.542]     })
[10:24:17.542]     if (TRUE) {
[10:24:17.542]         base::sink(type = "output", split = FALSE)
[10:24:17.542]         if (TRUE) {
[10:24:17.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.542]         }
[10:24:17.542]         else {
[10:24:17.542]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.542]         }
[10:24:17.542]         base::close(...future.stdout)
[10:24:17.542]         ...future.stdout <- NULL
[10:24:17.542]     }
[10:24:17.542]     ...future.result$conditions <- ...future.conditions
[10:24:17.542]     ...future.result$finished <- base::Sys.time()
[10:24:17.542]     ...future.result
[10:24:17.542] }
[10:24:17.546] assign_globals() ...
[10:24:17.546] List of 11
[10:24:17.546]  $ ...future.FUN            :function (x, ...)  
[10:24:17.546]  $ x_FUN                    :function (x)  
[10:24:17.546]  $ times                    : int 2
[10:24:17.546]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.546]  $ stop_if_not              :function (...)  
[10:24:17.546]  $ dim                      : NULL
[10:24:17.546]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:17.546]  $ future.call.arguments    : list()
[10:24:17.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.546]  $ ...future.elements_ii    :List of 5
[10:24:17.546]   ..$ : int 6
[10:24:17.546]   ..$ : int 7
[10:24:17.546]   ..$ : int 8
[10:24:17.546]   ..$ : int 9
[10:24:17.546]   ..$ : int 10
[10:24:17.546]  $ ...future.seeds_ii       : NULL
[10:24:17.546]  $ ...future.globals.maxSize: NULL
[10:24:17.546]  - attr(*, "where")=List of 11
[10:24:17.546]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.546]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.546]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.546]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.546]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.546]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.546]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.546]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.546]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.546]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.546]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.546]  - attr(*, "resolved")= logi FALSE
[10:24:17.546]  - attr(*, "total_size")= num 96456
[10:24:17.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.546]  - attr(*, "already-done")= logi TRUE
[10:24:17.559] - copied ‘...future.FUN’ to environment
[10:24:17.559] - reassign environment for ‘x_FUN’
[10:24:17.560] - copied ‘x_FUN’ to environment
[10:24:17.560] - copied ‘times’ to environment
[10:24:17.560] - copied ‘stopf’ to environment
[10:24:17.560] - copied ‘stop_if_not’ to environment
[10:24:17.560] - copied ‘dim’ to environment
[10:24:17.560] - copied ‘valid_types’ to environment
[10:24:17.560] - copied ‘future.call.arguments’ to environment
[10:24:17.560] - copied ‘...future.elements_ii’ to environment
[10:24:17.560] - copied ‘...future.seeds_ii’ to environment
[10:24:17.561] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.561] assign_globals() ... done
[10:24:17.561] requestCore(): workers = 2
[10:24:17.563] MulticoreFuture started
[10:24:17.563] - Launch lazy future ... done
[10:24:17.564] run() for ‘MulticoreFuture’ ... done
[10:24:17.564] Created future:
[10:24:17.564] plan(): Setting new future strategy stack:
[10:24:17.565] List of future strategies:
[10:24:17.565] 1. sequential:
[10:24:17.565]    - args: function (..., envir = parent.frame())
[10:24:17.565]    - tweaked: FALSE
[10:24:17.565]    - call: NULL
[10:24:17.565] plan(): nbrOfWorkers() = 1
[10:24:17.567] plan(): Setting new future strategy stack:
[10:24:17.568] List of future strategies:
[10:24:17.568] 1. multicore:
[10:24:17.568]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.568]    - tweaked: FALSE
[10:24:17.568]    - call: plan(strategy)
[10:24:17.573] plan(): nbrOfWorkers() = 2
[10:24:17.564] MulticoreFuture:
[10:24:17.564] Label: ‘future_vapply-2’
[10:24:17.564] Expression:
[10:24:17.564] {
[10:24:17.564]     do.call(function(...) {
[10:24:17.564]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.564]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.564]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.564]             on.exit(options(oopts), add = TRUE)
[10:24:17.564]         }
[10:24:17.564]         {
[10:24:17.564]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.564]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.564]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.564]             })
[10:24:17.564]         }
[10:24:17.564]     }, args = future.call.arguments)
[10:24:17.564] }
[10:24:17.564] Lazy evaluation: FALSE
[10:24:17.564] Asynchronous evaluation: TRUE
[10:24:17.564] Local evaluation: TRUE
[10:24:17.564] Environment: R_GlobalEnv
[10:24:17.564] Capture standard output: TRUE
[10:24:17.564] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.564] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.564] Packages: 1 packages (‘future.apply’)
[10:24:17.564] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.564] Resolved: TRUE
[10:24:17.564] Value: <not collected>
[10:24:17.564] Conditions captured: <none>
[10:24:17.564] Early signaling: FALSE
[10:24:17.564] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.564] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.574] Chunk #2 of 2 ... DONE
[10:24:17.574] Launching 2 futures (chunks) ... DONE
[10:24:17.574] Resolving 2 futures (chunks) ...
[10:24:17.574] resolve() on list ...
[10:24:17.574]  recursive: 0
[10:24:17.574]  length: 2
[10:24:17.575] 
[10:24:17.575] Future #1
[10:24:17.575] result() for MulticoreFuture ...
[10:24:17.576] result() for MulticoreFuture ...
[10:24:17.576] result() for MulticoreFuture ... done
[10:24:17.576] result() for MulticoreFuture ... done
[10:24:17.576] result() for MulticoreFuture ...
[10:24:17.577] result() for MulticoreFuture ... done
[10:24:17.577] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:17.577] - nx: 2
[10:24:17.577] - relay: TRUE
[10:24:17.577] - stdout: TRUE
[10:24:17.577] - signal: TRUE
[10:24:17.577] - resignal: FALSE
[10:24:17.578] - force: TRUE
[10:24:17.578] - relayed: [n=2] FALSE, FALSE
[10:24:17.578] - queued futures: [n=2] FALSE, FALSE
[10:24:17.578]  - until=1
[10:24:17.578]  - relaying element #1
[10:24:17.578] result() for MulticoreFuture ...
[10:24:17.578] result() for MulticoreFuture ... done
[10:24:17.579] result() for MulticoreFuture ...
[10:24:17.579] result() for MulticoreFuture ... done
[10:24:17.579] result() for MulticoreFuture ...
[10:24:17.579] result() for MulticoreFuture ... done
[10:24:17.579] result() for MulticoreFuture ...
[10:24:17.579] result() for MulticoreFuture ... done
[10:24:17.580] - relayed: [n=2] TRUE, FALSE
[10:24:17.580] - queued futures: [n=2] TRUE, FALSE
[10:24:17.580] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:17.580]  length: 1 (resolved future 1)
[10:24:17.580] Future #2
[10:24:17.581] result() for MulticoreFuture ...
[10:24:17.585] result() for MulticoreFuture ...
[10:24:17.585] result() for MulticoreFuture ... done
[10:24:17.586] result() for MulticoreFuture ... done
[10:24:17.586] result() for MulticoreFuture ...
[10:24:17.586] result() for MulticoreFuture ... done
[10:24:17.587] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:17.587] - nx: 2
[10:24:17.587] - relay: TRUE
[10:24:17.587] - stdout: TRUE
[10:24:17.587] - signal: TRUE
[10:24:17.587] - resignal: FALSE
[10:24:17.587] - force: TRUE
[10:24:17.588] - relayed: [n=2] TRUE, FALSE
[10:24:17.588] - queued futures: [n=2] TRUE, FALSE
[10:24:17.588]  - until=2
[10:24:17.588]  - relaying element #2
[10:24:17.588] result() for MulticoreFuture ...
[10:24:17.588] result() for MulticoreFuture ... done
[10:24:17.589] result() for MulticoreFuture ...
[10:24:17.589] result() for MulticoreFuture ... done
[10:24:17.589] result() for MulticoreFuture ...
[10:24:17.589] result() for MulticoreFuture ... done
[10:24:17.589] result() for MulticoreFuture ...
[10:24:17.589] result() for MulticoreFuture ... done
[10:24:17.590] - relayed: [n=2] TRUE, TRUE
[10:24:17.590] - queued futures: [n=2] TRUE, TRUE
[10:24:17.590] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:17.590]  length: 0 (resolved future 2)
[10:24:17.590] Relaying remaining futures
[10:24:17.590] signalConditionsASAP(NULL, pos=0) ...
[10:24:17.590] - nx: 2
[10:24:17.591] - relay: TRUE
[10:24:17.591] - stdout: TRUE
[10:24:17.591] - signal: TRUE
[10:24:17.591] - resignal: FALSE
[10:24:17.591] - force: TRUE
[10:24:17.591] - relayed: [n=2] TRUE, TRUE
[10:24:17.591] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:17.591] - relayed: [n=2] TRUE, TRUE
[10:24:17.591] - queued futures: [n=2] TRUE, TRUE
[10:24:17.592] signalConditionsASAP(NULL, pos=0) ... done
[10:24:17.592] resolve() on list ... DONE
[10:24:17.592] result() for MulticoreFuture ...
[10:24:17.592] result() for MulticoreFuture ... done
[10:24:17.592] result() for MulticoreFuture ...
[10:24:17.592] result() for MulticoreFuture ... done
[10:24:17.592] result() for MulticoreFuture ...
[10:24:17.592] result() for MulticoreFuture ... done
[10:24:17.593] result() for MulticoreFuture ...
[10:24:17.593] result() for MulticoreFuture ... done
[10:24:17.593]  - Number of value chunks collected: 2
[10:24:17.593] Resolving 2 futures (chunks) ... DONE
[10:24:17.593] Reducing values from 2 chunks ...
[10:24:17.593]  - Number of values collected after concatenation: 10
[10:24:17.593]  - Number of values expected: 10
[10:24:17.593] Reducing values from 2 chunks ... DONE
[10:24:17.594] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:24:17.595] future_lapply() ...
[10:24:17.601] Number of chunks: 2
[10:24:17.601] getGlobalsAndPackagesXApply() ...
[10:24:17.601]  - future.globals: TRUE
[10:24:17.601] getGlobalsAndPackages() ...
[10:24:17.601] Searching for globals...
[10:24:17.605] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:24:17.605] Searching for globals ... DONE
[10:24:17.605] Resolving globals: FALSE
[10:24:17.606] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[10:24:17.606] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:17.606] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.607] - packages: [1] ‘future.apply’
[10:24:17.607] getGlobalsAndPackages() ... DONE
[10:24:17.607]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.607]  - needed namespaces: [n=1] ‘future.apply’
[10:24:17.607] Finding globals ... DONE
[10:24:17.607]  - use_args: TRUE
[10:24:17.607]  - Getting '...' globals ...
[10:24:17.608] resolve() on list ...
[10:24:17.608]  recursive: 0
[10:24:17.608]  length: 1
[10:24:17.608]  elements: ‘...’
[10:24:17.608]  length: 0 (resolved future 1)
[10:24:17.608] resolve() on list ... DONE
[10:24:17.608]    - '...' content: [n=0] 
[10:24:17.608] List of 1
[10:24:17.608]  $ ...: list()
[10:24:17.608]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.608]  - attr(*, "where")=List of 1
[10:24:17.608]   ..$ ...:<environment: 0x55b93b3a4780> 
[10:24:17.608]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.608]  - attr(*, "resolved")= logi TRUE
[10:24:17.608]  - attr(*, "total_size")= num NA
[10:24:17.612]  - Getting '...' globals ... DONE
[10:24:17.613] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:17.613] List of 8
[10:24:17.613]  $ ...future.FUN:function (x, ...)  
[10:24:17.613]  $ x_FUN        :function (x)  
[10:24:17.613]  $ times        : int 4
[10:24:17.613]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.613]  $ stop_if_not  :function (...)  
[10:24:17.613]  $ dim          : int [1:2] 2 2
[10:24:17.613]  $ valid_types  : chr [1:2] "logical" "integer"
[10:24:17.613]  $ ...          : list()
[10:24:17.613]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.613]  - attr(*, "where")=List of 8
[10:24:17.613]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:17.613]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:17.613]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:17.613]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:17.613]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:17.613]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:17.613]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:17.613]   ..$ ...          :<environment: 0x55b93b3a4780> 
[10:24:17.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.613]  - attr(*, "resolved")= logi FALSE
[10:24:17.613]  - attr(*, "total_size")= num 97232
[10:24:17.618] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:17.619] getGlobalsAndPackagesXApply() ... DONE
[10:24:17.619] Number of futures (= number of chunks): 2
[10:24:17.619] Launching 2 futures (chunks) ...
[10:24:17.619] Chunk #1 of 2 ...
[10:24:17.619]  - Finding globals in 'X' for chunk #1 ...
[10:24:17.619] getGlobalsAndPackages() ...
[10:24:17.619] Searching for globals...
[10:24:17.619] 
[10:24:17.620] Searching for globals ... DONE
[10:24:17.620] - globals: [0] <none>
[10:24:17.620] getGlobalsAndPackages() ... DONE
[10:24:17.620]    + additional globals found: [n=0] 
[10:24:17.620]    + additional namespaces needed: [n=0] 
[10:24:17.620]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:17.620]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.620]  - seeds: <none>
[10:24:17.620]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.620] getGlobalsAndPackages() ...
[10:24:17.620] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.621] Resolving globals: FALSE
[10:24:17.621] Tweak future expression to call with '...' arguments ...
[10:24:17.621] {
[10:24:17.621]     do.call(function(...) {
[10:24:17.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.621]             on.exit(options(oopts), add = TRUE)
[10:24:17.621]         }
[10:24:17.621]         {
[10:24:17.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.621]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.621]             })
[10:24:17.621]         }
[10:24:17.621]     }, args = future.call.arguments)
[10:24:17.621] }
[10:24:17.621] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.622] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.622] - packages: [1] ‘future.apply’
[10:24:17.622] getGlobalsAndPackages() ... DONE
[10:24:17.622] run() for ‘Future’ ...
[10:24:17.622] - state: ‘created’
[10:24:17.622] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.626] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.626] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.626]   - Field: ‘label’
[10:24:17.626]   - Field: ‘local’
[10:24:17.626]   - Field: ‘owner’
[10:24:17.626]   - Field: ‘envir’
[10:24:17.627]   - Field: ‘workers’
[10:24:17.627]   - Field: ‘packages’
[10:24:17.627]   - Field: ‘gc’
[10:24:17.627]   - Field: ‘job’
[10:24:17.627]   - Field: ‘conditions’
[10:24:17.627]   - Field: ‘expr’
[10:24:17.627]   - Field: ‘uuid’
[10:24:17.627]   - Field: ‘seed’
[10:24:17.627]   - Field: ‘version’
[10:24:17.627]   - Field: ‘result’
[10:24:17.627]   - Field: ‘asynchronous’
[10:24:17.627]   - Field: ‘calls’
[10:24:17.628]   - Field: ‘globals’
[10:24:17.628]   - Field: ‘stdout’
[10:24:17.628]   - Field: ‘earlySignal’
[10:24:17.628]   - Field: ‘lazy’
[10:24:17.628]   - Field: ‘state’
[10:24:17.628] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.628] - Launch lazy future ...
[10:24:17.628] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.629] Packages needed by future strategies (n = 0): <none>
[10:24:17.629] {
[10:24:17.629]     {
[10:24:17.629]         {
[10:24:17.629]             ...future.startTime <- base::Sys.time()
[10:24:17.629]             {
[10:24:17.629]                 {
[10:24:17.629]                   {
[10:24:17.629]                     {
[10:24:17.629]                       {
[10:24:17.629]                         base::local({
[10:24:17.629]                           has_future <- base::requireNamespace("future", 
[10:24:17.629]                             quietly = TRUE)
[10:24:17.629]                           if (has_future) {
[10:24:17.629]                             ns <- base::getNamespace("future")
[10:24:17.629]                             version <- ns[[".package"]][["version"]]
[10:24:17.629]                             if (is.null(version)) 
[10:24:17.629]                               version <- utils::packageVersion("future")
[10:24:17.629]                           }
[10:24:17.629]                           else {
[10:24:17.629]                             version <- NULL
[10:24:17.629]                           }
[10:24:17.629]                           if (!has_future || version < "1.8.0") {
[10:24:17.629]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.629]                               "", base::R.version$version.string), 
[10:24:17.629]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.629]                                 base::R.version$platform, 8 * 
[10:24:17.629]                                   base::.Machine$sizeof.pointer), 
[10:24:17.629]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.629]                                 "release", "version")], collapse = " "), 
[10:24:17.629]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.629]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.629]                               info)
[10:24:17.629]                             info <- base::paste(info, collapse = "; ")
[10:24:17.629]                             if (!has_future) {
[10:24:17.629]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.629]                                 info)
[10:24:17.629]                             }
[10:24:17.629]                             else {
[10:24:17.629]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.629]                                 info, version)
[10:24:17.629]                             }
[10:24:17.629]                             base::stop(msg)
[10:24:17.629]                           }
[10:24:17.629]                         })
[10:24:17.629]                       }
[10:24:17.629]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.629]                       base::options(mc.cores = 1L)
[10:24:17.629]                     }
[10:24:17.629]                     base::local({
[10:24:17.629]                       for (pkg in "future.apply") {
[10:24:17.629]                         base::loadNamespace(pkg)
[10:24:17.629]                         base::library(pkg, character.only = TRUE)
[10:24:17.629]                       }
[10:24:17.629]                     })
[10:24:17.629]                   }
[10:24:17.629]                   options(future.plan = NULL)
[10:24:17.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.629]                 }
[10:24:17.629]                 ...future.workdir <- getwd()
[10:24:17.629]             }
[10:24:17.629]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.629]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.629]         }
[10:24:17.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.629]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.629]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.629]             base::names(...future.oldOptions))
[10:24:17.629]     }
[10:24:17.629]     if (FALSE) {
[10:24:17.629]     }
[10:24:17.629]     else {
[10:24:17.629]         if (TRUE) {
[10:24:17.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.629]                 open = "w")
[10:24:17.629]         }
[10:24:17.629]         else {
[10:24:17.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.629]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.629]         }
[10:24:17.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.629]             base::sink(type = "output", split = FALSE)
[10:24:17.629]             base::close(...future.stdout)
[10:24:17.629]         }, add = TRUE)
[10:24:17.629]     }
[10:24:17.629]     ...future.frame <- base::sys.nframe()
[10:24:17.629]     ...future.conditions <- base::list()
[10:24:17.629]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.629]     if (FALSE) {
[10:24:17.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.629]     }
[10:24:17.629]     ...future.result <- base::tryCatch({
[10:24:17.629]         base::withCallingHandlers({
[10:24:17.629]             ...future.value <- base::withVisible(base::local({
[10:24:17.629]                 withCallingHandlers({
[10:24:17.629]                   {
[10:24:17.629]                     do.call(function(...) {
[10:24:17.629]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.629]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.629]                         ...future.globals.maxSize)) {
[10:24:17.629]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.629]                         on.exit(options(oopts), add = TRUE)
[10:24:17.629]                       }
[10:24:17.629]                       {
[10:24:17.629]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.629]                           FUN = function(jj) {
[10:24:17.629]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.629]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.629]                           })
[10:24:17.629]                       }
[10:24:17.629]                     }, args = future.call.arguments)
[10:24:17.629]                   }
[10:24:17.629]                 }, immediateCondition = function(cond) {
[10:24:17.629]                   save_rds <- function (object, pathname, ...) 
[10:24:17.629]                   {
[10:24:17.629]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.629]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.629]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.629]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.629]                         fi_tmp[["mtime"]])
[10:24:17.629]                     }
[10:24:17.629]                     tryCatch({
[10:24:17.629]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.629]                     }, error = function(ex) {
[10:24:17.629]                       msg <- conditionMessage(ex)
[10:24:17.629]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.629]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.629]                         fi_tmp[["mtime"]], msg)
[10:24:17.629]                       ex$message <- msg
[10:24:17.629]                       stop(ex)
[10:24:17.629]                     })
[10:24:17.629]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.629]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.629]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.629]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.629]                       fi <- file.info(pathname)
[10:24:17.629]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.629]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.629]                         fi[["size"]], fi[["mtime"]])
[10:24:17.629]                       stop(msg)
[10:24:17.629]                     }
[10:24:17.629]                     invisible(pathname)
[10:24:17.629]                   }
[10:24:17.629]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.629]                     rootPath = tempdir()) 
[10:24:17.629]                   {
[10:24:17.629]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.629]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.629]                       tmpdir = path, fileext = ".rds")
[10:24:17.629]                     save_rds(obj, file)
[10:24:17.629]                   }
[10:24:17.629]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.629]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.629]                   {
[10:24:17.629]                     inherits <- base::inherits
[10:24:17.629]                     invokeRestart <- base::invokeRestart
[10:24:17.629]                     is.null <- base::is.null
[10:24:17.629]                     muffled <- FALSE
[10:24:17.629]                     if (inherits(cond, "message")) {
[10:24:17.629]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.629]                       if (muffled) 
[10:24:17.629]                         invokeRestart("muffleMessage")
[10:24:17.629]                     }
[10:24:17.629]                     else if (inherits(cond, "warning")) {
[10:24:17.629]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.629]                       if (muffled) 
[10:24:17.629]                         invokeRestart("muffleWarning")
[10:24:17.629]                     }
[10:24:17.629]                     else if (inherits(cond, "condition")) {
[10:24:17.629]                       if (!is.null(pattern)) {
[10:24:17.629]                         computeRestarts <- base::computeRestarts
[10:24:17.629]                         grepl <- base::grepl
[10:24:17.629]                         restarts <- computeRestarts(cond)
[10:24:17.629]                         for (restart in restarts) {
[10:24:17.629]                           name <- restart$name
[10:24:17.629]                           if (is.null(name)) 
[10:24:17.629]                             next
[10:24:17.629]                           if (!grepl(pattern, name)) 
[10:24:17.629]                             next
[10:24:17.629]                           invokeRestart(restart)
[10:24:17.629]                           muffled <- TRUE
[10:24:17.629]                           break
[10:24:17.629]                         }
[10:24:17.629]                       }
[10:24:17.629]                     }
[10:24:17.629]                     invisible(muffled)
[10:24:17.629]                   }
[10:24:17.629]                   muffleCondition(cond)
[10:24:17.629]                 })
[10:24:17.629]             }))
[10:24:17.629]             future::FutureResult(value = ...future.value$value, 
[10:24:17.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.629]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.629]                     ...future.globalenv.names))
[10:24:17.629]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.629]         }, condition = base::local({
[10:24:17.629]             c <- base::c
[10:24:17.629]             inherits <- base::inherits
[10:24:17.629]             invokeRestart <- base::invokeRestart
[10:24:17.629]             length <- base::length
[10:24:17.629]             list <- base::list
[10:24:17.629]             seq.int <- base::seq.int
[10:24:17.629]             signalCondition <- base::signalCondition
[10:24:17.629]             sys.calls <- base::sys.calls
[10:24:17.629]             `[[` <- base::`[[`
[10:24:17.629]             `+` <- base::`+`
[10:24:17.629]             `<<-` <- base::`<<-`
[10:24:17.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.629]                   3L)]
[10:24:17.629]             }
[10:24:17.629]             function(cond) {
[10:24:17.629]                 is_error <- inherits(cond, "error")
[10:24:17.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.629]                   NULL)
[10:24:17.629]                 if (is_error) {
[10:24:17.629]                   sessionInformation <- function() {
[10:24:17.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.629]                       search = base::search(), system = base::Sys.info())
[10:24:17.629]                   }
[10:24:17.629]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.629]                     cond$call), session = sessionInformation(), 
[10:24:17.629]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.629]                   signalCondition(cond)
[10:24:17.629]                 }
[10:24:17.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.629]                 "immediateCondition"))) {
[10:24:17.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.629]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.629]                   if (TRUE && !signal) {
[10:24:17.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.629]                     {
[10:24:17.629]                       inherits <- base::inherits
[10:24:17.629]                       invokeRestart <- base::invokeRestart
[10:24:17.629]                       is.null <- base::is.null
[10:24:17.629]                       muffled <- FALSE
[10:24:17.629]                       if (inherits(cond, "message")) {
[10:24:17.629]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.629]                         if (muffled) 
[10:24:17.629]                           invokeRestart("muffleMessage")
[10:24:17.629]                       }
[10:24:17.629]                       else if (inherits(cond, "warning")) {
[10:24:17.629]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.629]                         if (muffled) 
[10:24:17.629]                           invokeRestart("muffleWarning")
[10:24:17.629]                       }
[10:24:17.629]                       else if (inherits(cond, "condition")) {
[10:24:17.629]                         if (!is.null(pattern)) {
[10:24:17.629]                           computeRestarts <- base::computeRestarts
[10:24:17.629]                           grepl <- base::grepl
[10:24:17.629]                           restarts <- computeRestarts(cond)
[10:24:17.629]                           for (restart in restarts) {
[10:24:17.629]                             name <- restart$name
[10:24:17.629]                             if (is.null(name)) 
[10:24:17.629]                               next
[10:24:17.629]                             if (!grepl(pattern, name)) 
[10:24:17.629]                               next
[10:24:17.629]                             invokeRestart(restart)
[10:24:17.629]                             muffled <- TRUE
[10:24:17.629]                             break
[10:24:17.629]                           }
[10:24:17.629]                         }
[10:24:17.629]                       }
[10:24:17.629]                       invisible(muffled)
[10:24:17.629]                     }
[10:24:17.629]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.629]                   }
[10:24:17.629]                 }
[10:24:17.629]                 else {
[10:24:17.629]                   if (TRUE) {
[10:24:17.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.629]                     {
[10:24:17.629]                       inherits <- base::inherits
[10:24:17.629]                       invokeRestart <- base::invokeRestart
[10:24:17.629]                       is.null <- base::is.null
[10:24:17.629]                       muffled <- FALSE
[10:24:17.629]                       if (inherits(cond, "message")) {
[10:24:17.629]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.629]                         if (muffled) 
[10:24:17.629]                           invokeRestart("muffleMessage")
[10:24:17.629]                       }
[10:24:17.629]                       else if (inherits(cond, "warning")) {
[10:24:17.629]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.629]                         if (muffled) 
[10:24:17.629]                           invokeRestart("muffleWarning")
[10:24:17.629]                       }
[10:24:17.629]                       else if (inherits(cond, "condition")) {
[10:24:17.629]                         if (!is.null(pattern)) {
[10:24:17.629]                           computeRestarts <- base::computeRestarts
[10:24:17.629]                           grepl <- base::grepl
[10:24:17.629]                           restarts <- computeRestarts(cond)
[10:24:17.629]                           for (restart in restarts) {
[10:24:17.629]                             name <- restart$name
[10:24:17.629]                             if (is.null(name)) 
[10:24:17.629]                               next
[10:24:17.629]                             if (!grepl(pattern, name)) 
[10:24:17.629]                               next
[10:24:17.629]                             invokeRestart(restart)
[10:24:17.629]                             muffled <- TRUE
[10:24:17.629]                             break
[10:24:17.629]                           }
[10:24:17.629]                         }
[10:24:17.629]                       }
[10:24:17.629]                       invisible(muffled)
[10:24:17.629]                     }
[10:24:17.629]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.629]                   }
[10:24:17.629]                 }
[10:24:17.629]             }
[10:24:17.629]         }))
[10:24:17.629]     }, error = function(ex) {
[10:24:17.629]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.629]                 ...future.rng), started = ...future.startTime, 
[10:24:17.629]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.629]             version = "1.8"), class = "FutureResult")
[10:24:17.629]     }, finally = {
[10:24:17.629]         if (!identical(...future.workdir, getwd())) 
[10:24:17.629]             setwd(...future.workdir)
[10:24:17.629]         {
[10:24:17.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.629]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.629]             }
[10:24:17.629]             base::options(...future.oldOptions)
[10:24:17.629]             if (.Platform$OS.type == "windows") {
[10:24:17.629]                 old_names <- names(...future.oldEnvVars)
[10:24:17.629]                 envs <- base::Sys.getenv()
[10:24:17.629]                 names <- names(envs)
[10:24:17.629]                 common <- intersect(names, old_names)
[10:24:17.629]                 added <- setdiff(names, old_names)
[10:24:17.629]                 removed <- setdiff(old_names, names)
[10:24:17.629]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.629]                   envs[common]]
[10:24:17.629]                 NAMES <- toupper(changed)
[10:24:17.629]                 args <- list()
[10:24:17.629]                 for (kk in seq_along(NAMES)) {
[10:24:17.629]                   name <- changed[[kk]]
[10:24:17.629]                   NAME <- NAMES[[kk]]
[10:24:17.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.629]                     next
[10:24:17.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.629]                 }
[10:24:17.629]                 NAMES <- toupper(added)
[10:24:17.629]                 for (kk in seq_along(NAMES)) {
[10:24:17.629]                   name <- added[[kk]]
[10:24:17.629]                   NAME <- NAMES[[kk]]
[10:24:17.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.629]                     next
[10:24:17.629]                   args[[name]] <- ""
[10:24:17.629]                 }
[10:24:17.629]                 NAMES <- toupper(removed)
[10:24:17.629]                 for (kk in seq_along(NAMES)) {
[10:24:17.629]                   name <- removed[[kk]]
[10:24:17.629]                   NAME <- NAMES[[kk]]
[10:24:17.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.629]                     next
[10:24:17.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.629]                 }
[10:24:17.629]                 if (length(args) > 0) 
[10:24:17.629]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.629]             }
[10:24:17.629]             else {
[10:24:17.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.629]             }
[10:24:17.629]             {
[10:24:17.629]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.629]                   0L) {
[10:24:17.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.629]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.629]                   base::options(opts)
[10:24:17.629]                 }
[10:24:17.629]                 {
[10:24:17.629]                   {
[10:24:17.629]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.629]                     NULL
[10:24:17.629]                   }
[10:24:17.629]                   options(future.plan = NULL)
[10:24:17.629]                   if (is.na(NA_character_)) 
[10:24:17.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.629]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.629]                     envir = parent.frame()) 
[10:24:17.629]                   {
[10:24:17.629]                     default_workers <- missing(workers)
[10:24:17.629]                     if (is.function(workers)) 
[10:24:17.629]                       workers <- workers()
[10:24:17.629]                     workers <- structure(as.integer(workers), 
[10:24:17.629]                       class = class(workers))
[10:24:17.629]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.629]                       1L)
[10:24:17.629]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.629]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.629]                       if (default_workers) 
[10:24:17.629]                         supportsMulticore(warn = TRUE)
[10:24:17.629]                       return(sequential(..., envir = envir))
[10:24:17.629]                     }
[10:24:17.629]                     oopts <- options(mc.cores = workers)
[10:24:17.629]                     on.exit(options(oopts))
[10:24:17.629]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.629]                       envir = envir)
[10:24:17.629]                     if (!future$lazy) 
[10:24:17.629]                       future <- run(future)
[10:24:17.629]                     invisible(future)
[10:24:17.629]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.629]                 }
[10:24:17.629]             }
[10:24:17.629]         }
[10:24:17.629]     })
[10:24:17.629]     if (TRUE) {
[10:24:17.629]         base::sink(type = "output", split = FALSE)
[10:24:17.629]         if (TRUE) {
[10:24:17.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.629]         }
[10:24:17.629]         else {
[10:24:17.629]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.629]         }
[10:24:17.629]         base::close(...future.stdout)
[10:24:17.629]         ...future.stdout <- NULL
[10:24:17.629]     }
[10:24:17.629]     ...future.result$conditions <- ...future.conditions
[10:24:17.629]     ...future.result$finished <- base::Sys.time()
[10:24:17.629]     ...future.result
[10:24:17.629] }
[10:24:17.632] assign_globals() ...
[10:24:17.632] List of 11
[10:24:17.632]  $ ...future.FUN            :function (x, ...)  
[10:24:17.632]  $ x_FUN                    :function (x)  
[10:24:17.632]  $ times                    : int 4
[10:24:17.632]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.632]  $ stop_if_not              :function (...)  
[10:24:17.632]  $ dim                      : int [1:2] 2 2
[10:24:17.632]  $ valid_types              : chr [1:2] "logical" "integer"
[10:24:17.632]  $ future.call.arguments    : list()
[10:24:17.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.632]  $ ...future.elements_ii    :List of 5
[10:24:17.632]   ..$ : int 1
[10:24:17.632]   ..$ : int 2
[10:24:17.632]   ..$ : int 3
[10:24:17.632]   ..$ : int 4
[10:24:17.632]   ..$ : int 5
[10:24:17.632]  $ ...future.seeds_ii       : NULL
[10:24:17.632]  $ ...future.globals.maxSize: NULL
[10:24:17.632]  - attr(*, "where")=List of 11
[10:24:17.632]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.632]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.632]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.632]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.632]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.632]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.632]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.632]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.632]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.632]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.632]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.632]  - attr(*, "resolved")= logi FALSE
[10:24:17.632]  - attr(*, "total_size")= num 97232
[10:24:17.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.632]  - attr(*, "already-done")= logi TRUE
[10:24:17.642] - copied ‘...future.FUN’ to environment
[10:24:17.642] - reassign environment for ‘x_FUN’
[10:24:17.642] - copied ‘x_FUN’ to environment
[10:24:17.642] - copied ‘times’ to environment
[10:24:17.642] - copied ‘stopf’ to environment
[10:24:17.642] - copied ‘stop_if_not’ to environment
[10:24:17.642] - copied ‘dim’ to environment
[10:24:17.642] - copied ‘valid_types’ to environment
[10:24:17.642] - copied ‘future.call.arguments’ to environment
[10:24:17.642] - copied ‘...future.elements_ii’ to environment
[10:24:17.643] - copied ‘...future.seeds_ii’ to environment
[10:24:17.643] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.643] assign_globals() ... done
[10:24:17.643] requestCore(): workers = 2
[10:24:17.645] MulticoreFuture started
[10:24:17.645] - Launch lazy future ... done
[10:24:17.646] run() for ‘MulticoreFuture’ ... done
[10:24:17.646] Created future:
[10:24:17.647] plan(): Setting new future strategy stack:
[10:24:17.647] List of future strategies:
[10:24:17.647] 1. sequential:
[10:24:17.647]    - args: function (..., envir = parent.frame())
[10:24:17.647]    - tweaked: FALSE
[10:24:17.647]    - call: NULL
[10:24:17.647] plan(): nbrOfWorkers() = 1
[10:24:17.649] plan(): Setting new future strategy stack:
[10:24:17.650] List of future strategies:
[10:24:17.650] 1. multicore:
[10:24:17.650]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.650]    - tweaked: FALSE
[10:24:17.650]    - call: plan(strategy)
[10:24:17.655] plan(): nbrOfWorkers() = 2
[10:24:17.646] MulticoreFuture:
[10:24:17.646] Label: ‘future_vapply-1’
[10:24:17.646] Expression:
[10:24:17.646] {
[10:24:17.646]     do.call(function(...) {
[10:24:17.646]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.646]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.646]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.646]             on.exit(options(oopts), add = TRUE)
[10:24:17.646]         }
[10:24:17.646]         {
[10:24:17.646]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.646]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.646]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.646]             })
[10:24:17.646]         }
[10:24:17.646]     }, args = future.call.arguments)
[10:24:17.646] }
[10:24:17.646] Lazy evaluation: FALSE
[10:24:17.646] Asynchronous evaluation: TRUE
[10:24:17.646] Local evaluation: TRUE
[10:24:17.646] Environment: R_GlobalEnv
[10:24:17.646] Capture standard output: TRUE
[10:24:17.646] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.646] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.646] Packages: 1 packages (‘future.apply’)
[10:24:17.646] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.646] Resolved: TRUE
[10:24:17.646] Value: <not collected>
[10:24:17.646] Conditions captured: <none>
[10:24:17.646] Early signaling: FALSE
[10:24:17.646] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.646] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.656] Chunk #1 of 2 ... DONE
[10:24:17.656] Chunk #2 of 2 ...
[10:24:17.656]  - Finding globals in 'X' for chunk #2 ...
[10:24:17.656] getGlobalsAndPackages() ...
[10:24:17.656] Searching for globals...
[10:24:17.657] 
[10:24:17.657] Searching for globals ... DONE
[10:24:17.657] - globals: [0] <none>
[10:24:17.657] getGlobalsAndPackages() ... DONE
[10:24:17.657]    + additional globals found: [n=0] 
[10:24:17.658]    + additional namespaces needed: [n=0] 
[10:24:17.658]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:17.658]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.658]  - seeds: <none>
[10:24:17.658]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.658] getGlobalsAndPackages() ...
[10:24:17.658] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.659] Resolving globals: FALSE
[10:24:17.659] Tweak future expression to call with '...' arguments ...
[10:24:17.659] {
[10:24:17.659]     do.call(function(...) {
[10:24:17.659]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.659]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.659]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.659]             on.exit(options(oopts), add = TRUE)
[10:24:17.659]         }
[10:24:17.659]         {
[10:24:17.659]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.659]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.659]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.659]             })
[10:24:17.659]         }
[10:24:17.659]     }, args = future.call.arguments)
[10:24:17.659] }
[10:24:17.659] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.660] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.660] - packages: [1] ‘future.apply’
[10:24:17.661] getGlobalsAndPackages() ... DONE
[10:24:17.661] run() for ‘Future’ ...
[10:24:17.661] - state: ‘created’
[10:24:17.661] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.666] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.666]   - Field: ‘label’
[10:24:17.666]   - Field: ‘local’
[10:24:17.667]   - Field: ‘owner’
[10:24:17.667]   - Field: ‘envir’
[10:24:17.667]   - Field: ‘workers’
[10:24:17.667]   - Field: ‘packages’
[10:24:17.667]   - Field: ‘gc’
[10:24:17.667]   - Field: ‘job’
[10:24:17.675]   - Field: ‘conditions’
[10:24:17.675]   - Field: ‘expr’
[10:24:17.675]   - Field: ‘uuid’
[10:24:17.675]   - Field: ‘seed’
[10:24:17.675]   - Field: ‘version’
[10:24:17.675]   - Field: ‘result’
[10:24:17.675]   - Field: ‘asynchronous’
[10:24:17.676]   - Field: ‘calls’
[10:24:17.676]   - Field: ‘globals’
[10:24:17.676]   - Field: ‘stdout’
[10:24:17.676]   - Field: ‘earlySignal’
[10:24:17.676]   - Field: ‘lazy’
[10:24:17.676]   - Field: ‘state’
[10:24:17.676] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.676] - Launch lazy future ...
[10:24:17.677] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.677] Packages needed by future strategies (n = 0): <none>
[10:24:17.678] {
[10:24:17.678]     {
[10:24:17.678]         {
[10:24:17.678]             ...future.startTime <- base::Sys.time()
[10:24:17.678]             {
[10:24:17.678]                 {
[10:24:17.678]                   {
[10:24:17.678]                     {
[10:24:17.678]                       {
[10:24:17.678]                         base::local({
[10:24:17.678]                           has_future <- base::requireNamespace("future", 
[10:24:17.678]                             quietly = TRUE)
[10:24:17.678]                           if (has_future) {
[10:24:17.678]                             ns <- base::getNamespace("future")
[10:24:17.678]                             version <- ns[[".package"]][["version"]]
[10:24:17.678]                             if (is.null(version)) 
[10:24:17.678]                               version <- utils::packageVersion("future")
[10:24:17.678]                           }
[10:24:17.678]                           else {
[10:24:17.678]                             version <- NULL
[10:24:17.678]                           }
[10:24:17.678]                           if (!has_future || version < "1.8.0") {
[10:24:17.678]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.678]                               "", base::R.version$version.string), 
[10:24:17.678]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.678]                                 base::R.version$platform, 8 * 
[10:24:17.678]                                   base::.Machine$sizeof.pointer), 
[10:24:17.678]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.678]                                 "release", "version")], collapse = " "), 
[10:24:17.678]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.678]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.678]                               info)
[10:24:17.678]                             info <- base::paste(info, collapse = "; ")
[10:24:17.678]                             if (!has_future) {
[10:24:17.678]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.678]                                 info)
[10:24:17.678]                             }
[10:24:17.678]                             else {
[10:24:17.678]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.678]                                 info, version)
[10:24:17.678]                             }
[10:24:17.678]                             base::stop(msg)
[10:24:17.678]                           }
[10:24:17.678]                         })
[10:24:17.678]                       }
[10:24:17.678]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.678]                       base::options(mc.cores = 1L)
[10:24:17.678]                     }
[10:24:17.678]                     base::local({
[10:24:17.678]                       for (pkg in "future.apply") {
[10:24:17.678]                         base::loadNamespace(pkg)
[10:24:17.678]                         base::library(pkg, character.only = TRUE)
[10:24:17.678]                       }
[10:24:17.678]                     })
[10:24:17.678]                   }
[10:24:17.678]                   options(future.plan = NULL)
[10:24:17.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.678]                 }
[10:24:17.678]                 ...future.workdir <- getwd()
[10:24:17.678]             }
[10:24:17.678]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.678]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.678]         }
[10:24:17.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.678]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.678]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.678]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.678]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.678]             base::names(...future.oldOptions))
[10:24:17.678]     }
[10:24:17.678]     if (FALSE) {
[10:24:17.678]     }
[10:24:17.678]     else {
[10:24:17.678]         if (TRUE) {
[10:24:17.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.678]                 open = "w")
[10:24:17.678]         }
[10:24:17.678]         else {
[10:24:17.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.678]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.678]         }
[10:24:17.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.678]             base::sink(type = "output", split = FALSE)
[10:24:17.678]             base::close(...future.stdout)
[10:24:17.678]         }, add = TRUE)
[10:24:17.678]     }
[10:24:17.678]     ...future.frame <- base::sys.nframe()
[10:24:17.678]     ...future.conditions <- base::list()
[10:24:17.678]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.678]     if (FALSE) {
[10:24:17.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.678]     }
[10:24:17.678]     ...future.result <- base::tryCatch({
[10:24:17.678]         base::withCallingHandlers({
[10:24:17.678]             ...future.value <- base::withVisible(base::local({
[10:24:17.678]                 withCallingHandlers({
[10:24:17.678]                   {
[10:24:17.678]                     do.call(function(...) {
[10:24:17.678]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.678]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.678]                         ...future.globals.maxSize)) {
[10:24:17.678]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.678]                         on.exit(options(oopts), add = TRUE)
[10:24:17.678]                       }
[10:24:17.678]                       {
[10:24:17.678]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.678]                           FUN = function(jj) {
[10:24:17.678]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.678]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.678]                           })
[10:24:17.678]                       }
[10:24:17.678]                     }, args = future.call.arguments)
[10:24:17.678]                   }
[10:24:17.678]                 }, immediateCondition = function(cond) {
[10:24:17.678]                   save_rds <- function (object, pathname, ...) 
[10:24:17.678]                   {
[10:24:17.678]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.678]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.678]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.678]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.678]                         fi_tmp[["mtime"]])
[10:24:17.678]                     }
[10:24:17.678]                     tryCatch({
[10:24:17.678]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.678]                     }, error = function(ex) {
[10:24:17.678]                       msg <- conditionMessage(ex)
[10:24:17.678]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.678]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.678]                         fi_tmp[["mtime"]], msg)
[10:24:17.678]                       ex$message <- msg
[10:24:17.678]                       stop(ex)
[10:24:17.678]                     })
[10:24:17.678]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.678]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.678]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.678]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.678]                       fi <- file.info(pathname)
[10:24:17.678]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.678]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.678]                         fi[["size"]], fi[["mtime"]])
[10:24:17.678]                       stop(msg)
[10:24:17.678]                     }
[10:24:17.678]                     invisible(pathname)
[10:24:17.678]                   }
[10:24:17.678]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.678]                     rootPath = tempdir()) 
[10:24:17.678]                   {
[10:24:17.678]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.678]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.678]                       tmpdir = path, fileext = ".rds")
[10:24:17.678]                     save_rds(obj, file)
[10:24:17.678]                   }
[10:24:17.678]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.678]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.678]                   {
[10:24:17.678]                     inherits <- base::inherits
[10:24:17.678]                     invokeRestart <- base::invokeRestart
[10:24:17.678]                     is.null <- base::is.null
[10:24:17.678]                     muffled <- FALSE
[10:24:17.678]                     if (inherits(cond, "message")) {
[10:24:17.678]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.678]                       if (muffled) 
[10:24:17.678]                         invokeRestart("muffleMessage")
[10:24:17.678]                     }
[10:24:17.678]                     else if (inherits(cond, "warning")) {
[10:24:17.678]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.678]                       if (muffled) 
[10:24:17.678]                         invokeRestart("muffleWarning")
[10:24:17.678]                     }
[10:24:17.678]                     else if (inherits(cond, "condition")) {
[10:24:17.678]                       if (!is.null(pattern)) {
[10:24:17.678]                         computeRestarts <- base::computeRestarts
[10:24:17.678]                         grepl <- base::grepl
[10:24:17.678]                         restarts <- computeRestarts(cond)
[10:24:17.678]                         for (restart in restarts) {
[10:24:17.678]                           name <- restart$name
[10:24:17.678]                           if (is.null(name)) 
[10:24:17.678]                             next
[10:24:17.678]                           if (!grepl(pattern, name)) 
[10:24:17.678]                             next
[10:24:17.678]                           invokeRestart(restart)
[10:24:17.678]                           muffled <- TRUE
[10:24:17.678]                           break
[10:24:17.678]                         }
[10:24:17.678]                       }
[10:24:17.678]                     }
[10:24:17.678]                     invisible(muffled)
[10:24:17.678]                   }
[10:24:17.678]                   muffleCondition(cond)
[10:24:17.678]                 })
[10:24:17.678]             }))
[10:24:17.678]             future::FutureResult(value = ...future.value$value, 
[10:24:17.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.678]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.678]                     ...future.globalenv.names))
[10:24:17.678]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.678]         }, condition = base::local({
[10:24:17.678]             c <- base::c
[10:24:17.678]             inherits <- base::inherits
[10:24:17.678]             invokeRestart <- base::invokeRestart
[10:24:17.678]             length <- base::length
[10:24:17.678]             list <- base::list
[10:24:17.678]             seq.int <- base::seq.int
[10:24:17.678]             signalCondition <- base::signalCondition
[10:24:17.678]             sys.calls <- base::sys.calls
[10:24:17.678]             `[[` <- base::`[[`
[10:24:17.678]             `+` <- base::`+`
[10:24:17.678]             `<<-` <- base::`<<-`
[10:24:17.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.678]                   3L)]
[10:24:17.678]             }
[10:24:17.678]             function(cond) {
[10:24:17.678]                 is_error <- inherits(cond, "error")
[10:24:17.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.678]                   NULL)
[10:24:17.678]                 if (is_error) {
[10:24:17.678]                   sessionInformation <- function() {
[10:24:17.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.678]                       search = base::search(), system = base::Sys.info())
[10:24:17.678]                   }
[10:24:17.678]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.678]                     cond$call), session = sessionInformation(), 
[10:24:17.678]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.678]                   signalCondition(cond)
[10:24:17.678]                 }
[10:24:17.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.678]                 "immediateCondition"))) {
[10:24:17.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.678]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.678]                   if (TRUE && !signal) {
[10:24:17.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.678]                     {
[10:24:17.678]                       inherits <- base::inherits
[10:24:17.678]                       invokeRestart <- base::invokeRestart
[10:24:17.678]                       is.null <- base::is.null
[10:24:17.678]                       muffled <- FALSE
[10:24:17.678]                       if (inherits(cond, "message")) {
[10:24:17.678]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.678]                         if (muffled) 
[10:24:17.678]                           invokeRestart("muffleMessage")
[10:24:17.678]                       }
[10:24:17.678]                       else if (inherits(cond, "warning")) {
[10:24:17.678]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.678]                         if (muffled) 
[10:24:17.678]                           invokeRestart("muffleWarning")
[10:24:17.678]                       }
[10:24:17.678]                       else if (inherits(cond, "condition")) {
[10:24:17.678]                         if (!is.null(pattern)) {
[10:24:17.678]                           computeRestarts <- base::computeRestarts
[10:24:17.678]                           grepl <- base::grepl
[10:24:17.678]                           restarts <- computeRestarts(cond)
[10:24:17.678]                           for (restart in restarts) {
[10:24:17.678]                             name <- restart$name
[10:24:17.678]                             if (is.null(name)) 
[10:24:17.678]                               next
[10:24:17.678]                             if (!grepl(pattern, name)) 
[10:24:17.678]                               next
[10:24:17.678]                             invokeRestart(restart)
[10:24:17.678]                             muffled <- TRUE
[10:24:17.678]                             break
[10:24:17.678]                           }
[10:24:17.678]                         }
[10:24:17.678]                       }
[10:24:17.678]                       invisible(muffled)
[10:24:17.678]                     }
[10:24:17.678]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.678]                   }
[10:24:17.678]                 }
[10:24:17.678]                 else {
[10:24:17.678]                   if (TRUE) {
[10:24:17.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.678]                     {
[10:24:17.678]                       inherits <- base::inherits
[10:24:17.678]                       invokeRestart <- base::invokeRestart
[10:24:17.678]                       is.null <- base::is.null
[10:24:17.678]                       muffled <- FALSE
[10:24:17.678]                       if (inherits(cond, "message")) {
[10:24:17.678]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.678]                         if (muffled) 
[10:24:17.678]                           invokeRestart("muffleMessage")
[10:24:17.678]                       }
[10:24:17.678]                       else if (inherits(cond, "warning")) {
[10:24:17.678]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.678]                         if (muffled) 
[10:24:17.678]                           invokeRestart("muffleWarning")
[10:24:17.678]                       }
[10:24:17.678]                       else if (inherits(cond, "condition")) {
[10:24:17.678]                         if (!is.null(pattern)) {
[10:24:17.678]                           computeRestarts <- base::computeRestarts
[10:24:17.678]                           grepl <- base::grepl
[10:24:17.678]                           restarts <- computeRestarts(cond)
[10:24:17.678]                           for (restart in restarts) {
[10:24:17.678]                             name <- restart$name
[10:24:17.678]                             if (is.null(name)) 
[10:24:17.678]                               next
[10:24:17.678]                             if (!grepl(pattern, name)) 
[10:24:17.678]                               next
[10:24:17.678]                             invokeRestart(restart)
[10:24:17.678]                             muffled <- TRUE
[10:24:17.678]                             break
[10:24:17.678]                           }
[10:24:17.678]                         }
[10:24:17.678]                       }
[10:24:17.678]                       invisible(muffled)
[10:24:17.678]                     }
[10:24:17.678]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.678]                   }
[10:24:17.678]                 }
[10:24:17.678]             }
[10:24:17.678]         }))
[10:24:17.678]     }, error = function(ex) {
[10:24:17.678]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.678]                 ...future.rng), started = ...future.startTime, 
[10:24:17.678]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.678]             version = "1.8"), class = "FutureResult")
[10:24:17.678]     }, finally = {
[10:24:17.678]         if (!identical(...future.workdir, getwd())) 
[10:24:17.678]             setwd(...future.workdir)
[10:24:17.678]         {
[10:24:17.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.678]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.678]             }
[10:24:17.678]             base::options(...future.oldOptions)
[10:24:17.678]             if (.Platform$OS.type == "windows") {
[10:24:17.678]                 old_names <- names(...future.oldEnvVars)
[10:24:17.678]                 envs <- base::Sys.getenv()
[10:24:17.678]                 names <- names(envs)
[10:24:17.678]                 common <- intersect(names, old_names)
[10:24:17.678]                 added <- setdiff(names, old_names)
[10:24:17.678]                 removed <- setdiff(old_names, names)
[10:24:17.678]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.678]                   envs[common]]
[10:24:17.678]                 NAMES <- toupper(changed)
[10:24:17.678]                 args <- list()
[10:24:17.678]                 for (kk in seq_along(NAMES)) {
[10:24:17.678]                   name <- changed[[kk]]
[10:24:17.678]                   NAME <- NAMES[[kk]]
[10:24:17.678]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.678]                     next
[10:24:17.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.678]                 }
[10:24:17.678]                 NAMES <- toupper(added)
[10:24:17.678]                 for (kk in seq_along(NAMES)) {
[10:24:17.678]                   name <- added[[kk]]
[10:24:17.678]                   NAME <- NAMES[[kk]]
[10:24:17.678]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.678]                     next
[10:24:17.678]                   args[[name]] <- ""
[10:24:17.678]                 }
[10:24:17.678]                 NAMES <- toupper(removed)
[10:24:17.678]                 for (kk in seq_along(NAMES)) {
[10:24:17.678]                   name <- removed[[kk]]
[10:24:17.678]                   NAME <- NAMES[[kk]]
[10:24:17.678]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.678]                     next
[10:24:17.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.678]                 }
[10:24:17.678]                 if (length(args) > 0) 
[10:24:17.678]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.678]             }
[10:24:17.678]             else {
[10:24:17.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.678]             }
[10:24:17.678]             {
[10:24:17.678]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.678]                   0L) {
[10:24:17.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.678]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.678]                   base::options(opts)
[10:24:17.678]                 }
[10:24:17.678]                 {
[10:24:17.678]                   {
[10:24:17.678]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.678]                     NULL
[10:24:17.678]                   }
[10:24:17.678]                   options(future.plan = NULL)
[10:24:17.678]                   if (is.na(NA_character_)) 
[10:24:17.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.678]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.678]                     envir = parent.frame()) 
[10:24:17.678]                   {
[10:24:17.678]                     default_workers <- missing(workers)
[10:24:17.678]                     if (is.function(workers)) 
[10:24:17.678]                       workers <- workers()
[10:24:17.678]                     workers <- structure(as.integer(workers), 
[10:24:17.678]                       class = class(workers))
[10:24:17.678]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.678]                       1L)
[10:24:17.678]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.678]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.678]                       if (default_workers) 
[10:24:17.678]                         supportsMulticore(warn = TRUE)
[10:24:17.678]                       return(sequential(..., envir = envir))
[10:24:17.678]                     }
[10:24:17.678]                     oopts <- options(mc.cores = workers)
[10:24:17.678]                     on.exit(options(oopts))
[10:24:17.678]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.678]                       envir = envir)
[10:24:17.678]                     if (!future$lazy) 
[10:24:17.678]                       future <- run(future)
[10:24:17.678]                     invisible(future)
[10:24:17.678]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.678]                 }
[10:24:17.678]             }
[10:24:17.678]         }
[10:24:17.678]     })
[10:24:17.678]     if (TRUE) {
[10:24:17.678]         base::sink(type = "output", split = FALSE)
[10:24:17.678]         if (TRUE) {
[10:24:17.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.678]         }
[10:24:17.678]         else {
[10:24:17.678]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.678]         }
[10:24:17.678]         base::close(...future.stdout)
[10:24:17.678]         ...future.stdout <- NULL
[10:24:17.678]     }
[10:24:17.678]     ...future.result$conditions <- ...future.conditions
[10:24:17.678]     ...future.result$finished <- base::Sys.time()
[10:24:17.678]     ...future.result
[10:24:17.678] }
[10:24:17.681] assign_globals() ...
[10:24:17.682] List of 11
[10:24:17.682]  $ ...future.FUN            :function (x, ...)  
[10:24:17.682]  $ x_FUN                    :function (x)  
[10:24:17.682]  $ times                    : int 4
[10:24:17.682]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.682]  $ stop_if_not              :function (...)  
[10:24:17.682]  $ dim                      : int [1:2] 2 2
[10:24:17.682]  $ valid_types              : chr [1:2] "logical" "integer"
[10:24:17.682]  $ future.call.arguments    : list()
[10:24:17.682]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.682]  $ ...future.elements_ii    :List of 5
[10:24:17.682]   ..$ : int 6
[10:24:17.682]   ..$ : int 7
[10:24:17.682]   ..$ : int 8
[10:24:17.682]   ..$ : int 9
[10:24:17.682]   ..$ : int 10
[10:24:17.682]  $ ...future.seeds_ii       : NULL
[10:24:17.682]  $ ...future.globals.maxSize: NULL
[10:24:17.682]  - attr(*, "where")=List of 11
[10:24:17.682]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.682]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.682]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.682]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.682]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.682]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.682]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.682]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.682]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.682]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.682]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.682]  - attr(*, "resolved")= logi FALSE
[10:24:17.682]  - attr(*, "total_size")= num 97232
[10:24:17.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.682]  - attr(*, "already-done")= logi TRUE
[10:24:17.695] - copied ‘...future.FUN’ to environment
[10:24:17.695] - reassign environment for ‘x_FUN’
[10:24:17.695] - copied ‘x_FUN’ to environment
[10:24:17.695] - copied ‘times’ to environment
[10:24:17.695] - copied ‘stopf’ to environment
[10:24:17.695] - copied ‘stop_if_not’ to environment
[10:24:17.695] - copied ‘dim’ to environment
[10:24:17.695] - copied ‘valid_types’ to environment
[10:24:17.695] - copied ‘future.call.arguments’ to environment
[10:24:17.695] - copied ‘...future.elements_ii’ to environment
[10:24:17.696] - copied ‘...future.seeds_ii’ to environment
[10:24:17.696] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.696] assign_globals() ... done
[10:24:17.696] requestCore(): workers = 2
[10:24:17.698] MulticoreFuture started
[10:24:17.698] - Launch lazy future ... done
[10:24:17.699] run() for ‘MulticoreFuture’ ... done
[10:24:17.699] Created future:
[10:24:17.700] plan(): Setting new future strategy stack:
[10:24:17.700] List of future strategies:
[10:24:17.700] 1. sequential:
[10:24:17.700]    - args: function (..., envir = parent.frame())
[10:24:17.700]    - tweaked: FALSE
[10:24:17.700]    - call: NULL
[10:24:17.701] plan(): nbrOfWorkers() = 1
[10:24:17.703] plan(): Setting new future strategy stack:
[10:24:17.703] List of future strategies:
[10:24:17.703] 1. multicore:
[10:24:17.703]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.703]    - tweaked: FALSE
[10:24:17.703]    - call: plan(strategy)
[10:24:17.708] plan(): nbrOfWorkers() = 2
[10:24:17.699] MulticoreFuture:
[10:24:17.699] Label: ‘future_vapply-2’
[10:24:17.699] Expression:
[10:24:17.699] {
[10:24:17.699]     do.call(function(...) {
[10:24:17.699]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.699]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.699]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.699]             on.exit(options(oopts), add = TRUE)
[10:24:17.699]         }
[10:24:17.699]         {
[10:24:17.699]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.699]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.699]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.699]             })
[10:24:17.699]         }
[10:24:17.699]     }, args = future.call.arguments)
[10:24:17.699] }
[10:24:17.699] Lazy evaluation: FALSE
[10:24:17.699] Asynchronous evaluation: TRUE
[10:24:17.699] Local evaluation: TRUE
[10:24:17.699] Environment: R_GlobalEnv
[10:24:17.699] Capture standard output: TRUE
[10:24:17.699] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.699] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.699] Packages: 1 packages (‘future.apply’)
[10:24:17.699] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.699] Resolved: TRUE
[10:24:17.699] Value: <not collected>
[10:24:17.699] Conditions captured: <none>
[10:24:17.699] Early signaling: FALSE
[10:24:17.699] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.699] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.709] Chunk #2 of 2 ... DONE
[10:24:17.709] Launching 2 futures (chunks) ... DONE
[10:24:17.709] Resolving 2 futures (chunks) ...
[10:24:17.710] resolve() on list ...
[10:24:17.710]  recursive: 0
[10:24:17.710]  length: 2
[10:24:17.710] 
[10:24:17.710] Future #1
[10:24:17.711] result() for MulticoreFuture ...
[10:24:17.711] result() for MulticoreFuture ...
[10:24:17.712] result() for MulticoreFuture ... done
[10:24:17.712] result() for MulticoreFuture ... done
[10:24:17.712] result() for MulticoreFuture ...
[10:24:17.712] result() for MulticoreFuture ... done
[10:24:17.712] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:17.712] - nx: 2
[10:24:17.712] - relay: TRUE
[10:24:17.713] - stdout: TRUE
[10:24:17.713] - signal: TRUE
[10:24:17.713] - resignal: FALSE
[10:24:17.713] - force: TRUE
[10:24:17.713] - relayed: [n=2] FALSE, FALSE
[10:24:17.713] - queued futures: [n=2] FALSE, FALSE
[10:24:17.714]  - until=1
[10:24:17.714]  - relaying element #1
[10:24:17.714] result() for MulticoreFuture ...
[10:24:17.714] result() for MulticoreFuture ... done
[10:24:17.714] result() for MulticoreFuture ...
[10:24:17.714] result() for MulticoreFuture ... done
[10:24:17.715] result() for MulticoreFuture ...
[10:24:17.715] result() for MulticoreFuture ... done
[10:24:17.715] result() for MulticoreFuture ...
[10:24:17.715] result() for MulticoreFuture ... done
[10:24:17.715] - relayed: [n=2] TRUE, FALSE
[10:24:17.715] - queued futures: [n=2] TRUE, FALSE
[10:24:17.715] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:17.719]  length: 1 (resolved future 1)
[10:24:17.720] Future #2
[10:24:17.720] result() for MulticoreFuture ...
[10:24:17.721] result() for MulticoreFuture ...
[10:24:17.722] result() for MulticoreFuture ... done
[10:24:17.722] result() for MulticoreFuture ... done
[10:24:17.722] result() for MulticoreFuture ...
[10:24:17.722] result() for MulticoreFuture ... done
[10:24:17.723] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:17.723] - nx: 2
[10:24:17.723] - relay: TRUE
[10:24:17.723] - stdout: TRUE
[10:24:17.723] - signal: TRUE
[10:24:17.723] - resignal: FALSE
[10:24:17.723] - force: TRUE
[10:24:17.724] - relayed: [n=2] TRUE, FALSE
[10:24:17.724] - queued futures: [n=2] TRUE, FALSE
[10:24:17.724]  - until=2
[10:24:17.724]  - relaying element #2
[10:24:17.724] result() for MulticoreFuture ...
[10:24:17.724] result() for MulticoreFuture ... done
[10:24:17.725] result() for MulticoreFuture ...
[10:24:17.725] result() for MulticoreFuture ... done
[10:24:17.725] result() for MulticoreFuture ...
[10:24:17.725] result() for MulticoreFuture ... done
[10:24:17.725] result() for MulticoreFuture ...
[10:24:17.725] result() for MulticoreFuture ... done
[10:24:17.726] - relayed: [n=2] TRUE, TRUE
[10:24:17.726] - queued futures: [n=2] TRUE, TRUE
[10:24:17.726] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:17.726]  length: 0 (resolved future 2)
[10:24:17.726] Relaying remaining futures
[10:24:17.726] signalConditionsASAP(NULL, pos=0) ...
[10:24:17.726] - nx: 2
[10:24:17.727] - relay: TRUE
[10:24:17.727] - stdout: TRUE
[10:24:17.727] - signal: TRUE
[10:24:17.727] - resignal: FALSE
[10:24:17.727] - force: TRUE
[10:24:17.727] - relayed: [n=2] TRUE, TRUE
[10:24:17.727] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:17.728] - relayed: [n=2] TRUE, TRUE
[10:24:17.728] - queued futures: [n=2] TRUE, TRUE
[10:24:17.728] signalConditionsASAP(NULL, pos=0) ... done
[10:24:17.728] resolve() on list ... DONE
[10:24:17.728] result() for MulticoreFuture ...
[10:24:17.728] result() for MulticoreFuture ... done
[10:24:17.728] result() for MulticoreFuture ...
[10:24:17.728] result() for MulticoreFuture ... done
[10:24:17.729] result() for MulticoreFuture ...
[10:24:17.729] result() for MulticoreFuture ... done
[10:24:17.729] result() for MulticoreFuture ...
[10:24:17.729] result() for MulticoreFuture ... done
[10:24:17.729]  - Number of value chunks collected: 2
[10:24:17.729] Resolving 2 futures (chunks) ... DONE
[10:24:17.729] Reducing values from 2 chunks ...
[10:24:17.729]  - Number of values collected after concatenation: 10
[10:24:17.729]  - Number of values expected: 10
[10:24:17.730] Reducing values from 2 chunks ... DONE
[10:24:17.730] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:24:17.731] future_lapply() ...
[10:24:17.737] Number of chunks: 2
[10:24:17.737] getGlobalsAndPackagesXApply() ...
[10:24:17.737]  - future.globals: TRUE
[10:24:17.737] getGlobalsAndPackages() ...
[10:24:17.737] Searching for globals...
[10:24:17.741] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:24:17.741] Searching for globals ... DONE
[10:24:17.741] Resolving globals: FALSE
[10:24:17.742] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[10:24:17.742] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:17.743] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.743] - packages: [1] ‘future.apply’
[10:24:17.743] getGlobalsAndPackages() ... DONE
[10:24:17.743]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.743]  - needed namespaces: [n=1] ‘future.apply’
[10:24:17.743] Finding globals ... DONE
[10:24:17.743]  - use_args: TRUE
[10:24:17.743]  - Getting '...' globals ...
[10:24:17.744] resolve() on list ...
[10:24:17.744]  recursive: 0
[10:24:17.744]  length: 1
[10:24:17.744]  elements: ‘...’
[10:24:17.744]  length: 0 (resolved future 1)
[10:24:17.744] resolve() on list ... DONE
[10:24:17.744]    - '...' content: [n=0] 
[10:24:17.744] List of 1
[10:24:17.744]  $ ...: list()
[10:24:17.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.744]  - attr(*, "where")=List of 1
[10:24:17.744]   ..$ ...:<environment: 0x55b93b6c7e10> 
[10:24:17.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.744]  - attr(*, "resolved")= logi TRUE
[10:24:17.744]  - attr(*, "total_size")= num NA
[10:24:17.748]  - Getting '...' globals ... DONE
[10:24:17.749] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:17.749] List of 8
[10:24:17.749]  $ ...future.FUN:function (x, ...)  
[10:24:17.749]  $ x_FUN        :function (x)  
[10:24:17.749]  $ times        : int 4
[10:24:17.749]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.749]  $ stop_if_not  :function (...)  
[10:24:17.749]  $ dim          : int [1:2] 2 2
[10:24:17.749]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:17.749]  $ ...          : list()
[10:24:17.749]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.749]  - attr(*, "where")=List of 8
[10:24:17.749]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:17.749]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:17.749]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:17.749]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:17.749]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:17.749]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:17.749]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:17.749]   ..$ ...          :<environment: 0x55b93b6c7e10> 
[10:24:17.749]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.749]  - attr(*, "resolved")= logi FALSE
[10:24:17.749]  - attr(*, "total_size")= num 97304
[10:24:17.755] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:17.755] getGlobalsAndPackagesXApply() ... DONE
[10:24:17.755] Number of futures (= number of chunks): 2
[10:24:17.755] Launching 2 futures (chunks) ...
[10:24:17.755] Chunk #1 of 2 ...
[10:24:17.755]  - Finding globals in 'X' for chunk #1 ...
[10:24:17.755] getGlobalsAndPackages() ...
[10:24:17.755] Searching for globals...
[10:24:17.756] 
[10:24:17.756] Searching for globals ... DONE
[10:24:17.756] - globals: [0] <none>
[10:24:17.756] getGlobalsAndPackages() ... DONE
[10:24:17.756]    + additional globals found: [n=0] 
[10:24:17.756]    + additional namespaces needed: [n=0] 
[10:24:17.756]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:17.756]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.756]  - seeds: <none>
[10:24:17.756]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.757] getGlobalsAndPackages() ...
[10:24:17.757] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.757] Resolving globals: FALSE
[10:24:17.757] Tweak future expression to call with '...' arguments ...
[10:24:17.757] {
[10:24:17.757]     do.call(function(...) {
[10:24:17.757]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.757]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.757]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.757]             on.exit(options(oopts), add = TRUE)
[10:24:17.757]         }
[10:24:17.757]         {
[10:24:17.757]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.757]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.757]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.757]             })
[10:24:17.757]         }
[10:24:17.757]     }, args = future.call.arguments)
[10:24:17.757] }
[10:24:17.757] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.758] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.758] - packages: [1] ‘future.apply’
[10:24:17.758] getGlobalsAndPackages() ... DONE
[10:24:17.758] run() for ‘Future’ ...
[10:24:17.758] - state: ‘created’
[10:24:17.759] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.762] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.762]   - Field: ‘label’
[10:24:17.762]   - Field: ‘local’
[10:24:17.763]   - Field: ‘owner’
[10:24:17.763]   - Field: ‘envir’
[10:24:17.763]   - Field: ‘workers’
[10:24:17.763]   - Field: ‘packages’
[10:24:17.763]   - Field: ‘gc’
[10:24:17.763]   - Field: ‘job’
[10:24:17.763]   - Field: ‘conditions’
[10:24:17.763]   - Field: ‘expr’
[10:24:17.763]   - Field: ‘uuid’
[10:24:17.763]   - Field: ‘seed’
[10:24:17.763]   - Field: ‘version’
[10:24:17.764]   - Field: ‘result’
[10:24:17.764]   - Field: ‘asynchronous’
[10:24:17.764]   - Field: ‘calls’
[10:24:17.764]   - Field: ‘globals’
[10:24:17.764]   - Field: ‘stdout’
[10:24:17.764]   - Field: ‘earlySignal’
[10:24:17.764]   - Field: ‘lazy’
[10:24:17.764]   - Field: ‘state’
[10:24:17.764] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.764] - Launch lazy future ...
[10:24:17.765] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.765] Packages needed by future strategies (n = 0): <none>
[10:24:17.765] {
[10:24:17.765]     {
[10:24:17.765]         {
[10:24:17.765]             ...future.startTime <- base::Sys.time()
[10:24:17.765]             {
[10:24:17.765]                 {
[10:24:17.765]                   {
[10:24:17.765]                     {
[10:24:17.765]                       {
[10:24:17.765]                         base::local({
[10:24:17.765]                           has_future <- base::requireNamespace("future", 
[10:24:17.765]                             quietly = TRUE)
[10:24:17.765]                           if (has_future) {
[10:24:17.765]                             ns <- base::getNamespace("future")
[10:24:17.765]                             version <- ns[[".package"]][["version"]]
[10:24:17.765]                             if (is.null(version)) 
[10:24:17.765]                               version <- utils::packageVersion("future")
[10:24:17.765]                           }
[10:24:17.765]                           else {
[10:24:17.765]                             version <- NULL
[10:24:17.765]                           }
[10:24:17.765]                           if (!has_future || version < "1.8.0") {
[10:24:17.765]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.765]                               "", base::R.version$version.string), 
[10:24:17.765]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.765]                                 base::R.version$platform, 8 * 
[10:24:17.765]                                   base::.Machine$sizeof.pointer), 
[10:24:17.765]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.765]                                 "release", "version")], collapse = " "), 
[10:24:17.765]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.765]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.765]                               info)
[10:24:17.765]                             info <- base::paste(info, collapse = "; ")
[10:24:17.765]                             if (!has_future) {
[10:24:17.765]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.765]                                 info)
[10:24:17.765]                             }
[10:24:17.765]                             else {
[10:24:17.765]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.765]                                 info, version)
[10:24:17.765]                             }
[10:24:17.765]                             base::stop(msg)
[10:24:17.765]                           }
[10:24:17.765]                         })
[10:24:17.765]                       }
[10:24:17.765]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.765]                       base::options(mc.cores = 1L)
[10:24:17.765]                     }
[10:24:17.765]                     base::local({
[10:24:17.765]                       for (pkg in "future.apply") {
[10:24:17.765]                         base::loadNamespace(pkg)
[10:24:17.765]                         base::library(pkg, character.only = TRUE)
[10:24:17.765]                       }
[10:24:17.765]                     })
[10:24:17.765]                   }
[10:24:17.765]                   options(future.plan = NULL)
[10:24:17.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.765]                 }
[10:24:17.765]                 ...future.workdir <- getwd()
[10:24:17.765]             }
[10:24:17.765]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.765]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.765]         }
[10:24:17.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.765]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.765]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.765]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.765]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.765]             base::names(...future.oldOptions))
[10:24:17.765]     }
[10:24:17.765]     if (FALSE) {
[10:24:17.765]     }
[10:24:17.765]     else {
[10:24:17.765]         if (TRUE) {
[10:24:17.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.765]                 open = "w")
[10:24:17.765]         }
[10:24:17.765]         else {
[10:24:17.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.765]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.765]         }
[10:24:17.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.765]             base::sink(type = "output", split = FALSE)
[10:24:17.765]             base::close(...future.stdout)
[10:24:17.765]         }, add = TRUE)
[10:24:17.765]     }
[10:24:17.765]     ...future.frame <- base::sys.nframe()
[10:24:17.765]     ...future.conditions <- base::list()
[10:24:17.765]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.765]     if (FALSE) {
[10:24:17.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.765]     }
[10:24:17.765]     ...future.result <- base::tryCatch({
[10:24:17.765]         base::withCallingHandlers({
[10:24:17.765]             ...future.value <- base::withVisible(base::local({
[10:24:17.765]                 withCallingHandlers({
[10:24:17.765]                   {
[10:24:17.765]                     do.call(function(...) {
[10:24:17.765]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.765]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.765]                         ...future.globals.maxSize)) {
[10:24:17.765]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.765]                         on.exit(options(oopts), add = TRUE)
[10:24:17.765]                       }
[10:24:17.765]                       {
[10:24:17.765]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.765]                           FUN = function(jj) {
[10:24:17.765]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.765]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.765]                           })
[10:24:17.765]                       }
[10:24:17.765]                     }, args = future.call.arguments)
[10:24:17.765]                   }
[10:24:17.765]                 }, immediateCondition = function(cond) {
[10:24:17.765]                   save_rds <- function (object, pathname, ...) 
[10:24:17.765]                   {
[10:24:17.765]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.765]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.765]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.765]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.765]                         fi_tmp[["mtime"]])
[10:24:17.765]                     }
[10:24:17.765]                     tryCatch({
[10:24:17.765]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.765]                     }, error = function(ex) {
[10:24:17.765]                       msg <- conditionMessage(ex)
[10:24:17.765]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.765]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.765]                         fi_tmp[["mtime"]], msg)
[10:24:17.765]                       ex$message <- msg
[10:24:17.765]                       stop(ex)
[10:24:17.765]                     })
[10:24:17.765]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.765]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.765]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.765]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.765]                       fi <- file.info(pathname)
[10:24:17.765]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.765]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.765]                         fi[["size"]], fi[["mtime"]])
[10:24:17.765]                       stop(msg)
[10:24:17.765]                     }
[10:24:17.765]                     invisible(pathname)
[10:24:17.765]                   }
[10:24:17.765]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.765]                     rootPath = tempdir()) 
[10:24:17.765]                   {
[10:24:17.765]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.765]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.765]                       tmpdir = path, fileext = ".rds")
[10:24:17.765]                     save_rds(obj, file)
[10:24:17.765]                   }
[10:24:17.765]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.765]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.765]                   {
[10:24:17.765]                     inherits <- base::inherits
[10:24:17.765]                     invokeRestart <- base::invokeRestart
[10:24:17.765]                     is.null <- base::is.null
[10:24:17.765]                     muffled <- FALSE
[10:24:17.765]                     if (inherits(cond, "message")) {
[10:24:17.765]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.765]                       if (muffled) 
[10:24:17.765]                         invokeRestart("muffleMessage")
[10:24:17.765]                     }
[10:24:17.765]                     else if (inherits(cond, "warning")) {
[10:24:17.765]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.765]                       if (muffled) 
[10:24:17.765]                         invokeRestart("muffleWarning")
[10:24:17.765]                     }
[10:24:17.765]                     else if (inherits(cond, "condition")) {
[10:24:17.765]                       if (!is.null(pattern)) {
[10:24:17.765]                         computeRestarts <- base::computeRestarts
[10:24:17.765]                         grepl <- base::grepl
[10:24:17.765]                         restarts <- computeRestarts(cond)
[10:24:17.765]                         for (restart in restarts) {
[10:24:17.765]                           name <- restart$name
[10:24:17.765]                           if (is.null(name)) 
[10:24:17.765]                             next
[10:24:17.765]                           if (!grepl(pattern, name)) 
[10:24:17.765]                             next
[10:24:17.765]                           invokeRestart(restart)
[10:24:17.765]                           muffled <- TRUE
[10:24:17.765]                           break
[10:24:17.765]                         }
[10:24:17.765]                       }
[10:24:17.765]                     }
[10:24:17.765]                     invisible(muffled)
[10:24:17.765]                   }
[10:24:17.765]                   muffleCondition(cond)
[10:24:17.765]                 })
[10:24:17.765]             }))
[10:24:17.765]             future::FutureResult(value = ...future.value$value, 
[10:24:17.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.765]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.765]                     ...future.globalenv.names))
[10:24:17.765]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.765]         }, condition = base::local({
[10:24:17.765]             c <- base::c
[10:24:17.765]             inherits <- base::inherits
[10:24:17.765]             invokeRestart <- base::invokeRestart
[10:24:17.765]             length <- base::length
[10:24:17.765]             list <- base::list
[10:24:17.765]             seq.int <- base::seq.int
[10:24:17.765]             signalCondition <- base::signalCondition
[10:24:17.765]             sys.calls <- base::sys.calls
[10:24:17.765]             `[[` <- base::`[[`
[10:24:17.765]             `+` <- base::`+`
[10:24:17.765]             `<<-` <- base::`<<-`
[10:24:17.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.765]                   3L)]
[10:24:17.765]             }
[10:24:17.765]             function(cond) {
[10:24:17.765]                 is_error <- inherits(cond, "error")
[10:24:17.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.765]                   NULL)
[10:24:17.765]                 if (is_error) {
[10:24:17.765]                   sessionInformation <- function() {
[10:24:17.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.765]                       search = base::search(), system = base::Sys.info())
[10:24:17.765]                   }
[10:24:17.765]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.765]                     cond$call), session = sessionInformation(), 
[10:24:17.765]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.765]                   signalCondition(cond)
[10:24:17.765]                 }
[10:24:17.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.765]                 "immediateCondition"))) {
[10:24:17.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.765]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.765]                   if (TRUE && !signal) {
[10:24:17.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.765]                     {
[10:24:17.765]                       inherits <- base::inherits
[10:24:17.765]                       invokeRestart <- base::invokeRestart
[10:24:17.765]                       is.null <- base::is.null
[10:24:17.765]                       muffled <- FALSE
[10:24:17.765]                       if (inherits(cond, "message")) {
[10:24:17.765]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.765]                         if (muffled) 
[10:24:17.765]                           invokeRestart("muffleMessage")
[10:24:17.765]                       }
[10:24:17.765]                       else if (inherits(cond, "warning")) {
[10:24:17.765]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.765]                         if (muffled) 
[10:24:17.765]                           invokeRestart("muffleWarning")
[10:24:17.765]                       }
[10:24:17.765]                       else if (inherits(cond, "condition")) {
[10:24:17.765]                         if (!is.null(pattern)) {
[10:24:17.765]                           computeRestarts <- base::computeRestarts
[10:24:17.765]                           grepl <- base::grepl
[10:24:17.765]                           restarts <- computeRestarts(cond)
[10:24:17.765]                           for (restart in restarts) {
[10:24:17.765]                             name <- restart$name
[10:24:17.765]                             if (is.null(name)) 
[10:24:17.765]                               next
[10:24:17.765]                             if (!grepl(pattern, name)) 
[10:24:17.765]                               next
[10:24:17.765]                             invokeRestart(restart)
[10:24:17.765]                             muffled <- TRUE
[10:24:17.765]                             break
[10:24:17.765]                           }
[10:24:17.765]                         }
[10:24:17.765]                       }
[10:24:17.765]                       invisible(muffled)
[10:24:17.765]                     }
[10:24:17.765]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.765]                   }
[10:24:17.765]                 }
[10:24:17.765]                 else {
[10:24:17.765]                   if (TRUE) {
[10:24:17.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.765]                     {
[10:24:17.765]                       inherits <- base::inherits
[10:24:17.765]                       invokeRestart <- base::invokeRestart
[10:24:17.765]                       is.null <- base::is.null
[10:24:17.765]                       muffled <- FALSE
[10:24:17.765]                       if (inherits(cond, "message")) {
[10:24:17.765]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.765]                         if (muffled) 
[10:24:17.765]                           invokeRestart("muffleMessage")
[10:24:17.765]                       }
[10:24:17.765]                       else if (inherits(cond, "warning")) {
[10:24:17.765]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.765]                         if (muffled) 
[10:24:17.765]                           invokeRestart("muffleWarning")
[10:24:17.765]                       }
[10:24:17.765]                       else if (inherits(cond, "condition")) {
[10:24:17.765]                         if (!is.null(pattern)) {
[10:24:17.765]                           computeRestarts <- base::computeRestarts
[10:24:17.765]                           grepl <- base::grepl
[10:24:17.765]                           restarts <- computeRestarts(cond)
[10:24:17.765]                           for (restart in restarts) {
[10:24:17.765]                             name <- restart$name
[10:24:17.765]                             if (is.null(name)) 
[10:24:17.765]                               next
[10:24:17.765]                             if (!grepl(pattern, name)) 
[10:24:17.765]                               next
[10:24:17.765]                             invokeRestart(restart)
[10:24:17.765]                             muffled <- TRUE
[10:24:17.765]                             break
[10:24:17.765]                           }
[10:24:17.765]                         }
[10:24:17.765]                       }
[10:24:17.765]                       invisible(muffled)
[10:24:17.765]                     }
[10:24:17.765]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.765]                   }
[10:24:17.765]                 }
[10:24:17.765]             }
[10:24:17.765]         }))
[10:24:17.765]     }, error = function(ex) {
[10:24:17.765]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.765]                 ...future.rng), started = ...future.startTime, 
[10:24:17.765]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.765]             version = "1.8"), class = "FutureResult")
[10:24:17.765]     }, finally = {
[10:24:17.765]         if (!identical(...future.workdir, getwd())) 
[10:24:17.765]             setwd(...future.workdir)
[10:24:17.765]         {
[10:24:17.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.765]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.765]             }
[10:24:17.765]             base::options(...future.oldOptions)
[10:24:17.765]             if (.Platform$OS.type == "windows") {
[10:24:17.765]                 old_names <- names(...future.oldEnvVars)
[10:24:17.765]                 envs <- base::Sys.getenv()
[10:24:17.765]                 names <- names(envs)
[10:24:17.765]                 common <- intersect(names, old_names)
[10:24:17.765]                 added <- setdiff(names, old_names)
[10:24:17.765]                 removed <- setdiff(old_names, names)
[10:24:17.765]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.765]                   envs[common]]
[10:24:17.765]                 NAMES <- toupper(changed)
[10:24:17.765]                 args <- list()
[10:24:17.765]                 for (kk in seq_along(NAMES)) {
[10:24:17.765]                   name <- changed[[kk]]
[10:24:17.765]                   NAME <- NAMES[[kk]]
[10:24:17.765]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.765]                     next
[10:24:17.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.765]                 }
[10:24:17.765]                 NAMES <- toupper(added)
[10:24:17.765]                 for (kk in seq_along(NAMES)) {
[10:24:17.765]                   name <- added[[kk]]
[10:24:17.765]                   NAME <- NAMES[[kk]]
[10:24:17.765]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.765]                     next
[10:24:17.765]                   args[[name]] <- ""
[10:24:17.765]                 }
[10:24:17.765]                 NAMES <- toupper(removed)
[10:24:17.765]                 for (kk in seq_along(NAMES)) {
[10:24:17.765]                   name <- removed[[kk]]
[10:24:17.765]                   NAME <- NAMES[[kk]]
[10:24:17.765]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.765]                     next
[10:24:17.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.765]                 }
[10:24:17.765]                 if (length(args) > 0) 
[10:24:17.765]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.765]             }
[10:24:17.765]             else {
[10:24:17.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.765]             }
[10:24:17.765]             {
[10:24:17.765]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.765]                   0L) {
[10:24:17.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.765]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.765]                   base::options(opts)
[10:24:17.765]                 }
[10:24:17.765]                 {
[10:24:17.765]                   {
[10:24:17.765]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.765]                     NULL
[10:24:17.765]                   }
[10:24:17.765]                   options(future.plan = NULL)
[10:24:17.765]                   if (is.na(NA_character_)) 
[10:24:17.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.765]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.765]                     envir = parent.frame()) 
[10:24:17.765]                   {
[10:24:17.765]                     default_workers <- missing(workers)
[10:24:17.765]                     if (is.function(workers)) 
[10:24:17.765]                       workers <- workers()
[10:24:17.765]                     workers <- structure(as.integer(workers), 
[10:24:17.765]                       class = class(workers))
[10:24:17.765]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.765]                       1L)
[10:24:17.765]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.765]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.765]                       if (default_workers) 
[10:24:17.765]                         supportsMulticore(warn = TRUE)
[10:24:17.765]                       return(sequential(..., envir = envir))
[10:24:17.765]                     }
[10:24:17.765]                     oopts <- options(mc.cores = workers)
[10:24:17.765]                     on.exit(options(oopts))
[10:24:17.765]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.765]                       envir = envir)
[10:24:17.765]                     if (!future$lazy) 
[10:24:17.765]                       future <- run(future)
[10:24:17.765]                     invisible(future)
[10:24:17.765]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.765]                 }
[10:24:17.765]             }
[10:24:17.765]         }
[10:24:17.765]     })
[10:24:17.765]     if (TRUE) {
[10:24:17.765]         base::sink(type = "output", split = FALSE)
[10:24:17.765]         if (TRUE) {
[10:24:17.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.765]         }
[10:24:17.765]         else {
[10:24:17.765]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.765]         }
[10:24:17.765]         base::close(...future.stdout)
[10:24:17.765]         ...future.stdout <- NULL
[10:24:17.765]     }
[10:24:17.765]     ...future.result$conditions <- ...future.conditions
[10:24:17.765]     ...future.result$finished <- base::Sys.time()
[10:24:17.765]     ...future.result
[10:24:17.765] }
[10:24:17.768] assign_globals() ...
[10:24:17.768] List of 11
[10:24:17.768]  $ ...future.FUN            :function (x, ...)  
[10:24:17.768]  $ x_FUN                    :function (x)  
[10:24:17.768]  $ times                    : int 4
[10:24:17.768]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.768]  $ stop_if_not              :function (...)  
[10:24:17.768]  $ dim                      : int [1:2] 2 2
[10:24:17.768]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:17.768]  $ future.call.arguments    : list()
[10:24:17.768]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.768]  $ ...future.elements_ii    :List of 5
[10:24:17.768]   ..$ : int 1
[10:24:17.768]   ..$ : int 2
[10:24:17.768]   ..$ : int 3
[10:24:17.768]   ..$ : int 4
[10:24:17.768]   ..$ : int 5
[10:24:17.768]  $ ...future.seeds_ii       : NULL
[10:24:17.768]  $ ...future.globals.maxSize: NULL
[10:24:17.768]  - attr(*, "where")=List of 11
[10:24:17.768]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.768]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.768]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.768]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.768]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.768]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.768]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.768]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.768]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.768]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.768]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.768]  - attr(*, "resolved")= logi FALSE
[10:24:17.768]  - attr(*, "total_size")= num 97304
[10:24:17.768]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.768]  - attr(*, "already-done")= logi TRUE
[10:24:17.778] - copied ‘...future.FUN’ to environment
[10:24:17.778] - reassign environment for ‘x_FUN’
[10:24:17.778] - copied ‘x_FUN’ to environment
[10:24:17.778] - copied ‘times’ to environment
[10:24:17.778] - copied ‘stopf’ to environment
[10:24:17.778] - copied ‘stop_if_not’ to environment
[10:24:17.778] - copied ‘dim’ to environment
[10:24:17.779] - copied ‘valid_types’ to environment
[10:24:17.779] - copied ‘future.call.arguments’ to environment
[10:24:17.779] - copied ‘...future.elements_ii’ to environment
[10:24:17.779] - copied ‘...future.seeds_ii’ to environment
[10:24:17.779] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.779] assign_globals() ... done
[10:24:17.779] requestCore(): workers = 2
[10:24:17.781] MulticoreFuture started
[10:24:17.782] - Launch lazy future ... done
[10:24:17.782] run() for ‘MulticoreFuture’ ... done
[10:24:17.782] Created future:
[10:24:17.783] plan(): Setting new future strategy stack:
[10:24:17.783] List of future strategies:
[10:24:17.783] 1. sequential:
[10:24:17.783]    - args: function (..., envir = parent.frame())
[10:24:17.783]    - tweaked: FALSE
[10:24:17.783]    - call: NULL
[10:24:17.784] plan(): nbrOfWorkers() = 1
[10:24:17.786] plan(): Setting new future strategy stack:
[10:24:17.786] List of future strategies:
[10:24:17.786] 1. multicore:
[10:24:17.786]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.786]    - tweaked: FALSE
[10:24:17.786]    - call: plan(strategy)
[10:24:17.792] plan(): nbrOfWorkers() = 2
[10:24:17.782] MulticoreFuture:
[10:24:17.782] Label: ‘future_vapply-1’
[10:24:17.782] Expression:
[10:24:17.782] {
[10:24:17.782]     do.call(function(...) {
[10:24:17.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.782]             on.exit(options(oopts), add = TRUE)
[10:24:17.782]         }
[10:24:17.782]         {
[10:24:17.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.782]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.782]             })
[10:24:17.782]         }
[10:24:17.782]     }, args = future.call.arguments)
[10:24:17.782] }
[10:24:17.782] Lazy evaluation: FALSE
[10:24:17.782] Asynchronous evaluation: TRUE
[10:24:17.782] Local evaluation: TRUE
[10:24:17.782] Environment: R_GlobalEnv
[10:24:17.782] Capture standard output: TRUE
[10:24:17.782] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.782] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.782] Packages: 1 packages (‘future.apply’)
[10:24:17.782] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.782] Resolved: TRUE
[10:24:17.782] Value: <not collected>
[10:24:17.782] Conditions captured: <none>
[10:24:17.782] Early signaling: FALSE
[10:24:17.782] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.782] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.793] Chunk #1 of 2 ... DONE
[10:24:17.793] Chunk #2 of 2 ...
[10:24:17.793]  - Finding globals in 'X' for chunk #2 ...
[10:24:17.794] getGlobalsAndPackages() ...
[10:24:17.794] Searching for globals...
[10:24:17.794] 
[10:24:17.794] Searching for globals ... DONE
[10:24:17.794] - globals: [0] <none>
[10:24:17.795] getGlobalsAndPackages() ... DONE
[10:24:17.795]    + additional globals found: [n=0] 
[10:24:17.795]    + additional namespaces needed: [n=0] 
[10:24:17.795]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:17.795]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.795]  - seeds: <none>
[10:24:17.795]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.796] getGlobalsAndPackages() ...
[10:24:17.796] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.796] Resolving globals: FALSE
[10:24:17.796] Tweak future expression to call with '...' arguments ...
[10:24:17.796] {
[10:24:17.796]     do.call(function(...) {
[10:24:17.796]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.796]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.796]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.796]             on.exit(options(oopts), add = TRUE)
[10:24:17.796]         }
[10:24:17.796]         {
[10:24:17.796]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.796]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.796]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.796]             })
[10:24:17.796]         }
[10:24:17.796]     }, args = future.call.arguments)
[10:24:17.796] }
[10:24:17.797] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.798] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.798] - packages: [1] ‘future.apply’
[10:24:17.798] getGlobalsAndPackages() ... DONE
[10:24:17.799] run() for ‘Future’ ...
[10:24:17.799] - state: ‘created’
[10:24:17.799] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.804] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.804] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.804]   - Field: ‘label’
[10:24:17.804]   - Field: ‘local’
[10:24:17.804]   - Field: ‘owner’
[10:24:17.804]   - Field: ‘envir’
[10:24:17.805]   - Field: ‘workers’
[10:24:17.805]   - Field: ‘packages’
[10:24:17.805]   - Field: ‘gc’
[10:24:17.805]   - Field: ‘job’
[10:24:17.805]   - Field: ‘conditions’
[10:24:17.805]   - Field: ‘expr’
[10:24:17.805]   - Field: ‘uuid’
[10:24:17.806]   - Field: ‘seed’
[10:24:17.806]   - Field: ‘version’
[10:24:17.806]   - Field: ‘result’
[10:24:17.806]   - Field: ‘asynchronous’
[10:24:17.806]   - Field: ‘calls’
[10:24:17.806]   - Field: ‘globals’
[10:24:17.806]   - Field: ‘stdout’
[10:24:17.807]   - Field: ‘earlySignal’
[10:24:17.807]   - Field: ‘lazy’
[10:24:17.807]   - Field: ‘state’
[10:24:17.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.807] - Launch lazy future ...
[10:24:17.808] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.808] Packages needed by future strategies (n = 0): <none>
[10:24:17.809] {
[10:24:17.809]     {
[10:24:17.809]         {
[10:24:17.809]             ...future.startTime <- base::Sys.time()
[10:24:17.809]             {
[10:24:17.809]                 {
[10:24:17.809]                   {
[10:24:17.809]                     {
[10:24:17.809]                       {
[10:24:17.809]                         base::local({
[10:24:17.809]                           has_future <- base::requireNamespace("future", 
[10:24:17.809]                             quietly = TRUE)
[10:24:17.809]                           if (has_future) {
[10:24:17.809]                             ns <- base::getNamespace("future")
[10:24:17.809]                             version <- ns[[".package"]][["version"]]
[10:24:17.809]                             if (is.null(version)) 
[10:24:17.809]                               version <- utils::packageVersion("future")
[10:24:17.809]                           }
[10:24:17.809]                           else {
[10:24:17.809]                             version <- NULL
[10:24:17.809]                           }
[10:24:17.809]                           if (!has_future || version < "1.8.0") {
[10:24:17.809]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.809]                               "", base::R.version$version.string), 
[10:24:17.809]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.809]                                 base::R.version$platform, 8 * 
[10:24:17.809]                                   base::.Machine$sizeof.pointer), 
[10:24:17.809]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.809]                                 "release", "version")], collapse = " "), 
[10:24:17.809]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.809]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.809]                               info)
[10:24:17.809]                             info <- base::paste(info, collapse = "; ")
[10:24:17.809]                             if (!has_future) {
[10:24:17.809]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.809]                                 info)
[10:24:17.809]                             }
[10:24:17.809]                             else {
[10:24:17.809]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.809]                                 info, version)
[10:24:17.809]                             }
[10:24:17.809]                             base::stop(msg)
[10:24:17.809]                           }
[10:24:17.809]                         })
[10:24:17.809]                       }
[10:24:17.809]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.809]                       base::options(mc.cores = 1L)
[10:24:17.809]                     }
[10:24:17.809]                     base::local({
[10:24:17.809]                       for (pkg in "future.apply") {
[10:24:17.809]                         base::loadNamespace(pkg)
[10:24:17.809]                         base::library(pkg, character.only = TRUE)
[10:24:17.809]                       }
[10:24:17.809]                     })
[10:24:17.809]                   }
[10:24:17.809]                   options(future.plan = NULL)
[10:24:17.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.809]                 }
[10:24:17.809]                 ...future.workdir <- getwd()
[10:24:17.809]             }
[10:24:17.809]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.809]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.809]         }
[10:24:17.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.809]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.809]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.809]             base::names(...future.oldOptions))
[10:24:17.809]     }
[10:24:17.809]     if (FALSE) {
[10:24:17.809]     }
[10:24:17.809]     else {
[10:24:17.809]         if (TRUE) {
[10:24:17.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.809]                 open = "w")
[10:24:17.809]         }
[10:24:17.809]         else {
[10:24:17.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.809]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.809]         }
[10:24:17.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.809]             base::sink(type = "output", split = FALSE)
[10:24:17.809]             base::close(...future.stdout)
[10:24:17.809]         }, add = TRUE)
[10:24:17.809]     }
[10:24:17.809]     ...future.frame <- base::sys.nframe()
[10:24:17.809]     ...future.conditions <- base::list()
[10:24:17.809]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.809]     if (FALSE) {
[10:24:17.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.809]     }
[10:24:17.809]     ...future.result <- base::tryCatch({
[10:24:17.809]         base::withCallingHandlers({
[10:24:17.809]             ...future.value <- base::withVisible(base::local({
[10:24:17.809]                 withCallingHandlers({
[10:24:17.809]                   {
[10:24:17.809]                     do.call(function(...) {
[10:24:17.809]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.809]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.809]                         ...future.globals.maxSize)) {
[10:24:17.809]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.809]                         on.exit(options(oopts), add = TRUE)
[10:24:17.809]                       }
[10:24:17.809]                       {
[10:24:17.809]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.809]                           FUN = function(jj) {
[10:24:17.809]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.809]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.809]                           })
[10:24:17.809]                       }
[10:24:17.809]                     }, args = future.call.arguments)
[10:24:17.809]                   }
[10:24:17.809]                 }, immediateCondition = function(cond) {
[10:24:17.809]                   save_rds <- function (object, pathname, ...) 
[10:24:17.809]                   {
[10:24:17.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.809]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.809]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.809]                         fi_tmp[["mtime"]])
[10:24:17.809]                     }
[10:24:17.809]                     tryCatch({
[10:24:17.809]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.809]                     }, error = function(ex) {
[10:24:17.809]                       msg <- conditionMessage(ex)
[10:24:17.809]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.809]                         fi_tmp[["mtime"]], msg)
[10:24:17.809]                       ex$message <- msg
[10:24:17.809]                       stop(ex)
[10:24:17.809]                     })
[10:24:17.809]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.809]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.809]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.809]                       fi <- file.info(pathname)
[10:24:17.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.809]                         fi[["size"]], fi[["mtime"]])
[10:24:17.809]                       stop(msg)
[10:24:17.809]                     }
[10:24:17.809]                     invisible(pathname)
[10:24:17.809]                   }
[10:24:17.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.809]                     rootPath = tempdir()) 
[10:24:17.809]                   {
[10:24:17.809]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.809]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.809]                       tmpdir = path, fileext = ".rds")
[10:24:17.809]                     save_rds(obj, file)
[10:24:17.809]                   }
[10:24:17.809]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.809]                   {
[10:24:17.809]                     inherits <- base::inherits
[10:24:17.809]                     invokeRestart <- base::invokeRestart
[10:24:17.809]                     is.null <- base::is.null
[10:24:17.809]                     muffled <- FALSE
[10:24:17.809]                     if (inherits(cond, "message")) {
[10:24:17.809]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.809]                       if (muffled) 
[10:24:17.809]                         invokeRestart("muffleMessage")
[10:24:17.809]                     }
[10:24:17.809]                     else if (inherits(cond, "warning")) {
[10:24:17.809]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.809]                       if (muffled) 
[10:24:17.809]                         invokeRestart("muffleWarning")
[10:24:17.809]                     }
[10:24:17.809]                     else if (inherits(cond, "condition")) {
[10:24:17.809]                       if (!is.null(pattern)) {
[10:24:17.809]                         computeRestarts <- base::computeRestarts
[10:24:17.809]                         grepl <- base::grepl
[10:24:17.809]                         restarts <- computeRestarts(cond)
[10:24:17.809]                         for (restart in restarts) {
[10:24:17.809]                           name <- restart$name
[10:24:17.809]                           if (is.null(name)) 
[10:24:17.809]                             next
[10:24:17.809]                           if (!grepl(pattern, name)) 
[10:24:17.809]                             next
[10:24:17.809]                           invokeRestart(restart)
[10:24:17.809]                           muffled <- TRUE
[10:24:17.809]                           break
[10:24:17.809]                         }
[10:24:17.809]                       }
[10:24:17.809]                     }
[10:24:17.809]                     invisible(muffled)
[10:24:17.809]                   }
[10:24:17.809]                   muffleCondition(cond)
[10:24:17.809]                 })
[10:24:17.809]             }))
[10:24:17.809]             future::FutureResult(value = ...future.value$value, 
[10:24:17.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.809]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.809]                     ...future.globalenv.names))
[10:24:17.809]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.809]         }, condition = base::local({
[10:24:17.809]             c <- base::c
[10:24:17.809]             inherits <- base::inherits
[10:24:17.809]             invokeRestart <- base::invokeRestart
[10:24:17.809]             length <- base::length
[10:24:17.809]             list <- base::list
[10:24:17.809]             seq.int <- base::seq.int
[10:24:17.809]             signalCondition <- base::signalCondition
[10:24:17.809]             sys.calls <- base::sys.calls
[10:24:17.809]             `[[` <- base::`[[`
[10:24:17.809]             `+` <- base::`+`
[10:24:17.809]             `<<-` <- base::`<<-`
[10:24:17.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.809]                   3L)]
[10:24:17.809]             }
[10:24:17.809]             function(cond) {
[10:24:17.809]                 is_error <- inherits(cond, "error")
[10:24:17.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.809]                   NULL)
[10:24:17.809]                 if (is_error) {
[10:24:17.809]                   sessionInformation <- function() {
[10:24:17.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.809]                       search = base::search(), system = base::Sys.info())
[10:24:17.809]                   }
[10:24:17.809]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.809]                     cond$call), session = sessionInformation(), 
[10:24:17.809]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.809]                   signalCondition(cond)
[10:24:17.809]                 }
[10:24:17.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.809]                 "immediateCondition"))) {
[10:24:17.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.809]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.809]                   if (TRUE && !signal) {
[10:24:17.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.809]                     {
[10:24:17.809]                       inherits <- base::inherits
[10:24:17.809]                       invokeRestart <- base::invokeRestart
[10:24:17.809]                       is.null <- base::is.null
[10:24:17.809]                       muffled <- FALSE
[10:24:17.809]                       if (inherits(cond, "message")) {
[10:24:17.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.809]                         if (muffled) 
[10:24:17.809]                           invokeRestart("muffleMessage")
[10:24:17.809]                       }
[10:24:17.809]                       else if (inherits(cond, "warning")) {
[10:24:17.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.809]                         if (muffled) 
[10:24:17.809]                           invokeRestart("muffleWarning")
[10:24:17.809]                       }
[10:24:17.809]                       else if (inherits(cond, "condition")) {
[10:24:17.809]                         if (!is.null(pattern)) {
[10:24:17.809]                           computeRestarts <- base::computeRestarts
[10:24:17.809]                           grepl <- base::grepl
[10:24:17.809]                           restarts <- computeRestarts(cond)
[10:24:17.809]                           for (restart in restarts) {
[10:24:17.809]                             name <- restart$name
[10:24:17.809]                             if (is.null(name)) 
[10:24:17.809]                               next
[10:24:17.809]                             if (!grepl(pattern, name)) 
[10:24:17.809]                               next
[10:24:17.809]                             invokeRestart(restart)
[10:24:17.809]                             muffled <- TRUE
[10:24:17.809]                             break
[10:24:17.809]                           }
[10:24:17.809]                         }
[10:24:17.809]                       }
[10:24:17.809]                       invisible(muffled)
[10:24:17.809]                     }
[10:24:17.809]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.809]                   }
[10:24:17.809]                 }
[10:24:17.809]                 else {
[10:24:17.809]                   if (TRUE) {
[10:24:17.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.809]                     {
[10:24:17.809]                       inherits <- base::inherits
[10:24:17.809]                       invokeRestart <- base::invokeRestart
[10:24:17.809]                       is.null <- base::is.null
[10:24:17.809]                       muffled <- FALSE
[10:24:17.809]                       if (inherits(cond, "message")) {
[10:24:17.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.809]                         if (muffled) 
[10:24:17.809]                           invokeRestart("muffleMessage")
[10:24:17.809]                       }
[10:24:17.809]                       else if (inherits(cond, "warning")) {
[10:24:17.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.809]                         if (muffled) 
[10:24:17.809]                           invokeRestart("muffleWarning")
[10:24:17.809]                       }
[10:24:17.809]                       else if (inherits(cond, "condition")) {
[10:24:17.809]                         if (!is.null(pattern)) {
[10:24:17.809]                           computeRestarts <- base::computeRestarts
[10:24:17.809]                           grepl <- base::grepl
[10:24:17.809]                           restarts <- computeRestarts(cond)
[10:24:17.809]                           for (restart in restarts) {
[10:24:17.809]                             name <- restart$name
[10:24:17.809]                             if (is.null(name)) 
[10:24:17.809]                               next
[10:24:17.809]                             if (!grepl(pattern, name)) 
[10:24:17.809]                               next
[10:24:17.809]                             invokeRestart(restart)
[10:24:17.809]                             muffled <- TRUE
[10:24:17.809]                             break
[10:24:17.809]                           }
[10:24:17.809]                         }
[10:24:17.809]                       }
[10:24:17.809]                       invisible(muffled)
[10:24:17.809]                     }
[10:24:17.809]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.809]                   }
[10:24:17.809]                 }
[10:24:17.809]             }
[10:24:17.809]         }))
[10:24:17.809]     }, error = function(ex) {
[10:24:17.809]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.809]                 ...future.rng), started = ...future.startTime, 
[10:24:17.809]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.809]             version = "1.8"), class = "FutureResult")
[10:24:17.809]     }, finally = {
[10:24:17.809]         if (!identical(...future.workdir, getwd())) 
[10:24:17.809]             setwd(...future.workdir)
[10:24:17.809]         {
[10:24:17.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.809]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.809]             }
[10:24:17.809]             base::options(...future.oldOptions)
[10:24:17.809]             if (.Platform$OS.type == "windows") {
[10:24:17.809]                 old_names <- names(...future.oldEnvVars)
[10:24:17.809]                 envs <- base::Sys.getenv()
[10:24:17.809]                 names <- names(envs)
[10:24:17.809]                 common <- intersect(names, old_names)
[10:24:17.809]                 added <- setdiff(names, old_names)
[10:24:17.809]                 removed <- setdiff(old_names, names)
[10:24:17.809]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.809]                   envs[common]]
[10:24:17.809]                 NAMES <- toupper(changed)
[10:24:17.809]                 args <- list()
[10:24:17.809]                 for (kk in seq_along(NAMES)) {
[10:24:17.809]                   name <- changed[[kk]]
[10:24:17.809]                   NAME <- NAMES[[kk]]
[10:24:17.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.809]                     next
[10:24:17.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.809]                 }
[10:24:17.809]                 NAMES <- toupper(added)
[10:24:17.809]                 for (kk in seq_along(NAMES)) {
[10:24:17.809]                   name <- added[[kk]]
[10:24:17.809]                   NAME <- NAMES[[kk]]
[10:24:17.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.809]                     next
[10:24:17.809]                   args[[name]] <- ""
[10:24:17.809]                 }
[10:24:17.809]                 NAMES <- toupper(removed)
[10:24:17.809]                 for (kk in seq_along(NAMES)) {
[10:24:17.809]                   name <- removed[[kk]]
[10:24:17.809]                   NAME <- NAMES[[kk]]
[10:24:17.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.809]                     next
[10:24:17.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.809]                 }
[10:24:17.809]                 if (length(args) > 0) 
[10:24:17.809]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.809]             }
[10:24:17.809]             else {
[10:24:17.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.809]             }
[10:24:17.809]             {
[10:24:17.809]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.809]                   0L) {
[10:24:17.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.809]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.809]                   base::options(opts)
[10:24:17.809]                 }
[10:24:17.809]                 {
[10:24:17.809]                   {
[10:24:17.809]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.809]                     NULL
[10:24:17.809]                   }
[10:24:17.809]                   options(future.plan = NULL)
[10:24:17.809]                   if (is.na(NA_character_)) 
[10:24:17.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.809]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.809]                     envir = parent.frame()) 
[10:24:17.809]                   {
[10:24:17.809]                     default_workers <- missing(workers)
[10:24:17.809]                     if (is.function(workers)) 
[10:24:17.809]                       workers <- workers()
[10:24:17.809]                     workers <- structure(as.integer(workers), 
[10:24:17.809]                       class = class(workers))
[10:24:17.809]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.809]                       1L)
[10:24:17.809]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.809]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.809]                       if (default_workers) 
[10:24:17.809]                         supportsMulticore(warn = TRUE)
[10:24:17.809]                       return(sequential(..., envir = envir))
[10:24:17.809]                     }
[10:24:17.809]                     oopts <- options(mc.cores = workers)
[10:24:17.809]                     on.exit(options(oopts))
[10:24:17.809]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.809]                       envir = envir)
[10:24:17.809]                     if (!future$lazy) 
[10:24:17.809]                       future <- run(future)
[10:24:17.809]                     invisible(future)
[10:24:17.809]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.809]                 }
[10:24:17.809]             }
[10:24:17.809]         }
[10:24:17.809]     })
[10:24:17.809]     if (TRUE) {
[10:24:17.809]         base::sink(type = "output", split = FALSE)
[10:24:17.809]         if (TRUE) {
[10:24:17.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.809]         }
[10:24:17.809]         else {
[10:24:17.809]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.809]         }
[10:24:17.809]         base::close(...future.stdout)
[10:24:17.809]         ...future.stdout <- NULL
[10:24:17.809]     }
[10:24:17.809]     ...future.result$conditions <- ...future.conditions
[10:24:17.809]     ...future.result$finished <- base::Sys.time()
[10:24:17.809]     ...future.result
[10:24:17.809] }
[10:24:17.812] assign_globals() ...
[10:24:17.813] List of 11
[10:24:17.813]  $ ...future.FUN            :function (x, ...)  
[10:24:17.813]  $ x_FUN                    :function (x)  
[10:24:17.813]  $ times                    : int 4
[10:24:17.813]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.813]  $ stop_if_not              :function (...)  
[10:24:17.813]  $ dim                      : int [1:2] 2 2
[10:24:17.813]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:17.813]  $ future.call.arguments    : list()
[10:24:17.813]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.813]  $ ...future.elements_ii    :List of 5
[10:24:17.813]   ..$ : int 6
[10:24:17.813]   ..$ : int 7
[10:24:17.813]   ..$ : int 8
[10:24:17.813]   ..$ : int 9
[10:24:17.813]   ..$ : int 10
[10:24:17.813]  $ ...future.seeds_ii       : NULL
[10:24:17.813]  $ ...future.globals.maxSize: NULL
[10:24:17.813]  - attr(*, "where")=List of 11
[10:24:17.813]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.813]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.813]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.813]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.813]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.813]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.813]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.813]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.813]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.813]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.813]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.813]  - attr(*, "resolved")= logi FALSE
[10:24:17.813]  - attr(*, "total_size")= num 97304
[10:24:17.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.813]  - attr(*, "already-done")= logi TRUE
[10:24:17.830] - copied ‘...future.FUN’ to environment
[10:24:17.830] - reassign environment for ‘x_FUN’
[10:24:17.830] - copied ‘x_FUN’ to environment
[10:24:17.830] - copied ‘times’ to environment
[10:24:17.831] - copied ‘stopf’ to environment
[10:24:17.831] - copied ‘stop_if_not’ to environment
[10:24:17.831] - copied ‘dim’ to environment
[10:24:17.831] - copied ‘valid_types’ to environment
[10:24:17.831] - copied ‘future.call.arguments’ to environment
[10:24:17.831] - copied ‘...future.elements_ii’ to environment
[10:24:17.831] - copied ‘...future.seeds_ii’ to environment
[10:24:17.831] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.831] assign_globals() ... done
[10:24:17.832] requestCore(): workers = 2
[10:24:17.834] MulticoreFuture started
[10:24:17.834] - Launch lazy future ... done
[10:24:17.834] run() for ‘MulticoreFuture’ ... done
[10:24:17.835] Created future:
[10:24:17.835] plan(): Setting new future strategy stack:
[10:24:17.836] List of future strategies:
[10:24:17.836] 1. sequential:
[10:24:17.836]    - args: function (..., envir = parent.frame())
[10:24:17.836]    - tweaked: FALSE
[10:24:17.836]    - call: NULL
[10:24:17.836] plan(): nbrOfWorkers() = 1
[10:24:17.838] plan(): Setting new future strategy stack:
[10:24:17.839] List of future strategies:
[10:24:17.839] 1. multicore:
[10:24:17.839]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.839]    - tweaked: FALSE
[10:24:17.839]    - call: plan(strategy)
[10:24:17.844] plan(): nbrOfWorkers() = 2
[10:24:17.835] MulticoreFuture:
[10:24:17.835] Label: ‘future_vapply-2’
[10:24:17.835] Expression:
[10:24:17.835] {
[10:24:17.835]     do.call(function(...) {
[10:24:17.835]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.835]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.835]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.835]             on.exit(options(oopts), add = TRUE)
[10:24:17.835]         }
[10:24:17.835]         {
[10:24:17.835]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.835]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.835]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.835]             })
[10:24:17.835]         }
[10:24:17.835]     }, args = future.call.arguments)
[10:24:17.835] }
[10:24:17.835] Lazy evaluation: FALSE
[10:24:17.835] Asynchronous evaluation: TRUE
[10:24:17.835] Local evaluation: TRUE
[10:24:17.835] Environment: R_GlobalEnv
[10:24:17.835] Capture standard output: TRUE
[10:24:17.835] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.835] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.835] Packages: 1 packages (‘future.apply’)
[10:24:17.835] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.835] Resolved: TRUE
[10:24:17.835] Value: <not collected>
[10:24:17.835] Conditions captured: <none>
[10:24:17.835] Early signaling: FALSE
[10:24:17.835] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.835] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.845] Chunk #2 of 2 ... DONE
[10:24:17.845] Launching 2 futures (chunks) ... DONE
[10:24:17.845] Resolving 2 futures (chunks) ...
[10:24:17.845] resolve() on list ...
[10:24:17.845]  recursive: 0
[10:24:17.846]  length: 2
[10:24:17.846] 
[10:24:17.846] Future #1
[10:24:17.846] result() for MulticoreFuture ...
[10:24:17.847] result() for MulticoreFuture ...
[10:24:17.847] result() for MulticoreFuture ... done
[10:24:17.848] result() for MulticoreFuture ... done
[10:24:17.848] result() for MulticoreFuture ...
[10:24:17.848] result() for MulticoreFuture ... done
[10:24:17.848] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:17.848] - nx: 2
[10:24:17.849] - relay: TRUE
[10:24:17.849] - stdout: TRUE
[10:24:17.849] - signal: TRUE
[10:24:17.849] - resignal: FALSE
[10:24:17.849] - force: TRUE
[10:24:17.850] - relayed: [n=2] FALSE, FALSE
[10:24:17.850] - queued futures: [n=2] FALSE, FALSE
[10:24:17.850]  - until=1
[10:24:17.850]  - relaying element #1
[10:24:17.850] result() for MulticoreFuture ...
[10:24:17.851] result() for MulticoreFuture ... done
[10:24:17.851] result() for MulticoreFuture ...
[10:24:17.851] result() for MulticoreFuture ... done
[10:24:17.851] result() for MulticoreFuture ...
[10:24:17.851] result() for MulticoreFuture ... done
[10:24:17.852] result() for MulticoreFuture ...
[10:24:17.852] result() for MulticoreFuture ... done
[10:24:17.852] - relayed: [n=2] TRUE, FALSE
[10:24:17.852] - queued futures: [n=2] TRUE, FALSE
[10:24:17.852] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:17.853]  length: 1 (resolved future 1)
[10:24:17.853] Future #2
[10:24:17.853] result() for MulticoreFuture ...
[10:24:17.854] result() for MulticoreFuture ...
[10:24:17.854] result() for MulticoreFuture ... done
[10:24:17.854] result() for MulticoreFuture ... done
[10:24:17.855] result() for MulticoreFuture ...
[10:24:17.855] result() for MulticoreFuture ... done
[10:24:17.855] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:17.855] - nx: 2
[10:24:17.855] - relay: TRUE
[10:24:17.856] - stdout: TRUE
[10:24:17.856] - signal: TRUE
[10:24:17.856] - resignal: FALSE
[10:24:17.856] - force: TRUE
[10:24:17.856] - relayed: [n=2] TRUE, FALSE
[10:24:17.857] - queued futures: [n=2] TRUE, FALSE
[10:24:17.857]  - until=2
[10:24:17.857]  - relaying element #2
[10:24:17.857] result() for MulticoreFuture ...
[10:24:17.857] result() for MulticoreFuture ... done
[10:24:17.858] result() for MulticoreFuture ...
[10:24:17.858] result() for MulticoreFuture ... done
[10:24:17.860] result() for MulticoreFuture ...
[10:24:17.861] result() for MulticoreFuture ... done
[10:24:17.861] result() for MulticoreFuture ...
[10:24:17.861] result() for MulticoreFuture ... done
[10:24:17.861] - relayed: [n=2] TRUE, TRUE
[10:24:17.862] - queued futures: [n=2] TRUE, TRUE
[10:24:17.862] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:17.862]  length: 0 (resolved future 2)
[10:24:17.862] Relaying remaining futures
[10:24:17.863] signalConditionsASAP(NULL, pos=0) ...
[10:24:17.863] - nx: 2
[10:24:17.863] - relay: TRUE
[10:24:17.863] - stdout: TRUE
[10:24:17.863] - signal: TRUE
[10:24:17.864] - resignal: FALSE
[10:24:17.864] - force: TRUE
[10:24:17.864] - relayed: [n=2] TRUE, TRUE
[10:24:17.864] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:17.864] - relayed: [n=2] TRUE, TRUE
[10:24:17.865] - queued futures: [n=2] TRUE, TRUE
[10:24:17.865] signalConditionsASAP(NULL, pos=0) ... done
[10:24:17.865] resolve() on list ... DONE
[10:24:17.865] result() for MulticoreFuture ...
[10:24:17.865] result() for MulticoreFuture ... done
[10:24:17.866] result() for MulticoreFuture ...
[10:24:17.866] result() for MulticoreFuture ... done
[10:24:17.866] result() for MulticoreFuture ...
[10:24:17.866] result() for MulticoreFuture ... done
[10:24:17.867] result() for MulticoreFuture ...
[10:24:17.867] result() for MulticoreFuture ... done
[10:24:17.867]  - Number of value chunks collected: 2
[10:24:17.867] Resolving 2 futures (chunks) ... DONE
[10:24:17.867] Reducing values from 2 chunks ...
[10:24:17.868]  - Number of values collected after concatenation: 10
[10:24:17.868]  - Number of values expected: 10
[10:24:17.868] Reducing values from 2 chunks ... DONE
[10:24:17.868] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[10:24:17.872] future_lapply() ...
[10:24:17.880] Number of chunks: 2
[10:24:17.880] getGlobalsAndPackagesXApply() ...
[10:24:17.880]  - future.globals: TRUE
[10:24:17.880] getGlobalsAndPackages() ...
[10:24:17.881] Searching for globals...
[10:24:17.887] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[10:24:17.888] Searching for globals ... DONE
[10:24:17.888] Resolving globals: FALSE
[10:24:17.890] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[10:24:17.890] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:17.891] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.891] - packages: [1] ‘future.apply’
[10:24:17.891] getGlobalsAndPackages() ... DONE
[10:24:17.891]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:17.891]  - needed namespaces: [n=1] ‘future.apply’
[10:24:17.892] Finding globals ... DONE
[10:24:17.892]  - use_args: TRUE
[10:24:17.892]  - Getting '...' globals ...
[10:24:17.893] resolve() on list ...
[10:24:17.893]  recursive: 0
[10:24:17.893]  length: 1
[10:24:17.893]  elements: ‘...’
[10:24:17.893]  length: 0 (resolved future 1)
[10:24:17.893] resolve() on list ... DONE
[10:24:17.894]    - '...' content: [n=0] 
[10:24:17.894] List of 1
[10:24:17.894]  $ ...: list()
[10:24:17.894]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.894]  - attr(*, "where")=List of 1
[10:24:17.894]   ..$ ...:<environment: 0x55b93c1a16c0> 
[10:24:17.894]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.894]  - attr(*, "resolved")= logi TRUE
[10:24:17.894]  - attr(*, "total_size")= num NA
[10:24:17.899]  - Getting '...' globals ... DONE
[10:24:17.900] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:17.900] List of 8
[10:24:17.900]  $ ...future.FUN:function (x, ...)  
[10:24:17.900]  $ x_FUN        :function (x)  
[10:24:17.900]  $ times        : int 4
[10:24:17.900]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.900]  $ stop_if_not  :function (...)  
[10:24:17.900]  $ dim          : int [1:2] 2 2
[10:24:17.900]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:17.900]  $ ...          : list()
[10:24:17.900]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.900]  - attr(*, "where")=List of 8
[10:24:17.900]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:17.900]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:17.900]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:17.900]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:17.900]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:17.900]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:17.900]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:17.900]   ..$ ...          :<environment: 0x55b93c1a16c0> 
[10:24:17.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.900]  - attr(*, "resolved")= logi FALSE
[10:24:17.900]  - attr(*, "total_size")= num 105552
[10:24:17.908] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:17.908] getGlobalsAndPackagesXApply() ... DONE
[10:24:17.909] Number of futures (= number of chunks): 2
[10:24:17.909] Launching 2 futures (chunks) ...
[10:24:17.909] Chunk #1 of 2 ...
[10:24:17.909]  - Finding globals in 'X' for chunk #1 ...
[10:24:17.909] getGlobalsAndPackages() ...
[10:24:17.910] Searching for globals...
[10:24:17.910] 
[10:24:17.910] Searching for globals ... DONE
[10:24:17.910] - globals: [0] <none>
[10:24:17.910] getGlobalsAndPackages() ... DONE
[10:24:17.911]    + additional globals found: [n=0] 
[10:24:17.911]    + additional namespaces needed: [n=0] 
[10:24:17.911]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:17.911]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.911]  - seeds: <none>
[10:24:17.911]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.911] getGlobalsAndPackages() ...
[10:24:17.912] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.912] Resolving globals: FALSE
[10:24:17.912] Tweak future expression to call with '...' arguments ...
[10:24:17.912] {
[10:24:17.912]     do.call(function(...) {
[10:24:17.912]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.912]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.912]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.912]             on.exit(options(oopts), add = TRUE)
[10:24:17.912]         }
[10:24:17.912]         {
[10:24:17.912]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.912]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.912]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.912]             })
[10:24:17.912]         }
[10:24:17.912]     }, args = future.call.arguments)
[10:24:17.912] }
[10:24:17.913] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.913] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.913] - packages: [1] ‘future.apply’
[10:24:17.914] getGlobalsAndPackages() ... DONE
[10:24:17.914] run() for ‘Future’ ...
[10:24:17.914] - state: ‘created’
[10:24:17.915] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.919] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.919]   - Field: ‘label’
[10:24:17.919]   - Field: ‘local’
[10:24:17.919]   - Field: ‘owner’
[10:24:17.919]   - Field: ‘envir’
[10:24:17.920]   - Field: ‘workers’
[10:24:17.920]   - Field: ‘packages’
[10:24:17.920]   - Field: ‘gc’
[10:24:17.920]   - Field: ‘job’
[10:24:17.920]   - Field: ‘conditions’
[10:24:17.920]   - Field: ‘expr’
[10:24:17.920]   - Field: ‘uuid’
[10:24:17.920]   - Field: ‘seed’
[10:24:17.920]   - Field: ‘version’
[10:24:17.920]   - Field: ‘result’
[10:24:17.920]   - Field: ‘asynchronous’
[10:24:17.921]   - Field: ‘calls’
[10:24:17.921]   - Field: ‘globals’
[10:24:17.921]   - Field: ‘stdout’
[10:24:17.921]   - Field: ‘earlySignal’
[10:24:17.921]   - Field: ‘lazy’
[10:24:17.921]   - Field: ‘state’
[10:24:17.921] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.921] - Launch lazy future ...
[10:24:17.922] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.922] Packages needed by future strategies (n = 0): <none>
[10:24:17.922] {
[10:24:17.922]     {
[10:24:17.922]         {
[10:24:17.922]             ...future.startTime <- base::Sys.time()
[10:24:17.922]             {
[10:24:17.922]                 {
[10:24:17.922]                   {
[10:24:17.922]                     {
[10:24:17.922]                       {
[10:24:17.922]                         base::local({
[10:24:17.922]                           has_future <- base::requireNamespace("future", 
[10:24:17.922]                             quietly = TRUE)
[10:24:17.922]                           if (has_future) {
[10:24:17.922]                             ns <- base::getNamespace("future")
[10:24:17.922]                             version <- ns[[".package"]][["version"]]
[10:24:17.922]                             if (is.null(version)) 
[10:24:17.922]                               version <- utils::packageVersion("future")
[10:24:17.922]                           }
[10:24:17.922]                           else {
[10:24:17.922]                             version <- NULL
[10:24:17.922]                           }
[10:24:17.922]                           if (!has_future || version < "1.8.0") {
[10:24:17.922]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.922]                               "", base::R.version$version.string), 
[10:24:17.922]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.922]                                 base::R.version$platform, 8 * 
[10:24:17.922]                                   base::.Machine$sizeof.pointer), 
[10:24:17.922]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.922]                                 "release", "version")], collapse = " "), 
[10:24:17.922]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.922]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.922]                               info)
[10:24:17.922]                             info <- base::paste(info, collapse = "; ")
[10:24:17.922]                             if (!has_future) {
[10:24:17.922]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.922]                                 info)
[10:24:17.922]                             }
[10:24:17.922]                             else {
[10:24:17.922]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.922]                                 info, version)
[10:24:17.922]                             }
[10:24:17.922]                             base::stop(msg)
[10:24:17.922]                           }
[10:24:17.922]                         })
[10:24:17.922]                       }
[10:24:17.922]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.922]                       base::options(mc.cores = 1L)
[10:24:17.922]                     }
[10:24:17.922]                     base::local({
[10:24:17.922]                       for (pkg in "future.apply") {
[10:24:17.922]                         base::loadNamespace(pkg)
[10:24:17.922]                         base::library(pkg, character.only = TRUE)
[10:24:17.922]                       }
[10:24:17.922]                     })
[10:24:17.922]                   }
[10:24:17.922]                   options(future.plan = NULL)
[10:24:17.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.922]                 }
[10:24:17.922]                 ...future.workdir <- getwd()
[10:24:17.922]             }
[10:24:17.922]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.922]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.922]         }
[10:24:17.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.922]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.922]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.922]             base::names(...future.oldOptions))
[10:24:17.922]     }
[10:24:17.922]     if (FALSE) {
[10:24:17.922]     }
[10:24:17.922]     else {
[10:24:17.922]         if (TRUE) {
[10:24:17.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.922]                 open = "w")
[10:24:17.922]         }
[10:24:17.922]         else {
[10:24:17.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.922]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.922]         }
[10:24:17.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.922]             base::sink(type = "output", split = FALSE)
[10:24:17.922]             base::close(...future.stdout)
[10:24:17.922]         }, add = TRUE)
[10:24:17.922]     }
[10:24:17.922]     ...future.frame <- base::sys.nframe()
[10:24:17.922]     ...future.conditions <- base::list()
[10:24:17.922]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.922]     if (FALSE) {
[10:24:17.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.922]     }
[10:24:17.922]     ...future.result <- base::tryCatch({
[10:24:17.922]         base::withCallingHandlers({
[10:24:17.922]             ...future.value <- base::withVisible(base::local({
[10:24:17.922]                 withCallingHandlers({
[10:24:17.922]                   {
[10:24:17.922]                     do.call(function(...) {
[10:24:17.922]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.922]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.922]                         ...future.globals.maxSize)) {
[10:24:17.922]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.922]                         on.exit(options(oopts), add = TRUE)
[10:24:17.922]                       }
[10:24:17.922]                       {
[10:24:17.922]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.922]                           FUN = function(jj) {
[10:24:17.922]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.922]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.922]                           })
[10:24:17.922]                       }
[10:24:17.922]                     }, args = future.call.arguments)
[10:24:17.922]                   }
[10:24:17.922]                 }, immediateCondition = function(cond) {
[10:24:17.922]                   save_rds <- function (object, pathname, ...) 
[10:24:17.922]                   {
[10:24:17.922]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.922]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.922]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.922]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.922]                         fi_tmp[["mtime"]])
[10:24:17.922]                     }
[10:24:17.922]                     tryCatch({
[10:24:17.922]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.922]                     }, error = function(ex) {
[10:24:17.922]                       msg <- conditionMessage(ex)
[10:24:17.922]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.922]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.922]                         fi_tmp[["mtime"]], msg)
[10:24:17.922]                       ex$message <- msg
[10:24:17.922]                       stop(ex)
[10:24:17.922]                     })
[10:24:17.922]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.922]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.922]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.922]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.922]                       fi <- file.info(pathname)
[10:24:17.922]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.922]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.922]                         fi[["size"]], fi[["mtime"]])
[10:24:17.922]                       stop(msg)
[10:24:17.922]                     }
[10:24:17.922]                     invisible(pathname)
[10:24:17.922]                   }
[10:24:17.922]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.922]                     rootPath = tempdir()) 
[10:24:17.922]                   {
[10:24:17.922]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.922]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.922]                       tmpdir = path, fileext = ".rds")
[10:24:17.922]                     save_rds(obj, file)
[10:24:17.922]                   }
[10:24:17.922]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.922]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.922]                   {
[10:24:17.922]                     inherits <- base::inherits
[10:24:17.922]                     invokeRestart <- base::invokeRestart
[10:24:17.922]                     is.null <- base::is.null
[10:24:17.922]                     muffled <- FALSE
[10:24:17.922]                     if (inherits(cond, "message")) {
[10:24:17.922]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.922]                       if (muffled) 
[10:24:17.922]                         invokeRestart("muffleMessage")
[10:24:17.922]                     }
[10:24:17.922]                     else if (inherits(cond, "warning")) {
[10:24:17.922]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.922]                       if (muffled) 
[10:24:17.922]                         invokeRestart("muffleWarning")
[10:24:17.922]                     }
[10:24:17.922]                     else if (inherits(cond, "condition")) {
[10:24:17.922]                       if (!is.null(pattern)) {
[10:24:17.922]                         computeRestarts <- base::computeRestarts
[10:24:17.922]                         grepl <- base::grepl
[10:24:17.922]                         restarts <- computeRestarts(cond)
[10:24:17.922]                         for (restart in restarts) {
[10:24:17.922]                           name <- restart$name
[10:24:17.922]                           if (is.null(name)) 
[10:24:17.922]                             next
[10:24:17.922]                           if (!grepl(pattern, name)) 
[10:24:17.922]                             next
[10:24:17.922]                           invokeRestart(restart)
[10:24:17.922]                           muffled <- TRUE
[10:24:17.922]                           break
[10:24:17.922]                         }
[10:24:17.922]                       }
[10:24:17.922]                     }
[10:24:17.922]                     invisible(muffled)
[10:24:17.922]                   }
[10:24:17.922]                   muffleCondition(cond)
[10:24:17.922]                 })
[10:24:17.922]             }))
[10:24:17.922]             future::FutureResult(value = ...future.value$value, 
[10:24:17.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.922]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.922]                     ...future.globalenv.names))
[10:24:17.922]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.922]         }, condition = base::local({
[10:24:17.922]             c <- base::c
[10:24:17.922]             inherits <- base::inherits
[10:24:17.922]             invokeRestart <- base::invokeRestart
[10:24:17.922]             length <- base::length
[10:24:17.922]             list <- base::list
[10:24:17.922]             seq.int <- base::seq.int
[10:24:17.922]             signalCondition <- base::signalCondition
[10:24:17.922]             sys.calls <- base::sys.calls
[10:24:17.922]             `[[` <- base::`[[`
[10:24:17.922]             `+` <- base::`+`
[10:24:17.922]             `<<-` <- base::`<<-`
[10:24:17.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.922]                   3L)]
[10:24:17.922]             }
[10:24:17.922]             function(cond) {
[10:24:17.922]                 is_error <- inherits(cond, "error")
[10:24:17.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.922]                   NULL)
[10:24:17.922]                 if (is_error) {
[10:24:17.922]                   sessionInformation <- function() {
[10:24:17.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.922]                       search = base::search(), system = base::Sys.info())
[10:24:17.922]                   }
[10:24:17.922]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.922]                     cond$call), session = sessionInformation(), 
[10:24:17.922]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.922]                   signalCondition(cond)
[10:24:17.922]                 }
[10:24:17.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.922]                 "immediateCondition"))) {
[10:24:17.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.922]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.922]                   if (TRUE && !signal) {
[10:24:17.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.922]                     {
[10:24:17.922]                       inherits <- base::inherits
[10:24:17.922]                       invokeRestart <- base::invokeRestart
[10:24:17.922]                       is.null <- base::is.null
[10:24:17.922]                       muffled <- FALSE
[10:24:17.922]                       if (inherits(cond, "message")) {
[10:24:17.922]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.922]                         if (muffled) 
[10:24:17.922]                           invokeRestart("muffleMessage")
[10:24:17.922]                       }
[10:24:17.922]                       else if (inherits(cond, "warning")) {
[10:24:17.922]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.922]                         if (muffled) 
[10:24:17.922]                           invokeRestart("muffleWarning")
[10:24:17.922]                       }
[10:24:17.922]                       else if (inherits(cond, "condition")) {
[10:24:17.922]                         if (!is.null(pattern)) {
[10:24:17.922]                           computeRestarts <- base::computeRestarts
[10:24:17.922]                           grepl <- base::grepl
[10:24:17.922]                           restarts <- computeRestarts(cond)
[10:24:17.922]                           for (restart in restarts) {
[10:24:17.922]                             name <- restart$name
[10:24:17.922]                             if (is.null(name)) 
[10:24:17.922]                               next
[10:24:17.922]                             if (!grepl(pattern, name)) 
[10:24:17.922]                               next
[10:24:17.922]                             invokeRestart(restart)
[10:24:17.922]                             muffled <- TRUE
[10:24:17.922]                             break
[10:24:17.922]                           }
[10:24:17.922]                         }
[10:24:17.922]                       }
[10:24:17.922]                       invisible(muffled)
[10:24:17.922]                     }
[10:24:17.922]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.922]                   }
[10:24:17.922]                 }
[10:24:17.922]                 else {
[10:24:17.922]                   if (TRUE) {
[10:24:17.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.922]                     {
[10:24:17.922]                       inherits <- base::inherits
[10:24:17.922]                       invokeRestart <- base::invokeRestart
[10:24:17.922]                       is.null <- base::is.null
[10:24:17.922]                       muffled <- FALSE
[10:24:17.922]                       if (inherits(cond, "message")) {
[10:24:17.922]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.922]                         if (muffled) 
[10:24:17.922]                           invokeRestart("muffleMessage")
[10:24:17.922]                       }
[10:24:17.922]                       else if (inherits(cond, "warning")) {
[10:24:17.922]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.922]                         if (muffled) 
[10:24:17.922]                           invokeRestart("muffleWarning")
[10:24:17.922]                       }
[10:24:17.922]                       else if (inherits(cond, "condition")) {
[10:24:17.922]                         if (!is.null(pattern)) {
[10:24:17.922]                           computeRestarts <- base::computeRestarts
[10:24:17.922]                           grepl <- base::grepl
[10:24:17.922]                           restarts <- computeRestarts(cond)
[10:24:17.922]                           for (restart in restarts) {
[10:24:17.922]                             name <- restart$name
[10:24:17.922]                             if (is.null(name)) 
[10:24:17.922]                               next
[10:24:17.922]                             if (!grepl(pattern, name)) 
[10:24:17.922]                               next
[10:24:17.922]                             invokeRestart(restart)
[10:24:17.922]                             muffled <- TRUE
[10:24:17.922]                             break
[10:24:17.922]                           }
[10:24:17.922]                         }
[10:24:17.922]                       }
[10:24:17.922]                       invisible(muffled)
[10:24:17.922]                     }
[10:24:17.922]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.922]                   }
[10:24:17.922]                 }
[10:24:17.922]             }
[10:24:17.922]         }))
[10:24:17.922]     }, error = function(ex) {
[10:24:17.922]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.922]                 ...future.rng), started = ...future.startTime, 
[10:24:17.922]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.922]             version = "1.8"), class = "FutureResult")
[10:24:17.922]     }, finally = {
[10:24:17.922]         if (!identical(...future.workdir, getwd())) 
[10:24:17.922]             setwd(...future.workdir)
[10:24:17.922]         {
[10:24:17.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.922]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.922]             }
[10:24:17.922]             base::options(...future.oldOptions)
[10:24:17.922]             if (.Platform$OS.type == "windows") {
[10:24:17.922]                 old_names <- names(...future.oldEnvVars)
[10:24:17.922]                 envs <- base::Sys.getenv()
[10:24:17.922]                 names <- names(envs)
[10:24:17.922]                 common <- intersect(names, old_names)
[10:24:17.922]                 added <- setdiff(names, old_names)
[10:24:17.922]                 removed <- setdiff(old_names, names)
[10:24:17.922]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.922]                   envs[common]]
[10:24:17.922]                 NAMES <- toupper(changed)
[10:24:17.922]                 args <- list()
[10:24:17.922]                 for (kk in seq_along(NAMES)) {
[10:24:17.922]                   name <- changed[[kk]]
[10:24:17.922]                   NAME <- NAMES[[kk]]
[10:24:17.922]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.922]                     next
[10:24:17.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.922]                 }
[10:24:17.922]                 NAMES <- toupper(added)
[10:24:17.922]                 for (kk in seq_along(NAMES)) {
[10:24:17.922]                   name <- added[[kk]]
[10:24:17.922]                   NAME <- NAMES[[kk]]
[10:24:17.922]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.922]                     next
[10:24:17.922]                   args[[name]] <- ""
[10:24:17.922]                 }
[10:24:17.922]                 NAMES <- toupper(removed)
[10:24:17.922]                 for (kk in seq_along(NAMES)) {
[10:24:17.922]                   name <- removed[[kk]]
[10:24:17.922]                   NAME <- NAMES[[kk]]
[10:24:17.922]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.922]                     next
[10:24:17.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.922]                 }
[10:24:17.922]                 if (length(args) > 0) 
[10:24:17.922]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.922]             }
[10:24:17.922]             else {
[10:24:17.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.922]             }
[10:24:17.922]             {
[10:24:17.922]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.922]                   0L) {
[10:24:17.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.922]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.922]                   base::options(opts)
[10:24:17.922]                 }
[10:24:17.922]                 {
[10:24:17.922]                   {
[10:24:17.922]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.922]                     NULL
[10:24:17.922]                   }
[10:24:17.922]                   options(future.plan = NULL)
[10:24:17.922]                   if (is.na(NA_character_)) 
[10:24:17.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.922]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.922]                     envir = parent.frame()) 
[10:24:17.922]                   {
[10:24:17.922]                     default_workers <- missing(workers)
[10:24:17.922]                     if (is.function(workers)) 
[10:24:17.922]                       workers <- workers()
[10:24:17.922]                     workers <- structure(as.integer(workers), 
[10:24:17.922]                       class = class(workers))
[10:24:17.922]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.922]                       1L)
[10:24:17.922]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.922]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.922]                       if (default_workers) 
[10:24:17.922]                         supportsMulticore(warn = TRUE)
[10:24:17.922]                       return(sequential(..., envir = envir))
[10:24:17.922]                     }
[10:24:17.922]                     oopts <- options(mc.cores = workers)
[10:24:17.922]                     on.exit(options(oopts))
[10:24:17.922]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.922]                       envir = envir)
[10:24:17.922]                     if (!future$lazy) 
[10:24:17.922]                       future <- run(future)
[10:24:17.922]                     invisible(future)
[10:24:17.922]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.922]                 }
[10:24:17.922]             }
[10:24:17.922]         }
[10:24:17.922]     })
[10:24:17.922]     if (TRUE) {
[10:24:17.922]         base::sink(type = "output", split = FALSE)
[10:24:17.922]         if (TRUE) {
[10:24:17.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.922]         }
[10:24:17.922]         else {
[10:24:17.922]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.922]         }
[10:24:17.922]         base::close(...future.stdout)
[10:24:17.922]         ...future.stdout <- NULL
[10:24:17.922]     }
[10:24:17.922]     ...future.result$conditions <- ...future.conditions
[10:24:17.922]     ...future.result$finished <- base::Sys.time()
[10:24:17.922]     ...future.result
[10:24:17.922] }
[10:24:17.925] assign_globals() ...
[10:24:17.925] List of 11
[10:24:17.925]  $ ...future.FUN            :function (x, ...)  
[10:24:17.925]  $ x_FUN                    :function (x)  
[10:24:17.925]  $ times                    : int 4
[10:24:17.925]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.925]  $ stop_if_not              :function (...)  
[10:24:17.925]  $ dim                      : int [1:2] 2 2
[10:24:17.925]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:17.925]  $ future.call.arguments    : list()
[10:24:17.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.925]  $ ...future.elements_ii    :List of 5
[10:24:17.925]   ..$ : int 1
[10:24:17.925]   ..$ : int 2
[10:24:17.925]   ..$ : int 3
[10:24:17.925]   ..$ : int 4
[10:24:17.925]   ..$ : int 5
[10:24:17.925]  $ ...future.seeds_ii       : NULL
[10:24:17.925]  $ ...future.globals.maxSize: NULL
[10:24:17.925]  - attr(*, "where")=List of 11
[10:24:17.925]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.925]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.925]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.925]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.925]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.925]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.925]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.925]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.925]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.925]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.925]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.925]  - attr(*, "resolved")= logi FALSE
[10:24:17.925]  - attr(*, "total_size")= num 105552
[10:24:17.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.925]  - attr(*, "already-done")= logi TRUE
[10:24:17.937] - copied ‘...future.FUN’ to environment
[10:24:17.937] - reassign environment for ‘x_FUN’
[10:24:17.938] - copied ‘x_FUN’ to environment
[10:24:17.938] - copied ‘times’ to environment
[10:24:17.938] - copied ‘stopf’ to environment
[10:24:17.938] - copied ‘stop_if_not’ to environment
[10:24:17.938] - copied ‘dim’ to environment
[10:24:17.938] - copied ‘valid_types’ to environment
[10:24:17.938] - copied ‘future.call.arguments’ to environment
[10:24:17.938] - copied ‘...future.elements_ii’ to environment
[10:24:17.938] - copied ‘...future.seeds_ii’ to environment
[10:24:17.938] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.939] assign_globals() ... done
[10:24:17.939] requestCore(): workers = 2
[10:24:17.941] MulticoreFuture started
[10:24:17.942] - Launch lazy future ... done
[10:24:17.942] run() for ‘MulticoreFuture’ ... done
[10:24:17.943] Created future:
[10:24:17.943] plan(): Setting new future strategy stack:
[10:24:17.944] List of future strategies:
[10:24:17.944] 1. sequential:
[10:24:17.944]    - args: function (..., envir = parent.frame())
[10:24:17.944]    - tweaked: FALSE
[10:24:17.944]    - call: NULL
[10:24:17.945] plan(): nbrOfWorkers() = 1
[10:24:17.948] plan(): Setting new future strategy stack:
[10:24:17.948] List of future strategies:
[10:24:17.948] 1. multicore:
[10:24:17.948]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:17.948]    - tweaked: FALSE
[10:24:17.948]    - call: plan(strategy)
[10:24:17.954] plan(): nbrOfWorkers() = 2
[10:24:17.943] MulticoreFuture:
[10:24:17.943] Label: ‘future_vapply-1’
[10:24:17.943] Expression:
[10:24:17.943] {
[10:24:17.943]     do.call(function(...) {
[10:24:17.943]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.943]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.943]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.943]             on.exit(options(oopts), add = TRUE)
[10:24:17.943]         }
[10:24:17.943]         {
[10:24:17.943]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.943]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.943]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.943]             })
[10:24:17.943]         }
[10:24:17.943]     }, args = future.call.arguments)
[10:24:17.943] }
[10:24:17.943] Lazy evaluation: FALSE
[10:24:17.943] Asynchronous evaluation: TRUE
[10:24:17.943] Local evaluation: TRUE
[10:24:17.943] Environment: R_GlobalEnv
[10:24:17.943] Capture standard output: TRUE
[10:24:17.943] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.943] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.943] Packages: 1 packages (‘future.apply’)
[10:24:17.943] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.943] Resolved: TRUE
[10:24:17.943] Value: <not collected>
[10:24:17.943] Conditions captured: <none>
[10:24:17.943] Early signaling: FALSE
[10:24:17.943] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.943] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.955] Chunk #1 of 2 ... DONE
[10:24:17.955] Chunk #2 of 2 ...
[10:24:17.955]  - Finding globals in 'X' for chunk #2 ...
[10:24:17.955] getGlobalsAndPackages() ...
[10:24:17.956] Searching for globals...
[10:24:17.956] 
[10:24:17.956] Searching for globals ... DONE
[10:24:17.956] - globals: [0] <none>
[10:24:17.956] getGlobalsAndPackages() ... DONE
[10:24:17.957]    + additional globals found: [n=0] 
[10:24:17.957]    + additional namespaces needed: [n=0] 
[10:24:17.957]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:17.957]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:17.957]  - seeds: <none>
[10:24:17.957]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.958] getGlobalsAndPackages() ...
[10:24:17.958] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.958] Resolving globals: FALSE
[10:24:17.958] Tweak future expression to call with '...' arguments ...
[10:24:17.958] {
[10:24:17.958]     do.call(function(...) {
[10:24:17.958]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.958]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.958]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.958]             on.exit(options(oopts), add = TRUE)
[10:24:17.958]         }
[10:24:17.958]         {
[10:24:17.958]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.958]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.958]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.958]             })
[10:24:17.958]         }
[10:24:17.958]     }, args = future.call.arguments)
[10:24:17.958] }
[10:24:17.959] Tweak future expression to call with '...' arguments ... DONE
[10:24:17.960] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:17.960] - packages: [1] ‘future.apply’
[10:24:17.960] getGlobalsAndPackages() ... DONE
[10:24:17.961] run() for ‘Future’ ...
[10:24:17.961] - state: ‘created’
[10:24:17.961] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:17.965] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:17.966] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:17.966]   - Field: ‘label’
[10:24:17.966]   - Field: ‘local’
[10:24:17.966]   - Field: ‘owner’
[10:24:17.966]   - Field: ‘envir’
[10:24:17.966]   - Field: ‘workers’
[10:24:17.967]   - Field: ‘packages’
[10:24:17.967]   - Field: ‘gc’
[10:24:17.967]   - Field: ‘job’
[10:24:17.967]   - Field: ‘conditions’
[10:24:17.967]   - Field: ‘expr’
[10:24:17.967]   - Field: ‘uuid’
[10:24:17.967]   - Field: ‘seed’
[10:24:17.968]   - Field: ‘version’
[10:24:17.968]   - Field: ‘result’
[10:24:17.968]   - Field: ‘asynchronous’
[10:24:17.968]   - Field: ‘calls’
[10:24:17.968]   - Field: ‘globals’
[10:24:17.968]   - Field: ‘stdout’
[10:24:17.968]   - Field: ‘earlySignal’
[10:24:17.969]   - Field: ‘lazy’
[10:24:17.969]   - Field: ‘state’
[10:24:17.969] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:17.969] - Launch lazy future ...
[10:24:17.970] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:17.970] Packages needed by future strategies (n = 0): <none>
[10:24:17.973] {
[10:24:17.973]     {
[10:24:17.973]         {
[10:24:17.973]             ...future.startTime <- base::Sys.time()
[10:24:17.973]             {
[10:24:17.973]                 {
[10:24:17.973]                   {
[10:24:17.973]                     {
[10:24:17.973]                       {
[10:24:17.973]                         base::local({
[10:24:17.973]                           has_future <- base::requireNamespace("future", 
[10:24:17.973]                             quietly = TRUE)
[10:24:17.973]                           if (has_future) {
[10:24:17.973]                             ns <- base::getNamespace("future")
[10:24:17.973]                             version <- ns[[".package"]][["version"]]
[10:24:17.973]                             if (is.null(version)) 
[10:24:17.973]                               version <- utils::packageVersion("future")
[10:24:17.973]                           }
[10:24:17.973]                           else {
[10:24:17.973]                             version <- NULL
[10:24:17.973]                           }
[10:24:17.973]                           if (!has_future || version < "1.8.0") {
[10:24:17.973]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:17.973]                               "", base::R.version$version.string), 
[10:24:17.973]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:17.973]                                 base::R.version$platform, 8 * 
[10:24:17.973]                                   base::.Machine$sizeof.pointer), 
[10:24:17.973]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:17.973]                                 "release", "version")], collapse = " "), 
[10:24:17.973]                               hostname = base::Sys.info()[["nodename"]])
[10:24:17.973]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:17.973]                               info)
[10:24:17.973]                             info <- base::paste(info, collapse = "; ")
[10:24:17.973]                             if (!has_future) {
[10:24:17.973]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:17.973]                                 info)
[10:24:17.973]                             }
[10:24:17.973]                             else {
[10:24:17.973]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:17.973]                                 info, version)
[10:24:17.973]                             }
[10:24:17.973]                             base::stop(msg)
[10:24:17.973]                           }
[10:24:17.973]                         })
[10:24:17.973]                       }
[10:24:17.973]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:17.973]                       base::options(mc.cores = 1L)
[10:24:17.973]                     }
[10:24:17.973]                     base::local({
[10:24:17.973]                       for (pkg in "future.apply") {
[10:24:17.973]                         base::loadNamespace(pkg)
[10:24:17.973]                         base::library(pkg, character.only = TRUE)
[10:24:17.973]                       }
[10:24:17.973]                     })
[10:24:17.973]                   }
[10:24:17.973]                   options(future.plan = NULL)
[10:24:17.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:17.973]                 }
[10:24:17.973]                 ...future.workdir <- getwd()
[10:24:17.973]             }
[10:24:17.973]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:17.973]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:17.973]         }
[10:24:17.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:17.973]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:17.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:17.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:17.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:17.973]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:17.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:17.973]             base::names(...future.oldOptions))
[10:24:17.973]     }
[10:24:17.973]     if (FALSE) {
[10:24:17.973]     }
[10:24:17.973]     else {
[10:24:17.973]         if (TRUE) {
[10:24:17.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:17.973]                 open = "w")
[10:24:17.973]         }
[10:24:17.973]         else {
[10:24:17.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:17.973]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:17.973]         }
[10:24:17.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:17.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:17.973]             base::sink(type = "output", split = FALSE)
[10:24:17.973]             base::close(...future.stdout)
[10:24:17.973]         }, add = TRUE)
[10:24:17.973]     }
[10:24:17.973]     ...future.frame <- base::sys.nframe()
[10:24:17.973]     ...future.conditions <- base::list()
[10:24:17.973]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:17.973]     if (FALSE) {
[10:24:17.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:17.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:17.973]     }
[10:24:17.973]     ...future.result <- base::tryCatch({
[10:24:17.973]         base::withCallingHandlers({
[10:24:17.973]             ...future.value <- base::withVisible(base::local({
[10:24:17.973]                 withCallingHandlers({
[10:24:17.973]                   {
[10:24:17.973]                     do.call(function(...) {
[10:24:17.973]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.973]                       if (!identical(...future.globals.maxSize.org, 
[10:24:17.973]                         ...future.globals.maxSize)) {
[10:24:17.973]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.973]                         on.exit(options(oopts), add = TRUE)
[10:24:17.973]                       }
[10:24:17.973]                       {
[10:24:17.973]                         lapply(seq_along(...future.elements_ii), 
[10:24:17.973]                           FUN = function(jj) {
[10:24:17.973]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.973]                             ...future.FUN(...future.X_jj, ...)
[10:24:17.973]                           })
[10:24:17.973]                       }
[10:24:17.973]                     }, args = future.call.arguments)
[10:24:17.973]                   }
[10:24:17.973]                 }, immediateCondition = function(cond) {
[10:24:17.973]                   save_rds <- function (object, pathname, ...) 
[10:24:17.973]                   {
[10:24:17.973]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:17.973]                     if (file_test("-f", pathname_tmp)) {
[10:24:17.973]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.973]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:17.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.973]                         fi_tmp[["mtime"]])
[10:24:17.973]                     }
[10:24:17.973]                     tryCatch({
[10:24:17.973]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:17.973]                     }, error = function(ex) {
[10:24:17.973]                       msg <- conditionMessage(ex)
[10:24:17.973]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.973]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:17.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.973]                         fi_tmp[["mtime"]], msg)
[10:24:17.973]                       ex$message <- msg
[10:24:17.973]                       stop(ex)
[10:24:17.973]                     })
[10:24:17.973]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:17.973]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:17.973]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:17.973]                       fi_tmp <- file.info(pathname_tmp)
[10:24:17.973]                       fi <- file.info(pathname)
[10:24:17.973]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:17.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:17.973]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:17.973]                         fi[["size"]], fi[["mtime"]])
[10:24:17.973]                       stop(msg)
[10:24:17.973]                     }
[10:24:17.973]                     invisible(pathname)
[10:24:17.973]                   }
[10:24:17.973]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:17.973]                     rootPath = tempdir()) 
[10:24:17.973]                   {
[10:24:17.973]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:17.973]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:17.973]                       tmpdir = path, fileext = ".rds")
[10:24:17.973]                     save_rds(obj, file)
[10:24:17.973]                   }
[10:24:17.973]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:17.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.973]                   {
[10:24:17.973]                     inherits <- base::inherits
[10:24:17.973]                     invokeRestart <- base::invokeRestart
[10:24:17.973]                     is.null <- base::is.null
[10:24:17.973]                     muffled <- FALSE
[10:24:17.973]                     if (inherits(cond, "message")) {
[10:24:17.973]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:17.973]                       if (muffled) 
[10:24:17.973]                         invokeRestart("muffleMessage")
[10:24:17.973]                     }
[10:24:17.973]                     else if (inherits(cond, "warning")) {
[10:24:17.973]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:17.973]                       if (muffled) 
[10:24:17.973]                         invokeRestart("muffleWarning")
[10:24:17.973]                     }
[10:24:17.973]                     else if (inherits(cond, "condition")) {
[10:24:17.973]                       if (!is.null(pattern)) {
[10:24:17.973]                         computeRestarts <- base::computeRestarts
[10:24:17.973]                         grepl <- base::grepl
[10:24:17.973]                         restarts <- computeRestarts(cond)
[10:24:17.973]                         for (restart in restarts) {
[10:24:17.973]                           name <- restart$name
[10:24:17.973]                           if (is.null(name)) 
[10:24:17.973]                             next
[10:24:17.973]                           if (!grepl(pattern, name)) 
[10:24:17.973]                             next
[10:24:17.973]                           invokeRestart(restart)
[10:24:17.973]                           muffled <- TRUE
[10:24:17.973]                           break
[10:24:17.973]                         }
[10:24:17.973]                       }
[10:24:17.973]                     }
[10:24:17.973]                     invisible(muffled)
[10:24:17.973]                   }
[10:24:17.973]                   muffleCondition(cond)
[10:24:17.973]                 })
[10:24:17.973]             }))
[10:24:17.973]             future::FutureResult(value = ...future.value$value, 
[10:24:17.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.973]                   ...future.rng), globalenv = if (FALSE) 
[10:24:17.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:17.973]                     ...future.globalenv.names))
[10:24:17.973]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:17.973]         }, condition = base::local({
[10:24:17.973]             c <- base::c
[10:24:17.973]             inherits <- base::inherits
[10:24:17.973]             invokeRestart <- base::invokeRestart
[10:24:17.973]             length <- base::length
[10:24:17.973]             list <- base::list
[10:24:17.973]             seq.int <- base::seq.int
[10:24:17.973]             signalCondition <- base::signalCondition
[10:24:17.973]             sys.calls <- base::sys.calls
[10:24:17.973]             `[[` <- base::`[[`
[10:24:17.973]             `+` <- base::`+`
[10:24:17.973]             `<<-` <- base::`<<-`
[10:24:17.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:17.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:17.973]                   3L)]
[10:24:17.973]             }
[10:24:17.973]             function(cond) {
[10:24:17.973]                 is_error <- inherits(cond, "error")
[10:24:17.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:17.973]                   NULL)
[10:24:17.973]                 if (is_error) {
[10:24:17.973]                   sessionInformation <- function() {
[10:24:17.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:17.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:17.973]                       search = base::search(), system = base::Sys.info())
[10:24:17.973]                   }
[10:24:17.973]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:17.973]                     cond$call), session = sessionInformation(), 
[10:24:17.973]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:17.973]                   signalCondition(cond)
[10:24:17.973]                 }
[10:24:17.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:17.973]                 "immediateCondition"))) {
[10:24:17.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:17.973]                   ...future.conditions[[length(...future.conditions) + 
[10:24:17.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:17.973]                   if (TRUE && !signal) {
[10:24:17.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.973]                     {
[10:24:17.973]                       inherits <- base::inherits
[10:24:17.973]                       invokeRestart <- base::invokeRestart
[10:24:17.973]                       is.null <- base::is.null
[10:24:17.973]                       muffled <- FALSE
[10:24:17.973]                       if (inherits(cond, "message")) {
[10:24:17.973]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.973]                         if (muffled) 
[10:24:17.973]                           invokeRestart("muffleMessage")
[10:24:17.973]                       }
[10:24:17.973]                       else if (inherits(cond, "warning")) {
[10:24:17.973]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.973]                         if (muffled) 
[10:24:17.973]                           invokeRestart("muffleWarning")
[10:24:17.973]                       }
[10:24:17.973]                       else if (inherits(cond, "condition")) {
[10:24:17.973]                         if (!is.null(pattern)) {
[10:24:17.973]                           computeRestarts <- base::computeRestarts
[10:24:17.973]                           grepl <- base::grepl
[10:24:17.973]                           restarts <- computeRestarts(cond)
[10:24:17.973]                           for (restart in restarts) {
[10:24:17.973]                             name <- restart$name
[10:24:17.973]                             if (is.null(name)) 
[10:24:17.973]                               next
[10:24:17.973]                             if (!grepl(pattern, name)) 
[10:24:17.973]                               next
[10:24:17.973]                             invokeRestart(restart)
[10:24:17.973]                             muffled <- TRUE
[10:24:17.973]                             break
[10:24:17.973]                           }
[10:24:17.973]                         }
[10:24:17.973]                       }
[10:24:17.973]                       invisible(muffled)
[10:24:17.973]                     }
[10:24:17.973]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.973]                   }
[10:24:17.973]                 }
[10:24:17.973]                 else {
[10:24:17.973]                   if (TRUE) {
[10:24:17.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:17.973]                     {
[10:24:17.973]                       inherits <- base::inherits
[10:24:17.973]                       invokeRestart <- base::invokeRestart
[10:24:17.973]                       is.null <- base::is.null
[10:24:17.973]                       muffled <- FALSE
[10:24:17.973]                       if (inherits(cond, "message")) {
[10:24:17.973]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:17.973]                         if (muffled) 
[10:24:17.973]                           invokeRestart("muffleMessage")
[10:24:17.973]                       }
[10:24:17.973]                       else if (inherits(cond, "warning")) {
[10:24:17.973]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:17.973]                         if (muffled) 
[10:24:17.973]                           invokeRestart("muffleWarning")
[10:24:17.973]                       }
[10:24:17.973]                       else if (inherits(cond, "condition")) {
[10:24:17.973]                         if (!is.null(pattern)) {
[10:24:17.973]                           computeRestarts <- base::computeRestarts
[10:24:17.973]                           grepl <- base::grepl
[10:24:17.973]                           restarts <- computeRestarts(cond)
[10:24:17.973]                           for (restart in restarts) {
[10:24:17.973]                             name <- restart$name
[10:24:17.973]                             if (is.null(name)) 
[10:24:17.973]                               next
[10:24:17.973]                             if (!grepl(pattern, name)) 
[10:24:17.973]                               next
[10:24:17.973]                             invokeRestart(restart)
[10:24:17.973]                             muffled <- TRUE
[10:24:17.973]                             break
[10:24:17.973]                           }
[10:24:17.973]                         }
[10:24:17.973]                       }
[10:24:17.973]                       invisible(muffled)
[10:24:17.973]                     }
[10:24:17.973]                     muffleCondition(cond, pattern = "^muffle")
[10:24:17.973]                   }
[10:24:17.973]                 }
[10:24:17.973]             }
[10:24:17.973]         }))
[10:24:17.973]     }, error = function(ex) {
[10:24:17.973]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:17.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:17.973]                 ...future.rng), started = ...future.startTime, 
[10:24:17.973]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:17.973]             version = "1.8"), class = "FutureResult")
[10:24:17.973]     }, finally = {
[10:24:17.973]         if (!identical(...future.workdir, getwd())) 
[10:24:17.973]             setwd(...future.workdir)
[10:24:17.973]         {
[10:24:17.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:17.973]                 ...future.oldOptions$nwarnings <- NULL
[10:24:17.973]             }
[10:24:17.973]             base::options(...future.oldOptions)
[10:24:17.973]             if (.Platform$OS.type == "windows") {
[10:24:17.973]                 old_names <- names(...future.oldEnvVars)
[10:24:17.973]                 envs <- base::Sys.getenv()
[10:24:17.973]                 names <- names(envs)
[10:24:17.973]                 common <- intersect(names, old_names)
[10:24:17.973]                 added <- setdiff(names, old_names)
[10:24:17.973]                 removed <- setdiff(old_names, names)
[10:24:17.973]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:17.973]                   envs[common]]
[10:24:17.973]                 NAMES <- toupper(changed)
[10:24:17.973]                 args <- list()
[10:24:17.973]                 for (kk in seq_along(NAMES)) {
[10:24:17.973]                   name <- changed[[kk]]
[10:24:17.973]                   NAME <- NAMES[[kk]]
[10:24:17.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.973]                     next
[10:24:17.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.973]                 }
[10:24:17.973]                 NAMES <- toupper(added)
[10:24:17.973]                 for (kk in seq_along(NAMES)) {
[10:24:17.973]                   name <- added[[kk]]
[10:24:17.973]                   NAME <- NAMES[[kk]]
[10:24:17.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.973]                     next
[10:24:17.973]                   args[[name]] <- ""
[10:24:17.973]                 }
[10:24:17.973]                 NAMES <- toupper(removed)
[10:24:17.973]                 for (kk in seq_along(NAMES)) {
[10:24:17.973]                   name <- removed[[kk]]
[10:24:17.973]                   NAME <- NAMES[[kk]]
[10:24:17.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:17.973]                     next
[10:24:17.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:17.973]                 }
[10:24:17.973]                 if (length(args) > 0) 
[10:24:17.973]                   base::do.call(base::Sys.setenv, args = args)
[10:24:17.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:17.973]             }
[10:24:17.973]             else {
[10:24:17.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:17.973]             }
[10:24:17.973]             {
[10:24:17.973]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:17.973]                   0L) {
[10:24:17.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:17.973]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:17.973]                   base::options(opts)
[10:24:17.973]                 }
[10:24:17.973]                 {
[10:24:17.973]                   {
[10:24:17.973]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:17.973]                     NULL
[10:24:17.973]                   }
[10:24:17.973]                   options(future.plan = NULL)
[10:24:17.973]                   if (is.na(NA_character_)) 
[10:24:17.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:17.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:17.973]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:17.973]                     envir = parent.frame()) 
[10:24:17.973]                   {
[10:24:17.973]                     default_workers <- missing(workers)
[10:24:17.973]                     if (is.function(workers)) 
[10:24:17.973]                       workers <- workers()
[10:24:17.973]                     workers <- structure(as.integer(workers), 
[10:24:17.973]                       class = class(workers))
[10:24:17.973]                     stop_if_not(is.finite(workers), workers >= 
[10:24:17.973]                       1L)
[10:24:17.973]                     if ((workers == 1L && !inherits(workers, 
[10:24:17.973]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:17.973]                       if (default_workers) 
[10:24:17.973]                         supportsMulticore(warn = TRUE)
[10:24:17.973]                       return(sequential(..., envir = envir))
[10:24:17.973]                     }
[10:24:17.973]                     oopts <- options(mc.cores = workers)
[10:24:17.973]                     on.exit(options(oopts))
[10:24:17.973]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:17.973]                       envir = envir)
[10:24:17.973]                     if (!future$lazy) 
[10:24:17.973]                       future <- run(future)
[10:24:17.973]                     invisible(future)
[10:24:17.973]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:17.973]                 }
[10:24:17.973]             }
[10:24:17.973]         }
[10:24:17.973]     })
[10:24:17.973]     if (TRUE) {
[10:24:17.973]         base::sink(type = "output", split = FALSE)
[10:24:17.973]         if (TRUE) {
[10:24:17.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:17.973]         }
[10:24:17.973]         else {
[10:24:17.973]             ...future.result["stdout"] <- base::list(NULL)
[10:24:17.973]         }
[10:24:17.973]         base::close(...future.stdout)
[10:24:17.973]         ...future.stdout <- NULL
[10:24:17.973]     }
[10:24:17.973]     ...future.result$conditions <- ...future.conditions
[10:24:17.973]     ...future.result$finished <- base::Sys.time()
[10:24:17.973]     ...future.result
[10:24:17.973] }
[10:24:17.977] assign_globals() ...
[10:24:17.978] List of 11
[10:24:17.978]  $ ...future.FUN            :function (x, ...)  
[10:24:17.978]  $ x_FUN                    :function (x)  
[10:24:17.978]  $ times                    : int 4
[10:24:17.978]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:17.978]  $ stop_if_not              :function (...)  
[10:24:17.978]  $ dim                      : int [1:2] 2 2
[10:24:17.978]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:17.978]  $ future.call.arguments    : list()
[10:24:17.978]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:17.978]  $ ...future.elements_ii    :List of 5
[10:24:17.978]   ..$ : int 6
[10:24:17.978]   ..$ : int 7
[10:24:17.978]   ..$ : int 8
[10:24:17.978]   ..$ : int 9
[10:24:17.978]   ..$ : int 10
[10:24:17.978]  $ ...future.seeds_ii       : NULL
[10:24:17.978]  $ ...future.globals.maxSize: NULL
[10:24:17.978]  - attr(*, "where")=List of 11
[10:24:17.978]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:17.978]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:17.978]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:17.978]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:17.978]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:17.978]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:17.978]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:17.978]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:17.978]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:17.978]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:17.978]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:17.978]  - attr(*, "resolved")= logi FALSE
[10:24:17.978]  - attr(*, "total_size")= num 105552
[10:24:17.978]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:17.978]  - attr(*, "already-done")= logi TRUE
[10:24:17.992] - copied ‘...future.FUN’ to environment
[10:24:17.993] - reassign environment for ‘x_FUN’
[10:24:17.993] - copied ‘x_FUN’ to environment
[10:24:17.993] - copied ‘times’ to environment
[10:24:17.993] - copied ‘stopf’ to environment
[10:24:17.993] - copied ‘stop_if_not’ to environment
[10:24:17.993] - copied ‘dim’ to environment
[10:24:17.993] - copied ‘valid_types’ to environment
[10:24:17.993] - copied ‘future.call.arguments’ to environment
[10:24:17.994] - copied ‘...future.elements_ii’ to environment
[10:24:17.994] - copied ‘...future.seeds_ii’ to environment
[10:24:17.994] - copied ‘...future.globals.maxSize’ to environment
[10:24:17.994] assign_globals() ... done
[10:24:17.994] requestCore(): workers = 2
[10:24:17.996] MulticoreFuture started
[10:24:17.997] - Launch lazy future ... done
[10:24:17.997] run() for ‘MulticoreFuture’ ... done
[10:24:17.997] Created future:
[10:24:17.998] plan(): Setting new future strategy stack:
[10:24:17.998] List of future strategies:
[10:24:17.998] 1. sequential:
[10:24:17.998]    - args: function (..., envir = parent.frame())
[10:24:17.998]    - tweaked: FALSE
[10:24:17.998]    - call: NULL
[10:24:17.999] plan(): nbrOfWorkers() = 1
[10:24:18.001] plan(): Setting new future strategy stack:
[10:24:18.001] List of future strategies:
[10:24:18.001] 1. multicore:
[10:24:18.001]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.001]    - tweaked: FALSE
[10:24:18.001]    - call: plan(strategy)
[10:24:18.007] plan(): nbrOfWorkers() = 2
[10:24:17.997] MulticoreFuture:
[10:24:17.997] Label: ‘future_vapply-2’
[10:24:17.997] Expression:
[10:24:17.997] {
[10:24:17.997]     do.call(function(...) {
[10:24:17.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:17.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:17.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:17.997]             on.exit(options(oopts), add = TRUE)
[10:24:17.997]         }
[10:24:17.997]         {
[10:24:17.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:17.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:17.997]                 ...future.FUN(...future.X_jj, ...)
[10:24:17.997]             })
[10:24:17.997]         }
[10:24:17.997]     }, args = future.call.arguments)
[10:24:17.997] }
[10:24:17.997] Lazy evaluation: FALSE
[10:24:17.997] Asynchronous evaluation: TRUE
[10:24:17.997] Local evaluation: TRUE
[10:24:17.997] Environment: R_GlobalEnv
[10:24:17.997] Capture standard output: TRUE
[10:24:17.997] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:17.997] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:17.997] Packages: 1 packages (‘future.apply’)
[10:24:17.997] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:17.997] Resolved: TRUE
[10:24:17.997] Value: <not collected>
[10:24:17.997] Conditions captured: <none>
[10:24:17.997] Early signaling: FALSE
[10:24:17.997] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:17.997] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.008] Chunk #2 of 2 ... DONE
[10:24:18.008] Launching 2 futures (chunks) ... DONE
[10:24:18.008] Resolving 2 futures (chunks) ...
[10:24:18.008] resolve() on list ...
[10:24:18.009]  recursive: 0
[10:24:18.009]  length: 2
[10:24:18.009] 
[10:24:18.009] Future #1
[10:24:18.009] result() for MulticoreFuture ...
[10:24:18.010] result() for MulticoreFuture ...
[10:24:18.011] result() for MulticoreFuture ... done
[10:24:18.011] result() for MulticoreFuture ... done
[10:24:18.011] result() for MulticoreFuture ...
[10:24:18.011] result() for MulticoreFuture ... done
[10:24:18.011] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:18.012] - nx: 2
[10:24:18.012] - relay: TRUE
[10:24:18.012] - stdout: TRUE
[10:24:18.012] - signal: TRUE
[10:24:18.012] - resignal: FALSE
[10:24:18.012] - force: TRUE
[10:24:18.013] - relayed: [n=2] FALSE, FALSE
[10:24:18.013] - queued futures: [n=2] FALSE, FALSE
[10:24:18.013]  - until=1
[10:24:18.013]  - relaying element #1
[10:24:18.013] result() for MulticoreFuture ...
[10:24:18.014] result() for MulticoreFuture ... done
[10:24:18.014] result() for MulticoreFuture ...
[10:24:18.014] result() for MulticoreFuture ... done
[10:24:18.014] result() for MulticoreFuture ...
[10:24:18.015] result() for MulticoreFuture ... done
[10:24:18.015] result() for MulticoreFuture ...
[10:24:18.015] result() for MulticoreFuture ... done
[10:24:18.015] - relayed: [n=2] TRUE, FALSE
[10:24:18.015] - queued futures: [n=2] TRUE, FALSE
[10:24:18.015] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:18.015]  length: 1 (resolved future 1)
[10:24:18.016] Future #2
[10:24:18.016] result() for MulticoreFuture ...
[10:24:18.017] result() for MulticoreFuture ...
[10:24:18.017] result() for MulticoreFuture ... done
[10:24:18.017] result() for MulticoreFuture ... done
[10:24:18.017] result() for MulticoreFuture ...
[10:24:18.020] result() for MulticoreFuture ... done
[10:24:18.020] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:18.021] - nx: 2
[10:24:18.021] - relay: TRUE
[10:24:18.021] - stdout: TRUE
[10:24:18.021] - signal: TRUE
[10:24:18.021] - resignal: FALSE
[10:24:18.022] - force: TRUE
[10:24:18.022] - relayed: [n=2] TRUE, FALSE
[10:24:18.022] - queued futures: [n=2] TRUE, FALSE
[10:24:18.022]  - until=2
[10:24:18.022]  - relaying element #2
[10:24:18.022] result() for MulticoreFuture ...
[10:24:18.022] result() for MulticoreFuture ... done
[10:24:18.023] result() for MulticoreFuture ...
[10:24:18.023] result() for MulticoreFuture ... done
[10:24:18.023] result() for MulticoreFuture ...
[10:24:18.023] result() for MulticoreFuture ... done
[10:24:18.023] result() for MulticoreFuture ...
[10:24:18.023] result() for MulticoreFuture ... done
[10:24:18.024] - relayed: [n=2] TRUE, TRUE
[10:24:18.024] - queued futures: [n=2] TRUE, TRUE
[10:24:18.024] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:18.024]  length: 0 (resolved future 2)
[10:24:18.024] Relaying remaining futures
[10:24:18.024] signalConditionsASAP(NULL, pos=0) ...
[10:24:18.024] - nx: 2
[10:24:18.025] - relay: TRUE
[10:24:18.025] - stdout: TRUE
[10:24:18.025] - signal: TRUE
[10:24:18.025] - resignal: FALSE
[10:24:18.025] - force: TRUE
[10:24:18.025] - relayed: [n=2] TRUE, TRUE
[10:24:18.025] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:18.026] - relayed: [n=2] TRUE, TRUE
[10:24:18.026] - queued futures: [n=2] TRUE, TRUE
[10:24:18.026] signalConditionsASAP(NULL, pos=0) ... done
[10:24:18.026] resolve() on list ... DONE
[10:24:18.026] result() for MulticoreFuture ...
[10:24:18.026] result() for MulticoreFuture ... done
[10:24:18.027] result() for MulticoreFuture ...
[10:24:18.027] result() for MulticoreFuture ... done
[10:24:18.027] result() for MulticoreFuture ...
[10:24:18.027] result() for MulticoreFuture ... done
[10:24:18.027] result() for MulticoreFuture ...
[10:24:18.027] result() for MulticoreFuture ... done
[10:24:18.027]  - Number of value chunks collected: 2
[10:24:18.027] Resolving 2 futures (chunks) ... DONE
[10:24:18.028] Reducing values from 2 chunks ...
[10:24:18.028]  - Number of values collected after concatenation: 10
[10:24:18.028]  - Number of values expected: 10
[10:24:18.028] Reducing values from 2 chunks ... DONE
[10:24:18.028] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[10:24:18.031] future_lapply() ...
[10:24:18.037] Number of chunks: 2
[10:24:18.037] getGlobalsAndPackagesXApply() ...
[10:24:18.038]  - future.globals: TRUE
[10:24:18.038] getGlobalsAndPackages() ...
[10:24:18.038] Searching for globals...
[10:24:18.042] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[10:24:18.042] Searching for globals ... DONE
[10:24:18.042] Resolving globals: FALSE
[10:24:18.043] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[10:24:18.043] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:18.043] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:18.043] - packages: [2] ‘stats’, ‘future.apply’
[10:24:18.044] getGlobalsAndPackages() ... DONE
[10:24:18.044]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:18.044]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:24:18.044] Finding globals ... DONE
[10:24:18.044]  - use_args: TRUE
[10:24:18.044]  - Getting '...' globals ...
[10:24:18.044] resolve() on list ...
[10:24:18.045]  recursive: 0
[10:24:18.045]  length: 1
[10:24:18.045]  elements: ‘...’
[10:24:18.045]  length: 0 (resolved future 1)
[10:24:18.045] resolve() on list ... DONE
[10:24:18.045]    - '...' content: [n=0] 
[10:24:18.045] List of 1
[10:24:18.045]  $ ...: list()
[10:24:18.045]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.045]  - attr(*, "where")=List of 1
[10:24:18.045]   ..$ ...:<environment: 0x55b93b55ed90> 
[10:24:18.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.045]  - attr(*, "resolved")= logi TRUE
[10:24:18.045]  - attr(*, "total_size")= num NA
[10:24:18.050]  - Getting '...' globals ... DONE
[10:24:18.050] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:18.050] List of 8
[10:24:18.050]  $ ...future.FUN:function (x, ...)  
[10:24:18.050]  $ x_FUN        :function (x, ...)  
[10:24:18.050]  $ times        : int 5
[10:24:18.050]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.050]  $ stop_if_not  :function (...)  
[10:24:18.050]  $ dim          : NULL
[10:24:18.050]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:18.050]  $ ...          : list()
[10:24:18.050]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.050]  - attr(*, "where")=List of 8
[10:24:18.050]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:18.050]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:18.050]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:18.050]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:18.050]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:18.050]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:18.050]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:18.050]   ..$ ...          :<environment: 0x55b93b55ed90> 
[10:24:18.050]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.050]  - attr(*, "resolved")= logi FALSE
[10:24:18.050]  - attr(*, "total_size")= num 95528
[10:24:18.056] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:24:18.056] getGlobalsAndPackagesXApply() ... DONE
[10:24:18.056] Number of futures (= number of chunks): 2
[10:24:18.056] Launching 2 futures (chunks) ...
[10:24:18.056] Chunk #1 of 2 ...
[10:24:18.056]  - Finding globals in 'X' for chunk #1 ...
[10:24:18.057] getGlobalsAndPackages() ...
[10:24:18.057] Searching for globals...
[10:24:18.057] 
[10:24:18.057] Searching for globals ... DONE
[10:24:18.057] - globals: [0] <none>
[10:24:18.057] getGlobalsAndPackages() ... DONE
[10:24:18.057]    + additional globals found: [n=0] 
[10:24:18.057]    + additional namespaces needed: [n=0] 
[10:24:18.057]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:18.058]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.058]  - seeds: <none>
[10:24:18.058]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.058] getGlobalsAndPackages() ...
[10:24:18.058] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.058] Resolving globals: FALSE
[10:24:18.058] Tweak future expression to call with '...' arguments ...
[10:24:18.058] {
[10:24:18.058]     do.call(function(...) {
[10:24:18.058]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.058]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.058]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.058]             on.exit(options(oopts), add = TRUE)
[10:24:18.058]         }
[10:24:18.058]         {
[10:24:18.058]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.058]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.058]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.058]             })
[10:24:18.058]         }
[10:24:18.058]     }, args = future.call.arguments)
[10:24:18.058] }
[10:24:18.059] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.059] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.059] - packages: [2] ‘stats’, ‘future.apply’
[10:24:18.059] getGlobalsAndPackages() ... DONE
[10:24:18.060] run() for ‘Future’ ...
[10:24:18.060] - state: ‘created’
[10:24:18.060] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.064] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.064]   - Field: ‘label’
[10:24:18.064]   - Field: ‘local’
[10:24:18.064]   - Field: ‘owner’
[10:24:18.064]   - Field: ‘envir’
[10:24:18.064]   - Field: ‘workers’
[10:24:18.064]   - Field: ‘packages’
[10:24:18.064]   - Field: ‘gc’
[10:24:18.064]   - Field: ‘job’
[10:24:18.065]   - Field: ‘conditions’
[10:24:18.065]   - Field: ‘expr’
[10:24:18.065]   - Field: ‘uuid’
[10:24:18.065]   - Field: ‘seed’
[10:24:18.065]   - Field: ‘version’
[10:24:18.065]   - Field: ‘result’
[10:24:18.065]   - Field: ‘asynchronous’
[10:24:18.065]   - Field: ‘calls’
[10:24:18.065]   - Field: ‘globals’
[10:24:18.065]   - Field: ‘stdout’
[10:24:18.066]   - Field: ‘earlySignal’
[10:24:18.066]   - Field: ‘lazy’
[10:24:18.066]   - Field: ‘state’
[10:24:18.066] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.066] - Launch lazy future ...
[10:24:18.066] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:24:18.066] Packages needed by future strategies (n = 0): <none>
[10:24:18.067] {
[10:24:18.067]     {
[10:24:18.067]         {
[10:24:18.067]             ...future.startTime <- base::Sys.time()
[10:24:18.067]             {
[10:24:18.067]                 {
[10:24:18.067]                   {
[10:24:18.067]                     {
[10:24:18.067]                       {
[10:24:18.067]                         base::local({
[10:24:18.067]                           has_future <- base::requireNamespace("future", 
[10:24:18.067]                             quietly = TRUE)
[10:24:18.067]                           if (has_future) {
[10:24:18.067]                             ns <- base::getNamespace("future")
[10:24:18.067]                             version <- ns[[".package"]][["version"]]
[10:24:18.067]                             if (is.null(version)) 
[10:24:18.067]                               version <- utils::packageVersion("future")
[10:24:18.067]                           }
[10:24:18.067]                           else {
[10:24:18.067]                             version <- NULL
[10:24:18.067]                           }
[10:24:18.067]                           if (!has_future || version < "1.8.0") {
[10:24:18.067]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.067]                               "", base::R.version$version.string), 
[10:24:18.067]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.067]                                 base::R.version$platform, 8 * 
[10:24:18.067]                                   base::.Machine$sizeof.pointer), 
[10:24:18.067]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.067]                                 "release", "version")], collapse = " "), 
[10:24:18.067]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.067]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.067]                               info)
[10:24:18.067]                             info <- base::paste(info, collapse = "; ")
[10:24:18.067]                             if (!has_future) {
[10:24:18.067]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.067]                                 info)
[10:24:18.067]                             }
[10:24:18.067]                             else {
[10:24:18.067]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.067]                                 info, version)
[10:24:18.067]                             }
[10:24:18.067]                             base::stop(msg)
[10:24:18.067]                           }
[10:24:18.067]                         })
[10:24:18.067]                       }
[10:24:18.067]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.067]                       base::options(mc.cores = 1L)
[10:24:18.067]                     }
[10:24:18.067]                     base::local({
[10:24:18.067]                       for (pkg in c("stats", "future.apply")) {
[10:24:18.067]                         base::loadNamespace(pkg)
[10:24:18.067]                         base::library(pkg, character.only = TRUE)
[10:24:18.067]                       }
[10:24:18.067]                     })
[10:24:18.067]                   }
[10:24:18.067]                   options(future.plan = NULL)
[10:24:18.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.067]                 }
[10:24:18.067]                 ...future.workdir <- getwd()
[10:24:18.067]             }
[10:24:18.067]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.067]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.067]         }
[10:24:18.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.067]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.067]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.067]             base::names(...future.oldOptions))
[10:24:18.067]     }
[10:24:18.067]     if (FALSE) {
[10:24:18.067]     }
[10:24:18.067]     else {
[10:24:18.067]         if (TRUE) {
[10:24:18.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.067]                 open = "w")
[10:24:18.067]         }
[10:24:18.067]         else {
[10:24:18.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.067]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.067]         }
[10:24:18.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.067]             base::sink(type = "output", split = FALSE)
[10:24:18.067]             base::close(...future.stdout)
[10:24:18.067]         }, add = TRUE)
[10:24:18.067]     }
[10:24:18.067]     ...future.frame <- base::sys.nframe()
[10:24:18.067]     ...future.conditions <- base::list()
[10:24:18.067]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.067]     if (FALSE) {
[10:24:18.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.067]     }
[10:24:18.067]     ...future.result <- base::tryCatch({
[10:24:18.067]         base::withCallingHandlers({
[10:24:18.067]             ...future.value <- base::withVisible(base::local({
[10:24:18.067]                 withCallingHandlers({
[10:24:18.067]                   {
[10:24:18.067]                     do.call(function(...) {
[10:24:18.067]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.067]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.067]                         ...future.globals.maxSize)) {
[10:24:18.067]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.067]                         on.exit(options(oopts), add = TRUE)
[10:24:18.067]                       }
[10:24:18.067]                       {
[10:24:18.067]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.067]                           FUN = function(jj) {
[10:24:18.067]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.067]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.067]                           })
[10:24:18.067]                       }
[10:24:18.067]                     }, args = future.call.arguments)
[10:24:18.067]                   }
[10:24:18.067]                 }, immediateCondition = function(cond) {
[10:24:18.067]                   save_rds <- function (object, pathname, ...) 
[10:24:18.067]                   {
[10:24:18.067]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.067]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.067]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.067]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.067]                         fi_tmp[["mtime"]])
[10:24:18.067]                     }
[10:24:18.067]                     tryCatch({
[10:24:18.067]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.067]                     }, error = function(ex) {
[10:24:18.067]                       msg <- conditionMessage(ex)
[10:24:18.067]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.067]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.067]                         fi_tmp[["mtime"]], msg)
[10:24:18.067]                       ex$message <- msg
[10:24:18.067]                       stop(ex)
[10:24:18.067]                     })
[10:24:18.067]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.067]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.067]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.067]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.067]                       fi <- file.info(pathname)
[10:24:18.067]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.067]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.067]                         fi[["size"]], fi[["mtime"]])
[10:24:18.067]                       stop(msg)
[10:24:18.067]                     }
[10:24:18.067]                     invisible(pathname)
[10:24:18.067]                   }
[10:24:18.067]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.067]                     rootPath = tempdir()) 
[10:24:18.067]                   {
[10:24:18.067]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.067]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.067]                       tmpdir = path, fileext = ".rds")
[10:24:18.067]                     save_rds(obj, file)
[10:24:18.067]                   }
[10:24:18.067]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.067]                   {
[10:24:18.067]                     inherits <- base::inherits
[10:24:18.067]                     invokeRestart <- base::invokeRestart
[10:24:18.067]                     is.null <- base::is.null
[10:24:18.067]                     muffled <- FALSE
[10:24:18.067]                     if (inherits(cond, "message")) {
[10:24:18.067]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.067]                       if (muffled) 
[10:24:18.067]                         invokeRestart("muffleMessage")
[10:24:18.067]                     }
[10:24:18.067]                     else if (inherits(cond, "warning")) {
[10:24:18.067]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.067]                       if (muffled) 
[10:24:18.067]                         invokeRestart("muffleWarning")
[10:24:18.067]                     }
[10:24:18.067]                     else if (inherits(cond, "condition")) {
[10:24:18.067]                       if (!is.null(pattern)) {
[10:24:18.067]                         computeRestarts <- base::computeRestarts
[10:24:18.067]                         grepl <- base::grepl
[10:24:18.067]                         restarts <- computeRestarts(cond)
[10:24:18.067]                         for (restart in restarts) {
[10:24:18.067]                           name <- restart$name
[10:24:18.067]                           if (is.null(name)) 
[10:24:18.067]                             next
[10:24:18.067]                           if (!grepl(pattern, name)) 
[10:24:18.067]                             next
[10:24:18.067]                           invokeRestart(restart)
[10:24:18.067]                           muffled <- TRUE
[10:24:18.067]                           break
[10:24:18.067]                         }
[10:24:18.067]                       }
[10:24:18.067]                     }
[10:24:18.067]                     invisible(muffled)
[10:24:18.067]                   }
[10:24:18.067]                   muffleCondition(cond)
[10:24:18.067]                 })
[10:24:18.067]             }))
[10:24:18.067]             future::FutureResult(value = ...future.value$value, 
[10:24:18.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.067]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.067]                     ...future.globalenv.names))
[10:24:18.067]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.067]         }, condition = base::local({
[10:24:18.067]             c <- base::c
[10:24:18.067]             inherits <- base::inherits
[10:24:18.067]             invokeRestart <- base::invokeRestart
[10:24:18.067]             length <- base::length
[10:24:18.067]             list <- base::list
[10:24:18.067]             seq.int <- base::seq.int
[10:24:18.067]             signalCondition <- base::signalCondition
[10:24:18.067]             sys.calls <- base::sys.calls
[10:24:18.067]             `[[` <- base::`[[`
[10:24:18.067]             `+` <- base::`+`
[10:24:18.067]             `<<-` <- base::`<<-`
[10:24:18.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.067]                   3L)]
[10:24:18.067]             }
[10:24:18.067]             function(cond) {
[10:24:18.067]                 is_error <- inherits(cond, "error")
[10:24:18.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.067]                   NULL)
[10:24:18.067]                 if (is_error) {
[10:24:18.067]                   sessionInformation <- function() {
[10:24:18.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.067]                       search = base::search(), system = base::Sys.info())
[10:24:18.067]                   }
[10:24:18.067]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.067]                     cond$call), session = sessionInformation(), 
[10:24:18.067]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.067]                   signalCondition(cond)
[10:24:18.067]                 }
[10:24:18.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.067]                 "immediateCondition"))) {
[10:24:18.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.067]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.067]                   if (TRUE && !signal) {
[10:24:18.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.067]                     {
[10:24:18.067]                       inherits <- base::inherits
[10:24:18.067]                       invokeRestart <- base::invokeRestart
[10:24:18.067]                       is.null <- base::is.null
[10:24:18.067]                       muffled <- FALSE
[10:24:18.067]                       if (inherits(cond, "message")) {
[10:24:18.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.067]                         if (muffled) 
[10:24:18.067]                           invokeRestart("muffleMessage")
[10:24:18.067]                       }
[10:24:18.067]                       else if (inherits(cond, "warning")) {
[10:24:18.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.067]                         if (muffled) 
[10:24:18.067]                           invokeRestart("muffleWarning")
[10:24:18.067]                       }
[10:24:18.067]                       else if (inherits(cond, "condition")) {
[10:24:18.067]                         if (!is.null(pattern)) {
[10:24:18.067]                           computeRestarts <- base::computeRestarts
[10:24:18.067]                           grepl <- base::grepl
[10:24:18.067]                           restarts <- computeRestarts(cond)
[10:24:18.067]                           for (restart in restarts) {
[10:24:18.067]                             name <- restart$name
[10:24:18.067]                             if (is.null(name)) 
[10:24:18.067]                               next
[10:24:18.067]                             if (!grepl(pattern, name)) 
[10:24:18.067]                               next
[10:24:18.067]                             invokeRestart(restart)
[10:24:18.067]                             muffled <- TRUE
[10:24:18.067]                             break
[10:24:18.067]                           }
[10:24:18.067]                         }
[10:24:18.067]                       }
[10:24:18.067]                       invisible(muffled)
[10:24:18.067]                     }
[10:24:18.067]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.067]                   }
[10:24:18.067]                 }
[10:24:18.067]                 else {
[10:24:18.067]                   if (TRUE) {
[10:24:18.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.067]                     {
[10:24:18.067]                       inherits <- base::inherits
[10:24:18.067]                       invokeRestart <- base::invokeRestart
[10:24:18.067]                       is.null <- base::is.null
[10:24:18.067]                       muffled <- FALSE
[10:24:18.067]                       if (inherits(cond, "message")) {
[10:24:18.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.067]                         if (muffled) 
[10:24:18.067]                           invokeRestart("muffleMessage")
[10:24:18.067]                       }
[10:24:18.067]                       else if (inherits(cond, "warning")) {
[10:24:18.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.067]                         if (muffled) 
[10:24:18.067]                           invokeRestart("muffleWarning")
[10:24:18.067]                       }
[10:24:18.067]                       else if (inherits(cond, "condition")) {
[10:24:18.067]                         if (!is.null(pattern)) {
[10:24:18.067]                           computeRestarts <- base::computeRestarts
[10:24:18.067]                           grepl <- base::grepl
[10:24:18.067]                           restarts <- computeRestarts(cond)
[10:24:18.067]                           for (restart in restarts) {
[10:24:18.067]                             name <- restart$name
[10:24:18.067]                             if (is.null(name)) 
[10:24:18.067]                               next
[10:24:18.067]                             if (!grepl(pattern, name)) 
[10:24:18.067]                               next
[10:24:18.067]                             invokeRestart(restart)
[10:24:18.067]                             muffled <- TRUE
[10:24:18.067]                             break
[10:24:18.067]                           }
[10:24:18.067]                         }
[10:24:18.067]                       }
[10:24:18.067]                       invisible(muffled)
[10:24:18.067]                     }
[10:24:18.067]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.067]                   }
[10:24:18.067]                 }
[10:24:18.067]             }
[10:24:18.067]         }))
[10:24:18.067]     }, error = function(ex) {
[10:24:18.067]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.067]                 ...future.rng), started = ...future.startTime, 
[10:24:18.067]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.067]             version = "1.8"), class = "FutureResult")
[10:24:18.067]     }, finally = {
[10:24:18.067]         if (!identical(...future.workdir, getwd())) 
[10:24:18.067]             setwd(...future.workdir)
[10:24:18.067]         {
[10:24:18.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.067]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.067]             }
[10:24:18.067]             base::options(...future.oldOptions)
[10:24:18.067]             if (.Platform$OS.type == "windows") {
[10:24:18.067]                 old_names <- names(...future.oldEnvVars)
[10:24:18.067]                 envs <- base::Sys.getenv()
[10:24:18.067]                 names <- names(envs)
[10:24:18.067]                 common <- intersect(names, old_names)
[10:24:18.067]                 added <- setdiff(names, old_names)
[10:24:18.067]                 removed <- setdiff(old_names, names)
[10:24:18.067]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.067]                   envs[common]]
[10:24:18.067]                 NAMES <- toupper(changed)
[10:24:18.067]                 args <- list()
[10:24:18.067]                 for (kk in seq_along(NAMES)) {
[10:24:18.067]                   name <- changed[[kk]]
[10:24:18.067]                   NAME <- NAMES[[kk]]
[10:24:18.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.067]                     next
[10:24:18.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.067]                 }
[10:24:18.067]                 NAMES <- toupper(added)
[10:24:18.067]                 for (kk in seq_along(NAMES)) {
[10:24:18.067]                   name <- added[[kk]]
[10:24:18.067]                   NAME <- NAMES[[kk]]
[10:24:18.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.067]                     next
[10:24:18.067]                   args[[name]] <- ""
[10:24:18.067]                 }
[10:24:18.067]                 NAMES <- toupper(removed)
[10:24:18.067]                 for (kk in seq_along(NAMES)) {
[10:24:18.067]                   name <- removed[[kk]]
[10:24:18.067]                   NAME <- NAMES[[kk]]
[10:24:18.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.067]                     next
[10:24:18.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.067]                 }
[10:24:18.067]                 if (length(args) > 0) 
[10:24:18.067]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.067]             }
[10:24:18.067]             else {
[10:24:18.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.067]             }
[10:24:18.067]             {
[10:24:18.067]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.067]                   0L) {
[10:24:18.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.067]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.067]                   base::options(opts)
[10:24:18.067]                 }
[10:24:18.067]                 {
[10:24:18.067]                   {
[10:24:18.067]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.067]                     NULL
[10:24:18.067]                   }
[10:24:18.067]                   options(future.plan = NULL)
[10:24:18.067]                   if (is.na(NA_character_)) 
[10:24:18.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.067]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.067]                     envir = parent.frame()) 
[10:24:18.067]                   {
[10:24:18.067]                     default_workers <- missing(workers)
[10:24:18.067]                     if (is.function(workers)) 
[10:24:18.067]                       workers <- workers()
[10:24:18.067]                     workers <- structure(as.integer(workers), 
[10:24:18.067]                       class = class(workers))
[10:24:18.067]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.067]                       1L)
[10:24:18.067]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.067]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.067]                       if (default_workers) 
[10:24:18.067]                         supportsMulticore(warn = TRUE)
[10:24:18.067]                       return(sequential(..., envir = envir))
[10:24:18.067]                     }
[10:24:18.067]                     oopts <- options(mc.cores = workers)
[10:24:18.067]                     on.exit(options(oopts))
[10:24:18.067]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.067]                       envir = envir)
[10:24:18.067]                     if (!future$lazy) 
[10:24:18.067]                       future <- run(future)
[10:24:18.067]                     invisible(future)
[10:24:18.067]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.067]                 }
[10:24:18.067]             }
[10:24:18.067]         }
[10:24:18.067]     })
[10:24:18.067]     if (TRUE) {
[10:24:18.067]         base::sink(type = "output", split = FALSE)
[10:24:18.067]         if (TRUE) {
[10:24:18.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.067]         }
[10:24:18.067]         else {
[10:24:18.067]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.067]         }
[10:24:18.067]         base::close(...future.stdout)
[10:24:18.067]         ...future.stdout <- NULL
[10:24:18.067]     }
[10:24:18.067]     ...future.result$conditions <- ...future.conditions
[10:24:18.067]     ...future.result$finished <- base::Sys.time()
[10:24:18.067]     ...future.result
[10:24:18.067] }
[10:24:18.069] assign_globals() ...
[10:24:18.070] List of 11
[10:24:18.070]  $ ...future.FUN            :function (x, ...)  
[10:24:18.070]  $ x_FUN                    :function (x, ...)  
[10:24:18.070]  $ times                    : int 5
[10:24:18.070]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.070]  $ stop_if_not              :function (...)  
[10:24:18.070]  $ dim                      : NULL
[10:24:18.070]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:18.070]  $ future.call.arguments    : list()
[10:24:18.070]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.070]  $ ...future.elements_ii    :List of 1
[10:24:18.070]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:24:18.070]  $ ...future.seeds_ii       : NULL
[10:24:18.070]  $ ...future.globals.maxSize: NULL
[10:24:18.070]  - attr(*, "where")=List of 11
[10:24:18.070]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.070]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:18.070]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:18.070]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:18.070]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:18.070]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:18.070]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:18.070]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.070]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.070]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.070]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.070]  - attr(*, "resolved")= logi FALSE
[10:24:18.070]  - attr(*, "total_size")= num 95528
[10:24:18.070]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.070]  - attr(*, "already-done")= logi TRUE
[10:24:18.080] - copied ‘...future.FUN’ to environment
[10:24:18.080] - copied ‘x_FUN’ to environment
[10:24:18.080] - copied ‘times’ to environment
[10:24:18.080] - copied ‘stopf’ to environment
[10:24:18.080] - copied ‘stop_if_not’ to environment
[10:24:18.080] - copied ‘dim’ to environment
[10:24:18.080] - copied ‘valid_types’ to environment
[10:24:18.080] - copied ‘future.call.arguments’ to environment
[10:24:18.080] - copied ‘...future.elements_ii’ to environment
[10:24:18.081] - copied ‘...future.seeds_ii’ to environment
[10:24:18.081] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.081] assign_globals() ... done
[10:24:18.081] requestCore(): workers = 2
[10:24:18.083] MulticoreFuture started
[10:24:18.084] - Launch lazy future ... done
[10:24:18.084] run() for ‘MulticoreFuture’ ... done
[10:24:18.084] Created future:
[10:24:18.085] plan(): Setting new future strategy stack:
[10:24:18.085] List of future strategies:
[10:24:18.085] 1. sequential:
[10:24:18.085]    - args: function (..., envir = parent.frame())
[10:24:18.085]    - tweaked: FALSE
[10:24:18.085]    - call: NULL
[10:24:18.086] plan(): nbrOfWorkers() = 1
[10:24:18.089] plan(): Setting new future strategy stack:
[10:24:18.089] List of future strategies:
[10:24:18.089] 1. multicore:
[10:24:18.089]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.089]    - tweaked: FALSE
[10:24:18.089]    - call: plan(strategy)
[10:24:18.094] plan(): nbrOfWorkers() = 2
[10:24:18.085] MulticoreFuture:
[10:24:18.085] Label: ‘future_vapply-1’
[10:24:18.085] Expression:
[10:24:18.085] {
[10:24:18.085]     do.call(function(...) {
[10:24:18.085]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.085]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.085]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.085]             on.exit(options(oopts), add = TRUE)
[10:24:18.085]         }
[10:24:18.085]         {
[10:24:18.085]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.085]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.085]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.085]             })
[10:24:18.085]         }
[10:24:18.085]     }, args = future.call.arguments)
[10:24:18.085] }
[10:24:18.085] Lazy evaluation: FALSE
[10:24:18.085] Asynchronous evaluation: TRUE
[10:24:18.085] Local evaluation: TRUE
[10:24:18.085] Environment: R_GlobalEnv
[10:24:18.085] Capture standard output: TRUE
[10:24:18.085] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.085] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:18.085] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:24:18.085] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.085] Resolved: TRUE
[10:24:18.085] Value: <not collected>
[10:24:18.085] Conditions captured: <none>
[10:24:18.085] Early signaling: FALSE
[10:24:18.085] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.085] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.095] Chunk #1 of 2 ... DONE
[10:24:18.095] Chunk #2 of 2 ...
[10:24:18.096]  - Finding globals in 'X' for chunk #2 ...
[10:24:18.096] getGlobalsAndPackages() ...
[10:24:18.096] Searching for globals...
[10:24:18.097] 
[10:24:18.097] Searching for globals ... DONE
[10:24:18.097] - globals: [0] <none>
[10:24:18.097] getGlobalsAndPackages() ... DONE
[10:24:18.097]    + additional globals found: [n=0] 
[10:24:18.097]    + additional namespaces needed: [n=0] 
[10:24:18.097]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:18.098]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.098]  - seeds: <none>
[10:24:18.098]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.098] getGlobalsAndPackages() ...
[10:24:18.098] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.098] Resolving globals: FALSE
[10:24:18.098] Tweak future expression to call with '...' arguments ...
[10:24:18.099] {
[10:24:18.099]     do.call(function(...) {
[10:24:18.099]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.099]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.099]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.099]             on.exit(options(oopts), add = TRUE)
[10:24:18.099]         }
[10:24:18.099]         {
[10:24:18.099]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.099]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.099]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.099]             })
[10:24:18.099]         }
[10:24:18.099]     }, args = future.call.arguments)
[10:24:18.099] }
[10:24:18.099] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.100] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.100] - packages: [2] ‘stats’, ‘future.apply’
[10:24:18.100] getGlobalsAndPackages() ... DONE
[10:24:18.101] run() for ‘Future’ ...
[10:24:18.101] - state: ‘created’
[10:24:18.101] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.106] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.106] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.107]   - Field: ‘label’
[10:24:18.107]   - Field: ‘local’
[10:24:18.107]   - Field: ‘owner’
[10:24:18.107]   - Field: ‘envir’
[10:24:18.107]   - Field: ‘workers’
[10:24:18.107]   - Field: ‘packages’
[10:24:18.107]   - Field: ‘gc’
[10:24:18.108]   - Field: ‘job’
[10:24:18.108]   - Field: ‘conditions’
[10:24:18.108]   - Field: ‘expr’
[10:24:18.108]   - Field: ‘uuid’
[10:24:18.108]   - Field: ‘seed’
[10:24:18.108]   - Field: ‘version’
[10:24:18.109]   - Field: ‘result’
[10:24:18.109]   - Field: ‘asynchronous’
[10:24:18.109]   - Field: ‘calls’
[10:24:18.109]   - Field: ‘globals’
[10:24:18.109]   - Field: ‘stdout’
[10:24:18.109]   - Field: ‘earlySignal’
[10:24:18.112]   - Field: ‘lazy’
[10:24:18.112]   - Field: ‘state’
[10:24:18.113] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.113] - Launch lazy future ...
[10:24:18.114] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:24:18.114] Packages needed by future strategies (n = 0): <none>
[10:24:18.116] {
[10:24:18.116]     {
[10:24:18.116]         {
[10:24:18.116]             ...future.startTime <- base::Sys.time()
[10:24:18.116]             {
[10:24:18.116]                 {
[10:24:18.116]                   {
[10:24:18.116]                     {
[10:24:18.116]                       {
[10:24:18.116]                         base::local({
[10:24:18.116]                           has_future <- base::requireNamespace("future", 
[10:24:18.116]                             quietly = TRUE)
[10:24:18.116]                           if (has_future) {
[10:24:18.116]                             ns <- base::getNamespace("future")
[10:24:18.116]                             version <- ns[[".package"]][["version"]]
[10:24:18.116]                             if (is.null(version)) 
[10:24:18.116]                               version <- utils::packageVersion("future")
[10:24:18.116]                           }
[10:24:18.116]                           else {
[10:24:18.116]                             version <- NULL
[10:24:18.116]                           }
[10:24:18.116]                           if (!has_future || version < "1.8.0") {
[10:24:18.116]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.116]                               "", base::R.version$version.string), 
[10:24:18.116]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.116]                                 base::R.version$platform, 8 * 
[10:24:18.116]                                   base::.Machine$sizeof.pointer), 
[10:24:18.116]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.116]                                 "release", "version")], collapse = " "), 
[10:24:18.116]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.116]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.116]                               info)
[10:24:18.116]                             info <- base::paste(info, collapse = "; ")
[10:24:18.116]                             if (!has_future) {
[10:24:18.116]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.116]                                 info)
[10:24:18.116]                             }
[10:24:18.116]                             else {
[10:24:18.116]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.116]                                 info, version)
[10:24:18.116]                             }
[10:24:18.116]                             base::stop(msg)
[10:24:18.116]                           }
[10:24:18.116]                         })
[10:24:18.116]                       }
[10:24:18.116]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.116]                       base::options(mc.cores = 1L)
[10:24:18.116]                     }
[10:24:18.116]                     base::local({
[10:24:18.116]                       for (pkg in c("stats", "future.apply")) {
[10:24:18.116]                         base::loadNamespace(pkg)
[10:24:18.116]                         base::library(pkg, character.only = TRUE)
[10:24:18.116]                       }
[10:24:18.116]                     })
[10:24:18.116]                   }
[10:24:18.116]                   options(future.plan = NULL)
[10:24:18.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.116]                 }
[10:24:18.116]                 ...future.workdir <- getwd()
[10:24:18.116]             }
[10:24:18.116]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.116]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.116]         }
[10:24:18.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.116]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.116]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.116]             base::names(...future.oldOptions))
[10:24:18.116]     }
[10:24:18.116]     if (FALSE) {
[10:24:18.116]     }
[10:24:18.116]     else {
[10:24:18.116]         if (TRUE) {
[10:24:18.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.116]                 open = "w")
[10:24:18.116]         }
[10:24:18.116]         else {
[10:24:18.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.116]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.116]         }
[10:24:18.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.116]             base::sink(type = "output", split = FALSE)
[10:24:18.116]             base::close(...future.stdout)
[10:24:18.116]         }, add = TRUE)
[10:24:18.116]     }
[10:24:18.116]     ...future.frame <- base::sys.nframe()
[10:24:18.116]     ...future.conditions <- base::list()
[10:24:18.116]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.116]     if (FALSE) {
[10:24:18.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.116]     }
[10:24:18.116]     ...future.result <- base::tryCatch({
[10:24:18.116]         base::withCallingHandlers({
[10:24:18.116]             ...future.value <- base::withVisible(base::local({
[10:24:18.116]                 withCallingHandlers({
[10:24:18.116]                   {
[10:24:18.116]                     do.call(function(...) {
[10:24:18.116]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.116]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.116]                         ...future.globals.maxSize)) {
[10:24:18.116]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.116]                         on.exit(options(oopts), add = TRUE)
[10:24:18.116]                       }
[10:24:18.116]                       {
[10:24:18.116]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.116]                           FUN = function(jj) {
[10:24:18.116]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.116]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.116]                           })
[10:24:18.116]                       }
[10:24:18.116]                     }, args = future.call.arguments)
[10:24:18.116]                   }
[10:24:18.116]                 }, immediateCondition = function(cond) {
[10:24:18.116]                   save_rds <- function (object, pathname, ...) 
[10:24:18.116]                   {
[10:24:18.116]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.116]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.116]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.116]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.116]                         fi_tmp[["mtime"]])
[10:24:18.116]                     }
[10:24:18.116]                     tryCatch({
[10:24:18.116]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.116]                     }, error = function(ex) {
[10:24:18.116]                       msg <- conditionMessage(ex)
[10:24:18.116]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.116]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.116]                         fi_tmp[["mtime"]], msg)
[10:24:18.116]                       ex$message <- msg
[10:24:18.116]                       stop(ex)
[10:24:18.116]                     })
[10:24:18.116]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.116]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.116]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.116]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.116]                       fi <- file.info(pathname)
[10:24:18.116]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.116]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.116]                         fi[["size"]], fi[["mtime"]])
[10:24:18.116]                       stop(msg)
[10:24:18.116]                     }
[10:24:18.116]                     invisible(pathname)
[10:24:18.116]                   }
[10:24:18.116]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.116]                     rootPath = tempdir()) 
[10:24:18.116]                   {
[10:24:18.116]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.116]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.116]                       tmpdir = path, fileext = ".rds")
[10:24:18.116]                     save_rds(obj, file)
[10:24:18.116]                   }
[10:24:18.116]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.116]                   {
[10:24:18.116]                     inherits <- base::inherits
[10:24:18.116]                     invokeRestart <- base::invokeRestart
[10:24:18.116]                     is.null <- base::is.null
[10:24:18.116]                     muffled <- FALSE
[10:24:18.116]                     if (inherits(cond, "message")) {
[10:24:18.116]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.116]                       if (muffled) 
[10:24:18.116]                         invokeRestart("muffleMessage")
[10:24:18.116]                     }
[10:24:18.116]                     else if (inherits(cond, "warning")) {
[10:24:18.116]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.116]                       if (muffled) 
[10:24:18.116]                         invokeRestart("muffleWarning")
[10:24:18.116]                     }
[10:24:18.116]                     else if (inherits(cond, "condition")) {
[10:24:18.116]                       if (!is.null(pattern)) {
[10:24:18.116]                         computeRestarts <- base::computeRestarts
[10:24:18.116]                         grepl <- base::grepl
[10:24:18.116]                         restarts <- computeRestarts(cond)
[10:24:18.116]                         for (restart in restarts) {
[10:24:18.116]                           name <- restart$name
[10:24:18.116]                           if (is.null(name)) 
[10:24:18.116]                             next
[10:24:18.116]                           if (!grepl(pattern, name)) 
[10:24:18.116]                             next
[10:24:18.116]                           invokeRestart(restart)
[10:24:18.116]                           muffled <- TRUE
[10:24:18.116]                           break
[10:24:18.116]                         }
[10:24:18.116]                       }
[10:24:18.116]                     }
[10:24:18.116]                     invisible(muffled)
[10:24:18.116]                   }
[10:24:18.116]                   muffleCondition(cond)
[10:24:18.116]                 })
[10:24:18.116]             }))
[10:24:18.116]             future::FutureResult(value = ...future.value$value, 
[10:24:18.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.116]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.116]                     ...future.globalenv.names))
[10:24:18.116]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.116]         }, condition = base::local({
[10:24:18.116]             c <- base::c
[10:24:18.116]             inherits <- base::inherits
[10:24:18.116]             invokeRestart <- base::invokeRestart
[10:24:18.116]             length <- base::length
[10:24:18.116]             list <- base::list
[10:24:18.116]             seq.int <- base::seq.int
[10:24:18.116]             signalCondition <- base::signalCondition
[10:24:18.116]             sys.calls <- base::sys.calls
[10:24:18.116]             `[[` <- base::`[[`
[10:24:18.116]             `+` <- base::`+`
[10:24:18.116]             `<<-` <- base::`<<-`
[10:24:18.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.116]                   3L)]
[10:24:18.116]             }
[10:24:18.116]             function(cond) {
[10:24:18.116]                 is_error <- inherits(cond, "error")
[10:24:18.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.116]                   NULL)
[10:24:18.116]                 if (is_error) {
[10:24:18.116]                   sessionInformation <- function() {
[10:24:18.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.116]                       search = base::search(), system = base::Sys.info())
[10:24:18.116]                   }
[10:24:18.116]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.116]                     cond$call), session = sessionInformation(), 
[10:24:18.116]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.116]                   signalCondition(cond)
[10:24:18.116]                 }
[10:24:18.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.116]                 "immediateCondition"))) {
[10:24:18.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.116]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.116]                   if (TRUE && !signal) {
[10:24:18.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.116]                     {
[10:24:18.116]                       inherits <- base::inherits
[10:24:18.116]                       invokeRestart <- base::invokeRestart
[10:24:18.116]                       is.null <- base::is.null
[10:24:18.116]                       muffled <- FALSE
[10:24:18.116]                       if (inherits(cond, "message")) {
[10:24:18.116]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.116]                         if (muffled) 
[10:24:18.116]                           invokeRestart("muffleMessage")
[10:24:18.116]                       }
[10:24:18.116]                       else if (inherits(cond, "warning")) {
[10:24:18.116]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.116]                         if (muffled) 
[10:24:18.116]                           invokeRestart("muffleWarning")
[10:24:18.116]                       }
[10:24:18.116]                       else if (inherits(cond, "condition")) {
[10:24:18.116]                         if (!is.null(pattern)) {
[10:24:18.116]                           computeRestarts <- base::computeRestarts
[10:24:18.116]                           grepl <- base::grepl
[10:24:18.116]                           restarts <- computeRestarts(cond)
[10:24:18.116]                           for (restart in restarts) {
[10:24:18.116]                             name <- restart$name
[10:24:18.116]                             if (is.null(name)) 
[10:24:18.116]                               next
[10:24:18.116]                             if (!grepl(pattern, name)) 
[10:24:18.116]                               next
[10:24:18.116]                             invokeRestart(restart)
[10:24:18.116]                             muffled <- TRUE
[10:24:18.116]                             break
[10:24:18.116]                           }
[10:24:18.116]                         }
[10:24:18.116]                       }
[10:24:18.116]                       invisible(muffled)
[10:24:18.116]                     }
[10:24:18.116]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.116]                   }
[10:24:18.116]                 }
[10:24:18.116]                 else {
[10:24:18.116]                   if (TRUE) {
[10:24:18.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.116]                     {
[10:24:18.116]                       inherits <- base::inherits
[10:24:18.116]                       invokeRestart <- base::invokeRestart
[10:24:18.116]                       is.null <- base::is.null
[10:24:18.116]                       muffled <- FALSE
[10:24:18.116]                       if (inherits(cond, "message")) {
[10:24:18.116]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.116]                         if (muffled) 
[10:24:18.116]                           invokeRestart("muffleMessage")
[10:24:18.116]                       }
[10:24:18.116]                       else if (inherits(cond, "warning")) {
[10:24:18.116]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.116]                         if (muffled) 
[10:24:18.116]                           invokeRestart("muffleWarning")
[10:24:18.116]                       }
[10:24:18.116]                       else if (inherits(cond, "condition")) {
[10:24:18.116]                         if (!is.null(pattern)) {
[10:24:18.116]                           computeRestarts <- base::computeRestarts
[10:24:18.116]                           grepl <- base::grepl
[10:24:18.116]                           restarts <- computeRestarts(cond)
[10:24:18.116]                           for (restart in restarts) {
[10:24:18.116]                             name <- restart$name
[10:24:18.116]                             if (is.null(name)) 
[10:24:18.116]                               next
[10:24:18.116]                             if (!grepl(pattern, name)) 
[10:24:18.116]                               next
[10:24:18.116]                             invokeRestart(restart)
[10:24:18.116]                             muffled <- TRUE
[10:24:18.116]                             break
[10:24:18.116]                           }
[10:24:18.116]                         }
[10:24:18.116]                       }
[10:24:18.116]                       invisible(muffled)
[10:24:18.116]                     }
[10:24:18.116]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.116]                   }
[10:24:18.116]                 }
[10:24:18.116]             }
[10:24:18.116]         }))
[10:24:18.116]     }, error = function(ex) {
[10:24:18.116]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.116]                 ...future.rng), started = ...future.startTime, 
[10:24:18.116]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.116]             version = "1.8"), class = "FutureResult")
[10:24:18.116]     }, finally = {
[10:24:18.116]         if (!identical(...future.workdir, getwd())) 
[10:24:18.116]             setwd(...future.workdir)
[10:24:18.116]         {
[10:24:18.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.116]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.116]             }
[10:24:18.116]             base::options(...future.oldOptions)
[10:24:18.116]             if (.Platform$OS.type == "windows") {
[10:24:18.116]                 old_names <- names(...future.oldEnvVars)
[10:24:18.116]                 envs <- base::Sys.getenv()
[10:24:18.116]                 names <- names(envs)
[10:24:18.116]                 common <- intersect(names, old_names)
[10:24:18.116]                 added <- setdiff(names, old_names)
[10:24:18.116]                 removed <- setdiff(old_names, names)
[10:24:18.116]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.116]                   envs[common]]
[10:24:18.116]                 NAMES <- toupper(changed)
[10:24:18.116]                 args <- list()
[10:24:18.116]                 for (kk in seq_along(NAMES)) {
[10:24:18.116]                   name <- changed[[kk]]
[10:24:18.116]                   NAME <- NAMES[[kk]]
[10:24:18.116]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.116]                     next
[10:24:18.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.116]                 }
[10:24:18.116]                 NAMES <- toupper(added)
[10:24:18.116]                 for (kk in seq_along(NAMES)) {
[10:24:18.116]                   name <- added[[kk]]
[10:24:18.116]                   NAME <- NAMES[[kk]]
[10:24:18.116]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.116]                     next
[10:24:18.116]                   args[[name]] <- ""
[10:24:18.116]                 }
[10:24:18.116]                 NAMES <- toupper(removed)
[10:24:18.116]                 for (kk in seq_along(NAMES)) {
[10:24:18.116]                   name <- removed[[kk]]
[10:24:18.116]                   NAME <- NAMES[[kk]]
[10:24:18.116]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.116]                     next
[10:24:18.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.116]                 }
[10:24:18.116]                 if (length(args) > 0) 
[10:24:18.116]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.116]             }
[10:24:18.116]             else {
[10:24:18.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.116]             }
[10:24:18.116]             {
[10:24:18.116]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.116]                   0L) {
[10:24:18.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.116]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.116]                   base::options(opts)
[10:24:18.116]                 }
[10:24:18.116]                 {
[10:24:18.116]                   {
[10:24:18.116]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.116]                     NULL
[10:24:18.116]                   }
[10:24:18.116]                   options(future.plan = NULL)
[10:24:18.116]                   if (is.na(NA_character_)) 
[10:24:18.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.116]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.116]                     envir = parent.frame()) 
[10:24:18.116]                   {
[10:24:18.116]                     default_workers <- missing(workers)
[10:24:18.116]                     if (is.function(workers)) 
[10:24:18.116]                       workers <- workers()
[10:24:18.116]                     workers <- structure(as.integer(workers), 
[10:24:18.116]                       class = class(workers))
[10:24:18.116]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.116]                       1L)
[10:24:18.116]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.116]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.116]                       if (default_workers) 
[10:24:18.116]                         supportsMulticore(warn = TRUE)
[10:24:18.116]                       return(sequential(..., envir = envir))
[10:24:18.116]                     }
[10:24:18.116]                     oopts <- options(mc.cores = workers)
[10:24:18.116]                     on.exit(options(oopts))
[10:24:18.116]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.116]                       envir = envir)
[10:24:18.116]                     if (!future$lazy) 
[10:24:18.116]                       future <- run(future)
[10:24:18.116]                     invisible(future)
[10:24:18.116]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.116]                 }
[10:24:18.116]             }
[10:24:18.116]         }
[10:24:18.116]     })
[10:24:18.116]     if (TRUE) {
[10:24:18.116]         base::sink(type = "output", split = FALSE)
[10:24:18.116]         if (TRUE) {
[10:24:18.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.116]         }
[10:24:18.116]         else {
[10:24:18.116]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.116]         }
[10:24:18.116]         base::close(...future.stdout)
[10:24:18.116]         ...future.stdout <- NULL
[10:24:18.116]     }
[10:24:18.116]     ...future.result$conditions <- ...future.conditions
[10:24:18.116]     ...future.result$finished <- base::Sys.time()
[10:24:18.116]     ...future.result
[10:24:18.116] }
[10:24:18.119] assign_globals() ...
[10:24:18.120] List of 11
[10:24:18.120]  $ ...future.FUN            :function (x, ...)  
[10:24:18.120]  $ x_FUN                    :function (x, ...)  
[10:24:18.120]  $ times                    : int 5
[10:24:18.120]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.120]  $ stop_if_not              :function (...)  
[10:24:18.120]  $ dim                      : NULL
[10:24:18.120]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:18.120]  $ future.call.arguments    : list()
[10:24:18.120]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.120]  $ ...future.elements_ii    :List of 2
[10:24:18.120]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:24:18.120]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:24:18.120]  $ ...future.seeds_ii       : NULL
[10:24:18.120]  $ ...future.globals.maxSize: NULL
[10:24:18.120]  - attr(*, "where")=List of 11
[10:24:18.120]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.120]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:18.120]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:18.120]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:18.120]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:18.120]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:18.120]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:18.120]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.120]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.120]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.120]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.120]  - attr(*, "resolved")= logi FALSE
[10:24:18.120]  - attr(*, "total_size")= num 95528
[10:24:18.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.120]  - attr(*, "already-done")= logi TRUE
[10:24:18.133] - copied ‘...future.FUN’ to environment
[10:24:18.133] - copied ‘x_FUN’ to environment
[10:24:18.133] - copied ‘times’ to environment
[10:24:18.133] - copied ‘stopf’ to environment
[10:24:18.133] - copied ‘stop_if_not’ to environment
[10:24:18.134] - copied ‘dim’ to environment
[10:24:18.134] - copied ‘valid_types’ to environment
[10:24:18.134] - copied ‘future.call.arguments’ to environment
[10:24:18.134] - copied ‘...future.elements_ii’ to environment
[10:24:18.134] - copied ‘...future.seeds_ii’ to environment
[10:24:18.134] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.134] assign_globals() ... done
[10:24:18.134] requestCore(): workers = 2
[10:24:18.137] MulticoreFuture started
[10:24:18.137] - Launch lazy future ... done
[10:24:18.137] run() for ‘MulticoreFuture’ ... done
[10:24:18.138] Created future:
[10:24:18.139] plan(): Setting new future strategy stack:
[10:24:18.139] List of future strategies:
[10:24:18.139] 1. sequential:
[10:24:18.139]    - args: function (..., envir = parent.frame())
[10:24:18.139]    - tweaked: FALSE
[10:24:18.139]    - call: NULL
[10:24:18.140] plan(): nbrOfWorkers() = 1
[10:24:18.143] plan(): Setting new future strategy stack:
[10:24:18.143] List of future strategies:
[10:24:18.143] 1. multicore:
[10:24:18.143]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.143]    - tweaked: FALSE
[10:24:18.143]    - call: plan(strategy)
[10:24:18.148] plan(): nbrOfWorkers() = 2
[10:24:18.138] MulticoreFuture:
[10:24:18.138] Label: ‘future_vapply-2’
[10:24:18.138] Expression:
[10:24:18.138] {
[10:24:18.138]     do.call(function(...) {
[10:24:18.138]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.138]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.138]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.138]             on.exit(options(oopts), add = TRUE)
[10:24:18.138]         }
[10:24:18.138]         {
[10:24:18.138]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.138]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.138]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.138]             })
[10:24:18.138]         }
[10:24:18.138]     }, args = future.call.arguments)
[10:24:18.138] }
[10:24:18.138] Lazy evaluation: FALSE
[10:24:18.138] Asynchronous evaluation: TRUE
[10:24:18.138] Local evaluation: TRUE
[10:24:18.138] Environment: R_GlobalEnv
[10:24:18.138] Capture standard output: TRUE
[10:24:18.138] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.138] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:18.138] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:24:18.138] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.138] Resolved: TRUE
[10:24:18.138] Value: <not collected>
[10:24:18.138] Conditions captured: <none>
[10:24:18.138] Early signaling: FALSE
[10:24:18.138] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.138] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.149] Chunk #2 of 2 ... DONE
[10:24:18.149] Launching 2 futures (chunks) ... DONE
[10:24:18.149] Resolving 2 futures (chunks) ...
[10:24:18.150] resolve() on list ...
[10:24:18.150]  recursive: 0
[10:24:18.150]  length: 2
[10:24:18.150] 
[10:24:18.150] Future #1
[10:24:18.151] result() for MulticoreFuture ...
[10:24:18.152] result() for MulticoreFuture ...
[10:24:18.152] result() for MulticoreFuture ... done
[10:24:18.152] result() for MulticoreFuture ... done
[10:24:18.152] result() for MulticoreFuture ...
[10:24:18.152] result() for MulticoreFuture ... done
[10:24:18.152] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:18.153] - nx: 2
[10:24:18.153] - relay: TRUE
[10:24:18.153] - stdout: TRUE
[10:24:18.153] - signal: TRUE
[10:24:18.153] - resignal: FALSE
[10:24:18.154] - force: TRUE
[10:24:18.154] - relayed: [n=2] FALSE, FALSE
[10:24:18.154] - queued futures: [n=2] FALSE, FALSE
[10:24:18.154]  - until=1
[10:24:18.154]  - relaying element #1
[10:24:18.154] result() for MulticoreFuture ...
[10:24:18.155] result() for MulticoreFuture ... done
[10:24:18.155] result() for MulticoreFuture ...
[10:24:18.155] result() for MulticoreFuture ... done
[10:24:18.155] result() for MulticoreFuture ...
[10:24:18.155] result() for MulticoreFuture ... done
[10:24:18.156] result() for MulticoreFuture ...
[10:24:18.156] result() for MulticoreFuture ... done
[10:24:18.156] - relayed: [n=2] TRUE, FALSE
[10:24:18.156] - queued futures: [n=2] TRUE, FALSE
[10:24:18.156] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:18.157]  length: 1 (resolved future 1)
[10:24:18.157] Future #2
[10:24:18.157] result() for MulticoreFuture ...
[10:24:18.161] result() for MulticoreFuture ...
[10:24:18.161] result() for MulticoreFuture ... done
[10:24:18.161] result() for MulticoreFuture ... done
[10:24:18.161] result() for MulticoreFuture ...
[10:24:18.162] result() for MulticoreFuture ... done
[10:24:18.162] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:18.162] - nx: 2
[10:24:18.162] - relay: TRUE
[10:24:18.162] - stdout: TRUE
[10:24:18.163] - signal: TRUE
[10:24:18.163] - resignal: FALSE
[10:24:18.163] - force: TRUE
[10:24:18.163] - relayed: [n=2] TRUE, FALSE
[10:24:18.163] - queued futures: [n=2] TRUE, FALSE
[10:24:18.163]  - until=2
[10:24:18.163]  - relaying element #2
[10:24:18.164] result() for MulticoreFuture ...
[10:24:18.164] result() for MulticoreFuture ... done
[10:24:18.164] result() for MulticoreFuture ...
[10:24:18.164] result() for MulticoreFuture ... done
[10:24:18.164] result() for MulticoreFuture ...
[10:24:18.164] result() for MulticoreFuture ... done
[10:24:18.165] result() for MulticoreFuture ...
[10:24:18.165] result() for MulticoreFuture ... done
[10:24:18.165] - relayed: [n=2] TRUE, TRUE
[10:24:18.165] - queued futures: [n=2] TRUE, TRUE
[10:24:18.165] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:18.165]  length: 0 (resolved future 2)
[10:24:18.166] Relaying remaining futures
[10:24:18.166] signalConditionsASAP(NULL, pos=0) ...
[10:24:18.166] - nx: 2
[10:24:18.166] - relay: TRUE
[10:24:18.166] - stdout: TRUE
[10:24:18.166] - signal: TRUE
[10:24:18.166] - resignal: FALSE
[10:24:18.167] - force: TRUE
[10:24:18.167] - relayed: [n=2] TRUE, TRUE
[10:24:18.167] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:18.167] - relayed: [n=2] TRUE, TRUE
[10:24:18.167] - queued futures: [n=2] TRUE, TRUE
[10:24:18.167] signalConditionsASAP(NULL, pos=0) ... done
[10:24:18.167] resolve() on list ... DONE
[10:24:18.168] result() for MulticoreFuture ...
[10:24:18.168] result() for MulticoreFuture ... done
[10:24:18.168] result() for MulticoreFuture ...
[10:24:18.168] result() for MulticoreFuture ... done
[10:24:18.168] result() for MulticoreFuture ...
[10:24:18.168] result() for MulticoreFuture ... done
[10:24:18.168] result() for MulticoreFuture ...
[10:24:18.169] result() for MulticoreFuture ... done
[10:24:18.169]  - Number of value chunks collected: 2
[10:24:18.169] Resolving 2 futures (chunks) ... DONE
[10:24:18.169] Reducing values from 2 chunks ...
[10:24:18.169]  - Number of values collected after concatenation: 3
[10:24:18.169]  - Number of values expected: 3
[10:24:18.169] Reducing values from 2 chunks ... DONE
[10:24:18.169] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[10:24:18.172] future_lapply() ...
[10:24:18.180] Number of chunks: 2
[10:24:18.180] getGlobalsAndPackagesXApply() ...
[10:24:18.180]  - future.globals: TRUE
[10:24:18.180] getGlobalsAndPackages() ...
[10:24:18.180] Searching for globals...
[10:24:18.188] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:24:18.188] Searching for globals ... DONE
[10:24:18.188] Resolving globals: FALSE
[10:24:18.189] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[10:24:18.190] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[10:24:18.190] - globals: [1] ‘FUN’
[10:24:18.190] - packages: [1] ‘stats’
[10:24:18.190] getGlobalsAndPackages() ... DONE
[10:24:18.190]  - globals found/used: [n=1] ‘FUN’
[10:24:18.190]  - needed namespaces: [n=1] ‘stats’
[10:24:18.190] Finding globals ... DONE
[10:24:18.190]  - use_args: TRUE
[10:24:18.191]  - Getting '...' globals ...
[10:24:18.191] resolve() on list ...
[10:24:18.191]  recursive: 0
[10:24:18.191]  length: 1
[10:24:18.191]  elements: ‘...’
[10:24:18.191]  length: 0 (resolved future 1)
[10:24:18.192] resolve() on list ... DONE
[10:24:18.192]    - '...' content: [n=0] 
[10:24:18.192] List of 1
[10:24:18.192]  $ ...: list()
[10:24:18.192]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.192]  - attr(*, "where")=List of 1
[10:24:18.192]   ..$ ...:<environment: 0x55b93b58b080> 
[10:24:18.192]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.192]  - attr(*, "resolved")= logi TRUE
[10:24:18.192]  - attr(*, "total_size")= num NA
[10:24:18.194]  - Getting '...' globals ... DONE
[10:24:18.195] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:18.195] List of 2
[10:24:18.195]  $ ...future.FUN:function (x, na.rm = TRUE)  
[10:24:18.195]  $ ...          : list()
[10:24:18.195]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.195]  - attr(*, "where")=List of 2
[10:24:18.195]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:18.195]   ..$ ...          :<environment: 0x55b93b58b080> 
[10:24:18.195]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.195]  - attr(*, "resolved")= logi FALSE
[10:24:18.195]  - attr(*, "total_size")= num 46960
[10:24:18.197] Packages to be attached in all futures: [n=1] ‘stats’
[10:24:18.198] getGlobalsAndPackagesXApply() ... DONE
[10:24:18.198] Number of futures (= number of chunks): 2
[10:24:18.198] Launching 2 futures (chunks) ...
[10:24:18.198] Chunk #1 of 2 ...
[10:24:18.198]  - Finding globals in 'X' for chunk #1 ...
[10:24:18.198] getGlobalsAndPackages() ...
[10:24:18.198] Searching for globals...
[10:24:18.199] 
[10:24:18.199] Searching for globals ... DONE
[10:24:18.199] - globals: [0] <none>
[10:24:18.199] getGlobalsAndPackages() ... DONE
[10:24:18.199]    + additional globals found: [n=0] 
[10:24:18.199]    + additional namespaces needed: [n=0] 
[10:24:18.199]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:18.199]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.199]  - seeds: <none>
[10:24:18.199]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.200] getGlobalsAndPackages() ...
[10:24:18.200] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.200] Resolving globals: FALSE
[10:24:18.200] Tweak future expression to call with '...' arguments ...
[10:24:18.200] {
[10:24:18.200]     do.call(function(...) {
[10:24:18.200]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.200]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.200]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.200]             on.exit(options(oopts), add = TRUE)
[10:24:18.200]         }
[10:24:18.200]         {
[10:24:18.200]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.200]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.200]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.200]             })
[10:24:18.200]         }
[10:24:18.200]     }, args = future.call.arguments)
[10:24:18.200] }
[10:24:18.200] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.201] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.201] - packages: [1] ‘stats’
[10:24:18.201] getGlobalsAndPackages() ... DONE
[10:24:18.201] run() for ‘Future’ ...
[10:24:18.201] - state: ‘created’
[10:24:18.201] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.205] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.205] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.206]   - Field: ‘label’
[10:24:18.206]   - Field: ‘local’
[10:24:18.206]   - Field: ‘owner’
[10:24:18.206]   - Field: ‘envir’
[10:24:18.206]   - Field: ‘workers’
[10:24:18.206]   - Field: ‘packages’
[10:24:18.206]   - Field: ‘gc’
[10:24:18.206]   - Field: ‘job’
[10:24:18.206]   - Field: ‘conditions’
[10:24:18.206]   - Field: ‘expr’
[10:24:18.207]   - Field: ‘uuid’
[10:24:18.207]   - Field: ‘seed’
[10:24:18.207]   - Field: ‘version’
[10:24:18.207]   - Field: ‘result’
[10:24:18.207]   - Field: ‘asynchronous’
[10:24:18.207]   - Field: ‘calls’
[10:24:18.209]   - Field: ‘globals’
[10:24:18.209]   - Field: ‘stdout’
[10:24:18.209]   - Field: ‘earlySignal’
[10:24:18.209]   - Field: ‘lazy’
[10:24:18.210]   - Field: ‘state’
[10:24:18.210] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.210] - Launch lazy future ...
[10:24:18.210] Packages needed by the future expression (n = 1): ‘stats’
[10:24:18.210] Packages needed by future strategies (n = 0): <none>
[10:24:18.211] {
[10:24:18.211]     {
[10:24:18.211]         {
[10:24:18.211]             ...future.startTime <- base::Sys.time()
[10:24:18.211]             {
[10:24:18.211]                 {
[10:24:18.211]                   {
[10:24:18.211]                     {
[10:24:18.211]                       {
[10:24:18.211]                         base::local({
[10:24:18.211]                           has_future <- base::requireNamespace("future", 
[10:24:18.211]                             quietly = TRUE)
[10:24:18.211]                           if (has_future) {
[10:24:18.211]                             ns <- base::getNamespace("future")
[10:24:18.211]                             version <- ns[[".package"]][["version"]]
[10:24:18.211]                             if (is.null(version)) 
[10:24:18.211]                               version <- utils::packageVersion("future")
[10:24:18.211]                           }
[10:24:18.211]                           else {
[10:24:18.211]                             version <- NULL
[10:24:18.211]                           }
[10:24:18.211]                           if (!has_future || version < "1.8.0") {
[10:24:18.211]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.211]                               "", base::R.version$version.string), 
[10:24:18.211]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.211]                                 base::R.version$platform, 8 * 
[10:24:18.211]                                   base::.Machine$sizeof.pointer), 
[10:24:18.211]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.211]                                 "release", "version")], collapse = " "), 
[10:24:18.211]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.211]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.211]                               info)
[10:24:18.211]                             info <- base::paste(info, collapse = "; ")
[10:24:18.211]                             if (!has_future) {
[10:24:18.211]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.211]                                 info)
[10:24:18.211]                             }
[10:24:18.211]                             else {
[10:24:18.211]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.211]                                 info, version)
[10:24:18.211]                             }
[10:24:18.211]                             base::stop(msg)
[10:24:18.211]                           }
[10:24:18.211]                         })
[10:24:18.211]                       }
[10:24:18.211]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.211]                       base::options(mc.cores = 1L)
[10:24:18.211]                     }
[10:24:18.211]                     base::local({
[10:24:18.211]                       for (pkg in "stats") {
[10:24:18.211]                         base::loadNamespace(pkg)
[10:24:18.211]                         base::library(pkg, character.only = TRUE)
[10:24:18.211]                       }
[10:24:18.211]                     })
[10:24:18.211]                   }
[10:24:18.211]                   options(future.plan = NULL)
[10:24:18.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.211]                 }
[10:24:18.211]                 ...future.workdir <- getwd()
[10:24:18.211]             }
[10:24:18.211]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.211]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.211]         }
[10:24:18.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.211]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.211]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.211]             base::names(...future.oldOptions))
[10:24:18.211]     }
[10:24:18.211]     if (FALSE) {
[10:24:18.211]     }
[10:24:18.211]     else {
[10:24:18.211]         if (TRUE) {
[10:24:18.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.211]                 open = "w")
[10:24:18.211]         }
[10:24:18.211]         else {
[10:24:18.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.211]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.211]         }
[10:24:18.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.211]             base::sink(type = "output", split = FALSE)
[10:24:18.211]             base::close(...future.stdout)
[10:24:18.211]         }, add = TRUE)
[10:24:18.211]     }
[10:24:18.211]     ...future.frame <- base::sys.nframe()
[10:24:18.211]     ...future.conditions <- base::list()
[10:24:18.211]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.211]     if (FALSE) {
[10:24:18.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.211]     }
[10:24:18.211]     ...future.result <- base::tryCatch({
[10:24:18.211]         base::withCallingHandlers({
[10:24:18.211]             ...future.value <- base::withVisible(base::local({
[10:24:18.211]                 withCallingHandlers({
[10:24:18.211]                   {
[10:24:18.211]                     do.call(function(...) {
[10:24:18.211]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.211]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.211]                         ...future.globals.maxSize)) {
[10:24:18.211]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.211]                         on.exit(options(oopts), add = TRUE)
[10:24:18.211]                       }
[10:24:18.211]                       {
[10:24:18.211]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.211]                           FUN = function(jj) {
[10:24:18.211]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.211]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.211]                           })
[10:24:18.211]                       }
[10:24:18.211]                     }, args = future.call.arguments)
[10:24:18.211]                   }
[10:24:18.211]                 }, immediateCondition = function(cond) {
[10:24:18.211]                   save_rds <- function (object, pathname, ...) 
[10:24:18.211]                   {
[10:24:18.211]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.211]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.211]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.211]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.211]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.211]                         fi_tmp[["mtime"]])
[10:24:18.211]                     }
[10:24:18.211]                     tryCatch({
[10:24:18.211]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.211]                     }, error = function(ex) {
[10:24:18.211]                       msg <- conditionMessage(ex)
[10:24:18.211]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.211]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.211]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.211]                         fi_tmp[["mtime"]], msg)
[10:24:18.211]                       ex$message <- msg
[10:24:18.211]                       stop(ex)
[10:24:18.211]                     })
[10:24:18.211]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.211]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.211]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.211]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.211]                       fi <- file.info(pathname)
[10:24:18.211]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.211]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.211]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.211]                         fi[["size"]], fi[["mtime"]])
[10:24:18.211]                       stop(msg)
[10:24:18.211]                     }
[10:24:18.211]                     invisible(pathname)
[10:24:18.211]                   }
[10:24:18.211]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.211]                     rootPath = tempdir()) 
[10:24:18.211]                   {
[10:24:18.211]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.211]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.211]                       tmpdir = path, fileext = ".rds")
[10:24:18.211]                     save_rds(obj, file)
[10:24:18.211]                   }
[10:24:18.211]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.211]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.211]                   {
[10:24:18.211]                     inherits <- base::inherits
[10:24:18.211]                     invokeRestart <- base::invokeRestart
[10:24:18.211]                     is.null <- base::is.null
[10:24:18.211]                     muffled <- FALSE
[10:24:18.211]                     if (inherits(cond, "message")) {
[10:24:18.211]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.211]                       if (muffled) 
[10:24:18.211]                         invokeRestart("muffleMessage")
[10:24:18.211]                     }
[10:24:18.211]                     else if (inherits(cond, "warning")) {
[10:24:18.211]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.211]                       if (muffled) 
[10:24:18.211]                         invokeRestart("muffleWarning")
[10:24:18.211]                     }
[10:24:18.211]                     else if (inherits(cond, "condition")) {
[10:24:18.211]                       if (!is.null(pattern)) {
[10:24:18.211]                         computeRestarts <- base::computeRestarts
[10:24:18.211]                         grepl <- base::grepl
[10:24:18.211]                         restarts <- computeRestarts(cond)
[10:24:18.211]                         for (restart in restarts) {
[10:24:18.211]                           name <- restart$name
[10:24:18.211]                           if (is.null(name)) 
[10:24:18.211]                             next
[10:24:18.211]                           if (!grepl(pattern, name)) 
[10:24:18.211]                             next
[10:24:18.211]                           invokeRestart(restart)
[10:24:18.211]                           muffled <- TRUE
[10:24:18.211]                           break
[10:24:18.211]                         }
[10:24:18.211]                       }
[10:24:18.211]                     }
[10:24:18.211]                     invisible(muffled)
[10:24:18.211]                   }
[10:24:18.211]                   muffleCondition(cond)
[10:24:18.211]                 })
[10:24:18.211]             }))
[10:24:18.211]             future::FutureResult(value = ...future.value$value, 
[10:24:18.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.211]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.211]                     ...future.globalenv.names))
[10:24:18.211]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.211]         }, condition = base::local({
[10:24:18.211]             c <- base::c
[10:24:18.211]             inherits <- base::inherits
[10:24:18.211]             invokeRestart <- base::invokeRestart
[10:24:18.211]             length <- base::length
[10:24:18.211]             list <- base::list
[10:24:18.211]             seq.int <- base::seq.int
[10:24:18.211]             signalCondition <- base::signalCondition
[10:24:18.211]             sys.calls <- base::sys.calls
[10:24:18.211]             `[[` <- base::`[[`
[10:24:18.211]             `+` <- base::`+`
[10:24:18.211]             `<<-` <- base::`<<-`
[10:24:18.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.211]                   3L)]
[10:24:18.211]             }
[10:24:18.211]             function(cond) {
[10:24:18.211]                 is_error <- inherits(cond, "error")
[10:24:18.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.211]                   NULL)
[10:24:18.211]                 if (is_error) {
[10:24:18.211]                   sessionInformation <- function() {
[10:24:18.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.211]                       search = base::search(), system = base::Sys.info())
[10:24:18.211]                   }
[10:24:18.211]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.211]                     cond$call), session = sessionInformation(), 
[10:24:18.211]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.211]                   signalCondition(cond)
[10:24:18.211]                 }
[10:24:18.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.211]                 "immediateCondition"))) {
[10:24:18.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.211]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.211]                   if (TRUE && !signal) {
[10:24:18.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.211]                     {
[10:24:18.211]                       inherits <- base::inherits
[10:24:18.211]                       invokeRestart <- base::invokeRestart
[10:24:18.211]                       is.null <- base::is.null
[10:24:18.211]                       muffled <- FALSE
[10:24:18.211]                       if (inherits(cond, "message")) {
[10:24:18.211]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.211]                         if (muffled) 
[10:24:18.211]                           invokeRestart("muffleMessage")
[10:24:18.211]                       }
[10:24:18.211]                       else if (inherits(cond, "warning")) {
[10:24:18.211]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.211]                         if (muffled) 
[10:24:18.211]                           invokeRestart("muffleWarning")
[10:24:18.211]                       }
[10:24:18.211]                       else if (inherits(cond, "condition")) {
[10:24:18.211]                         if (!is.null(pattern)) {
[10:24:18.211]                           computeRestarts <- base::computeRestarts
[10:24:18.211]                           grepl <- base::grepl
[10:24:18.211]                           restarts <- computeRestarts(cond)
[10:24:18.211]                           for (restart in restarts) {
[10:24:18.211]                             name <- restart$name
[10:24:18.211]                             if (is.null(name)) 
[10:24:18.211]                               next
[10:24:18.211]                             if (!grepl(pattern, name)) 
[10:24:18.211]                               next
[10:24:18.211]                             invokeRestart(restart)
[10:24:18.211]                             muffled <- TRUE
[10:24:18.211]                             break
[10:24:18.211]                           }
[10:24:18.211]                         }
[10:24:18.211]                       }
[10:24:18.211]                       invisible(muffled)
[10:24:18.211]                     }
[10:24:18.211]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.211]                   }
[10:24:18.211]                 }
[10:24:18.211]                 else {
[10:24:18.211]                   if (TRUE) {
[10:24:18.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.211]                     {
[10:24:18.211]                       inherits <- base::inherits
[10:24:18.211]                       invokeRestart <- base::invokeRestart
[10:24:18.211]                       is.null <- base::is.null
[10:24:18.211]                       muffled <- FALSE
[10:24:18.211]                       if (inherits(cond, "message")) {
[10:24:18.211]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.211]                         if (muffled) 
[10:24:18.211]                           invokeRestart("muffleMessage")
[10:24:18.211]                       }
[10:24:18.211]                       else if (inherits(cond, "warning")) {
[10:24:18.211]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.211]                         if (muffled) 
[10:24:18.211]                           invokeRestart("muffleWarning")
[10:24:18.211]                       }
[10:24:18.211]                       else if (inherits(cond, "condition")) {
[10:24:18.211]                         if (!is.null(pattern)) {
[10:24:18.211]                           computeRestarts <- base::computeRestarts
[10:24:18.211]                           grepl <- base::grepl
[10:24:18.211]                           restarts <- computeRestarts(cond)
[10:24:18.211]                           for (restart in restarts) {
[10:24:18.211]                             name <- restart$name
[10:24:18.211]                             if (is.null(name)) 
[10:24:18.211]                               next
[10:24:18.211]                             if (!grepl(pattern, name)) 
[10:24:18.211]                               next
[10:24:18.211]                             invokeRestart(restart)
[10:24:18.211]                             muffled <- TRUE
[10:24:18.211]                             break
[10:24:18.211]                           }
[10:24:18.211]                         }
[10:24:18.211]                       }
[10:24:18.211]                       invisible(muffled)
[10:24:18.211]                     }
[10:24:18.211]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.211]                   }
[10:24:18.211]                 }
[10:24:18.211]             }
[10:24:18.211]         }))
[10:24:18.211]     }, error = function(ex) {
[10:24:18.211]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.211]                 ...future.rng), started = ...future.startTime, 
[10:24:18.211]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.211]             version = "1.8"), class = "FutureResult")
[10:24:18.211]     }, finally = {
[10:24:18.211]         if (!identical(...future.workdir, getwd())) 
[10:24:18.211]             setwd(...future.workdir)
[10:24:18.211]         {
[10:24:18.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.211]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.211]             }
[10:24:18.211]             base::options(...future.oldOptions)
[10:24:18.211]             if (.Platform$OS.type == "windows") {
[10:24:18.211]                 old_names <- names(...future.oldEnvVars)
[10:24:18.211]                 envs <- base::Sys.getenv()
[10:24:18.211]                 names <- names(envs)
[10:24:18.211]                 common <- intersect(names, old_names)
[10:24:18.211]                 added <- setdiff(names, old_names)
[10:24:18.211]                 removed <- setdiff(old_names, names)
[10:24:18.211]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.211]                   envs[common]]
[10:24:18.211]                 NAMES <- toupper(changed)
[10:24:18.211]                 args <- list()
[10:24:18.211]                 for (kk in seq_along(NAMES)) {
[10:24:18.211]                   name <- changed[[kk]]
[10:24:18.211]                   NAME <- NAMES[[kk]]
[10:24:18.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.211]                     next
[10:24:18.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.211]                 }
[10:24:18.211]                 NAMES <- toupper(added)
[10:24:18.211]                 for (kk in seq_along(NAMES)) {
[10:24:18.211]                   name <- added[[kk]]
[10:24:18.211]                   NAME <- NAMES[[kk]]
[10:24:18.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.211]                     next
[10:24:18.211]                   args[[name]] <- ""
[10:24:18.211]                 }
[10:24:18.211]                 NAMES <- toupper(removed)
[10:24:18.211]                 for (kk in seq_along(NAMES)) {
[10:24:18.211]                   name <- removed[[kk]]
[10:24:18.211]                   NAME <- NAMES[[kk]]
[10:24:18.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.211]                     next
[10:24:18.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.211]                 }
[10:24:18.211]                 if (length(args) > 0) 
[10:24:18.211]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.211]             }
[10:24:18.211]             else {
[10:24:18.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.211]             }
[10:24:18.211]             {
[10:24:18.211]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.211]                   0L) {
[10:24:18.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.211]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.211]                   base::options(opts)
[10:24:18.211]                 }
[10:24:18.211]                 {
[10:24:18.211]                   {
[10:24:18.211]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.211]                     NULL
[10:24:18.211]                   }
[10:24:18.211]                   options(future.plan = NULL)
[10:24:18.211]                   if (is.na(NA_character_)) 
[10:24:18.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.211]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.211]                     envir = parent.frame()) 
[10:24:18.211]                   {
[10:24:18.211]                     default_workers <- missing(workers)
[10:24:18.211]                     if (is.function(workers)) 
[10:24:18.211]                       workers <- workers()
[10:24:18.211]                     workers <- structure(as.integer(workers), 
[10:24:18.211]                       class = class(workers))
[10:24:18.211]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.211]                       1L)
[10:24:18.211]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.211]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.211]                       if (default_workers) 
[10:24:18.211]                         supportsMulticore(warn = TRUE)
[10:24:18.211]                       return(sequential(..., envir = envir))
[10:24:18.211]                     }
[10:24:18.211]                     oopts <- options(mc.cores = workers)
[10:24:18.211]                     on.exit(options(oopts))
[10:24:18.211]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.211]                       envir = envir)
[10:24:18.211]                     if (!future$lazy) 
[10:24:18.211]                       future <- run(future)
[10:24:18.211]                     invisible(future)
[10:24:18.211]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.211]                 }
[10:24:18.211]             }
[10:24:18.211]         }
[10:24:18.211]     })
[10:24:18.211]     if (TRUE) {
[10:24:18.211]         base::sink(type = "output", split = FALSE)
[10:24:18.211]         if (TRUE) {
[10:24:18.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.211]         }
[10:24:18.211]         else {
[10:24:18.211]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.211]         }
[10:24:18.211]         base::close(...future.stdout)
[10:24:18.211]         ...future.stdout <- NULL
[10:24:18.211]     }
[10:24:18.211]     ...future.result$conditions <- ...future.conditions
[10:24:18.211]     ...future.result$finished <- base::Sys.time()
[10:24:18.211]     ...future.result
[10:24:18.211] }
[10:24:18.213] assign_globals() ...
[10:24:18.214] List of 5
[10:24:18.214]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[10:24:18.214]  $ future.call.arguments    : list()
[10:24:18.214]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.214]  $ ...future.elements_ii    :List of 4
[10:24:18.214]   ..$ : int [1:3] 1 2 3
[10:24:18.214]   ..$ : int [1:4] 1 2 3 4
[10:24:18.214]   ..$ : int [1:5] 1 2 3 4 5
[10:24:18.214]   ..$ : int [1:6] 1 2 3 4 5 6
[10:24:18.214]  $ ...future.seeds_ii       : NULL
[10:24:18.214]  $ ...future.globals.maxSize: NULL
[10:24:18.214]  - attr(*, "where")=List of 5
[10:24:18.214]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.214]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.214]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.214]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.214]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.214]  - attr(*, "resolved")= logi FALSE
[10:24:18.214]  - attr(*, "total_size")= num 46960
[10:24:18.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.214]  - attr(*, "already-done")= logi TRUE
[10:24:18.219] - copied ‘...future.FUN’ to environment
[10:24:18.220] - copied ‘future.call.arguments’ to environment
[10:24:18.220] - copied ‘...future.elements_ii’ to environment
[10:24:18.220] - copied ‘...future.seeds_ii’ to environment
[10:24:18.220] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.220] assign_globals() ... done
[10:24:18.220] requestCore(): workers = 2
[10:24:18.222] MulticoreFuture started
[10:24:18.223] - Launch lazy future ... done
[10:24:18.223] run() for ‘MulticoreFuture’ ... done
[10:24:18.223] Created future:
[10:24:18.224] plan(): Setting new future strategy stack:
[10:24:18.224] List of future strategies:
[10:24:18.224] 1. sequential:
[10:24:18.224]    - args: function (..., envir = parent.frame())
[10:24:18.224]    - tweaked: FALSE
[10:24:18.224]    - call: NULL
[10:24:18.225] plan(): nbrOfWorkers() = 1
[10:24:18.227] plan(): Setting new future strategy stack:
[10:24:18.227] List of future strategies:
[10:24:18.227] 1. multicore:
[10:24:18.227]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.227]    - tweaked: FALSE
[10:24:18.227]    - call: plan(strategy)
[10:24:18.233] plan(): nbrOfWorkers() = 2
[10:24:18.224] MulticoreFuture:
[10:24:18.224] Label: ‘future_sapply-1’
[10:24:18.224] Expression:
[10:24:18.224] {
[10:24:18.224]     do.call(function(...) {
[10:24:18.224]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.224]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.224]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.224]             on.exit(options(oopts), add = TRUE)
[10:24:18.224]         }
[10:24:18.224]         {
[10:24:18.224]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.224]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.224]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.224]             })
[10:24:18.224]         }
[10:24:18.224]     }, args = future.call.arguments)
[10:24:18.224] }
[10:24:18.224] Lazy evaluation: FALSE
[10:24:18.224] Asynchronous evaluation: TRUE
[10:24:18.224] Local evaluation: TRUE
[10:24:18.224] Environment: R_GlobalEnv
[10:24:18.224] Capture standard output: TRUE
[10:24:18.224] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.224] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:18.224] Packages: 1 packages (‘stats’)
[10:24:18.224] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.224] Resolved: TRUE
[10:24:18.224] Value: <not collected>
[10:24:18.224] Conditions captured: <none>
[10:24:18.224] Early signaling: FALSE
[10:24:18.224] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.224] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.234] Chunk #1 of 2 ... DONE
[10:24:18.235] Chunk #2 of 2 ...
[10:24:18.235]  - Finding globals in 'X' for chunk #2 ...
[10:24:18.235] getGlobalsAndPackages() ...
[10:24:18.235] Searching for globals...
[10:24:18.236] 
[10:24:18.236] Searching for globals ... DONE
[10:24:18.236] - globals: [0] <none>
[10:24:18.236] getGlobalsAndPackages() ... DONE
[10:24:18.236]    + additional globals found: [n=0] 
[10:24:18.236]    + additional namespaces needed: [n=0] 
[10:24:18.237]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:18.237]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.237]  - seeds: <none>
[10:24:18.237]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.237] getGlobalsAndPackages() ...
[10:24:18.237] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.238] Resolving globals: FALSE
[10:24:18.238] Tweak future expression to call with '...' arguments ...
[10:24:18.238] {
[10:24:18.238]     do.call(function(...) {
[10:24:18.238]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.238]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.238]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.238]             on.exit(options(oopts), add = TRUE)
[10:24:18.238]         }
[10:24:18.238]         {
[10:24:18.238]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.238]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.238]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.238]             })
[10:24:18.238]         }
[10:24:18.238]     }, args = future.call.arguments)
[10:24:18.238] }
[10:24:18.238] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.239] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.239] - packages: [1] ‘stats’
[10:24:18.239] getGlobalsAndPackages() ... DONE
[10:24:18.240] run() for ‘Future’ ...
[10:24:18.240] - state: ‘created’
[10:24:18.240] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.245] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.246]   - Field: ‘label’
[10:24:18.246]   - Field: ‘local’
[10:24:18.246]   - Field: ‘owner’
[10:24:18.246]   - Field: ‘envir’
[10:24:18.246]   - Field: ‘workers’
[10:24:18.246]   - Field: ‘packages’
[10:24:18.246]   - Field: ‘gc’
[10:24:18.247]   - Field: ‘job’
[10:24:18.247]   - Field: ‘conditions’
[10:24:18.247]   - Field: ‘expr’
[10:24:18.247]   - Field: ‘uuid’
[10:24:18.247]   - Field: ‘seed’
[10:24:18.247]   - Field: ‘version’
[10:24:18.247]   - Field: ‘result’
[10:24:18.248]   - Field: ‘asynchronous’
[10:24:18.248]   - Field: ‘calls’
[10:24:18.248]   - Field: ‘globals’
[10:24:18.248]   - Field: ‘stdout’
[10:24:18.248]   - Field: ‘earlySignal’
[10:24:18.248]   - Field: ‘lazy’
[10:24:18.248]   - Field: ‘state’
[10:24:18.249] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.249] - Launch lazy future ...
[10:24:18.249] Packages needed by the future expression (n = 1): ‘stats’
[10:24:18.250] Packages needed by future strategies (n = 0): <none>
[10:24:18.254] {
[10:24:18.254]     {
[10:24:18.254]         {
[10:24:18.254]             ...future.startTime <- base::Sys.time()
[10:24:18.254]             {
[10:24:18.254]                 {
[10:24:18.254]                   {
[10:24:18.254]                     {
[10:24:18.254]                       {
[10:24:18.254]                         base::local({
[10:24:18.254]                           has_future <- base::requireNamespace("future", 
[10:24:18.254]                             quietly = TRUE)
[10:24:18.254]                           if (has_future) {
[10:24:18.254]                             ns <- base::getNamespace("future")
[10:24:18.254]                             version <- ns[[".package"]][["version"]]
[10:24:18.254]                             if (is.null(version)) 
[10:24:18.254]                               version <- utils::packageVersion("future")
[10:24:18.254]                           }
[10:24:18.254]                           else {
[10:24:18.254]                             version <- NULL
[10:24:18.254]                           }
[10:24:18.254]                           if (!has_future || version < "1.8.0") {
[10:24:18.254]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.254]                               "", base::R.version$version.string), 
[10:24:18.254]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.254]                                 base::R.version$platform, 8 * 
[10:24:18.254]                                   base::.Machine$sizeof.pointer), 
[10:24:18.254]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.254]                                 "release", "version")], collapse = " "), 
[10:24:18.254]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.254]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.254]                               info)
[10:24:18.254]                             info <- base::paste(info, collapse = "; ")
[10:24:18.254]                             if (!has_future) {
[10:24:18.254]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.254]                                 info)
[10:24:18.254]                             }
[10:24:18.254]                             else {
[10:24:18.254]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.254]                                 info, version)
[10:24:18.254]                             }
[10:24:18.254]                             base::stop(msg)
[10:24:18.254]                           }
[10:24:18.254]                         })
[10:24:18.254]                       }
[10:24:18.254]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.254]                       base::options(mc.cores = 1L)
[10:24:18.254]                     }
[10:24:18.254]                     base::local({
[10:24:18.254]                       for (pkg in "stats") {
[10:24:18.254]                         base::loadNamespace(pkg)
[10:24:18.254]                         base::library(pkg, character.only = TRUE)
[10:24:18.254]                       }
[10:24:18.254]                     })
[10:24:18.254]                   }
[10:24:18.254]                   options(future.plan = NULL)
[10:24:18.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.254]                 }
[10:24:18.254]                 ...future.workdir <- getwd()
[10:24:18.254]             }
[10:24:18.254]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.254]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.254]         }
[10:24:18.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.254]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.254]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.254]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.254]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.254]             base::names(...future.oldOptions))
[10:24:18.254]     }
[10:24:18.254]     if (FALSE) {
[10:24:18.254]     }
[10:24:18.254]     else {
[10:24:18.254]         if (TRUE) {
[10:24:18.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.254]                 open = "w")
[10:24:18.254]         }
[10:24:18.254]         else {
[10:24:18.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.254]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.254]         }
[10:24:18.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.254]             base::sink(type = "output", split = FALSE)
[10:24:18.254]             base::close(...future.stdout)
[10:24:18.254]         }, add = TRUE)
[10:24:18.254]     }
[10:24:18.254]     ...future.frame <- base::sys.nframe()
[10:24:18.254]     ...future.conditions <- base::list()
[10:24:18.254]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.254]     if (FALSE) {
[10:24:18.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.254]     }
[10:24:18.254]     ...future.result <- base::tryCatch({
[10:24:18.254]         base::withCallingHandlers({
[10:24:18.254]             ...future.value <- base::withVisible(base::local({
[10:24:18.254]                 withCallingHandlers({
[10:24:18.254]                   {
[10:24:18.254]                     do.call(function(...) {
[10:24:18.254]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.254]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.254]                         ...future.globals.maxSize)) {
[10:24:18.254]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.254]                         on.exit(options(oopts), add = TRUE)
[10:24:18.254]                       }
[10:24:18.254]                       {
[10:24:18.254]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.254]                           FUN = function(jj) {
[10:24:18.254]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.254]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.254]                           })
[10:24:18.254]                       }
[10:24:18.254]                     }, args = future.call.arguments)
[10:24:18.254]                   }
[10:24:18.254]                 }, immediateCondition = function(cond) {
[10:24:18.254]                   save_rds <- function (object, pathname, ...) 
[10:24:18.254]                   {
[10:24:18.254]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.254]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.254]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.254]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.254]                         fi_tmp[["mtime"]])
[10:24:18.254]                     }
[10:24:18.254]                     tryCatch({
[10:24:18.254]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.254]                     }, error = function(ex) {
[10:24:18.254]                       msg <- conditionMessage(ex)
[10:24:18.254]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.254]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.254]                         fi_tmp[["mtime"]], msg)
[10:24:18.254]                       ex$message <- msg
[10:24:18.254]                       stop(ex)
[10:24:18.254]                     })
[10:24:18.254]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.254]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.254]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.254]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.254]                       fi <- file.info(pathname)
[10:24:18.254]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.254]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.254]                         fi[["size"]], fi[["mtime"]])
[10:24:18.254]                       stop(msg)
[10:24:18.254]                     }
[10:24:18.254]                     invisible(pathname)
[10:24:18.254]                   }
[10:24:18.254]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.254]                     rootPath = tempdir()) 
[10:24:18.254]                   {
[10:24:18.254]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.254]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.254]                       tmpdir = path, fileext = ".rds")
[10:24:18.254]                     save_rds(obj, file)
[10:24:18.254]                   }
[10:24:18.254]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.254]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.254]                   {
[10:24:18.254]                     inherits <- base::inherits
[10:24:18.254]                     invokeRestart <- base::invokeRestart
[10:24:18.254]                     is.null <- base::is.null
[10:24:18.254]                     muffled <- FALSE
[10:24:18.254]                     if (inherits(cond, "message")) {
[10:24:18.254]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.254]                       if (muffled) 
[10:24:18.254]                         invokeRestart("muffleMessage")
[10:24:18.254]                     }
[10:24:18.254]                     else if (inherits(cond, "warning")) {
[10:24:18.254]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.254]                       if (muffled) 
[10:24:18.254]                         invokeRestart("muffleWarning")
[10:24:18.254]                     }
[10:24:18.254]                     else if (inherits(cond, "condition")) {
[10:24:18.254]                       if (!is.null(pattern)) {
[10:24:18.254]                         computeRestarts <- base::computeRestarts
[10:24:18.254]                         grepl <- base::grepl
[10:24:18.254]                         restarts <- computeRestarts(cond)
[10:24:18.254]                         for (restart in restarts) {
[10:24:18.254]                           name <- restart$name
[10:24:18.254]                           if (is.null(name)) 
[10:24:18.254]                             next
[10:24:18.254]                           if (!grepl(pattern, name)) 
[10:24:18.254]                             next
[10:24:18.254]                           invokeRestart(restart)
[10:24:18.254]                           muffled <- TRUE
[10:24:18.254]                           break
[10:24:18.254]                         }
[10:24:18.254]                       }
[10:24:18.254]                     }
[10:24:18.254]                     invisible(muffled)
[10:24:18.254]                   }
[10:24:18.254]                   muffleCondition(cond)
[10:24:18.254]                 })
[10:24:18.254]             }))
[10:24:18.254]             future::FutureResult(value = ...future.value$value, 
[10:24:18.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.254]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.254]                     ...future.globalenv.names))
[10:24:18.254]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.254]         }, condition = base::local({
[10:24:18.254]             c <- base::c
[10:24:18.254]             inherits <- base::inherits
[10:24:18.254]             invokeRestart <- base::invokeRestart
[10:24:18.254]             length <- base::length
[10:24:18.254]             list <- base::list
[10:24:18.254]             seq.int <- base::seq.int
[10:24:18.254]             signalCondition <- base::signalCondition
[10:24:18.254]             sys.calls <- base::sys.calls
[10:24:18.254]             `[[` <- base::`[[`
[10:24:18.254]             `+` <- base::`+`
[10:24:18.254]             `<<-` <- base::`<<-`
[10:24:18.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.254]                   3L)]
[10:24:18.254]             }
[10:24:18.254]             function(cond) {
[10:24:18.254]                 is_error <- inherits(cond, "error")
[10:24:18.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.254]                   NULL)
[10:24:18.254]                 if (is_error) {
[10:24:18.254]                   sessionInformation <- function() {
[10:24:18.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.254]                       search = base::search(), system = base::Sys.info())
[10:24:18.254]                   }
[10:24:18.254]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.254]                     cond$call), session = sessionInformation(), 
[10:24:18.254]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.254]                   signalCondition(cond)
[10:24:18.254]                 }
[10:24:18.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.254]                 "immediateCondition"))) {
[10:24:18.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.254]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.254]                   if (TRUE && !signal) {
[10:24:18.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.254]                     {
[10:24:18.254]                       inherits <- base::inherits
[10:24:18.254]                       invokeRestart <- base::invokeRestart
[10:24:18.254]                       is.null <- base::is.null
[10:24:18.254]                       muffled <- FALSE
[10:24:18.254]                       if (inherits(cond, "message")) {
[10:24:18.254]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.254]                         if (muffled) 
[10:24:18.254]                           invokeRestart("muffleMessage")
[10:24:18.254]                       }
[10:24:18.254]                       else if (inherits(cond, "warning")) {
[10:24:18.254]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.254]                         if (muffled) 
[10:24:18.254]                           invokeRestart("muffleWarning")
[10:24:18.254]                       }
[10:24:18.254]                       else if (inherits(cond, "condition")) {
[10:24:18.254]                         if (!is.null(pattern)) {
[10:24:18.254]                           computeRestarts <- base::computeRestarts
[10:24:18.254]                           grepl <- base::grepl
[10:24:18.254]                           restarts <- computeRestarts(cond)
[10:24:18.254]                           for (restart in restarts) {
[10:24:18.254]                             name <- restart$name
[10:24:18.254]                             if (is.null(name)) 
[10:24:18.254]                               next
[10:24:18.254]                             if (!grepl(pattern, name)) 
[10:24:18.254]                               next
[10:24:18.254]                             invokeRestart(restart)
[10:24:18.254]                             muffled <- TRUE
[10:24:18.254]                             break
[10:24:18.254]                           }
[10:24:18.254]                         }
[10:24:18.254]                       }
[10:24:18.254]                       invisible(muffled)
[10:24:18.254]                     }
[10:24:18.254]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.254]                   }
[10:24:18.254]                 }
[10:24:18.254]                 else {
[10:24:18.254]                   if (TRUE) {
[10:24:18.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.254]                     {
[10:24:18.254]                       inherits <- base::inherits
[10:24:18.254]                       invokeRestart <- base::invokeRestart
[10:24:18.254]                       is.null <- base::is.null
[10:24:18.254]                       muffled <- FALSE
[10:24:18.254]                       if (inherits(cond, "message")) {
[10:24:18.254]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.254]                         if (muffled) 
[10:24:18.254]                           invokeRestart("muffleMessage")
[10:24:18.254]                       }
[10:24:18.254]                       else if (inherits(cond, "warning")) {
[10:24:18.254]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.254]                         if (muffled) 
[10:24:18.254]                           invokeRestart("muffleWarning")
[10:24:18.254]                       }
[10:24:18.254]                       else if (inherits(cond, "condition")) {
[10:24:18.254]                         if (!is.null(pattern)) {
[10:24:18.254]                           computeRestarts <- base::computeRestarts
[10:24:18.254]                           grepl <- base::grepl
[10:24:18.254]                           restarts <- computeRestarts(cond)
[10:24:18.254]                           for (restart in restarts) {
[10:24:18.254]                             name <- restart$name
[10:24:18.254]                             if (is.null(name)) 
[10:24:18.254]                               next
[10:24:18.254]                             if (!grepl(pattern, name)) 
[10:24:18.254]                               next
[10:24:18.254]                             invokeRestart(restart)
[10:24:18.254]                             muffled <- TRUE
[10:24:18.254]                             break
[10:24:18.254]                           }
[10:24:18.254]                         }
[10:24:18.254]                       }
[10:24:18.254]                       invisible(muffled)
[10:24:18.254]                     }
[10:24:18.254]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.254]                   }
[10:24:18.254]                 }
[10:24:18.254]             }
[10:24:18.254]         }))
[10:24:18.254]     }, error = function(ex) {
[10:24:18.254]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.254]                 ...future.rng), started = ...future.startTime, 
[10:24:18.254]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.254]             version = "1.8"), class = "FutureResult")
[10:24:18.254]     }, finally = {
[10:24:18.254]         if (!identical(...future.workdir, getwd())) 
[10:24:18.254]             setwd(...future.workdir)
[10:24:18.254]         {
[10:24:18.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.254]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.254]             }
[10:24:18.254]             base::options(...future.oldOptions)
[10:24:18.254]             if (.Platform$OS.type == "windows") {
[10:24:18.254]                 old_names <- names(...future.oldEnvVars)
[10:24:18.254]                 envs <- base::Sys.getenv()
[10:24:18.254]                 names <- names(envs)
[10:24:18.254]                 common <- intersect(names, old_names)
[10:24:18.254]                 added <- setdiff(names, old_names)
[10:24:18.254]                 removed <- setdiff(old_names, names)
[10:24:18.254]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.254]                   envs[common]]
[10:24:18.254]                 NAMES <- toupper(changed)
[10:24:18.254]                 args <- list()
[10:24:18.254]                 for (kk in seq_along(NAMES)) {
[10:24:18.254]                   name <- changed[[kk]]
[10:24:18.254]                   NAME <- NAMES[[kk]]
[10:24:18.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.254]                     next
[10:24:18.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.254]                 }
[10:24:18.254]                 NAMES <- toupper(added)
[10:24:18.254]                 for (kk in seq_along(NAMES)) {
[10:24:18.254]                   name <- added[[kk]]
[10:24:18.254]                   NAME <- NAMES[[kk]]
[10:24:18.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.254]                     next
[10:24:18.254]                   args[[name]] <- ""
[10:24:18.254]                 }
[10:24:18.254]                 NAMES <- toupper(removed)
[10:24:18.254]                 for (kk in seq_along(NAMES)) {
[10:24:18.254]                   name <- removed[[kk]]
[10:24:18.254]                   NAME <- NAMES[[kk]]
[10:24:18.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.254]                     next
[10:24:18.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.254]                 }
[10:24:18.254]                 if (length(args) > 0) 
[10:24:18.254]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.254]             }
[10:24:18.254]             else {
[10:24:18.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.254]             }
[10:24:18.254]             {
[10:24:18.254]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.254]                   0L) {
[10:24:18.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.254]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.254]                   base::options(opts)
[10:24:18.254]                 }
[10:24:18.254]                 {
[10:24:18.254]                   {
[10:24:18.254]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.254]                     NULL
[10:24:18.254]                   }
[10:24:18.254]                   options(future.plan = NULL)
[10:24:18.254]                   if (is.na(NA_character_)) 
[10:24:18.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.254]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.254]                     envir = parent.frame()) 
[10:24:18.254]                   {
[10:24:18.254]                     default_workers <- missing(workers)
[10:24:18.254]                     if (is.function(workers)) 
[10:24:18.254]                       workers <- workers()
[10:24:18.254]                     workers <- structure(as.integer(workers), 
[10:24:18.254]                       class = class(workers))
[10:24:18.254]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.254]                       1L)
[10:24:18.254]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.254]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.254]                       if (default_workers) 
[10:24:18.254]                         supportsMulticore(warn = TRUE)
[10:24:18.254]                       return(sequential(..., envir = envir))
[10:24:18.254]                     }
[10:24:18.254]                     oopts <- options(mc.cores = workers)
[10:24:18.254]                     on.exit(options(oopts))
[10:24:18.254]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.254]                       envir = envir)
[10:24:18.254]                     if (!future$lazy) 
[10:24:18.254]                       future <- run(future)
[10:24:18.254]                     invisible(future)
[10:24:18.254]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.254]                 }
[10:24:18.254]             }
[10:24:18.254]         }
[10:24:18.254]     })
[10:24:18.254]     if (TRUE) {
[10:24:18.254]         base::sink(type = "output", split = FALSE)
[10:24:18.254]         if (TRUE) {
[10:24:18.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.254]         }
[10:24:18.254]         else {
[10:24:18.254]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.254]         }
[10:24:18.254]         base::close(...future.stdout)
[10:24:18.254]         ...future.stdout <- NULL
[10:24:18.254]     }
[10:24:18.254]     ...future.result$conditions <- ...future.conditions
[10:24:18.254]     ...future.result$finished <- base::Sys.time()
[10:24:18.254]     ...future.result
[10:24:18.254] }
[10:24:18.258] assign_globals() ...
[10:24:18.258] List of 5
[10:24:18.258]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[10:24:18.258]  $ future.call.arguments    : list()
[10:24:18.258]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.258]  $ ...future.elements_ii    :List of 3
[10:24:18.258]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:24:18.258]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:24:18.258]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:24:18.258]  $ ...future.seeds_ii       : NULL
[10:24:18.258]  $ ...future.globals.maxSize: NULL
[10:24:18.258]  - attr(*, "where")=List of 5
[10:24:18.258]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.258]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.258]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.258]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.258]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.258]  - attr(*, "resolved")= logi FALSE
[10:24:18.258]  - attr(*, "total_size")= num 46960
[10:24:18.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.258]  - attr(*, "already-done")= logi TRUE
[10:24:18.268] - copied ‘...future.FUN’ to environment
[10:24:18.268] - copied ‘future.call.arguments’ to environment
[10:24:18.269] - copied ‘...future.elements_ii’ to environment
[10:24:18.269] - copied ‘...future.seeds_ii’ to environment
[10:24:18.269] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.269] assign_globals() ... done
[10:24:18.269] requestCore(): workers = 2
[10:24:18.272] MulticoreFuture started
[10:24:18.272] - Launch lazy future ... done
[10:24:18.273] run() for ‘MulticoreFuture’ ... done
[10:24:18.273] Created future:
[10:24:18.274] plan(): Setting new future strategy stack:
[10:24:18.274] List of future strategies:
[10:24:18.274] 1. sequential:
[10:24:18.274]    - args: function (..., envir = parent.frame())
[10:24:18.274]    - tweaked: FALSE
[10:24:18.274]    - call: NULL
[10:24:18.275] plan(): nbrOfWorkers() = 1
[10:24:18.277] plan(): Setting new future strategy stack:
[10:24:18.277] List of future strategies:
[10:24:18.277] 1. multicore:
[10:24:18.277]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.277]    - tweaked: FALSE
[10:24:18.277]    - call: plan(strategy)
[10:24:18.283] plan(): nbrOfWorkers() = 2
[10:24:18.273] MulticoreFuture:
[10:24:18.273] Label: ‘future_sapply-2’
[10:24:18.273] Expression:
[10:24:18.273] {
[10:24:18.273]     do.call(function(...) {
[10:24:18.273]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.273]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.273]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.273]             on.exit(options(oopts), add = TRUE)
[10:24:18.273]         }
[10:24:18.273]         {
[10:24:18.273]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.273]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.273]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.273]             })
[10:24:18.273]         }
[10:24:18.273]     }, args = future.call.arguments)
[10:24:18.273] }
[10:24:18.273] Lazy evaluation: FALSE
[10:24:18.273] Asynchronous evaluation: TRUE
[10:24:18.273] Local evaluation: TRUE
[10:24:18.273] Environment: R_GlobalEnv
[10:24:18.273] Capture standard output: TRUE
[10:24:18.273] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.273] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:18.273] Packages: 1 packages (‘stats’)
[10:24:18.273] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.273] Resolved: TRUE
[10:24:18.273] Value: <not collected>
[10:24:18.273] Conditions captured: <none>
[10:24:18.273] Early signaling: FALSE
[10:24:18.273] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.273] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.284] Chunk #2 of 2 ... DONE
[10:24:18.284] Launching 2 futures (chunks) ... DONE
[10:24:18.285] Resolving 2 futures (chunks) ...
[10:24:18.285] resolve() on list ...
[10:24:18.285]  recursive: 0
[10:24:18.285]  length: 2
[10:24:18.285] 
[10:24:18.286] Future #1
[10:24:18.286] result() for MulticoreFuture ...
[10:24:18.287] result() for MulticoreFuture ...
[10:24:18.287] result() for MulticoreFuture ... done
[10:24:18.287] result() for MulticoreFuture ... done
[10:24:18.287] result() for MulticoreFuture ...
[10:24:18.287] result() for MulticoreFuture ... done
[10:24:18.288] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:18.288] - nx: 2
[10:24:18.288] - relay: TRUE
[10:24:18.288] - stdout: TRUE
[10:24:18.288] - signal: TRUE
[10:24:18.288] - resignal: FALSE
[10:24:18.289] - force: TRUE
[10:24:18.289] - relayed: [n=2] FALSE, FALSE
[10:24:18.289] - queued futures: [n=2] FALSE, FALSE
[10:24:18.289]  - until=1
[10:24:18.289]  - relaying element #1
[10:24:18.290] result() for MulticoreFuture ...
[10:24:18.290] result() for MulticoreFuture ... done
[10:24:18.290] result() for MulticoreFuture ...
[10:24:18.290] result() for MulticoreFuture ... done
[10:24:18.290] result() for MulticoreFuture ...
[10:24:18.290] result() for MulticoreFuture ... done
[10:24:18.291] result() for MulticoreFuture ...
[10:24:18.291] result() for MulticoreFuture ... done
[10:24:18.291] - relayed: [n=2] TRUE, FALSE
[10:24:18.291] - queued futures: [n=2] TRUE, FALSE
[10:24:18.291] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:18.292]  length: 1 (resolved future 1)
[10:24:18.292] Future #2
[10:24:18.292] result() for MulticoreFuture ...
[10:24:18.293] result() for MulticoreFuture ...
[10:24:18.293] result() for MulticoreFuture ... done
[10:24:18.293] result() for MulticoreFuture ... done
[10:24:18.293] result() for MulticoreFuture ...
[10:24:18.293] result() for MulticoreFuture ... done
[10:24:18.294] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:18.294] - nx: 2
[10:24:18.294] - relay: TRUE
[10:24:18.294] - stdout: TRUE
[10:24:18.294] - signal: TRUE
[10:24:18.294] - resignal: FALSE
[10:24:18.295] - force: TRUE
[10:24:18.295] - relayed: [n=2] TRUE, FALSE
[10:24:18.295] - queued futures: [n=2] TRUE, FALSE
[10:24:18.295]  - until=2
[10:24:18.295]  - relaying element #2
[10:24:18.295] result() for MulticoreFuture ...
[10:24:18.295] result() for MulticoreFuture ... done
[10:24:18.295] result() for MulticoreFuture ...
[10:24:18.296] result() for MulticoreFuture ... done
[10:24:18.296] result() for MulticoreFuture ...
[10:24:18.296] result() for MulticoreFuture ... done
[10:24:18.296] result() for MulticoreFuture ...
[10:24:18.296] result() for MulticoreFuture ... done
[10:24:18.296] - relayed: [n=2] TRUE, TRUE
[10:24:18.296] - queued futures: [n=2] TRUE, TRUE
[10:24:18.296] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:18.297]  length: 0 (resolved future 2)
[10:24:18.297] Relaying remaining futures
[10:24:18.297] signalConditionsASAP(NULL, pos=0) ...
[10:24:18.297] - nx: 2
[10:24:18.297] - relay: TRUE
[10:24:18.297] - stdout: TRUE
[10:24:18.297] - signal: TRUE
[10:24:18.297] - resignal: FALSE
[10:24:18.297] - force: TRUE
[10:24:18.298] - relayed: [n=2] TRUE, TRUE
[10:24:18.298] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:18.298] - relayed: [n=2] TRUE, TRUE
[10:24:18.298] - queued futures: [n=2] TRUE, TRUE
[10:24:18.298] signalConditionsASAP(NULL, pos=0) ... done
[10:24:18.301] resolve() on list ... DONE
[10:24:18.301] result() for MulticoreFuture ...
[10:24:18.301] result() for MulticoreFuture ... done
[10:24:18.302] result() for MulticoreFuture ...
[10:24:18.302] result() for MulticoreFuture ... done
[10:24:18.302] result() for MulticoreFuture ...
[10:24:18.302] result() for MulticoreFuture ... done
[10:24:18.303] result() for MulticoreFuture ...
[10:24:18.303] result() for MulticoreFuture ... done
[10:24:18.303]  - Number of value chunks collected: 2
[10:24:18.303] Resolving 2 futures (chunks) ... DONE
[10:24:18.303] Reducing values from 2 chunks ...
[10:24:18.303]  - Number of values collected after concatenation: 7
[10:24:18.304]  - Number of values expected: 7
[10:24:18.304] Reducing values from 2 chunks ... DONE
[10:24:18.304] future_lapply() ... DONE
[10:24:18.305] future_lapply() ...
[10:24:18.313] Number of chunks: 2
[10:24:18.313] getGlobalsAndPackagesXApply() ...
[10:24:18.313]  - future.globals: TRUE
[10:24:18.313] getGlobalsAndPackages() ...
[10:24:18.313] Searching for globals...
[10:24:18.321] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:24:18.321] Searching for globals ... DONE
[10:24:18.322] Resolving globals: FALSE
[10:24:18.323] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[10:24:18.323] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[10:24:18.323] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:18.324] - packages: [2] ‘stats’, ‘future.apply’
[10:24:18.324] getGlobalsAndPackages() ... DONE
[10:24:18.324]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:18.324]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:24:18.324] Finding globals ... DONE
[10:24:18.324]  - use_args: TRUE
[10:24:18.324]  - Getting '...' globals ...
[10:24:18.327] resolve() on list ...
[10:24:18.327]  recursive: 0
[10:24:18.327]  length: 1
[10:24:18.327]  elements: ‘...’
[10:24:18.327]  length: 0 (resolved future 1)
[10:24:18.327] resolve() on list ... DONE
[10:24:18.328]    - '...' content: [n=0] 
[10:24:18.328] List of 1
[10:24:18.328]  $ ...: list()
[10:24:18.328]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.328]  - attr(*, "where")=List of 1
[10:24:18.328]   ..$ ...:<environment: 0x55b93d1130b8> 
[10:24:18.328]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.328]  - attr(*, "resolved")= logi TRUE
[10:24:18.328]  - attr(*, "total_size")= num NA
[10:24:18.331]  - Getting '...' globals ... DONE
[10:24:18.331] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:18.331] List of 8
[10:24:18.331]  $ ...future.FUN:function (x, ...)  
[10:24:18.331]  $ x_FUN        :function (x, na.rm = TRUE)  
[10:24:18.331]  $ times        : int 5
[10:24:18.331]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.331]  $ stop_if_not  :function (...)  
[10:24:18.331]  $ dim          : NULL
[10:24:18.331]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:18.331]  $ ...          : list()
[10:24:18.331]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.331]  - attr(*, "where")=List of 8
[10:24:18.331]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:18.331]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:18.331]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:18.331]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:18.331]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:18.331]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:18.331]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:18.331]   ..$ ...          :<environment: 0x55b93d1130b8> 
[10:24:18.331]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.331]  - attr(*, "resolved")= logi FALSE
[10:24:18.331]  - attr(*, "total_size")= num 141240
[10:24:18.337] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:24:18.337] getGlobalsAndPackagesXApply() ... DONE
[10:24:18.337] Number of futures (= number of chunks): 2
[10:24:18.338] Launching 2 futures (chunks) ...
[10:24:18.338] Chunk #1 of 2 ...
[10:24:18.338]  - Finding globals in 'X' for chunk #1 ...
[10:24:18.338] getGlobalsAndPackages() ...
[10:24:18.338] Searching for globals...
[10:24:18.338] 
[10:24:18.338] Searching for globals ... DONE
[10:24:18.338] - globals: [0] <none>
[10:24:18.339] getGlobalsAndPackages() ... DONE
[10:24:18.339]    + additional globals found: [n=0] 
[10:24:18.339]    + additional namespaces needed: [n=0] 
[10:24:18.339]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:18.339]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.339]  - seeds: <none>
[10:24:18.339]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.339] getGlobalsAndPackages() ...
[10:24:18.339] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.339] Resolving globals: FALSE
[10:24:18.340] Tweak future expression to call with '...' arguments ...
[10:24:18.340] {
[10:24:18.340]     do.call(function(...) {
[10:24:18.340]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.340]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.340]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.340]             on.exit(options(oopts), add = TRUE)
[10:24:18.340]         }
[10:24:18.340]         {
[10:24:18.340]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.340]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.340]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.340]             })
[10:24:18.340]         }
[10:24:18.340]     }, args = future.call.arguments)
[10:24:18.340] }
[10:24:18.340] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.340] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.341] - packages: [2] ‘stats’, ‘future.apply’
[10:24:18.341] getGlobalsAndPackages() ... DONE
[10:24:18.341] run() for ‘Future’ ...
[10:24:18.341] - state: ‘created’
[10:24:18.341] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.345] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.345]   - Field: ‘label’
[10:24:18.345]   - Field: ‘local’
[10:24:18.346]   - Field: ‘owner’
[10:24:18.346]   - Field: ‘envir’
[10:24:18.346]   - Field: ‘workers’
[10:24:18.346]   - Field: ‘packages’
[10:24:18.346]   - Field: ‘gc’
[10:24:18.346]   - Field: ‘job’
[10:24:18.346]   - Field: ‘conditions’
[10:24:18.346]   - Field: ‘expr’
[10:24:18.346]   - Field: ‘uuid’
[10:24:18.346]   - Field: ‘seed’
[10:24:18.347]   - Field: ‘version’
[10:24:18.347]   - Field: ‘result’
[10:24:18.347]   - Field: ‘asynchronous’
[10:24:18.347]   - Field: ‘calls’
[10:24:18.347]   - Field: ‘globals’
[10:24:18.347]   - Field: ‘stdout’
[10:24:18.349]   - Field: ‘earlySignal’
[10:24:18.349]   - Field: ‘lazy’
[10:24:18.350]   - Field: ‘state’
[10:24:18.350] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.350] - Launch lazy future ...
[10:24:18.350] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:24:18.350] Packages needed by future strategies (n = 0): <none>
[10:24:18.351] {
[10:24:18.351]     {
[10:24:18.351]         {
[10:24:18.351]             ...future.startTime <- base::Sys.time()
[10:24:18.351]             {
[10:24:18.351]                 {
[10:24:18.351]                   {
[10:24:18.351]                     {
[10:24:18.351]                       {
[10:24:18.351]                         base::local({
[10:24:18.351]                           has_future <- base::requireNamespace("future", 
[10:24:18.351]                             quietly = TRUE)
[10:24:18.351]                           if (has_future) {
[10:24:18.351]                             ns <- base::getNamespace("future")
[10:24:18.351]                             version <- ns[[".package"]][["version"]]
[10:24:18.351]                             if (is.null(version)) 
[10:24:18.351]                               version <- utils::packageVersion("future")
[10:24:18.351]                           }
[10:24:18.351]                           else {
[10:24:18.351]                             version <- NULL
[10:24:18.351]                           }
[10:24:18.351]                           if (!has_future || version < "1.8.0") {
[10:24:18.351]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.351]                               "", base::R.version$version.string), 
[10:24:18.351]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.351]                                 base::R.version$platform, 8 * 
[10:24:18.351]                                   base::.Machine$sizeof.pointer), 
[10:24:18.351]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.351]                                 "release", "version")], collapse = " "), 
[10:24:18.351]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.351]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.351]                               info)
[10:24:18.351]                             info <- base::paste(info, collapse = "; ")
[10:24:18.351]                             if (!has_future) {
[10:24:18.351]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.351]                                 info)
[10:24:18.351]                             }
[10:24:18.351]                             else {
[10:24:18.351]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.351]                                 info, version)
[10:24:18.351]                             }
[10:24:18.351]                             base::stop(msg)
[10:24:18.351]                           }
[10:24:18.351]                         })
[10:24:18.351]                       }
[10:24:18.351]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.351]                       base::options(mc.cores = 1L)
[10:24:18.351]                     }
[10:24:18.351]                     base::local({
[10:24:18.351]                       for (pkg in c("stats", "future.apply")) {
[10:24:18.351]                         base::loadNamespace(pkg)
[10:24:18.351]                         base::library(pkg, character.only = TRUE)
[10:24:18.351]                       }
[10:24:18.351]                     })
[10:24:18.351]                   }
[10:24:18.351]                   options(future.plan = NULL)
[10:24:18.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.351]                 }
[10:24:18.351]                 ...future.workdir <- getwd()
[10:24:18.351]             }
[10:24:18.351]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.351]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.351]         }
[10:24:18.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.351]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.351]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.351]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.351]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.351]             base::names(...future.oldOptions))
[10:24:18.351]     }
[10:24:18.351]     if (FALSE) {
[10:24:18.351]     }
[10:24:18.351]     else {
[10:24:18.351]         if (TRUE) {
[10:24:18.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.351]                 open = "w")
[10:24:18.351]         }
[10:24:18.351]         else {
[10:24:18.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.351]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.351]         }
[10:24:18.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.351]             base::sink(type = "output", split = FALSE)
[10:24:18.351]             base::close(...future.stdout)
[10:24:18.351]         }, add = TRUE)
[10:24:18.351]     }
[10:24:18.351]     ...future.frame <- base::sys.nframe()
[10:24:18.351]     ...future.conditions <- base::list()
[10:24:18.351]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.351]     if (FALSE) {
[10:24:18.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.351]     }
[10:24:18.351]     ...future.result <- base::tryCatch({
[10:24:18.351]         base::withCallingHandlers({
[10:24:18.351]             ...future.value <- base::withVisible(base::local({
[10:24:18.351]                 withCallingHandlers({
[10:24:18.351]                   {
[10:24:18.351]                     do.call(function(...) {
[10:24:18.351]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.351]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.351]                         ...future.globals.maxSize)) {
[10:24:18.351]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.351]                         on.exit(options(oopts), add = TRUE)
[10:24:18.351]                       }
[10:24:18.351]                       {
[10:24:18.351]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.351]                           FUN = function(jj) {
[10:24:18.351]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.351]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.351]                           })
[10:24:18.351]                       }
[10:24:18.351]                     }, args = future.call.arguments)
[10:24:18.351]                   }
[10:24:18.351]                 }, immediateCondition = function(cond) {
[10:24:18.351]                   save_rds <- function (object, pathname, ...) 
[10:24:18.351]                   {
[10:24:18.351]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.351]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.351]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.351]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.351]                         fi_tmp[["mtime"]])
[10:24:18.351]                     }
[10:24:18.351]                     tryCatch({
[10:24:18.351]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.351]                     }, error = function(ex) {
[10:24:18.351]                       msg <- conditionMessage(ex)
[10:24:18.351]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.351]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.351]                         fi_tmp[["mtime"]], msg)
[10:24:18.351]                       ex$message <- msg
[10:24:18.351]                       stop(ex)
[10:24:18.351]                     })
[10:24:18.351]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.351]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.351]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.351]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.351]                       fi <- file.info(pathname)
[10:24:18.351]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.351]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.351]                         fi[["size"]], fi[["mtime"]])
[10:24:18.351]                       stop(msg)
[10:24:18.351]                     }
[10:24:18.351]                     invisible(pathname)
[10:24:18.351]                   }
[10:24:18.351]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.351]                     rootPath = tempdir()) 
[10:24:18.351]                   {
[10:24:18.351]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.351]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.351]                       tmpdir = path, fileext = ".rds")
[10:24:18.351]                     save_rds(obj, file)
[10:24:18.351]                   }
[10:24:18.351]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.351]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.351]                   {
[10:24:18.351]                     inherits <- base::inherits
[10:24:18.351]                     invokeRestart <- base::invokeRestart
[10:24:18.351]                     is.null <- base::is.null
[10:24:18.351]                     muffled <- FALSE
[10:24:18.351]                     if (inherits(cond, "message")) {
[10:24:18.351]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.351]                       if (muffled) 
[10:24:18.351]                         invokeRestart("muffleMessage")
[10:24:18.351]                     }
[10:24:18.351]                     else if (inherits(cond, "warning")) {
[10:24:18.351]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.351]                       if (muffled) 
[10:24:18.351]                         invokeRestart("muffleWarning")
[10:24:18.351]                     }
[10:24:18.351]                     else if (inherits(cond, "condition")) {
[10:24:18.351]                       if (!is.null(pattern)) {
[10:24:18.351]                         computeRestarts <- base::computeRestarts
[10:24:18.351]                         grepl <- base::grepl
[10:24:18.351]                         restarts <- computeRestarts(cond)
[10:24:18.351]                         for (restart in restarts) {
[10:24:18.351]                           name <- restart$name
[10:24:18.351]                           if (is.null(name)) 
[10:24:18.351]                             next
[10:24:18.351]                           if (!grepl(pattern, name)) 
[10:24:18.351]                             next
[10:24:18.351]                           invokeRestart(restart)
[10:24:18.351]                           muffled <- TRUE
[10:24:18.351]                           break
[10:24:18.351]                         }
[10:24:18.351]                       }
[10:24:18.351]                     }
[10:24:18.351]                     invisible(muffled)
[10:24:18.351]                   }
[10:24:18.351]                   muffleCondition(cond)
[10:24:18.351]                 })
[10:24:18.351]             }))
[10:24:18.351]             future::FutureResult(value = ...future.value$value, 
[10:24:18.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.351]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.351]                     ...future.globalenv.names))
[10:24:18.351]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.351]         }, condition = base::local({
[10:24:18.351]             c <- base::c
[10:24:18.351]             inherits <- base::inherits
[10:24:18.351]             invokeRestart <- base::invokeRestart
[10:24:18.351]             length <- base::length
[10:24:18.351]             list <- base::list
[10:24:18.351]             seq.int <- base::seq.int
[10:24:18.351]             signalCondition <- base::signalCondition
[10:24:18.351]             sys.calls <- base::sys.calls
[10:24:18.351]             `[[` <- base::`[[`
[10:24:18.351]             `+` <- base::`+`
[10:24:18.351]             `<<-` <- base::`<<-`
[10:24:18.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.351]                   3L)]
[10:24:18.351]             }
[10:24:18.351]             function(cond) {
[10:24:18.351]                 is_error <- inherits(cond, "error")
[10:24:18.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.351]                   NULL)
[10:24:18.351]                 if (is_error) {
[10:24:18.351]                   sessionInformation <- function() {
[10:24:18.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.351]                       search = base::search(), system = base::Sys.info())
[10:24:18.351]                   }
[10:24:18.351]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.351]                     cond$call), session = sessionInformation(), 
[10:24:18.351]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.351]                   signalCondition(cond)
[10:24:18.351]                 }
[10:24:18.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.351]                 "immediateCondition"))) {
[10:24:18.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.351]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.351]                   if (TRUE && !signal) {
[10:24:18.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.351]                     {
[10:24:18.351]                       inherits <- base::inherits
[10:24:18.351]                       invokeRestart <- base::invokeRestart
[10:24:18.351]                       is.null <- base::is.null
[10:24:18.351]                       muffled <- FALSE
[10:24:18.351]                       if (inherits(cond, "message")) {
[10:24:18.351]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.351]                         if (muffled) 
[10:24:18.351]                           invokeRestart("muffleMessage")
[10:24:18.351]                       }
[10:24:18.351]                       else if (inherits(cond, "warning")) {
[10:24:18.351]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.351]                         if (muffled) 
[10:24:18.351]                           invokeRestart("muffleWarning")
[10:24:18.351]                       }
[10:24:18.351]                       else if (inherits(cond, "condition")) {
[10:24:18.351]                         if (!is.null(pattern)) {
[10:24:18.351]                           computeRestarts <- base::computeRestarts
[10:24:18.351]                           grepl <- base::grepl
[10:24:18.351]                           restarts <- computeRestarts(cond)
[10:24:18.351]                           for (restart in restarts) {
[10:24:18.351]                             name <- restart$name
[10:24:18.351]                             if (is.null(name)) 
[10:24:18.351]                               next
[10:24:18.351]                             if (!grepl(pattern, name)) 
[10:24:18.351]                               next
[10:24:18.351]                             invokeRestart(restart)
[10:24:18.351]                             muffled <- TRUE
[10:24:18.351]                             break
[10:24:18.351]                           }
[10:24:18.351]                         }
[10:24:18.351]                       }
[10:24:18.351]                       invisible(muffled)
[10:24:18.351]                     }
[10:24:18.351]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.351]                   }
[10:24:18.351]                 }
[10:24:18.351]                 else {
[10:24:18.351]                   if (TRUE) {
[10:24:18.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.351]                     {
[10:24:18.351]                       inherits <- base::inherits
[10:24:18.351]                       invokeRestart <- base::invokeRestart
[10:24:18.351]                       is.null <- base::is.null
[10:24:18.351]                       muffled <- FALSE
[10:24:18.351]                       if (inherits(cond, "message")) {
[10:24:18.351]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.351]                         if (muffled) 
[10:24:18.351]                           invokeRestart("muffleMessage")
[10:24:18.351]                       }
[10:24:18.351]                       else if (inherits(cond, "warning")) {
[10:24:18.351]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.351]                         if (muffled) 
[10:24:18.351]                           invokeRestart("muffleWarning")
[10:24:18.351]                       }
[10:24:18.351]                       else if (inherits(cond, "condition")) {
[10:24:18.351]                         if (!is.null(pattern)) {
[10:24:18.351]                           computeRestarts <- base::computeRestarts
[10:24:18.351]                           grepl <- base::grepl
[10:24:18.351]                           restarts <- computeRestarts(cond)
[10:24:18.351]                           for (restart in restarts) {
[10:24:18.351]                             name <- restart$name
[10:24:18.351]                             if (is.null(name)) 
[10:24:18.351]                               next
[10:24:18.351]                             if (!grepl(pattern, name)) 
[10:24:18.351]                               next
[10:24:18.351]                             invokeRestart(restart)
[10:24:18.351]                             muffled <- TRUE
[10:24:18.351]                             break
[10:24:18.351]                           }
[10:24:18.351]                         }
[10:24:18.351]                       }
[10:24:18.351]                       invisible(muffled)
[10:24:18.351]                     }
[10:24:18.351]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.351]                   }
[10:24:18.351]                 }
[10:24:18.351]             }
[10:24:18.351]         }))
[10:24:18.351]     }, error = function(ex) {
[10:24:18.351]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.351]                 ...future.rng), started = ...future.startTime, 
[10:24:18.351]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.351]             version = "1.8"), class = "FutureResult")
[10:24:18.351]     }, finally = {
[10:24:18.351]         if (!identical(...future.workdir, getwd())) 
[10:24:18.351]             setwd(...future.workdir)
[10:24:18.351]         {
[10:24:18.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.351]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.351]             }
[10:24:18.351]             base::options(...future.oldOptions)
[10:24:18.351]             if (.Platform$OS.type == "windows") {
[10:24:18.351]                 old_names <- names(...future.oldEnvVars)
[10:24:18.351]                 envs <- base::Sys.getenv()
[10:24:18.351]                 names <- names(envs)
[10:24:18.351]                 common <- intersect(names, old_names)
[10:24:18.351]                 added <- setdiff(names, old_names)
[10:24:18.351]                 removed <- setdiff(old_names, names)
[10:24:18.351]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.351]                   envs[common]]
[10:24:18.351]                 NAMES <- toupper(changed)
[10:24:18.351]                 args <- list()
[10:24:18.351]                 for (kk in seq_along(NAMES)) {
[10:24:18.351]                   name <- changed[[kk]]
[10:24:18.351]                   NAME <- NAMES[[kk]]
[10:24:18.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.351]                     next
[10:24:18.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.351]                 }
[10:24:18.351]                 NAMES <- toupper(added)
[10:24:18.351]                 for (kk in seq_along(NAMES)) {
[10:24:18.351]                   name <- added[[kk]]
[10:24:18.351]                   NAME <- NAMES[[kk]]
[10:24:18.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.351]                     next
[10:24:18.351]                   args[[name]] <- ""
[10:24:18.351]                 }
[10:24:18.351]                 NAMES <- toupper(removed)
[10:24:18.351]                 for (kk in seq_along(NAMES)) {
[10:24:18.351]                   name <- removed[[kk]]
[10:24:18.351]                   NAME <- NAMES[[kk]]
[10:24:18.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.351]                     next
[10:24:18.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.351]                 }
[10:24:18.351]                 if (length(args) > 0) 
[10:24:18.351]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.351]             }
[10:24:18.351]             else {
[10:24:18.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.351]             }
[10:24:18.351]             {
[10:24:18.351]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.351]                   0L) {
[10:24:18.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.351]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.351]                   base::options(opts)
[10:24:18.351]                 }
[10:24:18.351]                 {
[10:24:18.351]                   {
[10:24:18.351]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.351]                     NULL
[10:24:18.351]                   }
[10:24:18.351]                   options(future.plan = NULL)
[10:24:18.351]                   if (is.na(NA_character_)) 
[10:24:18.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.351]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.351]                     envir = parent.frame()) 
[10:24:18.351]                   {
[10:24:18.351]                     default_workers <- missing(workers)
[10:24:18.351]                     if (is.function(workers)) 
[10:24:18.351]                       workers <- workers()
[10:24:18.351]                     workers <- structure(as.integer(workers), 
[10:24:18.351]                       class = class(workers))
[10:24:18.351]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.351]                       1L)
[10:24:18.351]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.351]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.351]                       if (default_workers) 
[10:24:18.351]                         supportsMulticore(warn = TRUE)
[10:24:18.351]                       return(sequential(..., envir = envir))
[10:24:18.351]                     }
[10:24:18.351]                     oopts <- options(mc.cores = workers)
[10:24:18.351]                     on.exit(options(oopts))
[10:24:18.351]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.351]                       envir = envir)
[10:24:18.351]                     if (!future$lazy) 
[10:24:18.351]                       future <- run(future)
[10:24:18.351]                     invisible(future)
[10:24:18.351]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.351]                 }
[10:24:18.351]             }
[10:24:18.351]         }
[10:24:18.351]     })
[10:24:18.351]     if (TRUE) {
[10:24:18.351]         base::sink(type = "output", split = FALSE)
[10:24:18.351]         if (TRUE) {
[10:24:18.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.351]         }
[10:24:18.351]         else {
[10:24:18.351]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.351]         }
[10:24:18.351]         base::close(...future.stdout)
[10:24:18.351]         ...future.stdout <- NULL
[10:24:18.351]     }
[10:24:18.351]     ...future.result$conditions <- ...future.conditions
[10:24:18.351]     ...future.result$finished <- base::Sys.time()
[10:24:18.351]     ...future.result
[10:24:18.351] }
[10:24:18.354] assign_globals() ...
[10:24:18.354] List of 11
[10:24:18.354]  $ ...future.FUN            :function (x, ...)  
[10:24:18.354]  $ x_FUN                    :function (x, na.rm = TRUE)  
[10:24:18.354]  $ times                    : int 5
[10:24:18.354]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.354]  $ stop_if_not              :function (...)  
[10:24:18.354]  $ dim                      : NULL
[10:24:18.354]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:18.354]  $ future.call.arguments    : list()
[10:24:18.354]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.354]  $ ...future.elements_ii    :List of 4
[10:24:18.354]   ..$ : int [1:3] 1 2 3
[10:24:18.354]   ..$ : int [1:4] 1 2 3 4
[10:24:18.354]   ..$ : int [1:5] 1 2 3 4 5
[10:24:18.354]   ..$ : int [1:6] 1 2 3 4 5 6
[10:24:18.354]  $ ...future.seeds_ii       : NULL
[10:24:18.354]  $ ...future.globals.maxSize: NULL
[10:24:18.354]  - attr(*, "where")=List of 11
[10:24:18.354]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.354]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:18.354]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:18.354]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:18.354]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:18.354]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:18.354]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:18.354]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.354]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.354]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.354]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.354]  - attr(*, "resolved")= logi FALSE
[10:24:18.354]  - attr(*, "total_size")= num 141240
[10:24:18.354]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.354]  - attr(*, "already-done")= logi TRUE
[10:24:18.363] - copied ‘...future.FUN’ to environment
[10:24:18.363] - copied ‘x_FUN’ to environment
[10:24:18.363] - copied ‘times’ to environment
[10:24:18.363] - copied ‘stopf’ to environment
[10:24:18.363] - copied ‘stop_if_not’ to environment
[10:24:18.364] - copied ‘dim’ to environment
[10:24:18.364] - copied ‘valid_types’ to environment
[10:24:18.364] - copied ‘future.call.arguments’ to environment
[10:24:18.364] - copied ‘...future.elements_ii’ to environment
[10:24:18.364] - copied ‘...future.seeds_ii’ to environment
[10:24:18.364] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.364] assign_globals() ... done
[10:24:18.364] requestCore(): workers = 2
[10:24:18.367] MulticoreFuture started
[10:24:18.367] - Launch lazy future ... done
[10:24:18.367] run() for ‘MulticoreFuture’ ... done
[10:24:18.368] Created future:
[10:24:18.368] plan(): Setting new future strategy stack:
[10:24:18.369] List of future strategies:
[10:24:18.369] 1. sequential:
[10:24:18.369]    - args: function (..., envir = parent.frame())
[10:24:18.369]    - tweaked: FALSE
[10:24:18.369]    - call: NULL
[10:24:18.369] plan(): nbrOfWorkers() = 1
[10:24:18.372] plan(): Setting new future strategy stack:
[10:24:18.372] List of future strategies:
[10:24:18.372] 1. multicore:
[10:24:18.372]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.372]    - tweaked: FALSE
[10:24:18.372]    - call: plan(strategy)
[10:24:18.377] plan(): nbrOfWorkers() = 2
[10:24:18.368] MulticoreFuture:
[10:24:18.368] Label: ‘future_vapply-1’
[10:24:18.368] Expression:
[10:24:18.368] {
[10:24:18.368]     do.call(function(...) {
[10:24:18.368]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.368]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.368]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.368]             on.exit(options(oopts), add = TRUE)
[10:24:18.368]         }
[10:24:18.368]         {
[10:24:18.368]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.368]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.368]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.368]             })
[10:24:18.368]         }
[10:24:18.368]     }, args = future.call.arguments)
[10:24:18.368] }
[10:24:18.368] Lazy evaluation: FALSE
[10:24:18.368] Asynchronous evaluation: TRUE
[10:24:18.368] Local evaluation: TRUE
[10:24:18.368] Environment: R_GlobalEnv
[10:24:18.368] Capture standard output: TRUE
[10:24:18.368] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.368] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:18.368] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:24:18.368] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.368] Resolved: TRUE
[10:24:18.368] Value: <not collected>
[10:24:18.368] Conditions captured: <none>
[10:24:18.368] Early signaling: FALSE
[10:24:18.368] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.368] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.378] Chunk #1 of 2 ... DONE
[10:24:18.378] Chunk #2 of 2 ...
[10:24:18.379]  - Finding globals in 'X' for chunk #2 ...
[10:24:18.379] getGlobalsAndPackages() ...
[10:24:18.379] Searching for globals...
[10:24:18.379] 
[10:24:18.380] Searching for globals ... DONE
[10:24:18.380] - globals: [0] <none>
[10:24:18.380] getGlobalsAndPackages() ... DONE
[10:24:18.380]    + additional globals found: [n=0] 
[10:24:18.380]    + additional namespaces needed: [n=0] 
[10:24:18.380]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:18.380]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.381]  - seeds: <none>
[10:24:18.381]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.381] getGlobalsAndPackages() ...
[10:24:18.381] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.381] Resolving globals: FALSE
[10:24:18.381] Tweak future expression to call with '...' arguments ...
[10:24:18.382] {
[10:24:18.382]     do.call(function(...) {
[10:24:18.382]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.382]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.382]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.382]             on.exit(options(oopts), add = TRUE)
[10:24:18.382]         }
[10:24:18.382]         {
[10:24:18.382]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.382]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.382]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.382]             })
[10:24:18.382]         }
[10:24:18.382]     }, args = future.call.arguments)
[10:24:18.382] }
[10:24:18.382] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.383] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.383] - packages: [2] ‘stats’, ‘future.apply’
[10:24:18.383] getGlobalsAndPackages() ... DONE
[10:24:18.388] run() for ‘Future’ ...
[10:24:18.388] - state: ‘created’
[10:24:18.388] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.395] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.395] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.396]   - Field: ‘label’
[10:24:18.396]   - Field: ‘local’
[10:24:18.396]   - Field: ‘owner’
[10:24:18.397]   - Field: ‘envir’
[10:24:18.397]   - Field: ‘workers’
[10:24:18.397]   - Field: ‘packages’
[10:24:18.397]   - Field: ‘gc’
[10:24:18.397]   - Field: ‘job’
[10:24:18.398]   - Field: ‘conditions’
[10:24:18.398]   - Field: ‘expr’
[10:24:18.398]   - Field: ‘uuid’
[10:24:18.398]   - Field: ‘seed’
[10:24:18.398]   - Field: ‘version’
[10:24:18.399]   - Field: ‘result’
[10:24:18.399]   - Field: ‘asynchronous’
[10:24:18.399]   - Field: ‘calls’
[10:24:18.399]   - Field: ‘globals’
[10:24:18.400]   - Field: ‘stdout’
[10:24:18.400]   - Field: ‘earlySignal’
[10:24:18.400]   - Field: ‘lazy’
[10:24:18.400]   - Field: ‘state’
[10:24:18.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.401] - Launch lazy future ...
[10:24:18.401] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:24:18.401] Packages needed by future strategies (n = 0): <none>
[10:24:18.402] {
[10:24:18.402]     {
[10:24:18.402]         {
[10:24:18.402]             ...future.startTime <- base::Sys.time()
[10:24:18.402]             {
[10:24:18.402]                 {
[10:24:18.402]                   {
[10:24:18.402]                     {
[10:24:18.402]                       {
[10:24:18.402]                         base::local({
[10:24:18.402]                           has_future <- base::requireNamespace("future", 
[10:24:18.402]                             quietly = TRUE)
[10:24:18.402]                           if (has_future) {
[10:24:18.402]                             ns <- base::getNamespace("future")
[10:24:18.402]                             version <- ns[[".package"]][["version"]]
[10:24:18.402]                             if (is.null(version)) 
[10:24:18.402]                               version <- utils::packageVersion("future")
[10:24:18.402]                           }
[10:24:18.402]                           else {
[10:24:18.402]                             version <- NULL
[10:24:18.402]                           }
[10:24:18.402]                           if (!has_future || version < "1.8.0") {
[10:24:18.402]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.402]                               "", base::R.version$version.string), 
[10:24:18.402]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.402]                                 base::R.version$platform, 8 * 
[10:24:18.402]                                   base::.Machine$sizeof.pointer), 
[10:24:18.402]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.402]                                 "release", "version")], collapse = " "), 
[10:24:18.402]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.402]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.402]                               info)
[10:24:18.402]                             info <- base::paste(info, collapse = "; ")
[10:24:18.402]                             if (!has_future) {
[10:24:18.402]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.402]                                 info)
[10:24:18.402]                             }
[10:24:18.402]                             else {
[10:24:18.402]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.402]                                 info, version)
[10:24:18.402]                             }
[10:24:18.402]                             base::stop(msg)
[10:24:18.402]                           }
[10:24:18.402]                         })
[10:24:18.402]                       }
[10:24:18.402]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.402]                       base::options(mc.cores = 1L)
[10:24:18.402]                     }
[10:24:18.402]                     base::local({
[10:24:18.402]                       for (pkg in c("stats", "future.apply")) {
[10:24:18.402]                         base::loadNamespace(pkg)
[10:24:18.402]                         base::library(pkg, character.only = TRUE)
[10:24:18.402]                       }
[10:24:18.402]                     })
[10:24:18.402]                   }
[10:24:18.402]                   options(future.plan = NULL)
[10:24:18.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.402]                 }
[10:24:18.402]                 ...future.workdir <- getwd()
[10:24:18.402]             }
[10:24:18.402]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.402]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.402]         }
[10:24:18.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.402]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.402]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.402]             base::names(...future.oldOptions))
[10:24:18.402]     }
[10:24:18.402]     if (FALSE) {
[10:24:18.402]     }
[10:24:18.402]     else {
[10:24:18.402]         if (TRUE) {
[10:24:18.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.402]                 open = "w")
[10:24:18.402]         }
[10:24:18.402]         else {
[10:24:18.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.402]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.402]         }
[10:24:18.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.402]             base::sink(type = "output", split = FALSE)
[10:24:18.402]             base::close(...future.stdout)
[10:24:18.402]         }, add = TRUE)
[10:24:18.402]     }
[10:24:18.402]     ...future.frame <- base::sys.nframe()
[10:24:18.402]     ...future.conditions <- base::list()
[10:24:18.402]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.402]     if (FALSE) {
[10:24:18.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.402]     }
[10:24:18.402]     ...future.result <- base::tryCatch({
[10:24:18.402]         base::withCallingHandlers({
[10:24:18.402]             ...future.value <- base::withVisible(base::local({
[10:24:18.402]                 withCallingHandlers({
[10:24:18.402]                   {
[10:24:18.402]                     do.call(function(...) {
[10:24:18.402]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.402]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.402]                         ...future.globals.maxSize)) {
[10:24:18.402]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.402]                         on.exit(options(oopts), add = TRUE)
[10:24:18.402]                       }
[10:24:18.402]                       {
[10:24:18.402]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.402]                           FUN = function(jj) {
[10:24:18.402]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.402]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.402]                           })
[10:24:18.402]                       }
[10:24:18.402]                     }, args = future.call.arguments)
[10:24:18.402]                   }
[10:24:18.402]                 }, immediateCondition = function(cond) {
[10:24:18.402]                   save_rds <- function (object, pathname, ...) 
[10:24:18.402]                   {
[10:24:18.402]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.402]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.402]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.402]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.402]                         fi_tmp[["mtime"]])
[10:24:18.402]                     }
[10:24:18.402]                     tryCatch({
[10:24:18.402]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.402]                     }, error = function(ex) {
[10:24:18.402]                       msg <- conditionMessage(ex)
[10:24:18.402]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.402]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.402]                         fi_tmp[["mtime"]], msg)
[10:24:18.402]                       ex$message <- msg
[10:24:18.402]                       stop(ex)
[10:24:18.402]                     })
[10:24:18.402]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.402]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.402]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.402]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.402]                       fi <- file.info(pathname)
[10:24:18.402]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.402]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.402]                         fi[["size"]], fi[["mtime"]])
[10:24:18.402]                       stop(msg)
[10:24:18.402]                     }
[10:24:18.402]                     invisible(pathname)
[10:24:18.402]                   }
[10:24:18.402]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.402]                     rootPath = tempdir()) 
[10:24:18.402]                   {
[10:24:18.402]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.402]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.402]                       tmpdir = path, fileext = ".rds")
[10:24:18.402]                     save_rds(obj, file)
[10:24:18.402]                   }
[10:24:18.402]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.402]                   {
[10:24:18.402]                     inherits <- base::inherits
[10:24:18.402]                     invokeRestart <- base::invokeRestart
[10:24:18.402]                     is.null <- base::is.null
[10:24:18.402]                     muffled <- FALSE
[10:24:18.402]                     if (inherits(cond, "message")) {
[10:24:18.402]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.402]                       if (muffled) 
[10:24:18.402]                         invokeRestart("muffleMessage")
[10:24:18.402]                     }
[10:24:18.402]                     else if (inherits(cond, "warning")) {
[10:24:18.402]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.402]                       if (muffled) 
[10:24:18.402]                         invokeRestart("muffleWarning")
[10:24:18.402]                     }
[10:24:18.402]                     else if (inherits(cond, "condition")) {
[10:24:18.402]                       if (!is.null(pattern)) {
[10:24:18.402]                         computeRestarts <- base::computeRestarts
[10:24:18.402]                         grepl <- base::grepl
[10:24:18.402]                         restarts <- computeRestarts(cond)
[10:24:18.402]                         for (restart in restarts) {
[10:24:18.402]                           name <- restart$name
[10:24:18.402]                           if (is.null(name)) 
[10:24:18.402]                             next
[10:24:18.402]                           if (!grepl(pattern, name)) 
[10:24:18.402]                             next
[10:24:18.402]                           invokeRestart(restart)
[10:24:18.402]                           muffled <- TRUE
[10:24:18.402]                           break
[10:24:18.402]                         }
[10:24:18.402]                       }
[10:24:18.402]                     }
[10:24:18.402]                     invisible(muffled)
[10:24:18.402]                   }
[10:24:18.402]                   muffleCondition(cond)
[10:24:18.402]                 })
[10:24:18.402]             }))
[10:24:18.402]             future::FutureResult(value = ...future.value$value, 
[10:24:18.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.402]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.402]                     ...future.globalenv.names))
[10:24:18.402]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.402]         }, condition = base::local({
[10:24:18.402]             c <- base::c
[10:24:18.402]             inherits <- base::inherits
[10:24:18.402]             invokeRestart <- base::invokeRestart
[10:24:18.402]             length <- base::length
[10:24:18.402]             list <- base::list
[10:24:18.402]             seq.int <- base::seq.int
[10:24:18.402]             signalCondition <- base::signalCondition
[10:24:18.402]             sys.calls <- base::sys.calls
[10:24:18.402]             `[[` <- base::`[[`
[10:24:18.402]             `+` <- base::`+`
[10:24:18.402]             `<<-` <- base::`<<-`
[10:24:18.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.402]                   3L)]
[10:24:18.402]             }
[10:24:18.402]             function(cond) {
[10:24:18.402]                 is_error <- inherits(cond, "error")
[10:24:18.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.402]                   NULL)
[10:24:18.402]                 if (is_error) {
[10:24:18.402]                   sessionInformation <- function() {
[10:24:18.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.402]                       search = base::search(), system = base::Sys.info())
[10:24:18.402]                   }
[10:24:18.402]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.402]                     cond$call), session = sessionInformation(), 
[10:24:18.402]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.402]                   signalCondition(cond)
[10:24:18.402]                 }
[10:24:18.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.402]                 "immediateCondition"))) {
[10:24:18.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.402]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.402]                   if (TRUE && !signal) {
[10:24:18.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.402]                     {
[10:24:18.402]                       inherits <- base::inherits
[10:24:18.402]                       invokeRestart <- base::invokeRestart
[10:24:18.402]                       is.null <- base::is.null
[10:24:18.402]                       muffled <- FALSE
[10:24:18.402]                       if (inherits(cond, "message")) {
[10:24:18.402]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.402]                         if (muffled) 
[10:24:18.402]                           invokeRestart("muffleMessage")
[10:24:18.402]                       }
[10:24:18.402]                       else if (inherits(cond, "warning")) {
[10:24:18.402]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.402]                         if (muffled) 
[10:24:18.402]                           invokeRestart("muffleWarning")
[10:24:18.402]                       }
[10:24:18.402]                       else if (inherits(cond, "condition")) {
[10:24:18.402]                         if (!is.null(pattern)) {
[10:24:18.402]                           computeRestarts <- base::computeRestarts
[10:24:18.402]                           grepl <- base::grepl
[10:24:18.402]                           restarts <- computeRestarts(cond)
[10:24:18.402]                           for (restart in restarts) {
[10:24:18.402]                             name <- restart$name
[10:24:18.402]                             if (is.null(name)) 
[10:24:18.402]                               next
[10:24:18.402]                             if (!grepl(pattern, name)) 
[10:24:18.402]                               next
[10:24:18.402]                             invokeRestart(restart)
[10:24:18.402]                             muffled <- TRUE
[10:24:18.402]                             break
[10:24:18.402]                           }
[10:24:18.402]                         }
[10:24:18.402]                       }
[10:24:18.402]                       invisible(muffled)
[10:24:18.402]                     }
[10:24:18.402]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.402]                   }
[10:24:18.402]                 }
[10:24:18.402]                 else {
[10:24:18.402]                   if (TRUE) {
[10:24:18.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.402]                     {
[10:24:18.402]                       inherits <- base::inherits
[10:24:18.402]                       invokeRestart <- base::invokeRestart
[10:24:18.402]                       is.null <- base::is.null
[10:24:18.402]                       muffled <- FALSE
[10:24:18.402]                       if (inherits(cond, "message")) {
[10:24:18.402]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.402]                         if (muffled) 
[10:24:18.402]                           invokeRestart("muffleMessage")
[10:24:18.402]                       }
[10:24:18.402]                       else if (inherits(cond, "warning")) {
[10:24:18.402]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.402]                         if (muffled) 
[10:24:18.402]                           invokeRestart("muffleWarning")
[10:24:18.402]                       }
[10:24:18.402]                       else if (inherits(cond, "condition")) {
[10:24:18.402]                         if (!is.null(pattern)) {
[10:24:18.402]                           computeRestarts <- base::computeRestarts
[10:24:18.402]                           grepl <- base::grepl
[10:24:18.402]                           restarts <- computeRestarts(cond)
[10:24:18.402]                           for (restart in restarts) {
[10:24:18.402]                             name <- restart$name
[10:24:18.402]                             if (is.null(name)) 
[10:24:18.402]                               next
[10:24:18.402]                             if (!grepl(pattern, name)) 
[10:24:18.402]                               next
[10:24:18.402]                             invokeRestart(restart)
[10:24:18.402]                             muffled <- TRUE
[10:24:18.402]                             break
[10:24:18.402]                           }
[10:24:18.402]                         }
[10:24:18.402]                       }
[10:24:18.402]                       invisible(muffled)
[10:24:18.402]                     }
[10:24:18.402]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.402]                   }
[10:24:18.402]                 }
[10:24:18.402]             }
[10:24:18.402]         }))
[10:24:18.402]     }, error = function(ex) {
[10:24:18.402]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.402]                 ...future.rng), started = ...future.startTime, 
[10:24:18.402]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.402]             version = "1.8"), class = "FutureResult")
[10:24:18.402]     }, finally = {
[10:24:18.402]         if (!identical(...future.workdir, getwd())) 
[10:24:18.402]             setwd(...future.workdir)
[10:24:18.402]         {
[10:24:18.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.402]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.402]             }
[10:24:18.402]             base::options(...future.oldOptions)
[10:24:18.402]             if (.Platform$OS.type == "windows") {
[10:24:18.402]                 old_names <- names(...future.oldEnvVars)
[10:24:18.402]                 envs <- base::Sys.getenv()
[10:24:18.402]                 names <- names(envs)
[10:24:18.402]                 common <- intersect(names, old_names)
[10:24:18.402]                 added <- setdiff(names, old_names)
[10:24:18.402]                 removed <- setdiff(old_names, names)
[10:24:18.402]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.402]                   envs[common]]
[10:24:18.402]                 NAMES <- toupper(changed)
[10:24:18.402]                 args <- list()
[10:24:18.402]                 for (kk in seq_along(NAMES)) {
[10:24:18.402]                   name <- changed[[kk]]
[10:24:18.402]                   NAME <- NAMES[[kk]]
[10:24:18.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.402]                     next
[10:24:18.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.402]                 }
[10:24:18.402]                 NAMES <- toupper(added)
[10:24:18.402]                 for (kk in seq_along(NAMES)) {
[10:24:18.402]                   name <- added[[kk]]
[10:24:18.402]                   NAME <- NAMES[[kk]]
[10:24:18.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.402]                     next
[10:24:18.402]                   args[[name]] <- ""
[10:24:18.402]                 }
[10:24:18.402]                 NAMES <- toupper(removed)
[10:24:18.402]                 for (kk in seq_along(NAMES)) {
[10:24:18.402]                   name <- removed[[kk]]
[10:24:18.402]                   NAME <- NAMES[[kk]]
[10:24:18.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.402]                     next
[10:24:18.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.402]                 }
[10:24:18.402]                 if (length(args) > 0) 
[10:24:18.402]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.402]             }
[10:24:18.402]             else {
[10:24:18.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.402]             }
[10:24:18.402]             {
[10:24:18.402]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.402]                   0L) {
[10:24:18.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.402]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.402]                   base::options(opts)
[10:24:18.402]                 }
[10:24:18.402]                 {
[10:24:18.402]                   {
[10:24:18.402]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.402]                     NULL
[10:24:18.402]                   }
[10:24:18.402]                   options(future.plan = NULL)
[10:24:18.402]                   if (is.na(NA_character_)) 
[10:24:18.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.402]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.402]                     envir = parent.frame()) 
[10:24:18.402]                   {
[10:24:18.402]                     default_workers <- missing(workers)
[10:24:18.402]                     if (is.function(workers)) 
[10:24:18.402]                       workers <- workers()
[10:24:18.402]                     workers <- structure(as.integer(workers), 
[10:24:18.402]                       class = class(workers))
[10:24:18.402]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.402]                       1L)
[10:24:18.402]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.402]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.402]                       if (default_workers) 
[10:24:18.402]                         supportsMulticore(warn = TRUE)
[10:24:18.402]                       return(sequential(..., envir = envir))
[10:24:18.402]                     }
[10:24:18.402]                     oopts <- options(mc.cores = workers)
[10:24:18.402]                     on.exit(options(oopts))
[10:24:18.402]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.402]                       envir = envir)
[10:24:18.402]                     if (!future$lazy) 
[10:24:18.402]                       future <- run(future)
[10:24:18.402]                     invisible(future)
[10:24:18.402]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.402]                 }
[10:24:18.402]             }
[10:24:18.402]         }
[10:24:18.402]     })
[10:24:18.402]     if (TRUE) {
[10:24:18.402]         base::sink(type = "output", split = FALSE)
[10:24:18.402]         if (TRUE) {
[10:24:18.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.402]         }
[10:24:18.402]         else {
[10:24:18.402]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.402]         }
[10:24:18.402]         base::close(...future.stdout)
[10:24:18.402]         ...future.stdout <- NULL
[10:24:18.402]     }
[10:24:18.402]     ...future.result$conditions <- ...future.conditions
[10:24:18.402]     ...future.result$finished <- base::Sys.time()
[10:24:18.402]     ...future.result
[10:24:18.402] }
[10:24:18.405] assign_globals() ...
[10:24:18.405] List of 11
[10:24:18.405]  $ ...future.FUN            :function (x, ...)  
[10:24:18.405]  $ x_FUN                    :function (x, na.rm = TRUE)  
[10:24:18.405]  $ times                    : int 5
[10:24:18.405]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.405]  $ stop_if_not              :function (...)  
[10:24:18.405]  $ dim                      : NULL
[10:24:18.405]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:18.405]  $ future.call.arguments    : list()
[10:24:18.405]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.405]  $ ...future.elements_ii    :List of 3
[10:24:18.405]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:24:18.405]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:24:18.405]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:24:18.405]  $ ...future.seeds_ii       : NULL
[10:24:18.405]  $ ...future.globals.maxSize: NULL
[10:24:18.405]  - attr(*, "where")=List of 11
[10:24:18.405]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.405]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:18.405]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:18.405]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:18.405]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:18.405]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:18.405]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:18.405]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.405]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.405]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.405]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.405]  - attr(*, "resolved")= logi FALSE
[10:24:18.405]  - attr(*, "total_size")= num 141240
[10:24:18.405]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.405]  - attr(*, "already-done")= logi TRUE
[10:24:18.416] - copied ‘...future.FUN’ to environment
[10:24:18.416] - copied ‘x_FUN’ to environment
[10:24:18.416] - copied ‘times’ to environment
[10:24:18.416] - copied ‘stopf’ to environment
[10:24:18.416] - copied ‘stop_if_not’ to environment
[10:24:18.417] - copied ‘dim’ to environment
[10:24:18.417] - copied ‘valid_types’ to environment
[10:24:18.417] - copied ‘future.call.arguments’ to environment
[10:24:18.417] - copied ‘...future.elements_ii’ to environment
[10:24:18.417] - copied ‘...future.seeds_ii’ to environment
[10:24:18.417] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.417] assign_globals() ... done
[10:24:18.417] requestCore(): workers = 2
[10:24:18.420] MulticoreFuture started
[10:24:18.420] - Launch lazy future ... done
[10:24:18.420] run() for ‘MulticoreFuture’ ... done
[10:24:18.420] Created future:
[10:24:18.421] plan(): Setting new future strategy stack:
[10:24:18.422] List of future strategies:
[10:24:18.422] 1. sequential:
[10:24:18.422]    - args: function (..., envir = parent.frame())
[10:24:18.422]    - tweaked: FALSE
[10:24:18.422]    - call: NULL
[10:24:18.422] plan(): nbrOfWorkers() = 1
[10:24:18.432] plan(): Setting new future strategy stack:
[10:24:18.432] List of future strategies:
[10:24:18.432] 1. multicore:
[10:24:18.432]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.432]    - tweaked: FALSE
[10:24:18.432]    - call: plan(strategy)
[10:24:18.438] plan(): nbrOfWorkers() = 2
[10:24:18.421] MulticoreFuture:
[10:24:18.421] Label: ‘future_vapply-2’
[10:24:18.421] Expression:
[10:24:18.421] {
[10:24:18.421]     do.call(function(...) {
[10:24:18.421]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.421]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.421]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.421]             on.exit(options(oopts), add = TRUE)
[10:24:18.421]         }
[10:24:18.421]         {
[10:24:18.421]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.421]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.421]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.421]             })
[10:24:18.421]         }
[10:24:18.421]     }, args = future.call.arguments)
[10:24:18.421] }
[10:24:18.421] Lazy evaluation: FALSE
[10:24:18.421] Asynchronous evaluation: TRUE
[10:24:18.421] Local evaluation: TRUE
[10:24:18.421] Environment: R_GlobalEnv
[10:24:18.421] Capture standard output: TRUE
[10:24:18.421] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.421] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:18.421] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:24:18.421] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.421] Resolved: TRUE
[10:24:18.421] Value: <not collected>
[10:24:18.421] Conditions captured: <none>
[10:24:18.421] Early signaling: FALSE
[10:24:18.421] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.421] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.439] Chunk #2 of 2 ... DONE
[10:24:18.439] Launching 2 futures (chunks) ... DONE
[10:24:18.439] Resolving 2 futures (chunks) ...
[10:24:18.439] resolve() on list ...
[10:24:18.439]  recursive: 0
[10:24:18.439]  length: 2
[10:24:18.439] 
[10:24:18.440] Future #1
[10:24:18.440] result() for MulticoreFuture ...
[10:24:18.441] result() for MulticoreFuture ...
[10:24:18.441] result() for MulticoreFuture ... done
[10:24:18.441] result() for MulticoreFuture ... done
[10:24:18.441] result() for MulticoreFuture ...
[10:24:18.442] result() for MulticoreFuture ... done
[10:24:18.442] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:18.442] - nx: 2
[10:24:18.442] - relay: TRUE
[10:24:18.443] - stdout: TRUE
[10:24:18.443] - signal: TRUE
[10:24:18.443] - resignal: FALSE
[10:24:18.443] - force: TRUE
[10:24:18.443] - relayed: [n=2] FALSE, FALSE
[10:24:18.444] - queued futures: [n=2] FALSE, FALSE
[10:24:18.444]  - until=1
[10:24:18.444]  - relaying element #1
[10:24:18.444] result() for MulticoreFuture ...
[10:24:18.445] result() for MulticoreFuture ... done
[10:24:18.445] result() for MulticoreFuture ...
[10:24:18.445] result() for MulticoreFuture ... done
[10:24:18.445] result() for MulticoreFuture ...
[10:24:18.446] result() for MulticoreFuture ... done
[10:24:18.446] result() for MulticoreFuture ...
[10:24:18.446] result() for MulticoreFuture ... done
[10:24:18.446] - relayed: [n=2] TRUE, FALSE
[10:24:18.446] - queued futures: [n=2] TRUE, FALSE
[10:24:18.447] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:18.447]  length: 1 (resolved future 1)
[10:24:18.447] Future #2
[10:24:18.447] result() for MulticoreFuture ...
[10:24:18.448] result() for MulticoreFuture ...
[10:24:18.449] result() for MulticoreFuture ... done
[10:24:18.449] result() for MulticoreFuture ... done
[10:24:18.449] result() for MulticoreFuture ...
[10:24:18.449] result() for MulticoreFuture ... done
[10:24:18.449] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:18.449] - nx: 2
[10:24:18.450] - relay: TRUE
[10:24:18.450] - stdout: TRUE
[10:24:18.450] - signal: TRUE
[10:24:18.450] - resignal: FALSE
[10:24:18.450] - force: TRUE
[10:24:18.450] - relayed: [n=2] TRUE, FALSE
[10:24:18.450] - queued futures: [n=2] TRUE, FALSE
[10:24:18.451]  - until=2
[10:24:18.451]  - relaying element #2
[10:24:18.451] result() for MulticoreFuture ...
[10:24:18.451] result() for MulticoreFuture ... done
[10:24:18.451] result() for MulticoreFuture ...
[10:24:18.451] result() for MulticoreFuture ... done
[10:24:18.451] result() for MulticoreFuture ...
[10:24:18.451] result() for MulticoreFuture ... done
[10:24:18.452] result() for MulticoreFuture ...
[10:24:18.452] result() for MulticoreFuture ... done
[10:24:18.452] - relayed: [n=2] TRUE, TRUE
[10:24:18.452] - queued futures: [n=2] TRUE, TRUE
[10:24:18.452] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:18.452]  length: 0 (resolved future 2)
[10:24:18.452] Relaying remaining futures
[10:24:18.452] signalConditionsASAP(NULL, pos=0) ...
[10:24:18.452] - nx: 2
[10:24:18.453] - relay: TRUE
[10:24:18.453] - stdout: TRUE
[10:24:18.453] - signal: TRUE
[10:24:18.453] - resignal: FALSE
[10:24:18.453] - force: TRUE
[10:24:18.453] - relayed: [n=2] TRUE, TRUE
[10:24:18.453] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:18.453] - relayed: [n=2] TRUE, TRUE
[10:24:18.453] - queued futures: [n=2] TRUE, TRUE
[10:24:18.454] signalConditionsASAP(NULL, pos=0) ... done
[10:24:18.454] resolve() on list ... DONE
[10:24:18.454] result() for MulticoreFuture ...
[10:24:18.454] result() for MulticoreFuture ... done
[10:24:18.454] result() for MulticoreFuture ...
[10:24:18.454] result() for MulticoreFuture ... done
[10:24:18.454] result() for MulticoreFuture ...
[10:24:18.454] result() for MulticoreFuture ... done
[10:24:18.454] result() for MulticoreFuture ...
[10:24:18.455] result() for MulticoreFuture ... done
[10:24:18.455]  - Number of value chunks collected: 2
[10:24:18.455] Resolving 2 futures (chunks) ... DONE
[10:24:18.455] Reducing values from 2 chunks ...
[10:24:18.455]  - Number of values collected after concatenation: 7
[10:24:18.455]  - Number of values expected: 7
[10:24:18.455] Reducing values from 2 chunks ... DONE
[10:24:18.455] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[10:24:18.457] future_lapply() ...
[10:24:18.462] Number of chunks: 2
[10:24:18.462] getGlobalsAndPackagesXApply() ...
[10:24:18.462]  - future.globals: TRUE
[10:24:18.462] getGlobalsAndPackages() ...
[10:24:18.462] Searching for globals...
[10:24:18.464] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[10:24:18.464] Searching for globals ... DONE
[10:24:18.464] Resolving globals: FALSE
[10:24:18.464] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[10:24:18.465] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[10:24:18.465] - globals: [1] ‘FUN’
[10:24:18.465] 
[10:24:18.465] getGlobalsAndPackages() ... DONE
[10:24:18.465]  - globals found/used: [n=1] ‘FUN’
[10:24:18.465]  - needed namespaces: [n=0] 
[10:24:18.465] Finding globals ... DONE
[10:24:18.466]  - use_args: TRUE
[10:24:18.466]  - Getting '...' globals ...
[10:24:18.466] resolve() on list ...
[10:24:18.466]  recursive: 0
[10:24:18.466]  length: 1
[10:24:18.466]  elements: ‘...’
[10:24:18.466]  length: 0 (resolved future 1)
[10:24:18.466] resolve() on list ... DONE
[10:24:18.467]    - '...' content: [n=1] ‘y’
[10:24:18.467] List of 1
[10:24:18.467]  $ ...:List of 1
[10:24:18.467]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:18.467]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.467]  - attr(*, "where")=List of 1
[10:24:18.467]   ..$ ...:<environment: 0x55b93b6ccba8> 
[10:24:18.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.467]  - attr(*, "resolved")= logi TRUE
[10:24:18.467]  - attr(*, "total_size")= num NA
[10:24:18.472]  - Getting '...' globals ... DONE
[10:24:18.472] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:18.473] List of 2
[10:24:18.473]  $ ...future.FUN:function (x, y)  
[10:24:18.473]  $ ...          :List of 1
[10:24:18.473]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:18.473]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.473]  - attr(*, "where")=List of 2
[10:24:18.473]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:18.473]   ..$ ...          :<environment: 0x55b93b6ccba8> 
[10:24:18.473]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.473]  - attr(*, "resolved")= logi FALSE
[10:24:18.473]  - attr(*, "total_size")= num 4264
[10:24:18.476] Packages to be attached in all futures: [n=0] 
[10:24:18.476] getGlobalsAndPackagesXApply() ... DONE
[10:24:18.477] Number of futures (= number of chunks): 2
[10:24:18.477] Launching 2 futures (chunks) ...
[10:24:18.477] Chunk #1 of 2 ...
[10:24:18.477]  - Finding globals in 'X' for chunk #1 ...
[10:24:18.477] getGlobalsAndPackages() ...
[10:24:18.477] Searching for globals...
[10:24:18.477] 
[10:24:18.478] Searching for globals ... DONE
[10:24:18.478] - globals: [0] <none>
[10:24:18.478] getGlobalsAndPackages() ... DONE
[10:24:18.478]    + additional globals found: [n=0] 
[10:24:18.478]    + additional namespaces needed: [n=0] 
[10:24:18.478]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:18.478]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.478]  - seeds: <none>
[10:24:18.478]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.478] getGlobalsAndPackages() ...
[10:24:18.478] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.479] Resolving globals: FALSE
[10:24:18.479] Tweak future expression to call with '...' arguments ...
[10:24:18.479] {
[10:24:18.479]     do.call(function(...) {
[10:24:18.479]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.479]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.479]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.479]             on.exit(options(oopts), add = TRUE)
[10:24:18.479]         }
[10:24:18.479]         {
[10:24:18.479]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.479]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.479]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.479]             })
[10:24:18.479]         }
[10:24:18.479]     }, args = future.call.arguments)
[10:24:18.479] }
[10:24:18.479] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.479] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.480] 
[10:24:18.480] getGlobalsAndPackages() ... DONE
[10:24:18.480] run() for ‘Future’ ...
[10:24:18.480] - state: ‘created’
[10:24:18.480] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.484] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.484]   - Field: ‘label’
[10:24:18.485]   - Field: ‘local’
[10:24:18.485]   - Field: ‘owner’
[10:24:18.485]   - Field: ‘envir’
[10:24:18.485]   - Field: ‘workers’
[10:24:18.485]   - Field: ‘packages’
[10:24:18.485]   - Field: ‘gc’
[10:24:18.485]   - Field: ‘job’
[10:24:18.486]   - Field: ‘conditions’
[10:24:18.486]   - Field: ‘expr’
[10:24:18.486]   - Field: ‘uuid’
[10:24:18.486]   - Field: ‘seed’
[10:24:18.486]   - Field: ‘version’
[10:24:18.486]   - Field: ‘result’
[10:24:18.486]   - Field: ‘asynchronous’
[10:24:18.486]   - Field: ‘calls’
[10:24:18.486]   - Field: ‘globals’
[10:24:18.486]   - Field: ‘stdout’
[10:24:18.487]   - Field: ‘earlySignal’
[10:24:18.487]   - Field: ‘lazy’
[10:24:18.487]   - Field: ‘state’
[10:24:18.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.487] - Launch lazy future ...
[10:24:18.487] Packages needed by the future expression (n = 0): <none>
[10:24:18.487] Packages needed by future strategies (n = 0): <none>
[10:24:18.488] {
[10:24:18.488]     {
[10:24:18.488]         {
[10:24:18.488]             ...future.startTime <- base::Sys.time()
[10:24:18.488]             {
[10:24:18.488]                 {
[10:24:18.488]                   {
[10:24:18.488]                     {
[10:24:18.488]                       base::local({
[10:24:18.488]                         has_future <- base::requireNamespace("future", 
[10:24:18.488]                           quietly = TRUE)
[10:24:18.488]                         if (has_future) {
[10:24:18.488]                           ns <- base::getNamespace("future")
[10:24:18.488]                           version <- ns[[".package"]][["version"]]
[10:24:18.488]                           if (is.null(version)) 
[10:24:18.488]                             version <- utils::packageVersion("future")
[10:24:18.488]                         }
[10:24:18.488]                         else {
[10:24:18.488]                           version <- NULL
[10:24:18.488]                         }
[10:24:18.488]                         if (!has_future || version < "1.8.0") {
[10:24:18.488]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.488]                             "", base::R.version$version.string), 
[10:24:18.488]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:18.488]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:18.488]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.488]                               "release", "version")], collapse = " "), 
[10:24:18.488]                             hostname = base::Sys.info()[["nodename"]])
[10:24:18.488]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.488]                             info)
[10:24:18.488]                           info <- base::paste(info, collapse = "; ")
[10:24:18.488]                           if (!has_future) {
[10:24:18.488]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.488]                               info)
[10:24:18.488]                           }
[10:24:18.488]                           else {
[10:24:18.488]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.488]                               info, version)
[10:24:18.488]                           }
[10:24:18.488]                           base::stop(msg)
[10:24:18.488]                         }
[10:24:18.488]                       })
[10:24:18.488]                     }
[10:24:18.488]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.488]                     base::options(mc.cores = 1L)
[10:24:18.488]                   }
[10:24:18.488]                   options(future.plan = NULL)
[10:24:18.488]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.488]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.488]                 }
[10:24:18.488]                 ...future.workdir <- getwd()
[10:24:18.488]             }
[10:24:18.488]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.488]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.488]         }
[10:24:18.488]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.488]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.488]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.488]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.488]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.488]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.488]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.488]             base::names(...future.oldOptions))
[10:24:18.488]     }
[10:24:18.488]     if (FALSE) {
[10:24:18.488]     }
[10:24:18.488]     else {
[10:24:18.488]         if (TRUE) {
[10:24:18.488]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.488]                 open = "w")
[10:24:18.488]         }
[10:24:18.488]         else {
[10:24:18.488]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.488]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.488]         }
[10:24:18.488]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.488]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.488]             base::sink(type = "output", split = FALSE)
[10:24:18.488]             base::close(...future.stdout)
[10:24:18.488]         }, add = TRUE)
[10:24:18.488]     }
[10:24:18.488]     ...future.frame <- base::sys.nframe()
[10:24:18.488]     ...future.conditions <- base::list()
[10:24:18.488]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.488]     if (FALSE) {
[10:24:18.488]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.488]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.488]     }
[10:24:18.488]     ...future.result <- base::tryCatch({
[10:24:18.488]         base::withCallingHandlers({
[10:24:18.488]             ...future.value <- base::withVisible(base::local({
[10:24:18.488]                 withCallingHandlers({
[10:24:18.488]                   {
[10:24:18.488]                     do.call(function(...) {
[10:24:18.488]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.488]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.488]                         ...future.globals.maxSize)) {
[10:24:18.488]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.488]                         on.exit(options(oopts), add = TRUE)
[10:24:18.488]                       }
[10:24:18.488]                       {
[10:24:18.488]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.488]                           FUN = function(jj) {
[10:24:18.488]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.488]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.488]                           })
[10:24:18.488]                       }
[10:24:18.488]                     }, args = future.call.arguments)
[10:24:18.488]                   }
[10:24:18.488]                 }, immediateCondition = function(cond) {
[10:24:18.488]                   save_rds <- function (object, pathname, ...) 
[10:24:18.488]                   {
[10:24:18.488]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.488]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.488]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.488]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.488]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.488]                         fi_tmp[["mtime"]])
[10:24:18.488]                     }
[10:24:18.488]                     tryCatch({
[10:24:18.488]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.488]                     }, error = function(ex) {
[10:24:18.488]                       msg <- conditionMessage(ex)
[10:24:18.488]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.488]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.488]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.488]                         fi_tmp[["mtime"]], msg)
[10:24:18.488]                       ex$message <- msg
[10:24:18.488]                       stop(ex)
[10:24:18.488]                     })
[10:24:18.488]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.488]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.488]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.488]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.488]                       fi <- file.info(pathname)
[10:24:18.488]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.488]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.488]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.488]                         fi[["size"]], fi[["mtime"]])
[10:24:18.488]                       stop(msg)
[10:24:18.488]                     }
[10:24:18.488]                     invisible(pathname)
[10:24:18.488]                   }
[10:24:18.488]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.488]                     rootPath = tempdir()) 
[10:24:18.488]                   {
[10:24:18.488]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.488]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.488]                       tmpdir = path, fileext = ".rds")
[10:24:18.488]                     save_rds(obj, file)
[10:24:18.488]                   }
[10:24:18.488]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.488]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.488]                   {
[10:24:18.488]                     inherits <- base::inherits
[10:24:18.488]                     invokeRestart <- base::invokeRestart
[10:24:18.488]                     is.null <- base::is.null
[10:24:18.488]                     muffled <- FALSE
[10:24:18.488]                     if (inherits(cond, "message")) {
[10:24:18.488]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.488]                       if (muffled) 
[10:24:18.488]                         invokeRestart("muffleMessage")
[10:24:18.488]                     }
[10:24:18.488]                     else if (inherits(cond, "warning")) {
[10:24:18.488]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.488]                       if (muffled) 
[10:24:18.488]                         invokeRestart("muffleWarning")
[10:24:18.488]                     }
[10:24:18.488]                     else if (inherits(cond, "condition")) {
[10:24:18.488]                       if (!is.null(pattern)) {
[10:24:18.488]                         computeRestarts <- base::computeRestarts
[10:24:18.488]                         grepl <- base::grepl
[10:24:18.488]                         restarts <- computeRestarts(cond)
[10:24:18.488]                         for (restart in restarts) {
[10:24:18.488]                           name <- restart$name
[10:24:18.488]                           if (is.null(name)) 
[10:24:18.488]                             next
[10:24:18.488]                           if (!grepl(pattern, name)) 
[10:24:18.488]                             next
[10:24:18.488]                           invokeRestart(restart)
[10:24:18.488]                           muffled <- TRUE
[10:24:18.488]                           break
[10:24:18.488]                         }
[10:24:18.488]                       }
[10:24:18.488]                     }
[10:24:18.488]                     invisible(muffled)
[10:24:18.488]                   }
[10:24:18.488]                   muffleCondition(cond)
[10:24:18.488]                 })
[10:24:18.488]             }))
[10:24:18.488]             future::FutureResult(value = ...future.value$value, 
[10:24:18.488]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.488]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.488]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.488]                     ...future.globalenv.names))
[10:24:18.488]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.488]         }, condition = base::local({
[10:24:18.488]             c <- base::c
[10:24:18.488]             inherits <- base::inherits
[10:24:18.488]             invokeRestart <- base::invokeRestart
[10:24:18.488]             length <- base::length
[10:24:18.488]             list <- base::list
[10:24:18.488]             seq.int <- base::seq.int
[10:24:18.488]             signalCondition <- base::signalCondition
[10:24:18.488]             sys.calls <- base::sys.calls
[10:24:18.488]             `[[` <- base::`[[`
[10:24:18.488]             `+` <- base::`+`
[10:24:18.488]             `<<-` <- base::`<<-`
[10:24:18.488]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.488]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.488]                   3L)]
[10:24:18.488]             }
[10:24:18.488]             function(cond) {
[10:24:18.488]                 is_error <- inherits(cond, "error")
[10:24:18.488]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.488]                   NULL)
[10:24:18.488]                 if (is_error) {
[10:24:18.488]                   sessionInformation <- function() {
[10:24:18.488]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.488]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.488]                       search = base::search(), system = base::Sys.info())
[10:24:18.488]                   }
[10:24:18.488]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.488]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.488]                     cond$call), session = sessionInformation(), 
[10:24:18.488]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.488]                   signalCondition(cond)
[10:24:18.488]                 }
[10:24:18.488]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.488]                 "immediateCondition"))) {
[10:24:18.488]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.488]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.488]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.488]                   if (TRUE && !signal) {
[10:24:18.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.488]                     {
[10:24:18.488]                       inherits <- base::inherits
[10:24:18.488]                       invokeRestart <- base::invokeRestart
[10:24:18.488]                       is.null <- base::is.null
[10:24:18.488]                       muffled <- FALSE
[10:24:18.488]                       if (inherits(cond, "message")) {
[10:24:18.488]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.488]                         if (muffled) 
[10:24:18.488]                           invokeRestart("muffleMessage")
[10:24:18.488]                       }
[10:24:18.488]                       else if (inherits(cond, "warning")) {
[10:24:18.488]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.488]                         if (muffled) 
[10:24:18.488]                           invokeRestart("muffleWarning")
[10:24:18.488]                       }
[10:24:18.488]                       else if (inherits(cond, "condition")) {
[10:24:18.488]                         if (!is.null(pattern)) {
[10:24:18.488]                           computeRestarts <- base::computeRestarts
[10:24:18.488]                           grepl <- base::grepl
[10:24:18.488]                           restarts <- computeRestarts(cond)
[10:24:18.488]                           for (restart in restarts) {
[10:24:18.488]                             name <- restart$name
[10:24:18.488]                             if (is.null(name)) 
[10:24:18.488]                               next
[10:24:18.488]                             if (!grepl(pattern, name)) 
[10:24:18.488]                               next
[10:24:18.488]                             invokeRestart(restart)
[10:24:18.488]                             muffled <- TRUE
[10:24:18.488]                             break
[10:24:18.488]                           }
[10:24:18.488]                         }
[10:24:18.488]                       }
[10:24:18.488]                       invisible(muffled)
[10:24:18.488]                     }
[10:24:18.488]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.488]                   }
[10:24:18.488]                 }
[10:24:18.488]                 else {
[10:24:18.488]                   if (TRUE) {
[10:24:18.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.488]                     {
[10:24:18.488]                       inherits <- base::inherits
[10:24:18.488]                       invokeRestart <- base::invokeRestart
[10:24:18.488]                       is.null <- base::is.null
[10:24:18.488]                       muffled <- FALSE
[10:24:18.488]                       if (inherits(cond, "message")) {
[10:24:18.488]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.488]                         if (muffled) 
[10:24:18.488]                           invokeRestart("muffleMessage")
[10:24:18.488]                       }
[10:24:18.488]                       else if (inherits(cond, "warning")) {
[10:24:18.488]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.488]                         if (muffled) 
[10:24:18.488]                           invokeRestart("muffleWarning")
[10:24:18.488]                       }
[10:24:18.488]                       else if (inherits(cond, "condition")) {
[10:24:18.488]                         if (!is.null(pattern)) {
[10:24:18.488]                           computeRestarts <- base::computeRestarts
[10:24:18.488]                           grepl <- base::grepl
[10:24:18.488]                           restarts <- computeRestarts(cond)
[10:24:18.488]                           for (restart in restarts) {
[10:24:18.488]                             name <- restart$name
[10:24:18.488]                             if (is.null(name)) 
[10:24:18.488]                               next
[10:24:18.488]                             if (!grepl(pattern, name)) 
[10:24:18.488]                               next
[10:24:18.488]                             invokeRestart(restart)
[10:24:18.488]                             muffled <- TRUE
[10:24:18.488]                             break
[10:24:18.488]                           }
[10:24:18.488]                         }
[10:24:18.488]                       }
[10:24:18.488]                       invisible(muffled)
[10:24:18.488]                     }
[10:24:18.488]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.488]                   }
[10:24:18.488]                 }
[10:24:18.488]             }
[10:24:18.488]         }))
[10:24:18.488]     }, error = function(ex) {
[10:24:18.488]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.488]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.488]                 ...future.rng), started = ...future.startTime, 
[10:24:18.488]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.488]             version = "1.8"), class = "FutureResult")
[10:24:18.488]     }, finally = {
[10:24:18.488]         if (!identical(...future.workdir, getwd())) 
[10:24:18.488]             setwd(...future.workdir)
[10:24:18.488]         {
[10:24:18.488]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.488]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.488]             }
[10:24:18.488]             base::options(...future.oldOptions)
[10:24:18.488]             if (.Platform$OS.type == "windows") {
[10:24:18.488]                 old_names <- names(...future.oldEnvVars)
[10:24:18.488]                 envs <- base::Sys.getenv()
[10:24:18.488]                 names <- names(envs)
[10:24:18.488]                 common <- intersect(names, old_names)
[10:24:18.488]                 added <- setdiff(names, old_names)
[10:24:18.488]                 removed <- setdiff(old_names, names)
[10:24:18.488]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.488]                   envs[common]]
[10:24:18.488]                 NAMES <- toupper(changed)
[10:24:18.488]                 args <- list()
[10:24:18.488]                 for (kk in seq_along(NAMES)) {
[10:24:18.488]                   name <- changed[[kk]]
[10:24:18.488]                   NAME <- NAMES[[kk]]
[10:24:18.488]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.488]                     next
[10:24:18.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.488]                 }
[10:24:18.488]                 NAMES <- toupper(added)
[10:24:18.488]                 for (kk in seq_along(NAMES)) {
[10:24:18.488]                   name <- added[[kk]]
[10:24:18.488]                   NAME <- NAMES[[kk]]
[10:24:18.488]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.488]                     next
[10:24:18.488]                   args[[name]] <- ""
[10:24:18.488]                 }
[10:24:18.488]                 NAMES <- toupper(removed)
[10:24:18.488]                 for (kk in seq_along(NAMES)) {
[10:24:18.488]                   name <- removed[[kk]]
[10:24:18.488]                   NAME <- NAMES[[kk]]
[10:24:18.488]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.488]                     next
[10:24:18.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.488]                 }
[10:24:18.488]                 if (length(args) > 0) 
[10:24:18.488]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.488]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.488]             }
[10:24:18.488]             else {
[10:24:18.488]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.488]             }
[10:24:18.488]             {
[10:24:18.488]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.488]                   0L) {
[10:24:18.488]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.488]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.488]                   base::options(opts)
[10:24:18.488]                 }
[10:24:18.488]                 {
[10:24:18.488]                   {
[10:24:18.488]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.488]                     NULL
[10:24:18.488]                   }
[10:24:18.488]                   options(future.plan = NULL)
[10:24:18.488]                   if (is.na(NA_character_)) 
[10:24:18.488]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.488]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.488]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.488]                     envir = parent.frame()) 
[10:24:18.488]                   {
[10:24:18.488]                     default_workers <- missing(workers)
[10:24:18.488]                     if (is.function(workers)) 
[10:24:18.488]                       workers <- workers()
[10:24:18.488]                     workers <- structure(as.integer(workers), 
[10:24:18.488]                       class = class(workers))
[10:24:18.488]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.488]                       1L)
[10:24:18.488]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.488]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.488]                       if (default_workers) 
[10:24:18.488]                         supportsMulticore(warn = TRUE)
[10:24:18.488]                       return(sequential(..., envir = envir))
[10:24:18.488]                     }
[10:24:18.488]                     oopts <- options(mc.cores = workers)
[10:24:18.488]                     on.exit(options(oopts))
[10:24:18.488]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.488]                       envir = envir)
[10:24:18.488]                     if (!future$lazy) 
[10:24:18.488]                       future <- run(future)
[10:24:18.488]                     invisible(future)
[10:24:18.488]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.488]                 }
[10:24:18.488]             }
[10:24:18.488]         }
[10:24:18.488]     })
[10:24:18.488]     if (TRUE) {
[10:24:18.488]         base::sink(type = "output", split = FALSE)
[10:24:18.488]         if (TRUE) {
[10:24:18.488]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.488]         }
[10:24:18.488]         else {
[10:24:18.488]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.488]         }
[10:24:18.488]         base::close(...future.stdout)
[10:24:18.488]         ...future.stdout <- NULL
[10:24:18.488]     }
[10:24:18.488]     ...future.result$conditions <- ...future.conditions
[10:24:18.488]     ...future.result$finished <- base::Sys.time()
[10:24:18.488]     ...future.result
[10:24:18.488] }
[10:24:18.490] assign_globals() ...
[10:24:18.490] List of 5
[10:24:18.490]  $ ...future.FUN            :function (x, y)  
[10:24:18.490]  $ future.call.arguments    :List of 1
[10:24:18.490]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:18.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.490]  $ ...future.elements_ii    :List of 2
[10:24:18.490]   ..$ A: num 50
[10:24:18.490]   ..$ B: num 60
[10:24:18.490]  $ ...future.seeds_ii       : NULL
[10:24:18.490]  $ ...future.globals.maxSize: NULL
[10:24:18.490]  - attr(*, "where")=List of 5
[10:24:18.490]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.490]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.490]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.490]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.490]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.490]  - attr(*, "resolved")= logi FALSE
[10:24:18.490]  - attr(*, "total_size")= num 4264
[10:24:18.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.490]  - attr(*, "already-done")= logi TRUE
[10:24:18.498] - reassign environment for ‘...future.FUN’
[10:24:18.498] - copied ‘...future.FUN’ to environment
[10:24:18.498] - copied ‘future.call.arguments’ to environment
[10:24:18.498] - copied ‘...future.elements_ii’ to environment
[10:24:18.499] - copied ‘...future.seeds_ii’ to environment
[10:24:18.499] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.499] assign_globals() ... done
[10:24:18.499] requestCore(): workers = 2
[10:24:18.501] MulticoreFuture started
[10:24:18.502] - Launch lazy future ... done
[10:24:18.503] plan(): Setting new future strategy stack:
[10:24:18.503] run() for ‘MulticoreFuture’ ... done
[10:24:18.503] Created future:
[10:24:18.503] List of future strategies:
[10:24:18.503] 1. sequential:
[10:24:18.503]    - args: function (..., envir = parent.frame())
[10:24:18.503]    - tweaked: FALSE
[10:24:18.503]    - call: NULL
[10:24:18.505] plan(): nbrOfWorkers() = 1
[10:24:18.507] plan(): Setting new future strategy stack:
[10:24:18.508] List of future strategies:
[10:24:18.508] 1. multicore:
[10:24:18.508]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.508]    - tweaked: FALSE
[10:24:18.508]    - call: plan(strategy)
[10:24:18.515] plan(): nbrOfWorkers() = 2
[10:24:18.504] MulticoreFuture:
[10:24:18.504] Label: ‘future_sapply-1’
[10:24:18.504] Expression:
[10:24:18.504] {
[10:24:18.504]     do.call(function(...) {
[10:24:18.504]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.504]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.504]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.504]             on.exit(options(oopts), add = TRUE)
[10:24:18.504]         }
[10:24:18.504]         {
[10:24:18.504]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.504]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.504]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.504]             })
[10:24:18.504]         }
[10:24:18.504]     }, args = future.call.arguments)
[10:24:18.504] }
[10:24:18.504] Lazy evaluation: FALSE
[10:24:18.504] Asynchronous evaluation: TRUE
[10:24:18.504] Local evaluation: TRUE
[10:24:18.504] Environment: R_GlobalEnv
[10:24:18.504] Capture standard output: TRUE
[10:24:18.504] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.504] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:18.504] Packages: <none>
[10:24:18.504] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.504] Resolved: TRUE
[10:24:18.504] Value: <not collected>
[10:24:18.504] Conditions captured: <none>
[10:24:18.504] Early signaling: FALSE
[10:24:18.504] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.504] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.516] Chunk #1 of 2 ... DONE
[10:24:18.516] Chunk #2 of 2 ...
[10:24:18.517]  - Finding globals in 'X' for chunk #2 ...
[10:24:18.517] getGlobalsAndPackages() ...
[10:24:18.517] Searching for globals...
[10:24:18.518] 
[10:24:18.518] Searching for globals ... DONE
[10:24:18.518] - globals: [0] <none>
[10:24:18.518] getGlobalsAndPackages() ... DONE
[10:24:18.518]    + additional globals found: [n=0] 
[10:24:18.519]    + additional namespaces needed: [n=0] 
[10:24:18.519]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:18.519]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.519]  - seeds: <none>
[10:24:18.519]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.520] getGlobalsAndPackages() ...
[10:24:18.520] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.520] Resolving globals: FALSE
[10:24:18.520] Tweak future expression to call with '...' arguments ...
[10:24:18.521] {
[10:24:18.521]     do.call(function(...) {
[10:24:18.521]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.521]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.521]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.521]             on.exit(options(oopts), add = TRUE)
[10:24:18.521]         }
[10:24:18.521]         {
[10:24:18.521]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.521]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.521]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.521]             })
[10:24:18.521]         }
[10:24:18.521]     }, args = future.call.arguments)
[10:24:18.521] }
[10:24:18.521] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.522] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.522] 
[10:24:18.522] getGlobalsAndPackages() ... DONE
[10:24:18.523] run() for ‘Future’ ...
[10:24:18.523] - state: ‘created’
[10:24:18.523] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.528] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.528] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.528]   - Field: ‘label’
[10:24:18.528]   - Field: ‘local’
[10:24:18.529]   - Field: ‘owner’
[10:24:18.529]   - Field: ‘envir’
[10:24:18.529]   - Field: ‘workers’
[10:24:18.529]   - Field: ‘packages’
[10:24:18.529]   - Field: ‘gc’
[10:24:18.529]   - Field: ‘job’
[10:24:18.529]   - Field: ‘conditions’
[10:24:18.530]   - Field: ‘expr’
[10:24:18.530]   - Field: ‘uuid’
[10:24:18.530]   - Field: ‘seed’
[10:24:18.530]   - Field: ‘version’
[10:24:18.530]   - Field: ‘result’
[10:24:18.530]   - Field: ‘asynchronous’
[10:24:18.530]   - Field: ‘calls’
[10:24:18.530]   - Field: ‘globals’
[10:24:18.531]   - Field: ‘stdout’
[10:24:18.531]   - Field: ‘earlySignal’
[10:24:18.531]   - Field: ‘lazy’
[10:24:18.531]   - Field: ‘state’
[10:24:18.531] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.531] - Launch lazy future ...
[10:24:18.532] Packages needed by the future expression (n = 0): <none>
[10:24:18.532] Packages needed by future strategies (n = 0): <none>
[10:24:18.533] {
[10:24:18.533]     {
[10:24:18.533]         {
[10:24:18.533]             ...future.startTime <- base::Sys.time()
[10:24:18.533]             {
[10:24:18.533]                 {
[10:24:18.533]                   {
[10:24:18.533]                     {
[10:24:18.533]                       base::local({
[10:24:18.533]                         has_future <- base::requireNamespace("future", 
[10:24:18.533]                           quietly = TRUE)
[10:24:18.533]                         if (has_future) {
[10:24:18.533]                           ns <- base::getNamespace("future")
[10:24:18.533]                           version <- ns[[".package"]][["version"]]
[10:24:18.533]                           if (is.null(version)) 
[10:24:18.533]                             version <- utils::packageVersion("future")
[10:24:18.533]                         }
[10:24:18.533]                         else {
[10:24:18.533]                           version <- NULL
[10:24:18.533]                         }
[10:24:18.533]                         if (!has_future || version < "1.8.0") {
[10:24:18.533]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.533]                             "", base::R.version$version.string), 
[10:24:18.533]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:18.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:18.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.533]                               "release", "version")], collapse = " "), 
[10:24:18.533]                             hostname = base::Sys.info()[["nodename"]])
[10:24:18.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.533]                             info)
[10:24:18.533]                           info <- base::paste(info, collapse = "; ")
[10:24:18.533]                           if (!has_future) {
[10:24:18.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.533]                               info)
[10:24:18.533]                           }
[10:24:18.533]                           else {
[10:24:18.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.533]                               info, version)
[10:24:18.533]                           }
[10:24:18.533]                           base::stop(msg)
[10:24:18.533]                         }
[10:24:18.533]                       })
[10:24:18.533]                     }
[10:24:18.533]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.533]                     base::options(mc.cores = 1L)
[10:24:18.533]                   }
[10:24:18.533]                   options(future.plan = NULL)
[10:24:18.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.533]                 }
[10:24:18.533]                 ...future.workdir <- getwd()
[10:24:18.533]             }
[10:24:18.533]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.533]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.533]         }
[10:24:18.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.533]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.533]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.533]             base::names(...future.oldOptions))
[10:24:18.533]     }
[10:24:18.533]     if (FALSE) {
[10:24:18.533]     }
[10:24:18.533]     else {
[10:24:18.533]         if (TRUE) {
[10:24:18.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.533]                 open = "w")
[10:24:18.533]         }
[10:24:18.533]         else {
[10:24:18.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.533]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.533]         }
[10:24:18.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.533]             base::sink(type = "output", split = FALSE)
[10:24:18.533]             base::close(...future.stdout)
[10:24:18.533]         }, add = TRUE)
[10:24:18.533]     }
[10:24:18.533]     ...future.frame <- base::sys.nframe()
[10:24:18.533]     ...future.conditions <- base::list()
[10:24:18.533]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.533]     if (FALSE) {
[10:24:18.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.533]     }
[10:24:18.533]     ...future.result <- base::tryCatch({
[10:24:18.533]         base::withCallingHandlers({
[10:24:18.533]             ...future.value <- base::withVisible(base::local({
[10:24:18.533]                 withCallingHandlers({
[10:24:18.533]                   {
[10:24:18.533]                     do.call(function(...) {
[10:24:18.533]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.533]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.533]                         ...future.globals.maxSize)) {
[10:24:18.533]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.533]                         on.exit(options(oopts), add = TRUE)
[10:24:18.533]                       }
[10:24:18.533]                       {
[10:24:18.533]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.533]                           FUN = function(jj) {
[10:24:18.533]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.533]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.533]                           })
[10:24:18.533]                       }
[10:24:18.533]                     }, args = future.call.arguments)
[10:24:18.533]                   }
[10:24:18.533]                 }, immediateCondition = function(cond) {
[10:24:18.533]                   save_rds <- function (object, pathname, ...) 
[10:24:18.533]                   {
[10:24:18.533]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.533]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.533]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.533]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.533]                         fi_tmp[["mtime"]])
[10:24:18.533]                     }
[10:24:18.533]                     tryCatch({
[10:24:18.533]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.533]                     }, error = function(ex) {
[10:24:18.533]                       msg <- conditionMessage(ex)
[10:24:18.533]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.533]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.533]                         fi_tmp[["mtime"]], msg)
[10:24:18.533]                       ex$message <- msg
[10:24:18.533]                       stop(ex)
[10:24:18.533]                     })
[10:24:18.533]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.533]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.533]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.533]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.533]                       fi <- file.info(pathname)
[10:24:18.533]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.533]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.533]                         fi[["size"]], fi[["mtime"]])
[10:24:18.533]                       stop(msg)
[10:24:18.533]                     }
[10:24:18.533]                     invisible(pathname)
[10:24:18.533]                   }
[10:24:18.533]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.533]                     rootPath = tempdir()) 
[10:24:18.533]                   {
[10:24:18.533]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.533]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.533]                       tmpdir = path, fileext = ".rds")
[10:24:18.533]                     save_rds(obj, file)
[10:24:18.533]                   }
[10:24:18.533]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.533]                   {
[10:24:18.533]                     inherits <- base::inherits
[10:24:18.533]                     invokeRestart <- base::invokeRestart
[10:24:18.533]                     is.null <- base::is.null
[10:24:18.533]                     muffled <- FALSE
[10:24:18.533]                     if (inherits(cond, "message")) {
[10:24:18.533]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.533]                       if (muffled) 
[10:24:18.533]                         invokeRestart("muffleMessage")
[10:24:18.533]                     }
[10:24:18.533]                     else if (inherits(cond, "warning")) {
[10:24:18.533]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.533]                       if (muffled) 
[10:24:18.533]                         invokeRestart("muffleWarning")
[10:24:18.533]                     }
[10:24:18.533]                     else if (inherits(cond, "condition")) {
[10:24:18.533]                       if (!is.null(pattern)) {
[10:24:18.533]                         computeRestarts <- base::computeRestarts
[10:24:18.533]                         grepl <- base::grepl
[10:24:18.533]                         restarts <- computeRestarts(cond)
[10:24:18.533]                         for (restart in restarts) {
[10:24:18.533]                           name <- restart$name
[10:24:18.533]                           if (is.null(name)) 
[10:24:18.533]                             next
[10:24:18.533]                           if (!grepl(pattern, name)) 
[10:24:18.533]                             next
[10:24:18.533]                           invokeRestart(restart)
[10:24:18.533]                           muffled <- TRUE
[10:24:18.533]                           break
[10:24:18.533]                         }
[10:24:18.533]                       }
[10:24:18.533]                     }
[10:24:18.533]                     invisible(muffled)
[10:24:18.533]                   }
[10:24:18.533]                   muffleCondition(cond)
[10:24:18.533]                 })
[10:24:18.533]             }))
[10:24:18.533]             future::FutureResult(value = ...future.value$value, 
[10:24:18.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.533]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.533]                     ...future.globalenv.names))
[10:24:18.533]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.533]         }, condition = base::local({
[10:24:18.533]             c <- base::c
[10:24:18.533]             inherits <- base::inherits
[10:24:18.533]             invokeRestart <- base::invokeRestart
[10:24:18.533]             length <- base::length
[10:24:18.533]             list <- base::list
[10:24:18.533]             seq.int <- base::seq.int
[10:24:18.533]             signalCondition <- base::signalCondition
[10:24:18.533]             sys.calls <- base::sys.calls
[10:24:18.533]             `[[` <- base::`[[`
[10:24:18.533]             `+` <- base::`+`
[10:24:18.533]             `<<-` <- base::`<<-`
[10:24:18.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.533]                   3L)]
[10:24:18.533]             }
[10:24:18.533]             function(cond) {
[10:24:18.533]                 is_error <- inherits(cond, "error")
[10:24:18.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.533]                   NULL)
[10:24:18.533]                 if (is_error) {
[10:24:18.533]                   sessionInformation <- function() {
[10:24:18.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.533]                       search = base::search(), system = base::Sys.info())
[10:24:18.533]                   }
[10:24:18.533]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.533]                     cond$call), session = sessionInformation(), 
[10:24:18.533]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.533]                   signalCondition(cond)
[10:24:18.533]                 }
[10:24:18.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.533]                 "immediateCondition"))) {
[10:24:18.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.533]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.533]                   if (TRUE && !signal) {
[10:24:18.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.533]                     {
[10:24:18.533]                       inherits <- base::inherits
[10:24:18.533]                       invokeRestart <- base::invokeRestart
[10:24:18.533]                       is.null <- base::is.null
[10:24:18.533]                       muffled <- FALSE
[10:24:18.533]                       if (inherits(cond, "message")) {
[10:24:18.533]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.533]                         if (muffled) 
[10:24:18.533]                           invokeRestart("muffleMessage")
[10:24:18.533]                       }
[10:24:18.533]                       else if (inherits(cond, "warning")) {
[10:24:18.533]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.533]                         if (muffled) 
[10:24:18.533]                           invokeRestart("muffleWarning")
[10:24:18.533]                       }
[10:24:18.533]                       else if (inherits(cond, "condition")) {
[10:24:18.533]                         if (!is.null(pattern)) {
[10:24:18.533]                           computeRestarts <- base::computeRestarts
[10:24:18.533]                           grepl <- base::grepl
[10:24:18.533]                           restarts <- computeRestarts(cond)
[10:24:18.533]                           for (restart in restarts) {
[10:24:18.533]                             name <- restart$name
[10:24:18.533]                             if (is.null(name)) 
[10:24:18.533]                               next
[10:24:18.533]                             if (!grepl(pattern, name)) 
[10:24:18.533]                               next
[10:24:18.533]                             invokeRestart(restart)
[10:24:18.533]                             muffled <- TRUE
[10:24:18.533]                             break
[10:24:18.533]                           }
[10:24:18.533]                         }
[10:24:18.533]                       }
[10:24:18.533]                       invisible(muffled)
[10:24:18.533]                     }
[10:24:18.533]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.533]                   }
[10:24:18.533]                 }
[10:24:18.533]                 else {
[10:24:18.533]                   if (TRUE) {
[10:24:18.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.533]                     {
[10:24:18.533]                       inherits <- base::inherits
[10:24:18.533]                       invokeRestart <- base::invokeRestart
[10:24:18.533]                       is.null <- base::is.null
[10:24:18.533]                       muffled <- FALSE
[10:24:18.533]                       if (inherits(cond, "message")) {
[10:24:18.533]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.533]                         if (muffled) 
[10:24:18.533]                           invokeRestart("muffleMessage")
[10:24:18.533]                       }
[10:24:18.533]                       else if (inherits(cond, "warning")) {
[10:24:18.533]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.533]                         if (muffled) 
[10:24:18.533]                           invokeRestart("muffleWarning")
[10:24:18.533]                       }
[10:24:18.533]                       else if (inherits(cond, "condition")) {
[10:24:18.533]                         if (!is.null(pattern)) {
[10:24:18.533]                           computeRestarts <- base::computeRestarts
[10:24:18.533]                           grepl <- base::grepl
[10:24:18.533]                           restarts <- computeRestarts(cond)
[10:24:18.533]                           for (restart in restarts) {
[10:24:18.533]                             name <- restart$name
[10:24:18.533]                             if (is.null(name)) 
[10:24:18.533]                               next
[10:24:18.533]                             if (!grepl(pattern, name)) 
[10:24:18.533]                               next
[10:24:18.533]                             invokeRestart(restart)
[10:24:18.533]                             muffled <- TRUE
[10:24:18.533]                             break
[10:24:18.533]                           }
[10:24:18.533]                         }
[10:24:18.533]                       }
[10:24:18.533]                       invisible(muffled)
[10:24:18.533]                     }
[10:24:18.533]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.533]                   }
[10:24:18.533]                 }
[10:24:18.533]             }
[10:24:18.533]         }))
[10:24:18.533]     }, error = function(ex) {
[10:24:18.533]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.533]                 ...future.rng), started = ...future.startTime, 
[10:24:18.533]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.533]             version = "1.8"), class = "FutureResult")
[10:24:18.533]     }, finally = {
[10:24:18.533]         if (!identical(...future.workdir, getwd())) 
[10:24:18.533]             setwd(...future.workdir)
[10:24:18.533]         {
[10:24:18.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.533]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.533]             }
[10:24:18.533]             base::options(...future.oldOptions)
[10:24:18.533]             if (.Platform$OS.type == "windows") {
[10:24:18.533]                 old_names <- names(...future.oldEnvVars)
[10:24:18.533]                 envs <- base::Sys.getenv()
[10:24:18.533]                 names <- names(envs)
[10:24:18.533]                 common <- intersect(names, old_names)
[10:24:18.533]                 added <- setdiff(names, old_names)
[10:24:18.533]                 removed <- setdiff(old_names, names)
[10:24:18.533]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.533]                   envs[common]]
[10:24:18.533]                 NAMES <- toupper(changed)
[10:24:18.533]                 args <- list()
[10:24:18.533]                 for (kk in seq_along(NAMES)) {
[10:24:18.533]                   name <- changed[[kk]]
[10:24:18.533]                   NAME <- NAMES[[kk]]
[10:24:18.533]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.533]                     next
[10:24:18.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.533]                 }
[10:24:18.533]                 NAMES <- toupper(added)
[10:24:18.533]                 for (kk in seq_along(NAMES)) {
[10:24:18.533]                   name <- added[[kk]]
[10:24:18.533]                   NAME <- NAMES[[kk]]
[10:24:18.533]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.533]                     next
[10:24:18.533]                   args[[name]] <- ""
[10:24:18.533]                 }
[10:24:18.533]                 NAMES <- toupper(removed)
[10:24:18.533]                 for (kk in seq_along(NAMES)) {
[10:24:18.533]                   name <- removed[[kk]]
[10:24:18.533]                   NAME <- NAMES[[kk]]
[10:24:18.533]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.533]                     next
[10:24:18.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.533]                 }
[10:24:18.533]                 if (length(args) > 0) 
[10:24:18.533]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.533]             }
[10:24:18.533]             else {
[10:24:18.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.533]             }
[10:24:18.533]             {
[10:24:18.533]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.533]                   0L) {
[10:24:18.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.533]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.533]                   base::options(opts)
[10:24:18.533]                 }
[10:24:18.533]                 {
[10:24:18.533]                   {
[10:24:18.533]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.533]                     NULL
[10:24:18.533]                   }
[10:24:18.533]                   options(future.plan = NULL)
[10:24:18.533]                   if (is.na(NA_character_)) 
[10:24:18.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.533]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.533]                     envir = parent.frame()) 
[10:24:18.533]                   {
[10:24:18.533]                     default_workers <- missing(workers)
[10:24:18.533]                     if (is.function(workers)) 
[10:24:18.533]                       workers <- workers()
[10:24:18.533]                     workers <- structure(as.integer(workers), 
[10:24:18.533]                       class = class(workers))
[10:24:18.533]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.533]                       1L)
[10:24:18.533]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.533]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.533]                       if (default_workers) 
[10:24:18.533]                         supportsMulticore(warn = TRUE)
[10:24:18.533]                       return(sequential(..., envir = envir))
[10:24:18.533]                     }
[10:24:18.533]                     oopts <- options(mc.cores = workers)
[10:24:18.533]                     on.exit(options(oopts))
[10:24:18.533]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.533]                       envir = envir)
[10:24:18.533]                     if (!future$lazy) 
[10:24:18.533]                       future <- run(future)
[10:24:18.533]                     invisible(future)
[10:24:18.533]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.533]                 }
[10:24:18.533]             }
[10:24:18.533]         }
[10:24:18.533]     })
[10:24:18.533]     if (TRUE) {
[10:24:18.533]         base::sink(type = "output", split = FALSE)
[10:24:18.533]         if (TRUE) {
[10:24:18.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.533]         }
[10:24:18.533]         else {
[10:24:18.533]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.533]         }
[10:24:18.533]         base::close(...future.stdout)
[10:24:18.533]         ...future.stdout <- NULL
[10:24:18.533]     }
[10:24:18.533]     ...future.result$conditions <- ...future.conditions
[10:24:18.533]     ...future.result$finished <- base::Sys.time()
[10:24:18.533]     ...future.result
[10:24:18.533] }
[10:24:18.536] assign_globals() ...
[10:24:18.536] List of 5
[10:24:18.536]  $ ...future.FUN            :function (x, y)  
[10:24:18.536]  $ future.call.arguments    :List of 1
[10:24:18.536]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:18.536]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.536]  $ ...future.elements_ii    :List of 2
[10:24:18.536]   ..$ C: num 70
[10:24:18.536]   ..$ D: num 80
[10:24:18.536]  $ ...future.seeds_ii       : NULL
[10:24:18.536]  $ ...future.globals.maxSize: NULL
[10:24:18.536]  - attr(*, "where")=List of 5
[10:24:18.536]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.536]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.536]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.536]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.536]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.536]  - attr(*, "resolved")= logi FALSE
[10:24:18.536]  - attr(*, "total_size")= num 4264
[10:24:18.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.536]  - attr(*, "already-done")= logi TRUE
[10:24:18.546] - reassign environment for ‘...future.FUN’
[10:24:18.546] - copied ‘...future.FUN’ to environment
[10:24:18.546] - copied ‘future.call.arguments’ to environment
[10:24:18.546] - copied ‘...future.elements_ii’ to environment
[10:24:18.546] - copied ‘...future.seeds_ii’ to environment
[10:24:18.546] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.547] assign_globals() ... done
[10:24:18.547] requestCore(): workers = 2
[10:24:18.550] MulticoreFuture started
[10:24:18.550] - Launch lazy future ... done
[10:24:18.551] plan(): Setting new future strategy stack:
[10:24:18.551] run() for ‘MulticoreFuture’ ... done
[10:24:18.551] Created future:
[10:24:18.551] List of future strategies:
[10:24:18.551] 1. sequential:
[10:24:18.551]    - args: function (..., envir = parent.frame())
[10:24:18.551]    - tweaked: FALSE
[10:24:18.551]    - call: NULL
[10:24:18.553] plan(): nbrOfWorkers() = 1
[10:24:18.556] plan(): Setting new future strategy stack:
[10:24:18.556] List of future strategies:
[10:24:18.556] 1. multicore:
[10:24:18.556]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.556]    - tweaked: FALSE
[10:24:18.556]    - call: plan(strategy)
[10:24:18.562] plan(): nbrOfWorkers() = 2
[10:24:18.552] MulticoreFuture:
[10:24:18.552] Label: ‘future_sapply-2’
[10:24:18.552] Expression:
[10:24:18.552] {
[10:24:18.552]     do.call(function(...) {
[10:24:18.552]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.552]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.552]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.552]             on.exit(options(oopts), add = TRUE)
[10:24:18.552]         }
[10:24:18.552]         {
[10:24:18.552]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.552]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.552]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.552]             })
[10:24:18.552]         }
[10:24:18.552]     }, args = future.call.arguments)
[10:24:18.552] }
[10:24:18.552] Lazy evaluation: FALSE
[10:24:18.552] Asynchronous evaluation: TRUE
[10:24:18.552] Local evaluation: TRUE
[10:24:18.552] Environment: R_GlobalEnv
[10:24:18.552] Capture standard output: TRUE
[10:24:18.552] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.552] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:18.552] Packages: <none>
[10:24:18.552] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.552] Resolved: TRUE
[10:24:18.552] Value: <not collected>
[10:24:18.552] Conditions captured: <none>
[10:24:18.552] Early signaling: FALSE
[10:24:18.552] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.552] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.564] Chunk #2 of 2 ... DONE
[10:24:18.564] Launching 2 futures (chunks) ... DONE
[10:24:18.564] Resolving 2 futures (chunks) ...
[10:24:18.564] resolve() on list ...
[10:24:18.564]  recursive: 0
[10:24:18.565]  length: 2
[10:24:18.565] 
[10:24:18.565] Future #1
[10:24:18.566] result() for MulticoreFuture ...
[10:24:18.567] result() for MulticoreFuture ...
[10:24:18.567] result() for MulticoreFuture ... done
[10:24:18.567] result() for MulticoreFuture ... done
[10:24:18.567] result() for MulticoreFuture ...
[10:24:18.567] result() for MulticoreFuture ... done
[10:24:18.568] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:18.568] - nx: 2
[10:24:18.568] - relay: TRUE
[10:24:18.568] - stdout: TRUE
[10:24:18.569] - signal: TRUE
[10:24:18.569] - resignal: FALSE
[10:24:18.569] - force: TRUE
[10:24:18.569] - relayed: [n=2] FALSE, FALSE
[10:24:18.570] - queued futures: [n=2] FALSE, FALSE
[10:24:18.570]  - until=1
[10:24:18.570]  - relaying element #1
[10:24:18.570] result() for MulticoreFuture ...
[10:24:18.570] result() for MulticoreFuture ... done
[10:24:18.571] result() for MulticoreFuture ...
[10:24:18.571] result() for MulticoreFuture ... done
[10:24:18.571] result() for MulticoreFuture ...
[10:24:18.571] result() for MulticoreFuture ... done
[10:24:18.571] result() for MulticoreFuture ...
[10:24:18.572] result() for MulticoreFuture ... done
[10:24:18.572] - relayed: [n=2] TRUE, FALSE
[10:24:18.572] - queued futures: [n=2] TRUE, FALSE
[10:24:18.572] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:18.572]  length: 1 (resolved future 1)
[10:24:18.573] Future #2
[10:24:18.573] result() for MulticoreFuture ...
[10:24:18.574] result() for MulticoreFuture ...
[10:24:18.574] result() for MulticoreFuture ... done
[10:24:18.574] result() for MulticoreFuture ... done
[10:24:18.574] result() for MulticoreFuture ...
[10:24:18.574] result() for MulticoreFuture ... done
[10:24:18.575] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:18.575] - nx: 2
[10:24:18.575] - relay: TRUE
[10:24:18.575] - stdout: TRUE
[10:24:18.575] - signal: TRUE
[10:24:18.575] - resignal: FALSE
[10:24:18.575] - force: TRUE
[10:24:18.575] - relayed: [n=2] TRUE, FALSE
[10:24:18.575] - queued futures: [n=2] TRUE, FALSE
[10:24:18.576]  - until=2
[10:24:18.576]  - relaying element #2
[10:24:18.576] result() for MulticoreFuture ...
[10:24:18.576] result() for MulticoreFuture ... done
[10:24:18.576] result() for MulticoreFuture ...
[10:24:18.576] result() for MulticoreFuture ... done
[10:24:18.576] result() for MulticoreFuture ...
[10:24:18.576] result() for MulticoreFuture ... done
[10:24:18.577] result() for MulticoreFuture ...
[10:24:18.577] result() for MulticoreFuture ... done
[10:24:18.577] - relayed: [n=2] TRUE, TRUE
[10:24:18.577] - queued futures: [n=2] TRUE, TRUE
[10:24:18.577] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:18.577]  length: 0 (resolved future 2)
[10:24:18.577] Relaying remaining futures
[10:24:18.577] signalConditionsASAP(NULL, pos=0) ...
[10:24:18.577] - nx: 2
[10:24:18.578] - relay: TRUE
[10:24:18.578] - stdout: TRUE
[10:24:18.578] - signal: TRUE
[10:24:18.578] - resignal: FALSE
[10:24:18.578] - force: TRUE
[10:24:18.578] - relayed: [n=2] TRUE, TRUE
[10:24:18.578] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:18.578] - relayed: [n=2] TRUE, TRUE
[10:24:18.578] - queued futures: [n=2] TRUE, TRUE
[10:24:18.579] signalConditionsASAP(NULL, pos=0) ... done
[10:24:18.579] resolve() on list ... DONE
[10:24:18.579] result() for MulticoreFuture ...
[10:24:18.579] result() for MulticoreFuture ... done
[10:24:18.579] result() for MulticoreFuture ...
[10:24:18.579] result() for MulticoreFuture ... done
[10:24:18.579] result() for MulticoreFuture ...
[10:24:18.579] result() for MulticoreFuture ... done
[10:24:18.579] result() for MulticoreFuture ...
[10:24:18.579] result() for MulticoreFuture ... done
[10:24:18.580]  - Number of value chunks collected: 2
[10:24:18.580] Resolving 2 futures (chunks) ... DONE
[10:24:18.580] Reducing values from 2 chunks ...
[10:24:18.580]  - Number of values collected after concatenation: 4
[10:24:18.580]  - Number of values expected: 4
[10:24:18.580] Reducing values from 2 chunks ... DONE
[10:24:18.580] future_lapply() ... DONE
[10:24:18.581] future_lapply() ...
[10:24:18.587] Number of chunks: 2
[10:24:18.587] getGlobalsAndPackagesXApply() ...
[10:24:18.587]  - future.globals: TRUE
[10:24:18.588] getGlobalsAndPackages() ...
[10:24:18.588] Searching for globals...
[10:24:18.594] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[10:24:18.594] Searching for globals ... DONE
[10:24:18.594] Resolving globals: FALSE
[10:24:18.595] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[10:24:18.596] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:18.596] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:18.596] - packages: [1] ‘future.apply’
[10:24:18.596] getGlobalsAndPackages() ... DONE
[10:24:18.597]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:18.597]  - needed namespaces: [n=1] ‘future.apply’
[10:24:18.597] Finding globals ... DONE
[10:24:18.597]  - use_args: TRUE
[10:24:18.597]  - Getting '...' globals ...
[10:24:18.597] resolve() on list ...
[10:24:18.597]  recursive: 0
[10:24:18.598]  length: 1
[10:24:18.598]  elements: ‘...’
[10:24:18.598]  length: 0 (resolved future 1)
[10:24:18.598] resolve() on list ... DONE
[10:24:18.598]    - '...' content: [n=1] ‘y’
[10:24:18.598] List of 1
[10:24:18.598]  $ ...:List of 1
[10:24:18.598]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:18.598]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.598]  - attr(*, "where")=List of 1
[10:24:18.598]   ..$ ...:<environment: 0x55b93c9f4848> 
[10:24:18.598]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.598]  - attr(*, "resolved")= logi TRUE
[10:24:18.598]  - attr(*, "total_size")= num NA
[10:24:18.601]  - Getting '...' globals ... DONE
[10:24:18.601] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:18.602] List of 8
[10:24:18.602]  $ ...future.FUN:function (x, ...)  
[10:24:18.602]  $ x_FUN        :function (x, y)  
[10:24:18.602]  $ times        : int 15
[10:24:18.602]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.602]  $ stop_if_not  :function (...)  
[10:24:18.602]  $ dim          : int [1:2] 3 5
[10:24:18.602]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:18.602]  $ ...          :List of 1
[10:24:18.602]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:18.602]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.602]  - attr(*, "where")=List of 8
[10:24:18.602]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:18.602]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:18.602]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:18.602]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:18.602]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:18.602]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:18.602]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:18.602]   ..$ ...          :<environment: 0x55b93c9f4848> 
[10:24:18.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.602]  - attr(*, "resolved")= logi FALSE
[10:24:18.602]  - attr(*, "total_size")= num 98600
[10:24:18.608] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:18.608] getGlobalsAndPackagesXApply() ... DONE
[10:24:18.608] Number of futures (= number of chunks): 2
[10:24:18.608] Launching 2 futures (chunks) ...
[10:24:18.608] Chunk #1 of 2 ...
[10:24:18.608]  - Finding globals in 'X' for chunk #1 ...
[10:24:18.608] getGlobalsAndPackages() ...
[10:24:18.608] Searching for globals...
[10:24:18.609] 
[10:24:18.609] Searching for globals ... DONE
[10:24:18.609] - globals: [0] <none>
[10:24:18.611] getGlobalsAndPackages() ... DONE
[10:24:18.611]    + additional globals found: [n=0] 
[10:24:18.611]    + additional namespaces needed: [n=0] 
[10:24:18.611]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:18.611]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.611]  - seeds: <none>
[10:24:18.611]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.611] getGlobalsAndPackages() ...
[10:24:18.612] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.612] Resolving globals: FALSE
[10:24:18.612] Tweak future expression to call with '...' arguments ...
[10:24:18.612] {
[10:24:18.612]     do.call(function(...) {
[10:24:18.612]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.612]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.612]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.612]             on.exit(options(oopts), add = TRUE)
[10:24:18.612]         }
[10:24:18.612]         {
[10:24:18.612]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.612]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.612]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.612]             })
[10:24:18.612]         }
[10:24:18.612]     }, args = future.call.arguments)
[10:24:18.612] }
[10:24:18.612] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.613] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.613] - packages: [1] ‘future.apply’
[10:24:18.613] getGlobalsAndPackages() ... DONE
[10:24:18.613] run() for ‘Future’ ...
[10:24:18.613] - state: ‘created’
[10:24:18.614] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.617] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.618] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.618]   - Field: ‘label’
[10:24:18.618]   - Field: ‘local’
[10:24:18.618]   - Field: ‘owner’
[10:24:18.618]   - Field: ‘envir’
[10:24:18.618]   - Field: ‘workers’
[10:24:18.618]   - Field: ‘packages’
[10:24:18.618]   - Field: ‘gc’
[10:24:18.618]   - Field: ‘job’
[10:24:18.619]   - Field: ‘conditions’
[10:24:18.619]   - Field: ‘expr’
[10:24:18.619]   - Field: ‘uuid’
[10:24:18.619]   - Field: ‘seed’
[10:24:18.619]   - Field: ‘version’
[10:24:18.619]   - Field: ‘result’
[10:24:18.619]   - Field: ‘asynchronous’
[10:24:18.619]   - Field: ‘calls’
[10:24:18.619]   - Field: ‘globals’
[10:24:18.619]   - Field: ‘stdout’
[10:24:18.620]   - Field: ‘earlySignal’
[10:24:18.620]   - Field: ‘lazy’
[10:24:18.620]   - Field: ‘state’
[10:24:18.620] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.620] - Launch lazy future ...
[10:24:18.620] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:18.620] Packages needed by future strategies (n = 0): <none>
[10:24:18.621] {
[10:24:18.621]     {
[10:24:18.621]         {
[10:24:18.621]             ...future.startTime <- base::Sys.time()
[10:24:18.621]             {
[10:24:18.621]                 {
[10:24:18.621]                   {
[10:24:18.621]                     {
[10:24:18.621]                       {
[10:24:18.621]                         base::local({
[10:24:18.621]                           has_future <- base::requireNamespace("future", 
[10:24:18.621]                             quietly = TRUE)
[10:24:18.621]                           if (has_future) {
[10:24:18.621]                             ns <- base::getNamespace("future")
[10:24:18.621]                             version <- ns[[".package"]][["version"]]
[10:24:18.621]                             if (is.null(version)) 
[10:24:18.621]                               version <- utils::packageVersion("future")
[10:24:18.621]                           }
[10:24:18.621]                           else {
[10:24:18.621]                             version <- NULL
[10:24:18.621]                           }
[10:24:18.621]                           if (!has_future || version < "1.8.0") {
[10:24:18.621]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.621]                               "", base::R.version$version.string), 
[10:24:18.621]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.621]                                 base::R.version$platform, 8 * 
[10:24:18.621]                                   base::.Machine$sizeof.pointer), 
[10:24:18.621]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.621]                                 "release", "version")], collapse = " "), 
[10:24:18.621]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.621]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.621]                               info)
[10:24:18.621]                             info <- base::paste(info, collapse = "; ")
[10:24:18.621]                             if (!has_future) {
[10:24:18.621]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.621]                                 info)
[10:24:18.621]                             }
[10:24:18.621]                             else {
[10:24:18.621]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.621]                                 info, version)
[10:24:18.621]                             }
[10:24:18.621]                             base::stop(msg)
[10:24:18.621]                           }
[10:24:18.621]                         })
[10:24:18.621]                       }
[10:24:18.621]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.621]                       base::options(mc.cores = 1L)
[10:24:18.621]                     }
[10:24:18.621]                     base::local({
[10:24:18.621]                       for (pkg in "future.apply") {
[10:24:18.621]                         base::loadNamespace(pkg)
[10:24:18.621]                         base::library(pkg, character.only = TRUE)
[10:24:18.621]                       }
[10:24:18.621]                     })
[10:24:18.621]                   }
[10:24:18.621]                   options(future.plan = NULL)
[10:24:18.621]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.621]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.621]                 }
[10:24:18.621]                 ...future.workdir <- getwd()
[10:24:18.621]             }
[10:24:18.621]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.621]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.621]         }
[10:24:18.621]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.621]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.621]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.621]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.621]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.621]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.621]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.621]             base::names(...future.oldOptions))
[10:24:18.621]     }
[10:24:18.621]     if (FALSE) {
[10:24:18.621]     }
[10:24:18.621]     else {
[10:24:18.621]         if (TRUE) {
[10:24:18.621]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.621]                 open = "w")
[10:24:18.621]         }
[10:24:18.621]         else {
[10:24:18.621]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.621]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.621]         }
[10:24:18.621]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.621]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.621]             base::sink(type = "output", split = FALSE)
[10:24:18.621]             base::close(...future.stdout)
[10:24:18.621]         }, add = TRUE)
[10:24:18.621]     }
[10:24:18.621]     ...future.frame <- base::sys.nframe()
[10:24:18.621]     ...future.conditions <- base::list()
[10:24:18.621]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.621]     if (FALSE) {
[10:24:18.621]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.621]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.621]     }
[10:24:18.621]     ...future.result <- base::tryCatch({
[10:24:18.621]         base::withCallingHandlers({
[10:24:18.621]             ...future.value <- base::withVisible(base::local({
[10:24:18.621]                 withCallingHandlers({
[10:24:18.621]                   {
[10:24:18.621]                     do.call(function(...) {
[10:24:18.621]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.621]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.621]                         ...future.globals.maxSize)) {
[10:24:18.621]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.621]                         on.exit(options(oopts), add = TRUE)
[10:24:18.621]                       }
[10:24:18.621]                       {
[10:24:18.621]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.621]                           FUN = function(jj) {
[10:24:18.621]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.621]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.621]                           })
[10:24:18.621]                       }
[10:24:18.621]                     }, args = future.call.arguments)
[10:24:18.621]                   }
[10:24:18.621]                 }, immediateCondition = function(cond) {
[10:24:18.621]                   save_rds <- function (object, pathname, ...) 
[10:24:18.621]                   {
[10:24:18.621]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.621]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.621]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.621]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.621]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.621]                         fi_tmp[["mtime"]])
[10:24:18.621]                     }
[10:24:18.621]                     tryCatch({
[10:24:18.621]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.621]                     }, error = function(ex) {
[10:24:18.621]                       msg <- conditionMessage(ex)
[10:24:18.621]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.621]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.621]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.621]                         fi_tmp[["mtime"]], msg)
[10:24:18.621]                       ex$message <- msg
[10:24:18.621]                       stop(ex)
[10:24:18.621]                     })
[10:24:18.621]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.621]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.621]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.621]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.621]                       fi <- file.info(pathname)
[10:24:18.621]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.621]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.621]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.621]                         fi[["size"]], fi[["mtime"]])
[10:24:18.621]                       stop(msg)
[10:24:18.621]                     }
[10:24:18.621]                     invisible(pathname)
[10:24:18.621]                   }
[10:24:18.621]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.621]                     rootPath = tempdir()) 
[10:24:18.621]                   {
[10:24:18.621]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.621]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.621]                       tmpdir = path, fileext = ".rds")
[10:24:18.621]                     save_rds(obj, file)
[10:24:18.621]                   }
[10:24:18.621]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.621]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.621]                   {
[10:24:18.621]                     inherits <- base::inherits
[10:24:18.621]                     invokeRestart <- base::invokeRestart
[10:24:18.621]                     is.null <- base::is.null
[10:24:18.621]                     muffled <- FALSE
[10:24:18.621]                     if (inherits(cond, "message")) {
[10:24:18.621]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.621]                       if (muffled) 
[10:24:18.621]                         invokeRestart("muffleMessage")
[10:24:18.621]                     }
[10:24:18.621]                     else if (inherits(cond, "warning")) {
[10:24:18.621]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.621]                       if (muffled) 
[10:24:18.621]                         invokeRestart("muffleWarning")
[10:24:18.621]                     }
[10:24:18.621]                     else if (inherits(cond, "condition")) {
[10:24:18.621]                       if (!is.null(pattern)) {
[10:24:18.621]                         computeRestarts <- base::computeRestarts
[10:24:18.621]                         grepl <- base::grepl
[10:24:18.621]                         restarts <- computeRestarts(cond)
[10:24:18.621]                         for (restart in restarts) {
[10:24:18.621]                           name <- restart$name
[10:24:18.621]                           if (is.null(name)) 
[10:24:18.621]                             next
[10:24:18.621]                           if (!grepl(pattern, name)) 
[10:24:18.621]                             next
[10:24:18.621]                           invokeRestart(restart)
[10:24:18.621]                           muffled <- TRUE
[10:24:18.621]                           break
[10:24:18.621]                         }
[10:24:18.621]                       }
[10:24:18.621]                     }
[10:24:18.621]                     invisible(muffled)
[10:24:18.621]                   }
[10:24:18.621]                   muffleCondition(cond)
[10:24:18.621]                 })
[10:24:18.621]             }))
[10:24:18.621]             future::FutureResult(value = ...future.value$value, 
[10:24:18.621]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.621]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.621]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.621]                     ...future.globalenv.names))
[10:24:18.621]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.621]         }, condition = base::local({
[10:24:18.621]             c <- base::c
[10:24:18.621]             inherits <- base::inherits
[10:24:18.621]             invokeRestart <- base::invokeRestart
[10:24:18.621]             length <- base::length
[10:24:18.621]             list <- base::list
[10:24:18.621]             seq.int <- base::seq.int
[10:24:18.621]             signalCondition <- base::signalCondition
[10:24:18.621]             sys.calls <- base::sys.calls
[10:24:18.621]             `[[` <- base::`[[`
[10:24:18.621]             `+` <- base::`+`
[10:24:18.621]             `<<-` <- base::`<<-`
[10:24:18.621]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.621]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.621]                   3L)]
[10:24:18.621]             }
[10:24:18.621]             function(cond) {
[10:24:18.621]                 is_error <- inherits(cond, "error")
[10:24:18.621]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.621]                   NULL)
[10:24:18.621]                 if (is_error) {
[10:24:18.621]                   sessionInformation <- function() {
[10:24:18.621]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.621]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.621]                       search = base::search(), system = base::Sys.info())
[10:24:18.621]                   }
[10:24:18.621]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.621]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.621]                     cond$call), session = sessionInformation(), 
[10:24:18.621]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.621]                   signalCondition(cond)
[10:24:18.621]                 }
[10:24:18.621]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.621]                 "immediateCondition"))) {
[10:24:18.621]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.621]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.621]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.621]                   if (TRUE && !signal) {
[10:24:18.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.621]                     {
[10:24:18.621]                       inherits <- base::inherits
[10:24:18.621]                       invokeRestart <- base::invokeRestart
[10:24:18.621]                       is.null <- base::is.null
[10:24:18.621]                       muffled <- FALSE
[10:24:18.621]                       if (inherits(cond, "message")) {
[10:24:18.621]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.621]                         if (muffled) 
[10:24:18.621]                           invokeRestart("muffleMessage")
[10:24:18.621]                       }
[10:24:18.621]                       else if (inherits(cond, "warning")) {
[10:24:18.621]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.621]                         if (muffled) 
[10:24:18.621]                           invokeRestart("muffleWarning")
[10:24:18.621]                       }
[10:24:18.621]                       else if (inherits(cond, "condition")) {
[10:24:18.621]                         if (!is.null(pattern)) {
[10:24:18.621]                           computeRestarts <- base::computeRestarts
[10:24:18.621]                           grepl <- base::grepl
[10:24:18.621]                           restarts <- computeRestarts(cond)
[10:24:18.621]                           for (restart in restarts) {
[10:24:18.621]                             name <- restart$name
[10:24:18.621]                             if (is.null(name)) 
[10:24:18.621]                               next
[10:24:18.621]                             if (!grepl(pattern, name)) 
[10:24:18.621]                               next
[10:24:18.621]                             invokeRestart(restart)
[10:24:18.621]                             muffled <- TRUE
[10:24:18.621]                             break
[10:24:18.621]                           }
[10:24:18.621]                         }
[10:24:18.621]                       }
[10:24:18.621]                       invisible(muffled)
[10:24:18.621]                     }
[10:24:18.621]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.621]                   }
[10:24:18.621]                 }
[10:24:18.621]                 else {
[10:24:18.621]                   if (TRUE) {
[10:24:18.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.621]                     {
[10:24:18.621]                       inherits <- base::inherits
[10:24:18.621]                       invokeRestart <- base::invokeRestart
[10:24:18.621]                       is.null <- base::is.null
[10:24:18.621]                       muffled <- FALSE
[10:24:18.621]                       if (inherits(cond, "message")) {
[10:24:18.621]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.621]                         if (muffled) 
[10:24:18.621]                           invokeRestart("muffleMessage")
[10:24:18.621]                       }
[10:24:18.621]                       else if (inherits(cond, "warning")) {
[10:24:18.621]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.621]                         if (muffled) 
[10:24:18.621]                           invokeRestart("muffleWarning")
[10:24:18.621]                       }
[10:24:18.621]                       else if (inherits(cond, "condition")) {
[10:24:18.621]                         if (!is.null(pattern)) {
[10:24:18.621]                           computeRestarts <- base::computeRestarts
[10:24:18.621]                           grepl <- base::grepl
[10:24:18.621]                           restarts <- computeRestarts(cond)
[10:24:18.621]                           for (restart in restarts) {
[10:24:18.621]                             name <- restart$name
[10:24:18.621]                             if (is.null(name)) 
[10:24:18.621]                               next
[10:24:18.621]                             if (!grepl(pattern, name)) 
[10:24:18.621]                               next
[10:24:18.621]                             invokeRestart(restart)
[10:24:18.621]                             muffled <- TRUE
[10:24:18.621]                             break
[10:24:18.621]                           }
[10:24:18.621]                         }
[10:24:18.621]                       }
[10:24:18.621]                       invisible(muffled)
[10:24:18.621]                     }
[10:24:18.621]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.621]                   }
[10:24:18.621]                 }
[10:24:18.621]             }
[10:24:18.621]         }))
[10:24:18.621]     }, error = function(ex) {
[10:24:18.621]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.621]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.621]                 ...future.rng), started = ...future.startTime, 
[10:24:18.621]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.621]             version = "1.8"), class = "FutureResult")
[10:24:18.621]     }, finally = {
[10:24:18.621]         if (!identical(...future.workdir, getwd())) 
[10:24:18.621]             setwd(...future.workdir)
[10:24:18.621]         {
[10:24:18.621]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.621]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.621]             }
[10:24:18.621]             base::options(...future.oldOptions)
[10:24:18.621]             if (.Platform$OS.type == "windows") {
[10:24:18.621]                 old_names <- names(...future.oldEnvVars)
[10:24:18.621]                 envs <- base::Sys.getenv()
[10:24:18.621]                 names <- names(envs)
[10:24:18.621]                 common <- intersect(names, old_names)
[10:24:18.621]                 added <- setdiff(names, old_names)
[10:24:18.621]                 removed <- setdiff(old_names, names)
[10:24:18.621]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.621]                   envs[common]]
[10:24:18.621]                 NAMES <- toupper(changed)
[10:24:18.621]                 args <- list()
[10:24:18.621]                 for (kk in seq_along(NAMES)) {
[10:24:18.621]                   name <- changed[[kk]]
[10:24:18.621]                   NAME <- NAMES[[kk]]
[10:24:18.621]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.621]                     next
[10:24:18.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.621]                 }
[10:24:18.621]                 NAMES <- toupper(added)
[10:24:18.621]                 for (kk in seq_along(NAMES)) {
[10:24:18.621]                   name <- added[[kk]]
[10:24:18.621]                   NAME <- NAMES[[kk]]
[10:24:18.621]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.621]                     next
[10:24:18.621]                   args[[name]] <- ""
[10:24:18.621]                 }
[10:24:18.621]                 NAMES <- toupper(removed)
[10:24:18.621]                 for (kk in seq_along(NAMES)) {
[10:24:18.621]                   name <- removed[[kk]]
[10:24:18.621]                   NAME <- NAMES[[kk]]
[10:24:18.621]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.621]                     next
[10:24:18.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.621]                 }
[10:24:18.621]                 if (length(args) > 0) 
[10:24:18.621]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.621]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.621]             }
[10:24:18.621]             else {
[10:24:18.621]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.621]             }
[10:24:18.621]             {
[10:24:18.621]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.621]                   0L) {
[10:24:18.621]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.621]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.621]                   base::options(opts)
[10:24:18.621]                 }
[10:24:18.621]                 {
[10:24:18.621]                   {
[10:24:18.621]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.621]                     NULL
[10:24:18.621]                   }
[10:24:18.621]                   options(future.plan = NULL)
[10:24:18.621]                   if (is.na(NA_character_)) 
[10:24:18.621]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.621]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.621]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.621]                     envir = parent.frame()) 
[10:24:18.621]                   {
[10:24:18.621]                     default_workers <- missing(workers)
[10:24:18.621]                     if (is.function(workers)) 
[10:24:18.621]                       workers <- workers()
[10:24:18.621]                     workers <- structure(as.integer(workers), 
[10:24:18.621]                       class = class(workers))
[10:24:18.621]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.621]                       1L)
[10:24:18.621]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.621]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.621]                       if (default_workers) 
[10:24:18.621]                         supportsMulticore(warn = TRUE)
[10:24:18.621]                       return(sequential(..., envir = envir))
[10:24:18.621]                     }
[10:24:18.621]                     oopts <- options(mc.cores = workers)
[10:24:18.621]                     on.exit(options(oopts))
[10:24:18.621]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.621]                       envir = envir)
[10:24:18.621]                     if (!future$lazy) 
[10:24:18.621]                       future <- run(future)
[10:24:18.621]                     invisible(future)
[10:24:18.621]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.621]                 }
[10:24:18.621]             }
[10:24:18.621]         }
[10:24:18.621]     })
[10:24:18.621]     if (TRUE) {
[10:24:18.621]         base::sink(type = "output", split = FALSE)
[10:24:18.621]         if (TRUE) {
[10:24:18.621]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.621]         }
[10:24:18.621]         else {
[10:24:18.621]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.621]         }
[10:24:18.621]         base::close(...future.stdout)
[10:24:18.621]         ...future.stdout <- NULL
[10:24:18.621]     }
[10:24:18.621]     ...future.result$conditions <- ...future.conditions
[10:24:18.621]     ...future.result$finished <- base::Sys.time()
[10:24:18.621]     ...future.result
[10:24:18.621] }
[10:24:18.624] assign_globals() ...
[10:24:18.624] List of 11
[10:24:18.624]  $ ...future.FUN            :function (x, ...)  
[10:24:18.624]  $ x_FUN                    :function (x, y)  
[10:24:18.624]  $ times                    : int 15
[10:24:18.624]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.624]  $ stop_if_not              :function (...)  
[10:24:18.624]  $ dim                      : int [1:2] 3 5
[10:24:18.624]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:18.624]  $ future.call.arguments    :List of 1
[10:24:18.624]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:18.624]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.624]  $ ...future.elements_ii    :List of 2
[10:24:18.624]   ..$ A: num 50
[10:24:18.624]   ..$ B: num 60
[10:24:18.624]  $ ...future.seeds_ii       : NULL
[10:24:18.624]  $ ...future.globals.maxSize: NULL
[10:24:18.624]  - attr(*, "where")=List of 11
[10:24:18.624]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.624]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:18.624]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:18.624]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:18.624]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:18.624]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:18.624]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:18.624]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.624]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.624]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.624]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.624]  - attr(*, "resolved")= logi FALSE
[10:24:18.624]  - attr(*, "total_size")= num 98600
[10:24:18.624]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.624]  - attr(*, "already-done")= logi TRUE
[10:24:18.632] - copied ‘...future.FUN’ to environment
[10:24:18.632] - reassign environment for ‘x_FUN’
[10:24:18.632] - copied ‘x_FUN’ to environment
[10:24:18.632] - copied ‘times’ to environment
[10:24:18.632] - copied ‘stopf’ to environment
[10:24:18.633] - copied ‘stop_if_not’ to environment
[10:24:18.633] - copied ‘dim’ to environment
[10:24:18.633] - copied ‘valid_types’ to environment
[10:24:18.633] - copied ‘future.call.arguments’ to environment
[10:24:18.633] - copied ‘...future.elements_ii’ to environment
[10:24:18.635] - copied ‘...future.seeds_ii’ to environment
[10:24:18.635] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.635] assign_globals() ... done
[10:24:18.635] requestCore(): workers = 2
[10:24:18.638] MulticoreFuture started
[10:24:18.639] - Launch lazy future ... done
[10:24:18.639] run() for ‘MulticoreFuture’ ... done
[10:24:18.640] Created future:
[10:24:18.640] plan(): Setting new future strategy stack:
[10:24:18.640] List of future strategies:
[10:24:18.640] 1. sequential:
[10:24:18.640]    - args: function (..., envir = parent.frame())
[10:24:18.640]    - tweaked: FALSE
[10:24:18.640]    - call: NULL
[10:24:18.642] plan(): nbrOfWorkers() = 1
[10:24:18.645] plan(): Setting new future strategy stack:
[10:24:18.645] List of future strategies:
[10:24:18.645] 1. multicore:
[10:24:18.645]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.645]    - tweaked: FALSE
[10:24:18.645]    - call: plan(strategy)
[10:24:18.652] plan(): nbrOfWorkers() = 2
[10:24:18.640] MulticoreFuture:
[10:24:18.640] Label: ‘future_vapply-1’
[10:24:18.640] Expression:
[10:24:18.640] {
[10:24:18.640]     do.call(function(...) {
[10:24:18.640]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.640]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.640]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.640]             on.exit(options(oopts), add = TRUE)
[10:24:18.640]         }
[10:24:18.640]         {
[10:24:18.640]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.640]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.640]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.640]             })
[10:24:18.640]         }
[10:24:18.640]     }, args = future.call.arguments)
[10:24:18.640] }
[10:24:18.640] Lazy evaluation: FALSE
[10:24:18.640] Asynchronous evaluation: TRUE
[10:24:18.640] Local evaluation: TRUE
[10:24:18.640] Environment: R_GlobalEnv
[10:24:18.640] Capture standard output: TRUE
[10:24:18.640] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.640] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:18.640] Packages: 1 packages (‘future.apply’)
[10:24:18.640] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.640] Resolved: TRUE
[10:24:18.640] Value: <not collected>
[10:24:18.640] Conditions captured: <none>
[10:24:18.640] Early signaling: FALSE
[10:24:18.640] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.640] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.653] Chunk #1 of 2 ... DONE
[10:24:18.653] Chunk #2 of 2 ...
[10:24:18.654]  - Finding globals in 'X' for chunk #2 ...
[10:24:18.654] getGlobalsAndPackages() ...
[10:24:18.654] Searching for globals...
[10:24:18.655] 
[10:24:18.655] Searching for globals ... DONE
[10:24:18.655] - globals: [0] <none>
[10:24:18.655] getGlobalsAndPackages() ... DONE
[10:24:18.655]    + additional globals found: [n=0] 
[10:24:18.656]    + additional namespaces needed: [n=0] 
[10:24:18.656]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:18.656]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.656]  - seeds: <none>
[10:24:18.657]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.657] getGlobalsAndPackages() ...
[10:24:18.657] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.657] Resolving globals: FALSE
[10:24:18.658] Tweak future expression to call with '...' arguments ...
[10:24:18.658] {
[10:24:18.658]     do.call(function(...) {
[10:24:18.658]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.658]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.658]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.658]             on.exit(options(oopts), add = TRUE)
[10:24:18.658]         }
[10:24:18.658]         {
[10:24:18.658]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.658]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.658]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.658]             })
[10:24:18.658]         }
[10:24:18.658]     }, args = future.call.arguments)
[10:24:18.658] }
[10:24:18.659] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.660] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.660] - packages: [1] ‘future.apply’
[10:24:18.660] getGlobalsAndPackages() ... DONE
[10:24:18.661] run() for ‘Future’ ...
[10:24:18.661] - state: ‘created’
[10:24:18.661] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.666] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.666]   - Field: ‘label’
[10:24:18.667]   - Field: ‘local’
[10:24:18.667]   - Field: ‘owner’
[10:24:18.667]   - Field: ‘envir’
[10:24:18.667]   - Field: ‘workers’
[10:24:18.668]   - Field: ‘packages’
[10:24:18.668]   - Field: ‘gc’
[10:24:18.668]   - Field: ‘job’
[10:24:18.668]   - Field: ‘conditions’
[10:24:18.668]   - Field: ‘expr’
[10:24:18.668]   - Field: ‘uuid’
[10:24:18.668]   - Field: ‘seed’
[10:24:18.668]   - Field: ‘version’
[10:24:18.669]   - Field: ‘result’
[10:24:18.669]   - Field: ‘asynchronous’
[10:24:18.669]   - Field: ‘calls’
[10:24:18.669]   - Field: ‘globals’
[10:24:18.669]   - Field: ‘stdout’
[10:24:18.669]   - Field: ‘earlySignal’
[10:24:18.670]   - Field: ‘lazy’
[10:24:18.670]   - Field: ‘state’
[10:24:18.670] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.670] - Launch lazy future ...
[10:24:18.670] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:18.670] Packages needed by future strategies (n = 0): <none>
[10:24:18.671] {
[10:24:18.671]     {
[10:24:18.671]         {
[10:24:18.671]             ...future.startTime <- base::Sys.time()
[10:24:18.671]             {
[10:24:18.671]                 {
[10:24:18.671]                   {
[10:24:18.671]                     {
[10:24:18.671]                       {
[10:24:18.671]                         base::local({
[10:24:18.671]                           has_future <- base::requireNamespace("future", 
[10:24:18.671]                             quietly = TRUE)
[10:24:18.671]                           if (has_future) {
[10:24:18.671]                             ns <- base::getNamespace("future")
[10:24:18.671]                             version <- ns[[".package"]][["version"]]
[10:24:18.671]                             if (is.null(version)) 
[10:24:18.671]                               version <- utils::packageVersion("future")
[10:24:18.671]                           }
[10:24:18.671]                           else {
[10:24:18.671]                             version <- NULL
[10:24:18.671]                           }
[10:24:18.671]                           if (!has_future || version < "1.8.0") {
[10:24:18.671]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.671]                               "", base::R.version$version.string), 
[10:24:18.671]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.671]                                 base::R.version$platform, 8 * 
[10:24:18.671]                                   base::.Machine$sizeof.pointer), 
[10:24:18.671]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.671]                                 "release", "version")], collapse = " "), 
[10:24:18.671]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.671]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.671]                               info)
[10:24:18.671]                             info <- base::paste(info, collapse = "; ")
[10:24:18.671]                             if (!has_future) {
[10:24:18.671]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.671]                                 info)
[10:24:18.671]                             }
[10:24:18.671]                             else {
[10:24:18.671]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.671]                                 info, version)
[10:24:18.671]                             }
[10:24:18.671]                             base::stop(msg)
[10:24:18.671]                           }
[10:24:18.671]                         })
[10:24:18.671]                       }
[10:24:18.671]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.671]                       base::options(mc.cores = 1L)
[10:24:18.671]                     }
[10:24:18.671]                     base::local({
[10:24:18.671]                       for (pkg in "future.apply") {
[10:24:18.671]                         base::loadNamespace(pkg)
[10:24:18.671]                         base::library(pkg, character.only = TRUE)
[10:24:18.671]                       }
[10:24:18.671]                     })
[10:24:18.671]                   }
[10:24:18.671]                   options(future.plan = NULL)
[10:24:18.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.671]                 }
[10:24:18.671]                 ...future.workdir <- getwd()
[10:24:18.671]             }
[10:24:18.671]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.671]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.671]         }
[10:24:18.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.671]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.671]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.671]             base::names(...future.oldOptions))
[10:24:18.671]     }
[10:24:18.671]     if (FALSE) {
[10:24:18.671]     }
[10:24:18.671]     else {
[10:24:18.671]         if (TRUE) {
[10:24:18.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.671]                 open = "w")
[10:24:18.671]         }
[10:24:18.671]         else {
[10:24:18.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.671]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.671]         }
[10:24:18.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.671]             base::sink(type = "output", split = FALSE)
[10:24:18.671]             base::close(...future.stdout)
[10:24:18.671]         }, add = TRUE)
[10:24:18.671]     }
[10:24:18.671]     ...future.frame <- base::sys.nframe()
[10:24:18.671]     ...future.conditions <- base::list()
[10:24:18.671]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.671]     if (FALSE) {
[10:24:18.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.671]     }
[10:24:18.671]     ...future.result <- base::tryCatch({
[10:24:18.671]         base::withCallingHandlers({
[10:24:18.671]             ...future.value <- base::withVisible(base::local({
[10:24:18.671]                 withCallingHandlers({
[10:24:18.671]                   {
[10:24:18.671]                     do.call(function(...) {
[10:24:18.671]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.671]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.671]                         ...future.globals.maxSize)) {
[10:24:18.671]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.671]                         on.exit(options(oopts), add = TRUE)
[10:24:18.671]                       }
[10:24:18.671]                       {
[10:24:18.671]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.671]                           FUN = function(jj) {
[10:24:18.671]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.671]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.671]                           })
[10:24:18.671]                       }
[10:24:18.671]                     }, args = future.call.arguments)
[10:24:18.671]                   }
[10:24:18.671]                 }, immediateCondition = function(cond) {
[10:24:18.671]                   save_rds <- function (object, pathname, ...) 
[10:24:18.671]                   {
[10:24:18.671]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.671]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.671]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.671]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.671]                         fi_tmp[["mtime"]])
[10:24:18.671]                     }
[10:24:18.671]                     tryCatch({
[10:24:18.671]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.671]                     }, error = function(ex) {
[10:24:18.671]                       msg <- conditionMessage(ex)
[10:24:18.671]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.671]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.671]                         fi_tmp[["mtime"]], msg)
[10:24:18.671]                       ex$message <- msg
[10:24:18.671]                       stop(ex)
[10:24:18.671]                     })
[10:24:18.671]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.671]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.671]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.671]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.671]                       fi <- file.info(pathname)
[10:24:18.671]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.671]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.671]                         fi[["size"]], fi[["mtime"]])
[10:24:18.671]                       stop(msg)
[10:24:18.671]                     }
[10:24:18.671]                     invisible(pathname)
[10:24:18.671]                   }
[10:24:18.671]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.671]                     rootPath = tempdir()) 
[10:24:18.671]                   {
[10:24:18.671]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.671]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.671]                       tmpdir = path, fileext = ".rds")
[10:24:18.671]                     save_rds(obj, file)
[10:24:18.671]                   }
[10:24:18.671]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.671]                   {
[10:24:18.671]                     inherits <- base::inherits
[10:24:18.671]                     invokeRestart <- base::invokeRestart
[10:24:18.671]                     is.null <- base::is.null
[10:24:18.671]                     muffled <- FALSE
[10:24:18.671]                     if (inherits(cond, "message")) {
[10:24:18.671]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.671]                       if (muffled) 
[10:24:18.671]                         invokeRestart("muffleMessage")
[10:24:18.671]                     }
[10:24:18.671]                     else if (inherits(cond, "warning")) {
[10:24:18.671]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.671]                       if (muffled) 
[10:24:18.671]                         invokeRestart("muffleWarning")
[10:24:18.671]                     }
[10:24:18.671]                     else if (inherits(cond, "condition")) {
[10:24:18.671]                       if (!is.null(pattern)) {
[10:24:18.671]                         computeRestarts <- base::computeRestarts
[10:24:18.671]                         grepl <- base::grepl
[10:24:18.671]                         restarts <- computeRestarts(cond)
[10:24:18.671]                         for (restart in restarts) {
[10:24:18.671]                           name <- restart$name
[10:24:18.671]                           if (is.null(name)) 
[10:24:18.671]                             next
[10:24:18.671]                           if (!grepl(pattern, name)) 
[10:24:18.671]                             next
[10:24:18.671]                           invokeRestart(restart)
[10:24:18.671]                           muffled <- TRUE
[10:24:18.671]                           break
[10:24:18.671]                         }
[10:24:18.671]                       }
[10:24:18.671]                     }
[10:24:18.671]                     invisible(muffled)
[10:24:18.671]                   }
[10:24:18.671]                   muffleCondition(cond)
[10:24:18.671]                 })
[10:24:18.671]             }))
[10:24:18.671]             future::FutureResult(value = ...future.value$value, 
[10:24:18.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.671]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.671]                     ...future.globalenv.names))
[10:24:18.671]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.671]         }, condition = base::local({
[10:24:18.671]             c <- base::c
[10:24:18.671]             inherits <- base::inherits
[10:24:18.671]             invokeRestart <- base::invokeRestart
[10:24:18.671]             length <- base::length
[10:24:18.671]             list <- base::list
[10:24:18.671]             seq.int <- base::seq.int
[10:24:18.671]             signalCondition <- base::signalCondition
[10:24:18.671]             sys.calls <- base::sys.calls
[10:24:18.671]             `[[` <- base::`[[`
[10:24:18.671]             `+` <- base::`+`
[10:24:18.671]             `<<-` <- base::`<<-`
[10:24:18.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.671]                   3L)]
[10:24:18.671]             }
[10:24:18.671]             function(cond) {
[10:24:18.671]                 is_error <- inherits(cond, "error")
[10:24:18.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.671]                   NULL)
[10:24:18.671]                 if (is_error) {
[10:24:18.671]                   sessionInformation <- function() {
[10:24:18.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.671]                       search = base::search(), system = base::Sys.info())
[10:24:18.671]                   }
[10:24:18.671]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.671]                     cond$call), session = sessionInformation(), 
[10:24:18.671]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.671]                   signalCondition(cond)
[10:24:18.671]                 }
[10:24:18.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.671]                 "immediateCondition"))) {
[10:24:18.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.671]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.671]                   if (TRUE && !signal) {
[10:24:18.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.671]                     {
[10:24:18.671]                       inherits <- base::inherits
[10:24:18.671]                       invokeRestart <- base::invokeRestart
[10:24:18.671]                       is.null <- base::is.null
[10:24:18.671]                       muffled <- FALSE
[10:24:18.671]                       if (inherits(cond, "message")) {
[10:24:18.671]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.671]                         if (muffled) 
[10:24:18.671]                           invokeRestart("muffleMessage")
[10:24:18.671]                       }
[10:24:18.671]                       else if (inherits(cond, "warning")) {
[10:24:18.671]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.671]                         if (muffled) 
[10:24:18.671]                           invokeRestart("muffleWarning")
[10:24:18.671]                       }
[10:24:18.671]                       else if (inherits(cond, "condition")) {
[10:24:18.671]                         if (!is.null(pattern)) {
[10:24:18.671]                           computeRestarts <- base::computeRestarts
[10:24:18.671]                           grepl <- base::grepl
[10:24:18.671]                           restarts <- computeRestarts(cond)
[10:24:18.671]                           for (restart in restarts) {
[10:24:18.671]                             name <- restart$name
[10:24:18.671]                             if (is.null(name)) 
[10:24:18.671]                               next
[10:24:18.671]                             if (!grepl(pattern, name)) 
[10:24:18.671]                               next
[10:24:18.671]                             invokeRestart(restart)
[10:24:18.671]                             muffled <- TRUE
[10:24:18.671]                             break
[10:24:18.671]                           }
[10:24:18.671]                         }
[10:24:18.671]                       }
[10:24:18.671]                       invisible(muffled)
[10:24:18.671]                     }
[10:24:18.671]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.671]                   }
[10:24:18.671]                 }
[10:24:18.671]                 else {
[10:24:18.671]                   if (TRUE) {
[10:24:18.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.671]                     {
[10:24:18.671]                       inherits <- base::inherits
[10:24:18.671]                       invokeRestart <- base::invokeRestart
[10:24:18.671]                       is.null <- base::is.null
[10:24:18.671]                       muffled <- FALSE
[10:24:18.671]                       if (inherits(cond, "message")) {
[10:24:18.671]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.671]                         if (muffled) 
[10:24:18.671]                           invokeRestart("muffleMessage")
[10:24:18.671]                       }
[10:24:18.671]                       else if (inherits(cond, "warning")) {
[10:24:18.671]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.671]                         if (muffled) 
[10:24:18.671]                           invokeRestart("muffleWarning")
[10:24:18.671]                       }
[10:24:18.671]                       else if (inherits(cond, "condition")) {
[10:24:18.671]                         if (!is.null(pattern)) {
[10:24:18.671]                           computeRestarts <- base::computeRestarts
[10:24:18.671]                           grepl <- base::grepl
[10:24:18.671]                           restarts <- computeRestarts(cond)
[10:24:18.671]                           for (restart in restarts) {
[10:24:18.671]                             name <- restart$name
[10:24:18.671]                             if (is.null(name)) 
[10:24:18.671]                               next
[10:24:18.671]                             if (!grepl(pattern, name)) 
[10:24:18.671]                               next
[10:24:18.671]                             invokeRestart(restart)
[10:24:18.671]                             muffled <- TRUE
[10:24:18.671]                             break
[10:24:18.671]                           }
[10:24:18.671]                         }
[10:24:18.671]                       }
[10:24:18.671]                       invisible(muffled)
[10:24:18.671]                     }
[10:24:18.671]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.671]                   }
[10:24:18.671]                 }
[10:24:18.671]             }
[10:24:18.671]         }))
[10:24:18.671]     }, error = function(ex) {
[10:24:18.671]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.671]                 ...future.rng), started = ...future.startTime, 
[10:24:18.671]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.671]             version = "1.8"), class = "FutureResult")
[10:24:18.671]     }, finally = {
[10:24:18.671]         if (!identical(...future.workdir, getwd())) 
[10:24:18.671]             setwd(...future.workdir)
[10:24:18.671]         {
[10:24:18.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.671]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.671]             }
[10:24:18.671]             base::options(...future.oldOptions)
[10:24:18.671]             if (.Platform$OS.type == "windows") {
[10:24:18.671]                 old_names <- names(...future.oldEnvVars)
[10:24:18.671]                 envs <- base::Sys.getenv()
[10:24:18.671]                 names <- names(envs)
[10:24:18.671]                 common <- intersect(names, old_names)
[10:24:18.671]                 added <- setdiff(names, old_names)
[10:24:18.671]                 removed <- setdiff(old_names, names)
[10:24:18.671]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.671]                   envs[common]]
[10:24:18.671]                 NAMES <- toupper(changed)
[10:24:18.671]                 args <- list()
[10:24:18.671]                 for (kk in seq_along(NAMES)) {
[10:24:18.671]                   name <- changed[[kk]]
[10:24:18.671]                   NAME <- NAMES[[kk]]
[10:24:18.671]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.671]                     next
[10:24:18.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.671]                 }
[10:24:18.671]                 NAMES <- toupper(added)
[10:24:18.671]                 for (kk in seq_along(NAMES)) {
[10:24:18.671]                   name <- added[[kk]]
[10:24:18.671]                   NAME <- NAMES[[kk]]
[10:24:18.671]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.671]                     next
[10:24:18.671]                   args[[name]] <- ""
[10:24:18.671]                 }
[10:24:18.671]                 NAMES <- toupper(removed)
[10:24:18.671]                 for (kk in seq_along(NAMES)) {
[10:24:18.671]                   name <- removed[[kk]]
[10:24:18.671]                   NAME <- NAMES[[kk]]
[10:24:18.671]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.671]                     next
[10:24:18.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.671]                 }
[10:24:18.671]                 if (length(args) > 0) 
[10:24:18.671]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.671]             }
[10:24:18.671]             else {
[10:24:18.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.671]             }
[10:24:18.671]             {
[10:24:18.671]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.671]                   0L) {
[10:24:18.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.671]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.671]                   base::options(opts)
[10:24:18.671]                 }
[10:24:18.671]                 {
[10:24:18.671]                   {
[10:24:18.671]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.671]                     NULL
[10:24:18.671]                   }
[10:24:18.671]                   options(future.plan = NULL)
[10:24:18.671]                   if (is.na(NA_character_)) 
[10:24:18.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.671]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.671]                     envir = parent.frame()) 
[10:24:18.671]                   {
[10:24:18.671]                     default_workers <- missing(workers)
[10:24:18.671]                     if (is.function(workers)) 
[10:24:18.671]                       workers <- workers()
[10:24:18.671]                     workers <- structure(as.integer(workers), 
[10:24:18.671]                       class = class(workers))
[10:24:18.671]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.671]                       1L)
[10:24:18.671]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.671]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.671]                       if (default_workers) 
[10:24:18.671]                         supportsMulticore(warn = TRUE)
[10:24:18.671]                       return(sequential(..., envir = envir))
[10:24:18.671]                     }
[10:24:18.671]                     oopts <- options(mc.cores = workers)
[10:24:18.671]                     on.exit(options(oopts))
[10:24:18.671]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.671]                       envir = envir)
[10:24:18.671]                     if (!future$lazy) 
[10:24:18.671]                       future <- run(future)
[10:24:18.671]                     invisible(future)
[10:24:18.671]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.671]                 }
[10:24:18.671]             }
[10:24:18.671]         }
[10:24:18.671]     })
[10:24:18.671]     if (TRUE) {
[10:24:18.671]         base::sink(type = "output", split = FALSE)
[10:24:18.671]         if (TRUE) {
[10:24:18.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.671]         }
[10:24:18.671]         else {
[10:24:18.671]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.671]         }
[10:24:18.671]         base::close(...future.stdout)
[10:24:18.671]         ...future.stdout <- NULL
[10:24:18.671]     }
[10:24:18.671]     ...future.result$conditions <- ...future.conditions
[10:24:18.671]     ...future.result$finished <- base::Sys.time()
[10:24:18.671]     ...future.result
[10:24:18.671] }
[10:24:18.675] assign_globals() ...
[10:24:18.675] List of 11
[10:24:18.675]  $ ...future.FUN            :function (x, ...)  
[10:24:18.675]  $ x_FUN                    :function (x, y)  
[10:24:18.675]  $ times                    : int 15
[10:24:18.675]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.675]  $ stop_if_not              :function (...)  
[10:24:18.675]  $ dim                      : int [1:2] 3 5
[10:24:18.675]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:18.675]  $ future.call.arguments    :List of 1
[10:24:18.675]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:18.675]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.675]  $ ...future.elements_ii    :List of 2
[10:24:18.675]   ..$ C: num 70
[10:24:18.675]   ..$ D: num 80
[10:24:18.675]  $ ...future.seeds_ii       : NULL
[10:24:18.675]  $ ...future.globals.maxSize: NULL
[10:24:18.675]  - attr(*, "where")=List of 11
[10:24:18.675]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.675]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:18.675]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:18.675]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:18.675]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:18.675]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:18.675]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:18.675]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.675]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.675]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.675]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.675]  - attr(*, "resolved")= logi FALSE
[10:24:18.675]  - attr(*, "total_size")= num 98600
[10:24:18.675]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.675]  - attr(*, "already-done")= logi TRUE
[10:24:18.687] - copied ‘...future.FUN’ to environment
[10:24:18.688] - reassign environment for ‘x_FUN’
[10:24:18.688] - copied ‘x_FUN’ to environment
[10:24:18.688] - copied ‘times’ to environment
[10:24:18.688] - copied ‘stopf’ to environment
[10:24:18.688] - copied ‘stop_if_not’ to environment
[10:24:18.688] - copied ‘dim’ to environment
[10:24:18.688] - copied ‘valid_types’ to environment
[10:24:18.688] - copied ‘future.call.arguments’ to environment
[10:24:18.688] - copied ‘...future.elements_ii’ to environment
[10:24:18.689] - copied ‘...future.seeds_ii’ to environment
[10:24:18.689] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.689] assign_globals() ... done
[10:24:18.689] requestCore(): workers = 2
[10:24:18.692] MulticoreFuture started
[10:24:18.692] - Launch lazy future ... done
[10:24:18.693] run() for ‘MulticoreFuture’ ... done
[10:24:18.693] Created future:
[10:24:18.693] plan(): Setting new future strategy stack:
[10:24:18.694] List of future strategies:
[10:24:18.694] 1. sequential:
[10:24:18.694]    - args: function (..., envir = parent.frame())
[10:24:18.694]    - tweaked: FALSE
[10:24:18.694]    - call: NULL
[10:24:18.695] plan(): nbrOfWorkers() = 1
[10:24:18.698] plan(): Setting new future strategy stack:
[10:24:18.698] List of future strategies:
[10:24:18.698] 1. multicore:
[10:24:18.698]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.698]    - tweaked: FALSE
[10:24:18.698]    - call: plan(strategy)
[10:24:18.705] plan(): nbrOfWorkers() = 2
[10:24:18.694] MulticoreFuture:
[10:24:18.694] Label: ‘future_vapply-2’
[10:24:18.694] Expression:
[10:24:18.694] {
[10:24:18.694]     do.call(function(...) {
[10:24:18.694]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.694]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.694]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.694]             on.exit(options(oopts), add = TRUE)
[10:24:18.694]         }
[10:24:18.694]         {
[10:24:18.694]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.694]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.694]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.694]             })
[10:24:18.694]         }
[10:24:18.694]     }, args = future.call.arguments)
[10:24:18.694] }
[10:24:18.694] Lazy evaluation: FALSE
[10:24:18.694] Asynchronous evaluation: TRUE
[10:24:18.694] Local evaluation: TRUE
[10:24:18.694] Environment: R_GlobalEnv
[10:24:18.694] Capture standard output: TRUE
[10:24:18.694] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.694] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:18.694] Packages: 1 packages (‘future.apply’)
[10:24:18.694] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.694] Resolved: TRUE
[10:24:18.694] Value: <not collected>
[10:24:18.694] Conditions captured: <none>
[10:24:18.694] Early signaling: FALSE
[10:24:18.694] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.694] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.707] Chunk #2 of 2 ... DONE
[10:24:18.707] Launching 2 futures (chunks) ... DONE
[10:24:18.707] Resolving 2 futures (chunks) ...
[10:24:18.707] resolve() on list ...
[10:24:18.708]  recursive: 0
[10:24:18.708]  length: 2
[10:24:18.708] 
[10:24:18.708] Future #1
[10:24:18.709] result() for MulticoreFuture ...
[10:24:18.710] result() for MulticoreFuture ...
[10:24:18.710] result() for MulticoreFuture ... done
[10:24:18.710] result() for MulticoreFuture ... done
[10:24:18.710] result() for MulticoreFuture ...
[10:24:18.710] result() for MulticoreFuture ... done
[10:24:18.710] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:18.710] - nx: 2
[10:24:18.711] - relay: TRUE
[10:24:18.711] - stdout: TRUE
[10:24:18.711] - signal: TRUE
[10:24:18.711] - resignal: FALSE
[10:24:18.711] - force: TRUE
[10:24:18.711] - relayed: [n=2] FALSE, FALSE
[10:24:18.712] - queued futures: [n=2] FALSE, FALSE
[10:24:18.712]  - until=1
[10:24:18.712]  - relaying element #1
[10:24:18.712] result() for MulticoreFuture ...
[10:24:18.712] result() for MulticoreFuture ... done
[10:24:18.713] result() for MulticoreFuture ...
[10:24:18.713] result() for MulticoreFuture ... done
[10:24:18.713] result() for MulticoreFuture ...
[10:24:18.713] result() for MulticoreFuture ... done
[10:24:18.714] result() for MulticoreFuture ...
[10:24:18.714] result() for MulticoreFuture ... done
[10:24:18.714] - relayed: [n=2] TRUE, FALSE
[10:24:18.714] - queued futures: [n=2] TRUE, FALSE
[10:24:18.714] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:18.714]  length: 1 (resolved future 1)
[10:24:18.715] Future #2
[10:24:18.715] result() for MulticoreFuture ...
[10:24:18.715] result() for MulticoreFuture ...
[10:24:18.716] result() for MulticoreFuture ... done
[10:24:18.716] result() for MulticoreFuture ... done
[10:24:18.716] result() for MulticoreFuture ...
[10:24:18.716] result() for MulticoreFuture ... done
[10:24:18.716] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:18.716] - nx: 2
[10:24:18.716] - relay: TRUE
[10:24:18.717] - stdout: TRUE
[10:24:18.717] - signal: TRUE
[10:24:18.717] - resignal: FALSE
[10:24:18.717] - force: TRUE
[10:24:18.717] - relayed: [n=2] TRUE, FALSE
[10:24:18.717] - queued futures: [n=2] TRUE, FALSE
[10:24:18.717]  - until=2
[10:24:18.717]  - relaying element #2
[10:24:18.717] result() for MulticoreFuture ...
[10:24:18.718] result() for MulticoreFuture ... done
[10:24:18.718] result() for MulticoreFuture ...
[10:24:18.718] result() for MulticoreFuture ... done
[10:24:18.718] result() for MulticoreFuture ...
[10:24:18.718] result() for MulticoreFuture ... done
[10:24:18.718] result() for MulticoreFuture ...
[10:24:18.718] result() for MulticoreFuture ... done
[10:24:18.718] - relayed: [n=2] TRUE, TRUE
[10:24:18.719] - queued futures: [n=2] TRUE, TRUE
[10:24:18.719] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:18.719]  length: 0 (resolved future 2)
[10:24:18.719] Relaying remaining futures
[10:24:18.719] signalConditionsASAP(NULL, pos=0) ...
[10:24:18.719] - nx: 2
[10:24:18.719] - relay: TRUE
[10:24:18.719] - stdout: TRUE
[10:24:18.719] - signal: TRUE
[10:24:18.720] - resignal: FALSE
[10:24:18.720] - force: TRUE
[10:24:18.720] - relayed: [n=2] TRUE, TRUE
[10:24:18.720] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:18.720] - relayed: [n=2] TRUE, TRUE
[10:24:18.720] - queued futures: [n=2] TRUE, TRUE
[10:24:18.720] signalConditionsASAP(NULL, pos=0) ... done
[10:24:18.720] resolve() on list ... DONE
[10:24:18.720] result() for MulticoreFuture ...
[10:24:18.721] result() for MulticoreFuture ... done
[10:24:18.721] result() for MulticoreFuture ...
[10:24:18.721] result() for MulticoreFuture ... done
[10:24:18.721] result() for MulticoreFuture ...
[10:24:18.721] result() for MulticoreFuture ... done
[10:24:18.721] result() for MulticoreFuture ...
[10:24:18.721] result() for MulticoreFuture ... done
[10:24:18.721]  - Number of value chunks collected: 2
[10:24:18.721] Resolving 2 futures (chunks) ... DONE
[10:24:18.722] Reducing values from 2 chunks ...
[10:24:18.722]  - Number of values collected after concatenation: 4
[10:24:18.722]  - Number of values expected: 4
[10:24:18.722] Reducing values from 2 chunks ... DONE
[10:24:18.722] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[10:24:18.724] future_lapply() ...
[10:24:18.733] Number of chunks: 2
[10:24:18.733] getGlobalsAndPackagesXApply() ...
[10:24:18.734]  - future.globals: TRUE
[10:24:18.734] getGlobalsAndPackages() ...
[10:24:18.734] Searching for globals...
[10:24:18.738] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:18.738] Searching for globals ... DONE
[10:24:18.738] Resolving globals: FALSE
[10:24:18.739] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[10:24:18.739] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:18.739] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:18.739] - packages: [1] ‘future.apply’
[10:24:18.740] getGlobalsAndPackages() ... DONE
[10:24:18.740]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:18.740]  - needed namespaces: [n=1] ‘future.apply’
[10:24:18.740] Finding globals ... DONE
[10:24:18.740]  - use_args: TRUE
[10:24:18.740]  - Getting '...' globals ...
[10:24:18.740] resolve() on list ...
[10:24:18.740]  recursive: 0
[10:24:18.741]  length: 1
[10:24:18.741]  elements: ‘...’
[10:24:18.741]  length: 0 (resolved future 1)
[10:24:18.741] resolve() on list ... DONE
[10:24:18.741]    - '...' content: [n=0] 
[10:24:18.741] List of 1
[10:24:18.741]  $ ...: list()
[10:24:18.741]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.741]  - attr(*, "where")=List of 1
[10:24:18.741]   ..$ ...:<environment: 0x55b93cdb5798> 
[10:24:18.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.741]  - attr(*, "resolved")= logi TRUE
[10:24:18.741]  - attr(*, "total_size")= num NA
[10:24:18.744]  - Getting '...' globals ... DONE
[10:24:18.744] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:18.744] List of 8
[10:24:18.744]  $ ...future.FUN:function (x, ...)  
[10:24:18.744]  $ x_FUN        :function (x)  
[10:24:18.744]  $ times        : int 1
[10:24:18.744]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.744]  $ stop_if_not  :function (...)  
[10:24:18.744]  $ dim          : NULL
[10:24:18.744]  $ valid_types  : chr "logical"
[10:24:18.744]  $ ...          : list()
[10:24:18.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.744]  - attr(*, "where")=List of 8
[10:24:18.744]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:18.744]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:18.744]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:18.744]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:18.744]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:18.744]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:18.744]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:18.744]   ..$ ...          :<environment: 0x55b93cdb5798> 
[10:24:18.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.744]  - attr(*, "resolved")= logi FALSE
[10:24:18.744]  - attr(*, "total_size")= num 94200
[10:24:18.751] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:18.752] getGlobalsAndPackagesXApply() ... DONE
[10:24:18.752] Number of futures (= number of chunks): 2
[10:24:18.752] Launching 2 futures (chunks) ...
[10:24:18.752] Chunk #1 of 2 ...
[10:24:18.752]  - Finding globals in 'X' for chunk #1 ...
[10:24:18.752] getGlobalsAndPackages() ...
[10:24:18.752] Searching for globals...
[10:24:18.753] 
[10:24:18.753] Searching for globals ... DONE
[10:24:18.753] - globals: [0] <none>
[10:24:18.753] getGlobalsAndPackages() ... DONE
[10:24:18.753]    + additional globals found: [n=0] 
[10:24:18.753]    + additional namespaces needed: [n=0] 
[10:24:18.753]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:18.753]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.753]  - seeds: <none>
[10:24:18.754]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.754] getGlobalsAndPackages() ...
[10:24:18.754] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.754] Resolving globals: FALSE
[10:24:18.754] Tweak future expression to call with '...' arguments ...
[10:24:18.754] {
[10:24:18.754]     do.call(function(...) {
[10:24:18.754]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.754]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.754]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.754]             on.exit(options(oopts), add = TRUE)
[10:24:18.754]         }
[10:24:18.754]         {
[10:24:18.754]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.754]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.754]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.754]             })
[10:24:18.754]         }
[10:24:18.754]     }, args = future.call.arguments)
[10:24:18.754] }
[10:24:18.754] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.755] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.755] - packages: [1] ‘future.apply’
[10:24:18.755] getGlobalsAndPackages() ... DONE
[10:24:18.756] run() for ‘Future’ ...
[10:24:18.756] - state: ‘created’
[10:24:18.756] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.760] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.760] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.760]   - Field: ‘label’
[10:24:18.760]   - Field: ‘local’
[10:24:18.760]   - Field: ‘owner’
[10:24:18.760]   - Field: ‘envir’
[10:24:18.760]   - Field: ‘workers’
[10:24:18.760]   - Field: ‘packages’
[10:24:18.760]   - Field: ‘gc’
[10:24:18.760]   - Field: ‘job’
[10:24:18.761]   - Field: ‘conditions’
[10:24:18.761]   - Field: ‘expr’
[10:24:18.761]   - Field: ‘uuid’
[10:24:18.761]   - Field: ‘seed’
[10:24:18.761]   - Field: ‘version’
[10:24:18.761]   - Field: ‘result’
[10:24:18.761]   - Field: ‘asynchronous’
[10:24:18.761]   - Field: ‘calls’
[10:24:18.761]   - Field: ‘globals’
[10:24:18.761]   - Field: ‘stdout’
[10:24:18.762]   - Field: ‘earlySignal’
[10:24:18.762]   - Field: ‘lazy’
[10:24:18.762]   - Field: ‘state’
[10:24:18.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.762] - Launch lazy future ...
[10:24:18.762] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:18.762] Packages needed by future strategies (n = 0): <none>
[10:24:18.763] {
[10:24:18.763]     {
[10:24:18.763]         {
[10:24:18.763]             ...future.startTime <- base::Sys.time()
[10:24:18.763]             {
[10:24:18.763]                 {
[10:24:18.763]                   {
[10:24:18.763]                     {
[10:24:18.763]                       {
[10:24:18.763]                         base::local({
[10:24:18.763]                           has_future <- base::requireNamespace("future", 
[10:24:18.763]                             quietly = TRUE)
[10:24:18.763]                           if (has_future) {
[10:24:18.763]                             ns <- base::getNamespace("future")
[10:24:18.763]                             version <- ns[[".package"]][["version"]]
[10:24:18.763]                             if (is.null(version)) 
[10:24:18.763]                               version <- utils::packageVersion("future")
[10:24:18.763]                           }
[10:24:18.763]                           else {
[10:24:18.763]                             version <- NULL
[10:24:18.763]                           }
[10:24:18.763]                           if (!has_future || version < "1.8.0") {
[10:24:18.763]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.763]                               "", base::R.version$version.string), 
[10:24:18.763]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.763]                                 base::R.version$platform, 8 * 
[10:24:18.763]                                   base::.Machine$sizeof.pointer), 
[10:24:18.763]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.763]                                 "release", "version")], collapse = " "), 
[10:24:18.763]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.763]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.763]                               info)
[10:24:18.763]                             info <- base::paste(info, collapse = "; ")
[10:24:18.763]                             if (!has_future) {
[10:24:18.763]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.763]                                 info)
[10:24:18.763]                             }
[10:24:18.763]                             else {
[10:24:18.763]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.763]                                 info, version)
[10:24:18.763]                             }
[10:24:18.763]                             base::stop(msg)
[10:24:18.763]                           }
[10:24:18.763]                         })
[10:24:18.763]                       }
[10:24:18.763]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.763]                       base::options(mc.cores = 1L)
[10:24:18.763]                     }
[10:24:18.763]                     base::local({
[10:24:18.763]                       for (pkg in "future.apply") {
[10:24:18.763]                         base::loadNamespace(pkg)
[10:24:18.763]                         base::library(pkg, character.only = TRUE)
[10:24:18.763]                       }
[10:24:18.763]                     })
[10:24:18.763]                   }
[10:24:18.763]                   options(future.plan = NULL)
[10:24:18.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.763]                 }
[10:24:18.763]                 ...future.workdir <- getwd()
[10:24:18.763]             }
[10:24:18.763]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.763]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.763]         }
[10:24:18.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.763]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.763]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.763]             base::names(...future.oldOptions))
[10:24:18.763]     }
[10:24:18.763]     if (FALSE) {
[10:24:18.763]     }
[10:24:18.763]     else {
[10:24:18.763]         if (TRUE) {
[10:24:18.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.763]                 open = "w")
[10:24:18.763]         }
[10:24:18.763]         else {
[10:24:18.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.763]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.763]         }
[10:24:18.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.763]             base::sink(type = "output", split = FALSE)
[10:24:18.763]             base::close(...future.stdout)
[10:24:18.763]         }, add = TRUE)
[10:24:18.763]     }
[10:24:18.763]     ...future.frame <- base::sys.nframe()
[10:24:18.763]     ...future.conditions <- base::list()
[10:24:18.763]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.763]     if (FALSE) {
[10:24:18.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.763]     }
[10:24:18.763]     ...future.result <- base::tryCatch({
[10:24:18.763]         base::withCallingHandlers({
[10:24:18.763]             ...future.value <- base::withVisible(base::local({
[10:24:18.763]                 withCallingHandlers({
[10:24:18.763]                   {
[10:24:18.763]                     do.call(function(...) {
[10:24:18.763]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.763]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.763]                         ...future.globals.maxSize)) {
[10:24:18.763]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.763]                         on.exit(options(oopts), add = TRUE)
[10:24:18.763]                       }
[10:24:18.763]                       {
[10:24:18.763]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.763]                           FUN = function(jj) {
[10:24:18.763]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.763]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.763]                           })
[10:24:18.763]                       }
[10:24:18.763]                     }, args = future.call.arguments)
[10:24:18.763]                   }
[10:24:18.763]                 }, immediateCondition = function(cond) {
[10:24:18.763]                   save_rds <- function (object, pathname, ...) 
[10:24:18.763]                   {
[10:24:18.763]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.763]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.763]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.763]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.763]                         fi_tmp[["mtime"]])
[10:24:18.763]                     }
[10:24:18.763]                     tryCatch({
[10:24:18.763]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.763]                     }, error = function(ex) {
[10:24:18.763]                       msg <- conditionMessage(ex)
[10:24:18.763]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.763]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.763]                         fi_tmp[["mtime"]], msg)
[10:24:18.763]                       ex$message <- msg
[10:24:18.763]                       stop(ex)
[10:24:18.763]                     })
[10:24:18.763]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.763]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.763]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.763]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.763]                       fi <- file.info(pathname)
[10:24:18.763]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.763]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.763]                         fi[["size"]], fi[["mtime"]])
[10:24:18.763]                       stop(msg)
[10:24:18.763]                     }
[10:24:18.763]                     invisible(pathname)
[10:24:18.763]                   }
[10:24:18.763]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.763]                     rootPath = tempdir()) 
[10:24:18.763]                   {
[10:24:18.763]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.763]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.763]                       tmpdir = path, fileext = ".rds")
[10:24:18.763]                     save_rds(obj, file)
[10:24:18.763]                   }
[10:24:18.763]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.763]                   {
[10:24:18.763]                     inherits <- base::inherits
[10:24:18.763]                     invokeRestart <- base::invokeRestart
[10:24:18.763]                     is.null <- base::is.null
[10:24:18.763]                     muffled <- FALSE
[10:24:18.763]                     if (inherits(cond, "message")) {
[10:24:18.763]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.763]                       if (muffled) 
[10:24:18.763]                         invokeRestart("muffleMessage")
[10:24:18.763]                     }
[10:24:18.763]                     else if (inherits(cond, "warning")) {
[10:24:18.763]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.763]                       if (muffled) 
[10:24:18.763]                         invokeRestart("muffleWarning")
[10:24:18.763]                     }
[10:24:18.763]                     else if (inherits(cond, "condition")) {
[10:24:18.763]                       if (!is.null(pattern)) {
[10:24:18.763]                         computeRestarts <- base::computeRestarts
[10:24:18.763]                         grepl <- base::grepl
[10:24:18.763]                         restarts <- computeRestarts(cond)
[10:24:18.763]                         for (restart in restarts) {
[10:24:18.763]                           name <- restart$name
[10:24:18.763]                           if (is.null(name)) 
[10:24:18.763]                             next
[10:24:18.763]                           if (!grepl(pattern, name)) 
[10:24:18.763]                             next
[10:24:18.763]                           invokeRestart(restart)
[10:24:18.763]                           muffled <- TRUE
[10:24:18.763]                           break
[10:24:18.763]                         }
[10:24:18.763]                       }
[10:24:18.763]                     }
[10:24:18.763]                     invisible(muffled)
[10:24:18.763]                   }
[10:24:18.763]                   muffleCondition(cond)
[10:24:18.763]                 })
[10:24:18.763]             }))
[10:24:18.763]             future::FutureResult(value = ...future.value$value, 
[10:24:18.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.763]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.763]                     ...future.globalenv.names))
[10:24:18.763]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.763]         }, condition = base::local({
[10:24:18.763]             c <- base::c
[10:24:18.763]             inherits <- base::inherits
[10:24:18.763]             invokeRestart <- base::invokeRestart
[10:24:18.763]             length <- base::length
[10:24:18.763]             list <- base::list
[10:24:18.763]             seq.int <- base::seq.int
[10:24:18.763]             signalCondition <- base::signalCondition
[10:24:18.763]             sys.calls <- base::sys.calls
[10:24:18.763]             `[[` <- base::`[[`
[10:24:18.763]             `+` <- base::`+`
[10:24:18.763]             `<<-` <- base::`<<-`
[10:24:18.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.763]                   3L)]
[10:24:18.763]             }
[10:24:18.763]             function(cond) {
[10:24:18.763]                 is_error <- inherits(cond, "error")
[10:24:18.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.763]                   NULL)
[10:24:18.763]                 if (is_error) {
[10:24:18.763]                   sessionInformation <- function() {
[10:24:18.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.763]                       search = base::search(), system = base::Sys.info())
[10:24:18.763]                   }
[10:24:18.763]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.763]                     cond$call), session = sessionInformation(), 
[10:24:18.763]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.763]                   signalCondition(cond)
[10:24:18.763]                 }
[10:24:18.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.763]                 "immediateCondition"))) {
[10:24:18.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.763]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.763]                   if (TRUE && !signal) {
[10:24:18.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.763]                     {
[10:24:18.763]                       inherits <- base::inherits
[10:24:18.763]                       invokeRestart <- base::invokeRestart
[10:24:18.763]                       is.null <- base::is.null
[10:24:18.763]                       muffled <- FALSE
[10:24:18.763]                       if (inherits(cond, "message")) {
[10:24:18.763]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.763]                         if (muffled) 
[10:24:18.763]                           invokeRestart("muffleMessage")
[10:24:18.763]                       }
[10:24:18.763]                       else if (inherits(cond, "warning")) {
[10:24:18.763]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.763]                         if (muffled) 
[10:24:18.763]                           invokeRestart("muffleWarning")
[10:24:18.763]                       }
[10:24:18.763]                       else if (inherits(cond, "condition")) {
[10:24:18.763]                         if (!is.null(pattern)) {
[10:24:18.763]                           computeRestarts <- base::computeRestarts
[10:24:18.763]                           grepl <- base::grepl
[10:24:18.763]                           restarts <- computeRestarts(cond)
[10:24:18.763]                           for (restart in restarts) {
[10:24:18.763]                             name <- restart$name
[10:24:18.763]                             if (is.null(name)) 
[10:24:18.763]                               next
[10:24:18.763]                             if (!grepl(pattern, name)) 
[10:24:18.763]                               next
[10:24:18.763]                             invokeRestart(restart)
[10:24:18.763]                             muffled <- TRUE
[10:24:18.763]                             break
[10:24:18.763]                           }
[10:24:18.763]                         }
[10:24:18.763]                       }
[10:24:18.763]                       invisible(muffled)
[10:24:18.763]                     }
[10:24:18.763]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.763]                   }
[10:24:18.763]                 }
[10:24:18.763]                 else {
[10:24:18.763]                   if (TRUE) {
[10:24:18.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.763]                     {
[10:24:18.763]                       inherits <- base::inherits
[10:24:18.763]                       invokeRestart <- base::invokeRestart
[10:24:18.763]                       is.null <- base::is.null
[10:24:18.763]                       muffled <- FALSE
[10:24:18.763]                       if (inherits(cond, "message")) {
[10:24:18.763]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.763]                         if (muffled) 
[10:24:18.763]                           invokeRestart("muffleMessage")
[10:24:18.763]                       }
[10:24:18.763]                       else if (inherits(cond, "warning")) {
[10:24:18.763]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.763]                         if (muffled) 
[10:24:18.763]                           invokeRestart("muffleWarning")
[10:24:18.763]                       }
[10:24:18.763]                       else if (inherits(cond, "condition")) {
[10:24:18.763]                         if (!is.null(pattern)) {
[10:24:18.763]                           computeRestarts <- base::computeRestarts
[10:24:18.763]                           grepl <- base::grepl
[10:24:18.763]                           restarts <- computeRestarts(cond)
[10:24:18.763]                           for (restart in restarts) {
[10:24:18.763]                             name <- restart$name
[10:24:18.763]                             if (is.null(name)) 
[10:24:18.763]                               next
[10:24:18.763]                             if (!grepl(pattern, name)) 
[10:24:18.763]                               next
[10:24:18.763]                             invokeRestart(restart)
[10:24:18.763]                             muffled <- TRUE
[10:24:18.763]                             break
[10:24:18.763]                           }
[10:24:18.763]                         }
[10:24:18.763]                       }
[10:24:18.763]                       invisible(muffled)
[10:24:18.763]                     }
[10:24:18.763]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.763]                   }
[10:24:18.763]                 }
[10:24:18.763]             }
[10:24:18.763]         }))
[10:24:18.763]     }, error = function(ex) {
[10:24:18.763]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.763]                 ...future.rng), started = ...future.startTime, 
[10:24:18.763]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.763]             version = "1.8"), class = "FutureResult")
[10:24:18.763]     }, finally = {
[10:24:18.763]         if (!identical(...future.workdir, getwd())) 
[10:24:18.763]             setwd(...future.workdir)
[10:24:18.763]         {
[10:24:18.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.763]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.763]             }
[10:24:18.763]             base::options(...future.oldOptions)
[10:24:18.763]             if (.Platform$OS.type == "windows") {
[10:24:18.763]                 old_names <- names(...future.oldEnvVars)
[10:24:18.763]                 envs <- base::Sys.getenv()
[10:24:18.763]                 names <- names(envs)
[10:24:18.763]                 common <- intersect(names, old_names)
[10:24:18.763]                 added <- setdiff(names, old_names)
[10:24:18.763]                 removed <- setdiff(old_names, names)
[10:24:18.763]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.763]                   envs[common]]
[10:24:18.763]                 NAMES <- toupper(changed)
[10:24:18.763]                 args <- list()
[10:24:18.763]                 for (kk in seq_along(NAMES)) {
[10:24:18.763]                   name <- changed[[kk]]
[10:24:18.763]                   NAME <- NAMES[[kk]]
[10:24:18.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.763]                     next
[10:24:18.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.763]                 }
[10:24:18.763]                 NAMES <- toupper(added)
[10:24:18.763]                 for (kk in seq_along(NAMES)) {
[10:24:18.763]                   name <- added[[kk]]
[10:24:18.763]                   NAME <- NAMES[[kk]]
[10:24:18.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.763]                     next
[10:24:18.763]                   args[[name]] <- ""
[10:24:18.763]                 }
[10:24:18.763]                 NAMES <- toupper(removed)
[10:24:18.763]                 for (kk in seq_along(NAMES)) {
[10:24:18.763]                   name <- removed[[kk]]
[10:24:18.763]                   NAME <- NAMES[[kk]]
[10:24:18.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.763]                     next
[10:24:18.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.763]                 }
[10:24:18.763]                 if (length(args) > 0) 
[10:24:18.763]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.763]             }
[10:24:18.763]             else {
[10:24:18.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.763]             }
[10:24:18.763]             {
[10:24:18.763]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.763]                   0L) {
[10:24:18.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.763]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.763]                   base::options(opts)
[10:24:18.763]                 }
[10:24:18.763]                 {
[10:24:18.763]                   {
[10:24:18.763]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.763]                     NULL
[10:24:18.763]                   }
[10:24:18.763]                   options(future.plan = NULL)
[10:24:18.763]                   if (is.na(NA_character_)) 
[10:24:18.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.763]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.763]                     envir = parent.frame()) 
[10:24:18.763]                   {
[10:24:18.763]                     default_workers <- missing(workers)
[10:24:18.763]                     if (is.function(workers)) 
[10:24:18.763]                       workers <- workers()
[10:24:18.763]                     workers <- structure(as.integer(workers), 
[10:24:18.763]                       class = class(workers))
[10:24:18.763]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.763]                       1L)
[10:24:18.763]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.763]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.763]                       if (default_workers) 
[10:24:18.763]                         supportsMulticore(warn = TRUE)
[10:24:18.763]                       return(sequential(..., envir = envir))
[10:24:18.763]                     }
[10:24:18.763]                     oopts <- options(mc.cores = workers)
[10:24:18.763]                     on.exit(options(oopts))
[10:24:18.763]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.763]                       envir = envir)
[10:24:18.763]                     if (!future$lazy) 
[10:24:18.763]                       future <- run(future)
[10:24:18.763]                     invisible(future)
[10:24:18.763]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.763]                 }
[10:24:18.763]             }
[10:24:18.763]         }
[10:24:18.763]     })
[10:24:18.763]     if (TRUE) {
[10:24:18.763]         base::sink(type = "output", split = FALSE)
[10:24:18.763]         if (TRUE) {
[10:24:18.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.763]         }
[10:24:18.763]         else {
[10:24:18.763]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.763]         }
[10:24:18.763]         base::close(...future.stdout)
[10:24:18.763]         ...future.stdout <- NULL
[10:24:18.763]     }
[10:24:18.763]     ...future.result$conditions <- ...future.conditions
[10:24:18.763]     ...future.result$finished <- base::Sys.time()
[10:24:18.763]     ...future.result
[10:24:18.763] }
[10:24:18.766] assign_globals() ...
[10:24:18.766] List of 11
[10:24:18.766]  $ ...future.FUN            :function (x, ...)  
[10:24:18.766]  $ x_FUN                    :function (x)  
[10:24:18.766]  $ times                    : int 1
[10:24:18.766]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.766]  $ stop_if_not              :function (...)  
[10:24:18.766]  $ dim                      : NULL
[10:24:18.766]  $ valid_types              : chr "logical"
[10:24:18.766]  $ future.call.arguments    : list()
[10:24:18.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.766]  $ ...future.elements_ii    :List of 6
[10:24:18.766]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[10:24:18.766]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[10:24:18.766]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[10:24:18.766]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[10:24:18.766]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[10:24:18.766]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[10:24:18.766]  $ ...future.seeds_ii       : NULL
[10:24:18.766]  $ ...future.globals.maxSize: NULL
[10:24:18.766]  - attr(*, "where")=List of 11
[10:24:18.766]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.766]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:18.766]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:18.766]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:18.766]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:18.766]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:18.766]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:18.766]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.766]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.766]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.766]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.766]  - attr(*, "resolved")= logi FALSE
[10:24:18.766]  - attr(*, "total_size")= num 94200
[10:24:18.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.766]  - attr(*, "already-done")= logi TRUE
[10:24:18.777] - copied ‘...future.FUN’ to environment
[10:24:18.777] - copied ‘x_FUN’ to environment
[10:24:18.777] - copied ‘times’ to environment
[10:24:18.777] - copied ‘stopf’ to environment
[10:24:18.778] - copied ‘stop_if_not’ to environment
[10:24:18.778] - copied ‘dim’ to environment
[10:24:18.778] - copied ‘valid_types’ to environment
[10:24:18.778] - copied ‘future.call.arguments’ to environment
[10:24:18.778] - copied ‘...future.elements_ii’ to environment
[10:24:18.778] - copied ‘...future.seeds_ii’ to environment
[10:24:18.778] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.778] assign_globals() ... done
[10:24:18.778] requestCore(): workers = 2
[10:24:18.781] MulticoreFuture started
[10:24:18.781] - Launch lazy future ... done
[10:24:18.782] run() for ‘MulticoreFuture’ ... done
[10:24:18.782] Created future:
[10:24:18.783] plan(): Setting new future strategy stack:
[10:24:18.783] List of future strategies:
[10:24:18.783] 1. sequential:
[10:24:18.783]    - args: function (..., envir = parent.frame())
[10:24:18.783]    - tweaked: FALSE
[10:24:18.783]    - call: NULL
[10:24:18.785] plan(): nbrOfWorkers() = 1
[10:24:18.787] plan(): Setting new future strategy stack:
[10:24:18.788] List of future strategies:
[10:24:18.788] 1. multicore:
[10:24:18.788]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.788]    - tweaked: FALSE
[10:24:18.788]    - call: plan(strategy)
[10:24:18.793] plan(): nbrOfWorkers() = 2
[10:24:18.783] MulticoreFuture:
[10:24:18.783] Label: ‘future_vapply-1’
[10:24:18.783] Expression:
[10:24:18.783] {
[10:24:18.783]     do.call(function(...) {
[10:24:18.783]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.783]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.783]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.783]             on.exit(options(oopts), add = TRUE)
[10:24:18.783]         }
[10:24:18.783]         {
[10:24:18.783]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.783]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.783]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.783]             })
[10:24:18.783]         }
[10:24:18.783]     }, args = future.call.arguments)
[10:24:18.783] }
[10:24:18.783] Lazy evaluation: FALSE
[10:24:18.783] Asynchronous evaluation: TRUE
[10:24:18.783] Local evaluation: TRUE
[10:24:18.783] Environment: R_GlobalEnv
[10:24:18.783] Capture standard output: TRUE
[10:24:18.783] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.783] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:18.783] Packages: 1 packages (‘future.apply’)
[10:24:18.783] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.783] Resolved: TRUE
[10:24:18.783] Value: <not collected>
[10:24:18.783] Conditions captured: <none>
[10:24:18.783] Early signaling: FALSE
[10:24:18.783] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.783] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.794] Chunk #1 of 2 ... DONE
[10:24:18.794] Chunk #2 of 2 ...
[10:24:18.794]  - Finding globals in 'X' for chunk #2 ...
[10:24:18.795] getGlobalsAndPackages() ...
[10:24:18.795] Searching for globals...
[10:24:18.795] 
[10:24:18.795] Searching for globals ... DONE
[10:24:18.796] - globals: [0] <none>
[10:24:18.796] getGlobalsAndPackages() ... DONE
[10:24:18.796]    + additional globals found: [n=0] 
[10:24:18.796]    + additional namespaces needed: [n=0] 
[10:24:18.796]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:18.796]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.796]  - seeds: <none>
[10:24:18.797]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.797] getGlobalsAndPackages() ...
[10:24:18.797] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.798] Resolving globals: FALSE
[10:24:18.798] Tweak future expression to call with '...' arguments ...
[10:24:18.798] {
[10:24:18.798]     do.call(function(...) {
[10:24:18.798]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.798]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.798]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.798]             on.exit(options(oopts), add = TRUE)
[10:24:18.798]         }
[10:24:18.798]         {
[10:24:18.798]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.798]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.798]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.798]             })
[10:24:18.798]         }
[10:24:18.798]     }, args = future.call.arguments)
[10:24:18.798] }
[10:24:18.798] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.799] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.800] - packages: [1] ‘future.apply’
[10:24:18.800] getGlobalsAndPackages() ... DONE
[10:24:18.800] run() for ‘Future’ ...
[10:24:18.801] - state: ‘created’
[10:24:18.801] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.805] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.805] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.806]   - Field: ‘label’
[10:24:18.806]   - Field: ‘local’
[10:24:18.806]   - Field: ‘owner’
[10:24:18.806]   - Field: ‘envir’
[10:24:18.806]   - Field: ‘workers’
[10:24:18.806]   - Field: ‘packages’
[10:24:18.807]   - Field: ‘gc’
[10:24:18.807]   - Field: ‘job’
[10:24:18.807]   - Field: ‘conditions’
[10:24:18.807]   - Field: ‘expr’
[10:24:18.807]   - Field: ‘uuid’
[10:24:18.807]   - Field: ‘seed’
[10:24:18.807]   - Field: ‘version’
[10:24:18.808]   - Field: ‘result’
[10:24:18.808]   - Field: ‘asynchronous’
[10:24:18.808]   - Field: ‘calls’
[10:24:18.808]   - Field: ‘globals’
[10:24:18.808]   - Field: ‘stdout’
[10:24:18.808]   - Field: ‘earlySignal’
[10:24:18.808]   - Field: ‘lazy’
[10:24:18.808]   - Field: ‘state’
[10:24:18.809] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.809] - Launch lazy future ...
[10:24:18.809] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:18.809] Packages needed by future strategies (n = 0): <none>
[10:24:18.810] {
[10:24:18.810]     {
[10:24:18.810]         {
[10:24:18.810]             ...future.startTime <- base::Sys.time()
[10:24:18.810]             {
[10:24:18.810]                 {
[10:24:18.810]                   {
[10:24:18.810]                     {
[10:24:18.810]                       {
[10:24:18.810]                         base::local({
[10:24:18.810]                           has_future <- base::requireNamespace("future", 
[10:24:18.810]                             quietly = TRUE)
[10:24:18.810]                           if (has_future) {
[10:24:18.810]                             ns <- base::getNamespace("future")
[10:24:18.810]                             version <- ns[[".package"]][["version"]]
[10:24:18.810]                             if (is.null(version)) 
[10:24:18.810]                               version <- utils::packageVersion("future")
[10:24:18.810]                           }
[10:24:18.810]                           else {
[10:24:18.810]                             version <- NULL
[10:24:18.810]                           }
[10:24:18.810]                           if (!has_future || version < "1.8.0") {
[10:24:18.810]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.810]                               "", base::R.version$version.string), 
[10:24:18.810]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.810]                                 base::R.version$platform, 8 * 
[10:24:18.810]                                   base::.Machine$sizeof.pointer), 
[10:24:18.810]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.810]                                 "release", "version")], collapse = " "), 
[10:24:18.810]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.810]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.810]                               info)
[10:24:18.810]                             info <- base::paste(info, collapse = "; ")
[10:24:18.810]                             if (!has_future) {
[10:24:18.810]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.810]                                 info)
[10:24:18.810]                             }
[10:24:18.810]                             else {
[10:24:18.810]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.810]                                 info, version)
[10:24:18.810]                             }
[10:24:18.810]                             base::stop(msg)
[10:24:18.810]                           }
[10:24:18.810]                         })
[10:24:18.810]                       }
[10:24:18.810]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.810]                       base::options(mc.cores = 1L)
[10:24:18.810]                     }
[10:24:18.810]                     base::local({
[10:24:18.810]                       for (pkg in "future.apply") {
[10:24:18.810]                         base::loadNamespace(pkg)
[10:24:18.810]                         base::library(pkg, character.only = TRUE)
[10:24:18.810]                       }
[10:24:18.810]                     })
[10:24:18.810]                   }
[10:24:18.810]                   options(future.plan = NULL)
[10:24:18.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.810]                 }
[10:24:18.810]                 ...future.workdir <- getwd()
[10:24:18.810]             }
[10:24:18.810]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.810]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.810]         }
[10:24:18.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.810]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.810]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.810]             base::names(...future.oldOptions))
[10:24:18.810]     }
[10:24:18.810]     if (FALSE) {
[10:24:18.810]     }
[10:24:18.810]     else {
[10:24:18.810]         if (TRUE) {
[10:24:18.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.810]                 open = "w")
[10:24:18.810]         }
[10:24:18.810]         else {
[10:24:18.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.810]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.810]         }
[10:24:18.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.810]             base::sink(type = "output", split = FALSE)
[10:24:18.810]             base::close(...future.stdout)
[10:24:18.810]         }, add = TRUE)
[10:24:18.810]     }
[10:24:18.810]     ...future.frame <- base::sys.nframe()
[10:24:18.810]     ...future.conditions <- base::list()
[10:24:18.810]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.810]     if (FALSE) {
[10:24:18.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.810]     }
[10:24:18.810]     ...future.result <- base::tryCatch({
[10:24:18.810]         base::withCallingHandlers({
[10:24:18.810]             ...future.value <- base::withVisible(base::local({
[10:24:18.810]                 withCallingHandlers({
[10:24:18.810]                   {
[10:24:18.810]                     do.call(function(...) {
[10:24:18.810]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.810]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.810]                         ...future.globals.maxSize)) {
[10:24:18.810]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.810]                         on.exit(options(oopts), add = TRUE)
[10:24:18.810]                       }
[10:24:18.810]                       {
[10:24:18.810]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.810]                           FUN = function(jj) {
[10:24:18.810]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.810]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.810]                           })
[10:24:18.810]                       }
[10:24:18.810]                     }, args = future.call.arguments)
[10:24:18.810]                   }
[10:24:18.810]                 }, immediateCondition = function(cond) {
[10:24:18.810]                   save_rds <- function (object, pathname, ...) 
[10:24:18.810]                   {
[10:24:18.810]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.810]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.810]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.810]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.810]                         fi_tmp[["mtime"]])
[10:24:18.810]                     }
[10:24:18.810]                     tryCatch({
[10:24:18.810]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.810]                     }, error = function(ex) {
[10:24:18.810]                       msg <- conditionMessage(ex)
[10:24:18.810]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.810]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.810]                         fi_tmp[["mtime"]], msg)
[10:24:18.810]                       ex$message <- msg
[10:24:18.810]                       stop(ex)
[10:24:18.810]                     })
[10:24:18.810]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.810]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.810]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.810]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.810]                       fi <- file.info(pathname)
[10:24:18.810]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.810]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.810]                         fi[["size"]], fi[["mtime"]])
[10:24:18.810]                       stop(msg)
[10:24:18.810]                     }
[10:24:18.810]                     invisible(pathname)
[10:24:18.810]                   }
[10:24:18.810]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.810]                     rootPath = tempdir()) 
[10:24:18.810]                   {
[10:24:18.810]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.810]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.810]                       tmpdir = path, fileext = ".rds")
[10:24:18.810]                     save_rds(obj, file)
[10:24:18.810]                   }
[10:24:18.810]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.810]                   {
[10:24:18.810]                     inherits <- base::inherits
[10:24:18.810]                     invokeRestart <- base::invokeRestart
[10:24:18.810]                     is.null <- base::is.null
[10:24:18.810]                     muffled <- FALSE
[10:24:18.810]                     if (inherits(cond, "message")) {
[10:24:18.810]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.810]                       if (muffled) 
[10:24:18.810]                         invokeRestart("muffleMessage")
[10:24:18.810]                     }
[10:24:18.810]                     else if (inherits(cond, "warning")) {
[10:24:18.810]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.810]                       if (muffled) 
[10:24:18.810]                         invokeRestart("muffleWarning")
[10:24:18.810]                     }
[10:24:18.810]                     else if (inherits(cond, "condition")) {
[10:24:18.810]                       if (!is.null(pattern)) {
[10:24:18.810]                         computeRestarts <- base::computeRestarts
[10:24:18.810]                         grepl <- base::grepl
[10:24:18.810]                         restarts <- computeRestarts(cond)
[10:24:18.810]                         for (restart in restarts) {
[10:24:18.810]                           name <- restart$name
[10:24:18.810]                           if (is.null(name)) 
[10:24:18.810]                             next
[10:24:18.810]                           if (!grepl(pattern, name)) 
[10:24:18.810]                             next
[10:24:18.810]                           invokeRestart(restart)
[10:24:18.810]                           muffled <- TRUE
[10:24:18.810]                           break
[10:24:18.810]                         }
[10:24:18.810]                       }
[10:24:18.810]                     }
[10:24:18.810]                     invisible(muffled)
[10:24:18.810]                   }
[10:24:18.810]                   muffleCondition(cond)
[10:24:18.810]                 })
[10:24:18.810]             }))
[10:24:18.810]             future::FutureResult(value = ...future.value$value, 
[10:24:18.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.810]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.810]                     ...future.globalenv.names))
[10:24:18.810]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.810]         }, condition = base::local({
[10:24:18.810]             c <- base::c
[10:24:18.810]             inherits <- base::inherits
[10:24:18.810]             invokeRestart <- base::invokeRestart
[10:24:18.810]             length <- base::length
[10:24:18.810]             list <- base::list
[10:24:18.810]             seq.int <- base::seq.int
[10:24:18.810]             signalCondition <- base::signalCondition
[10:24:18.810]             sys.calls <- base::sys.calls
[10:24:18.810]             `[[` <- base::`[[`
[10:24:18.810]             `+` <- base::`+`
[10:24:18.810]             `<<-` <- base::`<<-`
[10:24:18.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.810]                   3L)]
[10:24:18.810]             }
[10:24:18.810]             function(cond) {
[10:24:18.810]                 is_error <- inherits(cond, "error")
[10:24:18.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.810]                   NULL)
[10:24:18.810]                 if (is_error) {
[10:24:18.810]                   sessionInformation <- function() {
[10:24:18.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.810]                       search = base::search(), system = base::Sys.info())
[10:24:18.810]                   }
[10:24:18.810]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.810]                     cond$call), session = sessionInformation(), 
[10:24:18.810]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.810]                   signalCondition(cond)
[10:24:18.810]                 }
[10:24:18.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.810]                 "immediateCondition"))) {
[10:24:18.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.810]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.810]                   if (TRUE && !signal) {
[10:24:18.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.810]                     {
[10:24:18.810]                       inherits <- base::inherits
[10:24:18.810]                       invokeRestart <- base::invokeRestart
[10:24:18.810]                       is.null <- base::is.null
[10:24:18.810]                       muffled <- FALSE
[10:24:18.810]                       if (inherits(cond, "message")) {
[10:24:18.810]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.810]                         if (muffled) 
[10:24:18.810]                           invokeRestart("muffleMessage")
[10:24:18.810]                       }
[10:24:18.810]                       else if (inherits(cond, "warning")) {
[10:24:18.810]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.810]                         if (muffled) 
[10:24:18.810]                           invokeRestart("muffleWarning")
[10:24:18.810]                       }
[10:24:18.810]                       else if (inherits(cond, "condition")) {
[10:24:18.810]                         if (!is.null(pattern)) {
[10:24:18.810]                           computeRestarts <- base::computeRestarts
[10:24:18.810]                           grepl <- base::grepl
[10:24:18.810]                           restarts <- computeRestarts(cond)
[10:24:18.810]                           for (restart in restarts) {
[10:24:18.810]                             name <- restart$name
[10:24:18.810]                             if (is.null(name)) 
[10:24:18.810]                               next
[10:24:18.810]                             if (!grepl(pattern, name)) 
[10:24:18.810]                               next
[10:24:18.810]                             invokeRestart(restart)
[10:24:18.810]                             muffled <- TRUE
[10:24:18.810]                             break
[10:24:18.810]                           }
[10:24:18.810]                         }
[10:24:18.810]                       }
[10:24:18.810]                       invisible(muffled)
[10:24:18.810]                     }
[10:24:18.810]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.810]                   }
[10:24:18.810]                 }
[10:24:18.810]                 else {
[10:24:18.810]                   if (TRUE) {
[10:24:18.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.810]                     {
[10:24:18.810]                       inherits <- base::inherits
[10:24:18.810]                       invokeRestart <- base::invokeRestart
[10:24:18.810]                       is.null <- base::is.null
[10:24:18.810]                       muffled <- FALSE
[10:24:18.810]                       if (inherits(cond, "message")) {
[10:24:18.810]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.810]                         if (muffled) 
[10:24:18.810]                           invokeRestart("muffleMessage")
[10:24:18.810]                       }
[10:24:18.810]                       else if (inherits(cond, "warning")) {
[10:24:18.810]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.810]                         if (muffled) 
[10:24:18.810]                           invokeRestart("muffleWarning")
[10:24:18.810]                       }
[10:24:18.810]                       else if (inherits(cond, "condition")) {
[10:24:18.810]                         if (!is.null(pattern)) {
[10:24:18.810]                           computeRestarts <- base::computeRestarts
[10:24:18.810]                           grepl <- base::grepl
[10:24:18.810]                           restarts <- computeRestarts(cond)
[10:24:18.810]                           for (restart in restarts) {
[10:24:18.810]                             name <- restart$name
[10:24:18.810]                             if (is.null(name)) 
[10:24:18.810]                               next
[10:24:18.810]                             if (!grepl(pattern, name)) 
[10:24:18.810]                               next
[10:24:18.810]                             invokeRestart(restart)
[10:24:18.810]                             muffled <- TRUE
[10:24:18.810]                             break
[10:24:18.810]                           }
[10:24:18.810]                         }
[10:24:18.810]                       }
[10:24:18.810]                       invisible(muffled)
[10:24:18.810]                     }
[10:24:18.810]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.810]                   }
[10:24:18.810]                 }
[10:24:18.810]             }
[10:24:18.810]         }))
[10:24:18.810]     }, error = function(ex) {
[10:24:18.810]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.810]                 ...future.rng), started = ...future.startTime, 
[10:24:18.810]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.810]             version = "1.8"), class = "FutureResult")
[10:24:18.810]     }, finally = {
[10:24:18.810]         if (!identical(...future.workdir, getwd())) 
[10:24:18.810]             setwd(...future.workdir)
[10:24:18.810]         {
[10:24:18.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.810]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.810]             }
[10:24:18.810]             base::options(...future.oldOptions)
[10:24:18.810]             if (.Platform$OS.type == "windows") {
[10:24:18.810]                 old_names <- names(...future.oldEnvVars)
[10:24:18.810]                 envs <- base::Sys.getenv()
[10:24:18.810]                 names <- names(envs)
[10:24:18.810]                 common <- intersect(names, old_names)
[10:24:18.810]                 added <- setdiff(names, old_names)
[10:24:18.810]                 removed <- setdiff(old_names, names)
[10:24:18.810]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.810]                   envs[common]]
[10:24:18.810]                 NAMES <- toupper(changed)
[10:24:18.810]                 args <- list()
[10:24:18.810]                 for (kk in seq_along(NAMES)) {
[10:24:18.810]                   name <- changed[[kk]]
[10:24:18.810]                   NAME <- NAMES[[kk]]
[10:24:18.810]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.810]                     next
[10:24:18.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.810]                 }
[10:24:18.810]                 NAMES <- toupper(added)
[10:24:18.810]                 for (kk in seq_along(NAMES)) {
[10:24:18.810]                   name <- added[[kk]]
[10:24:18.810]                   NAME <- NAMES[[kk]]
[10:24:18.810]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.810]                     next
[10:24:18.810]                   args[[name]] <- ""
[10:24:18.810]                 }
[10:24:18.810]                 NAMES <- toupper(removed)
[10:24:18.810]                 for (kk in seq_along(NAMES)) {
[10:24:18.810]                   name <- removed[[kk]]
[10:24:18.810]                   NAME <- NAMES[[kk]]
[10:24:18.810]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.810]                     next
[10:24:18.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.810]                 }
[10:24:18.810]                 if (length(args) > 0) 
[10:24:18.810]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.810]             }
[10:24:18.810]             else {
[10:24:18.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.810]             }
[10:24:18.810]             {
[10:24:18.810]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.810]                   0L) {
[10:24:18.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.810]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.810]                   base::options(opts)
[10:24:18.810]                 }
[10:24:18.810]                 {
[10:24:18.810]                   {
[10:24:18.810]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.810]                     NULL
[10:24:18.810]                   }
[10:24:18.810]                   options(future.plan = NULL)
[10:24:18.810]                   if (is.na(NA_character_)) 
[10:24:18.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.810]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.810]                     envir = parent.frame()) 
[10:24:18.810]                   {
[10:24:18.810]                     default_workers <- missing(workers)
[10:24:18.810]                     if (is.function(workers)) 
[10:24:18.810]                       workers <- workers()
[10:24:18.810]                     workers <- structure(as.integer(workers), 
[10:24:18.810]                       class = class(workers))
[10:24:18.810]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.810]                       1L)
[10:24:18.810]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.810]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.810]                       if (default_workers) 
[10:24:18.810]                         supportsMulticore(warn = TRUE)
[10:24:18.810]                       return(sequential(..., envir = envir))
[10:24:18.810]                     }
[10:24:18.810]                     oopts <- options(mc.cores = workers)
[10:24:18.810]                     on.exit(options(oopts))
[10:24:18.810]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.810]                       envir = envir)
[10:24:18.810]                     if (!future$lazy) 
[10:24:18.810]                       future <- run(future)
[10:24:18.810]                     invisible(future)
[10:24:18.810]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.810]                 }
[10:24:18.810]             }
[10:24:18.810]         }
[10:24:18.810]     })
[10:24:18.810]     if (TRUE) {
[10:24:18.810]         base::sink(type = "output", split = FALSE)
[10:24:18.810]         if (TRUE) {
[10:24:18.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.810]         }
[10:24:18.810]         else {
[10:24:18.810]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.810]         }
[10:24:18.810]         base::close(...future.stdout)
[10:24:18.810]         ...future.stdout <- NULL
[10:24:18.810]     }
[10:24:18.810]     ...future.result$conditions <- ...future.conditions
[10:24:18.810]     ...future.result$finished <- base::Sys.time()
[10:24:18.810]     ...future.result
[10:24:18.810] }
[10:24:18.814] assign_globals() ...
[10:24:18.814] List of 11
[10:24:18.814]  $ ...future.FUN            :function (x, ...)  
[10:24:18.814]  $ x_FUN                    :function (x)  
[10:24:18.814]  $ times                    : int 1
[10:24:18.814]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.814]  $ stop_if_not              :function (...)  
[10:24:18.814]  $ dim                      : NULL
[10:24:18.814]  $ valid_types              : chr "logical"
[10:24:18.814]  $ future.call.arguments    : list()
[10:24:18.814]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.814]  $ ...future.elements_ii    :List of 5
[10:24:18.814]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[10:24:18.814]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[10:24:18.814]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[10:24:18.814]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[10:24:18.814]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[10:24:18.814]  $ ...future.seeds_ii       : NULL
[10:24:18.814]  $ ...future.globals.maxSize: NULL
[10:24:18.814]  - attr(*, "where")=List of 11
[10:24:18.814]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.814]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:18.814]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:18.814]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:18.814]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:18.814]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:18.814]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:18.814]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.814]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.814]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.814]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.814]  - attr(*, "resolved")= logi FALSE
[10:24:18.814]  - attr(*, "total_size")= num 94200
[10:24:18.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.814]  - attr(*, "already-done")= logi TRUE
[10:24:18.830] - copied ‘...future.FUN’ to environment
[10:24:18.830] - copied ‘x_FUN’ to environment
[10:24:18.830] - copied ‘times’ to environment
[10:24:18.830] - copied ‘stopf’ to environment
[10:24:18.830] - copied ‘stop_if_not’ to environment
[10:24:18.830] - copied ‘dim’ to environment
[10:24:18.830] - copied ‘valid_types’ to environment
[10:24:18.830] - copied ‘future.call.arguments’ to environment
[10:24:18.830] - copied ‘...future.elements_ii’ to environment
[10:24:18.831] - copied ‘...future.seeds_ii’ to environment
[10:24:18.831] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.831] assign_globals() ... done
[10:24:18.831] requestCore(): workers = 2
[10:24:18.833] MulticoreFuture started
[10:24:18.834] - Launch lazy future ... done
[10:24:18.834] run() for ‘MulticoreFuture’ ... done
[10:24:18.835] Created future:
[10:24:18.835] plan(): Setting new future strategy stack:
[10:24:18.835] List of future strategies:
[10:24:18.835] 1. sequential:
[10:24:18.835]    - args: function (..., envir = parent.frame())
[10:24:18.835]    - tweaked: FALSE
[10:24:18.835]    - call: NULL
[10:24:18.836] plan(): nbrOfWorkers() = 1
[10:24:18.838] plan(): Setting new future strategy stack:
[10:24:18.838] List of future strategies:
[10:24:18.838] 1. multicore:
[10:24:18.838]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.838]    - tweaked: FALSE
[10:24:18.838]    - call: plan(strategy)
[10:24:18.844] plan(): nbrOfWorkers() = 2
[10:24:18.835] MulticoreFuture:
[10:24:18.835] Label: ‘future_vapply-2’
[10:24:18.835] Expression:
[10:24:18.835] {
[10:24:18.835]     do.call(function(...) {
[10:24:18.835]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.835]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.835]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.835]             on.exit(options(oopts), add = TRUE)
[10:24:18.835]         }
[10:24:18.835]         {
[10:24:18.835]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.835]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.835]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.835]             })
[10:24:18.835]         }
[10:24:18.835]     }, args = future.call.arguments)
[10:24:18.835] }
[10:24:18.835] Lazy evaluation: FALSE
[10:24:18.835] Asynchronous evaluation: TRUE
[10:24:18.835] Local evaluation: TRUE
[10:24:18.835] Environment: R_GlobalEnv
[10:24:18.835] Capture standard output: TRUE
[10:24:18.835] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.835] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:18.835] Packages: 1 packages (‘future.apply’)
[10:24:18.835] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.835] Resolved: TRUE
[10:24:18.835] Value: <not collected>
[10:24:18.835] Conditions captured: <none>
[10:24:18.835] Early signaling: FALSE
[10:24:18.835] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.835] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.845] Chunk #2 of 2 ... DONE
[10:24:18.845] Launching 2 futures (chunks) ... DONE
[10:24:18.846] Resolving 2 futures (chunks) ...
[10:24:18.846] resolve() on list ...
[10:24:18.846]  recursive: 0
[10:24:18.846]  length: 2
[10:24:18.846] 
[10:24:18.847] Future #1
[10:24:18.847] result() for MulticoreFuture ...
[10:24:18.848] result() for MulticoreFuture ...
[10:24:18.848] result() for MulticoreFuture ... done
[10:24:18.848] result() for MulticoreFuture ... done
[10:24:18.848] result() for MulticoreFuture ...
[10:24:18.848] result() for MulticoreFuture ... done
[10:24:18.849] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:18.849] - nx: 2
[10:24:18.849] - relay: TRUE
[10:24:18.849] - stdout: TRUE
[10:24:18.849] - signal: TRUE
[10:24:18.850] - resignal: FALSE
[10:24:18.850] - force: TRUE
[10:24:18.850] - relayed: [n=2] FALSE, FALSE
[10:24:18.850] - queued futures: [n=2] FALSE, FALSE
[10:24:18.850]  - until=1
[10:24:18.850]  - relaying element #1
[10:24:18.851] result() for MulticoreFuture ...
[10:24:18.851] result() for MulticoreFuture ... done
[10:24:18.851] result() for MulticoreFuture ...
[10:24:18.851] result() for MulticoreFuture ... done
[10:24:18.851] result() for MulticoreFuture ...
[10:24:18.851] result() for MulticoreFuture ... done
[10:24:18.852] result() for MulticoreFuture ...
[10:24:18.852] result() for MulticoreFuture ... done
[10:24:18.852] - relayed: [n=2] TRUE, FALSE
[10:24:18.852] - queued futures: [n=2] TRUE, FALSE
[10:24:18.852] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:18.852]  length: 1 (resolved future 1)
[10:24:18.853] Future #2
[10:24:18.853] result() for MulticoreFuture ...
[10:24:18.854] result() for MulticoreFuture ...
[10:24:18.854] result() for MulticoreFuture ... done
[10:24:18.854] result() for MulticoreFuture ... done
[10:24:18.854] result() for MulticoreFuture ...
[10:24:18.854] result() for MulticoreFuture ... done
[10:24:18.854] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:18.855] - nx: 2
[10:24:18.855] - relay: TRUE
[10:24:18.855] - stdout: TRUE
[10:24:18.855] - signal: TRUE
[10:24:18.855] - resignal: FALSE
[10:24:18.855] - force: TRUE
[10:24:18.855] - relayed: [n=2] TRUE, FALSE
[10:24:18.856] - queued futures: [n=2] TRUE, FALSE
[10:24:18.856]  - until=2
[10:24:18.856]  - relaying element #2
[10:24:18.856] result() for MulticoreFuture ...
[10:24:18.856] result() for MulticoreFuture ... done
[10:24:18.860] result() for MulticoreFuture ...
[10:24:18.860] result() for MulticoreFuture ... done
[10:24:18.861] result() for MulticoreFuture ...
[10:24:18.861] result() for MulticoreFuture ... done
[10:24:18.861] result() for MulticoreFuture ...
[10:24:18.861] result() for MulticoreFuture ... done
[10:24:18.861] - relayed: [n=2] TRUE, TRUE
[10:24:18.861] - queued futures: [n=2] TRUE, TRUE
[10:24:18.861] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:18.861]  length: 0 (resolved future 2)
[10:24:18.861] Relaying remaining futures
[10:24:18.862] signalConditionsASAP(NULL, pos=0) ...
[10:24:18.862] - nx: 2
[10:24:18.862] - relay: TRUE
[10:24:18.862] - stdout: TRUE
[10:24:18.862] - signal: TRUE
[10:24:18.862] - resignal: FALSE
[10:24:18.862] - force: TRUE
[10:24:18.862] - relayed: [n=2] TRUE, TRUE
[10:24:18.863] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:18.863] - relayed: [n=2] TRUE, TRUE
[10:24:18.863] - queued futures: [n=2] TRUE, TRUE
[10:24:18.863] signalConditionsASAP(NULL, pos=0) ... done
[10:24:18.863] resolve() on list ... DONE
[10:24:18.863] result() for MulticoreFuture ...
[10:24:18.863] result() for MulticoreFuture ... done
[10:24:18.864] result() for MulticoreFuture ...
[10:24:18.864] result() for MulticoreFuture ... done
[10:24:18.864] result() for MulticoreFuture ...
[10:24:18.864] result() for MulticoreFuture ... done
[10:24:18.864] result() for MulticoreFuture ...
[10:24:18.864] result() for MulticoreFuture ... done
[10:24:18.865]  - Number of value chunks collected: 2
[10:24:18.865] Resolving 2 futures (chunks) ... DONE
[10:24:18.865] Reducing values from 2 chunks ...
[10:24:18.865]  - Number of values collected after concatenation: 11
[10:24:18.865]  - Number of values expected: 11
[10:24:18.865] Reducing values from 2 chunks ... DONE
[10:24:18.865] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[10:24:18.867] future_lapply() ...
[10:24:18.874] Number of chunks: 2
[10:24:18.874] getGlobalsAndPackagesXApply() ...
[10:24:18.874]  - future.globals: TRUE
[10:24:18.874] getGlobalsAndPackages() ...
[10:24:18.874] Searching for globals...
[10:24:18.878] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:18.878] Searching for globals ... DONE
[10:24:18.878] Resolving globals: FALSE
[10:24:18.879] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[10:24:18.879] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:18.879] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:18.880] - packages: [1] ‘future.apply’
[10:24:18.880] getGlobalsAndPackages() ... DONE
[10:24:18.880]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:18.880]  - needed namespaces: [n=1] ‘future.apply’
[10:24:18.880] Finding globals ... DONE
[10:24:18.880]  - use_args: TRUE
[10:24:18.880]  - Getting '...' globals ...
[10:24:18.880] resolve() on list ...
[10:24:18.881]  recursive: 0
[10:24:18.881]  length: 1
[10:24:18.881]  elements: ‘...’
[10:24:18.881]  length: 0 (resolved future 1)
[10:24:18.881] resolve() on list ... DONE
[10:24:18.881]    - '...' content: [n=0] 
[10:24:18.881] List of 1
[10:24:18.881]  $ ...: list()
[10:24:18.881]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.881]  - attr(*, "where")=List of 1
[10:24:18.881]   ..$ ...:<environment: 0x55b93ce4d340> 
[10:24:18.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.881]  - attr(*, "resolved")= logi TRUE
[10:24:18.881]  - attr(*, "total_size")= num NA
[10:24:18.884]  - Getting '...' globals ... DONE
[10:24:18.884] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:18.884] List of 8
[10:24:18.884]  $ ...future.FUN:function (x, ...)  
[10:24:18.884]  $ x_FUN        :function (x)  
[10:24:18.884]  $ times        : int 1
[10:24:18.884]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.884]  $ stop_if_not  :function (...)  
[10:24:18.884]  $ dim          : NULL
[10:24:18.884]  $ valid_types  : chr [1:2] "logical" "integer"
[10:24:18.884]  $ ...          : list()
[10:24:18.884]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.884]  - attr(*, "where")=List of 8
[10:24:18.884]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:18.884]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:18.884]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:18.884]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:18.884]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:18.884]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:18.884]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:18.884]   ..$ ...          :<environment: 0x55b93ce4d340> 
[10:24:18.884]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.884]  - attr(*, "resolved")= logi FALSE
[10:24:18.884]  - attr(*, "total_size")= num 94264
[10:24:18.892] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:18.893] getGlobalsAndPackagesXApply() ... DONE
[10:24:18.893] Number of futures (= number of chunks): 2
[10:24:18.893] Launching 2 futures (chunks) ...
[10:24:18.893] Chunk #1 of 2 ...
[10:24:18.893]  - Finding globals in 'X' for chunk #1 ...
[10:24:18.893] getGlobalsAndPackages() ...
[10:24:18.893] Searching for globals...
[10:24:18.894] 
[10:24:18.894] Searching for globals ... DONE
[10:24:18.894] - globals: [0] <none>
[10:24:18.894] getGlobalsAndPackages() ... DONE
[10:24:18.894]    + additional globals found: [n=0] 
[10:24:18.894]    + additional namespaces needed: [n=0] 
[10:24:18.894]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:18.894]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.895]  - seeds: <none>
[10:24:18.895]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.895] getGlobalsAndPackages() ...
[10:24:18.895] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.895] Resolving globals: FALSE
[10:24:18.895] Tweak future expression to call with '...' arguments ...
[10:24:18.895] {
[10:24:18.895]     do.call(function(...) {
[10:24:18.895]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.895]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.895]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.895]             on.exit(options(oopts), add = TRUE)
[10:24:18.895]         }
[10:24:18.895]         {
[10:24:18.895]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.895]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.895]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.895]             })
[10:24:18.895]         }
[10:24:18.895]     }, args = future.call.arguments)
[10:24:18.895] }
[10:24:18.895] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.896] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.896] - packages: [1] ‘future.apply’
[10:24:18.896] getGlobalsAndPackages() ... DONE
[10:24:18.897] run() for ‘Future’ ...
[10:24:18.897] - state: ‘created’
[10:24:18.897] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.900] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.901]   - Field: ‘label’
[10:24:18.901]   - Field: ‘local’
[10:24:18.901]   - Field: ‘owner’
[10:24:18.901]   - Field: ‘envir’
[10:24:18.901]   - Field: ‘workers’
[10:24:18.901]   - Field: ‘packages’
[10:24:18.901]   - Field: ‘gc’
[10:24:18.901]   - Field: ‘job’
[10:24:18.902]   - Field: ‘conditions’
[10:24:18.902]   - Field: ‘expr’
[10:24:18.902]   - Field: ‘uuid’
[10:24:18.902]   - Field: ‘seed’
[10:24:18.902]   - Field: ‘version’
[10:24:18.902]   - Field: ‘result’
[10:24:18.902]   - Field: ‘asynchronous’
[10:24:18.902]   - Field: ‘calls’
[10:24:18.902]   - Field: ‘globals’
[10:24:18.902]   - Field: ‘stdout’
[10:24:18.902]   - Field: ‘earlySignal’
[10:24:18.903]   - Field: ‘lazy’
[10:24:18.903]   - Field: ‘state’
[10:24:18.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.903] - Launch lazy future ...
[10:24:18.903] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:18.903] Packages needed by future strategies (n = 0): <none>
[10:24:18.904] {
[10:24:18.904]     {
[10:24:18.904]         {
[10:24:18.904]             ...future.startTime <- base::Sys.time()
[10:24:18.904]             {
[10:24:18.904]                 {
[10:24:18.904]                   {
[10:24:18.904]                     {
[10:24:18.904]                       {
[10:24:18.904]                         base::local({
[10:24:18.904]                           has_future <- base::requireNamespace("future", 
[10:24:18.904]                             quietly = TRUE)
[10:24:18.904]                           if (has_future) {
[10:24:18.904]                             ns <- base::getNamespace("future")
[10:24:18.904]                             version <- ns[[".package"]][["version"]]
[10:24:18.904]                             if (is.null(version)) 
[10:24:18.904]                               version <- utils::packageVersion("future")
[10:24:18.904]                           }
[10:24:18.904]                           else {
[10:24:18.904]                             version <- NULL
[10:24:18.904]                           }
[10:24:18.904]                           if (!has_future || version < "1.8.0") {
[10:24:18.904]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.904]                               "", base::R.version$version.string), 
[10:24:18.904]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.904]                                 base::R.version$platform, 8 * 
[10:24:18.904]                                   base::.Machine$sizeof.pointer), 
[10:24:18.904]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.904]                                 "release", "version")], collapse = " "), 
[10:24:18.904]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.904]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.904]                               info)
[10:24:18.904]                             info <- base::paste(info, collapse = "; ")
[10:24:18.904]                             if (!has_future) {
[10:24:18.904]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.904]                                 info)
[10:24:18.904]                             }
[10:24:18.904]                             else {
[10:24:18.904]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.904]                                 info, version)
[10:24:18.904]                             }
[10:24:18.904]                             base::stop(msg)
[10:24:18.904]                           }
[10:24:18.904]                         })
[10:24:18.904]                       }
[10:24:18.904]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.904]                       base::options(mc.cores = 1L)
[10:24:18.904]                     }
[10:24:18.904]                     base::local({
[10:24:18.904]                       for (pkg in "future.apply") {
[10:24:18.904]                         base::loadNamespace(pkg)
[10:24:18.904]                         base::library(pkg, character.only = TRUE)
[10:24:18.904]                       }
[10:24:18.904]                     })
[10:24:18.904]                   }
[10:24:18.904]                   options(future.plan = NULL)
[10:24:18.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.904]                 }
[10:24:18.904]                 ...future.workdir <- getwd()
[10:24:18.904]             }
[10:24:18.904]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.904]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.904]         }
[10:24:18.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.904]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.904]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.904]             base::names(...future.oldOptions))
[10:24:18.904]     }
[10:24:18.904]     if (FALSE) {
[10:24:18.904]     }
[10:24:18.904]     else {
[10:24:18.904]         if (TRUE) {
[10:24:18.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.904]                 open = "w")
[10:24:18.904]         }
[10:24:18.904]         else {
[10:24:18.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.904]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.904]         }
[10:24:18.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.904]             base::sink(type = "output", split = FALSE)
[10:24:18.904]             base::close(...future.stdout)
[10:24:18.904]         }, add = TRUE)
[10:24:18.904]     }
[10:24:18.904]     ...future.frame <- base::sys.nframe()
[10:24:18.904]     ...future.conditions <- base::list()
[10:24:18.904]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.904]     if (FALSE) {
[10:24:18.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.904]     }
[10:24:18.904]     ...future.result <- base::tryCatch({
[10:24:18.904]         base::withCallingHandlers({
[10:24:18.904]             ...future.value <- base::withVisible(base::local({
[10:24:18.904]                 withCallingHandlers({
[10:24:18.904]                   {
[10:24:18.904]                     do.call(function(...) {
[10:24:18.904]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.904]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.904]                         ...future.globals.maxSize)) {
[10:24:18.904]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.904]                         on.exit(options(oopts), add = TRUE)
[10:24:18.904]                       }
[10:24:18.904]                       {
[10:24:18.904]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.904]                           FUN = function(jj) {
[10:24:18.904]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.904]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.904]                           })
[10:24:18.904]                       }
[10:24:18.904]                     }, args = future.call.arguments)
[10:24:18.904]                   }
[10:24:18.904]                 }, immediateCondition = function(cond) {
[10:24:18.904]                   save_rds <- function (object, pathname, ...) 
[10:24:18.904]                   {
[10:24:18.904]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.904]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.904]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.904]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.904]                         fi_tmp[["mtime"]])
[10:24:18.904]                     }
[10:24:18.904]                     tryCatch({
[10:24:18.904]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.904]                     }, error = function(ex) {
[10:24:18.904]                       msg <- conditionMessage(ex)
[10:24:18.904]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.904]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.904]                         fi_tmp[["mtime"]], msg)
[10:24:18.904]                       ex$message <- msg
[10:24:18.904]                       stop(ex)
[10:24:18.904]                     })
[10:24:18.904]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.904]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.904]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.904]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.904]                       fi <- file.info(pathname)
[10:24:18.904]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.904]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.904]                         fi[["size"]], fi[["mtime"]])
[10:24:18.904]                       stop(msg)
[10:24:18.904]                     }
[10:24:18.904]                     invisible(pathname)
[10:24:18.904]                   }
[10:24:18.904]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.904]                     rootPath = tempdir()) 
[10:24:18.904]                   {
[10:24:18.904]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.904]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.904]                       tmpdir = path, fileext = ".rds")
[10:24:18.904]                     save_rds(obj, file)
[10:24:18.904]                   }
[10:24:18.904]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.904]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.904]                   {
[10:24:18.904]                     inherits <- base::inherits
[10:24:18.904]                     invokeRestart <- base::invokeRestart
[10:24:18.904]                     is.null <- base::is.null
[10:24:18.904]                     muffled <- FALSE
[10:24:18.904]                     if (inherits(cond, "message")) {
[10:24:18.904]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.904]                       if (muffled) 
[10:24:18.904]                         invokeRestart("muffleMessage")
[10:24:18.904]                     }
[10:24:18.904]                     else if (inherits(cond, "warning")) {
[10:24:18.904]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.904]                       if (muffled) 
[10:24:18.904]                         invokeRestart("muffleWarning")
[10:24:18.904]                     }
[10:24:18.904]                     else if (inherits(cond, "condition")) {
[10:24:18.904]                       if (!is.null(pattern)) {
[10:24:18.904]                         computeRestarts <- base::computeRestarts
[10:24:18.904]                         grepl <- base::grepl
[10:24:18.904]                         restarts <- computeRestarts(cond)
[10:24:18.904]                         for (restart in restarts) {
[10:24:18.904]                           name <- restart$name
[10:24:18.904]                           if (is.null(name)) 
[10:24:18.904]                             next
[10:24:18.904]                           if (!grepl(pattern, name)) 
[10:24:18.904]                             next
[10:24:18.904]                           invokeRestart(restart)
[10:24:18.904]                           muffled <- TRUE
[10:24:18.904]                           break
[10:24:18.904]                         }
[10:24:18.904]                       }
[10:24:18.904]                     }
[10:24:18.904]                     invisible(muffled)
[10:24:18.904]                   }
[10:24:18.904]                   muffleCondition(cond)
[10:24:18.904]                 })
[10:24:18.904]             }))
[10:24:18.904]             future::FutureResult(value = ...future.value$value, 
[10:24:18.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.904]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.904]                     ...future.globalenv.names))
[10:24:18.904]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.904]         }, condition = base::local({
[10:24:18.904]             c <- base::c
[10:24:18.904]             inherits <- base::inherits
[10:24:18.904]             invokeRestart <- base::invokeRestart
[10:24:18.904]             length <- base::length
[10:24:18.904]             list <- base::list
[10:24:18.904]             seq.int <- base::seq.int
[10:24:18.904]             signalCondition <- base::signalCondition
[10:24:18.904]             sys.calls <- base::sys.calls
[10:24:18.904]             `[[` <- base::`[[`
[10:24:18.904]             `+` <- base::`+`
[10:24:18.904]             `<<-` <- base::`<<-`
[10:24:18.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.904]                   3L)]
[10:24:18.904]             }
[10:24:18.904]             function(cond) {
[10:24:18.904]                 is_error <- inherits(cond, "error")
[10:24:18.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.904]                   NULL)
[10:24:18.904]                 if (is_error) {
[10:24:18.904]                   sessionInformation <- function() {
[10:24:18.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.904]                       search = base::search(), system = base::Sys.info())
[10:24:18.904]                   }
[10:24:18.904]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.904]                     cond$call), session = sessionInformation(), 
[10:24:18.904]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.904]                   signalCondition(cond)
[10:24:18.904]                 }
[10:24:18.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.904]                 "immediateCondition"))) {
[10:24:18.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.904]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.904]                   if (TRUE && !signal) {
[10:24:18.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.904]                     {
[10:24:18.904]                       inherits <- base::inherits
[10:24:18.904]                       invokeRestart <- base::invokeRestart
[10:24:18.904]                       is.null <- base::is.null
[10:24:18.904]                       muffled <- FALSE
[10:24:18.904]                       if (inherits(cond, "message")) {
[10:24:18.904]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.904]                         if (muffled) 
[10:24:18.904]                           invokeRestart("muffleMessage")
[10:24:18.904]                       }
[10:24:18.904]                       else if (inherits(cond, "warning")) {
[10:24:18.904]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.904]                         if (muffled) 
[10:24:18.904]                           invokeRestart("muffleWarning")
[10:24:18.904]                       }
[10:24:18.904]                       else if (inherits(cond, "condition")) {
[10:24:18.904]                         if (!is.null(pattern)) {
[10:24:18.904]                           computeRestarts <- base::computeRestarts
[10:24:18.904]                           grepl <- base::grepl
[10:24:18.904]                           restarts <- computeRestarts(cond)
[10:24:18.904]                           for (restart in restarts) {
[10:24:18.904]                             name <- restart$name
[10:24:18.904]                             if (is.null(name)) 
[10:24:18.904]                               next
[10:24:18.904]                             if (!grepl(pattern, name)) 
[10:24:18.904]                               next
[10:24:18.904]                             invokeRestart(restart)
[10:24:18.904]                             muffled <- TRUE
[10:24:18.904]                             break
[10:24:18.904]                           }
[10:24:18.904]                         }
[10:24:18.904]                       }
[10:24:18.904]                       invisible(muffled)
[10:24:18.904]                     }
[10:24:18.904]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.904]                   }
[10:24:18.904]                 }
[10:24:18.904]                 else {
[10:24:18.904]                   if (TRUE) {
[10:24:18.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.904]                     {
[10:24:18.904]                       inherits <- base::inherits
[10:24:18.904]                       invokeRestart <- base::invokeRestart
[10:24:18.904]                       is.null <- base::is.null
[10:24:18.904]                       muffled <- FALSE
[10:24:18.904]                       if (inherits(cond, "message")) {
[10:24:18.904]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.904]                         if (muffled) 
[10:24:18.904]                           invokeRestart("muffleMessage")
[10:24:18.904]                       }
[10:24:18.904]                       else if (inherits(cond, "warning")) {
[10:24:18.904]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.904]                         if (muffled) 
[10:24:18.904]                           invokeRestart("muffleWarning")
[10:24:18.904]                       }
[10:24:18.904]                       else if (inherits(cond, "condition")) {
[10:24:18.904]                         if (!is.null(pattern)) {
[10:24:18.904]                           computeRestarts <- base::computeRestarts
[10:24:18.904]                           grepl <- base::grepl
[10:24:18.904]                           restarts <- computeRestarts(cond)
[10:24:18.904]                           for (restart in restarts) {
[10:24:18.904]                             name <- restart$name
[10:24:18.904]                             if (is.null(name)) 
[10:24:18.904]                               next
[10:24:18.904]                             if (!grepl(pattern, name)) 
[10:24:18.904]                               next
[10:24:18.904]                             invokeRestart(restart)
[10:24:18.904]                             muffled <- TRUE
[10:24:18.904]                             break
[10:24:18.904]                           }
[10:24:18.904]                         }
[10:24:18.904]                       }
[10:24:18.904]                       invisible(muffled)
[10:24:18.904]                     }
[10:24:18.904]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.904]                   }
[10:24:18.904]                 }
[10:24:18.904]             }
[10:24:18.904]         }))
[10:24:18.904]     }, error = function(ex) {
[10:24:18.904]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.904]                 ...future.rng), started = ...future.startTime, 
[10:24:18.904]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.904]             version = "1.8"), class = "FutureResult")
[10:24:18.904]     }, finally = {
[10:24:18.904]         if (!identical(...future.workdir, getwd())) 
[10:24:18.904]             setwd(...future.workdir)
[10:24:18.904]         {
[10:24:18.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.904]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.904]             }
[10:24:18.904]             base::options(...future.oldOptions)
[10:24:18.904]             if (.Platform$OS.type == "windows") {
[10:24:18.904]                 old_names <- names(...future.oldEnvVars)
[10:24:18.904]                 envs <- base::Sys.getenv()
[10:24:18.904]                 names <- names(envs)
[10:24:18.904]                 common <- intersect(names, old_names)
[10:24:18.904]                 added <- setdiff(names, old_names)
[10:24:18.904]                 removed <- setdiff(old_names, names)
[10:24:18.904]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.904]                   envs[common]]
[10:24:18.904]                 NAMES <- toupper(changed)
[10:24:18.904]                 args <- list()
[10:24:18.904]                 for (kk in seq_along(NAMES)) {
[10:24:18.904]                   name <- changed[[kk]]
[10:24:18.904]                   NAME <- NAMES[[kk]]
[10:24:18.904]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.904]                     next
[10:24:18.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.904]                 }
[10:24:18.904]                 NAMES <- toupper(added)
[10:24:18.904]                 for (kk in seq_along(NAMES)) {
[10:24:18.904]                   name <- added[[kk]]
[10:24:18.904]                   NAME <- NAMES[[kk]]
[10:24:18.904]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.904]                     next
[10:24:18.904]                   args[[name]] <- ""
[10:24:18.904]                 }
[10:24:18.904]                 NAMES <- toupper(removed)
[10:24:18.904]                 for (kk in seq_along(NAMES)) {
[10:24:18.904]                   name <- removed[[kk]]
[10:24:18.904]                   NAME <- NAMES[[kk]]
[10:24:18.904]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.904]                     next
[10:24:18.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.904]                 }
[10:24:18.904]                 if (length(args) > 0) 
[10:24:18.904]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.904]             }
[10:24:18.904]             else {
[10:24:18.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.904]             }
[10:24:18.904]             {
[10:24:18.904]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.904]                   0L) {
[10:24:18.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.904]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.904]                   base::options(opts)
[10:24:18.904]                 }
[10:24:18.904]                 {
[10:24:18.904]                   {
[10:24:18.904]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.904]                     NULL
[10:24:18.904]                   }
[10:24:18.904]                   options(future.plan = NULL)
[10:24:18.904]                   if (is.na(NA_character_)) 
[10:24:18.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.904]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.904]                     envir = parent.frame()) 
[10:24:18.904]                   {
[10:24:18.904]                     default_workers <- missing(workers)
[10:24:18.904]                     if (is.function(workers)) 
[10:24:18.904]                       workers <- workers()
[10:24:18.904]                     workers <- structure(as.integer(workers), 
[10:24:18.904]                       class = class(workers))
[10:24:18.904]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.904]                       1L)
[10:24:18.904]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.904]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.904]                       if (default_workers) 
[10:24:18.904]                         supportsMulticore(warn = TRUE)
[10:24:18.904]                       return(sequential(..., envir = envir))
[10:24:18.904]                     }
[10:24:18.904]                     oopts <- options(mc.cores = workers)
[10:24:18.904]                     on.exit(options(oopts))
[10:24:18.904]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.904]                       envir = envir)
[10:24:18.904]                     if (!future$lazy) 
[10:24:18.904]                       future <- run(future)
[10:24:18.904]                     invisible(future)
[10:24:18.904]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.904]                 }
[10:24:18.904]             }
[10:24:18.904]         }
[10:24:18.904]     })
[10:24:18.904]     if (TRUE) {
[10:24:18.904]         base::sink(type = "output", split = FALSE)
[10:24:18.904]         if (TRUE) {
[10:24:18.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.904]         }
[10:24:18.904]         else {
[10:24:18.904]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.904]         }
[10:24:18.904]         base::close(...future.stdout)
[10:24:18.904]         ...future.stdout <- NULL
[10:24:18.904]     }
[10:24:18.904]     ...future.result$conditions <- ...future.conditions
[10:24:18.904]     ...future.result$finished <- base::Sys.time()
[10:24:18.904]     ...future.result
[10:24:18.904] }
[10:24:18.907] assign_globals() ...
[10:24:18.907] List of 11
[10:24:18.907]  $ ...future.FUN            :function (x, ...)  
[10:24:18.907]  $ x_FUN                    :function (x)  
[10:24:18.907]  $ times                    : int 1
[10:24:18.907]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.907]  $ stop_if_not              :function (...)  
[10:24:18.907]  $ dim                      : NULL
[10:24:18.907]  $ valid_types              : chr [1:2] "logical" "integer"
[10:24:18.907]  $ future.call.arguments    : list()
[10:24:18.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.907]  $ ...future.elements_ii    :List of 1
[10:24:18.907]   ..$ a: num 1
[10:24:18.907]  $ ...future.seeds_ii       : NULL
[10:24:18.907]  $ ...future.globals.maxSize: NULL
[10:24:18.907]  - attr(*, "where")=List of 11
[10:24:18.907]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.907]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:18.907]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:18.907]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:18.907]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:18.907]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:18.907]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:18.907]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.907]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.907]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.907]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.907]  - attr(*, "resolved")= logi FALSE
[10:24:18.907]  - attr(*, "total_size")= num 94264
[10:24:18.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.907]  - attr(*, "already-done")= logi TRUE
[10:24:18.917] - copied ‘...future.FUN’ to environment
[10:24:18.917] - copied ‘x_FUN’ to environment
[10:24:18.917] - copied ‘times’ to environment
[10:24:18.917] - copied ‘stopf’ to environment
[10:24:18.917] - copied ‘stop_if_not’ to environment
[10:24:18.917] - copied ‘dim’ to environment
[10:24:18.918] - copied ‘valid_types’ to environment
[10:24:18.918] - copied ‘future.call.arguments’ to environment
[10:24:18.918] - copied ‘...future.elements_ii’ to environment
[10:24:18.918] - copied ‘...future.seeds_ii’ to environment
[10:24:18.918] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.918] assign_globals() ... done
[10:24:18.918] requestCore(): workers = 2
[10:24:18.921] MulticoreFuture started
[10:24:18.922] - Launch lazy future ... done
[10:24:18.923] run() for ‘MulticoreFuture’ ... done
[10:24:18.924] Created future:
[10:24:18.924] plan(): Setting new future strategy stack:
[10:24:18.924] List of future strategies:
[10:24:18.924] 1. sequential:
[10:24:18.924]    - args: function (..., envir = parent.frame())
[10:24:18.924]    - tweaked: FALSE
[10:24:18.924]    - call: NULL
[10:24:18.925] plan(): nbrOfWorkers() = 1
[10:24:18.927] plan(): Setting new future strategy stack:
[10:24:18.928] List of future strategies:
[10:24:18.928] 1. multicore:
[10:24:18.928]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.928]    - tweaked: FALSE
[10:24:18.928]    - call: plan(strategy)
[10:24:18.934] plan(): nbrOfWorkers() = 2
[10:24:18.924] MulticoreFuture:
[10:24:18.924] Label: ‘future_vapply-1’
[10:24:18.924] Expression:
[10:24:18.924] {
[10:24:18.924]     do.call(function(...) {
[10:24:18.924]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.924]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.924]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.924]             on.exit(options(oopts), add = TRUE)
[10:24:18.924]         }
[10:24:18.924]         {
[10:24:18.924]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.924]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.924]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.924]             })
[10:24:18.924]         }
[10:24:18.924]     }, args = future.call.arguments)
[10:24:18.924] }
[10:24:18.924] Lazy evaluation: FALSE
[10:24:18.924] Asynchronous evaluation: TRUE
[10:24:18.924] Local evaluation: TRUE
[10:24:18.924] Environment: R_GlobalEnv
[10:24:18.924] Capture standard output: TRUE
[10:24:18.924] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.924] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:18.924] Packages: 1 packages (‘future.apply’)
[10:24:18.924] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.924] Resolved: TRUE
[10:24:18.924] Value: <not collected>
[10:24:18.924] Conditions captured: <none>
[10:24:18.924] Early signaling: FALSE
[10:24:18.924] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.924] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.935] Chunk #1 of 2 ... DONE
[10:24:18.935] Chunk #2 of 2 ...
[10:24:18.935]  - Finding globals in 'X' for chunk #2 ...
[10:24:18.935] getGlobalsAndPackages() ...
[10:24:18.935] Searching for globals...
[10:24:18.936] 
[10:24:18.936] Searching for globals ... DONE
[10:24:18.936] - globals: [0] <none>
[10:24:18.936] getGlobalsAndPackages() ... DONE
[10:24:18.937]    + additional globals found: [n=0] 
[10:24:18.937]    + additional namespaces needed: [n=0] 
[10:24:18.937]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:18.937]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:18.937]  - seeds: <none>
[10:24:18.937]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.938] getGlobalsAndPackages() ...
[10:24:18.938] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.938] Resolving globals: FALSE
[10:24:18.938] Tweak future expression to call with '...' arguments ...
[10:24:18.939] {
[10:24:18.939]     do.call(function(...) {
[10:24:18.939]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.939]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.939]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.939]             on.exit(options(oopts), add = TRUE)
[10:24:18.939]         }
[10:24:18.939]         {
[10:24:18.939]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.939]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.939]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.939]             })
[10:24:18.939]         }
[10:24:18.939]     }, args = future.call.arguments)
[10:24:18.939] }
[10:24:18.939] Tweak future expression to call with '...' arguments ... DONE
[10:24:18.940] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:18.940] - packages: [1] ‘future.apply’
[10:24:18.940] getGlobalsAndPackages() ... DONE
[10:24:18.941] run() for ‘Future’ ...
[10:24:18.941] - state: ‘created’
[10:24:18.941] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:18.946] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.946] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:18.946]   - Field: ‘label’
[10:24:18.946]   - Field: ‘local’
[10:24:18.947]   - Field: ‘owner’
[10:24:18.947]   - Field: ‘envir’
[10:24:18.947]   - Field: ‘workers’
[10:24:18.947]   - Field: ‘packages’
[10:24:18.947]   - Field: ‘gc’
[10:24:18.947]   - Field: ‘job’
[10:24:18.948]   - Field: ‘conditions’
[10:24:18.948]   - Field: ‘expr’
[10:24:18.948]   - Field: ‘uuid’
[10:24:18.948]   - Field: ‘seed’
[10:24:18.948]   - Field: ‘version’
[10:24:18.948]   - Field: ‘result’
[10:24:18.948]   - Field: ‘asynchronous’
[10:24:18.949]   - Field: ‘calls’
[10:24:18.949]   - Field: ‘globals’
[10:24:18.949]   - Field: ‘stdout’
[10:24:18.949]   - Field: ‘earlySignal’
[10:24:18.949]   - Field: ‘lazy’
[10:24:18.949]   - Field: ‘state’
[10:24:18.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:18.950] - Launch lazy future ...
[10:24:18.950] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:18.950] Packages needed by future strategies (n = 0): <none>
[10:24:18.951] {
[10:24:18.951]     {
[10:24:18.951]         {
[10:24:18.951]             ...future.startTime <- base::Sys.time()
[10:24:18.951]             {
[10:24:18.951]                 {
[10:24:18.951]                   {
[10:24:18.951]                     {
[10:24:18.951]                       {
[10:24:18.951]                         base::local({
[10:24:18.951]                           has_future <- base::requireNamespace("future", 
[10:24:18.951]                             quietly = TRUE)
[10:24:18.951]                           if (has_future) {
[10:24:18.951]                             ns <- base::getNamespace("future")
[10:24:18.951]                             version <- ns[[".package"]][["version"]]
[10:24:18.951]                             if (is.null(version)) 
[10:24:18.951]                               version <- utils::packageVersion("future")
[10:24:18.951]                           }
[10:24:18.951]                           else {
[10:24:18.951]                             version <- NULL
[10:24:18.951]                           }
[10:24:18.951]                           if (!has_future || version < "1.8.0") {
[10:24:18.951]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:18.951]                               "", base::R.version$version.string), 
[10:24:18.951]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:18.951]                                 base::R.version$platform, 8 * 
[10:24:18.951]                                   base::.Machine$sizeof.pointer), 
[10:24:18.951]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:18.951]                                 "release", "version")], collapse = " "), 
[10:24:18.951]                               hostname = base::Sys.info()[["nodename"]])
[10:24:18.951]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:18.951]                               info)
[10:24:18.951]                             info <- base::paste(info, collapse = "; ")
[10:24:18.951]                             if (!has_future) {
[10:24:18.951]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:18.951]                                 info)
[10:24:18.951]                             }
[10:24:18.951]                             else {
[10:24:18.951]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:18.951]                                 info, version)
[10:24:18.951]                             }
[10:24:18.951]                             base::stop(msg)
[10:24:18.951]                           }
[10:24:18.951]                         })
[10:24:18.951]                       }
[10:24:18.951]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:18.951]                       base::options(mc.cores = 1L)
[10:24:18.951]                     }
[10:24:18.951]                     base::local({
[10:24:18.951]                       for (pkg in "future.apply") {
[10:24:18.951]                         base::loadNamespace(pkg)
[10:24:18.951]                         base::library(pkg, character.only = TRUE)
[10:24:18.951]                       }
[10:24:18.951]                     })
[10:24:18.951]                   }
[10:24:18.951]                   options(future.plan = NULL)
[10:24:18.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:18.951]                 }
[10:24:18.951]                 ...future.workdir <- getwd()
[10:24:18.951]             }
[10:24:18.951]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:18.951]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:18.951]         }
[10:24:18.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:18.951]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:18.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:18.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:18.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:18.951]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:18.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:18.951]             base::names(...future.oldOptions))
[10:24:18.951]     }
[10:24:18.951]     if (FALSE) {
[10:24:18.951]     }
[10:24:18.951]     else {
[10:24:18.951]         if (TRUE) {
[10:24:18.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:18.951]                 open = "w")
[10:24:18.951]         }
[10:24:18.951]         else {
[10:24:18.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:18.951]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:18.951]         }
[10:24:18.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:18.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:18.951]             base::sink(type = "output", split = FALSE)
[10:24:18.951]             base::close(...future.stdout)
[10:24:18.951]         }, add = TRUE)
[10:24:18.951]     }
[10:24:18.951]     ...future.frame <- base::sys.nframe()
[10:24:18.951]     ...future.conditions <- base::list()
[10:24:18.951]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:18.951]     if (FALSE) {
[10:24:18.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:18.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:18.951]     }
[10:24:18.951]     ...future.result <- base::tryCatch({
[10:24:18.951]         base::withCallingHandlers({
[10:24:18.951]             ...future.value <- base::withVisible(base::local({
[10:24:18.951]                 withCallingHandlers({
[10:24:18.951]                   {
[10:24:18.951]                     do.call(function(...) {
[10:24:18.951]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.951]                       if (!identical(...future.globals.maxSize.org, 
[10:24:18.951]                         ...future.globals.maxSize)) {
[10:24:18.951]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.951]                         on.exit(options(oopts), add = TRUE)
[10:24:18.951]                       }
[10:24:18.951]                       {
[10:24:18.951]                         lapply(seq_along(...future.elements_ii), 
[10:24:18.951]                           FUN = function(jj) {
[10:24:18.951]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.951]                             ...future.FUN(...future.X_jj, ...)
[10:24:18.951]                           })
[10:24:18.951]                       }
[10:24:18.951]                     }, args = future.call.arguments)
[10:24:18.951]                   }
[10:24:18.951]                 }, immediateCondition = function(cond) {
[10:24:18.951]                   save_rds <- function (object, pathname, ...) 
[10:24:18.951]                   {
[10:24:18.951]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:18.951]                     if (file_test("-f", pathname_tmp)) {
[10:24:18.951]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.951]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:18.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.951]                         fi_tmp[["mtime"]])
[10:24:18.951]                     }
[10:24:18.951]                     tryCatch({
[10:24:18.951]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:18.951]                     }, error = function(ex) {
[10:24:18.951]                       msg <- conditionMessage(ex)
[10:24:18.951]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.951]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:18.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.951]                         fi_tmp[["mtime"]], msg)
[10:24:18.951]                       ex$message <- msg
[10:24:18.951]                       stop(ex)
[10:24:18.951]                     })
[10:24:18.951]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:18.951]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:18.951]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:18.951]                       fi_tmp <- file.info(pathname_tmp)
[10:24:18.951]                       fi <- file.info(pathname)
[10:24:18.951]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:18.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:18.951]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:18.951]                         fi[["size"]], fi[["mtime"]])
[10:24:18.951]                       stop(msg)
[10:24:18.951]                     }
[10:24:18.951]                     invisible(pathname)
[10:24:18.951]                   }
[10:24:18.951]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:18.951]                     rootPath = tempdir()) 
[10:24:18.951]                   {
[10:24:18.951]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:18.951]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:18.951]                       tmpdir = path, fileext = ".rds")
[10:24:18.951]                     save_rds(obj, file)
[10:24:18.951]                   }
[10:24:18.951]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:18.951]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.951]                   {
[10:24:18.951]                     inherits <- base::inherits
[10:24:18.951]                     invokeRestart <- base::invokeRestart
[10:24:18.951]                     is.null <- base::is.null
[10:24:18.951]                     muffled <- FALSE
[10:24:18.951]                     if (inherits(cond, "message")) {
[10:24:18.951]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:18.951]                       if (muffled) 
[10:24:18.951]                         invokeRestart("muffleMessage")
[10:24:18.951]                     }
[10:24:18.951]                     else if (inherits(cond, "warning")) {
[10:24:18.951]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:18.951]                       if (muffled) 
[10:24:18.951]                         invokeRestart("muffleWarning")
[10:24:18.951]                     }
[10:24:18.951]                     else if (inherits(cond, "condition")) {
[10:24:18.951]                       if (!is.null(pattern)) {
[10:24:18.951]                         computeRestarts <- base::computeRestarts
[10:24:18.951]                         grepl <- base::grepl
[10:24:18.951]                         restarts <- computeRestarts(cond)
[10:24:18.951]                         for (restart in restarts) {
[10:24:18.951]                           name <- restart$name
[10:24:18.951]                           if (is.null(name)) 
[10:24:18.951]                             next
[10:24:18.951]                           if (!grepl(pattern, name)) 
[10:24:18.951]                             next
[10:24:18.951]                           invokeRestart(restart)
[10:24:18.951]                           muffled <- TRUE
[10:24:18.951]                           break
[10:24:18.951]                         }
[10:24:18.951]                       }
[10:24:18.951]                     }
[10:24:18.951]                     invisible(muffled)
[10:24:18.951]                   }
[10:24:18.951]                   muffleCondition(cond)
[10:24:18.951]                 })
[10:24:18.951]             }))
[10:24:18.951]             future::FutureResult(value = ...future.value$value, 
[10:24:18.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.951]                   ...future.rng), globalenv = if (FALSE) 
[10:24:18.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:18.951]                     ...future.globalenv.names))
[10:24:18.951]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:18.951]         }, condition = base::local({
[10:24:18.951]             c <- base::c
[10:24:18.951]             inherits <- base::inherits
[10:24:18.951]             invokeRestart <- base::invokeRestart
[10:24:18.951]             length <- base::length
[10:24:18.951]             list <- base::list
[10:24:18.951]             seq.int <- base::seq.int
[10:24:18.951]             signalCondition <- base::signalCondition
[10:24:18.951]             sys.calls <- base::sys.calls
[10:24:18.951]             `[[` <- base::`[[`
[10:24:18.951]             `+` <- base::`+`
[10:24:18.951]             `<<-` <- base::`<<-`
[10:24:18.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:18.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:18.951]                   3L)]
[10:24:18.951]             }
[10:24:18.951]             function(cond) {
[10:24:18.951]                 is_error <- inherits(cond, "error")
[10:24:18.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:18.951]                   NULL)
[10:24:18.951]                 if (is_error) {
[10:24:18.951]                   sessionInformation <- function() {
[10:24:18.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:18.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:18.951]                       search = base::search(), system = base::Sys.info())
[10:24:18.951]                   }
[10:24:18.951]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:18.951]                     cond$call), session = sessionInformation(), 
[10:24:18.951]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:18.951]                   signalCondition(cond)
[10:24:18.951]                 }
[10:24:18.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:18.951]                 "immediateCondition"))) {
[10:24:18.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:18.951]                   ...future.conditions[[length(...future.conditions) + 
[10:24:18.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:18.951]                   if (TRUE && !signal) {
[10:24:18.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.951]                     {
[10:24:18.951]                       inherits <- base::inherits
[10:24:18.951]                       invokeRestart <- base::invokeRestart
[10:24:18.951]                       is.null <- base::is.null
[10:24:18.951]                       muffled <- FALSE
[10:24:18.951]                       if (inherits(cond, "message")) {
[10:24:18.951]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.951]                         if (muffled) 
[10:24:18.951]                           invokeRestart("muffleMessage")
[10:24:18.951]                       }
[10:24:18.951]                       else if (inherits(cond, "warning")) {
[10:24:18.951]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.951]                         if (muffled) 
[10:24:18.951]                           invokeRestart("muffleWarning")
[10:24:18.951]                       }
[10:24:18.951]                       else if (inherits(cond, "condition")) {
[10:24:18.951]                         if (!is.null(pattern)) {
[10:24:18.951]                           computeRestarts <- base::computeRestarts
[10:24:18.951]                           grepl <- base::grepl
[10:24:18.951]                           restarts <- computeRestarts(cond)
[10:24:18.951]                           for (restart in restarts) {
[10:24:18.951]                             name <- restart$name
[10:24:18.951]                             if (is.null(name)) 
[10:24:18.951]                               next
[10:24:18.951]                             if (!grepl(pattern, name)) 
[10:24:18.951]                               next
[10:24:18.951]                             invokeRestart(restart)
[10:24:18.951]                             muffled <- TRUE
[10:24:18.951]                             break
[10:24:18.951]                           }
[10:24:18.951]                         }
[10:24:18.951]                       }
[10:24:18.951]                       invisible(muffled)
[10:24:18.951]                     }
[10:24:18.951]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.951]                   }
[10:24:18.951]                 }
[10:24:18.951]                 else {
[10:24:18.951]                   if (TRUE) {
[10:24:18.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:18.951]                     {
[10:24:18.951]                       inherits <- base::inherits
[10:24:18.951]                       invokeRestart <- base::invokeRestart
[10:24:18.951]                       is.null <- base::is.null
[10:24:18.951]                       muffled <- FALSE
[10:24:18.951]                       if (inherits(cond, "message")) {
[10:24:18.951]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:18.951]                         if (muffled) 
[10:24:18.951]                           invokeRestart("muffleMessage")
[10:24:18.951]                       }
[10:24:18.951]                       else if (inherits(cond, "warning")) {
[10:24:18.951]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:18.951]                         if (muffled) 
[10:24:18.951]                           invokeRestart("muffleWarning")
[10:24:18.951]                       }
[10:24:18.951]                       else if (inherits(cond, "condition")) {
[10:24:18.951]                         if (!is.null(pattern)) {
[10:24:18.951]                           computeRestarts <- base::computeRestarts
[10:24:18.951]                           grepl <- base::grepl
[10:24:18.951]                           restarts <- computeRestarts(cond)
[10:24:18.951]                           for (restart in restarts) {
[10:24:18.951]                             name <- restart$name
[10:24:18.951]                             if (is.null(name)) 
[10:24:18.951]                               next
[10:24:18.951]                             if (!grepl(pattern, name)) 
[10:24:18.951]                               next
[10:24:18.951]                             invokeRestart(restart)
[10:24:18.951]                             muffled <- TRUE
[10:24:18.951]                             break
[10:24:18.951]                           }
[10:24:18.951]                         }
[10:24:18.951]                       }
[10:24:18.951]                       invisible(muffled)
[10:24:18.951]                     }
[10:24:18.951]                     muffleCondition(cond, pattern = "^muffle")
[10:24:18.951]                   }
[10:24:18.951]                 }
[10:24:18.951]             }
[10:24:18.951]         }))
[10:24:18.951]     }, error = function(ex) {
[10:24:18.951]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:18.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:18.951]                 ...future.rng), started = ...future.startTime, 
[10:24:18.951]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:18.951]             version = "1.8"), class = "FutureResult")
[10:24:18.951]     }, finally = {
[10:24:18.951]         if (!identical(...future.workdir, getwd())) 
[10:24:18.951]             setwd(...future.workdir)
[10:24:18.951]         {
[10:24:18.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:18.951]                 ...future.oldOptions$nwarnings <- NULL
[10:24:18.951]             }
[10:24:18.951]             base::options(...future.oldOptions)
[10:24:18.951]             if (.Platform$OS.type == "windows") {
[10:24:18.951]                 old_names <- names(...future.oldEnvVars)
[10:24:18.951]                 envs <- base::Sys.getenv()
[10:24:18.951]                 names <- names(envs)
[10:24:18.951]                 common <- intersect(names, old_names)
[10:24:18.951]                 added <- setdiff(names, old_names)
[10:24:18.951]                 removed <- setdiff(old_names, names)
[10:24:18.951]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:18.951]                   envs[common]]
[10:24:18.951]                 NAMES <- toupper(changed)
[10:24:18.951]                 args <- list()
[10:24:18.951]                 for (kk in seq_along(NAMES)) {
[10:24:18.951]                   name <- changed[[kk]]
[10:24:18.951]                   NAME <- NAMES[[kk]]
[10:24:18.951]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.951]                     next
[10:24:18.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.951]                 }
[10:24:18.951]                 NAMES <- toupper(added)
[10:24:18.951]                 for (kk in seq_along(NAMES)) {
[10:24:18.951]                   name <- added[[kk]]
[10:24:18.951]                   NAME <- NAMES[[kk]]
[10:24:18.951]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.951]                     next
[10:24:18.951]                   args[[name]] <- ""
[10:24:18.951]                 }
[10:24:18.951]                 NAMES <- toupper(removed)
[10:24:18.951]                 for (kk in seq_along(NAMES)) {
[10:24:18.951]                   name <- removed[[kk]]
[10:24:18.951]                   NAME <- NAMES[[kk]]
[10:24:18.951]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:18.951]                     next
[10:24:18.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:18.951]                 }
[10:24:18.951]                 if (length(args) > 0) 
[10:24:18.951]                   base::do.call(base::Sys.setenv, args = args)
[10:24:18.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:18.951]             }
[10:24:18.951]             else {
[10:24:18.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:18.951]             }
[10:24:18.951]             {
[10:24:18.951]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:18.951]                   0L) {
[10:24:18.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:18.951]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:18.951]                   base::options(opts)
[10:24:18.951]                 }
[10:24:18.951]                 {
[10:24:18.951]                   {
[10:24:18.951]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:18.951]                     NULL
[10:24:18.951]                   }
[10:24:18.951]                   options(future.plan = NULL)
[10:24:18.951]                   if (is.na(NA_character_)) 
[10:24:18.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:18.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:18.951]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:18.951]                     envir = parent.frame()) 
[10:24:18.951]                   {
[10:24:18.951]                     default_workers <- missing(workers)
[10:24:18.951]                     if (is.function(workers)) 
[10:24:18.951]                       workers <- workers()
[10:24:18.951]                     workers <- structure(as.integer(workers), 
[10:24:18.951]                       class = class(workers))
[10:24:18.951]                     stop_if_not(is.finite(workers), workers >= 
[10:24:18.951]                       1L)
[10:24:18.951]                     if ((workers == 1L && !inherits(workers, 
[10:24:18.951]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:18.951]                       if (default_workers) 
[10:24:18.951]                         supportsMulticore(warn = TRUE)
[10:24:18.951]                       return(sequential(..., envir = envir))
[10:24:18.951]                     }
[10:24:18.951]                     oopts <- options(mc.cores = workers)
[10:24:18.951]                     on.exit(options(oopts))
[10:24:18.951]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:18.951]                       envir = envir)
[10:24:18.951]                     if (!future$lazy) 
[10:24:18.951]                       future <- run(future)
[10:24:18.951]                     invisible(future)
[10:24:18.951]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:18.951]                 }
[10:24:18.951]             }
[10:24:18.951]         }
[10:24:18.951]     })
[10:24:18.951]     if (TRUE) {
[10:24:18.951]         base::sink(type = "output", split = FALSE)
[10:24:18.951]         if (TRUE) {
[10:24:18.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:18.951]         }
[10:24:18.951]         else {
[10:24:18.951]             ...future.result["stdout"] <- base::list(NULL)
[10:24:18.951]         }
[10:24:18.951]         base::close(...future.stdout)
[10:24:18.951]         ...future.stdout <- NULL
[10:24:18.951]     }
[10:24:18.951]     ...future.result$conditions <- ...future.conditions
[10:24:18.951]     ...future.result$finished <- base::Sys.time()
[10:24:18.951]     ...future.result
[10:24:18.951] }
[10:24:18.955] assign_globals() ...
[10:24:18.955] List of 11
[10:24:18.955]  $ ...future.FUN            :function (x, ...)  
[10:24:18.955]  $ x_FUN                    :function (x)  
[10:24:18.955]  $ times                    : int 1
[10:24:18.955]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:18.955]  $ stop_if_not              :function (...)  
[10:24:18.955]  $ dim                      : NULL
[10:24:18.955]  $ valid_types              : chr [1:2] "logical" "integer"
[10:24:18.955]  $ future.call.arguments    : list()
[10:24:18.955]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:18.955]  $ ...future.elements_ii    :List of 2
[10:24:18.955]   ..$ b: num 2
[10:24:18.955]   ..$ c: num 3
[10:24:18.955]  $ ...future.seeds_ii       : NULL
[10:24:18.955]  $ ...future.globals.maxSize: NULL
[10:24:18.955]  - attr(*, "where")=List of 11
[10:24:18.955]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:18.955]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:18.955]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:18.955]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:18.955]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:18.955]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:18.955]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:18.955]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:18.955]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:18.955]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:18.955]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:18.955]  - attr(*, "resolved")= logi FALSE
[10:24:18.955]  - attr(*, "total_size")= num 94264
[10:24:18.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:18.955]  - attr(*, "already-done")= logi TRUE
[10:24:18.971] - copied ‘...future.FUN’ to environment
[10:24:18.971] - copied ‘x_FUN’ to environment
[10:24:18.971] - copied ‘times’ to environment
[10:24:18.971] - copied ‘stopf’ to environment
[10:24:18.971] - copied ‘stop_if_not’ to environment
[10:24:18.971] - copied ‘dim’ to environment
[10:24:18.971] - copied ‘valid_types’ to environment
[10:24:18.971] - copied ‘future.call.arguments’ to environment
[10:24:18.971] - copied ‘...future.elements_ii’ to environment
[10:24:18.972] - copied ‘...future.seeds_ii’ to environment
[10:24:18.972] - copied ‘...future.globals.maxSize’ to environment
[10:24:18.972] assign_globals() ... done
[10:24:18.972] requestCore(): workers = 2
[10:24:18.974] MulticoreFuture started
[10:24:18.975] - Launch lazy future ... done
[10:24:18.975] run() for ‘MulticoreFuture’ ... done
[10:24:18.975] Created future:
[10:24:18.976] plan(): Setting new future strategy stack:
[10:24:18.976] List of future strategies:
[10:24:18.976] 1. sequential:
[10:24:18.976]    - args: function (..., envir = parent.frame())
[10:24:18.976]    - tweaked: FALSE
[10:24:18.976]    - call: NULL
[10:24:18.977] plan(): nbrOfWorkers() = 1
[10:24:18.979] plan(): Setting new future strategy stack:
[10:24:18.979] List of future strategies:
[10:24:18.979] 1. multicore:
[10:24:18.979]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:18.979]    - tweaked: FALSE
[10:24:18.979]    - call: plan(strategy)
[10:24:18.985] plan(): nbrOfWorkers() = 2
[10:24:18.975] MulticoreFuture:
[10:24:18.975] Label: ‘future_vapply-2’
[10:24:18.975] Expression:
[10:24:18.975] {
[10:24:18.975]     do.call(function(...) {
[10:24:18.975]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:18.975]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:18.975]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:18.975]             on.exit(options(oopts), add = TRUE)
[10:24:18.975]         }
[10:24:18.975]         {
[10:24:18.975]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:18.975]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:18.975]                 ...future.FUN(...future.X_jj, ...)
[10:24:18.975]             })
[10:24:18.975]         }
[10:24:18.975]     }, args = future.call.arguments)
[10:24:18.975] }
[10:24:18.975] Lazy evaluation: FALSE
[10:24:18.975] Asynchronous evaluation: TRUE
[10:24:18.975] Local evaluation: TRUE
[10:24:18.975] Environment: R_GlobalEnv
[10:24:18.975] Capture standard output: TRUE
[10:24:18.975] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:18.975] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:18.975] Packages: 1 packages (‘future.apply’)
[10:24:18.975] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:18.975] Resolved: TRUE
[10:24:18.975] Value: <not collected>
[10:24:18.975] Conditions captured: <none>
[10:24:18.975] Early signaling: FALSE
[10:24:18.975] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:18.975] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:18.986] Chunk #2 of 2 ... DONE
[10:24:18.986] Launching 2 futures (chunks) ... DONE
[10:24:18.986] Resolving 2 futures (chunks) ...
[10:24:18.987] resolve() on list ...
[10:24:18.987]  recursive: 0
[10:24:18.987]  length: 2
[10:24:18.987] 
[10:24:18.987] Future #1
[10:24:18.987] result() for MulticoreFuture ...
[10:24:18.988] result() for MulticoreFuture ...
[10:24:18.988] result() for MulticoreFuture ... done
[10:24:18.989] result() for MulticoreFuture ... done
[10:24:18.989] result() for MulticoreFuture ...
[10:24:18.989] result() for MulticoreFuture ... done
[10:24:18.989] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:18.989] - nx: 2
[10:24:18.990] - relay: TRUE
[10:24:18.990] - stdout: TRUE
[10:24:18.990] - signal: TRUE
[10:24:18.990] - resignal: FALSE
[10:24:18.990] - force: TRUE
[10:24:18.990] - relayed: [n=2] FALSE, FALSE
[10:24:18.991] - queued futures: [n=2] FALSE, FALSE
[10:24:18.991]  - until=1
[10:24:18.991]  - relaying element #1
[10:24:18.991] result() for MulticoreFuture ...
[10:24:18.991] result() for MulticoreFuture ... done
[10:24:18.992] result() for MulticoreFuture ...
[10:24:18.992] result() for MulticoreFuture ... done
[10:24:18.992] result() for MulticoreFuture ...
[10:24:18.992] result() for MulticoreFuture ... done
[10:24:18.992] result() for MulticoreFuture ...
[10:24:18.992] result() for MulticoreFuture ... done
[10:24:18.992] - relayed: [n=2] TRUE, FALSE
[10:24:18.993] - queued futures: [n=2] TRUE, FALSE
[10:24:18.993] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:18.993]  length: 1 (resolved future 1)
[10:24:18.993] Future #2
[10:24:18.994] result() for MulticoreFuture ...
[10:24:18.994] result() for MulticoreFuture ...
[10:24:18.995] result() for MulticoreFuture ... done
[10:24:18.995] result() for MulticoreFuture ... done
[10:24:18.995] result() for MulticoreFuture ...
[10:24:18.995] result() for MulticoreFuture ... done
[10:24:18.995] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:18.996] - nx: 2
[10:24:18.996] - relay: TRUE
[10:24:18.996] - stdout: TRUE
[10:24:18.996] - signal: TRUE
[10:24:18.996] - resignal: FALSE
[10:24:18.996] - force: TRUE
[10:24:18.997] - relayed: [n=2] TRUE, FALSE
[10:24:18.997] - queued futures: [n=2] TRUE, FALSE
[10:24:18.997]  - until=2
[10:24:18.997]  - relaying element #2
[10:24:18.997] result() for MulticoreFuture ...
[10:24:18.997] result() for MulticoreFuture ... done
[10:24:18.998] result() for MulticoreFuture ...
[10:24:18.998] result() for MulticoreFuture ... done
[10:24:18.998] result() for MulticoreFuture ...
[10:24:19.000] result() for MulticoreFuture ... done
[10:24:19.001] result() for MulticoreFuture ...
[10:24:19.001] result() for MulticoreFuture ... done
[10:24:19.001] - relayed: [n=2] TRUE, TRUE
[10:24:19.001] - queued futures: [n=2] TRUE, TRUE
[10:24:19.001] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:24:19.001]  length: 0 (resolved future 2)
[10:24:19.002] Relaying remaining futures
[10:24:19.002] signalConditionsASAP(NULL, pos=0) ...
[10:24:19.002] - nx: 2
[10:24:19.002] - relay: TRUE
[10:24:19.002] - stdout: TRUE
[10:24:19.002] - signal: TRUE
[10:24:19.002] - resignal: FALSE
[10:24:19.003] - force: TRUE
[10:24:19.003] - relayed: [n=2] TRUE, TRUE
[10:24:19.003] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:19.003] - relayed: [n=2] TRUE, TRUE
[10:24:19.003] - queued futures: [n=2] TRUE, TRUE
[10:24:19.003] signalConditionsASAP(NULL, pos=0) ... done
[10:24:19.003] resolve() on list ... DONE
[10:24:19.004] result() for MulticoreFuture ...
[10:24:19.004] result() for MulticoreFuture ... done
[10:24:19.004] result() for MulticoreFuture ...
[10:24:19.004] result() for MulticoreFuture ... done
[10:24:19.004] result() for MulticoreFuture ...
[10:24:19.004] result() for MulticoreFuture ... done
[10:24:19.004] result() for MulticoreFuture ...
[10:24:19.005] result() for MulticoreFuture ... done
[10:24:19.005]  - Number of value chunks collected: 2
[10:24:19.005] Resolving 2 futures (chunks) ... DONE
[10:24:19.005] Reducing values from 2 chunks ...
[10:24:19.005]  - Number of values collected after concatenation: 3
[10:24:19.005]  - Number of values expected: 3
[10:24:19.005] Reducing values from 2 chunks ... DONE
[10:24:19.006] future_lapply() ... DONE
- exceptions ...
[10:24:19.006] future_lapply() ...
[10:24:19.013] Number of chunks: 2
[10:24:19.013] getGlobalsAndPackagesXApply() ...
[10:24:19.013]  - future.globals: TRUE
[10:24:19.013] getGlobalsAndPackages() ...
[10:24:19.013] Searching for globals...
[10:24:19.017] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:19.017] Searching for globals ... DONE
[10:24:19.017] Resolving globals: FALSE
[10:24:19.018] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[10:24:19.019] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:19.019] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:19.019] - packages: [1] ‘future.apply’
[10:24:19.019] getGlobalsAndPackages() ... DONE
[10:24:19.019]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:19.019]  - needed namespaces: [n=1] ‘future.apply’
[10:24:19.019] Finding globals ... DONE
[10:24:19.019]  - use_args: TRUE
[10:24:19.019]  - Getting '...' globals ...
[10:24:19.020] resolve() on list ...
[10:24:19.020]  recursive: 0
[10:24:19.020]  length: 1
[10:24:19.020]  elements: ‘...’
[10:24:19.020]  length: 0 (resolved future 1)
[10:24:19.020] resolve() on list ... DONE
[10:24:19.020]    - '...' content: [n=0] 
[10:24:19.020] List of 1
[10:24:19.020]  $ ...: list()
[10:24:19.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:19.020]  - attr(*, "where")=List of 1
[10:24:19.020]   ..$ ...:<environment: 0x55b93b388280> 
[10:24:19.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:19.020]  - attr(*, "resolved")= logi TRUE
[10:24:19.020]  - attr(*, "total_size")= num NA
[10:24:19.023]  - Getting '...' globals ... DONE
[10:24:19.023] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:19.024] List of 8
[10:24:19.024]  $ ...future.FUN:function (x, ...)  
[10:24:19.024]  $ x_FUN        :function (x)  
[10:24:19.024]  $ times        : int 2
[10:24:19.024]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:19.024]  $ stop_if_not  :function (...)  
[10:24:19.024]  $ dim          : NULL
[10:24:19.024]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:19.024]  $ ...          : list()
[10:24:19.024]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:19.024]  - attr(*, "where")=List of 8
[10:24:19.024]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:19.024]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:19.024]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:19.024]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:19.024]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:19.024]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:19.024]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:19.024]   ..$ ...          :<environment: 0x55b93b388280> 
[10:24:19.024]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:19.024]  - attr(*, "resolved")= logi FALSE
[10:24:19.024]  - attr(*, "total_size")= num 95128
[10:24:19.032] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:19.032] getGlobalsAndPackagesXApply() ... DONE
[10:24:19.032] Number of futures (= number of chunks): 2
[10:24:19.032] Launching 2 futures (chunks) ...
[10:24:19.032] Chunk #1 of 2 ...
[10:24:19.032]  - Finding globals in 'X' for chunk #1 ...
[10:24:19.032] getGlobalsAndPackages() ...
[10:24:19.032] Searching for globals...
[10:24:19.033] 
[10:24:19.033] Searching for globals ... DONE
[10:24:19.033] - globals: [0] <none>
[10:24:19.033] getGlobalsAndPackages() ... DONE
[10:24:19.033]    + additional globals found: [n=0] 
[10:24:19.033]    + additional namespaces needed: [n=0] 
[10:24:19.033]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:19.033]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:19.033]  - seeds: <none>
[10:24:19.034]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:19.034] getGlobalsAndPackages() ...
[10:24:19.034] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:19.034] Resolving globals: FALSE
[10:24:19.034] Tweak future expression to call with '...' arguments ...
[10:24:19.034] {
[10:24:19.034]     do.call(function(...) {
[10:24:19.034]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:19.034]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:19.034]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:19.034]             on.exit(options(oopts), add = TRUE)
[10:24:19.034]         }
[10:24:19.034]         {
[10:24:19.034]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:19.034]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:19.034]                 ...future.FUN(...future.X_jj, ...)
[10:24:19.034]             })
[10:24:19.034]         }
[10:24:19.034]     }, args = future.call.arguments)
[10:24:19.034] }
[10:24:19.034] Tweak future expression to call with '...' arguments ... DONE
[10:24:19.035] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:19.035] - packages: [1] ‘future.apply’
[10:24:19.035] getGlobalsAndPackages() ... DONE
[10:24:19.035] run() for ‘Future’ ...
[10:24:19.036] - state: ‘created’
[10:24:19.036] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:19.039] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:19.040] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:19.040]   - Field: ‘label’
[10:24:19.040]   - Field: ‘local’
[10:24:19.040]   - Field: ‘owner’
[10:24:19.040]   - Field: ‘envir’
[10:24:19.040]   - Field: ‘workers’
[10:24:19.040]   - Field: ‘packages’
[10:24:19.040]   - Field: ‘gc’
[10:24:19.040]   - Field: ‘job’
[10:24:19.040]   - Field: ‘conditions’
[10:24:19.041]   - Field: ‘expr’
[10:24:19.041]   - Field: ‘uuid’
[10:24:19.041]   - Field: ‘seed’
[10:24:19.041]   - Field: ‘version’
[10:24:19.041]   - Field: ‘result’
[10:24:19.041]   - Field: ‘asynchronous’
[10:24:19.041]   - Field: ‘calls’
[10:24:19.041]   - Field: ‘globals’
[10:24:19.041]   - Field: ‘stdout’
[10:24:19.041]   - Field: ‘earlySignal’
[10:24:19.041]   - Field: ‘lazy’
[10:24:19.042]   - Field: ‘state’
[10:24:19.042] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:19.042] - Launch lazy future ...
[10:24:19.042] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:19.042] Packages needed by future strategies (n = 0): <none>
[10:24:19.043] {
[10:24:19.043]     {
[10:24:19.043]         {
[10:24:19.043]             ...future.startTime <- base::Sys.time()
[10:24:19.043]             {
[10:24:19.043]                 {
[10:24:19.043]                   {
[10:24:19.043]                     {
[10:24:19.043]                       {
[10:24:19.043]                         base::local({
[10:24:19.043]                           has_future <- base::requireNamespace("future", 
[10:24:19.043]                             quietly = TRUE)
[10:24:19.043]                           if (has_future) {
[10:24:19.043]                             ns <- base::getNamespace("future")
[10:24:19.043]                             version <- ns[[".package"]][["version"]]
[10:24:19.043]                             if (is.null(version)) 
[10:24:19.043]                               version <- utils::packageVersion("future")
[10:24:19.043]                           }
[10:24:19.043]                           else {
[10:24:19.043]                             version <- NULL
[10:24:19.043]                           }
[10:24:19.043]                           if (!has_future || version < "1.8.0") {
[10:24:19.043]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:19.043]                               "", base::R.version$version.string), 
[10:24:19.043]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:19.043]                                 base::R.version$platform, 8 * 
[10:24:19.043]                                   base::.Machine$sizeof.pointer), 
[10:24:19.043]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:19.043]                                 "release", "version")], collapse = " "), 
[10:24:19.043]                               hostname = base::Sys.info()[["nodename"]])
[10:24:19.043]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:19.043]                               info)
[10:24:19.043]                             info <- base::paste(info, collapse = "; ")
[10:24:19.043]                             if (!has_future) {
[10:24:19.043]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:19.043]                                 info)
[10:24:19.043]                             }
[10:24:19.043]                             else {
[10:24:19.043]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:19.043]                                 info, version)
[10:24:19.043]                             }
[10:24:19.043]                             base::stop(msg)
[10:24:19.043]                           }
[10:24:19.043]                         })
[10:24:19.043]                       }
[10:24:19.043]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:19.043]                       base::options(mc.cores = 1L)
[10:24:19.043]                     }
[10:24:19.043]                     base::local({
[10:24:19.043]                       for (pkg in "future.apply") {
[10:24:19.043]                         base::loadNamespace(pkg)
[10:24:19.043]                         base::library(pkg, character.only = TRUE)
[10:24:19.043]                       }
[10:24:19.043]                     })
[10:24:19.043]                   }
[10:24:19.043]                   options(future.plan = NULL)
[10:24:19.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:19.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:19.043]                 }
[10:24:19.043]                 ...future.workdir <- getwd()
[10:24:19.043]             }
[10:24:19.043]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:19.043]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:19.043]         }
[10:24:19.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:19.043]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:19.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:19.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:19.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:19.043]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:19.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:19.043]             base::names(...future.oldOptions))
[10:24:19.043]     }
[10:24:19.043]     if (FALSE) {
[10:24:19.043]     }
[10:24:19.043]     else {
[10:24:19.043]         if (TRUE) {
[10:24:19.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:19.043]                 open = "w")
[10:24:19.043]         }
[10:24:19.043]         else {
[10:24:19.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:19.043]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:19.043]         }
[10:24:19.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:19.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:19.043]             base::sink(type = "output", split = FALSE)
[10:24:19.043]             base::close(...future.stdout)
[10:24:19.043]         }, add = TRUE)
[10:24:19.043]     }
[10:24:19.043]     ...future.frame <- base::sys.nframe()
[10:24:19.043]     ...future.conditions <- base::list()
[10:24:19.043]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:19.043]     if (FALSE) {
[10:24:19.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:19.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:19.043]     }
[10:24:19.043]     ...future.result <- base::tryCatch({
[10:24:19.043]         base::withCallingHandlers({
[10:24:19.043]             ...future.value <- base::withVisible(base::local({
[10:24:19.043]                 withCallingHandlers({
[10:24:19.043]                   {
[10:24:19.043]                     do.call(function(...) {
[10:24:19.043]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:19.043]                       if (!identical(...future.globals.maxSize.org, 
[10:24:19.043]                         ...future.globals.maxSize)) {
[10:24:19.043]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:19.043]                         on.exit(options(oopts), add = TRUE)
[10:24:19.043]                       }
[10:24:19.043]                       {
[10:24:19.043]                         lapply(seq_along(...future.elements_ii), 
[10:24:19.043]                           FUN = function(jj) {
[10:24:19.043]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:19.043]                             ...future.FUN(...future.X_jj, ...)
[10:24:19.043]                           })
[10:24:19.043]                       }
[10:24:19.043]                     }, args = future.call.arguments)
[10:24:19.043]                   }
[10:24:19.043]                 }, immediateCondition = function(cond) {
[10:24:19.043]                   save_rds <- function (object, pathname, ...) 
[10:24:19.043]                   {
[10:24:19.043]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:19.043]                     if (file_test("-f", pathname_tmp)) {
[10:24:19.043]                       fi_tmp <- file.info(pathname_tmp)
[10:24:19.043]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:19.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:19.043]                         fi_tmp[["mtime"]])
[10:24:19.043]                     }
[10:24:19.043]                     tryCatch({
[10:24:19.043]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:19.043]                     }, error = function(ex) {
[10:24:19.043]                       msg <- conditionMessage(ex)
[10:24:19.043]                       fi_tmp <- file.info(pathname_tmp)
[10:24:19.043]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:19.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:19.043]                         fi_tmp[["mtime"]], msg)
[10:24:19.043]                       ex$message <- msg
[10:24:19.043]                       stop(ex)
[10:24:19.043]                     })
[10:24:19.043]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:19.043]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:19.043]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:19.043]                       fi_tmp <- file.info(pathname_tmp)
[10:24:19.043]                       fi <- file.info(pathname)
[10:24:19.043]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:19.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:19.043]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:19.043]                         fi[["size"]], fi[["mtime"]])
[10:24:19.043]                       stop(msg)
[10:24:19.043]                     }
[10:24:19.043]                     invisible(pathname)
[10:24:19.043]                   }
[10:24:19.043]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:19.043]                     rootPath = tempdir()) 
[10:24:19.043]                   {
[10:24:19.043]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:19.043]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:19.043]                       tmpdir = path, fileext = ".rds")
[10:24:19.043]                     save_rds(obj, file)
[10:24:19.043]                   }
[10:24:19.043]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:19.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.043]                   {
[10:24:19.043]                     inherits <- base::inherits
[10:24:19.043]                     invokeRestart <- base::invokeRestart
[10:24:19.043]                     is.null <- base::is.null
[10:24:19.043]                     muffled <- FALSE
[10:24:19.043]                     if (inherits(cond, "message")) {
[10:24:19.043]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:19.043]                       if (muffled) 
[10:24:19.043]                         invokeRestart("muffleMessage")
[10:24:19.043]                     }
[10:24:19.043]                     else if (inherits(cond, "warning")) {
[10:24:19.043]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:19.043]                       if (muffled) 
[10:24:19.043]                         invokeRestart("muffleWarning")
[10:24:19.043]                     }
[10:24:19.043]                     else if (inherits(cond, "condition")) {
[10:24:19.043]                       if (!is.null(pattern)) {
[10:24:19.043]                         computeRestarts <- base::computeRestarts
[10:24:19.043]                         grepl <- base::grepl
[10:24:19.043]                         restarts <- computeRestarts(cond)
[10:24:19.043]                         for (restart in restarts) {
[10:24:19.043]                           name <- restart$name
[10:24:19.043]                           if (is.null(name)) 
[10:24:19.043]                             next
[10:24:19.043]                           if (!grepl(pattern, name)) 
[10:24:19.043]                             next
[10:24:19.043]                           invokeRestart(restart)
[10:24:19.043]                           muffled <- TRUE
[10:24:19.043]                           break
[10:24:19.043]                         }
[10:24:19.043]                       }
[10:24:19.043]                     }
[10:24:19.043]                     invisible(muffled)
[10:24:19.043]                   }
[10:24:19.043]                   muffleCondition(cond)
[10:24:19.043]                 })
[10:24:19.043]             }))
[10:24:19.043]             future::FutureResult(value = ...future.value$value, 
[10:24:19.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:19.043]                   ...future.rng), globalenv = if (FALSE) 
[10:24:19.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:19.043]                     ...future.globalenv.names))
[10:24:19.043]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:19.043]         }, condition = base::local({
[10:24:19.043]             c <- base::c
[10:24:19.043]             inherits <- base::inherits
[10:24:19.043]             invokeRestart <- base::invokeRestart
[10:24:19.043]             length <- base::length
[10:24:19.043]             list <- base::list
[10:24:19.043]             seq.int <- base::seq.int
[10:24:19.043]             signalCondition <- base::signalCondition
[10:24:19.043]             sys.calls <- base::sys.calls
[10:24:19.043]             `[[` <- base::`[[`
[10:24:19.043]             `+` <- base::`+`
[10:24:19.043]             `<<-` <- base::`<<-`
[10:24:19.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:19.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:19.043]                   3L)]
[10:24:19.043]             }
[10:24:19.043]             function(cond) {
[10:24:19.043]                 is_error <- inherits(cond, "error")
[10:24:19.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:19.043]                   NULL)
[10:24:19.043]                 if (is_error) {
[10:24:19.043]                   sessionInformation <- function() {
[10:24:19.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:19.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:19.043]                       search = base::search(), system = base::Sys.info())
[10:24:19.043]                   }
[10:24:19.043]                   ...future.conditions[[length(...future.conditions) + 
[10:24:19.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:19.043]                     cond$call), session = sessionInformation(), 
[10:24:19.043]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:19.043]                   signalCondition(cond)
[10:24:19.043]                 }
[10:24:19.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:19.043]                 "immediateCondition"))) {
[10:24:19.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:19.043]                   ...future.conditions[[length(...future.conditions) + 
[10:24:19.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:19.043]                   if (TRUE && !signal) {
[10:24:19.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.043]                     {
[10:24:19.043]                       inherits <- base::inherits
[10:24:19.043]                       invokeRestart <- base::invokeRestart
[10:24:19.043]                       is.null <- base::is.null
[10:24:19.043]                       muffled <- FALSE
[10:24:19.043]                       if (inherits(cond, "message")) {
[10:24:19.043]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:19.043]                         if (muffled) 
[10:24:19.043]                           invokeRestart("muffleMessage")
[10:24:19.043]                       }
[10:24:19.043]                       else if (inherits(cond, "warning")) {
[10:24:19.043]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:19.043]                         if (muffled) 
[10:24:19.043]                           invokeRestart("muffleWarning")
[10:24:19.043]                       }
[10:24:19.043]                       else if (inherits(cond, "condition")) {
[10:24:19.043]                         if (!is.null(pattern)) {
[10:24:19.043]                           computeRestarts <- base::computeRestarts
[10:24:19.043]                           grepl <- base::grepl
[10:24:19.043]                           restarts <- computeRestarts(cond)
[10:24:19.043]                           for (restart in restarts) {
[10:24:19.043]                             name <- restart$name
[10:24:19.043]                             if (is.null(name)) 
[10:24:19.043]                               next
[10:24:19.043]                             if (!grepl(pattern, name)) 
[10:24:19.043]                               next
[10:24:19.043]                             invokeRestart(restart)
[10:24:19.043]                             muffled <- TRUE
[10:24:19.043]                             break
[10:24:19.043]                           }
[10:24:19.043]                         }
[10:24:19.043]                       }
[10:24:19.043]                       invisible(muffled)
[10:24:19.043]                     }
[10:24:19.043]                     muffleCondition(cond, pattern = "^muffle")
[10:24:19.043]                   }
[10:24:19.043]                 }
[10:24:19.043]                 else {
[10:24:19.043]                   if (TRUE) {
[10:24:19.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.043]                     {
[10:24:19.043]                       inherits <- base::inherits
[10:24:19.043]                       invokeRestart <- base::invokeRestart
[10:24:19.043]                       is.null <- base::is.null
[10:24:19.043]                       muffled <- FALSE
[10:24:19.043]                       if (inherits(cond, "message")) {
[10:24:19.043]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:19.043]                         if (muffled) 
[10:24:19.043]                           invokeRestart("muffleMessage")
[10:24:19.043]                       }
[10:24:19.043]                       else if (inherits(cond, "warning")) {
[10:24:19.043]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:19.043]                         if (muffled) 
[10:24:19.043]                           invokeRestart("muffleWarning")
[10:24:19.043]                       }
[10:24:19.043]                       else if (inherits(cond, "condition")) {
[10:24:19.043]                         if (!is.null(pattern)) {
[10:24:19.043]                           computeRestarts <- base::computeRestarts
[10:24:19.043]                           grepl <- base::grepl
[10:24:19.043]                           restarts <- computeRestarts(cond)
[10:24:19.043]                           for (restart in restarts) {
[10:24:19.043]                             name <- restart$name
[10:24:19.043]                             if (is.null(name)) 
[10:24:19.043]                               next
[10:24:19.043]                             if (!grepl(pattern, name)) 
[10:24:19.043]                               next
[10:24:19.043]                             invokeRestart(restart)
[10:24:19.043]                             muffled <- TRUE
[10:24:19.043]                             break
[10:24:19.043]                           }
[10:24:19.043]                         }
[10:24:19.043]                       }
[10:24:19.043]                       invisible(muffled)
[10:24:19.043]                     }
[10:24:19.043]                     muffleCondition(cond, pattern = "^muffle")
[10:24:19.043]                   }
[10:24:19.043]                 }
[10:24:19.043]             }
[10:24:19.043]         }))
[10:24:19.043]     }, error = function(ex) {
[10:24:19.043]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:19.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:19.043]                 ...future.rng), started = ...future.startTime, 
[10:24:19.043]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:19.043]             version = "1.8"), class = "FutureResult")
[10:24:19.043]     }, finally = {
[10:24:19.043]         if (!identical(...future.workdir, getwd())) 
[10:24:19.043]             setwd(...future.workdir)
[10:24:19.043]         {
[10:24:19.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:19.043]                 ...future.oldOptions$nwarnings <- NULL
[10:24:19.043]             }
[10:24:19.043]             base::options(...future.oldOptions)
[10:24:19.043]             if (.Platform$OS.type == "windows") {
[10:24:19.043]                 old_names <- names(...future.oldEnvVars)
[10:24:19.043]                 envs <- base::Sys.getenv()
[10:24:19.043]                 names <- names(envs)
[10:24:19.043]                 common <- intersect(names, old_names)
[10:24:19.043]                 added <- setdiff(names, old_names)
[10:24:19.043]                 removed <- setdiff(old_names, names)
[10:24:19.043]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:19.043]                   envs[common]]
[10:24:19.043]                 NAMES <- toupper(changed)
[10:24:19.043]                 args <- list()
[10:24:19.043]                 for (kk in seq_along(NAMES)) {
[10:24:19.043]                   name <- changed[[kk]]
[10:24:19.043]                   NAME <- NAMES[[kk]]
[10:24:19.043]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.043]                     next
[10:24:19.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:19.043]                 }
[10:24:19.043]                 NAMES <- toupper(added)
[10:24:19.043]                 for (kk in seq_along(NAMES)) {
[10:24:19.043]                   name <- added[[kk]]
[10:24:19.043]                   NAME <- NAMES[[kk]]
[10:24:19.043]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.043]                     next
[10:24:19.043]                   args[[name]] <- ""
[10:24:19.043]                 }
[10:24:19.043]                 NAMES <- toupper(removed)
[10:24:19.043]                 for (kk in seq_along(NAMES)) {
[10:24:19.043]                   name <- removed[[kk]]
[10:24:19.043]                   NAME <- NAMES[[kk]]
[10:24:19.043]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.043]                     next
[10:24:19.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:19.043]                 }
[10:24:19.043]                 if (length(args) > 0) 
[10:24:19.043]                   base::do.call(base::Sys.setenv, args = args)
[10:24:19.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:19.043]             }
[10:24:19.043]             else {
[10:24:19.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:19.043]             }
[10:24:19.043]             {
[10:24:19.043]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:19.043]                   0L) {
[10:24:19.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:19.043]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:19.043]                   base::options(opts)
[10:24:19.043]                 }
[10:24:19.043]                 {
[10:24:19.043]                   {
[10:24:19.043]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:19.043]                     NULL
[10:24:19.043]                   }
[10:24:19.043]                   options(future.plan = NULL)
[10:24:19.043]                   if (is.na(NA_character_)) 
[10:24:19.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:19.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:19.043]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:19.043]                     envir = parent.frame()) 
[10:24:19.043]                   {
[10:24:19.043]                     default_workers <- missing(workers)
[10:24:19.043]                     if (is.function(workers)) 
[10:24:19.043]                       workers <- workers()
[10:24:19.043]                     workers <- structure(as.integer(workers), 
[10:24:19.043]                       class = class(workers))
[10:24:19.043]                     stop_if_not(is.finite(workers), workers >= 
[10:24:19.043]                       1L)
[10:24:19.043]                     if ((workers == 1L && !inherits(workers, 
[10:24:19.043]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:19.043]                       if (default_workers) 
[10:24:19.043]                         supportsMulticore(warn = TRUE)
[10:24:19.043]                       return(sequential(..., envir = envir))
[10:24:19.043]                     }
[10:24:19.043]                     oopts <- options(mc.cores = workers)
[10:24:19.043]                     on.exit(options(oopts))
[10:24:19.043]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:19.043]                       envir = envir)
[10:24:19.043]                     if (!future$lazy) 
[10:24:19.043]                       future <- run(future)
[10:24:19.043]                     invisible(future)
[10:24:19.043]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:19.043]                 }
[10:24:19.043]             }
[10:24:19.043]         }
[10:24:19.043]     })
[10:24:19.043]     if (TRUE) {
[10:24:19.043]         base::sink(type = "output", split = FALSE)
[10:24:19.043]         if (TRUE) {
[10:24:19.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:19.043]         }
[10:24:19.043]         else {
[10:24:19.043]             ...future.result["stdout"] <- base::list(NULL)
[10:24:19.043]         }
[10:24:19.043]         base::close(...future.stdout)
[10:24:19.043]         ...future.stdout <- NULL
[10:24:19.043]     }
[10:24:19.043]     ...future.result$conditions <- ...future.conditions
[10:24:19.043]     ...future.result$finished <- base::Sys.time()
[10:24:19.043]     ...future.result
[10:24:19.043] }
[10:24:19.046] assign_globals() ...
[10:24:19.046] List of 11
[10:24:19.046]  $ ...future.FUN            :function (x, ...)  
[10:24:19.046]  $ x_FUN                    :function (x)  
[10:24:19.046]  $ times                    : int 2
[10:24:19.046]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:19.046]  $ stop_if_not              :function (...)  
[10:24:19.046]  $ dim                      : NULL
[10:24:19.046]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:19.046]  $ future.call.arguments    : list()
[10:24:19.046]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:19.046]  $ ...future.elements_ii    :List of 1
[10:24:19.046]   ..$ : int 1
[10:24:19.046]  $ ...future.seeds_ii       : NULL
[10:24:19.046]  $ ...future.globals.maxSize: NULL
[10:24:19.046]  - attr(*, "where")=List of 11
[10:24:19.046]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:19.046]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:19.046]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:19.046]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:19.046]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:19.046]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:19.046]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:19.046]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:19.046]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:19.046]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:19.046]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:19.046]  - attr(*, "resolved")= logi FALSE
[10:24:19.046]  - attr(*, "total_size")= num 95128
[10:24:19.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:19.046]  - attr(*, "already-done")= logi TRUE
[10:24:19.056] - copied ‘...future.FUN’ to environment
[10:24:19.056] - copied ‘x_FUN’ to environment
[10:24:19.056] - copied ‘times’ to environment
[10:24:19.056] - copied ‘stopf’ to environment
[10:24:19.056] - copied ‘stop_if_not’ to environment
[10:24:19.056] - copied ‘dim’ to environment
[10:24:19.057] - copied ‘valid_types’ to environment
[10:24:19.057] - copied ‘future.call.arguments’ to environment
[10:24:19.057] - copied ‘...future.elements_ii’ to environment
[10:24:19.057] - copied ‘...future.seeds_ii’ to environment
[10:24:19.057] - copied ‘...future.globals.maxSize’ to environment
[10:24:19.057] assign_globals() ... done
[10:24:19.057] requestCore(): workers = 2
[10:24:19.060] MulticoreFuture started
[10:24:19.060] - Launch lazy future ... done
[10:24:19.061] run() for ‘MulticoreFuture’ ... done
[10:24:19.061] Created future:
[10:24:19.062] plan(): Setting new future strategy stack:
[10:24:19.062] List of future strategies:
[10:24:19.062] 1. sequential:
[10:24:19.062]    - args: function (..., envir = parent.frame())
[10:24:19.062]    - tweaked: FALSE
[10:24:19.062]    - call: NULL
[10:24:19.063] plan(): nbrOfWorkers() = 1
[10:24:19.065] plan(): Setting new future strategy stack:
[10:24:19.065] List of future strategies:
[10:24:19.065] 1. multicore:
[10:24:19.065]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:19.065]    - tweaked: FALSE
[10:24:19.065]    - call: plan(strategy)
[10:24:19.072] plan(): nbrOfWorkers() = 2
[10:24:19.061] MulticoreFuture:
[10:24:19.061] Label: ‘future_vapply-1’
[10:24:19.061] Expression:
[10:24:19.061] {
[10:24:19.061]     do.call(function(...) {
[10:24:19.061]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:19.061]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:19.061]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:19.061]             on.exit(options(oopts), add = TRUE)
[10:24:19.061]         }
[10:24:19.061]         {
[10:24:19.061]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:19.061]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:19.061]                 ...future.FUN(...future.X_jj, ...)
[10:24:19.061]             })
[10:24:19.061]         }
[10:24:19.061]     }, args = future.call.arguments)
[10:24:19.061] }
[10:24:19.061] Lazy evaluation: FALSE
[10:24:19.061] Asynchronous evaluation: TRUE
[10:24:19.061] Local evaluation: TRUE
[10:24:19.061] Environment: R_GlobalEnv
[10:24:19.061] Capture standard output: TRUE
[10:24:19.061] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:19.061] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:19.061] Packages: 1 packages (‘future.apply’)
[10:24:19.061] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:19.061] Resolved: FALSE
[10:24:19.061] Value: <not collected>
[10:24:19.061] Conditions captured: <none>
[10:24:19.061] Early signaling: FALSE
[10:24:19.061] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:19.061] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:19.075] Chunk #1 of 2 ... DONE
[10:24:19.075] Chunk #2 of 2 ...
[10:24:19.075]  - Finding globals in 'X' for chunk #2 ...
[10:24:19.076] getGlobalsAndPackages() ...
[10:24:19.076] Searching for globals...
[10:24:19.076] 
[10:24:19.077] Searching for globals ... DONE
[10:24:19.077] - globals: [0] <none>
[10:24:19.077] getGlobalsAndPackages() ... DONE
[10:24:19.077]    + additional globals found: [n=0] 
[10:24:19.077]    + additional namespaces needed: [n=0] 
[10:24:19.077]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:19.077]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:19.078]  - seeds: <none>
[10:24:19.078]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:19.078] getGlobalsAndPackages() ...
[10:24:19.078] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:19.078] Resolving globals: FALSE
[10:24:19.078] Tweak future expression to call with '...' arguments ...
[10:24:19.079] {
[10:24:19.079]     do.call(function(...) {
[10:24:19.079]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:19.079]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:19.079]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:19.079]             on.exit(options(oopts), add = TRUE)
[10:24:19.079]         }
[10:24:19.079]         {
[10:24:19.079]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:19.079]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:19.079]                 ...future.FUN(...future.X_jj, ...)
[10:24:19.079]             })
[10:24:19.079]         }
[10:24:19.079]     }, args = future.call.arguments)
[10:24:19.079] }
[10:24:19.079] Tweak future expression to call with '...' arguments ... DONE
[10:24:19.080] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:19.080] - packages: [1] ‘future.apply’
[10:24:19.080] getGlobalsAndPackages() ... DONE
[10:24:19.081] run() for ‘Future’ ...
[10:24:19.081] - state: ‘created’
[10:24:19.081] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:19.086] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:19.086] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:19.086]   - Field: ‘label’
[10:24:19.086]   - Field: ‘local’
[10:24:19.086]   - Field: ‘owner’
[10:24:19.087]   - Field: ‘envir’
[10:24:19.087]   - Field: ‘workers’
[10:24:19.087]   - Field: ‘packages’
[10:24:19.087]   - Field: ‘gc’
[10:24:19.087]   - Field: ‘job’
[10:24:19.087]   - Field: ‘conditions’
[10:24:19.087]   - Field: ‘expr’
[10:24:19.088]   - Field: ‘uuid’
[10:24:19.088]   - Field: ‘seed’
[10:24:19.088]   - Field: ‘version’
[10:24:19.088]   - Field: ‘result’
[10:24:19.088]   - Field: ‘asynchronous’
[10:24:19.088]   - Field: ‘calls’
[10:24:19.089]   - Field: ‘globals’
[10:24:19.089]   - Field: ‘stdout’
[10:24:19.089]   - Field: ‘earlySignal’
[10:24:19.089]   - Field: ‘lazy’
[10:24:19.089]   - Field: ‘state’
[10:24:19.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:19.089] - Launch lazy future ...
[10:24:19.090] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:19.090] Packages needed by future strategies (n = 0): <none>
[10:24:19.091] {
[10:24:19.091]     {
[10:24:19.091]         {
[10:24:19.091]             ...future.startTime <- base::Sys.time()
[10:24:19.091]             {
[10:24:19.091]                 {
[10:24:19.091]                   {
[10:24:19.091]                     {
[10:24:19.091]                       {
[10:24:19.091]                         base::local({
[10:24:19.091]                           has_future <- base::requireNamespace("future", 
[10:24:19.091]                             quietly = TRUE)
[10:24:19.091]                           if (has_future) {
[10:24:19.091]                             ns <- base::getNamespace("future")
[10:24:19.091]                             version <- ns[[".package"]][["version"]]
[10:24:19.091]                             if (is.null(version)) 
[10:24:19.091]                               version <- utils::packageVersion("future")
[10:24:19.091]                           }
[10:24:19.091]                           else {
[10:24:19.091]                             version <- NULL
[10:24:19.091]                           }
[10:24:19.091]                           if (!has_future || version < "1.8.0") {
[10:24:19.091]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:19.091]                               "", base::R.version$version.string), 
[10:24:19.091]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:19.091]                                 base::R.version$platform, 8 * 
[10:24:19.091]                                   base::.Machine$sizeof.pointer), 
[10:24:19.091]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:19.091]                                 "release", "version")], collapse = " "), 
[10:24:19.091]                               hostname = base::Sys.info()[["nodename"]])
[10:24:19.091]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:19.091]                               info)
[10:24:19.091]                             info <- base::paste(info, collapse = "; ")
[10:24:19.091]                             if (!has_future) {
[10:24:19.091]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:19.091]                                 info)
[10:24:19.091]                             }
[10:24:19.091]                             else {
[10:24:19.091]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:19.091]                                 info, version)
[10:24:19.091]                             }
[10:24:19.091]                             base::stop(msg)
[10:24:19.091]                           }
[10:24:19.091]                         })
[10:24:19.091]                       }
[10:24:19.091]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:19.091]                       base::options(mc.cores = 1L)
[10:24:19.091]                     }
[10:24:19.091]                     base::local({
[10:24:19.091]                       for (pkg in "future.apply") {
[10:24:19.091]                         base::loadNamespace(pkg)
[10:24:19.091]                         base::library(pkg, character.only = TRUE)
[10:24:19.091]                       }
[10:24:19.091]                     })
[10:24:19.091]                   }
[10:24:19.091]                   options(future.plan = NULL)
[10:24:19.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:19.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:19.091]                 }
[10:24:19.091]                 ...future.workdir <- getwd()
[10:24:19.091]             }
[10:24:19.091]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:19.091]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:19.091]         }
[10:24:19.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:19.091]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:19.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:19.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:19.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:19.091]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:19.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:19.091]             base::names(...future.oldOptions))
[10:24:19.091]     }
[10:24:19.091]     if (FALSE) {
[10:24:19.091]     }
[10:24:19.091]     else {
[10:24:19.091]         if (TRUE) {
[10:24:19.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:19.091]                 open = "w")
[10:24:19.091]         }
[10:24:19.091]         else {
[10:24:19.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:19.091]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:19.091]         }
[10:24:19.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:19.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:19.091]             base::sink(type = "output", split = FALSE)
[10:24:19.091]             base::close(...future.stdout)
[10:24:19.091]         }, add = TRUE)
[10:24:19.091]     }
[10:24:19.091]     ...future.frame <- base::sys.nframe()
[10:24:19.091]     ...future.conditions <- base::list()
[10:24:19.091]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:19.091]     if (FALSE) {
[10:24:19.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:19.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:19.091]     }
[10:24:19.091]     ...future.result <- base::tryCatch({
[10:24:19.091]         base::withCallingHandlers({
[10:24:19.091]             ...future.value <- base::withVisible(base::local({
[10:24:19.091]                 withCallingHandlers({
[10:24:19.091]                   {
[10:24:19.091]                     do.call(function(...) {
[10:24:19.091]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:19.091]                       if (!identical(...future.globals.maxSize.org, 
[10:24:19.091]                         ...future.globals.maxSize)) {
[10:24:19.091]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:19.091]                         on.exit(options(oopts), add = TRUE)
[10:24:19.091]                       }
[10:24:19.091]                       {
[10:24:19.091]                         lapply(seq_along(...future.elements_ii), 
[10:24:19.091]                           FUN = function(jj) {
[10:24:19.091]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:19.091]                             ...future.FUN(...future.X_jj, ...)
[10:24:19.091]                           })
[10:24:19.091]                       }
[10:24:19.091]                     }, args = future.call.arguments)
[10:24:19.091]                   }
[10:24:19.091]                 }, immediateCondition = function(cond) {
[10:24:19.091]                   save_rds <- function (object, pathname, ...) 
[10:24:19.091]                   {
[10:24:19.091]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:19.091]                     if (file_test("-f", pathname_tmp)) {
[10:24:19.091]                       fi_tmp <- file.info(pathname_tmp)
[10:24:19.091]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:19.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:19.091]                         fi_tmp[["mtime"]])
[10:24:19.091]                     }
[10:24:19.091]                     tryCatch({
[10:24:19.091]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:19.091]                     }, error = function(ex) {
[10:24:19.091]                       msg <- conditionMessage(ex)
[10:24:19.091]                       fi_tmp <- file.info(pathname_tmp)
[10:24:19.091]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:19.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:19.091]                         fi_tmp[["mtime"]], msg)
[10:24:19.091]                       ex$message <- msg
[10:24:19.091]                       stop(ex)
[10:24:19.091]                     })
[10:24:19.091]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:19.091]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:19.091]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:19.091]                       fi_tmp <- file.info(pathname_tmp)
[10:24:19.091]                       fi <- file.info(pathname)
[10:24:19.091]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:19.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:19.091]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:19.091]                         fi[["size"]], fi[["mtime"]])
[10:24:19.091]                       stop(msg)
[10:24:19.091]                     }
[10:24:19.091]                     invisible(pathname)
[10:24:19.091]                   }
[10:24:19.091]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:19.091]                     rootPath = tempdir()) 
[10:24:19.091]                   {
[10:24:19.091]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:19.091]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:19.091]                       tmpdir = path, fileext = ".rds")
[10:24:19.091]                     save_rds(obj, file)
[10:24:19.091]                   }
[10:24:19.091]                   saveImmediateCondition(cond, path = "/tmp/Rtmprwau2G/.future/immediateConditions")
[10:24:19.091]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.091]                   {
[10:24:19.091]                     inherits <- base::inherits
[10:24:19.091]                     invokeRestart <- base::invokeRestart
[10:24:19.091]                     is.null <- base::is.null
[10:24:19.091]                     muffled <- FALSE
[10:24:19.091]                     if (inherits(cond, "message")) {
[10:24:19.091]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:19.091]                       if (muffled) 
[10:24:19.091]                         invokeRestart("muffleMessage")
[10:24:19.091]                     }
[10:24:19.091]                     else if (inherits(cond, "warning")) {
[10:24:19.091]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:19.091]                       if (muffled) 
[10:24:19.091]                         invokeRestart("muffleWarning")
[10:24:19.091]                     }
[10:24:19.091]                     else if (inherits(cond, "condition")) {
[10:24:19.091]                       if (!is.null(pattern)) {
[10:24:19.091]                         computeRestarts <- base::computeRestarts
[10:24:19.091]                         grepl <- base::grepl
[10:24:19.091]                         restarts <- computeRestarts(cond)
[10:24:19.091]                         for (restart in restarts) {
[10:24:19.091]                           name <- restart$name
[10:24:19.091]                           if (is.null(name)) 
[10:24:19.091]                             next
[10:24:19.091]                           if (!grepl(pattern, name)) 
[10:24:19.091]                             next
[10:24:19.091]                           invokeRestart(restart)
[10:24:19.091]                           muffled <- TRUE
[10:24:19.091]                           break
[10:24:19.091]                         }
[10:24:19.091]                       }
[10:24:19.091]                     }
[10:24:19.091]                     invisible(muffled)
[10:24:19.091]                   }
[10:24:19.091]                   muffleCondition(cond)
[10:24:19.091]                 })
[10:24:19.091]             }))
[10:24:19.091]             future::FutureResult(value = ...future.value$value, 
[10:24:19.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:19.091]                   ...future.rng), globalenv = if (FALSE) 
[10:24:19.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:19.091]                     ...future.globalenv.names))
[10:24:19.091]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:19.091]         }, condition = base::local({
[10:24:19.091]             c <- base::c
[10:24:19.091]             inherits <- base::inherits
[10:24:19.091]             invokeRestart <- base::invokeRestart
[10:24:19.091]             length <- base::length
[10:24:19.091]             list <- base::list
[10:24:19.091]             seq.int <- base::seq.int
[10:24:19.091]             signalCondition <- base::signalCondition
[10:24:19.091]             sys.calls <- base::sys.calls
[10:24:19.091]             `[[` <- base::`[[`
[10:24:19.091]             `+` <- base::`+`
[10:24:19.091]             `<<-` <- base::`<<-`
[10:24:19.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:19.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:19.091]                   3L)]
[10:24:19.091]             }
[10:24:19.091]             function(cond) {
[10:24:19.091]                 is_error <- inherits(cond, "error")
[10:24:19.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:19.091]                   NULL)
[10:24:19.091]                 if (is_error) {
[10:24:19.091]                   sessionInformation <- function() {
[10:24:19.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:19.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:19.091]                       search = base::search(), system = base::Sys.info())
[10:24:19.091]                   }
[10:24:19.091]                   ...future.conditions[[length(...future.conditions) + 
[10:24:19.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:19.091]                     cond$call), session = sessionInformation(), 
[10:24:19.091]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:19.091]                   signalCondition(cond)
[10:24:19.091]                 }
[10:24:19.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:19.091]                 "immediateCondition"))) {
[10:24:19.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:19.091]                   ...future.conditions[[length(...future.conditions) + 
[10:24:19.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:19.091]                   if (TRUE && !signal) {
[10:24:19.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.091]                     {
[10:24:19.091]                       inherits <- base::inherits
[10:24:19.091]                       invokeRestart <- base::invokeRestart
[10:24:19.091]                       is.null <- base::is.null
[10:24:19.091]                       muffled <- FALSE
[10:24:19.091]                       if (inherits(cond, "message")) {
[10:24:19.091]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:19.091]                         if (muffled) 
[10:24:19.091]                           invokeRestart("muffleMessage")
[10:24:19.091]                       }
[10:24:19.091]                       else if (inherits(cond, "warning")) {
[10:24:19.091]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:19.091]                         if (muffled) 
[10:24:19.091]                           invokeRestart("muffleWarning")
[10:24:19.091]                       }
[10:24:19.091]                       else if (inherits(cond, "condition")) {
[10:24:19.091]                         if (!is.null(pattern)) {
[10:24:19.091]                           computeRestarts <- base::computeRestarts
[10:24:19.091]                           grepl <- base::grepl
[10:24:19.091]                           restarts <- computeRestarts(cond)
[10:24:19.091]                           for (restart in restarts) {
[10:24:19.091]                             name <- restart$name
[10:24:19.091]                             if (is.null(name)) 
[10:24:19.091]                               next
[10:24:19.091]                             if (!grepl(pattern, name)) 
[10:24:19.091]                               next
[10:24:19.091]                             invokeRestart(restart)
[10:24:19.091]                             muffled <- TRUE
[10:24:19.091]                             break
[10:24:19.091]                           }
[10:24:19.091]                         }
[10:24:19.091]                       }
[10:24:19.091]                       invisible(muffled)
[10:24:19.091]                     }
[10:24:19.091]                     muffleCondition(cond, pattern = "^muffle")
[10:24:19.091]                   }
[10:24:19.091]                 }
[10:24:19.091]                 else {
[10:24:19.091]                   if (TRUE) {
[10:24:19.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.091]                     {
[10:24:19.091]                       inherits <- base::inherits
[10:24:19.091]                       invokeRestart <- base::invokeRestart
[10:24:19.091]                       is.null <- base::is.null
[10:24:19.091]                       muffled <- FALSE
[10:24:19.091]                       if (inherits(cond, "message")) {
[10:24:19.091]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:19.091]                         if (muffled) 
[10:24:19.091]                           invokeRestart("muffleMessage")
[10:24:19.091]                       }
[10:24:19.091]                       else if (inherits(cond, "warning")) {
[10:24:19.091]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:19.091]                         if (muffled) 
[10:24:19.091]                           invokeRestart("muffleWarning")
[10:24:19.091]                       }
[10:24:19.091]                       else if (inherits(cond, "condition")) {
[10:24:19.091]                         if (!is.null(pattern)) {
[10:24:19.091]                           computeRestarts <- base::computeRestarts
[10:24:19.091]                           grepl <- base::grepl
[10:24:19.091]                           restarts <- computeRestarts(cond)
[10:24:19.091]                           for (restart in restarts) {
[10:24:19.091]                             name <- restart$name
[10:24:19.091]                             if (is.null(name)) 
[10:24:19.091]                               next
[10:24:19.091]                             if (!grepl(pattern, name)) 
[10:24:19.091]                               next
[10:24:19.091]                             invokeRestart(restart)
[10:24:19.091]                             muffled <- TRUE
[10:24:19.091]                             break
[10:24:19.091]                           }
[10:24:19.091]                         }
[10:24:19.091]                       }
[10:24:19.091]                       invisible(muffled)
[10:24:19.091]                     }
[10:24:19.091]                     muffleCondition(cond, pattern = "^muffle")
[10:24:19.091]                   }
[10:24:19.091]                 }
[10:24:19.091]             }
[10:24:19.091]         }))
[10:24:19.091]     }, error = function(ex) {
[10:24:19.091]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:19.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:19.091]                 ...future.rng), started = ...future.startTime, 
[10:24:19.091]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:19.091]             version = "1.8"), class = "FutureResult")
[10:24:19.091]     }, finally = {
[10:24:19.091]         if (!identical(...future.workdir, getwd())) 
[10:24:19.091]             setwd(...future.workdir)
[10:24:19.091]         {
[10:24:19.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:19.091]                 ...future.oldOptions$nwarnings <- NULL
[10:24:19.091]             }
[10:24:19.091]             base::options(...future.oldOptions)
[10:24:19.091]             if (.Platform$OS.type == "windows") {
[10:24:19.091]                 old_names <- names(...future.oldEnvVars)
[10:24:19.091]                 envs <- base::Sys.getenv()
[10:24:19.091]                 names <- names(envs)
[10:24:19.091]                 common <- intersect(names, old_names)
[10:24:19.091]                 added <- setdiff(names, old_names)
[10:24:19.091]                 removed <- setdiff(old_names, names)
[10:24:19.091]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:19.091]                   envs[common]]
[10:24:19.091]                 NAMES <- toupper(changed)
[10:24:19.091]                 args <- list()
[10:24:19.091]                 for (kk in seq_along(NAMES)) {
[10:24:19.091]                   name <- changed[[kk]]
[10:24:19.091]                   NAME <- NAMES[[kk]]
[10:24:19.091]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.091]                     next
[10:24:19.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:19.091]                 }
[10:24:19.091]                 NAMES <- toupper(added)
[10:24:19.091]                 for (kk in seq_along(NAMES)) {
[10:24:19.091]                   name <- added[[kk]]
[10:24:19.091]                   NAME <- NAMES[[kk]]
[10:24:19.091]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.091]                     next
[10:24:19.091]                   args[[name]] <- ""
[10:24:19.091]                 }
[10:24:19.091]                 NAMES <- toupper(removed)
[10:24:19.091]                 for (kk in seq_along(NAMES)) {
[10:24:19.091]                   name <- removed[[kk]]
[10:24:19.091]                   NAME <- NAMES[[kk]]
[10:24:19.091]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.091]                     next
[10:24:19.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:19.091]                 }
[10:24:19.091]                 if (length(args) > 0) 
[10:24:19.091]                   base::do.call(base::Sys.setenv, args = args)
[10:24:19.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:19.091]             }
[10:24:19.091]             else {
[10:24:19.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:19.091]             }
[10:24:19.091]             {
[10:24:19.091]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:19.091]                   0L) {
[10:24:19.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:19.091]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:19.091]                   base::options(opts)
[10:24:19.091]                 }
[10:24:19.091]                 {
[10:24:19.091]                   {
[10:24:19.091]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:19.091]                     NULL
[10:24:19.091]                   }
[10:24:19.091]                   options(future.plan = NULL)
[10:24:19.091]                   if (is.na(NA_character_)) 
[10:24:19.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:19.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:19.091]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:19.091]                     envir = parent.frame()) 
[10:24:19.091]                   {
[10:24:19.091]                     default_workers <- missing(workers)
[10:24:19.091]                     if (is.function(workers)) 
[10:24:19.091]                       workers <- workers()
[10:24:19.091]                     workers <- structure(as.integer(workers), 
[10:24:19.091]                       class = class(workers))
[10:24:19.091]                     stop_if_not(is.finite(workers), workers >= 
[10:24:19.091]                       1L)
[10:24:19.091]                     if ((workers == 1L && !inherits(workers, 
[10:24:19.091]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:19.091]                       if (default_workers) 
[10:24:19.091]                         supportsMulticore(warn = TRUE)
[10:24:19.091]                       return(sequential(..., envir = envir))
[10:24:19.091]                     }
[10:24:19.091]                     oopts <- options(mc.cores = workers)
[10:24:19.091]                     on.exit(options(oopts))
[10:24:19.091]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:19.091]                       envir = envir)
[10:24:19.091]                     if (!future$lazy) 
[10:24:19.091]                       future <- run(future)
[10:24:19.091]                     invisible(future)
[10:24:19.091]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:19.091]                 }
[10:24:19.091]             }
[10:24:19.091]         }
[10:24:19.091]     })
[10:24:19.091]     if (TRUE) {
[10:24:19.091]         base::sink(type = "output", split = FALSE)
[10:24:19.091]         if (TRUE) {
[10:24:19.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:19.091]         }
[10:24:19.091]         else {
[10:24:19.091]             ...future.result["stdout"] <- base::list(NULL)
[10:24:19.091]         }
[10:24:19.091]         base::close(...future.stdout)
[10:24:19.091]         ...future.stdout <- NULL
[10:24:19.091]     }
[10:24:19.091]     ...future.result$conditions <- ...future.conditions
[10:24:19.091]     ...future.result$finished <- base::Sys.time()
[10:24:19.091]     ...future.result
[10:24:19.091] }
[10:24:19.097] assign_globals() ...
[10:24:19.098] List of 11
[10:24:19.098]  $ ...future.FUN            :function (x, ...)  
[10:24:19.098]  $ x_FUN                    :function (x)  
[10:24:19.098]  $ times                    : int 2
[10:24:19.098]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:19.098]  $ stop_if_not              :function (...)  
[10:24:19.098]  $ dim                      : NULL
[10:24:19.098]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:24:19.098]  $ future.call.arguments    : list()
[10:24:19.098]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:19.098]  $ ...future.elements_ii    :List of 2
[10:24:19.098]   ..$ : int 2
[10:24:19.098]   ..$ : int 3
[10:24:19.098]  $ ...future.seeds_ii       : NULL
[10:24:19.098]  $ ...future.globals.maxSize: NULL
[10:24:19.098]  - attr(*, "where")=List of 11
[10:24:19.098]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:19.098]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:24:19.098]   ..$ times                    :<environment: R_EmptyEnv> 
[10:24:19.098]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:24:19.098]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:24:19.098]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:24:19.098]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:24:19.098]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:19.098]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:19.098]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:19.098]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:19.098]  - attr(*, "resolved")= logi FALSE
[10:24:19.098]  - attr(*, "total_size")= num 95128
[10:24:19.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:19.098]  - attr(*, "already-done")= logi TRUE
[10:24:19.111] - copied ‘...future.FUN’ to environment
[10:24:19.111] - copied ‘x_FUN’ to environment
[10:24:19.111] - copied ‘times’ to environment
[10:24:19.111] - copied ‘stopf’ to environment
[10:24:19.111] - copied ‘stop_if_not’ to environment
[10:24:19.111] - copied ‘dim’ to environment
[10:24:19.111] - copied ‘valid_types’ to environment
[10:24:19.112] - copied ‘future.call.arguments’ to environment
[10:24:19.112] - copied ‘...future.elements_ii’ to environment
[10:24:19.112] - copied ‘...future.seeds_ii’ to environment
[10:24:19.112] - copied ‘...future.globals.maxSize’ to environment
[10:24:19.112] assign_globals() ... done
[10:24:19.112] requestCore(): workers = 2
[10:24:19.115] MulticoreFuture started
[10:24:19.115] - Launch lazy future ... done
[10:24:19.115] run() for ‘MulticoreFuture’ ... done
[10:24:19.115] Created future:
[10:24:19.116] plan(): Setting new future strategy stack:
[10:24:19.116] List of future strategies:
[10:24:19.116] 1. sequential:
[10:24:19.116]    - args: function (..., envir = parent.frame())
[10:24:19.116]    - tweaked: FALSE
[10:24:19.116]    - call: NULL
[10:24:19.117] plan(): nbrOfWorkers() = 1
[10:24:19.119] plan(): Setting new future strategy stack:
[10:24:19.119] List of future strategies:
[10:24:19.119] 1. multicore:
[10:24:19.119]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:19.119]    - tweaked: FALSE
[10:24:19.119]    - call: plan(strategy)
[10:24:19.125] plan(): nbrOfWorkers() = 2
[10:24:19.116] MulticoreFuture:
[10:24:19.116] Label: ‘future_vapply-2’
[10:24:19.116] Expression:
[10:24:19.116] {
[10:24:19.116]     do.call(function(...) {
[10:24:19.116]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:19.116]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:19.116]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:19.116]             on.exit(options(oopts), add = TRUE)
[10:24:19.116]         }
[10:24:19.116]         {
[10:24:19.116]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:19.116]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:19.116]                 ...future.FUN(...future.X_jj, ...)
[10:24:19.116]             })
[10:24:19.116]         }
[10:24:19.116]     }, args = future.call.arguments)
[10:24:19.116] }
[10:24:19.116] Lazy evaluation: FALSE
[10:24:19.116] Asynchronous evaluation: TRUE
[10:24:19.116] Local evaluation: TRUE
[10:24:19.116] Environment: R_GlobalEnv
[10:24:19.116] Capture standard output: TRUE
[10:24:19.116] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:19.116] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:19.116] Packages: 1 packages (‘future.apply’)
[10:24:19.116] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:19.116] Resolved: FALSE
[10:24:19.116] Value: <not collected>
[10:24:19.116] Conditions captured: <none>
[10:24:19.116] Early signaling: FALSE
[10:24:19.116] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:19.116] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:19.129] Chunk #2 of 2 ... DONE
[10:24:19.129] Launching 2 futures (chunks) ... DONE
[10:24:19.129] Resolving 2 futures (chunks) ...
[10:24:19.130] resolve() on list ...
[10:24:19.130]  recursive: 0
[10:24:19.130]  length: 2
[10:24:19.130] 
[10:24:19.130] Future #1
[10:24:19.131] result() for MulticoreFuture ...
[10:24:19.143] result() for MulticoreFuture ...
[10:24:19.144] result() for MulticoreFuture ... done
[10:24:19.144] signalConditions() ...
[10:24:19.144]  - include = ‘immediateCondition’
[10:24:19.144]  - exclude = 
[10:24:19.144]  - resignal = FALSE
[10:24:19.145]  - Number of conditions: 1
[10:24:19.145] signalConditions() ... done
[10:24:19.145] result() for MulticoreFuture ... done
[10:24:19.145] result() for MulticoreFuture ...
[10:24:19.145] result() for MulticoreFuture ... done
[10:24:19.146] signalConditions() ...
[10:24:19.146]  - include = ‘immediateCondition’
[10:24:19.146]  - exclude = 
[10:24:19.146]  - resignal = FALSE
[10:24:19.146]  - Number of conditions: 1
[10:24:19.147] signalConditions() ... done
[10:24:19.147] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:19.147] - nx: 2
[10:24:19.147] - relay: TRUE
[10:24:19.147] - stdout: TRUE
[10:24:19.148] - signal: TRUE
[10:24:19.148] - resignal: FALSE
[10:24:19.148] - force: TRUE
[10:24:19.148] - relayed: [n=2] FALSE, FALSE
[10:24:19.148] - queued futures: [n=2] FALSE, FALSE
[10:24:19.148]  - until=1
[10:24:19.149]  - relaying element #1
[10:24:19.149] result() for MulticoreFuture ...
[10:24:19.149] result() for MulticoreFuture ... done
[10:24:19.149] result() for MulticoreFuture ...
[10:24:19.149] result() for MulticoreFuture ... done
[10:24:19.149] signalConditions() ...
[10:24:19.150]  - include = ‘immediateCondition’
[10:24:19.150]  - exclude = 
[10:24:19.150]  - resignal = FALSE
[10:24:19.150]  - Number of conditions: 1
[10:24:19.150] signalConditions() ... done
[10:24:19.151] result() for MulticoreFuture ...
[10:24:19.151] result() for MulticoreFuture ... done
[10:24:19.151] signalConditions() ...
[10:24:19.151]  - include = ‘immediateCondition’
[10:24:19.151]  - exclude = 
[10:24:19.151]  - resignal = FALSE
[10:24:19.152]  - Number of conditions: 1
[10:24:19.152] signalConditions() ... done
[10:24:19.152] result() for MulticoreFuture ...
[10:24:19.152] result() for MulticoreFuture ... done
[10:24:19.152] signalConditions() ...
[10:24:19.152]  - include = ‘condition’
[10:24:19.153]  - exclude = ‘immediateCondition’
[10:24:19.153]  - resignal = TRUE
[10:24:19.153]  - Number of conditions: 1
[10:24:19.153]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:24:19.153] signalConditions() ... done
[10:24:19.153] - relayed: [n=2] FALSE, FALSE
[10:24:19.154] - queued futures: [n=2] TRUE, FALSE
[10:24:19.154] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:19.154] plan(): Setting new future strategy stack:
[10:24:19.154] List of future strategies:
[10:24:19.154] 1. sequential:
[10:24:19.154]    - args: function (..., envir = parent.frame())
[10:24:19.154]    - tweaked: FALSE
[10:24:19.154]    - call: plan(sequential)
[10:24:19.155] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:24:19.156] plan(): Setting new future strategy stack:
[10:24:19.156] List of future strategies:
[10:24:19.156] 1. multisession:
[10:24:19.156]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:19.156]    - tweaked: FALSE
[10:24:19.156]    - call: plan(strategy)
[10:24:19.156] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:24:19.156] multisession:
[10:24:19.156] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:19.156] - tweaked: FALSE
[10:24:19.156] - call: plan(strategy)
[10:24:19.164] getGlobalsAndPackages() ...
[10:24:19.164] Not searching for globals
[10:24:19.164] - globals: [0] <none>
[10:24:19.164] getGlobalsAndPackages() ... DONE
[10:24:19.165] [local output] makeClusterPSOCK() ...
[10:24:19.244] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:24:19.245] [local output] Base port: 11184
[10:24:19.246] [local output] Getting setup options for 2 cluster nodes ...
[10:24:19.246] [local output]  - Node 1 of 2 ...
[10:24:19.246] [local output] localMachine=TRUE => revtunnel=FALSE

[10:24:19.247] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmprwau2G/worker.rank=1.parallelly.parent=77888.130404a3ef617.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmprwau2G/worker.rank=1.parallelly.parent=77888.130404a3ef617.pid")'’
[10:24:19.437] - Possible to infer worker's PID: TRUE
[10:24:19.438] [local output] Rscript port: 11184

[10:24:19.438] [local output]  - Node 2 of 2 ...
[10:24:19.439] [local output] localMachine=TRUE => revtunnel=FALSE

[10:24:19.439] [local output] Rscript port: 11184

[10:24:19.439] [local output] Getting setup options for 2 cluster nodes ... done
[10:24:19.440] [local output]  - Parallel setup requested for some PSOCK nodes
[10:24:19.440] [local output] Setting up PSOCK nodes in parallel
[10:24:19.440] List of 36
[10:24:19.440]  $ worker          : chr "localhost"
[10:24:19.440]   ..- attr(*, "localhost")= logi TRUE
[10:24:19.440]  $ master          : chr "localhost"
[10:24:19.440]  $ port            : int 11184
[10:24:19.440]  $ connectTimeout  : num 120
[10:24:19.440]  $ timeout         : num 2592000
[10:24:19.440]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:24:19.440]  $ homogeneous     : logi TRUE
[10:24:19.440]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:24:19.440]  $ rscript_envs    : NULL
[10:24:19.440]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:24:19.440]  $ rscript_startup : NULL
[10:24:19.440]  $ rscript_sh      : chr "sh"
[10:24:19.440]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:24:19.440]  $ methods         : logi TRUE
[10:24:19.440]  $ socketOptions   : chr "no-delay"
[10:24:19.440]  $ useXDR          : logi FALSE
[10:24:19.440]  $ outfile         : chr "/dev/null"
[10:24:19.440]  $ renice          : int NA
[10:24:19.440]  $ rshcmd          : NULL
[10:24:19.440]  $ user            : chr(0) 
[10:24:19.440]  $ revtunnel       : logi FALSE
[10:24:19.440]  $ rshlogfile      : NULL
[10:24:19.440]  $ rshopts         : chr(0) 
[10:24:19.440]  $ rank            : int 1
[10:24:19.440]  $ manual          : logi FALSE
[10:24:19.440]  $ dryrun          : logi FALSE
[10:24:19.440]  $ quiet           : logi FALSE
[10:24:19.440]  $ setup_strategy  : chr "parallel"
[10:24:19.440]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:24:19.440]  $ pidfile         : chr "/tmp/Rtmprwau2G/worker.rank=1.parallelly.parent=77888.130404a3ef617.pid"
[10:24:19.440]  $ rshcmd_label    : NULL
[10:24:19.440]  $ rsh_call        : NULL
[10:24:19.440]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:24:19.440]  $ localMachine    : logi TRUE
[10:24:19.440]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:24:19.440]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:24:19.440]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:24:19.440]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:24:19.440]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:24:19.440]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:24:19.440]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:24:19.440]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:24:19.440]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:24:19.440]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:24:19.440]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:24:19.440]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:24:19.440]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:24:19.440]  $ arguments       :List of 28
[10:24:19.440]   ..$ worker          : chr "localhost"
[10:24:19.440]   ..$ master          : NULL
[10:24:19.440]   ..$ port            : int 11184
[10:24:19.440]   ..$ connectTimeout  : num 120
[10:24:19.440]   ..$ timeout         : num 2592000
[10:24:19.440]   ..$ rscript         : NULL
[10:24:19.440]   ..$ homogeneous     : NULL
[10:24:19.440]   ..$ rscript_args    : NULL
[10:24:19.440]   ..$ rscript_envs    : NULL
[10:24:19.440]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:24:19.440]   ..$ rscript_startup : NULL
[10:24:19.440]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:24:19.440]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:24:19.440]   ..$ methods         : logi TRUE
[10:24:19.440]   ..$ socketOptions   : chr "no-delay"
[10:24:19.440]   ..$ useXDR          : logi FALSE
[10:24:19.440]   ..$ outfile         : chr "/dev/null"
[10:24:19.440]   ..$ renice          : int NA
[10:24:19.440]   ..$ rshcmd          : NULL
[10:24:19.440]   ..$ user            : NULL
[10:24:19.440]   ..$ revtunnel       : logi NA
[10:24:19.440]   ..$ rshlogfile      : NULL
[10:24:19.440]   ..$ rshopts         : NULL
[10:24:19.440]   ..$ rank            : int 1
[10:24:19.440]   ..$ manual          : logi FALSE
[10:24:19.440]   ..$ dryrun          : logi FALSE
[10:24:19.440]   ..$ quiet           : logi FALSE
[10:24:19.440]   ..$ setup_strategy  : chr "parallel"
[10:24:19.440]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:24:19.459] [local output] System call to launch all workers:
[10:24:19.459] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmprwau2G/worker.rank=1.parallelly.parent=77888.130404a3ef617.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11184 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:24:19.459] [local output] Starting PSOCK main server
[10:24:19.465] [local output] Workers launched
[10:24:19.465] [local output] Waiting for workers to connect back
[10:24:19.466]  - [local output] 0 workers out of 2 ready
[10:24:19.728]  - [local output] 0 workers out of 2 ready
[10:24:19.729]  - [local output] 1 workers out of 2 ready
[10:24:19.739]  - [local output] 1 workers out of 2 ready
[10:24:19.739]  - [local output] 2 workers out of 2 ready
[10:24:19.739] [local output] Launching of workers completed
[10:24:19.739] [local output] Collecting session information from workers
[10:24:19.740] [local output]  - Worker #1 of 2
[10:24:19.740] [local output]  - Worker #2 of 2
[10:24:19.741] [local output] makeClusterPSOCK() ... done
[10:24:19.752] Packages needed by the future expression (n = 0): <none>
[10:24:19.752] Packages needed by future strategies (n = 0): <none>
[10:24:19.752] {
[10:24:19.752]     {
[10:24:19.752]         {
[10:24:19.752]             ...future.startTime <- base::Sys.time()
[10:24:19.752]             {
[10:24:19.752]                 {
[10:24:19.752]                   {
[10:24:19.752]                     {
[10:24:19.752]                       base::local({
[10:24:19.752]                         has_future <- base::requireNamespace("future", 
[10:24:19.752]                           quietly = TRUE)
[10:24:19.752]                         if (has_future) {
[10:24:19.752]                           ns <- base::getNamespace("future")
[10:24:19.752]                           version <- ns[[".package"]][["version"]]
[10:24:19.752]                           if (is.null(version)) 
[10:24:19.752]                             version <- utils::packageVersion("future")
[10:24:19.752]                         }
[10:24:19.752]                         else {
[10:24:19.752]                           version <- NULL
[10:24:19.752]                         }
[10:24:19.752]                         if (!has_future || version < "1.8.0") {
[10:24:19.752]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:19.752]                             "", base::R.version$version.string), 
[10:24:19.752]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:19.752]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:19.752]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:19.752]                               "release", "version")], collapse = " "), 
[10:24:19.752]                             hostname = base::Sys.info()[["nodename"]])
[10:24:19.752]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:19.752]                             info)
[10:24:19.752]                           info <- base::paste(info, collapse = "; ")
[10:24:19.752]                           if (!has_future) {
[10:24:19.752]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:19.752]                               info)
[10:24:19.752]                           }
[10:24:19.752]                           else {
[10:24:19.752]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:19.752]                               info, version)
[10:24:19.752]                           }
[10:24:19.752]                           base::stop(msg)
[10:24:19.752]                         }
[10:24:19.752]                       })
[10:24:19.752]                     }
[10:24:19.752]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:19.752]                     base::options(mc.cores = 1L)
[10:24:19.752]                   }
[10:24:19.752]                   options(future.plan = NULL)
[10:24:19.752]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:19.752]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:19.752]                 }
[10:24:19.752]                 ...future.workdir <- getwd()
[10:24:19.752]             }
[10:24:19.752]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:19.752]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:19.752]         }
[10:24:19.752]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:19.752]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:19.752]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:19.752]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:19.752]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:19.752]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:19.752]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:19.752]             base::names(...future.oldOptions))
[10:24:19.752]     }
[10:24:19.752]     if (FALSE) {
[10:24:19.752]     }
[10:24:19.752]     else {
[10:24:19.752]         if (TRUE) {
[10:24:19.752]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:19.752]                 open = "w")
[10:24:19.752]         }
[10:24:19.752]         else {
[10:24:19.752]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:19.752]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:19.752]         }
[10:24:19.752]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:19.752]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:19.752]             base::sink(type = "output", split = FALSE)
[10:24:19.752]             base::close(...future.stdout)
[10:24:19.752]         }, add = TRUE)
[10:24:19.752]     }
[10:24:19.752]     ...future.frame <- base::sys.nframe()
[10:24:19.752]     ...future.conditions <- base::list()
[10:24:19.752]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:19.752]     if (FALSE) {
[10:24:19.752]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:19.752]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:19.752]     }
[10:24:19.752]     ...future.result <- base::tryCatch({
[10:24:19.752]         base::withCallingHandlers({
[10:24:19.752]             ...future.value <- base::withVisible(base::local({
[10:24:19.752]                 ...future.makeSendCondition <- base::local({
[10:24:19.752]                   sendCondition <- NULL
[10:24:19.752]                   function(frame = 1L) {
[10:24:19.752]                     if (is.function(sendCondition)) 
[10:24:19.752]                       return(sendCondition)
[10:24:19.752]                     ns <- getNamespace("parallel")
[10:24:19.752]                     if (exists("sendData", mode = "function", 
[10:24:19.752]                       envir = ns)) {
[10:24:19.752]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:19.752]                         envir = ns)
[10:24:19.752]                       envir <- sys.frame(frame)
[10:24:19.752]                       master <- NULL
[10:24:19.752]                       while (!identical(envir, .GlobalEnv) && 
[10:24:19.752]                         !identical(envir, emptyenv())) {
[10:24:19.752]                         if (exists("master", mode = "list", envir = envir, 
[10:24:19.752]                           inherits = FALSE)) {
[10:24:19.752]                           master <- get("master", mode = "list", 
[10:24:19.752]                             envir = envir, inherits = FALSE)
[10:24:19.752]                           if (inherits(master, c("SOCKnode", 
[10:24:19.752]                             "SOCK0node"))) {
[10:24:19.752]                             sendCondition <<- function(cond) {
[10:24:19.752]                               data <- list(type = "VALUE", value = cond, 
[10:24:19.752]                                 success = TRUE)
[10:24:19.752]                               parallel_sendData(master, data)
[10:24:19.752]                             }
[10:24:19.752]                             return(sendCondition)
[10:24:19.752]                           }
[10:24:19.752]                         }
[10:24:19.752]                         frame <- frame + 1L
[10:24:19.752]                         envir <- sys.frame(frame)
[10:24:19.752]                       }
[10:24:19.752]                     }
[10:24:19.752]                     sendCondition <<- function(cond) NULL
[10:24:19.752]                   }
[10:24:19.752]                 })
[10:24:19.752]                 withCallingHandlers({
[10:24:19.752]                   NA
[10:24:19.752]                 }, immediateCondition = function(cond) {
[10:24:19.752]                   sendCondition <- ...future.makeSendCondition()
[10:24:19.752]                   sendCondition(cond)
[10:24:19.752]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.752]                   {
[10:24:19.752]                     inherits <- base::inherits
[10:24:19.752]                     invokeRestart <- base::invokeRestart
[10:24:19.752]                     is.null <- base::is.null
[10:24:19.752]                     muffled <- FALSE
[10:24:19.752]                     if (inherits(cond, "message")) {
[10:24:19.752]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:19.752]                       if (muffled) 
[10:24:19.752]                         invokeRestart("muffleMessage")
[10:24:19.752]                     }
[10:24:19.752]                     else if (inherits(cond, "warning")) {
[10:24:19.752]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:19.752]                       if (muffled) 
[10:24:19.752]                         invokeRestart("muffleWarning")
[10:24:19.752]                     }
[10:24:19.752]                     else if (inherits(cond, "condition")) {
[10:24:19.752]                       if (!is.null(pattern)) {
[10:24:19.752]                         computeRestarts <- base::computeRestarts
[10:24:19.752]                         grepl <- base::grepl
[10:24:19.752]                         restarts <- computeRestarts(cond)
[10:24:19.752]                         for (restart in restarts) {
[10:24:19.752]                           name <- restart$name
[10:24:19.752]                           if (is.null(name)) 
[10:24:19.752]                             next
[10:24:19.752]                           if (!grepl(pattern, name)) 
[10:24:19.752]                             next
[10:24:19.752]                           invokeRestart(restart)
[10:24:19.752]                           muffled <- TRUE
[10:24:19.752]                           break
[10:24:19.752]                         }
[10:24:19.752]                       }
[10:24:19.752]                     }
[10:24:19.752]                     invisible(muffled)
[10:24:19.752]                   }
[10:24:19.752]                   muffleCondition(cond)
[10:24:19.752]                 })
[10:24:19.752]             }))
[10:24:19.752]             future::FutureResult(value = ...future.value$value, 
[10:24:19.752]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:19.752]                   ...future.rng), globalenv = if (FALSE) 
[10:24:19.752]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:19.752]                     ...future.globalenv.names))
[10:24:19.752]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:19.752]         }, condition = base::local({
[10:24:19.752]             c <- base::c
[10:24:19.752]             inherits <- base::inherits
[10:24:19.752]             invokeRestart <- base::invokeRestart
[10:24:19.752]             length <- base::length
[10:24:19.752]             list <- base::list
[10:24:19.752]             seq.int <- base::seq.int
[10:24:19.752]             signalCondition <- base::signalCondition
[10:24:19.752]             sys.calls <- base::sys.calls
[10:24:19.752]             `[[` <- base::`[[`
[10:24:19.752]             `+` <- base::`+`
[10:24:19.752]             `<<-` <- base::`<<-`
[10:24:19.752]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:19.752]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:19.752]                   3L)]
[10:24:19.752]             }
[10:24:19.752]             function(cond) {
[10:24:19.752]                 is_error <- inherits(cond, "error")
[10:24:19.752]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:19.752]                   NULL)
[10:24:19.752]                 if (is_error) {
[10:24:19.752]                   sessionInformation <- function() {
[10:24:19.752]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:19.752]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:19.752]                       search = base::search(), system = base::Sys.info())
[10:24:19.752]                   }
[10:24:19.752]                   ...future.conditions[[length(...future.conditions) + 
[10:24:19.752]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:19.752]                     cond$call), session = sessionInformation(), 
[10:24:19.752]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:19.752]                   signalCondition(cond)
[10:24:19.752]                 }
[10:24:19.752]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:19.752]                 "immediateCondition"))) {
[10:24:19.752]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:19.752]                   ...future.conditions[[length(...future.conditions) + 
[10:24:19.752]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:19.752]                   if (TRUE && !signal) {
[10:24:19.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.752]                     {
[10:24:19.752]                       inherits <- base::inherits
[10:24:19.752]                       invokeRestart <- base::invokeRestart
[10:24:19.752]                       is.null <- base::is.null
[10:24:19.752]                       muffled <- FALSE
[10:24:19.752]                       if (inherits(cond, "message")) {
[10:24:19.752]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:19.752]                         if (muffled) 
[10:24:19.752]                           invokeRestart("muffleMessage")
[10:24:19.752]                       }
[10:24:19.752]                       else if (inherits(cond, "warning")) {
[10:24:19.752]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:19.752]                         if (muffled) 
[10:24:19.752]                           invokeRestart("muffleWarning")
[10:24:19.752]                       }
[10:24:19.752]                       else if (inherits(cond, "condition")) {
[10:24:19.752]                         if (!is.null(pattern)) {
[10:24:19.752]                           computeRestarts <- base::computeRestarts
[10:24:19.752]                           grepl <- base::grepl
[10:24:19.752]                           restarts <- computeRestarts(cond)
[10:24:19.752]                           for (restart in restarts) {
[10:24:19.752]                             name <- restart$name
[10:24:19.752]                             if (is.null(name)) 
[10:24:19.752]                               next
[10:24:19.752]                             if (!grepl(pattern, name)) 
[10:24:19.752]                               next
[10:24:19.752]                             invokeRestart(restart)
[10:24:19.752]                             muffled <- TRUE
[10:24:19.752]                             break
[10:24:19.752]                           }
[10:24:19.752]                         }
[10:24:19.752]                       }
[10:24:19.752]                       invisible(muffled)
[10:24:19.752]                     }
[10:24:19.752]                     muffleCondition(cond, pattern = "^muffle")
[10:24:19.752]                   }
[10:24:19.752]                 }
[10:24:19.752]                 else {
[10:24:19.752]                   if (TRUE) {
[10:24:19.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.752]                     {
[10:24:19.752]                       inherits <- base::inherits
[10:24:19.752]                       invokeRestart <- base::invokeRestart
[10:24:19.752]                       is.null <- base::is.null
[10:24:19.752]                       muffled <- FALSE
[10:24:19.752]                       if (inherits(cond, "message")) {
[10:24:19.752]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:19.752]                         if (muffled) 
[10:24:19.752]                           invokeRestart("muffleMessage")
[10:24:19.752]                       }
[10:24:19.752]                       else if (inherits(cond, "warning")) {
[10:24:19.752]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:19.752]                         if (muffled) 
[10:24:19.752]                           invokeRestart("muffleWarning")
[10:24:19.752]                       }
[10:24:19.752]                       else if (inherits(cond, "condition")) {
[10:24:19.752]                         if (!is.null(pattern)) {
[10:24:19.752]                           computeRestarts <- base::computeRestarts
[10:24:19.752]                           grepl <- base::grepl
[10:24:19.752]                           restarts <- computeRestarts(cond)
[10:24:19.752]                           for (restart in restarts) {
[10:24:19.752]                             name <- restart$name
[10:24:19.752]                             if (is.null(name)) 
[10:24:19.752]                               next
[10:24:19.752]                             if (!grepl(pattern, name)) 
[10:24:19.752]                               next
[10:24:19.752]                             invokeRestart(restart)
[10:24:19.752]                             muffled <- TRUE
[10:24:19.752]                             break
[10:24:19.752]                           }
[10:24:19.752]                         }
[10:24:19.752]                       }
[10:24:19.752]                       invisible(muffled)
[10:24:19.752]                     }
[10:24:19.752]                     muffleCondition(cond, pattern = "^muffle")
[10:24:19.752]                   }
[10:24:19.752]                 }
[10:24:19.752]             }
[10:24:19.752]         }))
[10:24:19.752]     }, error = function(ex) {
[10:24:19.752]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:19.752]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:19.752]                 ...future.rng), started = ...future.startTime, 
[10:24:19.752]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:19.752]             version = "1.8"), class = "FutureResult")
[10:24:19.752]     }, finally = {
[10:24:19.752]         if (!identical(...future.workdir, getwd())) 
[10:24:19.752]             setwd(...future.workdir)
[10:24:19.752]         {
[10:24:19.752]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:19.752]                 ...future.oldOptions$nwarnings <- NULL
[10:24:19.752]             }
[10:24:19.752]             base::options(...future.oldOptions)
[10:24:19.752]             if (.Platform$OS.type == "windows") {
[10:24:19.752]                 old_names <- names(...future.oldEnvVars)
[10:24:19.752]                 envs <- base::Sys.getenv()
[10:24:19.752]                 names <- names(envs)
[10:24:19.752]                 common <- intersect(names, old_names)
[10:24:19.752]                 added <- setdiff(names, old_names)
[10:24:19.752]                 removed <- setdiff(old_names, names)
[10:24:19.752]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:19.752]                   envs[common]]
[10:24:19.752]                 NAMES <- toupper(changed)
[10:24:19.752]                 args <- list()
[10:24:19.752]                 for (kk in seq_along(NAMES)) {
[10:24:19.752]                   name <- changed[[kk]]
[10:24:19.752]                   NAME <- NAMES[[kk]]
[10:24:19.752]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.752]                     next
[10:24:19.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:19.752]                 }
[10:24:19.752]                 NAMES <- toupper(added)
[10:24:19.752]                 for (kk in seq_along(NAMES)) {
[10:24:19.752]                   name <- added[[kk]]
[10:24:19.752]                   NAME <- NAMES[[kk]]
[10:24:19.752]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.752]                     next
[10:24:19.752]                   args[[name]] <- ""
[10:24:19.752]                 }
[10:24:19.752]                 NAMES <- toupper(removed)
[10:24:19.752]                 for (kk in seq_along(NAMES)) {
[10:24:19.752]                   name <- removed[[kk]]
[10:24:19.752]                   NAME <- NAMES[[kk]]
[10:24:19.752]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.752]                     next
[10:24:19.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:19.752]                 }
[10:24:19.752]                 if (length(args) > 0) 
[10:24:19.752]                   base::do.call(base::Sys.setenv, args = args)
[10:24:19.752]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:19.752]             }
[10:24:19.752]             else {
[10:24:19.752]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:19.752]             }
[10:24:19.752]             {
[10:24:19.752]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:19.752]                   0L) {
[10:24:19.752]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:19.752]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:19.752]                   base::options(opts)
[10:24:19.752]                 }
[10:24:19.752]                 {
[10:24:19.752]                   {
[10:24:19.752]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:19.752]                     NULL
[10:24:19.752]                   }
[10:24:19.752]                   options(future.plan = NULL)
[10:24:19.752]                   if (is.na(NA_character_)) 
[10:24:19.752]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:19.752]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:19.752]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:19.752]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:19.752]                     envir = parent.frame()) 
[10:24:19.752]                   {
[10:24:19.752]                     if (is.function(workers)) 
[10:24:19.752]                       workers <- workers()
[10:24:19.752]                     workers <- structure(as.integer(workers), 
[10:24:19.752]                       class = class(workers))
[10:24:19.752]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:19.752]                       workers >= 1)
[10:24:19.752]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:19.752]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:19.752]                     }
[10:24:19.752]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:19.752]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:19.752]                       envir = envir)
[10:24:19.752]                     if (!future$lazy) 
[10:24:19.752]                       future <- run(future)
[10:24:19.752]                     invisible(future)
[10:24:19.752]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:19.752]                 }
[10:24:19.752]             }
[10:24:19.752]         }
[10:24:19.752]     })
[10:24:19.752]     if (TRUE) {
[10:24:19.752]         base::sink(type = "output", split = FALSE)
[10:24:19.752]         if (TRUE) {
[10:24:19.752]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:19.752]         }
[10:24:19.752]         else {
[10:24:19.752]             ...future.result["stdout"] <- base::list(NULL)
[10:24:19.752]         }
[10:24:19.752]         base::close(...future.stdout)
[10:24:19.752]         ...future.stdout <- NULL
[10:24:19.752]     }
[10:24:19.752]     ...future.result$conditions <- ...future.conditions
[10:24:19.752]     ...future.result$finished <- base::Sys.time()
[10:24:19.752]     ...future.result
[10:24:19.752] }
[10:24:19.807] MultisessionFuture started
[10:24:19.807] result() for ClusterFuture ...
[10:24:19.808] receiveMessageFromWorker() for ClusterFuture ...
[10:24:19.808] - Validating connection of MultisessionFuture
[10:24:19.851] - received message: FutureResult
[10:24:19.851] - Received FutureResult
[10:24:19.852] - Erased future from FutureRegistry
[10:24:19.852] result() for ClusterFuture ...
[10:24:19.852] - result already collected: FutureResult
[10:24:19.852] result() for ClusterFuture ... done
[10:24:19.852] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:19.852] result() for ClusterFuture ... done
[10:24:19.852] result() for ClusterFuture ...
[10:24:19.853] - result already collected: FutureResult
[10:24:19.853] result() for ClusterFuture ... done
[10:24:19.853] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:24:19.857] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[10:24:19.860] future_lapply() ...
[10:24:19.865] Number of chunks: 2
[10:24:19.866] getGlobalsAndPackagesXApply() ...
[10:24:19.866]  - future.globals: TRUE
[10:24:19.866] getGlobalsAndPackages() ...
[10:24:19.866] Searching for globals...
[10:24:19.870] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:19.870] Searching for globals ... DONE
[10:24:19.870] Resolving globals: FALSE
[10:24:19.871] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[10:24:19.872] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:19.872] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:19.872] - packages: [1] ‘future.apply’
[10:24:19.872] getGlobalsAndPackages() ... DONE
[10:24:19.872]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:19.872]  - needed namespaces: [n=1] ‘future.apply’
[10:24:19.872] Finding globals ... DONE
[10:24:19.873]  - use_args: TRUE
[10:24:19.873]  - Getting '...' globals ...
[10:24:19.873] resolve() on list ...
[10:24:19.873]  recursive: 0
[10:24:19.873]  length: 1
[10:24:19.873]  elements: ‘...’
[10:24:19.874]  length: 0 (resolved future 1)
[10:24:19.874] resolve() on list ... DONE
[10:24:19.874]    - '...' content: [n=0] 
[10:24:19.874] List of 1
[10:24:19.874]  $ ...: list()
[10:24:19.874]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:19.874]  - attr(*, "where")=List of 1
[10:24:19.874]   ..$ ...:<environment: 0x55b93e2875d8> 
[10:24:19.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:19.874]  - attr(*, "resolved")= logi TRUE
[10:24:19.874]  - attr(*, "total_size")= num NA
[10:24:19.877]  - Getting '...' globals ... DONE
[10:24:19.877] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:19.877] List of 8
[10:24:19.877]  $ ...future.FUN:function (x, ...)  
[10:24:19.877]  $ x_FUN        :function (x)  
[10:24:19.877]  $ times        : int 1
[10:24:19.877]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:19.877]  $ stop_if_not  :function (...)  
[10:24:19.877]  $ dim          : NULL
[10:24:19.877]  $ valid_types  : chr "character"
[10:24:19.877]  $ ...          : list()
[10:24:19.877]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:19.877]  - attr(*, "where")=List of 8
[10:24:19.877]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:19.877]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:19.877]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:19.877]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:19.877]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:19.877]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:19.877]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:19.877]   ..$ ...          :<environment: 0x55b93e2875d8> 
[10:24:19.877]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:19.877]  - attr(*, "resolved")= logi FALSE
[10:24:19.877]  - attr(*, "total_size")= num 94208
[10:24:19.884] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:19.884] getGlobalsAndPackagesXApply() ... DONE
[10:24:19.885] Number of futures (= number of chunks): 2
[10:24:19.885] Launching 2 futures (chunks) ...
[10:24:19.885] Chunk #1 of 2 ...
[10:24:19.885]  - Finding globals in 'X' for chunk #1 ...
[10:24:19.885] getGlobalsAndPackages() ...
[10:24:19.885] Searching for globals...
[10:24:19.886] 
[10:24:19.886] Searching for globals ... DONE
[10:24:19.886] - globals: [0] <none>
[10:24:19.886] getGlobalsAndPackages() ... DONE
[10:24:19.886]    + additional globals found: [n=0] 
[10:24:19.886]    + additional namespaces needed: [n=0] 
[10:24:19.886]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:19.886]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:19.886]  - seeds: <none>
[10:24:19.887]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:19.887] getGlobalsAndPackages() ...
[10:24:19.887] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:19.887] Resolving globals: FALSE
[10:24:19.887] Tweak future expression to call with '...' arguments ...
[10:24:19.887] {
[10:24:19.887]     do.call(function(...) {
[10:24:19.887]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:19.887]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:19.887]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:19.887]             on.exit(options(oopts), add = TRUE)
[10:24:19.887]         }
[10:24:19.887]         {
[10:24:19.887]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:19.887]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:19.887]                 ...future.FUN(...future.X_jj, ...)
[10:24:19.887]             })
[10:24:19.887]         }
[10:24:19.887]     }, args = future.call.arguments)
[10:24:19.887] }
[10:24:19.888] Tweak future expression to call with '...' arguments ... DONE
[10:24:19.888] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:19.888] - packages: [1] ‘future.apply’
[10:24:19.888] getGlobalsAndPackages() ... DONE
[10:24:19.889] run() for ‘Future’ ...
[10:24:19.889] - state: ‘created’
[10:24:19.889] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:19.903] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:19.903] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:19.904]   - Field: ‘node’
[10:24:19.904]   - Field: ‘label’
[10:24:19.904]   - Field: ‘local’
[10:24:19.904]   - Field: ‘owner’
[10:24:19.904]   - Field: ‘envir’
[10:24:19.904]   - Field: ‘workers’
[10:24:19.904]   - Field: ‘packages’
[10:24:19.904]   - Field: ‘gc’
[10:24:19.904]   - Field: ‘conditions’
[10:24:19.904]   - Field: ‘persistent’
[10:24:19.905]   - Field: ‘expr’
[10:24:19.905]   - Field: ‘uuid’
[10:24:19.905]   - Field: ‘seed’
[10:24:19.905]   - Field: ‘version’
[10:24:19.905]   - Field: ‘result’
[10:24:19.905]   - Field: ‘asynchronous’
[10:24:19.905]   - Field: ‘calls’
[10:24:19.905]   - Field: ‘globals’
[10:24:19.906]   - Field: ‘stdout’
[10:24:19.906]   - Field: ‘earlySignal’
[10:24:19.906]   - Field: ‘lazy’
[10:24:19.906]   - Field: ‘state’
[10:24:19.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:19.906] - Launch lazy future ...
[10:24:19.906] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:19.907] Packages needed by future strategies (n = 0): <none>
[10:24:19.907] {
[10:24:19.907]     {
[10:24:19.907]         {
[10:24:19.907]             ...future.startTime <- base::Sys.time()
[10:24:19.907]             {
[10:24:19.907]                 {
[10:24:19.907]                   {
[10:24:19.907]                     {
[10:24:19.907]                       {
[10:24:19.907]                         base::local({
[10:24:19.907]                           has_future <- base::requireNamespace("future", 
[10:24:19.907]                             quietly = TRUE)
[10:24:19.907]                           if (has_future) {
[10:24:19.907]                             ns <- base::getNamespace("future")
[10:24:19.907]                             version <- ns[[".package"]][["version"]]
[10:24:19.907]                             if (is.null(version)) 
[10:24:19.907]                               version <- utils::packageVersion("future")
[10:24:19.907]                           }
[10:24:19.907]                           else {
[10:24:19.907]                             version <- NULL
[10:24:19.907]                           }
[10:24:19.907]                           if (!has_future || version < "1.8.0") {
[10:24:19.907]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:19.907]                               "", base::R.version$version.string), 
[10:24:19.907]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:19.907]                                 base::R.version$platform, 8 * 
[10:24:19.907]                                   base::.Machine$sizeof.pointer), 
[10:24:19.907]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:19.907]                                 "release", "version")], collapse = " "), 
[10:24:19.907]                               hostname = base::Sys.info()[["nodename"]])
[10:24:19.907]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:19.907]                               info)
[10:24:19.907]                             info <- base::paste(info, collapse = "; ")
[10:24:19.907]                             if (!has_future) {
[10:24:19.907]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:19.907]                                 info)
[10:24:19.907]                             }
[10:24:19.907]                             else {
[10:24:19.907]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:19.907]                                 info, version)
[10:24:19.907]                             }
[10:24:19.907]                             base::stop(msg)
[10:24:19.907]                           }
[10:24:19.907]                         })
[10:24:19.907]                       }
[10:24:19.907]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:19.907]                       base::options(mc.cores = 1L)
[10:24:19.907]                     }
[10:24:19.907]                     base::local({
[10:24:19.907]                       for (pkg in "future.apply") {
[10:24:19.907]                         base::loadNamespace(pkg)
[10:24:19.907]                         base::library(pkg, character.only = TRUE)
[10:24:19.907]                       }
[10:24:19.907]                     })
[10:24:19.907]                   }
[10:24:19.907]                   options(future.plan = NULL)
[10:24:19.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:19.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:19.907]                 }
[10:24:19.907]                 ...future.workdir <- getwd()
[10:24:19.907]             }
[10:24:19.907]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:19.907]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:19.907]         }
[10:24:19.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:19.907]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:19.907]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:19.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:19.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:19.907]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:19.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:19.907]             base::names(...future.oldOptions))
[10:24:19.907]     }
[10:24:19.907]     if (FALSE) {
[10:24:19.907]     }
[10:24:19.907]     else {
[10:24:19.907]         if (TRUE) {
[10:24:19.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:19.907]                 open = "w")
[10:24:19.907]         }
[10:24:19.907]         else {
[10:24:19.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:19.907]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:19.907]         }
[10:24:19.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:19.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:19.907]             base::sink(type = "output", split = FALSE)
[10:24:19.907]             base::close(...future.stdout)
[10:24:19.907]         }, add = TRUE)
[10:24:19.907]     }
[10:24:19.907]     ...future.frame <- base::sys.nframe()
[10:24:19.907]     ...future.conditions <- base::list()
[10:24:19.907]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:19.907]     if (FALSE) {
[10:24:19.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:19.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:19.907]     }
[10:24:19.907]     ...future.result <- base::tryCatch({
[10:24:19.907]         base::withCallingHandlers({
[10:24:19.907]             ...future.value <- base::withVisible(base::local({
[10:24:19.907]                 ...future.makeSendCondition <- base::local({
[10:24:19.907]                   sendCondition <- NULL
[10:24:19.907]                   function(frame = 1L) {
[10:24:19.907]                     if (is.function(sendCondition)) 
[10:24:19.907]                       return(sendCondition)
[10:24:19.907]                     ns <- getNamespace("parallel")
[10:24:19.907]                     if (exists("sendData", mode = "function", 
[10:24:19.907]                       envir = ns)) {
[10:24:19.907]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:19.907]                         envir = ns)
[10:24:19.907]                       envir <- sys.frame(frame)
[10:24:19.907]                       master <- NULL
[10:24:19.907]                       while (!identical(envir, .GlobalEnv) && 
[10:24:19.907]                         !identical(envir, emptyenv())) {
[10:24:19.907]                         if (exists("master", mode = "list", envir = envir, 
[10:24:19.907]                           inherits = FALSE)) {
[10:24:19.907]                           master <- get("master", mode = "list", 
[10:24:19.907]                             envir = envir, inherits = FALSE)
[10:24:19.907]                           if (inherits(master, c("SOCKnode", 
[10:24:19.907]                             "SOCK0node"))) {
[10:24:19.907]                             sendCondition <<- function(cond) {
[10:24:19.907]                               data <- list(type = "VALUE", value = cond, 
[10:24:19.907]                                 success = TRUE)
[10:24:19.907]                               parallel_sendData(master, data)
[10:24:19.907]                             }
[10:24:19.907]                             return(sendCondition)
[10:24:19.907]                           }
[10:24:19.907]                         }
[10:24:19.907]                         frame <- frame + 1L
[10:24:19.907]                         envir <- sys.frame(frame)
[10:24:19.907]                       }
[10:24:19.907]                     }
[10:24:19.907]                     sendCondition <<- function(cond) NULL
[10:24:19.907]                   }
[10:24:19.907]                 })
[10:24:19.907]                 withCallingHandlers({
[10:24:19.907]                   {
[10:24:19.907]                     do.call(function(...) {
[10:24:19.907]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:19.907]                       if (!identical(...future.globals.maxSize.org, 
[10:24:19.907]                         ...future.globals.maxSize)) {
[10:24:19.907]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:19.907]                         on.exit(options(oopts), add = TRUE)
[10:24:19.907]                       }
[10:24:19.907]                       {
[10:24:19.907]                         lapply(seq_along(...future.elements_ii), 
[10:24:19.907]                           FUN = function(jj) {
[10:24:19.907]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:19.907]                             ...future.FUN(...future.X_jj, ...)
[10:24:19.907]                           })
[10:24:19.907]                       }
[10:24:19.907]                     }, args = future.call.arguments)
[10:24:19.907]                   }
[10:24:19.907]                 }, immediateCondition = function(cond) {
[10:24:19.907]                   sendCondition <- ...future.makeSendCondition()
[10:24:19.907]                   sendCondition(cond)
[10:24:19.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.907]                   {
[10:24:19.907]                     inherits <- base::inherits
[10:24:19.907]                     invokeRestart <- base::invokeRestart
[10:24:19.907]                     is.null <- base::is.null
[10:24:19.907]                     muffled <- FALSE
[10:24:19.907]                     if (inherits(cond, "message")) {
[10:24:19.907]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:19.907]                       if (muffled) 
[10:24:19.907]                         invokeRestart("muffleMessage")
[10:24:19.907]                     }
[10:24:19.907]                     else if (inherits(cond, "warning")) {
[10:24:19.907]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:19.907]                       if (muffled) 
[10:24:19.907]                         invokeRestart("muffleWarning")
[10:24:19.907]                     }
[10:24:19.907]                     else if (inherits(cond, "condition")) {
[10:24:19.907]                       if (!is.null(pattern)) {
[10:24:19.907]                         computeRestarts <- base::computeRestarts
[10:24:19.907]                         grepl <- base::grepl
[10:24:19.907]                         restarts <- computeRestarts(cond)
[10:24:19.907]                         for (restart in restarts) {
[10:24:19.907]                           name <- restart$name
[10:24:19.907]                           if (is.null(name)) 
[10:24:19.907]                             next
[10:24:19.907]                           if (!grepl(pattern, name)) 
[10:24:19.907]                             next
[10:24:19.907]                           invokeRestart(restart)
[10:24:19.907]                           muffled <- TRUE
[10:24:19.907]                           break
[10:24:19.907]                         }
[10:24:19.907]                       }
[10:24:19.907]                     }
[10:24:19.907]                     invisible(muffled)
[10:24:19.907]                   }
[10:24:19.907]                   muffleCondition(cond)
[10:24:19.907]                 })
[10:24:19.907]             }))
[10:24:19.907]             future::FutureResult(value = ...future.value$value, 
[10:24:19.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:19.907]                   ...future.rng), globalenv = if (FALSE) 
[10:24:19.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:19.907]                     ...future.globalenv.names))
[10:24:19.907]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:19.907]         }, condition = base::local({
[10:24:19.907]             c <- base::c
[10:24:19.907]             inherits <- base::inherits
[10:24:19.907]             invokeRestart <- base::invokeRestart
[10:24:19.907]             length <- base::length
[10:24:19.907]             list <- base::list
[10:24:19.907]             seq.int <- base::seq.int
[10:24:19.907]             signalCondition <- base::signalCondition
[10:24:19.907]             sys.calls <- base::sys.calls
[10:24:19.907]             `[[` <- base::`[[`
[10:24:19.907]             `+` <- base::`+`
[10:24:19.907]             `<<-` <- base::`<<-`
[10:24:19.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:19.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:19.907]                   3L)]
[10:24:19.907]             }
[10:24:19.907]             function(cond) {
[10:24:19.907]                 is_error <- inherits(cond, "error")
[10:24:19.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:19.907]                   NULL)
[10:24:19.907]                 if (is_error) {
[10:24:19.907]                   sessionInformation <- function() {
[10:24:19.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:19.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:19.907]                       search = base::search(), system = base::Sys.info())
[10:24:19.907]                   }
[10:24:19.907]                   ...future.conditions[[length(...future.conditions) + 
[10:24:19.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:19.907]                     cond$call), session = sessionInformation(), 
[10:24:19.907]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:19.907]                   signalCondition(cond)
[10:24:19.907]                 }
[10:24:19.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:19.907]                 "immediateCondition"))) {
[10:24:19.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:19.907]                   ...future.conditions[[length(...future.conditions) + 
[10:24:19.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:19.907]                   if (TRUE && !signal) {
[10:24:19.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.907]                     {
[10:24:19.907]                       inherits <- base::inherits
[10:24:19.907]                       invokeRestart <- base::invokeRestart
[10:24:19.907]                       is.null <- base::is.null
[10:24:19.907]                       muffled <- FALSE
[10:24:19.907]                       if (inherits(cond, "message")) {
[10:24:19.907]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:19.907]                         if (muffled) 
[10:24:19.907]                           invokeRestart("muffleMessage")
[10:24:19.907]                       }
[10:24:19.907]                       else if (inherits(cond, "warning")) {
[10:24:19.907]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:19.907]                         if (muffled) 
[10:24:19.907]                           invokeRestart("muffleWarning")
[10:24:19.907]                       }
[10:24:19.907]                       else if (inherits(cond, "condition")) {
[10:24:19.907]                         if (!is.null(pattern)) {
[10:24:19.907]                           computeRestarts <- base::computeRestarts
[10:24:19.907]                           grepl <- base::grepl
[10:24:19.907]                           restarts <- computeRestarts(cond)
[10:24:19.907]                           for (restart in restarts) {
[10:24:19.907]                             name <- restart$name
[10:24:19.907]                             if (is.null(name)) 
[10:24:19.907]                               next
[10:24:19.907]                             if (!grepl(pattern, name)) 
[10:24:19.907]                               next
[10:24:19.907]                             invokeRestart(restart)
[10:24:19.907]                             muffled <- TRUE
[10:24:19.907]                             break
[10:24:19.907]                           }
[10:24:19.907]                         }
[10:24:19.907]                       }
[10:24:19.907]                       invisible(muffled)
[10:24:19.907]                     }
[10:24:19.907]                     muffleCondition(cond, pattern = "^muffle")
[10:24:19.907]                   }
[10:24:19.907]                 }
[10:24:19.907]                 else {
[10:24:19.907]                   if (TRUE) {
[10:24:19.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:19.907]                     {
[10:24:19.907]                       inherits <- base::inherits
[10:24:19.907]                       invokeRestart <- base::invokeRestart
[10:24:19.907]                       is.null <- base::is.null
[10:24:19.907]                       muffled <- FALSE
[10:24:19.907]                       if (inherits(cond, "message")) {
[10:24:19.907]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:19.907]                         if (muffled) 
[10:24:19.907]                           invokeRestart("muffleMessage")
[10:24:19.907]                       }
[10:24:19.907]                       else if (inherits(cond, "warning")) {
[10:24:19.907]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:19.907]                         if (muffled) 
[10:24:19.907]                           invokeRestart("muffleWarning")
[10:24:19.907]                       }
[10:24:19.907]                       else if (inherits(cond, "condition")) {
[10:24:19.907]                         if (!is.null(pattern)) {
[10:24:19.907]                           computeRestarts <- base::computeRestarts
[10:24:19.907]                           grepl <- base::grepl
[10:24:19.907]                           restarts <- computeRestarts(cond)
[10:24:19.907]                           for (restart in restarts) {
[10:24:19.907]                             name <- restart$name
[10:24:19.907]                             if (is.null(name)) 
[10:24:19.907]                               next
[10:24:19.907]                             if (!grepl(pattern, name)) 
[10:24:19.907]                               next
[10:24:19.907]                             invokeRestart(restart)
[10:24:19.907]                             muffled <- TRUE
[10:24:19.907]                             break
[10:24:19.907]                           }
[10:24:19.907]                         }
[10:24:19.907]                       }
[10:24:19.907]                       invisible(muffled)
[10:24:19.907]                     }
[10:24:19.907]                     muffleCondition(cond, pattern = "^muffle")
[10:24:19.907]                   }
[10:24:19.907]                 }
[10:24:19.907]             }
[10:24:19.907]         }))
[10:24:19.907]     }, error = function(ex) {
[10:24:19.907]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:19.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:19.907]                 ...future.rng), started = ...future.startTime, 
[10:24:19.907]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:19.907]             version = "1.8"), class = "FutureResult")
[10:24:19.907]     }, finally = {
[10:24:19.907]         if (!identical(...future.workdir, getwd())) 
[10:24:19.907]             setwd(...future.workdir)
[10:24:19.907]         {
[10:24:19.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:19.907]                 ...future.oldOptions$nwarnings <- NULL
[10:24:19.907]             }
[10:24:19.907]             base::options(...future.oldOptions)
[10:24:19.907]             if (.Platform$OS.type == "windows") {
[10:24:19.907]                 old_names <- names(...future.oldEnvVars)
[10:24:19.907]                 envs <- base::Sys.getenv()
[10:24:19.907]                 names <- names(envs)
[10:24:19.907]                 common <- intersect(names, old_names)
[10:24:19.907]                 added <- setdiff(names, old_names)
[10:24:19.907]                 removed <- setdiff(old_names, names)
[10:24:19.907]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:19.907]                   envs[common]]
[10:24:19.907]                 NAMES <- toupper(changed)
[10:24:19.907]                 args <- list()
[10:24:19.907]                 for (kk in seq_along(NAMES)) {
[10:24:19.907]                   name <- changed[[kk]]
[10:24:19.907]                   NAME <- NAMES[[kk]]
[10:24:19.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.907]                     next
[10:24:19.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:19.907]                 }
[10:24:19.907]                 NAMES <- toupper(added)
[10:24:19.907]                 for (kk in seq_along(NAMES)) {
[10:24:19.907]                   name <- added[[kk]]
[10:24:19.907]                   NAME <- NAMES[[kk]]
[10:24:19.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.907]                     next
[10:24:19.907]                   args[[name]] <- ""
[10:24:19.907]                 }
[10:24:19.907]                 NAMES <- toupper(removed)
[10:24:19.907]                 for (kk in seq_along(NAMES)) {
[10:24:19.907]                   name <- removed[[kk]]
[10:24:19.907]                   NAME <- NAMES[[kk]]
[10:24:19.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:19.907]                     next
[10:24:19.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:19.907]                 }
[10:24:19.907]                 if (length(args) > 0) 
[10:24:19.907]                   base::do.call(base::Sys.setenv, args = args)
[10:24:19.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:19.907]             }
[10:24:19.907]             else {
[10:24:19.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:19.907]             }
[10:24:19.907]             {
[10:24:19.907]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:19.907]                   0L) {
[10:24:19.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:19.907]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:19.907]                   base::options(opts)
[10:24:19.907]                 }
[10:24:19.907]                 {
[10:24:19.907]                   {
[10:24:19.907]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:19.907]                     NULL
[10:24:19.907]                   }
[10:24:19.907]                   options(future.plan = NULL)
[10:24:19.907]                   if (is.na(NA_character_)) 
[10:24:19.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:19.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:19.907]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:19.907]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:19.907]                     envir = parent.frame()) 
[10:24:19.907]                   {
[10:24:19.907]                     if (is.function(workers)) 
[10:24:19.907]                       workers <- workers()
[10:24:19.907]                     workers <- structure(as.integer(workers), 
[10:24:19.907]                       class = class(workers))
[10:24:19.907]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:19.907]                       workers >= 1)
[10:24:19.907]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:19.907]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:19.907]                     }
[10:24:19.907]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:19.907]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:19.907]                       envir = envir)
[10:24:19.907]                     if (!future$lazy) 
[10:24:19.907]                       future <- run(future)
[10:24:19.907]                     invisible(future)
[10:24:19.907]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:19.907]                 }
[10:24:19.907]             }
[10:24:19.907]         }
[10:24:19.907]     })
[10:24:19.907]     if (TRUE) {
[10:24:19.907]         base::sink(type = "output", split = FALSE)
[10:24:19.907]         if (TRUE) {
[10:24:19.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:19.907]         }
[10:24:19.907]         else {
[10:24:19.907]             ...future.result["stdout"] <- base::list(NULL)
[10:24:19.907]         }
[10:24:19.907]         base::close(...future.stdout)
[10:24:19.907]         ...future.stdout <- NULL
[10:24:19.907]     }
[10:24:19.907]     ...future.result$conditions <- ...future.conditions
[10:24:19.907]     ...future.result$finished <- base::Sys.time()
[10:24:19.907]     ...future.result
[10:24:19.907] }
[10:24:19.910] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[10:24:19.911] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:19.954] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:19.954] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[10:24:19.954] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[10:24:19.954] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:19.955] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:19.955] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:19.998] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:19.998] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:20.042] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:20.042] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:24:20.042] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.042] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[10:24:20.043] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[10:24:20.043] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:20.044] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.044] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[10:24:20.044] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[10:24:20.044] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:20.045] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.045] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:20.045] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.045] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[10:24:20.046] MultisessionFuture started
[10:24:20.046] - Launch lazy future ... done
[10:24:20.046] run() for ‘MultisessionFuture’ ... done
[10:24:20.047] Created future:
[10:24:20.047] MultisessionFuture:
[10:24:20.047] Label: ‘future_vapply-1’
[10:24:20.047] Expression:
[10:24:20.047] {
[10:24:20.047]     do.call(function(...) {
[10:24:20.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:20.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.047]             on.exit(options(oopts), add = TRUE)
[10:24:20.047]         }
[10:24:20.047]         {
[10:24:20.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:20.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.047]                 ...future.FUN(...future.X_jj, ...)
[10:24:20.047]             })
[10:24:20.047]         }
[10:24:20.047]     }, args = future.call.arguments)
[10:24:20.047] }
[10:24:20.047] Lazy evaluation: FALSE
[10:24:20.047] Asynchronous evaluation: TRUE
[10:24:20.047] Local evaluation: TRUE
[10:24:20.047] Environment: R_GlobalEnv
[10:24:20.047] Capture standard output: TRUE
[10:24:20.047] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:20.047] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:20.047] Packages: 1 packages (‘future.apply’)
[10:24:20.047] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:20.047] Resolved: FALSE
[10:24:20.047] Value: <not collected>
[10:24:20.047] Conditions captured: <none>
[10:24:20.047] Early signaling: FALSE
[10:24:20.047] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:20.047] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:20.059] Chunk #1 of 2 ... DONE
[10:24:20.059] Chunk #2 of 2 ...
[10:24:20.059]  - Finding globals in 'X' for chunk #2 ...
[10:24:20.059] getGlobalsAndPackages() ...
[10:24:20.059] Searching for globals...
[10:24:20.060] 
[10:24:20.060] Searching for globals ... DONE
[10:24:20.060] - globals: [0] <none>
[10:24:20.060] getGlobalsAndPackages() ... DONE
[10:24:20.060]    + additional globals found: [n=0] 
[10:24:20.060]    + additional namespaces needed: [n=0] 
[10:24:20.060]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:20.061]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:20.061]  - seeds: <none>
[10:24:20.061]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.061] getGlobalsAndPackages() ...
[10:24:20.061] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.061] Resolving globals: FALSE
[10:24:20.061] Tweak future expression to call with '...' arguments ...
[10:24:20.062] {
[10:24:20.062]     do.call(function(...) {
[10:24:20.062]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.062]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:20.062]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.062]             on.exit(options(oopts), add = TRUE)
[10:24:20.062]         }
[10:24:20.062]         {
[10:24:20.062]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:20.062]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.062]                 ...future.FUN(...future.X_jj, ...)
[10:24:20.062]             })
[10:24:20.062]         }
[10:24:20.062]     }, args = future.call.arguments)
[10:24:20.062] }
[10:24:20.062] Tweak future expression to call with '...' arguments ... DONE
[10:24:20.062] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.063] - packages: [1] ‘future.apply’
[10:24:20.063] getGlobalsAndPackages() ... DONE
[10:24:20.063] run() for ‘Future’ ...
[10:24:20.063] - state: ‘created’
[10:24:20.063] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:20.078] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:20.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:20.078]   - Field: ‘node’
[10:24:20.079]   - Field: ‘label’
[10:24:20.079]   - Field: ‘local’
[10:24:20.079]   - Field: ‘owner’
[10:24:20.079]   - Field: ‘envir’
[10:24:20.079]   - Field: ‘workers’
[10:24:20.079]   - Field: ‘packages’
[10:24:20.079]   - Field: ‘gc’
[10:24:20.079]   - Field: ‘conditions’
[10:24:20.079]   - Field: ‘persistent’
[10:24:20.079]   - Field: ‘expr’
[10:24:20.080]   - Field: ‘uuid’
[10:24:20.080]   - Field: ‘seed’
[10:24:20.080]   - Field: ‘version’
[10:24:20.080]   - Field: ‘result’
[10:24:20.080]   - Field: ‘asynchronous’
[10:24:20.080]   - Field: ‘calls’
[10:24:20.080]   - Field: ‘globals’
[10:24:20.080]   - Field: ‘stdout’
[10:24:20.080]   - Field: ‘earlySignal’
[10:24:20.081]   - Field: ‘lazy’
[10:24:20.081]   - Field: ‘state’
[10:24:20.081] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:20.081] - Launch lazy future ...
[10:24:20.081] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:20.081] Packages needed by future strategies (n = 0): <none>
[10:24:20.082] {
[10:24:20.082]     {
[10:24:20.082]         {
[10:24:20.082]             ...future.startTime <- base::Sys.time()
[10:24:20.082]             {
[10:24:20.082]                 {
[10:24:20.082]                   {
[10:24:20.082]                     {
[10:24:20.082]                       {
[10:24:20.082]                         base::local({
[10:24:20.082]                           has_future <- base::requireNamespace("future", 
[10:24:20.082]                             quietly = TRUE)
[10:24:20.082]                           if (has_future) {
[10:24:20.082]                             ns <- base::getNamespace("future")
[10:24:20.082]                             version <- ns[[".package"]][["version"]]
[10:24:20.082]                             if (is.null(version)) 
[10:24:20.082]                               version <- utils::packageVersion("future")
[10:24:20.082]                           }
[10:24:20.082]                           else {
[10:24:20.082]                             version <- NULL
[10:24:20.082]                           }
[10:24:20.082]                           if (!has_future || version < "1.8.0") {
[10:24:20.082]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:20.082]                               "", base::R.version$version.string), 
[10:24:20.082]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:20.082]                                 base::R.version$platform, 8 * 
[10:24:20.082]                                   base::.Machine$sizeof.pointer), 
[10:24:20.082]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:20.082]                                 "release", "version")], collapse = " "), 
[10:24:20.082]                               hostname = base::Sys.info()[["nodename"]])
[10:24:20.082]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:20.082]                               info)
[10:24:20.082]                             info <- base::paste(info, collapse = "; ")
[10:24:20.082]                             if (!has_future) {
[10:24:20.082]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:20.082]                                 info)
[10:24:20.082]                             }
[10:24:20.082]                             else {
[10:24:20.082]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:20.082]                                 info, version)
[10:24:20.082]                             }
[10:24:20.082]                             base::stop(msg)
[10:24:20.082]                           }
[10:24:20.082]                         })
[10:24:20.082]                       }
[10:24:20.082]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:20.082]                       base::options(mc.cores = 1L)
[10:24:20.082]                     }
[10:24:20.082]                     base::local({
[10:24:20.082]                       for (pkg in "future.apply") {
[10:24:20.082]                         base::loadNamespace(pkg)
[10:24:20.082]                         base::library(pkg, character.only = TRUE)
[10:24:20.082]                       }
[10:24:20.082]                     })
[10:24:20.082]                   }
[10:24:20.082]                   options(future.plan = NULL)
[10:24:20.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:20.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:20.082]                 }
[10:24:20.082]                 ...future.workdir <- getwd()
[10:24:20.082]             }
[10:24:20.082]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:20.082]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:20.082]         }
[10:24:20.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:20.082]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:20.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:20.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:20.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:20.082]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:20.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:20.082]             base::names(...future.oldOptions))
[10:24:20.082]     }
[10:24:20.082]     if (FALSE) {
[10:24:20.082]     }
[10:24:20.082]     else {
[10:24:20.082]         if (TRUE) {
[10:24:20.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:20.082]                 open = "w")
[10:24:20.082]         }
[10:24:20.082]         else {
[10:24:20.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:20.082]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:20.082]         }
[10:24:20.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:20.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:20.082]             base::sink(type = "output", split = FALSE)
[10:24:20.082]             base::close(...future.stdout)
[10:24:20.082]         }, add = TRUE)
[10:24:20.082]     }
[10:24:20.082]     ...future.frame <- base::sys.nframe()
[10:24:20.082]     ...future.conditions <- base::list()
[10:24:20.082]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:20.082]     if (FALSE) {
[10:24:20.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:20.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:20.082]     }
[10:24:20.082]     ...future.result <- base::tryCatch({
[10:24:20.082]         base::withCallingHandlers({
[10:24:20.082]             ...future.value <- base::withVisible(base::local({
[10:24:20.082]                 ...future.makeSendCondition <- base::local({
[10:24:20.082]                   sendCondition <- NULL
[10:24:20.082]                   function(frame = 1L) {
[10:24:20.082]                     if (is.function(sendCondition)) 
[10:24:20.082]                       return(sendCondition)
[10:24:20.082]                     ns <- getNamespace("parallel")
[10:24:20.082]                     if (exists("sendData", mode = "function", 
[10:24:20.082]                       envir = ns)) {
[10:24:20.082]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:20.082]                         envir = ns)
[10:24:20.082]                       envir <- sys.frame(frame)
[10:24:20.082]                       master <- NULL
[10:24:20.082]                       while (!identical(envir, .GlobalEnv) && 
[10:24:20.082]                         !identical(envir, emptyenv())) {
[10:24:20.082]                         if (exists("master", mode = "list", envir = envir, 
[10:24:20.082]                           inherits = FALSE)) {
[10:24:20.082]                           master <- get("master", mode = "list", 
[10:24:20.082]                             envir = envir, inherits = FALSE)
[10:24:20.082]                           if (inherits(master, c("SOCKnode", 
[10:24:20.082]                             "SOCK0node"))) {
[10:24:20.082]                             sendCondition <<- function(cond) {
[10:24:20.082]                               data <- list(type = "VALUE", value = cond, 
[10:24:20.082]                                 success = TRUE)
[10:24:20.082]                               parallel_sendData(master, data)
[10:24:20.082]                             }
[10:24:20.082]                             return(sendCondition)
[10:24:20.082]                           }
[10:24:20.082]                         }
[10:24:20.082]                         frame <- frame + 1L
[10:24:20.082]                         envir <- sys.frame(frame)
[10:24:20.082]                       }
[10:24:20.082]                     }
[10:24:20.082]                     sendCondition <<- function(cond) NULL
[10:24:20.082]                   }
[10:24:20.082]                 })
[10:24:20.082]                 withCallingHandlers({
[10:24:20.082]                   {
[10:24:20.082]                     do.call(function(...) {
[10:24:20.082]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.082]                       if (!identical(...future.globals.maxSize.org, 
[10:24:20.082]                         ...future.globals.maxSize)) {
[10:24:20.082]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.082]                         on.exit(options(oopts), add = TRUE)
[10:24:20.082]                       }
[10:24:20.082]                       {
[10:24:20.082]                         lapply(seq_along(...future.elements_ii), 
[10:24:20.082]                           FUN = function(jj) {
[10:24:20.082]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.082]                             ...future.FUN(...future.X_jj, ...)
[10:24:20.082]                           })
[10:24:20.082]                       }
[10:24:20.082]                     }, args = future.call.arguments)
[10:24:20.082]                   }
[10:24:20.082]                 }, immediateCondition = function(cond) {
[10:24:20.082]                   sendCondition <- ...future.makeSendCondition()
[10:24:20.082]                   sendCondition(cond)
[10:24:20.082]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.082]                   {
[10:24:20.082]                     inherits <- base::inherits
[10:24:20.082]                     invokeRestart <- base::invokeRestart
[10:24:20.082]                     is.null <- base::is.null
[10:24:20.082]                     muffled <- FALSE
[10:24:20.082]                     if (inherits(cond, "message")) {
[10:24:20.082]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:20.082]                       if (muffled) 
[10:24:20.082]                         invokeRestart("muffleMessage")
[10:24:20.082]                     }
[10:24:20.082]                     else if (inherits(cond, "warning")) {
[10:24:20.082]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:20.082]                       if (muffled) 
[10:24:20.082]                         invokeRestart("muffleWarning")
[10:24:20.082]                     }
[10:24:20.082]                     else if (inherits(cond, "condition")) {
[10:24:20.082]                       if (!is.null(pattern)) {
[10:24:20.082]                         computeRestarts <- base::computeRestarts
[10:24:20.082]                         grepl <- base::grepl
[10:24:20.082]                         restarts <- computeRestarts(cond)
[10:24:20.082]                         for (restart in restarts) {
[10:24:20.082]                           name <- restart$name
[10:24:20.082]                           if (is.null(name)) 
[10:24:20.082]                             next
[10:24:20.082]                           if (!grepl(pattern, name)) 
[10:24:20.082]                             next
[10:24:20.082]                           invokeRestart(restart)
[10:24:20.082]                           muffled <- TRUE
[10:24:20.082]                           break
[10:24:20.082]                         }
[10:24:20.082]                       }
[10:24:20.082]                     }
[10:24:20.082]                     invisible(muffled)
[10:24:20.082]                   }
[10:24:20.082]                   muffleCondition(cond)
[10:24:20.082]                 })
[10:24:20.082]             }))
[10:24:20.082]             future::FutureResult(value = ...future.value$value, 
[10:24:20.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:20.082]                   ...future.rng), globalenv = if (FALSE) 
[10:24:20.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:20.082]                     ...future.globalenv.names))
[10:24:20.082]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:20.082]         }, condition = base::local({
[10:24:20.082]             c <- base::c
[10:24:20.082]             inherits <- base::inherits
[10:24:20.082]             invokeRestart <- base::invokeRestart
[10:24:20.082]             length <- base::length
[10:24:20.082]             list <- base::list
[10:24:20.082]             seq.int <- base::seq.int
[10:24:20.082]             signalCondition <- base::signalCondition
[10:24:20.082]             sys.calls <- base::sys.calls
[10:24:20.082]             `[[` <- base::`[[`
[10:24:20.082]             `+` <- base::`+`
[10:24:20.082]             `<<-` <- base::`<<-`
[10:24:20.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:20.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:20.082]                   3L)]
[10:24:20.082]             }
[10:24:20.082]             function(cond) {
[10:24:20.082]                 is_error <- inherits(cond, "error")
[10:24:20.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:20.082]                   NULL)
[10:24:20.082]                 if (is_error) {
[10:24:20.082]                   sessionInformation <- function() {
[10:24:20.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:20.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:20.082]                       search = base::search(), system = base::Sys.info())
[10:24:20.082]                   }
[10:24:20.082]                   ...future.conditions[[length(...future.conditions) + 
[10:24:20.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:20.082]                     cond$call), session = sessionInformation(), 
[10:24:20.082]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:20.082]                   signalCondition(cond)
[10:24:20.082]                 }
[10:24:20.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:20.082]                 "immediateCondition"))) {
[10:24:20.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:20.082]                   ...future.conditions[[length(...future.conditions) + 
[10:24:20.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:20.082]                   if (TRUE && !signal) {
[10:24:20.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.082]                     {
[10:24:20.082]                       inherits <- base::inherits
[10:24:20.082]                       invokeRestart <- base::invokeRestart
[10:24:20.082]                       is.null <- base::is.null
[10:24:20.082]                       muffled <- FALSE
[10:24:20.082]                       if (inherits(cond, "message")) {
[10:24:20.082]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:20.082]                         if (muffled) 
[10:24:20.082]                           invokeRestart("muffleMessage")
[10:24:20.082]                       }
[10:24:20.082]                       else if (inherits(cond, "warning")) {
[10:24:20.082]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:20.082]                         if (muffled) 
[10:24:20.082]                           invokeRestart("muffleWarning")
[10:24:20.082]                       }
[10:24:20.082]                       else if (inherits(cond, "condition")) {
[10:24:20.082]                         if (!is.null(pattern)) {
[10:24:20.082]                           computeRestarts <- base::computeRestarts
[10:24:20.082]                           grepl <- base::grepl
[10:24:20.082]                           restarts <- computeRestarts(cond)
[10:24:20.082]                           for (restart in restarts) {
[10:24:20.082]                             name <- restart$name
[10:24:20.082]                             if (is.null(name)) 
[10:24:20.082]                               next
[10:24:20.082]                             if (!grepl(pattern, name)) 
[10:24:20.082]                               next
[10:24:20.082]                             invokeRestart(restart)
[10:24:20.082]                             muffled <- TRUE
[10:24:20.082]                             break
[10:24:20.082]                           }
[10:24:20.082]                         }
[10:24:20.082]                       }
[10:24:20.082]                       invisible(muffled)
[10:24:20.082]                     }
[10:24:20.082]                     muffleCondition(cond, pattern = "^muffle")
[10:24:20.082]                   }
[10:24:20.082]                 }
[10:24:20.082]                 else {
[10:24:20.082]                   if (TRUE) {
[10:24:20.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.082]                     {
[10:24:20.082]                       inherits <- base::inherits
[10:24:20.082]                       invokeRestart <- base::invokeRestart
[10:24:20.082]                       is.null <- base::is.null
[10:24:20.082]                       muffled <- FALSE
[10:24:20.082]                       if (inherits(cond, "message")) {
[10:24:20.082]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:20.082]                         if (muffled) 
[10:24:20.082]                           invokeRestart("muffleMessage")
[10:24:20.082]                       }
[10:24:20.082]                       else if (inherits(cond, "warning")) {
[10:24:20.082]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:20.082]                         if (muffled) 
[10:24:20.082]                           invokeRestart("muffleWarning")
[10:24:20.082]                       }
[10:24:20.082]                       else if (inherits(cond, "condition")) {
[10:24:20.082]                         if (!is.null(pattern)) {
[10:24:20.082]                           computeRestarts <- base::computeRestarts
[10:24:20.082]                           grepl <- base::grepl
[10:24:20.082]                           restarts <- computeRestarts(cond)
[10:24:20.082]                           for (restart in restarts) {
[10:24:20.082]                             name <- restart$name
[10:24:20.082]                             if (is.null(name)) 
[10:24:20.082]                               next
[10:24:20.082]                             if (!grepl(pattern, name)) 
[10:24:20.082]                               next
[10:24:20.082]                             invokeRestart(restart)
[10:24:20.082]                             muffled <- TRUE
[10:24:20.082]                             break
[10:24:20.082]                           }
[10:24:20.082]                         }
[10:24:20.082]                       }
[10:24:20.082]                       invisible(muffled)
[10:24:20.082]                     }
[10:24:20.082]                     muffleCondition(cond, pattern = "^muffle")
[10:24:20.082]                   }
[10:24:20.082]                 }
[10:24:20.082]             }
[10:24:20.082]         }))
[10:24:20.082]     }, error = function(ex) {
[10:24:20.082]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:20.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:20.082]                 ...future.rng), started = ...future.startTime, 
[10:24:20.082]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:20.082]             version = "1.8"), class = "FutureResult")
[10:24:20.082]     }, finally = {
[10:24:20.082]         if (!identical(...future.workdir, getwd())) 
[10:24:20.082]             setwd(...future.workdir)
[10:24:20.082]         {
[10:24:20.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:20.082]                 ...future.oldOptions$nwarnings <- NULL
[10:24:20.082]             }
[10:24:20.082]             base::options(...future.oldOptions)
[10:24:20.082]             if (.Platform$OS.type == "windows") {
[10:24:20.082]                 old_names <- names(...future.oldEnvVars)
[10:24:20.082]                 envs <- base::Sys.getenv()
[10:24:20.082]                 names <- names(envs)
[10:24:20.082]                 common <- intersect(names, old_names)
[10:24:20.082]                 added <- setdiff(names, old_names)
[10:24:20.082]                 removed <- setdiff(old_names, names)
[10:24:20.082]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:20.082]                   envs[common]]
[10:24:20.082]                 NAMES <- toupper(changed)
[10:24:20.082]                 args <- list()
[10:24:20.082]                 for (kk in seq_along(NAMES)) {
[10:24:20.082]                   name <- changed[[kk]]
[10:24:20.082]                   NAME <- NAMES[[kk]]
[10:24:20.082]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.082]                     next
[10:24:20.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:20.082]                 }
[10:24:20.082]                 NAMES <- toupper(added)
[10:24:20.082]                 for (kk in seq_along(NAMES)) {
[10:24:20.082]                   name <- added[[kk]]
[10:24:20.082]                   NAME <- NAMES[[kk]]
[10:24:20.082]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.082]                     next
[10:24:20.082]                   args[[name]] <- ""
[10:24:20.082]                 }
[10:24:20.082]                 NAMES <- toupper(removed)
[10:24:20.082]                 for (kk in seq_along(NAMES)) {
[10:24:20.082]                   name <- removed[[kk]]
[10:24:20.082]                   NAME <- NAMES[[kk]]
[10:24:20.082]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.082]                     next
[10:24:20.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:20.082]                 }
[10:24:20.082]                 if (length(args) > 0) 
[10:24:20.082]                   base::do.call(base::Sys.setenv, args = args)
[10:24:20.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:20.082]             }
[10:24:20.082]             else {
[10:24:20.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:20.082]             }
[10:24:20.082]             {
[10:24:20.082]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:20.082]                   0L) {
[10:24:20.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:20.082]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:20.082]                   base::options(opts)
[10:24:20.082]                 }
[10:24:20.082]                 {
[10:24:20.082]                   {
[10:24:20.082]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:20.082]                     NULL
[10:24:20.082]                   }
[10:24:20.082]                   options(future.plan = NULL)
[10:24:20.082]                   if (is.na(NA_character_)) 
[10:24:20.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:20.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:20.082]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:20.082]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:20.082]                     envir = parent.frame()) 
[10:24:20.082]                   {
[10:24:20.082]                     if (is.function(workers)) 
[10:24:20.082]                       workers <- workers()
[10:24:20.082]                     workers <- structure(as.integer(workers), 
[10:24:20.082]                       class = class(workers))
[10:24:20.082]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:20.082]                       workers >= 1)
[10:24:20.082]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:20.082]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:20.082]                     }
[10:24:20.082]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:20.082]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:20.082]                       envir = envir)
[10:24:20.082]                     if (!future$lazy) 
[10:24:20.082]                       future <- run(future)
[10:24:20.082]                     invisible(future)
[10:24:20.082]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:20.082]                 }
[10:24:20.082]             }
[10:24:20.082]         }
[10:24:20.082]     })
[10:24:20.082]     if (TRUE) {
[10:24:20.082]         base::sink(type = "output", split = FALSE)
[10:24:20.082]         if (TRUE) {
[10:24:20.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:20.082]         }
[10:24:20.082]         else {
[10:24:20.082]             ...future.result["stdout"] <- base::list(NULL)
[10:24:20.082]         }
[10:24:20.082]         base::close(...future.stdout)
[10:24:20.082]         ...future.stdout <- NULL
[10:24:20.082]     }
[10:24:20.082]     ...future.result$conditions <- ...future.conditions
[10:24:20.082]     ...future.result$finished <- base::Sys.time()
[10:24:20.082]     ...future.result
[10:24:20.082] }
[10:24:20.136] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[10:24:20.136] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:20.140] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:20.141] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[10:24:20.141] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[10:24:20.141] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:20.142] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:20.142] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:20.186] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:20.186] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:20.230] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:20.230] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:24:20.230] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:24:20.230] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[10:24:20.231] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[10:24:20.231] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:20.232] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:20.232] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[10:24:20.232] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[10:24:20.232] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:20.233] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:20.235] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:20.236] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:20.236] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[10:24:20.236] MultisessionFuture started
[10:24:20.237] - Launch lazy future ... done
[10:24:20.237] run() for ‘MultisessionFuture’ ... done
[10:24:20.237] Created future:
[10:24:20.237] MultisessionFuture:
[10:24:20.237] Label: ‘future_vapply-2’
[10:24:20.237] Expression:
[10:24:20.237] {
[10:24:20.237]     do.call(function(...) {
[10:24:20.237]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.237]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:20.237]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.237]             on.exit(options(oopts), add = TRUE)
[10:24:20.237]         }
[10:24:20.237]         {
[10:24:20.237]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:20.237]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.237]                 ...future.FUN(...future.X_jj, ...)
[10:24:20.237]             })
[10:24:20.237]         }
[10:24:20.237]     }, args = future.call.arguments)
[10:24:20.237] }
[10:24:20.237] Lazy evaluation: FALSE
[10:24:20.237] Asynchronous evaluation: TRUE
[10:24:20.237] Local evaluation: TRUE
[10:24:20.237] Environment: R_GlobalEnv
[10:24:20.237] Capture standard output: TRUE
[10:24:20.237] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:20.237] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:20.237] Packages: 1 packages (‘future.apply’)
[10:24:20.237] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:20.237] Resolved: FALSE
[10:24:20.237] Value: <not collected>
[10:24:20.237] Conditions captured: <none>
[10:24:20.237] Early signaling: FALSE
[10:24:20.237] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:20.237] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:20.249] Chunk #2 of 2 ... DONE
[10:24:20.249] Launching 2 futures (chunks) ... DONE
[10:24:20.249] Resolving 2 futures (chunks) ...
[10:24:20.249] resolve() on list ...
[10:24:20.249]  recursive: 0
[10:24:20.249]  length: 2
[10:24:20.250] 
[10:24:20.250] receiveMessageFromWorker() for ClusterFuture ...
[10:24:20.250] - Validating connection of MultisessionFuture
[10:24:20.250] - received message: FutureResult
[10:24:20.250] - Received FutureResult
[10:24:20.250] - Erased future from FutureRegistry
[10:24:20.251] result() for ClusterFuture ...
[10:24:20.251] - result already collected: FutureResult
[10:24:20.251] result() for ClusterFuture ... done
[10:24:20.251] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:20.251] Future #1
[10:24:20.251] result() for ClusterFuture ...
[10:24:20.251] - result already collected: FutureResult
[10:24:20.251] result() for ClusterFuture ... done
[10:24:20.251] result() for ClusterFuture ...
[10:24:20.251] - result already collected: FutureResult
[10:24:20.251] result() for ClusterFuture ... done
[10:24:20.252] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:20.252] - nx: 2
[10:24:20.252] - relay: TRUE
[10:24:20.252] - stdout: TRUE
[10:24:20.252] - signal: TRUE
[10:24:20.252] - resignal: FALSE
[10:24:20.252] - force: TRUE
[10:24:20.252] - relayed: [n=2] FALSE, FALSE
[10:24:20.252] - queued futures: [n=2] FALSE, FALSE
[10:24:20.252]  - until=1
[10:24:20.252]  - relaying element #1
[10:24:20.252] result() for ClusterFuture ...
[10:24:20.253] - result already collected: FutureResult
[10:24:20.253] result() for ClusterFuture ... done
[10:24:20.253] result() for ClusterFuture ...
[10:24:20.253] - result already collected: FutureResult
[10:24:20.253] result() for ClusterFuture ... done
[10:24:20.253] result() for ClusterFuture ...
[10:24:20.253] - result already collected: FutureResult
[10:24:20.253] result() for ClusterFuture ... done
[10:24:20.253] result() for ClusterFuture ...
[10:24:20.253] - result already collected: FutureResult
[10:24:20.253] result() for ClusterFuture ... done
[10:24:20.254] - relayed: [n=2] TRUE, FALSE
[10:24:20.254] - queued futures: [n=2] TRUE, FALSE
[10:24:20.254] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:20.254]  length: 1 (resolved future 1)
[10:24:20.337] receiveMessageFromWorker() for ClusterFuture ...
[10:24:20.337] - Validating connection of MultisessionFuture
[10:24:20.337] - received message: FutureResult
[10:24:20.338] - Received FutureResult
[10:24:20.338] - Erased future from FutureRegistry
[10:24:20.338] result() for ClusterFuture ...
[10:24:20.338] - result already collected: FutureResult
[10:24:20.338] result() for ClusterFuture ... done
[10:24:20.338] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:20.338] Future #2
[10:24:20.338] result() for ClusterFuture ...
[10:24:20.338] - result already collected: FutureResult
[10:24:20.339] result() for ClusterFuture ... done
[10:24:20.339] result() for ClusterFuture ...
[10:24:20.339] - result already collected: FutureResult
[10:24:20.339] result() for ClusterFuture ... done
[10:24:20.339] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:20.339] - nx: 2
[10:24:20.339] - relay: TRUE
[10:24:20.339] - stdout: TRUE
[10:24:20.339] - signal: TRUE
[10:24:20.339] - resignal: FALSE
[10:24:20.339] - force: TRUE
[10:24:20.339] - relayed: [n=2] TRUE, FALSE
[10:24:20.340] - queued futures: [n=2] TRUE, FALSE
[10:24:20.340]  - until=2
[10:24:20.340]  - relaying element #2
[10:24:20.340] result() for ClusterFuture ...
[10:24:20.340] - result already collected: FutureResult
[10:24:20.340] result() for ClusterFuture ... done
[10:24:20.340] result() for ClusterFuture ...
[10:24:20.340] - result already collected: FutureResult
[10:24:20.340] result() for ClusterFuture ... done
[10:24:20.341] result() for ClusterFuture ...
[10:24:20.341] - result already collected: FutureResult
[10:24:20.341] result() for ClusterFuture ... done
[10:24:20.341] result() for ClusterFuture ...
[10:24:20.341] - result already collected: FutureResult
[10:24:20.341] result() for ClusterFuture ... done
[10:24:20.341] - relayed: [n=2] TRUE, TRUE
[10:24:20.341] - queued futures: [n=2] TRUE, TRUE
[10:24:20.341] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:20.341]  length: 0 (resolved future 2)
[10:24:20.342] Relaying remaining futures
[10:24:20.342] signalConditionsASAP(NULL, pos=0) ...
[10:24:20.342] - nx: 2
[10:24:20.342] - relay: TRUE
[10:24:20.342] - stdout: TRUE
[10:24:20.342] - signal: TRUE
[10:24:20.342] - resignal: FALSE
[10:24:20.342] - force: TRUE
[10:24:20.342] - relayed: [n=2] TRUE, TRUE
[10:24:20.342] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:20.342] - relayed: [n=2] TRUE, TRUE
[10:24:20.343] - queued futures: [n=2] TRUE, TRUE
[10:24:20.343] signalConditionsASAP(NULL, pos=0) ... done
[10:24:20.343] resolve() on list ... DONE
[10:24:20.343] result() for ClusterFuture ...
[10:24:20.343] - result already collected: FutureResult
[10:24:20.343] result() for ClusterFuture ... done
[10:24:20.343] result() for ClusterFuture ...
[10:24:20.343] - result already collected: FutureResult
[10:24:20.343] result() for ClusterFuture ... done
[10:24:20.343] result() for ClusterFuture ...
[10:24:20.343] - result already collected: FutureResult
[10:24:20.344] result() for ClusterFuture ... done
[10:24:20.344] result() for ClusterFuture ...
[10:24:20.344] - result already collected: FutureResult
[10:24:20.344] result() for ClusterFuture ... done
[10:24:20.344]  - Number of value chunks collected: 2
[10:24:20.344] Resolving 2 futures (chunks) ... DONE
[10:24:20.344] Reducing values from 2 chunks ...
[10:24:20.344]  - Number of values collected after concatenation: 2
[10:24:20.344]  - Number of values expected: 2
[10:24:20.344] Reducing values from 2 chunks ... DONE
[10:24:20.344] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[10:24:20.346] future_lapply() ...
[10:24:20.351] Number of chunks: 2
[10:24:20.351] getGlobalsAndPackagesXApply() ...
[10:24:20.351]  - future.globals: TRUE
[10:24:20.351] getGlobalsAndPackages() ...
[10:24:20.351] Searching for globals...
[10:24:20.355] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[10:24:20.355] Searching for globals ... DONE
[10:24:20.355] Resolving globals: FALSE
[10:24:20.356] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[10:24:20.356] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:20.356] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:20.356] - packages: [1] ‘future.apply’
[10:24:20.357] getGlobalsAndPackages() ... DONE
[10:24:20.357]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:20.357]  - needed namespaces: [n=1] ‘future.apply’
[10:24:20.357] Finding globals ... DONE
[10:24:20.357]  - use_args: TRUE
[10:24:20.357]  - Getting '...' globals ...
[10:24:20.357] resolve() on list ...
[10:24:20.357]  recursive: 0
[10:24:20.358]  length: 1
[10:24:20.358]  elements: ‘...’
[10:24:20.358]  length: 0 (resolved future 1)
[10:24:20.358] resolve() on list ... DONE
[10:24:20.358]    - '...' content: [n=0] 
[10:24:20.358] List of 1
[10:24:20.358]  $ ...: list()
[10:24:20.358]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:20.358]  - attr(*, "where")=List of 1
[10:24:20.358]   ..$ ...:<environment: 0x55b93bf48608> 
[10:24:20.358]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:20.358]  - attr(*, "resolved")= logi TRUE
[10:24:20.358]  - attr(*, "total_size")= num NA
[10:24:20.360]  - Getting '...' globals ... DONE
[10:24:20.361] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:20.361] List of 8
[10:24:20.361]  $ ...future.FUN:function (x, ...)  
[10:24:20.361]  $ x_FUN        :function (x)  
[10:24:20.361]  $ times        : int 0
[10:24:20.361]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:20.361]  $ stop_if_not  :function (...)  
[10:24:20.361]  $ dim          : NULL
[10:24:20.361]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:20.361]  $ ...          : list()
[10:24:20.361]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:20.361]  - attr(*, "where")=List of 8
[10:24:20.361]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:20.361]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:20.361]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:20.361]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:20.361]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:20.361]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:20.361]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:20.361]   ..$ ...          :<environment: 0x55b93bf48608> 
[10:24:20.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:20.361]  - attr(*, "resolved")= logi FALSE
[10:24:20.361]  - attr(*, "total_size")= num 95472
[10:24:20.366] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:20.366] getGlobalsAndPackagesXApply() ... DONE
[10:24:20.366] Number of futures (= number of chunks): 2
[10:24:20.367] Launching 2 futures (chunks) ...
[10:24:20.367] Chunk #1 of 2 ...
[10:24:20.367]  - Finding globals in 'X' for chunk #1 ...
[10:24:20.367] getGlobalsAndPackages() ...
[10:24:20.367] Searching for globals...
[10:24:20.367] 
[10:24:20.367] Searching for globals ... DONE
[10:24:20.367] - globals: [0] <none>
[10:24:20.367] getGlobalsAndPackages() ... DONE
[10:24:20.368]    + additional globals found: [n=0] 
[10:24:20.368]    + additional namespaces needed: [n=0] 
[10:24:20.368]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:20.368]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:20.368]  - seeds: <none>
[10:24:20.368]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.368] getGlobalsAndPackages() ...
[10:24:20.368] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.368] Resolving globals: FALSE
[10:24:20.368] Tweak future expression to call with '...' arguments ...
[10:24:20.369] {
[10:24:20.369]     do.call(function(...) {
[10:24:20.369]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.369]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:20.369]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.369]             on.exit(options(oopts), add = TRUE)
[10:24:20.369]         }
[10:24:20.369]         {
[10:24:20.369]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:20.369]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.369]                 ...future.FUN(...future.X_jj, ...)
[10:24:20.369]             })
[10:24:20.369]         }
[10:24:20.369]     }, args = future.call.arguments)
[10:24:20.369] }
[10:24:20.369] Tweak future expression to call with '...' arguments ... DONE
[10:24:20.369] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.369] - packages: [1] ‘future.apply’
[10:24:20.370] getGlobalsAndPackages() ... DONE
[10:24:20.370] run() for ‘Future’ ...
[10:24:20.370] - state: ‘created’
[10:24:20.370] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:20.383] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:20.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:20.384]   - Field: ‘node’
[10:24:20.384]   - Field: ‘label’
[10:24:20.384]   - Field: ‘local’
[10:24:20.384]   - Field: ‘owner’
[10:24:20.384]   - Field: ‘envir’
[10:24:20.384]   - Field: ‘workers’
[10:24:20.384]   - Field: ‘packages’
[10:24:20.384]   - Field: ‘gc’
[10:24:20.384]   - Field: ‘conditions’
[10:24:20.385]   - Field: ‘persistent’
[10:24:20.385]   - Field: ‘expr’
[10:24:20.385]   - Field: ‘uuid’
[10:24:20.385]   - Field: ‘seed’
[10:24:20.385]   - Field: ‘version’
[10:24:20.385]   - Field: ‘result’
[10:24:20.385]   - Field: ‘asynchronous’
[10:24:20.385]   - Field: ‘calls’
[10:24:20.385]   - Field: ‘globals’
[10:24:20.385]   - Field: ‘stdout’
[10:24:20.385]   - Field: ‘earlySignal’
[10:24:20.386]   - Field: ‘lazy’
[10:24:20.386]   - Field: ‘state’
[10:24:20.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:20.386] - Launch lazy future ...
[10:24:20.386] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:20.386] Packages needed by future strategies (n = 0): <none>
[10:24:20.387] {
[10:24:20.387]     {
[10:24:20.387]         {
[10:24:20.387]             ...future.startTime <- base::Sys.time()
[10:24:20.387]             {
[10:24:20.387]                 {
[10:24:20.387]                   {
[10:24:20.387]                     {
[10:24:20.387]                       {
[10:24:20.387]                         base::local({
[10:24:20.387]                           has_future <- base::requireNamespace("future", 
[10:24:20.387]                             quietly = TRUE)
[10:24:20.387]                           if (has_future) {
[10:24:20.387]                             ns <- base::getNamespace("future")
[10:24:20.387]                             version <- ns[[".package"]][["version"]]
[10:24:20.387]                             if (is.null(version)) 
[10:24:20.387]                               version <- utils::packageVersion("future")
[10:24:20.387]                           }
[10:24:20.387]                           else {
[10:24:20.387]                             version <- NULL
[10:24:20.387]                           }
[10:24:20.387]                           if (!has_future || version < "1.8.0") {
[10:24:20.387]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:20.387]                               "", base::R.version$version.string), 
[10:24:20.387]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:20.387]                                 base::R.version$platform, 8 * 
[10:24:20.387]                                   base::.Machine$sizeof.pointer), 
[10:24:20.387]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:20.387]                                 "release", "version")], collapse = " "), 
[10:24:20.387]                               hostname = base::Sys.info()[["nodename"]])
[10:24:20.387]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:20.387]                               info)
[10:24:20.387]                             info <- base::paste(info, collapse = "; ")
[10:24:20.387]                             if (!has_future) {
[10:24:20.387]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:20.387]                                 info)
[10:24:20.387]                             }
[10:24:20.387]                             else {
[10:24:20.387]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:20.387]                                 info, version)
[10:24:20.387]                             }
[10:24:20.387]                             base::stop(msg)
[10:24:20.387]                           }
[10:24:20.387]                         })
[10:24:20.387]                       }
[10:24:20.387]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:20.387]                       base::options(mc.cores = 1L)
[10:24:20.387]                     }
[10:24:20.387]                     base::local({
[10:24:20.387]                       for (pkg in "future.apply") {
[10:24:20.387]                         base::loadNamespace(pkg)
[10:24:20.387]                         base::library(pkg, character.only = TRUE)
[10:24:20.387]                       }
[10:24:20.387]                     })
[10:24:20.387]                   }
[10:24:20.387]                   options(future.plan = NULL)
[10:24:20.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:20.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:20.387]                 }
[10:24:20.387]                 ...future.workdir <- getwd()
[10:24:20.387]             }
[10:24:20.387]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:20.387]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:20.387]         }
[10:24:20.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:20.387]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:20.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:20.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:20.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:20.387]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:20.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:20.387]             base::names(...future.oldOptions))
[10:24:20.387]     }
[10:24:20.387]     if (FALSE) {
[10:24:20.387]     }
[10:24:20.387]     else {
[10:24:20.387]         if (TRUE) {
[10:24:20.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:20.387]                 open = "w")
[10:24:20.387]         }
[10:24:20.387]         else {
[10:24:20.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:20.387]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:20.387]         }
[10:24:20.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:20.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:20.387]             base::sink(type = "output", split = FALSE)
[10:24:20.387]             base::close(...future.stdout)
[10:24:20.387]         }, add = TRUE)
[10:24:20.387]     }
[10:24:20.387]     ...future.frame <- base::sys.nframe()
[10:24:20.387]     ...future.conditions <- base::list()
[10:24:20.387]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:20.387]     if (FALSE) {
[10:24:20.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:20.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:20.387]     }
[10:24:20.387]     ...future.result <- base::tryCatch({
[10:24:20.387]         base::withCallingHandlers({
[10:24:20.387]             ...future.value <- base::withVisible(base::local({
[10:24:20.387]                 ...future.makeSendCondition <- base::local({
[10:24:20.387]                   sendCondition <- NULL
[10:24:20.387]                   function(frame = 1L) {
[10:24:20.387]                     if (is.function(sendCondition)) 
[10:24:20.387]                       return(sendCondition)
[10:24:20.387]                     ns <- getNamespace("parallel")
[10:24:20.387]                     if (exists("sendData", mode = "function", 
[10:24:20.387]                       envir = ns)) {
[10:24:20.387]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:20.387]                         envir = ns)
[10:24:20.387]                       envir <- sys.frame(frame)
[10:24:20.387]                       master <- NULL
[10:24:20.387]                       while (!identical(envir, .GlobalEnv) && 
[10:24:20.387]                         !identical(envir, emptyenv())) {
[10:24:20.387]                         if (exists("master", mode = "list", envir = envir, 
[10:24:20.387]                           inherits = FALSE)) {
[10:24:20.387]                           master <- get("master", mode = "list", 
[10:24:20.387]                             envir = envir, inherits = FALSE)
[10:24:20.387]                           if (inherits(master, c("SOCKnode", 
[10:24:20.387]                             "SOCK0node"))) {
[10:24:20.387]                             sendCondition <<- function(cond) {
[10:24:20.387]                               data <- list(type = "VALUE", value = cond, 
[10:24:20.387]                                 success = TRUE)
[10:24:20.387]                               parallel_sendData(master, data)
[10:24:20.387]                             }
[10:24:20.387]                             return(sendCondition)
[10:24:20.387]                           }
[10:24:20.387]                         }
[10:24:20.387]                         frame <- frame + 1L
[10:24:20.387]                         envir <- sys.frame(frame)
[10:24:20.387]                       }
[10:24:20.387]                     }
[10:24:20.387]                     sendCondition <<- function(cond) NULL
[10:24:20.387]                   }
[10:24:20.387]                 })
[10:24:20.387]                 withCallingHandlers({
[10:24:20.387]                   {
[10:24:20.387]                     do.call(function(...) {
[10:24:20.387]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.387]                       if (!identical(...future.globals.maxSize.org, 
[10:24:20.387]                         ...future.globals.maxSize)) {
[10:24:20.387]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.387]                         on.exit(options(oopts), add = TRUE)
[10:24:20.387]                       }
[10:24:20.387]                       {
[10:24:20.387]                         lapply(seq_along(...future.elements_ii), 
[10:24:20.387]                           FUN = function(jj) {
[10:24:20.387]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.387]                             ...future.FUN(...future.X_jj, ...)
[10:24:20.387]                           })
[10:24:20.387]                       }
[10:24:20.387]                     }, args = future.call.arguments)
[10:24:20.387]                   }
[10:24:20.387]                 }, immediateCondition = function(cond) {
[10:24:20.387]                   sendCondition <- ...future.makeSendCondition()
[10:24:20.387]                   sendCondition(cond)
[10:24:20.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.387]                   {
[10:24:20.387]                     inherits <- base::inherits
[10:24:20.387]                     invokeRestart <- base::invokeRestart
[10:24:20.387]                     is.null <- base::is.null
[10:24:20.387]                     muffled <- FALSE
[10:24:20.387]                     if (inherits(cond, "message")) {
[10:24:20.387]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:20.387]                       if (muffled) 
[10:24:20.387]                         invokeRestart("muffleMessage")
[10:24:20.387]                     }
[10:24:20.387]                     else if (inherits(cond, "warning")) {
[10:24:20.387]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:20.387]                       if (muffled) 
[10:24:20.387]                         invokeRestart("muffleWarning")
[10:24:20.387]                     }
[10:24:20.387]                     else if (inherits(cond, "condition")) {
[10:24:20.387]                       if (!is.null(pattern)) {
[10:24:20.387]                         computeRestarts <- base::computeRestarts
[10:24:20.387]                         grepl <- base::grepl
[10:24:20.387]                         restarts <- computeRestarts(cond)
[10:24:20.387]                         for (restart in restarts) {
[10:24:20.387]                           name <- restart$name
[10:24:20.387]                           if (is.null(name)) 
[10:24:20.387]                             next
[10:24:20.387]                           if (!grepl(pattern, name)) 
[10:24:20.387]                             next
[10:24:20.387]                           invokeRestart(restart)
[10:24:20.387]                           muffled <- TRUE
[10:24:20.387]                           break
[10:24:20.387]                         }
[10:24:20.387]                       }
[10:24:20.387]                     }
[10:24:20.387]                     invisible(muffled)
[10:24:20.387]                   }
[10:24:20.387]                   muffleCondition(cond)
[10:24:20.387]                 })
[10:24:20.387]             }))
[10:24:20.387]             future::FutureResult(value = ...future.value$value, 
[10:24:20.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:20.387]                   ...future.rng), globalenv = if (FALSE) 
[10:24:20.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:20.387]                     ...future.globalenv.names))
[10:24:20.387]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:20.387]         }, condition = base::local({
[10:24:20.387]             c <- base::c
[10:24:20.387]             inherits <- base::inherits
[10:24:20.387]             invokeRestart <- base::invokeRestart
[10:24:20.387]             length <- base::length
[10:24:20.387]             list <- base::list
[10:24:20.387]             seq.int <- base::seq.int
[10:24:20.387]             signalCondition <- base::signalCondition
[10:24:20.387]             sys.calls <- base::sys.calls
[10:24:20.387]             `[[` <- base::`[[`
[10:24:20.387]             `+` <- base::`+`
[10:24:20.387]             `<<-` <- base::`<<-`
[10:24:20.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:20.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:20.387]                   3L)]
[10:24:20.387]             }
[10:24:20.387]             function(cond) {
[10:24:20.387]                 is_error <- inherits(cond, "error")
[10:24:20.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:20.387]                   NULL)
[10:24:20.387]                 if (is_error) {
[10:24:20.387]                   sessionInformation <- function() {
[10:24:20.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:20.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:20.387]                       search = base::search(), system = base::Sys.info())
[10:24:20.387]                   }
[10:24:20.387]                   ...future.conditions[[length(...future.conditions) + 
[10:24:20.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:20.387]                     cond$call), session = sessionInformation(), 
[10:24:20.387]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:20.387]                   signalCondition(cond)
[10:24:20.387]                 }
[10:24:20.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:20.387]                 "immediateCondition"))) {
[10:24:20.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:20.387]                   ...future.conditions[[length(...future.conditions) + 
[10:24:20.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:20.387]                   if (TRUE && !signal) {
[10:24:20.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.387]                     {
[10:24:20.387]                       inherits <- base::inherits
[10:24:20.387]                       invokeRestart <- base::invokeRestart
[10:24:20.387]                       is.null <- base::is.null
[10:24:20.387]                       muffled <- FALSE
[10:24:20.387]                       if (inherits(cond, "message")) {
[10:24:20.387]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:20.387]                         if (muffled) 
[10:24:20.387]                           invokeRestart("muffleMessage")
[10:24:20.387]                       }
[10:24:20.387]                       else if (inherits(cond, "warning")) {
[10:24:20.387]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:20.387]                         if (muffled) 
[10:24:20.387]                           invokeRestart("muffleWarning")
[10:24:20.387]                       }
[10:24:20.387]                       else if (inherits(cond, "condition")) {
[10:24:20.387]                         if (!is.null(pattern)) {
[10:24:20.387]                           computeRestarts <- base::computeRestarts
[10:24:20.387]                           grepl <- base::grepl
[10:24:20.387]                           restarts <- computeRestarts(cond)
[10:24:20.387]                           for (restart in restarts) {
[10:24:20.387]                             name <- restart$name
[10:24:20.387]                             if (is.null(name)) 
[10:24:20.387]                               next
[10:24:20.387]                             if (!grepl(pattern, name)) 
[10:24:20.387]                               next
[10:24:20.387]                             invokeRestart(restart)
[10:24:20.387]                             muffled <- TRUE
[10:24:20.387]                             break
[10:24:20.387]                           }
[10:24:20.387]                         }
[10:24:20.387]                       }
[10:24:20.387]                       invisible(muffled)
[10:24:20.387]                     }
[10:24:20.387]                     muffleCondition(cond, pattern = "^muffle")
[10:24:20.387]                   }
[10:24:20.387]                 }
[10:24:20.387]                 else {
[10:24:20.387]                   if (TRUE) {
[10:24:20.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.387]                     {
[10:24:20.387]                       inherits <- base::inherits
[10:24:20.387]                       invokeRestart <- base::invokeRestart
[10:24:20.387]                       is.null <- base::is.null
[10:24:20.387]                       muffled <- FALSE
[10:24:20.387]                       if (inherits(cond, "message")) {
[10:24:20.387]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:20.387]                         if (muffled) 
[10:24:20.387]                           invokeRestart("muffleMessage")
[10:24:20.387]                       }
[10:24:20.387]                       else if (inherits(cond, "warning")) {
[10:24:20.387]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:20.387]                         if (muffled) 
[10:24:20.387]                           invokeRestart("muffleWarning")
[10:24:20.387]                       }
[10:24:20.387]                       else if (inherits(cond, "condition")) {
[10:24:20.387]                         if (!is.null(pattern)) {
[10:24:20.387]                           computeRestarts <- base::computeRestarts
[10:24:20.387]                           grepl <- base::grepl
[10:24:20.387]                           restarts <- computeRestarts(cond)
[10:24:20.387]                           for (restart in restarts) {
[10:24:20.387]                             name <- restart$name
[10:24:20.387]                             if (is.null(name)) 
[10:24:20.387]                               next
[10:24:20.387]                             if (!grepl(pattern, name)) 
[10:24:20.387]                               next
[10:24:20.387]                             invokeRestart(restart)
[10:24:20.387]                             muffled <- TRUE
[10:24:20.387]                             break
[10:24:20.387]                           }
[10:24:20.387]                         }
[10:24:20.387]                       }
[10:24:20.387]                       invisible(muffled)
[10:24:20.387]                     }
[10:24:20.387]                     muffleCondition(cond, pattern = "^muffle")
[10:24:20.387]                   }
[10:24:20.387]                 }
[10:24:20.387]             }
[10:24:20.387]         }))
[10:24:20.387]     }, error = function(ex) {
[10:24:20.387]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:20.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:20.387]                 ...future.rng), started = ...future.startTime, 
[10:24:20.387]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:20.387]             version = "1.8"), class = "FutureResult")
[10:24:20.387]     }, finally = {
[10:24:20.387]         if (!identical(...future.workdir, getwd())) 
[10:24:20.387]             setwd(...future.workdir)
[10:24:20.387]         {
[10:24:20.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:20.387]                 ...future.oldOptions$nwarnings <- NULL
[10:24:20.387]             }
[10:24:20.387]             base::options(...future.oldOptions)
[10:24:20.387]             if (.Platform$OS.type == "windows") {
[10:24:20.387]                 old_names <- names(...future.oldEnvVars)
[10:24:20.387]                 envs <- base::Sys.getenv()
[10:24:20.387]                 names <- names(envs)
[10:24:20.387]                 common <- intersect(names, old_names)
[10:24:20.387]                 added <- setdiff(names, old_names)
[10:24:20.387]                 removed <- setdiff(old_names, names)
[10:24:20.387]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:20.387]                   envs[common]]
[10:24:20.387]                 NAMES <- toupper(changed)
[10:24:20.387]                 args <- list()
[10:24:20.387]                 for (kk in seq_along(NAMES)) {
[10:24:20.387]                   name <- changed[[kk]]
[10:24:20.387]                   NAME <- NAMES[[kk]]
[10:24:20.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.387]                     next
[10:24:20.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:20.387]                 }
[10:24:20.387]                 NAMES <- toupper(added)
[10:24:20.387]                 for (kk in seq_along(NAMES)) {
[10:24:20.387]                   name <- added[[kk]]
[10:24:20.387]                   NAME <- NAMES[[kk]]
[10:24:20.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.387]                     next
[10:24:20.387]                   args[[name]] <- ""
[10:24:20.387]                 }
[10:24:20.387]                 NAMES <- toupper(removed)
[10:24:20.387]                 for (kk in seq_along(NAMES)) {
[10:24:20.387]                   name <- removed[[kk]]
[10:24:20.387]                   NAME <- NAMES[[kk]]
[10:24:20.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.387]                     next
[10:24:20.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:20.387]                 }
[10:24:20.387]                 if (length(args) > 0) 
[10:24:20.387]                   base::do.call(base::Sys.setenv, args = args)
[10:24:20.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:20.387]             }
[10:24:20.387]             else {
[10:24:20.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:20.387]             }
[10:24:20.387]             {
[10:24:20.387]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:20.387]                   0L) {
[10:24:20.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:20.387]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:20.387]                   base::options(opts)
[10:24:20.387]                 }
[10:24:20.387]                 {
[10:24:20.387]                   {
[10:24:20.387]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:20.387]                     NULL
[10:24:20.387]                   }
[10:24:20.387]                   options(future.plan = NULL)
[10:24:20.387]                   if (is.na(NA_character_)) 
[10:24:20.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:20.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:20.387]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:20.387]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:20.387]                     envir = parent.frame()) 
[10:24:20.387]                   {
[10:24:20.387]                     if (is.function(workers)) 
[10:24:20.387]                       workers <- workers()
[10:24:20.387]                     workers <- structure(as.integer(workers), 
[10:24:20.387]                       class = class(workers))
[10:24:20.387]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:20.387]                       workers >= 1)
[10:24:20.387]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:20.387]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:20.387]                     }
[10:24:20.387]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:20.387]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:20.387]                       envir = envir)
[10:24:20.387]                     if (!future$lazy) 
[10:24:20.387]                       future <- run(future)
[10:24:20.387]                     invisible(future)
[10:24:20.387]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:20.387]                 }
[10:24:20.387]             }
[10:24:20.387]         }
[10:24:20.387]     })
[10:24:20.387]     if (TRUE) {
[10:24:20.387]         base::sink(type = "output", split = FALSE)
[10:24:20.387]         if (TRUE) {
[10:24:20.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:20.387]         }
[10:24:20.387]         else {
[10:24:20.387]             ...future.result["stdout"] <- base::list(NULL)
[10:24:20.387]         }
[10:24:20.387]         base::close(...future.stdout)
[10:24:20.387]         ...future.stdout <- NULL
[10:24:20.387]     }
[10:24:20.387]     ...future.result$conditions <- ...future.conditions
[10:24:20.387]     ...future.result$finished <- base::Sys.time()
[10:24:20.387]     ...future.result
[10:24:20.387] }
[10:24:20.390] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[10:24:20.390] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:20.434] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:20.434] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[10:24:20.434] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[10:24:20.434] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:20.435] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:20.435] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:20.478] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:20.478] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:20.522] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:20.522] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:24:20.522] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.522] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:24:20.523] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:24:20.523] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:20.523] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.523] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:24:20.523] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:24:20.524] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:20.524] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.524] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:20.524] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.524] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[10:24:20.525] MultisessionFuture started
[10:24:20.525] - Launch lazy future ... done
[10:24:20.525] run() for ‘MultisessionFuture’ ... done
[10:24:20.525] Created future:
[10:24:20.525] MultisessionFuture:
[10:24:20.525] Label: ‘future_vapply-1’
[10:24:20.525] Expression:
[10:24:20.525] {
[10:24:20.525]     do.call(function(...) {
[10:24:20.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:20.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.525]             on.exit(options(oopts), add = TRUE)
[10:24:20.525]         }
[10:24:20.525]         {
[10:24:20.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:20.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.525]                 ...future.FUN(...future.X_jj, ...)
[10:24:20.525]             })
[10:24:20.525]         }
[10:24:20.525]     }, args = future.call.arguments)
[10:24:20.525] }
[10:24:20.525] Lazy evaluation: FALSE
[10:24:20.525] Asynchronous evaluation: TRUE
[10:24:20.525] Local evaluation: TRUE
[10:24:20.525] Environment: R_GlobalEnv
[10:24:20.525] Capture standard output: TRUE
[10:24:20.525] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:20.525] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:20.525] Packages: 1 packages (‘future.apply’)
[10:24:20.525] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:20.525] Resolved: FALSE
[10:24:20.525] Value: <not collected>
[10:24:20.525] Conditions captured: <none>
[10:24:20.525] Early signaling: FALSE
[10:24:20.525] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:20.525] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:20.537] Chunk #1 of 2 ... DONE
[10:24:20.537] Chunk #2 of 2 ...
[10:24:20.537]  - Finding globals in 'X' for chunk #2 ...
[10:24:20.537] getGlobalsAndPackages() ...
[10:24:20.538] Searching for globals...
[10:24:20.538] 
[10:24:20.538] Searching for globals ... DONE
[10:24:20.538] - globals: [0] <none>
[10:24:20.538] getGlobalsAndPackages() ... DONE
[10:24:20.538]    + additional globals found: [n=0] 
[10:24:20.538]    + additional namespaces needed: [n=0] 
[10:24:20.539]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:20.539]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:20.539]  - seeds: <none>
[10:24:20.539]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.539] getGlobalsAndPackages() ...
[10:24:20.539] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.539] Resolving globals: FALSE
[10:24:20.539] Tweak future expression to call with '...' arguments ...
[10:24:20.539] {
[10:24:20.539]     do.call(function(...) {
[10:24:20.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:20.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.539]             on.exit(options(oopts), add = TRUE)
[10:24:20.539]         }
[10:24:20.539]         {
[10:24:20.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:20.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.539]                 ...future.FUN(...future.X_jj, ...)
[10:24:20.539]             })
[10:24:20.539]         }
[10:24:20.539]     }, args = future.call.arguments)
[10:24:20.539] }
[10:24:20.540] Tweak future expression to call with '...' arguments ... DONE
[10:24:20.540] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.540] - packages: [1] ‘future.apply’
[10:24:20.540] getGlobalsAndPackages() ... DONE
[10:24:20.541] run() for ‘Future’ ...
[10:24:20.541] - state: ‘created’
[10:24:20.541] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:20.554] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:20.554] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:20.555]   - Field: ‘node’
[10:24:20.555]   - Field: ‘label’
[10:24:20.555]   - Field: ‘local’
[10:24:20.555]   - Field: ‘owner’
[10:24:20.555]   - Field: ‘envir’
[10:24:20.555]   - Field: ‘workers’
[10:24:20.555]   - Field: ‘packages’
[10:24:20.555]   - Field: ‘gc’
[10:24:20.555]   - Field: ‘conditions’
[10:24:20.555]   - Field: ‘persistent’
[10:24:20.556]   - Field: ‘expr’
[10:24:20.556]   - Field: ‘uuid’
[10:24:20.556]   - Field: ‘seed’
[10:24:20.556]   - Field: ‘version’
[10:24:20.556]   - Field: ‘result’
[10:24:20.556]   - Field: ‘asynchronous’
[10:24:20.556]   - Field: ‘calls’
[10:24:20.556]   - Field: ‘globals’
[10:24:20.556]   - Field: ‘stdout’
[10:24:20.556]   - Field: ‘earlySignal’
[10:24:20.556]   - Field: ‘lazy’
[10:24:20.557]   - Field: ‘state’
[10:24:20.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:20.557] - Launch lazy future ...
[10:24:20.557] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:20.557] Packages needed by future strategies (n = 0): <none>
[10:24:20.558] {
[10:24:20.558]     {
[10:24:20.558]         {
[10:24:20.558]             ...future.startTime <- base::Sys.time()
[10:24:20.558]             {
[10:24:20.558]                 {
[10:24:20.558]                   {
[10:24:20.558]                     {
[10:24:20.558]                       {
[10:24:20.558]                         base::local({
[10:24:20.558]                           has_future <- base::requireNamespace("future", 
[10:24:20.558]                             quietly = TRUE)
[10:24:20.558]                           if (has_future) {
[10:24:20.558]                             ns <- base::getNamespace("future")
[10:24:20.558]                             version <- ns[[".package"]][["version"]]
[10:24:20.558]                             if (is.null(version)) 
[10:24:20.558]                               version <- utils::packageVersion("future")
[10:24:20.558]                           }
[10:24:20.558]                           else {
[10:24:20.558]                             version <- NULL
[10:24:20.558]                           }
[10:24:20.558]                           if (!has_future || version < "1.8.0") {
[10:24:20.558]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:20.558]                               "", base::R.version$version.string), 
[10:24:20.558]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:20.558]                                 base::R.version$platform, 8 * 
[10:24:20.558]                                   base::.Machine$sizeof.pointer), 
[10:24:20.558]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:20.558]                                 "release", "version")], collapse = " "), 
[10:24:20.558]                               hostname = base::Sys.info()[["nodename"]])
[10:24:20.558]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:20.558]                               info)
[10:24:20.558]                             info <- base::paste(info, collapse = "; ")
[10:24:20.558]                             if (!has_future) {
[10:24:20.558]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:20.558]                                 info)
[10:24:20.558]                             }
[10:24:20.558]                             else {
[10:24:20.558]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:20.558]                                 info, version)
[10:24:20.558]                             }
[10:24:20.558]                             base::stop(msg)
[10:24:20.558]                           }
[10:24:20.558]                         })
[10:24:20.558]                       }
[10:24:20.558]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:20.558]                       base::options(mc.cores = 1L)
[10:24:20.558]                     }
[10:24:20.558]                     base::local({
[10:24:20.558]                       for (pkg in "future.apply") {
[10:24:20.558]                         base::loadNamespace(pkg)
[10:24:20.558]                         base::library(pkg, character.only = TRUE)
[10:24:20.558]                       }
[10:24:20.558]                     })
[10:24:20.558]                   }
[10:24:20.558]                   options(future.plan = NULL)
[10:24:20.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:20.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:20.558]                 }
[10:24:20.558]                 ...future.workdir <- getwd()
[10:24:20.558]             }
[10:24:20.558]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:20.558]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:20.558]         }
[10:24:20.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:20.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:20.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:20.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:20.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:20.558]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:20.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:20.558]             base::names(...future.oldOptions))
[10:24:20.558]     }
[10:24:20.558]     if (FALSE) {
[10:24:20.558]     }
[10:24:20.558]     else {
[10:24:20.558]         if (TRUE) {
[10:24:20.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:20.558]                 open = "w")
[10:24:20.558]         }
[10:24:20.558]         else {
[10:24:20.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:20.558]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:20.558]         }
[10:24:20.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:20.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:20.558]             base::sink(type = "output", split = FALSE)
[10:24:20.558]             base::close(...future.stdout)
[10:24:20.558]         }, add = TRUE)
[10:24:20.558]     }
[10:24:20.558]     ...future.frame <- base::sys.nframe()
[10:24:20.558]     ...future.conditions <- base::list()
[10:24:20.558]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:20.558]     if (FALSE) {
[10:24:20.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:20.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:20.558]     }
[10:24:20.558]     ...future.result <- base::tryCatch({
[10:24:20.558]         base::withCallingHandlers({
[10:24:20.558]             ...future.value <- base::withVisible(base::local({
[10:24:20.558]                 ...future.makeSendCondition <- base::local({
[10:24:20.558]                   sendCondition <- NULL
[10:24:20.558]                   function(frame = 1L) {
[10:24:20.558]                     if (is.function(sendCondition)) 
[10:24:20.558]                       return(sendCondition)
[10:24:20.558]                     ns <- getNamespace("parallel")
[10:24:20.558]                     if (exists("sendData", mode = "function", 
[10:24:20.558]                       envir = ns)) {
[10:24:20.558]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:20.558]                         envir = ns)
[10:24:20.558]                       envir <- sys.frame(frame)
[10:24:20.558]                       master <- NULL
[10:24:20.558]                       while (!identical(envir, .GlobalEnv) && 
[10:24:20.558]                         !identical(envir, emptyenv())) {
[10:24:20.558]                         if (exists("master", mode = "list", envir = envir, 
[10:24:20.558]                           inherits = FALSE)) {
[10:24:20.558]                           master <- get("master", mode = "list", 
[10:24:20.558]                             envir = envir, inherits = FALSE)
[10:24:20.558]                           if (inherits(master, c("SOCKnode", 
[10:24:20.558]                             "SOCK0node"))) {
[10:24:20.558]                             sendCondition <<- function(cond) {
[10:24:20.558]                               data <- list(type = "VALUE", value = cond, 
[10:24:20.558]                                 success = TRUE)
[10:24:20.558]                               parallel_sendData(master, data)
[10:24:20.558]                             }
[10:24:20.558]                             return(sendCondition)
[10:24:20.558]                           }
[10:24:20.558]                         }
[10:24:20.558]                         frame <- frame + 1L
[10:24:20.558]                         envir <- sys.frame(frame)
[10:24:20.558]                       }
[10:24:20.558]                     }
[10:24:20.558]                     sendCondition <<- function(cond) NULL
[10:24:20.558]                   }
[10:24:20.558]                 })
[10:24:20.558]                 withCallingHandlers({
[10:24:20.558]                   {
[10:24:20.558]                     do.call(function(...) {
[10:24:20.558]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.558]                       if (!identical(...future.globals.maxSize.org, 
[10:24:20.558]                         ...future.globals.maxSize)) {
[10:24:20.558]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.558]                         on.exit(options(oopts), add = TRUE)
[10:24:20.558]                       }
[10:24:20.558]                       {
[10:24:20.558]                         lapply(seq_along(...future.elements_ii), 
[10:24:20.558]                           FUN = function(jj) {
[10:24:20.558]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.558]                             ...future.FUN(...future.X_jj, ...)
[10:24:20.558]                           })
[10:24:20.558]                       }
[10:24:20.558]                     }, args = future.call.arguments)
[10:24:20.558]                   }
[10:24:20.558]                 }, immediateCondition = function(cond) {
[10:24:20.558]                   sendCondition <- ...future.makeSendCondition()
[10:24:20.558]                   sendCondition(cond)
[10:24:20.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.558]                   {
[10:24:20.558]                     inherits <- base::inherits
[10:24:20.558]                     invokeRestart <- base::invokeRestart
[10:24:20.558]                     is.null <- base::is.null
[10:24:20.558]                     muffled <- FALSE
[10:24:20.558]                     if (inherits(cond, "message")) {
[10:24:20.558]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:20.558]                       if (muffled) 
[10:24:20.558]                         invokeRestart("muffleMessage")
[10:24:20.558]                     }
[10:24:20.558]                     else if (inherits(cond, "warning")) {
[10:24:20.558]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:20.558]                       if (muffled) 
[10:24:20.558]                         invokeRestart("muffleWarning")
[10:24:20.558]                     }
[10:24:20.558]                     else if (inherits(cond, "condition")) {
[10:24:20.558]                       if (!is.null(pattern)) {
[10:24:20.558]                         computeRestarts <- base::computeRestarts
[10:24:20.558]                         grepl <- base::grepl
[10:24:20.558]                         restarts <- computeRestarts(cond)
[10:24:20.558]                         for (restart in restarts) {
[10:24:20.558]                           name <- restart$name
[10:24:20.558]                           if (is.null(name)) 
[10:24:20.558]                             next
[10:24:20.558]                           if (!grepl(pattern, name)) 
[10:24:20.558]                             next
[10:24:20.558]                           invokeRestart(restart)
[10:24:20.558]                           muffled <- TRUE
[10:24:20.558]                           break
[10:24:20.558]                         }
[10:24:20.558]                       }
[10:24:20.558]                     }
[10:24:20.558]                     invisible(muffled)
[10:24:20.558]                   }
[10:24:20.558]                   muffleCondition(cond)
[10:24:20.558]                 })
[10:24:20.558]             }))
[10:24:20.558]             future::FutureResult(value = ...future.value$value, 
[10:24:20.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:20.558]                   ...future.rng), globalenv = if (FALSE) 
[10:24:20.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:20.558]                     ...future.globalenv.names))
[10:24:20.558]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:20.558]         }, condition = base::local({
[10:24:20.558]             c <- base::c
[10:24:20.558]             inherits <- base::inherits
[10:24:20.558]             invokeRestart <- base::invokeRestart
[10:24:20.558]             length <- base::length
[10:24:20.558]             list <- base::list
[10:24:20.558]             seq.int <- base::seq.int
[10:24:20.558]             signalCondition <- base::signalCondition
[10:24:20.558]             sys.calls <- base::sys.calls
[10:24:20.558]             `[[` <- base::`[[`
[10:24:20.558]             `+` <- base::`+`
[10:24:20.558]             `<<-` <- base::`<<-`
[10:24:20.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:20.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:20.558]                   3L)]
[10:24:20.558]             }
[10:24:20.558]             function(cond) {
[10:24:20.558]                 is_error <- inherits(cond, "error")
[10:24:20.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:20.558]                   NULL)
[10:24:20.558]                 if (is_error) {
[10:24:20.558]                   sessionInformation <- function() {
[10:24:20.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:20.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:20.558]                       search = base::search(), system = base::Sys.info())
[10:24:20.558]                   }
[10:24:20.558]                   ...future.conditions[[length(...future.conditions) + 
[10:24:20.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:20.558]                     cond$call), session = sessionInformation(), 
[10:24:20.558]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:20.558]                   signalCondition(cond)
[10:24:20.558]                 }
[10:24:20.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:20.558]                 "immediateCondition"))) {
[10:24:20.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:20.558]                   ...future.conditions[[length(...future.conditions) + 
[10:24:20.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:20.558]                   if (TRUE && !signal) {
[10:24:20.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.558]                     {
[10:24:20.558]                       inherits <- base::inherits
[10:24:20.558]                       invokeRestart <- base::invokeRestart
[10:24:20.558]                       is.null <- base::is.null
[10:24:20.558]                       muffled <- FALSE
[10:24:20.558]                       if (inherits(cond, "message")) {
[10:24:20.558]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:20.558]                         if (muffled) 
[10:24:20.558]                           invokeRestart("muffleMessage")
[10:24:20.558]                       }
[10:24:20.558]                       else if (inherits(cond, "warning")) {
[10:24:20.558]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:20.558]                         if (muffled) 
[10:24:20.558]                           invokeRestart("muffleWarning")
[10:24:20.558]                       }
[10:24:20.558]                       else if (inherits(cond, "condition")) {
[10:24:20.558]                         if (!is.null(pattern)) {
[10:24:20.558]                           computeRestarts <- base::computeRestarts
[10:24:20.558]                           grepl <- base::grepl
[10:24:20.558]                           restarts <- computeRestarts(cond)
[10:24:20.558]                           for (restart in restarts) {
[10:24:20.558]                             name <- restart$name
[10:24:20.558]                             if (is.null(name)) 
[10:24:20.558]                               next
[10:24:20.558]                             if (!grepl(pattern, name)) 
[10:24:20.558]                               next
[10:24:20.558]                             invokeRestart(restart)
[10:24:20.558]                             muffled <- TRUE
[10:24:20.558]                             break
[10:24:20.558]                           }
[10:24:20.558]                         }
[10:24:20.558]                       }
[10:24:20.558]                       invisible(muffled)
[10:24:20.558]                     }
[10:24:20.558]                     muffleCondition(cond, pattern = "^muffle")
[10:24:20.558]                   }
[10:24:20.558]                 }
[10:24:20.558]                 else {
[10:24:20.558]                   if (TRUE) {
[10:24:20.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.558]                     {
[10:24:20.558]                       inherits <- base::inherits
[10:24:20.558]                       invokeRestart <- base::invokeRestart
[10:24:20.558]                       is.null <- base::is.null
[10:24:20.558]                       muffled <- FALSE
[10:24:20.558]                       if (inherits(cond, "message")) {
[10:24:20.558]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:20.558]                         if (muffled) 
[10:24:20.558]                           invokeRestart("muffleMessage")
[10:24:20.558]                       }
[10:24:20.558]                       else if (inherits(cond, "warning")) {
[10:24:20.558]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:20.558]                         if (muffled) 
[10:24:20.558]                           invokeRestart("muffleWarning")
[10:24:20.558]                       }
[10:24:20.558]                       else if (inherits(cond, "condition")) {
[10:24:20.558]                         if (!is.null(pattern)) {
[10:24:20.558]                           computeRestarts <- base::computeRestarts
[10:24:20.558]                           grepl <- base::grepl
[10:24:20.558]                           restarts <- computeRestarts(cond)
[10:24:20.558]                           for (restart in restarts) {
[10:24:20.558]                             name <- restart$name
[10:24:20.558]                             if (is.null(name)) 
[10:24:20.558]                               next
[10:24:20.558]                             if (!grepl(pattern, name)) 
[10:24:20.558]                               next
[10:24:20.558]                             invokeRestart(restart)
[10:24:20.558]                             muffled <- TRUE
[10:24:20.558]                             break
[10:24:20.558]                           }
[10:24:20.558]                         }
[10:24:20.558]                       }
[10:24:20.558]                       invisible(muffled)
[10:24:20.558]                     }
[10:24:20.558]                     muffleCondition(cond, pattern = "^muffle")
[10:24:20.558]                   }
[10:24:20.558]                 }
[10:24:20.558]             }
[10:24:20.558]         }))
[10:24:20.558]     }, error = function(ex) {
[10:24:20.558]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:20.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:20.558]                 ...future.rng), started = ...future.startTime, 
[10:24:20.558]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:20.558]             version = "1.8"), class = "FutureResult")
[10:24:20.558]     }, finally = {
[10:24:20.558]         if (!identical(...future.workdir, getwd())) 
[10:24:20.558]             setwd(...future.workdir)
[10:24:20.558]         {
[10:24:20.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:20.558]                 ...future.oldOptions$nwarnings <- NULL
[10:24:20.558]             }
[10:24:20.558]             base::options(...future.oldOptions)
[10:24:20.558]             if (.Platform$OS.type == "windows") {
[10:24:20.558]                 old_names <- names(...future.oldEnvVars)
[10:24:20.558]                 envs <- base::Sys.getenv()
[10:24:20.558]                 names <- names(envs)
[10:24:20.558]                 common <- intersect(names, old_names)
[10:24:20.558]                 added <- setdiff(names, old_names)
[10:24:20.558]                 removed <- setdiff(old_names, names)
[10:24:20.558]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:20.558]                   envs[common]]
[10:24:20.558]                 NAMES <- toupper(changed)
[10:24:20.558]                 args <- list()
[10:24:20.558]                 for (kk in seq_along(NAMES)) {
[10:24:20.558]                   name <- changed[[kk]]
[10:24:20.558]                   NAME <- NAMES[[kk]]
[10:24:20.558]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.558]                     next
[10:24:20.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:20.558]                 }
[10:24:20.558]                 NAMES <- toupper(added)
[10:24:20.558]                 for (kk in seq_along(NAMES)) {
[10:24:20.558]                   name <- added[[kk]]
[10:24:20.558]                   NAME <- NAMES[[kk]]
[10:24:20.558]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.558]                     next
[10:24:20.558]                   args[[name]] <- ""
[10:24:20.558]                 }
[10:24:20.558]                 NAMES <- toupper(removed)
[10:24:20.558]                 for (kk in seq_along(NAMES)) {
[10:24:20.558]                   name <- removed[[kk]]
[10:24:20.558]                   NAME <- NAMES[[kk]]
[10:24:20.558]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.558]                     next
[10:24:20.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:20.558]                 }
[10:24:20.558]                 if (length(args) > 0) 
[10:24:20.558]                   base::do.call(base::Sys.setenv, args = args)
[10:24:20.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:20.558]             }
[10:24:20.558]             else {
[10:24:20.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:20.558]             }
[10:24:20.558]             {
[10:24:20.558]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:20.558]                   0L) {
[10:24:20.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:20.558]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:20.558]                   base::options(opts)
[10:24:20.558]                 }
[10:24:20.558]                 {
[10:24:20.558]                   {
[10:24:20.558]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:20.558]                     NULL
[10:24:20.558]                   }
[10:24:20.558]                   options(future.plan = NULL)
[10:24:20.558]                   if (is.na(NA_character_)) 
[10:24:20.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:20.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:20.558]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:20.558]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:20.558]                     envir = parent.frame()) 
[10:24:20.558]                   {
[10:24:20.558]                     if (is.function(workers)) 
[10:24:20.558]                       workers <- workers()
[10:24:20.558]                     workers <- structure(as.integer(workers), 
[10:24:20.558]                       class = class(workers))
[10:24:20.558]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:20.558]                       workers >= 1)
[10:24:20.558]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:20.558]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:20.558]                     }
[10:24:20.558]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:20.558]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:20.558]                       envir = envir)
[10:24:20.558]                     if (!future$lazy) 
[10:24:20.558]                       future <- run(future)
[10:24:20.558]                     invisible(future)
[10:24:20.558]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:20.558]                 }
[10:24:20.558]             }
[10:24:20.558]         }
[10:24:20.558]     })
[10:24:20.558]     if (TRUE) {
[10:24:20.558]         base::sink(type = "output", split = FALSE)
[10:24:20.558]         if (TRUE) {
[10:24:20.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:20.558]         }
[10:24:20.558]         else {
[10:24:20.558]             ...future.result["stdout"] <- base::list(NULL)
[10:24:20.558]         }
[10:24:20.558]         base::close(...future.stdout)
[10:24:20.558]         ...future.stdout <- NULL
[10:24:20.558]     }
[10:24:20.558]     ...future.result$conditions <- ...future.conditions
[10:24:20.558]     ...future.result$finished <- base::Sys.time()
[10:24:20.558]     ...future.result
[10:24:20.558] }
[10:24:20.560] Exporting 11 global objects (93.23 KiB) to cluster node #2 ...
[10:24:20.561] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:20.602] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:20.602] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[10:24:20.602] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[10:24:20.603] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:20.603] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:20.603] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:20.646] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:20.646] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:20.690] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:20.690] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:24:20.690] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:24:20.690] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:24:20.691] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:24:20.691] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:20.691] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:20.691] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:24:20.692] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:24:20.692] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:20.692] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:20.692] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:20.693] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:20.693] Exporting 11 global objects (93.23 KiB) to cluster node #2 ... DONE
[10:24:20.693] MultisessionFuture started
[10:24:20.694] - Launch lazy future ... done
[10:24:20.694] run() for ‘MultisessionFuture’ ... done
[10:24:20.694] Created future:
[10:24:20.694] MultisessionFuture:
[10:24:20.694] Label: ‘future_vapply-2’
[10:24:20.694] Expression:
[10:24:20.694] {
[10:24:20.694]     do.call(function(...) {
[10:24:20.694]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.694]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:20.694]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.694]             on.exit(options(oopts), add = TRUE)
[10:24:20.694]         }
[10:24:20.694]         {
[10:24:20.694]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:20.694]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.694]                 ...future.FUN(...future.X_jj, ...)
[10:24:20.694]             })
[10:24:20.694]         }
[10:24:20.694]     }, args = future.call.arguments)
[10:24:20.694] }
[10:24:20.694] Lazy evaluation: FALSE
[10:24:20.694] Asynchronous evaluation: TRUE
[10:24:20.694] Local evaluation: TRUE
[10:24:20.694] Environment: R_GlobalEnv
[10:24:20.694] Capture standard output: TRUE
[10:24:20.694] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:20.694] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:20.694] Packages: 1 packages (‘future.apply’)
[10:24:20.694] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:20.694] Resolved: FALSE
[10:24:20.694] Value: <not collected>
[10:24:20.694] Conditions captured: <none>
[10:24:20.694] Early signaling: FALSE
[10:24:20.694] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:20.694] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:20.706] Chunk #2 of 2 ... DONE
[10:24:20.706] Launching 2 futures (chunks) ... DONE
[10:24:20.706] Resolving 2 futures (chunks) ...
[10:24:20.706] resolve() on list ...
[10:24:20.706]  recursive: 0
[10:24:20.706]  length: 2
[10:24:20.706] 
[10:24:20.707] receiveMessageFromWorker() for ClusterFuture ...
[10:24:20.707] - Validating connection of MultisessionFuture
[10:24:20.707] - received message: FutureResult
[10:24:20.707] - Received FutureResult
[10:24:20.707] - Erased future from FutureRegistry
[10:24:20.707] result() for ClusterFuture ...
[10:24:20.707] - result already collected: FutureResult
[10:24:20.708] result() for ClusterFuture ... done
[10:24:20.708] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:20.708] Future #1
[10:24:20.708] result() for ClusterFuture ...
[10:24:20.708] - result already collected: FutureResult
[10:24:20.708] result() for ClusterFuture ... done
[10:24:20.708] result() for ClusterFuture ...
[10:24:20.708] - result already collected: FutureResult
[10:24:20.708] result() for ClusterFuture ... done
[10:24:20.708] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:20.708] - nx: 2
[10:24:20.709] - relay: TRUE
[10:24:20.709] - stdout: TRUE
[10:24:20.709] - signal: TRUE
[10:24:20.709] - resignal: FALSE
[10:24:20.709] - force: TRUE
[10:24:20.709] - relayed: [n=2] FALSE, FALSE
[10:24:20.709] - queued futures: [n=2] FALSE, FALSE
[10:24:20.709]  - until=1
[10:24:20.709]  - relaying element #1
[10:24:20.709] result() for ClusterFuture ...
[10:24:20.709] - result already collected: FutureResult
[10:24:20.710] result() for ClusterFuture ... done
[10:24:20.710] result() for ClusterFuture ...
[10:24:20.710] - result already collected: FutureResult
[10:24:20.710] result() for ClusterFuture ... done
[10:24:20.710] result() for ClusterFuture ...
[10:24:20.710] - result already collected: FutureResult
[10:24:20.710] result() for ClusterFuture ... done
[10:24:20.710] result() for ClusterFuture ...
[10:24:20.710] - result already collected: FutureResult
[10:24:20.710] result() for ClusterFuture ... done
[10:24:20.710] - relayed: [n=2] TRUE, FALSE
[10:24:20.711] - queued futures: [n=2] TRUE, FALSE
[10:24:20.711] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:20.711]  length: 1 (resolved future 1)
[10:24:20.752] receiveMessageFromWorker() for ClusterFuture ...
[10:24:20.752] - Validating connection of MultisessionFuture
[10:24:20.753] - received message: FutureResult
[10:24:20.753] - Received FutureResult
[10:24:20.753] - Erased future from FutureRegistry
[10:24:20.753] result() for ClusterFuture ...
[10:24:20.753] - result already collected: FutureResult
[10:24:20.753] result() for ClusterFuture ... done
[10:24:20.753] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:20.753] Future #2
[10:24:20.753] result() for ClusterFuture ...
[10:24:20.754] - result already collected: FutureResult
[10:24:20.754] result() for ClusterFuture ... done
[10:24:20.754] result() for ClusterFuture ...
[10:24:20.754] - result already collected: FutureResult
[10:24:20.754] result() for ClusterFuture ... done
[10:24:20.754] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:20.754] - nx: 2
[10:24:20.754] - relay: TRUE
[10:24:20.754] - stdout: TRUE
[10:24:20.754] - signal: TRUE
[10:24:20.754] - resignal: FALSE
[10:24:20.754] - force: TRUE
[10:24:20.755] - relayed: [n=2] TRUE, FALSE
[10:24:20.755] - queued futures: [n=2] TRUE, FALSE
[10:24:20.755]  - until=2
[10:24:20.755]  - relaying element #2
[10:24:20.755] result() for ClusterFuture ...
[10:24:20.755] - result already collected: FutureResult
[10:24:20.755] result() for ClusterFuture ... done
[10:24:20.755] result() for ClusterFuture ...
[10:24:20.755] - result already collected: FutureResult
[10:24:20.755] result() for ClusterFuture ... done
[10:24:20.755] result() for ClusterFuture ...
[10:24:20.756] - result already collected: FutureResult
[10:24:20.756] result() for ClusterFuture ... done
[10:24:20.756] result() for ClusterFuture ...
[10:24:20.756] - result already collected: FutureResult
[10:24:20.756] result() for ClusterFuture ... done
[10:24:20.756] - relayed: [n=2] TRUE, TRUE
[10:24:20.756] - queued futures: [n=2] TRUE, TRUE
[10:24:20.756] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:20.756]  length: 0 (resolved future 2)
[10:24:20.756] Relaying remaining futures
[10:24:20.756] signalConditionsASAP(NULL, pos=0) ...
[10:24:20.757] - nx: 2
[10:24:20.757] - relay: TRUE
[10:24:20.757] - stdout: TRUE
[10:24:20.757] - signal: TRUE
[10:24:20.757] - resignal: FALSE
[10:24:20.757] - force: TRUE
[10:24:20.757] - relayed: [n=2] TRUE, TRUE
[10:24:20.757] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:20.757] - relayed: [n=2] TRUE, TRUE
[10:24:20.757] - queued futures: [n=2] TRUE, TRUE
[10:24:20.757] signalConditionsASAP(NULL, pos=0) ... done
[10:24:20.758] resolve() on list ... DONE
[10:24:20.758] result() for ClusterFuture ...
[10:24:20.758] - result already collected: FutureResult
[10:24:20.758] result() for ClusterFuture ... done
[10:24:20.758] result() for ClusterFuture ...
[10:24:20.758] - result already collected: FutureResult
[10:24:20.758] result() for ClusterFuture ... done
[10:24:20.758] result() for ClusterFuture ...
[10:24:20.758] - result already collected: FutureResult
[10:24:20.758] result() for ClusterFuture ... done
[10:24:20.758] result() for ClusterFuture ...
[10:24:20.758] - result already collected: FutureResult
[10:24:20.759] result() for ClusterFuture ... done
[10:24:20.759]  - Number of value chunks collected: 2
[10:24:20.759] Resolving 2 futures (chunks) ... DONE
[10:24:20.759] Reducing values from 2 chunks ...
[10:24:20.759]  - Number of values collected after concatenation: 10
[10:24:20.759]  - Number of values expected: 10
[10:24:20.759] Reducing values from 2 chunks ... DONE
[10:24:20.759] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[10:24:20.760] future_lapply() ...
[10:24:20.771] Number of chunks: 2
[10:24:20.771] getGlobalsAndPackagesXApply() ...
[10:24:20.771]  - future.globals: TRUE
[10:24:20.771] getGlobalsAndPackages() ...
[10:24:20.772] Searching for globals...
[10:24:20.775] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[10:24:20.775] Searching for globals ... DONE
[10:24:20.775] Resolving globals: FALSE
[10:24:20.776] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[10:24:20.776] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:20.777] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:20.777] - packages: [1] ‘future.apply’
[10:24:20.777] getGlobalsAndPackages() ... DONE
[10:24:20.777]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:20.777]  - needed namespaces: [n=1] ‘future.apply’
[10:24:20.777] Finding globals ... DONE
[10:24:20.777]  - use_args: TRUE
[10:24:20.777]  - Getting '...' globals ...
[10:24:20.778] resolve() on list ...
[10:24:20.778]  recursive: 0
[10:24:20.778]  length: 1
[10:24:20.778]  elements: ‘...’
[10:24:20.778]  length: 0 (resolved future 1)
[10:24:20.778] resolve() on list ... DONE
[10:24:20.778]    - '...' content: [n=0] 
[10:24:20.778] List of 1
[10:24:20.778]  $ ...: list()
[10:24:20.778]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:20.778]  - attr(*, "where")=List of 1
[10:24:20.778]   ..$ ...:<environment: 0x55b93f93acc0> 
[10:24:20.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:20.778]  - attr(*, "resolved")= logi TRUE
[10:24:20.778]  - attr(*, "total_size")= num NA
[10:24:20.781]  - Getting '...' globals ... DONE
[10:24:20.781] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:20.781] List of 8
[10:24:20.781]  $ ...future.FUN:function (x, ...)  
[10:24:20.781]  $ x_FUN        :function (x)  
[10:24:20.781]  $ times        : int 0
[10:24:20.781]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:20.781]  $ stop_if_not  :function (...)  
[10:24:20.781]  $ dim          : NULL
[10:24:20.781]  $ valid_types  : chr [1:2] "logical" "integer"
[10:24:20.781]  $ ...          : list()
[10:24:20.781]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:20.781]  - attr(*, "where")=List of 8
[10:24:20.781]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:20.781]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:20.781]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:20.781]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:20.781]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:20.781]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:20.781]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:20.781]   ..$ ...          :<environment: 0x55b93f93acc0> 
[10:24:20.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:20.781]  - attr(*, "resolved")= logi FALSE
[10:24:20.781]  - attr(*, "total_size")= num 95400
[10:24:20.787] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:20.787] getGlobalsAndPackagesXApply() ... DONE
[10:24:20.787] Number of futures (= number of chunks): 2
[10:24:20.787] Launching 2 futures (chunks) ...
[10:24:20.787] Chunk #1 of 2 ...
[10:24:20.787]  - Finding globals in 'X' for chunk #1 ...
[10:24:20.787] getGlobalsAndPackages() ...
[10:24:20.787] Searching for globals...
[10:24:20.788] 
[10:24:20.788] Searching for globals ... DONE
[10:24:20.788] - globals: [0] <none>
[10:24:20.788] getGlobalsAndPackages() ... DONE
[10:24:20.788]    + additional globals found: [n=0] 
[10:24:20.788]    + additional namespaces needed: [n=0] 
[10:24:20.788]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:20.788]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:20.788]  - seeds: <none>
[10:24:20.789]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.789] getGlobalsAndPackages() ...
[10:24:20.789] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.789] Resolving globals: FALSE
[10:24:20.789] Tweak future expression to call with '...' arguments ...
[10:24:20.789] {
[10:24:20.789]     do.call(function(...) {
[10:24:20.789]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.789]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:20.789]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.789]             on.exit(options(oopts), add = TRUE)
[10:24:20.789]         }
[10:24:20.789]         {
[10:24:20.789]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:20.789]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.789]                 ...future.FUN(...future.X_jj, ...)
[10:24:20.789]             })
[10:24:20.789]         }
[10:24:20.789]     }, args = future.call.arguments)
[10:24:20.789] }
[10:24:20.789] Tweak future expression to call with '...' arguments ... DONE
[10:24:20.790] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.790] - packages: [1] ‘future.apply’
[10:24:20.790] getGlobalsAndPackages() ... DONE
[10:24:20.790] run() for ‘Future’ ...
[10:24:20.791] - state: ‘created’
[10:24:20.791] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:20.804] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:20.804] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:20.804]   - Field: ‘node’
[10:24:20.804]   - Field: ‘label’
[10:24:20.804]   - Field: ‘local’
[10:24:20.805]   - Field: ‘owner’
[10:24:20.805]   - Field: ‘envir’
[10:24:20.805]   - Field: ‘workers’
[10:24:20.805]   - Field: ‘packages’
[10:24:20.805]   - Field: ‘gc’
[10:24:20.805]   - Field: ‘conditions’
[10:24:20.805]   - Field: ‘persistent’
[10:24:20.805]   - Field: ‘expr’
[10:24:20.805]   - Field: ‘uuid’
[10:24:20.805]   - Field: ‘seed’
[10:24:20.806]   - Field: ‘version’
[10:24:20.806]   - Field: ‘result’
[10:24:20.806]   - Field: ‘asynchronous’
[10:24:20.806]   - Field: ‘calls’
[10:24:20.806]   - Field: ‘globals’
[10:24:20.806]   - Field: ‘stdout’
[10:24:20.806]   - Field: ‘earlySignal’
[10:24:20.806]   - Field: ‘lazy’
[10:24:20.806]   - Field: ‘state’
[10:24:20.806] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:20.806] - Launch lazy future ...
[10:24:20.807] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:20.807] Packages needed by future strategies (n = 0): <none>
[10:24:20.807] {
[10:24:20.807]     {
[10:24:20.807]         {
[10:24:20.807]             ...future.startTime <- base::Sys.time()
[10:24:20.807]             {
[10:24:20.807]                 {
[10:24:20.807]                   {
[10:24:20.807]                     {
[10:24:20.807]                       {
[10:24:20.807]                         base::local({
[10:24:20.807]                           has_future <- base::requireNamespace("future", 
[10:24:20.807]                             quietly = TRUE)
[10:24:20.807]                           if (has_future) {
[10:24:20.807]                             ns <- base::getNamespace("future")
[10:24:20.807]                             version <- ns[[".package"]][["version"]]
[10:24:20.807]                             if (is.null(version)) 
[10:24:20.807]                               version <- utils::packageVersion("future")
[10:24:20.807]                           }
[10:24:20.807]                           else {
[10:24:20.807]                             version <- NULL
[10:24:20.807]                           }
[10:24:20.807]                           if (!has_future || version < "1.8.0") {
[10:24:20.807]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:20.807]                               "", base::R.version$version.string), 
[10:24:20.807]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:20.807]                                 base::R.version$platform, 8 * 
[10:24:20.807]                                   base::.Machine$sizeof.pointer), 
[10:24:20.807]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:20.807]                                 "release", "version")], collapse = " "), 
[10:24:20.807]                               hostname = base::Sys.info()[["nodename"]])
[10:24:20.807]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:20.807]                               info)
[10:24:20.807]                             info <- base::paste(info, collapse = "; ")
[10:24:20.807]                             if (!has_future) {
[10:24:20.807]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:20.807]                                 info)
[10:24:20.807]                             }
[10:24:20.807]                             else {
[10:24:20.807]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:20.807]                                 info, version)
[10:24:20.807]                             }
[10:24:20.807]                             base::stop(msg)
[10:24:20.807]                           }
[10:24:20.807]                         })
[10:24:20.807]                       }
[10:24:20.807]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:20.807]                       base::options(mc.cores = 1L)
[10:24:20.807]                     }
[10:24:20.807]                     base::local({
[10:24:20.807]                       for (pkg in "future.apply") {
[10:24:20.807]                         base::loadNamespace(pkg)
[10:24:20.807]                         base::library(pkg, character.only = TRUE)
[10:24:20.807]                       }
[10:24:20.807]                     })
[10:24:20.807]                   }
[10:24:20.807]                   options(future.plan = NULL)
[10:24:20.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:20.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:20.807]                 }
[10:24:20.807]                 ...future.workdir <- getwd()
[10:24:20.807]             }
[10:24:20.807]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:20.807]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:20.807]         }
[10:24:20.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:20.807]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:20.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:20.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:20.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:20.807]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:20.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:20.807]             base::names(...future.oldOptions))
[10:24:20.807]     }
[10:24:20.807]     if (FALSE) {
[10:24:20.807]     }
[10:24:20.807]     else {
[10:24:20.807]         if (TRUE) {
[10:24:20.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:20.807]                 open = "w")
[10:24:20.807]         }
[10:24:20.807]         else {
[10:24:20.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:20.807]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:20.807]         }
[10:24:20.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:20.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:20.807]             base::sink(type = "output", split = FALSE)
[10:24:20.807]             base::close(...future.stdout)
[10:24:20.807]         }, add = TRUE)
[10:24:20.807]     }
[10:24:20.807]     ...future.frame <- base::sys.nframe()
[10:24:20.807]     ...future.conditions <- base::list()
[10:24:20.807]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:20.807]     if (FALSE) {
[10:24:20.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:20.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:20.807]     }
[10:24:20.807]     ...future.result <- base::tryCatch({
[10:24:20.807]         base::withCallingHandlers({
[10:24:20.807]             ...future.value <- base::withVisible(base::local({
[10:24:20.807]                 ...future.makeSendCondition <- base::local({
[10:24:20.807]                   sendCondition <- NULL
[10:24:20.807]                   function(frame = 1L) {
[10:24:20.807]                     if (is.function(sendCondition)) 
[10:24:20.807]                       return(sendCondition)
[10:24:20.807]                     ns <- getNamespace("parallel")
[10:24:20.807]                     if (exists("sendData", mode = "function", 
[10:24:20.807]                       envir = ns)) {
[10:24:20.807]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:20.807]                         envir = ns)
[10:24:20.807]                       envir <- sys.frame(frame)
[10:24:20.807]                       master <- NULL
[10:24:20.807]                       while (!identical(envir, .GlobalEnv) && 
[10:24:20.807]                         !identical(envir, emptyenv())) {
[10:24:20.807]                         if (exists("master", mode = "list", envir = envir, 
[10:24:20.807]                           inherits = FALSE)) {
[10:24:20.807]                           master <- get("master", mode = "list", 
[10:24:20.807]                             envir = envir, inherits = FALSE)
[10:24:20.807]                           if (inherits(master, c("SOCKnode", 
[10:24:20.807]                             "SOCK0node"))) {
[10:24:20.807]                             sendCondition <<- function(cond) {
[10:24:20.807]                               data <- list(type = "VALUE", value = cond, 
[10:24:20.807]                                 success = TRUE)
[10:24:20.807]                               parallel_sendData(master, data)
[10:24:20.807]                             }
[10:24:20.807]                             return(sendCondition)
[10:24:20.807]                           }
[10:24:20.807]                         }
[10:24:20.807]                         frame <- frame + 1L
[10:24:20.807]                         envir <- sys.frame(frame)
[10:24:20.807]                       }
[10:24:20.807]                     }
[10:24:20.807]                     sendCondition <<- function(cond) NULL
[10:24:20.807]                   }
[10:24:20.807]                 })
[10:24:20.807]                 withCallingHandlers({
[10:24:20.807]                   {
[10:24:20.807]                     do.call(function(...) {
[10:24:20.807]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.807]                       if (!identical(...future.globals.maxSize.org, 
[10:24:20.807]                         ...future.globals.maxSize)) {
[10:24:20.807]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.807]                         on.exit(options(oopts), add = TRUE)
[10:24:20.807]                       }
[10:24:20.807]                       {
[10:24:20.807]                         lapply(seq_along(...future.elements_ii), 
[10:24:20.807]                           FUN = function(jj) {
[10:24:20.807]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.807]                             ...future.FUN(...future.X_jj, ...)
[10:24:20.807]                           })
[10:24:20.807]                       }
[10:24:20.807]                     }, args = future.call.arguments)
[10:24:20.807]                   }
[10:24:20.807]                 }, immediateCondition = function(cond) {
[10:24:20.807]                   sendCondition <- ...future.makeSendCondition()
[10:24:20.807]                   sendCondition(cond)
[10:24:20.807]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.807]                   {
[10:24:20.807]                     inherits <- base::inherits
[10:24:20.807]                     invokeRestart <- base::invokeRestart
[10:24:20.807]                     is.null <- base::is.null
[10:24:20.807]                     muffled <- FALSE
[10:24:20.807]                     if (inherits(cond, "message")) {
[10:24:20.807]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:20.807]                       if (muffled) 
[10:24:20.807]                         invokeRestart("muffleMessage")
[10:24:20.807]                     }
[10:24:20.807]                     else if (inherits(cond, "warning")) {
[10:24:20.807]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:20.807]                       if (muffled) 
[10:24:20.807]                         invokeRestart("muffleWarning")
[10:24:20.807]                     }
[10:24:20.807]                     else if (inherits(cond, "condition")) {
[10:24:20.807]                       if (!is.null(pattern)) {
[10:24:20.807]                         computeRestarts <- base::computeRestarts
[10:24:20.807]                         grepl <- base::grepl
[10:24:20.807]                         restarts <- computeRestarts(cond)
[10:24:20.807]                         for (restart in restarts) {
[10:24:20.807]                           name <- restart$name
[10:24:20.807]                           if (is.null(name)) 
[10:24:20.807]                             next
[10:24:20.807]                           if (!grepl(pattern, name)) 
[10:24:20.807]                             next
[10:24:20.807]                           invokeRestart(restart)
[10:24:20.807]                           muffled <- TRUE
[10:24:20.807]                           break
[10:24:20.807]                         }
[10:24:20.807]                       }
[10:24:20.807]                     }
[10:24:20.807]                     invisible(muffled)
[10:24:20.807]                   }
[10:24:20.807]                   muffleCondition(cond)
[10:24:20.807]                 })
[10:24:20.807]             }))
[10:24:20.807]             future::FutureResult(value = ...future.value$value, 
[10:24:20.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:20.807]                   ...future.rng), globalenv = if (FALSE) 
[10:24:20.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:20.807]                     ...future.globalenv.names))
[10:24:20.807]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:20.807]         }, condition = base::local({
[10:24:20.807]             c <- base::c
[10:24:20.807]             inherits <- base::inherits
[10:24:20.807]             invokeRestart <- base::invokeRestart
[10:24:20.807]             length <- base::length
[10:24:20.807]             list <- base::list
[10:24:20.807]             seq.int <- base::seq.int
[10:24:20.807]             signalCondition <- base::signalCondition
[10:24:20.807]             sys.calls <- base::sys.calls
[10:24:20.807]             `[[` <- base::`[[`
[10:24:20.807]             `+` <- base::`+`
[10:24:20.807]             `<<-` <- base::`<<-`
[10:24:20.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:20.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:20.807]                   3L)]
[10:24:20.807]             }
[10:24:20.807]             function(cond) {
[10:24:20.807]                 is_error <- inherits(cond, "error")
[10:24:20.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:20.807]                   NULL)
[10:24:20.807]                 if (is_error) {
[10:24:20.807]                   sessionInformation <- function() {
[10:24:20.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:20.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:20.807]                       search = base::search(), system = base::Sys.info())
[10:24:20.807]                   }
[10:24:20.807]                   ...future.conditions[[length(...future.conditions) + 
[10:24:20.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:20.807]                     cond$call), session = sessionInformation(), 
[10:24:20.807]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:20.807]                   signalCondition(cond)
[10:24:20.807]                 }
[10:24:20.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:20.807]                 "immediateCondition"))) {
[10:24:20.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:20.807]                   ...future.conditions[[length(...future.conditions) + 
[10:24:20.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:20.807]                   if (TRUE && !signal) {
[10:24:20.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.807]                     {
[10:24:20.807]                       inherits <- base::inherits
[10:24:20.807]                       invokeRestart <- base::invokeRestart
[10:24:20.807]                       is.null <- base::is.null
[10:24:20.807]                       muffled <- FALSE
[10:24:20.807]                       if (inherits(cond, "message")) {
[10:24:20.807]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:20.807]                         if (muffled) 
[10:24:20.807]                           invokeRestart("muffleMessage")
[10:24:20.807]                       }
[10:24:20.807]                       else if (inherits(cond, "warning")) {
[10:24:20.807]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:20.807]                         if (muffled) 
[10:24:20.807]                           invokeRestart("muffleWarning")
[10:24:20.807]                       }
[10:24:20.807]                       else if (inherits(cond, "condition")) {
[10:24:20.807]                         if (!is.null(pattern)) {
[10:24:20.807]                           computeRestarts <- base::computeRestarts
[10:24:20.807]                           grepl <- base::grepl
[10:24:20.807]                           restarts <- computeRestarts(cond)
[10:24:20.807]                           for (restart in restarts) {
[10:24:20.807]                             name <- restart$name
[10:24:20.807]                             if (is.null(name)) 
[10:24:20.807]                               next
[10:24:20.807]                             if (!grepl(pattern, name)) 
[10:24:20.807]                               next
[10:24:20.807]                             invokeRestart(restart)
[10:24:20.807]                             muffled <- TRUE
[10:24:20.807]                             break
[10:24:20.807]                           }
[10:24:20.807]                         }
[10:24:20.807]                       }
[10:24:20.807]                       invisible(muffled)
[10:24:20.807]                     }
[10:24:20.807]                     muffleCondition(cond, pattern = "^muffle")
[10:24:20.807]                   }
[10:24:20.807]                 }
[10:24:20.807]                 else {
[10:24:20.807]                   if (TRUE) {
[10:24:20.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.807]                     {
[10:24:20.807]                       inherits <- base::inherits
[10:24:20.807]                       invokeRestart <- base::invokeRestart
[10:24:20.807]                       is.null <- base::is.null
[10:24:20.807]                       muffled <- FALSE
[10:24:20.807]                       if (inherits(cond, "message")) {
[10:24:20.807]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:20.807]                         if (muffled) 
[10:24:20.807]                           invokeRestart("muffleMessage")
[10:24:20.807]                       }
[10:24:20.807]                       else if (inherits(cond, "warning")) {
[10:24:20.807]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:20.807]                         if (muffled) 
[10:24:20.807]                           invokeRestart("muffleWarning")
[10:24:20.807]                       }
[10:24:20.807]                       else if (inherits(cond, "condition")) {
[10:24:20.807]                         if (!is.null(pattern)) {
[10:24:20.807]                           computeRestarts <- base::computeRestarts
[10:24:20.807]                           grepl <- base::grepl
[10:24:20.807]                           restarts <- computeRestarts(cond)
[10:24:20.807]                           for (restart in restarts) {
[10:24:20.807]                             name <- restart$name
[10:24:20.807]                             if (is.null(name)) 
[10:24:20.807]                               next
[10:24:20.807]                             if (!grepl(pattern, name)) 
[10:24:20.807]                               next
[10:24:20.807]                             invokeRestart(restart)
[10:24:20.807]                             muffled <- TRUE
[10:24:20.807]                             break
[10:24:20.807]                           }
[10:24:20.807]                         }
[10:24:20.807]                       }
[10:24:20.807]                       invisible(muffled)
[10:24:20.807]                     }
[10:24:20.807]                     muffleCondition(cond, pattern = "^muffle")
[10:24:20.807]                   }
[10:24:20.807]                 }
[10:24:20.807]             }
[10:24:20.807]         }))
[10:24:20.807]     }, error = function(ex) {
[10:24:20.807]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:20.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:20.807]                 ...future.rng), started = ...future.startTime, 
[10:24:20.807]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:20.807]             version = "1.8"), class = "FutureResult")
[10:24:20.807]     }, finally = {
[10:24:20.807]         if (!identical(...future.workdir, getwd())) 
[10:24:20.807]             setwd(...future.workdir)
[10:24:20.807]         {
[10:24:20.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:20.807]                 ...future.oldOptions$nwarnings <- NULL
[10:24:20.807]             }
[10:24:20.807]             base::options(...future.oldOptions)
[10:24:20.807]             if (.Platform$OS.type == "windows") {
[10:24:20.807]                 old_names <- names(...future.oldEnvVars)
[10:24:20.807]                 envs <- base::Sys.getenv()
[10:24:20.807]                 names <- names(envs)
[10:24:20.807]                 common <- intersect(names, old_names)
[10:24:20.807]                 added <- setdiff(names, old_names)
[10:24:20.807]                 removed <- setdiff(old_names, names)
[10:24:20.807]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:20.807]                   envs[common]]
[10:24:20.807]                 NAMES <- toupper(changed)
[10:24:20.807]                 args <- list()
[10:24:20.807]                 for (kk in seq_along(NAMES)) {
[10:24:20.807]                   name <- changed[[kk]]
[10:24:20.807]                   NAME <- NAMES[[kk]]
[10:24:20.807]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.807]                     next
[10:24:20.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:20.807]                 }
[10:24:20.807]                 NAMES <- toupper(added)
[10:24:20.807]                 for (kk in seq_along(NAMES)) {
[10:24:20.807]                   name <- added[[kk]]
[10:24:20.807]                   NAME <- NAMES[[kk]]
[10:24:20.807]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.807]                     next
[10:24:20.807]                   args[[name]] <- ""
[10:24:20.807]                 }
[10:24:20.807]                 NAMES <- toupper(removed)
[10:24:20.807]                 for (kk in seq_along(NAMES)) {
[10:24:20.807]                   name <- removed[[kk]]
[10:24:20.807]                   NAME <- NAMES[[kk]]
[10:24:20.807]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.807]                     next
[10:24:20.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:20.807]                 }
[10:24:20.807]                 if (length(args) > 0) 
[10:24:20.807]                   base::do.call(base::Sys.setenv, args = args)
[10:24:20.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:20.807]             }
[10:24:20.807]             else {
[10:24:20.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:20.807]             }
[10:24:20.807]             {
[10:24:20.807]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:20.807]                   0L) {
[10:24:20.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:20.807]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:20.807]                   base::options(opts)
[10:24:20.807]                 }
[10:24:20.807]                 {
[10:24:20.807]                   {
[10:24:20.807]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:20.807]                     NULL
[10:24:20.807]                   }
[10:24:20.807]                   options(future.plan = NULL)
[10:24:20.807]                   if (is.na(NA_character_)) 
[10:24:20.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:20.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:20.807]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:20.807]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:20.807]                     envir = parent.frame()) 
[10:24:20.807]                   {
[10:24:20.807]                     if (is.function(workers)) 
[10:24:20.807]                       workers <- workers()
[10:24:20.807]                     workers <- structure(as.integer(workers), 
[10:24:20.807]                       class = class(workers))
[10:24:20.807]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:20.807]                       workers >= 1)
[10:24:20.807]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:20.807]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:20.807]                     }
[10:24:20.807]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:20.807]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:20.807]                       envir = envir)
[10:24:20.807]                     if (!future$lazy) 
[10:24:20.807]                       future <- run(future)
[10:24:20.807]                     invisible(future)
[10:24:20.807]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:20.807]                 }
[10:24:20.807]             }
[10:24:20.807]         }
[10:24:20.807]     })
[10:24:20.807]     if (TRUE) {
[10:24:20.807]         base::sink(type = "output", split = FALSE)
[10:24:20.807]         if (TRUE) {
[10:24:20.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:20.807]         }
[10:24:20.807]         else {
[10:24:20.807]             ...future.result["stdout"] <- base::list(NULL)
[10:24:20.807]         }
[10:24:20.807]         base::close(...future.stdout)
[10:24:20.807]         ...future.stdout <- NULL
[10:24:20.807]     }
[10:24:20.807]     ...future.result$conditions <- ...future.conditions
[10:24:20.807]     ...future.result$finished <- base::Sys.time()
[10:24:20.807]     ...future.result
[10:24:20.807] }
[10:24:20.810] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[10:24:20.810] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:20.854] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:20.854] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[10:24:20.854] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[10:24:20.854] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:20.855] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:20.855] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:20.898] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:20.898] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:20.946] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:20.946] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:24:20.946] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.946] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[10:24:20.947] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[10:24:20.947] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:20.947] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.947] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:24:20.948] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:24:20.948] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:20.948] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.948] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:20.948] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:20.949] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[10:24:20.949] MultisessionFuture started
[10:24:20.949] - Launch lazy future ... done
[10:24:20.949] run() for ‘MultisessionFuture’ ... done
[10:24:20.949] Created future:
[10:24:20.950] MultisessionFuture:
[10:24:20.950] Label: ‘future_vapply-1’
[10:24:20.950] Expression:
[10:24:20.950] {
[10:24:20.950]     do.call(function(...) {
[10:24:20.950]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.950]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:20.950]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.950]             on.exit(options(oopts), add = TRUE)
[10:24:20.950]         }
[10:24:20.950]         {
[10:24:20.950]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:20.950]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.950]                 ...future.FUN(...future.X_jj, ...)
[10:24:20.950]             })
[10:24:20.950]         }
[10:24:20.950]     }, args = future.call.arguments)
[10:24:20.950] }
[10:24:20.950] Lazy evaluation: FALSE
[10:24:20.950] Asynchronous evaluation: TRUE
[10:24:20.950] Local evaluation: TRUE
[10:24:20.950] Environment: R_GlobalEnv
[10:24:20.950] Capture standard output: TRUE
[10:24:20.950] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:20.950] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:20.950] Packages: 1 packages (‘future.apply’)
[10:24:20.950] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:20.950] Resolved: FALSE
[10:24:20.950] Value: <not collected>
[10:24:20.950] Conditions captured: <none>
[10:24:20.950] Early signaling: FALSE
[10:24:20.950] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:20.950] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:20.961] Chunk #1 of 2 ... DONE
[10:24:20.961] Chunk #2 of 2 ...
[10:24:20.962]  - Finding globals in 'X' for chunk #2 ...
[10:24:20.962] getGlobalsAndPackages() ...
[10:24:20.962] Searching for globals...
[10:24:20.962] 
[10:24:20.962] Searching for globals ... DONE
[10:24:20.962] - globals: [0] <none>
[10:24:20.962] getGlobalsAndPackages() ... DONE
[10:24:20.962]    + additional globals found: [n=0] 
[10:24:20.962]    + additional namespaces needed: [n=0] 
[10:24:20.963]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:20.963]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:20.963]  - seeds: <none>
[10:24:20.963]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.963] getGlobalsAndPackages() ...
[10:24:20.963] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.963] Resolving globals: FALSE
[10:24:20.963] Tweak future expression to call with '...' arguments ...
[10:24:20.963] {
[10:24:20.963]     do.call(function(...) {
[10:24:20.963]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.963]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:20.963]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.963]             on.exit(options(oopts), add = TRUE)
[10:24:20.963]         }
[10:24:20.963]         {
[10:24:20.963]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:20.963]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.963]                 ...future.FUN(...future.X_jj, ...)
[10:24:20.963]             })
[10:24:20.963]         }
[10:24:20.963]     }, args = future.call.arguments)
[10:24:20.963] }
[10:24:20.964] Tweak future expression to call with '...' arguments ... DONE
[10:24:20.964] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:20.964] - packages: [1] ‘future.apply’
[10:24:20.964] getGlobalsAndPackages() ... DONE
[10:24:20.965] run() for ‘Future’ ...
[10:24:20.965] - state: ‘created’
[10:24:20.965] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:20.979] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:20.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:20.979]   - Field: ‘node’
[10:24:20.979]   - Field: ‘label’
[10:24:20.979]   - Field: ‘local’
[10:24:20.979]   - Field: ‘owner’
[10:24:20.979]   - Field: ‘envir’
[10:24:20.980]   - Field: ‘workers’
[10:24:20.980]   - Field: ‘packages’
[10:24:20.980]   - Field: ‘gc’
[10:24:20.980]   - Field: ‘conditions’
[10:24:20.980]   - Field: ‘persistent’
[10:24:20.980]   - Field: ‘expr’
[10:24:20.980]   - Field: ‘uuid’
[10:24:20.980]   - Field: ‘seed’
[10:24:20.980]   - Field: ‘version’
[10:24:20.980]   - Field: ‘result’
[10:24:20.980]   - Field: ‘asynchronous’
[10:24:20.981]   - Field: ‘calls’
[10:24:20.981]   - Field: ‘globals’
[10:24:20.981]   - Field: ‘stdout’
[10:24:20.981]   - Field: ‘earlySignal’
[10:24:20.981]   - Field: ‘lazy’
[10:24:20.981]   - Field: ‘state’
[10:24:20.981] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:20.981] - Launch lazy future ...
[10:24:20.982] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:20.982] Packages needed by future strategies (n = 0): <none>
[10:24:20.982] {
[10:24:20.982]     {
[10:24:20.982]         {
[10:24:20.982]             ...future.startTime <- base::Sys.time()
[10:24:20.982]             {
[10:24:20.982]                 {
[10:24:20.982]                   {
[10:24:20.982]                     {
[10:24:20.982]                       {
[10:24:20.982]                         base::local({
[10:24:20.982]                           has_future <- base::requireNamespace("future", 
[10:24:20.982]                             quietly = TRUE)
[10:24:20.982]                           if (has_future) {
[10:24:20.982]                             ns <- base::getNamespace("future")
[10:24:20.982]                             version <- ns[[".package"]][["version"]]
[10:24:20.982]                             if (is.null(version)) 
[10:24:20.982]                               version <- utils::packageVersion("future")
[10:24:20.982]                           }
[10:24:20.982]                           else {
[10:24:20.982]                             version <- NULL
[10:24:20.982]                           }
[10:24:20.982]                           if (!has_future || version < "1.8.0") {
[10:24:20.982]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:20.982]                               "", base::R.version$version.string), 
[10:24:20.982]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:20.982]                                 base::R.version$platform, 8 * 
[10:24:20.982]                                   base::.Machine$sizeof.pointer), 
[10:24:20.982]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:20.982]                                 "release", "version")], collapse = " "), 
[10:24:20.982]                               hostname = base::Sys.info()[["nodename"]])
[10:24:20.982]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:20.982]                               info)
[10:24:20.982]                             info <- base::paste(info, collapse = "; ")
[10:24:20.982]                             if (!has_future) {
[10:24:20.982]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:20.982]                                 info)
[10:24:20.982]                             }
[10:24:20.982]                             else {
[10:24:20.982]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:20.982]                                 info, version)
[10:24:20.982]                             }
[10:24:20.982]                             base::stop(msg)
[10:24:20.982]                           }
[10:24:20.982]                         })
[10:24:20.982]                       }
[10:24:20.982]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:20.982]                       base::options(mc.cores = 1L)
[10:24:20.982]                     }
[10:24:20.982]                     base::local({
[10:24:20.982]                       for (pkg in "future.apply") {
[10:24:20.982]                         base::loadNamespace(pkg)
[10:24:20.982]                         base::library(pkg, character.only = TRUE)
[10:24:20.982]                       }
[10:24:20.982]                     })
[10:24:20.982]                   }
[10:24:20.982]                   options(future.plan = NULL)
[10:24:20.982]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:20.982]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:20.982]                 }
[10:24:20.982]                 ...future.workdir <- getwd()
[10:24:20.982]             }
[10:24:20.982]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:20.982]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:20.982]         }
[10:24:20.982]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:20.982]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:20.982]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:20.982]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:20.982]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:20.982]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:20.982]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:20.982]             base::names(...future.oldOptions))
[10:24:20.982]     }
[10:24:20.982]     if (FALSE) {
[10:24:20.982]     }
[10:24:20.982]     else {
[10:24:20.982]         if (TRUE) {
[10:24:20.982]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:20.982]                 open = "w")
[10:24:20.982]         }
[10:24:20.982]         else {
[10:24:20.982]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:20.982]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:20.982]         }
[10:24:20.982]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:20.982]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:20.982]             base::sink(type = "output", split = FALSE)
[10:24:20.982]             base::close(...future.stdout)
[10:24:20.982]         }, add = TRUE)
[10:24:20.982]     }
[10:24:20.982]     ...future.frame <- base::sys.nframe()
[10:24:20.982]     ...future.conditions <- base::list()
[10:24:20.982]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:20.982]     if (FALSE) {
[10:24:20.982]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:20.982]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:20.982]     }
[10:24:20.982]     ...future.result <- base::tryCatch({
[10:24:20.982]         base::withCallingHandlers({
[10:24:20.982]             ...future.value <- base::withVisible(base::local({
[10:24:20.982]                 ...future.makeSendCondition <- base::local({
[10:24:20.982]                   sendCondition <- NULL
[10:24:20.982]                   function(frame = 1L) {
[10:24:20.982]                     if (is.function(sendCondition)) 
[10:24:20.982]                       return(sendCondition)
[10:24:20.982]                     ns <- getNamespace("parallel")
[10:24:20.982]                     if (exists("sendData", mode = "function", 
[10:24:20.982]                       envir = ns)) {
[10:24:20.982]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:20.982]                         envir = ns)
[10:24:20.982]                       envir <- sys.frame(frame)
[10:24:20.982]                       master <- NULL
[10:24:20.982]                       while (!identical(envir, .GlobalEnv) && 
[10:24:20.982]                         !identical(envir, emptyenv())) {
[10:24:20.982]                         if (exists("master", mode = "list", envir = envir, 
[10:24:20.982]                           inherits = FALSE)) {
[10:24:20.982]                           master <- get("master", mode = "list", 
[10:24:20.982]                             envir = envir, inherits = FALSE)
[10:24:20.982]                           if (inherits(master, c("SOCKnode", 
[10:24:20.982]                             "SOCK0node"))) {
[10:24:20.982]                             sendCondition <<- function(cond) {
[10:24:20.982]                               data <- list(type = "VALUE", value = cond, 
[10:24:20.982]                                 success = TRUE)
[10:24:20.982]                               parallel_sendData(master, data)
[10:24:20.982]                             }
[10:24:20.982]                             return(sendCondition)
[10:24:20.982]                           }
[10:24:20.982]                         }
[10:24:20.982]                         frame <- frame + 1L
[10:24:20.982]                         envir <- sys.frame(frame)
[10:24:20.982]                       }
[10:24:20.982]                     }
[10:24:20.982]                     sendCondition <<- function(cond) NULL
[10:24:20.982]                   }
[10:24:20.982]                 })
[10:24:20.982]                 withCallingHandlers({
[10:24:20.982]                   {
[10:24:20.982]                     do.call(function(...) {
[10:24:20.982]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:20.982]                       if (!identical(...future.globals.maxSize.org, 
[10:24:20.982]                         ...future.globals.maxSize)) {
[10:24:20.982]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:20.982]                         on.exit(options(oopts), add = TRUE)
[10:24:20.982]                       }
[10:24:20.982]                       {
[10:24:20.982]                         lapply(seq_along(...future.elements_ii), 
[10:24:20.982]                           FUN = function(jj) {
[10:24:20.982]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:20.982]                             ...future.FUN(...future.X_jj, ...)
[10:24:20.982]                           })
[10:24:20.982]                       }
[10:24:20.982]                     }, args = future.call.arguments)
[10:24:20.982]                   }
[10:24:20.982]                 }, immediateCondition = function(cond) {
[10:24:20.982]                   sendCondition <- ...future.makeSendCondition()
[10:24:20.982]                   sendCondition(cond)
[10:24:20.982]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.982]                   {
[10:24:20.982]                     inherits <- base::inherits
[10:24:20.982]                     invokeRestart <- base::invokeRestart
[10:24:20.982]                     is.null <- base::is.null
[10:24:20.982]                     muffled <- FALSE
[10:24:20.982]                     if (inherits(cond, "message")) {
[10:24:20.982]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:20.982]                       if (muffled) 
[10:24:20.982]                         invokeRestart("muffleMessage")
[10:24:20.982]                     }
[10:24:20.982]                     else if (inherits(cond, "warning")) {
[10:24:20.982]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:20.982]                       if (muffled) 
[10:24:20.982]                         invokeRestart("muffleWarning")
[10:24:20.982]                     }
[10:24:20.982]                     else if (inherits(cond, "condition")) {
[10:24:20.982]                       if (!is.null(pattern)) {
[10:24:20.982]                         computeRestarts <- base::computeRestarts
[10:24:20.982]                         grepl <- base::grepl
[10:24:20.982]                         restarts <- computeRestarts(cond)
[10:24:20.982]                         for (restart in restarts) {
[10:24:20.982]                           name <- restart$name
[10:24:20.982]                           if (is.null(name)) 
[10:24:20.982]                             next
[10:24:20.982]                           if (!grepl(pattern, name)) 
[10:24:20.982]                             next
[10:24:20.982]                           invokeRestart(restart)
[10:24:20.982]                           muffled <- TRUE
[10:24:20.982]                           break
[10:24:20.982]                         }
[10:24:20.982]                       }
[10:24:20.982]                     }
[10:24:20.982]                     invisible(muffled)
[10:24:20.982]                   }
[10:24:20.982]                   muffleCondition(cond)
[10:24:20.982]                 })
[10:24:20.982]             }))
[10:24:20.982]             future::FutureResult(value = ...future.value$value, 
[10:24:20.982]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:20.982]                   ...future.rng), globalenv = if (FALSE) 
[10:24:20.982]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:20.982]                     ...future.globalenv.names))
[10:24:20.982]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:20.982]         }, condition = base::local({
[10:24:20.982]             c <- base::c
[10:24:20.982]             inherits <- base::inherits
[10:24:20.982]             invokeRestart <- base::invokeRestart
[10:24:20.982]             length <- base::length
[10:24:20.982]             list <- base::list
[10:24:20.982]             seq.int <- base::seq.int
[10:24:20.982]             signalCondition <- base::signalCondition
[10:24:20.982]             sys.calls <- base::sys.calls
[10:24:20.982]             `[[` <- base::`[[`
[10:24:20.982]             `+` <- base::`+`
[10:24:20.982]             `<<-` <- base::`<<-`
[10:24:20.982]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:20.982]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:20.982]                   3L)]
[10:24:20.982]             }
[10:24:20.982]             function(cond) {
[10:24:20.982]                 is_error <- inherits(cond, "error")
[10:24:20.982]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:20.982]                   NULL)
[10:24:20.982]                 if (is_error) {
[10:24:20.982]                   sessionInformation <- function() {
[10:24:20.982]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:20.982]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:20.982]                       search = base::search(), system = base::Sys.info())
[10:24:20.982]                   }
[10:24:20.982]                   ...future.conditions[[length(...future.conditions) + 
[10:24:20.982]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:20.982]                     cond$call), session = sessionInformation(), 
[10:24:20.982]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:20.982]                   signalCondition(cond)
[10:24:20.982]                 }
[10:24:20.982]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:20.982]                 "immediateCondition"))) {
[10:24:20.982]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:20.982]                   ...future.conditions[[length(...future.conditions) + 
[10:24:20.982]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:20.982]                   if (TRUE && !signal) {
[10:24:20.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.982]                     {
[10:24:20.982]                       inherits <- base::inherits
[10:24:20.982]                       invokeRestart <- base::invokeRestart
[10:24:20.982]                       is.null <- base::is.null
[10:24:20.982]                       muffled <- FALSE
[10:24:20.982]                       if (inherits(cond, "message")) {
[10:24:20.982]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:20.982]                         if (muffled) 
[10:24:20.982]                           invokeRestart("muffleMessage")
[10:24:20.982]                       }
[10:24:20.982]                       else if (inherits(cond, "warning")) {
[10:24:20.982]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:20.982]                         if (muffled) 
[10:24:20.982]                           invokeRestart("muffleWarning")
[10:24:20.982]                       }
[10:24:20.982]                       else if (inherits(cond, "condition")) {
[10:24:20.982]                         if (!is.null(pattern)) {
[10:24:20.982]                           computeRestarts <- base::computeRestarts
[10:24:20.982]                           grepl <- base::grepl
[10:24:20.982]                           restarts <- computeRestarts(cond)
[10:24:20.982]                           for (restart in restarts) {
[10:24:20.982]                             name <- restart$name
[10:24:20.982]                             if (is.null(name)) 
[10:24:20.982]                               next
[10:24:20.982]                             if (!grepl(pattern, name)) 
[10:24:20.982]                               next
[10:24:20.982]                             invokeRestart(restart)
[10:24:20.982]                             muffled <- TRUE
[10:24:20.982]                             break
[10:24:20.982]                           }
[10:24:20.982]                         }
[10:24:20.982]                       }
[10:24:20.982]                       invisible(muffled)
[10:24:20.982]                     }
[10:24:20.982]                     muffleCondition(cond, pattern = "^muffle")
[10:24:20.982]                   }
[10:24:20.982]                 }
[10:24:20.982]                 else {
[10:24:20.982]                   if (TRUE) {
[10:24:20.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:20.982]                     {
[10:24:20.982]                       inherits <- base::inherits
[10:24:20.982]                       invokeRestart <- base::invokeRestart
[10:24:20.982]                       is.null <- base::is.null
[10:24:20.982]                       muffled <- FALSE
[10:24:20.982]                       if (inherits(cond, "message")) {
[10:24:20.982]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:20.982]                         if (muffled) 
[10:24:20.982]                           invokeRestart("muffleMessage")
[10:24:20.982]                       }
[10:24:20.982]                       else if (inherits(cond, "warning")) {
[10:24:20.982]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:20.982]                         if (muffled) 
[10:24:20.982]                           invokeRestart("muffleWarning")
[10:24:20.982]                       }
[10:24:20.982]                       else if (inherits(cond, "condition")) {
[10:24:20.982]                         if (!is.null(pattern)) {
[10:24:20.982]                           computeRestarts <- base::computeRestarts
[10:24:20.982]                           grepl <- base::grepl
[10:24:20.982]                           restarts <- computeRestarts(cond)
[10:24:20.982]                           for (restart in restarts) {
[10:24:20.982]                             name <- restart$name
[10:24:20.982]                             if (is.null(name)) 
[10:24:20.982]                               next
[10:24:20.982]                             if (!grepl(pattern, name)) 
[10:24:20.982]                               next
[10:24:20.982]                             invokeRestart(restart)
[10:24:20.982]                             muffled <- TRUE
[10:24:20.982]                             break
[10:24:20.982]                           }
[10:24:20.982]                         }
[10:24:20.982]                       }
[10:24:20.982]                       invisible(muffled)
[10:24:20.982]                     }
[10:24:20.982]                     muffleCondition(cond, pattern = "^muffle")
[10:24:20.982]                   }
[10:24:20.982]                 }
[10:24:20.982]             }
[10:24:20.982]         }))
[10:24:20.982]     }, error = function(ex) {
[10:24:20.982]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:20.982]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:20.982]                 ...future.rng), started = ...future.startTime, 
[10:24:20.982]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:20.982]             version = "1.8"), class = "FutureResult")
[10:24:20.982]     }, finally = {
[10:24:20.982]         if (!identical(...future.workdir, getwd())) 
[10:24:20.982]             setwd(...future.workdir)
[10:24:20.982]         {
[10:24:20.982]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:20.982]                 ...future.oldOptions$nwarnings <- NULL
[10:24:20.982]             }
[10:24:20.982]             base::options(...future.oldOptions)
[10:24:20.982]             if (.Platform$OS.type == "windows") {
[10:24:20.982]                 old_names <- names(...future.oldEnvVars)
[10:24:20.982]                 envs <- base::Sys.getenv()
[10:24:20.982]                 names <- names(envs)
[10:24:20.982]                 common <- intersect(names, old_names)
[10:24:20.982]                 added <- setdiff(names, old_names)
[10:24:20.982]                 removed <- setdiff(old_names, names)
[10:24:20.982]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:20.982]                   envs[common]]
[10:24:20.982]                 NAMES <- toupper(changed)
[10:24:20.982]                 args <- list()
[10:24:20.982]                 for (kk in seq_along(NAMES)) {
[10:24:20.982]                   name <- changed[[kk]]
[10:24:20.982]                   NAME <- NAMES[[kk]]
[10:24:20.982]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.982]                     next
[10:24:20.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:20.982]                 }
[10:24:20.982]                 NAMES <- toupper(added)
[10:24:20.982]                 for (kk in seq_along(NAMES)) {
[10:24:20.982]                   name <- added[[kk]]
[10:24:20.982]                   NAME <- NAMES[[kk]]
[10:24:20.982]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.982]                     next
[10:24:20.982]                   args[[name]] <- ""
[10:24:20.982]                 }
[10:24:20.982]                 NAMES <- toupper(removed)
[10:24:20.982]                 for (kk in seq_along(NAMES)) {
[10:24:20.982]                   name <- removed[[kk]]
[10:24:20.982]                   NAME <- NAMES[[kk]]
[10:24:20.982]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:20.982]                     next
[10:24:20.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:20.982]                 }
[10:24:20.982]                 if (length(args) > 0) 
[10:24:20.982]                   base::do.call(base::Sys.setenv, args = args)
[10:24:20.982]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:20.982]             }
[10:24:20.982]             else {
[10:24:20.982]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:20.982]             }
[10:24:20.982]             {
[10:24:20.982]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:20.982]                   0L) {
[10:24:20.982]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:20.982]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:20.982]                   base::options(opts)
[10:24:20.982]                 }
[10:24:20.982]                 {
[10:24:20.982]                   {
[10:24:20.982]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:20.982]                     NULL
[10:24:20.982]                   }
[10:24:20.982]                   options(future.plan = NULL)
[10:24:20.982]                   if (is.na(NA_character_)) 
[10:24:20.982]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:20.982]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:20.982]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:20.982]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:20.982]                     envir = parent.frame()) 
[10:24:20.982]                   {
[10:24:20.982]                     if (is.function(workers)) 
[10:24:20.982]                       workers <- workers()
[10:24:20.982]                     workers <- structure(as.integer(workers), 
[10:24:20.982]                       class = class(workers))
[10:24:20.982]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:20.982]                       workers >= 1)
[10:24:20.982]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:20.982]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:20.982]                     }
[10:24:20.982]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:20.982]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:20.982]                       envir = envir)
[10:24:20.982]                     if (!future$lazy) 
[10:24:20.982]                       future <- run(future)
[10:24:20.982]                     invisible(future)
[10:24:20.982]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:20.982]                 }
[10:24:20.982]             }
[10:24:20.982]         }
[10:24:20.982]     })
[10:24:20.982]     if (TRUE) {
[10:24:20.982]         base::sink(type = "output", split = FALSE)
[10:24:20.982]         if (TRUE) {
[10:24:20.982]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:20.982]         }
[10:24:20.982]         else {
[10:24:20.982]             ...future.result["stdout"] <- base::list(NULL)
[10:24:20.982]         }
[10:24:20.982]         base::close(...future.stdout)
[10:24:20.982]         ...future.stdout <- NULL
[10:24:20.982]     }
[10:24:20.982]     ...future.result$conditions <- ...future.conditions
[10:24:20.982]     ...future.result$finished <- base::Sys.time()
[10:24:20.982]     ...future.result
[10:24:20.982] }
[10:24:20.985] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[10:24:20.985] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:21.026] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:21.026] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[10:24:21.026] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[10:24:21.026] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:21.027] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:21.027] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:21.070] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:21.070] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:21.114] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:21.114] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:24:21.114] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.114] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[10:24:21.115] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[10:24:21.115] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:21.115] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.116] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:24:21.116] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:24:21.116] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:21.116] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.117] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:21.117] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.117] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[10:24:21.118] MultisessionFuture started
[10:24:21.118] - Launch lazy future ... done
[10:24:21.118] run() for ‘MultisessionFuture’ ... done
[10:24:21.118] Created future:
[10:24:21.118] MultisessionFuture:
[10:24:21.118] Label: ‘future_vapply-2’
[10:24:21.118] Expression:
[10:24:21.118] {
[10:24:21.118]     do.call(function(...) {
[10:24:21.118]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.118]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:21.118]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.118]             on.exit(options(oopts), add = TRUE)
[10:24:21.118]         }
[10:24:21.118]         {
[10:24:21.118]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:21.118]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.118]                 ...future.FUN(...future.X_jj, ...)
[10:24:21.118]             })
[10:24:21.118]         }
[10:24:21.118]     }, args = future.call.arguments)
[10:24:21.118] }
[10:24:21.118] Lazy evaluation: FALSE
[10:24:21.118] Asynchronous evaluation: TRUE
[10:24:21.118] Local evaluation: TRUE
[10:24:21.118] Environment: R_GlobalEnv
[10:24:21.118] Capture standard output: TRUE
[10:24:21.118] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:21.118] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:21.118] Packages: 1 packages (‘future.apply’)
[10:24:21.118] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:21.118] Resolved: FALSE
[10:24:21.118] Value: <not collected>
[10:24:21.118] Conditions captured: <none>
[10:24:21.118] Early signaling: FALSE
[10:24:21.118] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:21.118] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:21.130] Chunk #2 of 2 ... DONE
[10:24:21.130] Launching 2 futures (chunks) ... DONE
[10:24:21.130] Resolving 2 futures (chunks) ...
[10:24:21.131] resolve() on list ...
[10:24:21.131]  recursive: 0
[10:24:21.131]  length: 2
[10:24:21.131] 
[10:24:21.131] receiveMessageFromWorker() for ClusterFuture ...
[10:24:21.132] - Validating connection of MultisessionFuture
[10:24:21.132] - received message: FutureResult
[10:24:21.132] - Received FutureResult
[10:24:21.132] - Erased future from FutureRegistry
[10:24:21.132] result() for ClusterFuture ...
[10:24:21.132] - result already collected: FutureResult
[10:24:21.132] result() for ClusterFuture ... done
[10:24:21.132] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:21.132] Future #1
[10:24:21.133] result() for ClusterFuture ...
[10:24:21.133] - result already collected: FutureResult
[10:24:21.133] result() for ClusterFuture ... done
[10:24:21.133] result() for ClusterFuture ...
[10:24:21.133] - result already collected: FutureResult
[10:24:21.133] result() for ClusterFuture ... done
[10:24:21.133] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:21.133] - nx: 2
[10:24:21.133] - relay: TRUE
[10:24:21.133] - stdout: TRUE
[10:24:21.133] - signal: TRUE
[10:24:21.134] - resignal: FALSE
[10:24:21.134] - force: TRUE
[10:24:21.134] - relayed: [n=2] FALSE, FALSE
[10:24:21.134] - queued futures: [n=2] FALSE, FALSE
[10:24:21.134]  - until=1
[10:24:21.134]  - relaying element #1
[10:24:21.134] result() for ClusterFuture ...
[10:24:21.134] - result already collected: FutureResult
[10:24:21.134] result() for ClusterFuture ... done
[10:24:21.134] result() for ClusterFuture ...
[10:24:21.134] - result already collected: FutureResult
[10:24:21.135] result() for ClusterFuture ... done
[10:24:21.135] result() for ClusterFuture ...
[10:24:21.135] - result already collected: FutureResult
[10:24:21.135] result() for ClusterFuture ... done
[10:24:21.135] result() for ClusterFuture ...
[10:24:21.135] - result already collected: FutureResult
[10:24:21.135] result() for ClusterFuture ... done
[10:24:21.135] - relayed: [n=2] TRUE, FALSE
[10:24:21.135] - queued futures: [n=2] TRUE, FALSE
[10:24:21.135] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:21.136]  length: 1 (resolved future 1)
[10:24:21.167] receiveMessageFromWorker() for ClusterFuture ...
[10:24:21.167] - Validating connection of MultisessionFuture
[10:24:21.167] - received message: FutureResult
[10:24:21.167] - Received FutureResult
[10:24:21.167] - Erased future from FutureRegistry
[10:24:21.167] result() for ClusterFuture ...
[10:24:21.168] - result already collected: FutureResult
[10:24:21.168] result() for ClusterFuture ... done
[10:24:21.168] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:21.168] Future #2
[10:24:21.168] result() for ClusterFuture ...
[10:24:21.168] - result already collected: FutureResult
[10:24:21.168] result() for ClusterFuture ... done
[10:24:21.168] result() for ClusterFuture ...
[10:24:21.168] - result already collected: FutureResult
[10:24:21.168] result() for ClusterFuture ... done
[10:24:21.169] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:21.169] - nx: 2
[10:24:21.169] - relay: TRUE
[10:24:21.169] - stdout: TRUE
[10:24:21.169] - signal: TRUE
[10:24:21.169] - resignal: FALSE
[10:24:21.169] - force: TRUE
[10:24:21.169] - relayed: [n=2] TRUE, FALSE
[10:24:21.169] - queued futures: [n=2] TRUE, FALSE
[10:24:21.169]  - until=2
[10:24:21.169]  - relaying element #2
[10:24:21.170] result() for ClusterFuture ...
[10:24:21.170] - result already collected: FutureResult
[10:24:21.170] result() for ClusterFuture ... done
[10:24:21.170] result() for ClusterFuture ...
[10:24:21.170] - result already collected: FutureResult
[10:24:21.170] result() for ClusterFuture ... done
[10:24:21.170] result() for ClusterFuture ...
[10:24:21.170] - result already collected: FutureResult
[10:24:21.170] result() for ClusterFuture ... done
[10:24:21.170] result() for ClusterFuture ...
[10:24:21.170] - result already collected: FutureResult
[10:24:21.171] result() for ClusterFuture ... done
[10:24:21.171] - relayed: [n=2] TRUE, TRUE
[10:24:21.171] - queued futures: [n=2] TRUE, TRUE
[10:24:21.171] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:21.171]  length: 0 (resolved future 2)
[10:24:21.171] Relaying remaining futures
[10:24:21.171] signalConditionsASAP(NULL, pos=0) ...
[10:24:21.171] - nx: 2
[10:24:21.171] - relay: TRUE
[10:24:21.171] - stdout: TRUE
[10:24:21.171] - signal: TRUE
[10:24:21.172] - resignal: FALSE
[10:24:21.172] - force: TRUE
[10:24:21.172] - relayed: [n=2] TRUE, TRUE
[10:24:21.172] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:21.172] - relayed: [n=2] TRUE, TRUE
[10:24:21.172] - queued futures: [n=2] TRUE, TRUE
[10:24:21.172] signalConditionsASAP(NULL, pos=0) ... done
[10:24:21.172] resolve() on list ... DONE
[10:24:21.172] result() for ClusterFuture ...
[10:24:21.172] - result already collected: FutureResult
[10:24:21.172] result() for ClusterFuture ... done
[10:24:21.173] result() for ClusterFuture ...
[10:24:21.173] - result already collected: FutureResult
[10:24:21.173] result() for ClusterFuture ... done
[10:24:21.173] result() for ClusterFuture ...
[10:24:21.173] - result already collected: FutureResult
[10:24:21.173] result() for ClusterFuture ... done
[10:24:21.173] result() for ClusterFuture ...
[10:24:21.173] - result already collected: FutureResult
[10:24:21.173] result() for ClusterFuture ... done
[10:24:21.173]  - Number of value chunks collected: 2
[10:24:21.174] Resolving 2 futures (chunks) ... DONE
[10:24:21.174] Reducing values from 2 chunks ...
[10:24:21.174]  - Number of values collected after concatenation: 10
[10:24:21.174]  - Number of values expected: 10
[10:24:21.174] Reducing values from 2 chunks ... DONE
[10:24:21.174] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[10:24:21.175] future_lapply() ...
[10:24:21.180] Number of chunks: 2
[10:24:21.180] getGlobalsAndPackagesXApply() ...
[10:24:21.181]  - future.globals: TRUE
[10:24:21.181] getGlobalsAndPackages() ...
[10:24:21.181] Searching for globals...
[10:24:21.184] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:21.184] Searching for globals ... DONE
[10:24:21.184] Resolving globals: FALSE
[10:24:21.185] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[10:24:21.185] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:21.186] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:21.186] - packages: [1] ‘future.apply’
[10:24:21.186] getGlobalsAndPackages() ... DONE
[10:24:21.186]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:21.186]  - needed namespaces: [n=1] ‘future.apply’
[10:24:21.186] Finding globals ... DONE
[10:24:21.186]  - use_args: TRUE
[10:24:21.186]  - Getting '...' globals ...
[10:24:21.187] resolve() on list ...
[10:24:21.187]  recursive: 0
[10:24:21.187]  length: 1
[10:24:21.187]  elements: ‘...’
[10:24:21.187]  length: 0 (resolved future 1)
[10:24:21.187] resolve() on list ... DONE
[10:24:21.187]    - '...' content: [n=0] 
[10:24:21.187] List of 1
[10:24:21.187]  $ ...: list()
[10:24:21.187]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:21.187]  - attr(*, "where")=List of 1
[10:24:21.187]   ..$ ...:<environment: 0x55b93e8a8c50> 
[10:24:21.187]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:21.187]  - attr(*, "resolved")= logi TRUE
[10:24:21.187]  - attr(*, "total_size")= num NA
[10:24:21.190]  - Getting '...' globals ... DONE
[10:24:21.190] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:21.190] List of 8
[10:24:21.190]  $ ...future.FUN:function (x, ...)  
[10:24:21.190]  $ x_FUN        :function (x)  
[10:24:21.190]  $ times        : int 1
[10:24:21.190]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:21.190]  $ stop_if_not  :function (...)  
[10:24:21.190]  $ dim          : NULL
[10:24:21.190]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:21.190]  $ ...          : list()
[10:24:21.190]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:21.190]  - attr(*, "where")=List of 8
[10:24:21.190]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:21.190]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:21.190]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:21.190]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:21.190]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:21.190]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:21.190]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:21.190]   ..$ ...          :<environment: 0x55b93e8a8c50> 
[10:24:21.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:21.190]  - attr(*, "resolved")= logi FALSE
[10:24:21.190]  - attr(*, "total_size")= num 94336
[10:24:21.198] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:21.198] getGlobalsAndPackagesXApply() ... DONE
[10:24:21.198] Number of futures (= number of chunks): 2
[10:24:21.198] Launching 2 futures (chunks) ...
[10:24:21.198] Chunk #1 of 2 ...
[10:24:21.199]  - Finding globals in 'X' for chunk #1 ...
[10:24:21.199] getGlobalsAndPackages() ...
[10:24:21.199] Searching for globals...
[10:24:21.199] 
[10:24:21.199] Searching for globals ... DONE
[10:24:21.199] - globals: [0] <none>
[10:24:21.199] getGlobalsAndPackages() ... DONE
[10:24:21.199]    + additional globals found: [n=0] 
[10:24:21.199]    + additional namespaces needed: [n=0] 
[10:24:21.200]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:21.200]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:21.200]  - seeds: <none>
[10:24:21.200]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.200] getGlobalsAndPackages() ...
[10:24:21.200] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.200] Resolving globals: FALSE
[10:24:21.200] Tweak future expression to call with '...' arguments ...
[10:24:21.200] {
[10:24:21.200]     do.call(function(...) {
[10:24:21.200]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.200]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:21.200]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.200]             on.exit(options(oopts), add = TRUE)
[10:24:21.200]         }
[10:24:21.200]         {
[10:24:21.200]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:21.200]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.200]                 ...future.FUN(...future.X_jj, ...)
[10:24:21.200]             })
[10:24:21.200]         }
[10:24:21.200]     }, args = future.call.arguments)
[10:24:21.200] }
[10:24:21.201] Tweak future expression to call with '...' arguments ... DONE
[10:24:21.201] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.201] - packages: [1] ‘future.apply’
[10:24:21.201] getGlobalsAndPackages() ... DONE
[10:24:21.202] run() for ‘Future’ ...
[10:24:21.202] - state: ‘created’
[10:24:21.202] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:21.216] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:21.216] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:21.216]   - Field: ‘node’
[10:24:21.216]   - Field: ‘label’
[10:24:21.216]   - Field: ‘local’
[10:24:21.216]   - Field: ‘owner’
[10:24:21.217]   - Field: ‘envir’
[10:24:21.217]   - Field: ‘workers’
[10:24:21.217]   - Field: ‘packages’
[10:24:21.217]   - Field: ‘gc’
[10:24:21.217]   - Field: ‘conditions’
[10:24:21.217]   - Field: ‘persistent’
[10:24:21.217]   - Field: ‘expr’
[10:24:21.217]   - Field: ‘uuid’
[10:24:21.218]   - Field: ‘seed’
[10:24:21.218]   - Field: ‘version’
[10:24:21.218]   - Field: ‘result’
[10:24:21.218]   - Field: ‘asynchronous’
[10:24:21.218]   - Field: ‘calls’
[10:24:21.218]   - Field: ‘globals’
[10:24:21.218]   - Field: ‘stdout’
[10:24:21.218]   - Field: ‘earlySignal’
[10:24:21.218]   - Field: ‘lazy’
[10:24:21.218]   - Field: ‘state’
[10:24:21.218] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:21.219] - Launch lazy future ...
[10:24:21.219] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:21.219] Packages needed by future strategies (n = 0): <none>
[10:24:21.219] {
[10:24:21.219]     {
[10:24:21.219]         {
[10:24:21.219]             ...future.startTime <- base::Sys.time()
[10:24:21.219]             {
[10:24:21.219]                 {
[10:24:21.219]                   {
[10:24:21.219]                     {
[10:24:21.219]                       {
[10:24:21.219]                         base::local({
[10:24:21.219]                           has_future <- base::requireNamespace("future", 
[10:24:21.219]                             quietly = TRUE)
[10:24:21.219]                           if (has_future) {
[10:24:21.219]                             ns <- base::getNamespace("future")
[10:24:21.219]                             version <- ns[[".package"]][["version"]]
[10:24:21.219]                             if (is.null(version)) 
[10:24:21.219]                               version <- utils::packageVersion("future")
[10:24:21.219]                           }
[10:24:21.219]                           else {
[10:24:21.219]                             version <- NULL
[10:24:21.219]                           }
[10:24:21.219]                           if (!has_future || version < "1.8.0") {
[10:24:21.219]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:21.219]                               "", base::R.version$version.string), 
[10:24:21.219]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:21.219]                                 base::R.version$platform, 8 * 
[10:24:21.219]                                   base::.Machine$sizeof.pointer), 
[10:24:21.219]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:21.219]                                 "release", "version")], collapse = " "), 
[10:24:21.219]                               hostname = base::Sys.info()[["nodename"]])
[10:24:21.219]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:21.219]                               info)
[10:24:21.219]                             info <- base::paste(info, collapse = "; ")
[10:24:21.219]                             if (!has_future) {
[10:24:21.219]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:21.219]                                 info)
[10:24:21.219]                             }
[10:24:21.219]                             else {
[10:24:21.219]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:21.219]                                 info, version)
[10:24:21.219]                             }
[10:24:21.219]                             base::stop(msg)
[10:24:21.219]                           }
[10:24:21.219]                         })
[10:24:21.219]                       }
[10:24:21.219]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:21.219]                       base::options(mc.cores = 1L)
[10:24:21.219]                     }
[10:24:21.219]                     base::local({
[10:24:21.219]                       for (pkg in "future.apply") {
[10:24:21.219]                         base::loadNamespace(pkg)
[10:24:21.219]                         base::library(pkg, character.only = TRUE)
[10:24:21.219]                       }
[10:24:21.219]                     })
[10:24:21.219]                   }
[10:24:21.219]                   options(future.plan = NULL)
[10:24:21.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:21.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:21.219]                 }
[10:24:21.219]                 ...future.workdir <- getwd()
[10:24:21.219]             }
[10:24:21.219]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:21.219]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:21.219]         }
[10:24:21.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:21.219]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:21.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:21.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:21.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:21.219]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:21.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:21.219]             base::names(...future.oldOptions))
[10:24:21.219]     }
[10:24:21.219]     if (FALSE) {
[10:24:21.219]     }
[10:24:21.219]     else {
[10:24:21.219]         if (TRUE) {
[10:24:21.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:21.219]                 open = "w")
[10:24:21.219]         }
[10:24:21.219]         else {
[10:24:21.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:21.219]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:21.219]         }
[10:24:21.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:21.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:21.219]             base::sink(type = "output", split = FALSE)
[10:24:21.219]             base::close(...future.stdout)
[10:24:21.219]         }, add = TRUE)
[10:24:21.219]     }
[10:24:21.219]     ...future.frame <- base::sys.nframe()
[10:24:21.219]     ...future.conditions <- base::list()
[10:24:21.219]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:21.219]     if (FALSE) {
[10:24:21.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:21.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:21.219]     }
[10:24:21.219]     ...future.result <- base::tryCatch({
[10:24:21.219]         base::withCallingHandlers({
[10:24:21.219]             ...future.value <- base::withVisible(base::local({
[10:24:21.219]                 ...future.makeSendCondition <- base::local({
[10:24:21.219]                   sendCondition <- NULL
[10:24:21.219]                   function(frame = 1L) {
[10:24:21.219]                     if (is.function(sendCondition)) 
[10:24:21.219]                       return(sendCondition)
[10:24:21.219]                     ns <- getNamespace("parallel")
[10:24:21.219]                     if (exists("sendData", mode = "function", 
[10:24:21.219]                       envir = ns)) {
[10:24:21.219]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:21.219]                         envir = ns)
[10:24:21.219]                       envir <- sys.frame(frame)
[10:24:21.219]                       master <- NULL
[10:24:21.219]                       while (!identical(envir, .GlobalEnv) && 
[10:24:21.219]                         !identical(envir, emptyenv())) {
[10:24:21.219]                         if (exists("master", mode = "list", envir = envir, 
[10:24:21.219]                           inherits = FALSE)) {
[10:24:21.219]                           master <- get("master", mode = "list", 
[10:24:21.219]                             envir = envir, inherits = FALSE)
[10:24:21.219]                           if (inherits(master, c("SOCKnode", 
[10:24:21.219]                             "SOCK0node"))) {
[10:24:21.219]                             sendCondition <<- function(cond) {
[10:24:21.219]                               data <- list(type = "VALUE", value = cond, 
[10:24:21.219]                                 success = TRUE)
[10:24:21.219]                               parallel_sendData(master, data)
[10:24:21.219]                             }
[10:24:21.219]                             return(sendCondition)
[10:24:21.219]                           }
[10:24:21.219]                         }
[10:24:21.219]                         frame <- frame + 1L
[10:24:21.219]                         envir <- sys.frame(frame)
[10:24:21.219]                       }
[10:24:21.219]                     }
[10:24:21.219]                     sendCondition <<- function(cond) NULL
[10:24:21.219]                   }
[10:24:21.219]                 })
[10:24:21.219]                 withCallingHandlers({
[10:24:21.219]                   {
[10:24:21.219]                     do.call(function(...) {
[10:24:21.219]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.219]                       if (!identical(...future.globals.maxSize.org, 
[10:24:21.219]                         ...future.globals.maxSize)) {
[10:24:21.219]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.219]                         on.exit(options(oopts), add = TRUE)
[10:24:21.219]                       }
[10:24:21.219]                       {
[10:24:21.219]                         lapply(seq_along(...future.elements_ii), 
[10:24:21.219]                           FUN = function(jj) {
[10:24:21.219]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.219]                             ...future.FUN(...future.X_jj, ...)
[10:24:21.219]                           })
[10:24:21.219]                       }
[10:24:21.219]                     }, args = future.call.arguments)
[10:24:21.219]                   }
[10:24:21.219]                 }, immediateCondition = function(cond) {
[10:24:21.219]                   sendCondition <- ...future.makeSendCondition()
[10:24:21.219]                   sendCondition(cond)
[10:24:21.219]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.219]                   {
[10:24:21.219]                     inherits <- base::inherits
[10:24:21.219]                     invokeRestart <- base::invokeRestart
[10:24:21.219]                     is.null <- base::is.null
[10:24:21.219]                     muffled <- FALSE
[10:24:21.219]                     if (inherits(cond, "message")) {
[10:24:21.219]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:21.219]                       if (muffled) 
[10:24:21.219]                         invokeRestart("muffleMessage")
[10:24:21.219]                     }
[10:24:21.219]                     else if (inherits(cond, "warning")) {
[10:24:21.219]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:21.219]                       if (muffled) 
[10:24:21.219]                         invokeRestart("muffleWarning")
[10:24:21.219]                     }
[10:24:21.219]                     else if (inherits(cond, "condition")) {
[10:24:21.219]                       if (!is.null(pattern)) {
[10:24:21.219]                         computeRestarts <- base::computeRestarts
[10:24:21.219]                         grepl <- base::grepl
[10:24:21.219]                         restarts <- computeRestarts(cond)
[10:24:21.219]                         for (restart in restarts) {
[10:24:21.219]                           name <- restart$name
[10:24:21.219]                           if (is.null(name)) 
[10:24:21.219]                             next
[10:24:21.219]                           if (!grepl(pattern, name)) 
[10:24:21.219]                             next
[10:24:21.219]                           invokeRestart(restart)
[10:24:21.219]                           muffled <- TRUE
[10:24:21.219]                           break
[10:24:21.219]                         }
[10:24:21.219]                       }
[10:24:21.219]                     }
[10:24:21.219]                     invisible(muffled)
[10:24:21.219]                   }
[10:24:21.219]                   muffleCondition(cond)
[10:24:21.219]                 })
[10:24:21.219]             }))
[10:24:21.219]             future::FutureResult(value = ...future.value$value, 
[10:24:21.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:21.219]                   ...future.rng), globalenv = if (FALSE) 
[10:24:21.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:21.219]                     ...future.globalenv.names))
[10:24:21.219]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:21.219]         }, condition = base::local({
[10:24:21.219]             c <- base::c
[10:24:21.219]             inherits <- base::inherits
[10:24:21.219]             invokeRestart <- base::invokeRestart
[10:24:21.219]             length <- base::length
[10:24:21.219]             list <- base::list
[10:24:21.219]             seq.int <- base::seq.int
[10:24:21.219]             signalCondition <- base::signalCondition
[10:24:21.219]             sys.calls <- base::sys.calls
[10:24:21.219]             `[[` <- base::`[[`
[10:24:21.219]             `+` <- base::`+`
[10:24:21.219]             `<<-` <- base::`<<-`
[10:24:21.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:21.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:21.219]                   3L)]
[10:24:21.219]             }
[10:24:21.219]             function(cond) {
[10:24:21.219]                 is_error <- inherits(cond, "error")
[10:24:21.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:21.219]                   NULL)
[10:24:21.219]                 if (is_error) {
[10:24:21.219]                   sessionInformation <- function() {
[10:24:21.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:21.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:21.219]                       search = base::search(), system = base::Sys.info())
[10:24:21.219]                   }
[10:24:21.219]                   ...future.conditions[[length(...future.conditions) + 
[10:24:21.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:21.219]                     cond$call), session = sessionInformation(), 
[10:24:21.219]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:21.219]                   signalCondition(cond)
[10:24:21.219]                 }
[10:24:21.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:21.219]                 "immediateCondition"))) {
[10:24:21.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:21.219]                   ...future.conditions[[length(...future.conditions) + 
[10:24:21.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:21.219]                   if (TRUE && !signal) {
[10:24:21.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.219]                     {
[10:24:21.219]                       inherits <- base::inherits
[10:24:21.219]                       invokeRestart <- base::invokeRestart
[10:24:21.219]                       is.null <- base::is.null
[10:24:21.219]                       muffled <- FALSE
[10:24:21.219]                       if (inherits(cond, "message")) {
[10:24:21.219]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:21.219]                         if (muffled) 
[10:24:21.219]                           invokeRestart("muffleMessage")
[10:24:21.219]                       }
[10:24:21.219]                       else if (inherits(cond, "warning")) {
[10:24:21.219]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:21.219]                         if (muffled) 
[10:24:21.219]                           invokeRestart("muffleWarning")
[10:24:21.219]                       }
[10:24:21.219]                       else if (inherits(cond, "condition")) {
[10:24:21.219]                         if (!is.null(pattern)) {
[10:24:21.219]                           computeRestarts <- base::computeRestarts
[10:24:21.219]                           grepl <- base::grepl
[10:24:21.219]                           restarts <- computeRestarts(cond)
[10:24:21.219]                           for (restart in restarts) {
[10:24:21.219]                             name <- restart$name
[10:24:21.219]                             if (is.null(name)) 
[10:24:21.219]                               next
[10:24:21.219]                             if (!grepl(pattern, name)) 
[10:24:21.219]                               next
[10:24:21.219]                             invokeRestart(restart)
[10:24:21.219]                             muffled <- TRUE
[10:24:21.219]                             break
[10:24:21.219]                           }
[10:24:21.219]                         }
[10:24:21.219]                       }
[10:24:21.219]                       invisible(muffled)
[10:24:21.219]                     }
[10:24:21.219]                     muffleCondition(cond, pattern = "^muffle")
[10:24:21.219]                   }
[10:24:21.219]                 }
[10:24:21.219]                 else {
[10:24:21.219]                   if (TRUE) {
[10:24:21.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.219]                     {
[10:24:21.219]                       inherits <- base::inherits
[10:24:21.219]                       invokeRestart <- base::invokeRestart
[10:24:21.219]                       is.null <- base::is.null
[10:24:21.219]                       muffled <- FALSE
[10:24:21.219]                       if (inherits(cond, "message")) {
[10:24:21.219]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:21.219]                         if (muffled) 
[10:24:21.219]                           invokeRestart("muffleMessage")
[10:24:21.219]                       }
[10:24:21.219]                       else if (inherits(cond, "warning")) {
[10:24:21.219]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:21.219]                         if (muffled) 
[10:24:21.219]                           invokeRestart("muffleWarning")
[10:24:21.219]                       }
[10:24:21.219]                       else if (inherits(cond, "condition")) {
[10:24:21.219]                         if (!is.null(pattern)) {
[10:24:21.219]                           computeRestarts <- base::computeRestarts
[10:24:21.219]                           grepl <- base::grepl
[10:24:21.219]                           restarts <- computeRestarts(cond)
[10:24:21.219]                           for (restart in restarts) {
[10:24:21.219]                             name <- restart$name
[10:24:21.219]                             if (is.null(name)) 
[10:24:21.219]                               next
[10:24:21.219]                             if (!grepl(pattern, name)) 
[10:24:21.219]                               next
[10:24:21.219]                             invokeRestart(restart)
[10:24:21.219]                             muffled <- TRUE
[10:24:21.219]                             break
[10:24:21.219]                           }
[10:24:21.219]                         }
[10:24:21.219]                       }
[10:24:21.219]                       invisible(muffled)
[10:24:21.219]                     }
[10:24:21.219]                     muffleCondition(cond, pattern = "^muffle")
[10:24:21.219]                   }
[10:24:21.219]                 }
[10:24:21.219]             }
[10:24:21.219]         }))
[10:24:21.219]     }, error = function(ex) {
[10:24:21.219]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:21.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:21.219]                 ...future.rng), started = ...future.startTime, 
[10:24:21.219]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:21.219]             version = "1.8"), class = "FutureResult")
[10:24:21.219]     }, finally = {
[10:24:21.219]         if (!identical(...future.workdir, getwd())) 
[10:24:21.219]             setwd(...future.workdir)
[10:24:21.219]         {
[10:24:21.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:21.219]                 ...future.oldOptions$nwarnings <- NULL
[10:24:21.219]             }
[10:24:21.219]             base::options(...future.oldOptions)
[10:24:21.219]             if (.Platform$OS.type == "windows") {
[10:24:21.219]                 old_names <- names(...future.oldEnvVars)
[10:24:21.219]                 envs <- base::Sys.getenv()
[10:24:21.219]                 names <- names(envs)
[10:24:21.219]                 common <- intersect(names, old_names)
[10:24:21.219]                 added <- setdiff(names, old_names)
[10:24:21.219]                 removed <- setdiff(old_names, names)
[10:24:21.219]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:21.219]                   envs[common]]
[10:24:21.219]                 NAMES <- toupper(changed)
[10:24:21.219]                 args <- list()
[10:24:21.219]                 for (kk in seq_along(NAMES)) {
[10:24:21.219]                   name <- changed[[kk]]
[10:24:21.219]                   NAME <- NAMES[[kk]]
[10:24:21.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.219]                     next
[10:24:21.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:21.219]                 }
[10:24:21.219]                 NAMES <- toupper(added)
[10:24:21.219]                 for (kk in seq_along(NAMES)) {
[10:24:21.219]                   name <- added[[kk]]
[10:24:21.219]                   NAME <- NAMES[[kk]]
[10:24:21.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.219]                     next
[10:24:21.219]                   args[[name]] <- ""
[10:24:21.219]                 }
[10:24:21.219]                 NAMES <- toupper(removed)
[10:24:21.219]                 for (kk in seq_along(NAMES)) {
[10:24:21.219]                   name <- removed[[kk]]
[10:24:21.219]                   NAME <- NAMES[[kk]]
[10:24:21.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.219]                     next
[10:24:21.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:21.219]                 }
[10:24:21.219]                 if (length(args) > 0) 
[10:24:21.219]                   base::do.call(base::Sys.setenv, args = args)
[10:24:21.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:21.219]             }
[10:24:21.219]             else {
[10:24:21.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:21.219]             }
[10:24:21.219]             {
[10:24:21.219]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:21.219]                   0L) {
[10:24:21.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:21.219]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:21.219]                   base::options(opts)
[10:24:21.219]                 }
[10:24:21.219]                 {
[10:24:21.219]                   {
[10:24:21.219]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:21.219]                     NULL
[10:24:21.219]                   }
[10:24:21.219]                   options(future.plan = NULL)
[10:24:21.219]                   if (is.na(NA_character_)) 
[10:24:21.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:21.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:21.219]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:21.219]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:21.219]                     envir = parent.frame()) 
[10:24:21.219]                   {
[10:24:21.219]                     if (is.function(workers)) 
[10:24:21.219]                       workers <- workers()
[10:24:21.219]                     workers <- structure(as.integer(workers), 
[10:24:21.219]                       class = class(workers))
[10:24:21.219]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:21.219]                       workers >= 1)
[10:24:21.219]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:21.219]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:21.219]                     }
[10:24:21.219]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:21.219]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:21.219]                       envir = envir)
[10:24:21.219]                     if (!future$lazy) 
[10:24:21.219]                       future <- run(future)
[10:24:21.219]                     invisible(future)
[10:24:21.219]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:21.219]                 }
[10:24:21.219]             }
[10:24:21.219]         }
[10:24:21.219]     })
[10:24:21.219]     if (TRUE) {
[10:24:21.219]         base::sink(type = "output", split = FALSE)
[10:24:21.219]         if (TRUE) {
[10:24:21.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:21.219]         }
[10:24:21.219]         else {
[10:24:21.219]             ...future.result["stdout"] <- base::list(NULL)
[10:24:21.219]         }
[10:24:21.219]         base::close(...future.stdout)
[10:24:21.219]         ...future.stdout <- NULL
[10:24:21.219]     }
[10:24:21.219]     ...future.result$conditions <- ...future.conditions
[10:24:21.219]     ...future.result$finished <- base::Sys.time()
[10:24:21.219]     ...future.result
[10:24:21.219] }
[10:24:21.222] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[10:24:21.222] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:21.266] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:21.266] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[10:24:21.266] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[10:24:21.267] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:21.267] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:21.267] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:21.310] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:21.310] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:21.354] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:21.354] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:24:21.354] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:24:21.355] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:24:21.355] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:24:21.355] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:21.356] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:21.356] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:24:21.356] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:24:21.356] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:21.357] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:21.357] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:21.357] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:21.357] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[10:24:21.358] MultisessionFuture started
[10:24:21.358] - Launch lazy future ... done
[10:24:21.358] run() for ‘MultisessionFuture’ ... done
[10:24:21.358] Created future:
[10:24:21.358] MultisessionFuture:
[10:24:21.358] Label: ‘future_vapply-1’
[10:24:21.358] Expression:
[10:24:21.358] {
[10:24:21.358]     do.call(function(...) {
[10:24:21.358]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.358]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:21.358]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.358]             on.exit(options(oopts), add = TRUE)
[10:24:21.358]         }
[10:24:21.358]         {
[10:24:21.358]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:21.358]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.358]                 ...future.FUN(...future.X_jj, ...)
[10:24:21.358]             })
[10:24:21.358]         }
[10:24:21.358]     }, args = future.call.arguments)
[10:24:21.358] }
[10:24:21.358] Lazy evaluation: FALSE
[10:24:21.358] Asynchronous evaluation: TRUE
[10:24:21.358] Local evaluation: TRUE
[10:24:21.358] Environment: R_GlobalEnv
[10:24:21.358] Capture standard output: TRUE
[10:24:21.358] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:21.358] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:21.358] Packages: 1 packages (‘future.apply’)
[10:24:21.358] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:21.358] Resolved: FALSE
[10:24:21.358] Value: <not collected>
[10:24:21.358] Conditions captured: <none>
[10:24:21.358] Early signaling: FALSE
[10:24:21.358] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:21.358] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:21.370] Chunk #1 of 2 ... DONE
[10:24:21.370] Chunk #2 of 2 ...
[10:24:21.371]  - Finding globals in 'X' for chunk #2 ...
[10:24:21.371] getGlobalsAndPackages() ...
[10:24:21.371] Searching for globals...
[10:24:21.371] 
[10:24:21.371] Searching for globals ... DONE
[10:24:21.372] - globals: [0] <none>
[10:24:21.372] getGlobalsAndPackages() ... DONE
[10:24:21.372]    + additional globals found: [n=0] 
[10:24:21.372]    + additional namespaces needed: [n=0] 
[10:24:21.372]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:21.372]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:21.373]  - seeds: <none>
[10:24:21.373]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.373] getGlobalsAndPackages() ...
[10:24:21.373] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.373] Resolving globals: FALSE
[10:24:21.374] Tweak future expression to call with '...' arguments ...
[10:24:21.374] {
[10:24:21.374]     do.call(function(...) {
[10:24:21.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:21.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.374]             on.exit(options(oopts), add = TRUE)
[10:24:21.374]         }
[10:24:21.374]         {
[10:24:21.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:21.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.374]                 ...future.FUN(...future.X_jj, ...)
[10:24:21.374]             })
[10:24:21.374]         }
[10:24:21.374]     }, args = future.call.arguments)
[10:24:21.374] }
[10:24:21.374] Tweak future expression to call with '...' arguments ... DONE
[10:24:21.375] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.375] - packages: [1] ‘future.apply’
[10:24:21.376] getGlobalsAndPackages() ... DONE
[10:24:21.376] run() for ‘Future’ ...
[10:24:21.376] - state: ‘created’
[10:24:21.377] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:21.394] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:21.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:21.394]   - Field: ‘node’
[10:24:21.395]   - Field: ‘label’
[10:24:21.395]   - Field: ‘local’
[10:24:21.395]   - Field: ‘owner’
[10:24:21.395]   - Field: ‘envir’
[10:24:21.395]   - Field: ‘workers’
[10:24:21.396]   - Field: ‘packages’
[10:24:21.396]   - Field: ‘gc’
[10:24:21.396]   - Field: ‘conditions’
[10:24:21.396]   - Field: ‘persistent’
[10:24:21.396]   - Field: ‘expr’
[10:24:21.396]   - Field: ‘uuid’
[10:24:21.397]   - Field: ‘seed’
[10:24:21.397]   - Field: ‘version’
[10:24:21.397]   - Field: ‘result’
[10:24:21.397]   - Field: ‘asynchronous’
[10:24:21.397]   - Field: ‘calls’
[10:24:21.397]   - Field: ‘globals’
[10:24:21.398]   - Field: ‘stdout’
[10:24:21.398]   - Field: ‘earlySignal’
[10:24:21.398]   - Field: ‘lazy’
[10:24:21.398]   - Field: ‘state’
[10:24:21.398] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:21.398] - Launch lazy future ...
[10:24:21.399] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:21.399] Packages needed by future strategies (n = 0): <none>
[10:24:21.400] {
[10:24:21.400]     {
[10:24:21.400]         {
[10:24:21.400]             ...future.startTime <- base::Sys.time()
[10:24:21.400]             {
[10:24:21.400]                 {
[10:24:21.400]                   {
[10:24:21.400]                     {
[10:24:21.400]                       {
[10:24:21.400]                         base::local({
[10:24:21.400]                           has_future <- base::requireNamespace("future", 
[10:24:21.400]                             quietly = TRUE)
[10:24:21.400]                           if (has_future) {
[10:24:21.400]                             ns <- base::getNamespace("future")
[10:24:21.400]                             version <- ns[[".package"]][["version"]]
[10:24:21.400]                             if (is.null(version)) 
[10:24:21.400]                               version <- utils::packageVersion("future")
[10:24:21.400]                           }
[10:24:21.400]                           else {
[10:24:21.400]                             version <- NULL
[10:24:21.400]                           }
[10:24:21.400]                           if (!has_future || version < "1.8.0") {
[10:24:21.400]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:21.400]                               "", base::R.version$version.string), 
[10:24:21.400]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:21.400]                                 base::R.version$platform, 8 * 
[10:24:21.400]                                   base::.Machine$sizeof.pointer), 
[10:24:21.400]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:21.400]                                 "release", "version")], collapse = " "), 
[10:24:21.400]                               hostname = base::Sys.info()[["nodename"]])
[10:24:21.400]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:21.400]                               info)
[10:24:21.400]                             info <- base::paste(info, collapse = "; ")
[10:24:21.400]                             if (!has_future) {
[10:24:21.400]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:21.400]                                 info)
[10:24:21.400]                             }
[10:24:21.400]                             else {
[10:24:21.400]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:21.400]                                 info, version)
[10:24:21.400]                             }
[10:24:21.400]                             base::stop(msg)
[10:24:21.400]                           }
[10:24:21.400]                         })
[10:24:21.400]                       }
[10:24:21.400]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:21.400]                       base::options(mc.cores = 1L)
[10:24:21.400]                     }
[10:24:21.400]                     base::local({
[10:24:21.400]                       for (pkg in "future.apply") {
[10:24:21.400]                         base::loadNamespace(pkg)
[10:24:21.400]                         base::library(pkg, character.only = TRUE)
[10:24:21.400]                       }
[10:24:21.400]                     })
[10:24:21.400]                   }
[10:24:21.400]                   options(future.plan = NULL)
[10:24:21.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:21.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:21.400]                 }
[10:24:21.400]                 ...future.workdir <- getwd()
[10:24:21.400]             }
[10:24:21.400]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:21.400]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:21.400]         }
[10:24:21.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:21.400]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:21.400]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:21.400]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:21.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:21.400]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:21.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:21.400]             base::names(...future.oldOptions))
[10:24:21.400]     }
[10:24:21.400]     if (FALSE) {
[10:24:21.400]     }
[10:24:21.400]     else {
[10:24:21.400]         if (TRUE) {
[10:24:21.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:21.400]                 open = "w")
[10:24:21.400]         }
[10:24:21.400]         else {
[10:24:21.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:21.400]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:21.400]         }
[10:24:21.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:21.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:21.400]             base::sink(type = "output", split = FALSE)
[10:24:21.400]             base::close(...future.stdout)
[10:24:21.400]         }, add = TRUE)
[10:24:21.400]     }
[10:24:21.400]     ...future.frame <- base::sys.nframe()
[10:24:21.400]     ...future.conditions <- base::list()
[10:24:21.400]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:21.400]     if (FALSE) {
[10:24:21.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:21.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:21.400]     }
[10:24:21.400]     ...future.result <- base::tryCatch({
[10:24:21.400]         base::withCallingHandlers({
[10:24:21.400]             ...future.value <- base::withVisible(base::local({
[10:24:21.400]                 ...future.makeSendCondition <- base::local({
[10:24:21.400]                   sendCondition <- NULL
[10:24:21.400]                   function(frame = 1L) {
[10:24:21.400]                     if (is.function(sendCondition)) 
[10:24:21.400]                       return(sendCondition)
[10:24:21.400]                     ns <- getNamespace("parallel")
[10:24:21.400]                     if (exists("sendData", mode = "function", 
[10:24:21.400]                       envir = ns)) {
[10:24:21.400]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:21.400]                         envir = ns)
[10:24:21.400]                       envir <- sys.frame(frame)
[10:24:21.400]                       master <- NULL
[10:24:21.400]                       while (!identical(envir, .GlobalEnv) && 
[10:24:21.400]                         !identical(envir, emptyenv())) {
[10:24:21.400]                         if (exists("master", mode = "list", envir = envir, 
[10:24:21.400]                           inherits = FALSE)) {
[10:24:21.400]                           master <- get("master", mode = "list", 
[10:24:21.400]                             envir = envir, inherits = FALSE)
[10:24:21.400]                           if (inherits(master, c("SOCKnode", 
[10:24:21.400]                             "SOCK0node"))) {
[10:24:21.400]                             sendCondition <<- function(cond) {
[10:24:21.400]                               data <- list(type = "VALUE", value = cond, 
[10:24:21.400]                                 success = TRUE)
[10:24:21.400]                               parallel_sendData(master, data)
[10:24:21.400]                             }
[10:24:21.400]                             return(sendCondition)
[10:24:21.400]                           }
[10:24:21.400]                         }
[10:24:21.400]                         frame <- frame + 1L
[10:24:21.400]                         envir <- sys.frame(frame)
[10:24:21.400]                       }
[10:24:21.400]                     }
[10:24:21.400]                     sendCondition <<- function(cond) NULL
[10:24:21.400]                   }
[10:24:21.400]                 })
[10:24:21.400]                 withCallingHandlers({
[10:24:21.400]                   {
[10:24:21.400]                     do.call(function(...) {
[10:24:21.400]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.400]                       if (!identical(...future.globals.maxSize.org, 
[10:24:21.400]                         ...future.globals.maxSize)) {
[10:24:21.400]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.400]                         on.exit(options(oopts), add = TRUE)
[10:24:21.400]                       }
[10:24:21.400]                       {
[10:24:21.400]                         lapply(seq_along(...future.elements_ii), 
[10:24:21.400]                           FUN = function(jj) {
[10:24:21.400]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.400]                             ...future.FUN(...future.X_jj, ...)
[10:24:21.400]                           })
[10:24:21.400]                       }
[10:24:21.400]                     }, args = future.call.arguments)
[10:24:21.400]                   }
[10:24:21.400]                 }, immediateCondition = function(cond) {
[10:24:21.400]                   sendCondition <- ...future.makeSendCondition()
[10:24:21.400]                   sendCondition(cond)
[10:24:21.400]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.400]                   {
[10:24:21.400]                     inherits <- base::inherits
[10:24:21.400]                     invokeRestart <- base::invokeRestart
[10:24:21.400]                     is.null <- base::is.null
[10:24:21.400]                     muffled <- FALSE
[10:24:21.400]                     if (inherits(cond, "message")) {
[10:24:21.400]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:21.400]                       if (muffled) 
[10:24:21.400]                         invokeRestart("muffleMessage")
[10:24:21.400]                     }
[10:24:21.400]                     else if (inherits(cond, "warning")) {
[10:24:21.400]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:21.400]                       if (muffled) 
[10:24:21.400]                         invokeRestart("muffleWarning")
[10:24:21.400]                     }
[10:24:21.400]                     else if (inherits(cond, "condition")) {
[10:24:21.400]                       if (!is.null(pattern)) {
[10:24:21.400]                         computeRestarts <- base::computeRestarts
[10:24:21.400]                         grepl <- base::grepl
[10:24:21.400]                         restarts <- computeRestarts(cond)
[10:24:21.400]                         for (restart in restarts) {
[10:24:21.400]                           name <- restart$name
[10:24:21.400]                           if (is.null(name)) 
[10:24:21.400]                             next
[10:24:21.400]                           if (!grepl(pattern, name)) 
[10:24:21.400]                             next
[10:24:21.400]                           invokeRestart(restart)
[10:24:21.400]                           muffled <- TRUE
[10:24:21.400]                           break
[10:24:21.400]                         }
[10:24:21.400]                       }
[10:24:21.400]                     }
[10:24:21.400]                     invisible(muffled)
[10:24:21.400]                   }
[10:24:21.400]                   muffleCondition(cond)
[10:24:21.400]                 })
[10:24:21.400]             }))
[10:24:21.400]             future::FutureResult(value = ...future.value$value, 
[10:24:21.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:21.400]                   ...future.rng), globalenv = if (FALSE) 
[10:24:21.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:21.400]                     ...future.globalenv.names))
[10:24:21.400]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:21.400]         }, condition = base::local({
[10:24:21.400]             c <- base::c
[10:24:21.400]             inherits <- base::inherits
[10:24:21.400]             invokeRestart <- base::invokeRestart
[10:24:21.400]             length <- base::length
[10:24:21.400]             list <- base::list
[10:24:21.400]             seq.int <- base::seq.int
[10:24:21.400]             signalCondition <- base::signalCondition
[10:24:21.400]             sys.calls <- base::sys.calls
[10:24:21.400]             `[[` <- base::`[[`
[10:24:21.400]             `+` <- base::`+`
[10:24:21.400]             `<<-` <- base::`<<-`
[10:24:21.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:21.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:21.400]                   3L)]
[10:24:21.400]             }
[10:24:21.400]             function(cond) {
[10:24:21.400]                 is_error <- inherits(cond, "error")
[10:24:21.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:21.400]                   NULL)
[10:24:21.400]                 if (is_error) {
[10:24:21.400]                   sessionInformation <- function() {
[10:24:21.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:21.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:21.400]                       search = base::search(), system = base::Sys.info())
[10:24:21.400]                   }
[10:24:21.400]                   ...future.conditions[[length(...future.conditions) + 
[10:24:21.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:21.400]                     cond$call), session = sessionInformation(), 
[10:24:21.400]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:21.400]                   signalCondition(cond)
[10:24:21.400]                 }
[10:24:21.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:21.400]                 "immediateCondition"))) {
[10:24:21.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:21.400]                   ...future.conditions[[length(...future.conditions) + 
[10:24:21.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:21.400]                   if (TRUE && !signal) {
[10:24:21.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.400]                     {
[10:24:21.400]                       inherits <- base::inherits
[10:24:21.400]                       invokeRestart <- base::invokeRestart
[10:24:21.400]                       is.null <- base::is.null
[10:24:21.400]                       muffled <- FALSE
[10:24:21.400]                       if (inherits(cond, "message")) {
[10:24:21.400]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:21.400]                         if (muffled) 
[10:24:21.400]                           invokeRestart("muffleMessage")
[10:24:21.400]                       }
[10:24:21.400]                       else if (inherits(cond, "warning")) {
[10:24:21.400]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:21.400]                         if (muffled) 
[10:24:21.400]                           invokeRestart("muffleWarning")
[10:24:21.400]                       }
[10:24:21.400]                       else if (inherits(cond, "condition")) {
[10:24:21.400]                         if (!is.null(pattern)) {
[10:24:21.400]                           computeRestarts <- base::computeRestarts
[10:24:21.400]                           grepl <- base::grepl
[10:24:21.400]                           restarts <- computeRestarts(cond)
[10:24:21.400]                           for (restart in restarts) {
[10:24:21.400]                             name <- restart$name
[10:24:21.400]                             if (is.null(name)) 
[10:24:21.400]                               next
[10:24:21.400]                             if (!grepl(pattern, name)) 
[10:24:21.400]                               next
[10:24:21.400]                             invokeRestart(restart)
[10:24:21.400]                             muffled <- TRUE
[10:24:21.400]                             break
[10:24:21.400]                           }
[10:24:21.400]                         }
[10:24:21.400]                       }
[10:24:21.400]                       invisible(muffled)
[10:24:21.400]                     }
[10:24:21.400]                     muffleCondition(cond, pattern = "^muffle")
[10:24:21.400]                   }
[10:24:21.400]                 }
[10:24:21.400]                 else {
[10:24:21.400]                   if (TRUE) {
[10:24:21.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.400]                     {
[10:24:21.400]                       inherits <- base::inherits
[10:24:21.400]                       invokeRestart <- base::invokeRestart
[10:24:21.400]                       is.null <- base::is.null
[10:24:21.400]                       muffled <- FALSE
[10:24:21.400]                       if (inherits(cond, "message")) {
[10:24:21.400]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:21.400]                         if (muffled) 
[10:24:21.400]                           invokeRestart("muffleMessage")
[10:24:21.400]                       }
[10:24:21.400]                       else if (inherits(cond, "warning")) {
[10:24:21.400]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:21.400]                         if (muffled) 
[10:24:21.400]                           invokeRestart("muffleWarning")
[10:24:21.400]                       }
[10:24:21.400]                       else if (inherits(cond, "condition")) {
[10:24:21.400]                         if (!is.null(pattern)) {
[10:24:21.400]                           computeRestarts <- base::computeRestarts
[10:24:21.400]                           grepl <- base::grepl
[10:24:21.400]                           restarts <- computeRestarts(cond)
[10:24:21.400]                           for (restart in restarts) {
[10:24:21.400]                             name <- restart$name
[10:24:21.400]                             if (is.null(name)) 
[10:24:21.400]                               next
[10:24:21.400]                             if (!grepl(pattern, name)) 
[10:24:21.400]                               next
[10:24:21.400]                             invokeRestart(restart)
[10:24:21.400]                             muffled <- TRUE
[10:24:21.400]                             break
[10:24:21.400]                           }
[10:24:21.400]                         }
[10:24:21.400]                       }
[10:24:21.400]                       invisible(muffled)
[10:24:21.400]                     }
[10:24:21.400]                     muffleCondition(cond, pattern = "^muffle")
[10:24:21.400]                   }
[10:24:21.400]                 }
[10:24:21.400]             }
[10:24:21.400]         }))
[10:24:21.400]     }, error = function(ex) {
[10:24:21.400]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:21.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:21.400]                 ...future.rng), started = ...future.startTime, 
[10:24:21.400]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:21.400]             version = "1.8"), class = "FutureResult")
[10:24:21.400]     }, finally = {
[10:24:21.400]         if (!identical(...future.workdir, getwd())) 
[10:24:21.400]             setwd(...future.workdir)
[10:24:21.400]         {
[10:24:21.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:21.400]                 ...future.oldOptions$nwarnings <- NULL
[10:24:21.400]             }
[10:24:21.400]             base::options(...future.oldOptions)
[10:24:21.400]             if (.Platform$OS.type == "windows") {
[10:24:21.400]                 old_names <- names(...future.oldEnvVars)
[10:24:21.400]                 envs <- base::Sys.getenv()
[10:24:21.400]                 names <- names(envs)
[10:24:21.400]                 common <- intersect(names, old_names)
[10:24:21.400]                 added <- setdiff(names, old_names)
[10:24:21.400]                 removed <- setdiff(old_names, names)
[10:24:21.400]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:21.400]                   envs[common]]
[10:24:21.400]                 NAMES <- toupper(changed)
[10:24:21.400]                 args <- list()
[10:24:21.400]                 for (kk in seq_along(NAMES)) {
[10:24:21.400]                   name <- changed[[kk]]
[10:24:21.400]                   NAME <- NAMES[[kk]]
[10:24:21.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.400]                     next
[10:24:21.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:21.400]                 }
[10:24:21.400]                 NAMES <- toupper(added)
[10:24:21.400]                 for (kk in seq_along(NAMES)) {
[10:24:21.400]                   name <- added[[kk]]
[10:24:21.400]                   NAME <- NAMES[[kk]]
[10:24:21.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.400]                     next
[10:24:21.400]                   args[[name]] <- ""
[10:24:21.400]                 }
[10:24:21.400]                 NAMES <- toupper(removed)
[10:24:21.400]                 for (kk in seq_along(NAMES)) {
[10:24:21.400]                   name <- removed[[kk]]
[10:24:21.400]                   NAME <- NAMES[[kk]]
[10:24:21.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.400]                     next
[10:24:21.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:21.400]                 }
[10:24:21.400]                 if (length(args) > 0) 
[10:24:21.400]                   base::do.call(base::Sys.setenv, args = args)
[10:24:21.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:21.400]             }
[10:24:21.400]             else {
[10:24:21.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:21.400]             }
[10:24:21.400]             {
[10:24:21.400]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:21.400]                   0L) {
[10:24:21.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:21.400]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:21.400]                   base::options(opts)
[10:24:21.400]                 }
[10:24:21.400]                 {
[10:24:21.400]                   {
[10:24:21.400]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:21.400]                     NULL
[10:24:21.400]                   }
[10:24:21.400]                   options(future.plan = NULL)
[10:24:21.400]                   if (is.na(NA_character_)) 
[10:24:21.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:21.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:21.400]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:21.400]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:21.400]                     envir = parent.frame()) 
[10:24:21.400]                   {
[10:24:21.400]                     if (is.function(workers)) 
[10:24:21.400]                       workers <- workers()
[10:24:21.400]                     workers <- structure(as.integer(workers), 
[10:24:21.400]                       class = class(workers))
[10:24:21.400]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:21.400]                       workers >= 1)
[10:24:21.400]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:21.400]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:21.400]                     }
[10:24:21.400]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:21.400]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:21.400]                       envir = envir)
[10:24:21.400]                     if (!future$lazy) 
[10:24:21.400]                       future <- run(future)
[10:24:21.400]                     invisible(future)
[10:24:21.400]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:21.400]                 }
[10:24:21.400]             }
[10:24:21.400]         }
[10:24:21.400]     })
[10:24:21.400]     if (TRUE) {
[10:24:21.400]         base::sink(type = "output", split = FALSE)
[10:24:21.400]         if (TRUE) {
[10:24:21.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:21.400]         }
[10:24:21.400]         else {
[10:24:21.400]             ...future.result["stdout"] <- base::list(NULL)
[10:24:21.400]         }
[10:24:21.400]         base::close(...future.stdout)
[10:24:21.400]         ...future.stdout <- NULL
[10:24:21.400]     }
[10:24:21.400]     ...future.result$conditions <- ...future.conditions
[10:24:21.400]     ...future.result$finished <- base::Sys.time()
[10:24:21.400]     ...future.result
[10:24:21.400] }
[10:24:21.405] Exporting 11 global objects (92.12 KiB) to cluster node #2 ...
[10:24:21.405] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:21.450] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:21.450] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[10:24:21.450] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[10:24:21.451] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:21.451] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:21.451] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:21.494] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:21.494] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:21.538] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:21.538] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:24:21.538] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.538] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:24:21.539] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:24:21.539] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:21.539] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.540] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:24:21.540] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:24:21.540] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:21.540] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.541] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:21.541] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.541] Exporting 11 global objects (92.12 KiB) to cluster node #2 ... DONE
[10:24:21.542] MultisessionFuture started
[10:24:21.542] - Launch lazy future ... done
[10:24:21.542] run() for ‘MultisessionFuture’ ... done
[10:24:21.542] Created future:
[10:24:21.542] MultisessionFuture:
[10:24:21.542] Label: ‘future_vapply-2’
[10:24:21.542] Expression:
[10:24:21.542] {
[10:24:21.542]     do.call(function(...) {
[10:24:21.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:21.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.542]             on.exit(options(oopts), add = TRUE)
[10:24:21.542]         }
[10:24:21.542]         {
[10:24:21.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:21.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.542]                 ...future.FUN(...future.X_jj, ...)
[10:24:21.542]             })
[10:24:21.542]         }
[10:24:21.542]     }, args = future.call.arguments)
[10:24:21.542] }
[10:24:21.542] Lazy evaluation: FALSE
[10:24:21.542] Asynchronous evaluation: TRUE
[10:24:21.542] Local evaluation: TRUE
[10:24:21.542] Environment: R_GlobalEnv
[10:24:21.542] Capture standard output: TRUE
[10:24:21.542] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:21.542] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:21.542] Packages: 1 packages (‘future.apply’)
[10:24:21.542] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:21.542] Resolved: FALSE
[10:24:21.542] Value: <not collected>
[10:24:21.542] Conditions captured: <none>
[10:24:21.542] Early signaling: FALSE
[10:24:21.542] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:21.542] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:21.554] Chunk #2 of 2 ... DONE
[10:24:21.554] Launching 2 futures (chunks) ... DONE
[10:24:21.554] Resolving 2 futures (chunks) ...
[10:24:21.554] resolve() on list ...
[10:24:21.554]  recursive: 0
[10:24:21.554]  length: 2
[10:24:21.555] 
[10:24:21.555] receiveMessageFromWorker() for ClusterFuture ...
[10:24:21.555] - Validating connection of MultisessionFuture
[10:24:21.555] - received message: FutureResult
[10:24:21.555] - Received FutureResult
[10:24:21.556] - Erased future from FutureRegistry
[10:24:21.556] result() for ClusterFuture ...
[10:24:21.556] - result already collected: FutureResult
[10:24:21.556] result() for ClusterFuture ... done
[10:24:21.556] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:21.556] Future #1
[10:24:21.556] result() for ClusterFuture ...
[10:24:21.556] - result already collected: FutureResult
[10:24:21.556] result() for ClusterFuture ... done
[10:24:21.556] result() for ClusterFuture ...
[10:24:21.556] - result already collected: FutureResult
[10:24:21.557] result() for ClusterFuture ... done
[10:24:21.557] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:21.557] - nx: 2
[10:24:21.557] - relay: TRUE
[10:24:21.557] - stdout: TRUE
[10:24:21.557] - signal: TRUE
[10:24:21.557] - resignal: FALSE
[10:24:21.557] - force: TRUE
[10:24:21.557] - relayed: [n=2] FALSE, FALSE
[10:24:21.557] - queued futures: [n=2] FALSE, FALSE
[10:24:21.557]  - until=1
[10:24:21.558]  - relaying element #1
[10:24:21.558] result() for ClusterFuture ...
[10:24:21.558] - result already collected: FutureResult
[10:24:21.558] result() for ClusterFuture ... done
[10:24:21.558] result() for ClusterFuture ...
[10:24:21.558] - result already collected: FutureResult
[10:24:21.558] result() for ClusterFuture ... done
[10:24:21.558] result() for ClusterFuture ...
[10:24:21.558] - result already collected: FutureResult
[10:24:21.558] result() for ClusterFuture ... done
[10:24:21.559] result() for ClusterFuture ...
[10:24:21.559] - result already collected: FutureResult
[10:24:21.559] result() for ClusterFuture ... done
[10:24:21.559] - relayed: [n=2] TRUE, FALSE
[10:24:21.559] - queued futures: [n=2] TRUE, FALSE
[10:24:21.559] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:21.559]  length: 1 (resolved future 1)
[10:24:21.601] receiveMessageFromWorker() for ClusterFuture ...
[10:24:21.601] - Validating connection of MultisessionFuture
[10:24:21.601] - received message: FutureResult
[10:24:21.601] - Received FutureResult
[10:24:21.601] - Erased future from FutureRegistry
[10:24:21.602] result() for ClusterFuture ...
[10:24:21.602] - result already collected: FutureResult
[10:24:21.602] result() for ClusterFuture ... done
[10:24:21.602] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:21.602] Future #2
[10:24:21.602] result() for ClusterFuture ...
[10:24:21.602] - result already collected: FutureResult
[10:24:21.602] result() for ClusterFuture ... done
[10:24:21.602] result() for ClusterFuture ...
[10:24:21.602] - result already collected: FutureResult
[10:24:21.602] result() for ClusterFuture ... done
[10:24:21.603] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:21.603] - nx: 2
[10:24:21.603] - relay: TRUE
[10:24:21.603] - stdout: TRUE
[10:24:21.603] - signal: TRUE
[10:24:21.603] - resignal: FALSE
[10:24:21.603] - force: TRUE
[10:24:21.603] - relayed: [n=2] TRUE, FALSE
[10:24:21.603] - queued futures: [n=2] TRUE, FALSE
[10:24:21.603]  - until=2
[10:24:21.603]  - relaying element #2
[10:24:21.604] result() for ClusterFuture ...
[10:24:21.604] - result already collected: FutureResult
[10:24:21.604] result() for ClusterFuture ... done
[10:24:21.604] result() for ClusterFuture ...
[10:24:21.604] - result already collected: FutureResult
[10:24:21.604] result() for ClusterFuture ... done
[10:24:21.604] result() for ClusterFuture ...
[10:24:21.604] - result already collected: FutureResult
[10:24:21.604] result() for ClusterFuture ... done
[10:24:21.604] result() for ClusterFuture ...
[10:24:21.604] - result already collected: FutureResult
[10:24:21.605] result() for ClusterFuture ... done
[10:24:21.605] - relayed: [n=2] TRUE, TRUE
[10:24:21.605] - queued futures: [n=2] TRUE, TRUE
[10:24:21.605] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:21.605]  length: 0 (resolved future 2)
[10:24:21.605] Relaying remaining futures
[10:24:21.605] signalConditionsASAP(NULL, pos=0) ...
[10:24:21.605] - nx: 2
[10:24:21.605] - relay: TRUE
[10:24:21.605] - stdout: TRUE
[10:24:21.605] - signal: TRUE
[10:24:21.606] - resignal: FALSE
[10:24:21.606] - force: TRUE
[10:24:21.606] - relayed: [n=2] TRUE, TRUE
[10:24:21.606] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:21.606] - relayed: [n=2] TRUE, TRUE
[10:24:21.606] - queued futures: [n=2] TRUE, TRUE
[10:24:21.606] signalConditionsASAP(NULL, pos=0) ... done
[10:24:21.606] resolve() on list ... DONE
[10:24:21.606] result() for ClusterFuture ...
[10:24:21.606] - result already collected: FutureResult
[10:24:21.606] result() for ClusterFuture ... done
[10:24:21.607] result() for ClusterFuture ...
[10:24:21.607] - result already collected: FutureResult
[10:24:21.607] result() for ClusterFuture ... done
[10:24:21.607] result() for ClusterFuture ...
[10:24:21.607] - result already collected: FutureResult
[10:24:21.607] result() for ClusterFuture ... done
[10:24:21.607] result() for ClusterFuture ...
[10:24:21.607] - result already collected: FutureResult
[10:24:21.607] result() for ClusterFuture ... done
[10:24:21.607]  - Number of value chunks collected: 2
[10:24:21.608] Resolving 2 futures (chunks) ... DONE
[10:24:21.608] Reducing values from 2 chunks ...
[10:24:21.608]  - Number of values collected after concatenation: 10
[10:24:21.608]  - Number of values expected: 10
[10:24:21.608] Reducing values from 2 chunks ... DONE
[10:24:21.608] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[10:24:21.609] future_lapply() ...
[10:24:21.614] Number of chunks: 2
[10:24:21.614] getGlobalsAndPackagesXApply() ...
[10:24:21.614]  - future.globals: TRUE
[10:24:21.614] getGlobalsAndPackages() ...
[10:24:21.615] Searching for globals...
[10:24:21.618] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[10:24:21.618] Searching for globals ... DONE
[10:24:21.618] Resolving globals: FALSE
[10:24:21.619] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[10:24:21.620] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:21.620] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:21.620] - packages: [1] ‘future.apply’
[10:24:21.620] getGlobalsAndPackages() ... DONE
[10:24:21.620]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:21.620]  - needed namespaces: [n=1] ‘future.apply’
[10:24:21.620] Finding globals ... DONE
[10:24:21.620]  - use_args: TRUE
[10:24:21.620]  - Getting '...' globals ...
[10:24:21.621] resolve() on list ...
[10:24:21.621]  recursive: 0
[10:24:21.621]  length: 1
[10:24:21.621]  elements: ‘...’
[10:24:21.621]  length: 0 (resolved future 1)
[10:24:21.621] resolve() on list ... DONE
[10:24:21.621]    - '...' content: [n=0] 
[10:24:21.621] List of 1
[10:24:21.621]  $ ...: list()
[10:24:21.621]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:21.621]  - attr(*, "where")=List of 1
[10:24:21.621]   ..$ ...:<environment: 0x55b93e55e220> 
[10:24:21.621]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:21.621]  - attr(*, "resolved")= logi TRUE
[10:24:21.621]  - attr(*, "total_size")= num NA
[10:24:21.624]  - Getting '...' globals ... DONE
[10:24:21.624] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:21.624] List of 8
[10:24:21.624]  $ ...future.FUN:function (x, ...)  
[10:24:21.624]  $ x_FUN        :function (x)  
[10:24:21.624]  $ times        : int 2
[10:24:21.624]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:21.624]  $ stop_if_not  :function (...)  
[10:24:21.624]  $ dim          : NULL
[10:24:21.624]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:21.624]  $ ...          : list()
[10:24:21.624]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:21.624]  - attr(*, "where")=List of 8
[10:24:21.624]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:21.624]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:21.624]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:21.624]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:21.624]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:21.624]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:21.624]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:21.624]   ..$ ...          :<environment: 0x55b93e55e220> 
[10:24:21.624]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:21.624]  - attr(*, "resolved")= logi FALSE
[10:24:21.624]  - attr(*, "total_size")= num 96456
[10:24:21.630] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:21.630] getGlobalsAndPackagesXApply() ... DONE
[10:24:21.630] Number of futures (= number of chunks): 2
[10:24:21.630] Launching 2 futures (chunks) ...
[10:24:21.630] Chunk #1 of 2 ...
[10:24:21.630]  - Finding globals in 'X' for chunk #1 ...
[10:24:21.630] getGlobalsAndPackages() ...
[10:24:21.631] Searching for globals...
[10:24:21.631] 
[10:24:21.631] Searching for globals ... DONE
[10:24:21.631] - globals: [0] <none>
[10:24:21.631] getGlobalsAndPackages() ... DONE
[10:24:21.631]    + additional globals found: [n=0] 
[10:24:21.631]    + additional namespaces needed: [n=0] 
[10:24:21.631]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:21.631]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:21.632]  - seeds: <none>
[10:24:21.632]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.632] getGlobalsAndPackages() ...
[10:24:21.632] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.632] Resolving globals: FALSE
[10:24:21.632] Tweak future expression to call with '...' arguments ...
[10:24:21.632] {
[10:24:21.632]     do.call(function(...) {
[10:24:21.632]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.632]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:21.632]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.632]             on.exit(options(oopts), add = TRUE)
[10:24:21.632]         }
[10:24:21.632]         {
[10:24:21.632]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:21.632]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.632]                 ...future.FUN(...future.X_jj, ...)
[10:24:21.632]             })
[10:24:21.632]         }
[10:24:21.632]     }, args = future.call.arguments)
[10:24:21.632] }
[10:24:21.632] Tweak future expression to call with '...' arguments ... DONE
[10:24:21.633] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.633] - packages: [1] ‘future.apply’
[10:24:21.633] getGlobalsAndPackages() ... DONE
[10:24:21.633] run() for ‘Future’ ...
[10:24:21.634] - state: ‘created’
[10:24:21.634] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:21.647] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:21.648] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:21.648]   - Field: ‘node’
[10:24:21.648]   - Field: ‘label’
[10:24:21.648]   - Field: ‘local’
[10:24:21.648]   - Field: ‘owner’
[10:24:21.648]   - Field: ‘envir’
[10:24:21.648]   - Field: ‘workers’
[10:24:21.648]   - Field: ‘packages’
[10:24:21.648]   - Field: ‘gc’
[10:24:21.649]   - Field: ‘conditions’
[10:24:21.649]   - Field: ‘persistent’
[10:24:21.649]   - Field: ‘expr’
[10:24:21.649]   - Field: ‘uuid’
[10:24:21.649]   - Field: ‘seed’
[10:24:21.649]   - Field: ‘version’
[10:24:21.649]   - Field: ‘result’
[10:24:21.649]   - Field: ‘asynchronous’
[10:24:21.649]   - Field: ‘calls’
[10:24:21.649]   - Field: ‘globals’
[10:24:21.650]   - Field: ‘stdout’
[10:24:21.650]   - Field: ‘earlySignal’
[10:24:21.650]   - Field: ‘lazy’
[10:24:21.650]   - Field: ‘state’
[10:24:21.650] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:21.650] - Launch lazy future ...
[10:24:21.650] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:21.650] Packages needed by future strategies (n = 0): <none>
[10:24:21.651] {
[10:24:21.651]     {
[10:24:21.651]         {
[10:24:21.651]             ...future.startTime <- base::Sys.time()
[10:24:21.651]             {
[10:24:21.651]                 {
[10:24:21.651]                   {
[10:24:21.651]                     {
[10:24:21.651]                       {
[10:24:21.651]                         base::local({
[10:24:21.651]                           has_future <- base::requireNamespace("future", 
[10:24:21.651]                             quietly = TRUE)
[10:24:21.651]                           if (has_future) {
[10:24:21.651]                             ns <- base::getNamespace("future")
[10:24:21.651]                             version <- ns[[".package"]][["version"]]
[10:24:21.651]                             if (is.null(version)) 
[10:24:21.651]                               version <- utils::packageVersion("future")
[10:24:21.651]                           }
[10:24:21.651]                           else {
[10:24:21.651]                             version <- NULL
[10:24:21.651]                           }
[10:24:21.651]                           if (!has_future || version < "1.8.0") {
[10:24:21.651]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:21.651]                               "", base::R.version$version.string), 
[10:24:21.651]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:21.651]                                 base::R.version$platform, 8 * 
[10:24:21.651]                                   base::.Machine$sizeof.pointer), 
[10:24:21.651]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:21.651]                                 "release", "version")], collapse = " "), 
[10:24:21.651]                               hostname = base::Sys.info()[["nodename"]])
[10:24:21.651]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:21.651]                               info)
[10:24:21.651]                             info <- base::paste(info, collapse = "; ")
[10:24:21.651]                             if (!has_future) {
[10:24:21.651]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:21.651]                                 info)
[10:24:21.651]                             }
[10:24:21.651]                             else {
[10:24:21.651]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:21.651]                                 info, version)
[10:24:21.651]                             }
[10:24:21.651]                             base::stop(msg)
[10:24:21.651]                           }
[10:24:21.651]                         })
[10:24:21.651]                       }
[10:24:21.651]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:21.651]                       base::options(mc.cores = 1L)
[10:24:21.651]                     }
[10:24:21.651]                     base::local({
[10:24:21.651]                       for (pkg in "future.apply") {
[10:24:21.651]                         base::loadNamespace(pkg)
[10:24:21.651]                         base::library(pkg, character.only = TRUE)
[10:24:21.651]                       }
[10:24:21.651]                     })
[10:24:21.651]                   }
[10:24:21.651]                   options(future.plan = NULL)
[10:24:21.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:21.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:21.651]                 }
[10:24:21.651]                 ...future.workdir <- getwd()
[10:24:21.651]             }
[10:24:21.651]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:21.651]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:21.651]         }
[10:24:21.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:21.651]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:21.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:21.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:21.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:21.651]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:21.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:21.651]             base::names(...future.oldOptions))
[10:24:21.651]     }
[10:24:21.651]     if (FALSE) {
[10:24:21.651]     }
[10:24:21.651]     else {
[10:24:21.651]         if (TRUE) {
[10:24:21.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:21.651]                 open = "w")
[10:24:21.651]         }
[10:24:21.651]         else {
[10:24:21.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:21.651]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:21.651]         }
[10:24:21.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:21.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:21.651]             base::sink(type = "output", split = FALSE)
[10:24:21.651]             base::close(...future.stdout)
[10:24:21.651]         }, add = TRUE)
[10:24:21.651]     }
[10:24:21.651]     ...future.frame <- base::sys.nframe()
[10:24:21.651]     ...future.conditions <- base::list()
[10:24:21.651]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:21.651]     if (FALSE) {
[10:24:21.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:21.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:21.651]     }
[10:24:21.651]     ...future.result <- base::tryCatch({
[10:24:21.651]         base::withCallingHandlers({
[10:24:21.651]             ...future.value <- base::withVisible(base::local({
[10:24:21.651]                 ...future.makeSendCondition <- base::local({
[10:24:21.651]                   sendCondition <- NULL
[10:24:21.651]                   function(frame = 1L) {
[10:24:21.651]                     if (is.function(sendCondition)) 
[10:24:21.651]                       return(sendCondition)
[10:24:21.651]                     ns <- getNamespace("parallel")
[10:24:21.651]                     if (exists("sendData", mode = "function", 
[10:24:21.651]                       envir = ns)) {
[10:24:21.651]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:21.651]                         envir = ns)
[10:24:21.651]                       envir <- sys.frame(frame)
[10:24:21.651]                       master <- NULL
[10:24:21.651]                       while (!identical(envir, .GlobalEnv) && 
[10:24:21.651]                         !identical(envir, emptyenv())) {
[10:24:21.651]                         if (exists("master", mode = "list", envir = envir, 
[10:24:21.651]                           inherits = FALSE)) {
[10:24:21.651]                           master <- get("master", mode = "list", 
[10:24:21.651]                             envir = envir, inherits = FALSE)
[10:24:21.651]                           if (inherits(master, c("SOCKnode", 
[10:24:21.651]                             "SOCK0node"))) {
[10:24:21.651]                             sendCondition <<- function(cond) {
[10:24:21.651]                               data <- list(type = "VALUE", value = cond, 
[10:24:21.651]                                 success = TRUE)
[10:24:21.651]                               parallel_sendData(master, data)
[10:24:21.651]                             }
[10:24:21.651]                             return(sendCondition)
[10:24:21.651]                           }
[10:24:21.651]                         }
[10:24:21.651]                         frame <- frame + 1L
[10:24:21.651]                         envir <- sys.frame(frame)
[10:24:21.651]                       }
[10:24:21.651]                     }
[10:24:21.651]                     sendCondition <<- function(cond) NULL
[10:24:21.651]                   }
[10:24:21.651]                 })
[10:24:21.651]                 withCallingHandlers({
[10:24:21.651]                   {
[10:24:21.651]                     do.call(function(...) {
[10:24:21.651]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.651]                       if (!identical(...future.globals.maxSize.org, 
[10:24:21.651]                         ...future.globals.maxSize)) {
[10:24:21.651]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.651]                         on.exit(options(oopts), add = TRUE)
[10:24:21.651]                       }
[10:24:21.651]                       {
[10:24:21.651]                         lapply(seq_along(...future.elements_ii), 
[10:24:21.651]                           FUN = function(jj) {
[10:24:21.651]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.651]                             ...future.FUN(...future.X_jj, ...)
[10:24:21.651]                           })
[10:24:21.651]                       }
[10:24:21.651]                     }, args = future.call.arguments)
[10:24:21.651]                   }
[10:24:21.651]                 }, immediateCondition = function(cond) {
[10:24:21.651]                   sendCondition <- ...future.makeSendCondition()
[10:24:21.651]                   sendCondition(cond)
[10:24:21.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.651]                   {
[10:24:21.651]                     inherits <- base::inherits
[10:24:21.651]                     invokeRestart <- base::invokeRestart
[10:24:21.651]                     is.null <- base::is.null
[10:24:21.651]                     muffled <- FALSE
[10:24:21.651]                     if (inherits(cond, "message")) {
[10:24:21.651]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:21.651]                       if (muffled) 
[10:24:21.651]                         invokeRestart("muffleMessage")
[10:24:21.651]                     }
[10:24:21.651]                     else if (inherits(cond, "warning")) {
[10:24:21.651]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:21.651]                       if (muffled) 
[10:24:21.651]                         invokeRestart("muffleWarning")
[10:24:21.651]                     }
[10:24:21.651]                     else if (inherits(cond, "condition")) {
[10:24:21.651]                       if (!is.null(pattern)) {
[10:24:21.651]                         computeRestarts <- base::computeRestarts
[10:24:21.651]                         grepl <- base::grepl
[10:24:21.651]                         restarts <- computeRestarts(cond)
[10:24:21.651]                         for (restart in restarts) {
[10:24:21.651]                           name <- restart$name
[10:24:21.651]                           if (is.null(name)) 
[10:24:21.651]                             next
[10:24:21.651]                           if (!grepl(pattern, name)) 
[10:24:21.651]                             next
[10:24:21.651]                           invokeRestart(restart)
[10:24:21.651]                           muffled <- TRUE
[10:24:21.651]                           break
[10:24:21.651]                         }
[10:24:21.651]                       }
[10:24:21.651]                     }
[10:24:21.651]                     invisible(muffled)
[10:24:21.651]                   }
[10:24:21.651]                   muffleCondition(cond)
[10:24:21.651]                 })
[10:24:21.651]             }))
[10:24:21.651]             future::FutureResult(value = ...future.value$value, 
[10:24:21.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:21.651]                   ...future.rng), globalenv = if (FALSE) 
[10:24:21.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:21.651]                     ...future.globalenv.names))
[10:24:21.651]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:21.651]         }, condition = base::local({
[10:24:21.651]             c <- base::c
[10:24:21.651]             inherits <- base::inherits
[10:24:21.651]             invokeRestart <- base::invokeRestart
[10:24:21.651]             length <- base::length
[10:24:21.651]             list <- base::list
[10:24:21.651]             seq.int <- base::seq.int
[10:24:21.651]             signalCondition <- base::signalCondition
[10:24:21.651]             sys.calls <- base::sys.calls
[10:24:21.651]             `[[` <- base::`[[`
[10:24:21.651]             `+` <- base::`+`
[10:24:21.651]             `<<-` <- base::`<<-`
[10:24:21.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:21.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:21.651]                   3L)]
[10:24:21.651]             }
[10:24:21.651]             function(cond) {
[10:24:21.651]                 is_error <- inherits(cond, "error")
[10:24:21.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:21.651]                   NULL)
[10:24:21.651]                 if (is_error) {
[10:24:21.651]                   sessionInformation <- function() {
[10:24:21.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:21.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:21.651]                       search = base::search(), system = base::Sys.info())
[10:24:21.651]                   }
[10:24:21.651]                   ...future.conditions[[length(...future.conditions) + 
[10:24:21.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:21.651]                     cond$call), session = sessionInformation(), 
[10:24:21.651]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:21.651]                   signalCondition(cond)
[10:24:21.651]                 }
[10:24:21.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:21.651]                 "immediateCondition"))) {
[10:24:21.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:21.651]                   ...future.conditions[[length(...future.conditions) + 
[10:24:21.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:21.651]                   if (TRUE && !signal) {
[10:24:21.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.651]                     {
[10:24:21.651]                       inherits <- base::inherits
[10:24:21.651]                       invokeRestart <- base::invokeRestart
[10:24:21.651]                       is.null <- base::is.null
[10:24:21.651]                       muffled <- FALSE
[10:24:21.651]                       if (inherits(cond, "message")) {
[10:24:21.651]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:21.651]                         if (muffled) 
[10:24:21.651]                           invokeRestart("muffleMessage")
[10:24:21.651]                       }
[10:24:21.651]                       else if (inherits(cond, "warning")) {
[10:24:21.651]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:21.651]                         if (muffled) 
[10:24:21.651]                           invokeRestart("muffleWarning")
[10:24:21.651]                       }
[10:24:21.651]                       else if (inherits(cond, "condition")) {
[10:24:21.651]                         if (!is.null(pattern)) {
[10:24:21.651]                           computeRestarts <- base::computeRestarts
[10:24:21.651]                           grepl <- base::grepl
[10:24:21.651]                           restarts <- computeRestarts(cond)
[10:24:21.651]                           for (restart in restarts) {
[10:24:21.651]                             name <- restart$name
[10:24:21.651]                             if (is.null(name)) 
[10:24:21.651]                               next
[10:24:21.651]                             if (!grepl(pattern, name)) 
[10:24:21.651]                               next
[10:24:21.651]                             invokeRestart(restart)
[10:24:21.651]                             muffled <- TRUE
[10:24:21.651]                             break
[10:24:21.651]                           }
[10:24:21.651]                         }
[10:24:21.651]                       }
[10:24:21.651]                       invisible(muffled)
[10:24:21.651]                     }
[10:24:21.651]                     muffleCondition(cond, pattern = "^muffle")
[10:24:21.651]                   }
[10:24:21.651]                 }
[10:24:21.651]                 else {
[10:24:21.651]                   if (TRUE) {
[10:24:21.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.651]                     {
[10:24:21.651]                       inherits <- base::inherits
[10:24:21.651]                       invokeRestart <- base::invokeRestart
[10:24:21.651]                       is.null <- base::is.null
[10:24:21.651]                       muffled <- FALSE
[10:24:21.651]                       if (inherits(cond, "message")) {
[10:24:21.651]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:21.651]                         if (muffled) 
[10:24:21.651]                           invokeRestart("muffleMessage")
[10:24:21.651]                       }
[10:24:21.651]                       else if (inherits(cond, "warning")) {
[10:24:21.651]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:21.651]                         if (muffled) 
[10:24:21.651]                           invokeRestart("muffleWarning")
[10:24:21.651]                       }
[10:24:21.651]                       else if (inherits(cond, "condition")) {
[10:24:21.651]                         if (!is.null(pattern)) {
[10:24:21.651]                           computeRestarts <- base::computeRestarts
[10:24:21.651]                           grepl <- base::grepl
[10:24:21.651]                           restarts <- computeRestarts(cond)
[10:24:21.651]                           for (restart in restarts) {
[10:24:21.651]                             name <- restart$name
[10:24:21.651]                             if (is.null(name)) 
[10:24:21.651]                               next
[10:24:21.651]                             if (!grepl(pattern, name)) 
[10:24:21.651]                               next
[10:24:21.651]                             invokeRestart(restart)
[10:24:21.651]                             muffled <- TRUE
[10:24:21.651]                             break
[10:24:21.651]                           }
[10:24:21.651]                         }
[10:24:21.651]                       }
[10:24:21.651]                       invisible(muffled)
[10:24:21.651]                     }
[10:24:21.651]                     muffleCondition(cond, pattern = "^muffle")
[10:24:21.651]                   }
[10:24:21.651]                 }
[10:24:21.651]             }
[10:24:21.651]         }))
[10:24:21.651]     }, error = function(ex) {
[10:24:21.651]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:21.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:21.651]                 ...future.rng), started = ...future.startTime, 
[10:24:21.651]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:21.651]             version = "1.8"), class = "FutureResult")
[10:24:21.651]     }, finally = {
[10:24:21.651]         if (!identical(...future.workdir, getwd())) 
[10:24:21.651]             setwd(...future.workdir)
[10:24:21.651]         {
[10:24:21.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:21.651]                 ...future.oldOptions$nwarnings <- NULL
[10:24:21.651]             }
[10:24:21.651]             base::options(...future.oldOptions)
[10:24:21.651]             if (.Platform$OS.type == "windows") {
[10:24:21.651]                 old_names <- names(...future.oldEnvVars)
[10:24:21.651]                 envs <- base::Sys.getenv()
[10:24:21.651]                 names <- names(envs)
[10:24:21.651]                 common <- intersect(names, old_names)
[10:24:21.651]                 added <- setdiff(names, old_names)
[10:24:21.651]                 removed <- setdiff(old_names, names)
[10:24:21.651]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:21.651]                   envs[common]]
[10:24:21.651]                 NAMES <- toupper(changed)
[10:24:21.651]                 args <- list()
[10:24:21.651]                 for (kk in seq_along(NAMES)) {
[10:24:21.651]                   name <- changed[[kk]]
[10:24:21.651]                   NAME <- NAMES[[kk]]
[10:24:21.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.651]                     next
[10:24:21.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:21.651]                 }
[10:24:21.651]                 NAMES <- toupper(added)
[10:24:21.651]                 for (kk in seq_along(NAMES)) {
[10:24:21.651]                   name <- added[[kk]]
[10:24:21.651]                   NAME <- NAMES[[kk]]
[10:24:21.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.651]                     next
[10:24:21.651]                   args[[name]] <- ""
[10:24:21.651]                 }
[10:24:21.651]                 NAMES <- toupper(removed)
[10:24:21.651]                 for (kk in seq_along(NAMES)) {
[10:24:21.651]                   name <- removed[[kk]]
[10:24:21.651]                   NAME <- NAMES[[kk]]
[10:24:21.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.651]                     next
[10:24:21.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:21.651]                 }
[10:24:21.651]                 if (length(args) > 0) 
[10:24:21.651]                   base::do.call(base::Sys.setenv, args = args)
[10:24:21.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:21.651]             }
[10:24:21.651]             else {
[10:24:21.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:21.651]             }
[10:24:21.651]             {
[10:24:21.651]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:21.651]                   0L) {
[10:24:21.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:21.651]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:21.651]                   base::options(opts)
[10:24:21.651]                 }
[10:24:21.651]                 {
[10:24:21.651]                   {
[10:24:21.651]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:21.651]                     NULL
[10:24:21.651]                   }
[10:24:21.651]                   options(future.plan = NULL)
[10:24:21.651]                   if (is.na(NA_character_)) 
[10:24:21.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:21.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:21.651]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:21.651]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:21.651]                     envir = parent.frame()) 
[10:24:21.651]                   {
[10:24:21.651]                     if (is.function(workers)) 
[10:24:21.651]                       workers <- workers()
[10:24:21.651]                     workers <- structure(as.integer(workers), 
[10:24:21.651]                       class = class(workers))
[10:24:21.651]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:21.651]                       workers >= 1)
[10:24:21.651]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:21.651]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:21.651]                     }
[10:24:21.651]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:21.651]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:21.651]                       envir = envir)
[10:24:21.651]                     if (!future$lazy) 
[10:24:21.651]                       future <- run(future)
[10:24:21.651]                     invisible(future)
[10:24:21.651]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:21.651]                 }
[10:24:21.651]             }
[10:24:21.651]         }
[10:24:21.651]     })
[10:24:21.651]     if (TRUE) {
[10:24:21.651]         base::sink(type = "output", split = FALSE)
[10:24:21.651]         if (TRUE) {
[10:24:21.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:21.651]         }
[10:24:21.651]         else {
[10:24:21.651]             ...future.result["stdout"] <- base::list(NULL)
[10:24:21.651]         }
[10:24:21.651]         base::close(...future.stdout)
[10:24:21.651]         ...future.stdout <- NULL
[10:24:21.651]     }
[10:24:21.651]     ...future.result$conditions <- ...future.conditions
[10:24:21.651]     ...future.result$finished <- base::Sys.time()
[10:24:21.651]     ...future.result
[10:24:21.651] }
[10:24:21.654] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[10:24:21.654] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:21.698] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:21.698] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[10:24:21.698] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[10:24:21.698] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:21.699] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:21.699] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:21.742] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:21.742] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:21.786] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:21.786] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:24:21.787] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:24:21.787] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:24:21.787] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:24:21.787] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:21.788] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:21.788] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:24:21.788] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:24:21.788] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:21.788] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:21.789] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:21.789] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:21.789] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[10:24:21.790] MultisessionFuture started
[10:24:21.790] - Launch lazy future ... done
[10:24:21.790] run() for ‘MultisessionFuture’ ... done
[10:24:21.790] Created future:
[10:24:21.790] MultisessionFuture:
[10:24:21.790] Label: ‘future_vapply-1’
[10:24:21.790] Expression:
[10:24:21.790] {
[10:24:21.790]     do.call(function(...) {
[10:24:21.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:21.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.790]             on.exit(options(oopts), add = TRUE)
[10:24:21.790]         }
[10:24:21.790]         {
[10:24:21.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:21.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.790]                 ...future.FUN(...future.X_jj, ...)
[10:24:21.790]             })
[10:24:21.790]         }
[10:24:21.790]     }, args = future.call.arguments)
[10:24:21.790] }
[10:24:21.790] Lazy evaluation: FALSE
[10:24:21.790] Asynchronous evaluation: TRUE
[10:24:21.790] Local evaluation: TRUE
[10:24:21.790] Environment: R_GlobalEnv
[10:24:21.790] Capture standard output: TRUE
[10:24:21.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:21.790] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:21.790] Packages: 1 packages (‘future.apply’)
[10:24:21.790] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:21.790] Resolved: FALSE
[10:24:21.790] Value: <not collected>
[10:24:21.790] Conditions captured: <none>
[10:24:21.790] Early signaling: FALSE
[10:24:21.790] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:21.790] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:21.802] Chunk #1 of 2 ... DONE
[10:24:21.802] Chunk #2 of 2 ...
[10:24:21.802]  - Finding globals in 'X' for chunk #2 ...
[10:24:21.802] getGlobalsAndPackages() ...
[10:24:21.803] Searching for globals...
[10:24:21.803] 
[10:24:21.805] Searching for globals ... DONE
[10:24:21.805] - globals: [0] <none>
[10:24:21.805] getGlobalsAndPackages() ... DONE
[10:24:21.806]    + additional globals found: [n=0] 
[10:24:21.806]    + additional namespaces needed: [n=0] 
[10:24:21.806]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:21.806]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:21.806]  - seeds: <none>
[10:24:21.806]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.806] getGlobalsAndPackages() ...
[10:24:21.806] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.806] Resolving globals: FALSE
[10:24:21.806] Tweak future expression to call with '...' arguments ...
[10:24:21.807] {
[10:24:21.807]     do.call(function(...) {
[10:24:21.807]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.807]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:21.807]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.807]             on.exit(options(oopts), add = TRUE)
[10:24:21.807]         }
[10:24:21.807]         {
[10:24:21.807]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:21.807]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.807]                 ...future.FUN(...future.X_jj, ...)
[10:24:21.807]             })
[10:24:21.807]         }
[10:24:21.807]     }, args = future.call.arguments)
[10:24:21.807] }
[10:24:21.807] Tweak future expression to call with '...' arguments ... DONE
[10:24:21.807] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:21.808] - packages: [1] ‘future.apply’
[10:24:21.808] getGlobalsAndPackages() ... DONE
[10:24:21.808] run() for ‘Future’ ...
[10:24:21.808] - state: ‘created’
[10:24:21.808] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:21.823] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:21.823] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:21.823]   - Field: ‘node’
[10:24:21.823]   - Field: ‘label’
[10:24:21.823]   - Field: ‘local’
[10:24:21.823]   - Field: ‘owner’
[10:24:21.823]   - Field: ‘envir’
[10:24:21.823]   - Field: ‘workers’
[10:24:21.824]   - Field: ‘packages’
[10:24:21.824]   - Field: ‘gc’
[10:24:21.824]   - Field: ‘conditions’
[10:24:21.824]   - Field: ‘persistent’
[10:24:21.824]   - Field: ‘expr’
[10:24:21.824]   - Field: ‘uuid’
[10:24:21.824]   - Field: ‘seed’
[10:24:21.824]   - Field: ‘version’
[10:24:21.824]   - Field: ‘result’
[10:24:21.824]   - Field: ‘asynchronous’
[10:24:21.825]   - Field: ‘calls’
[10:24:21.825]   - Field: ‘globals’
[10:24:21.825]   - Field: ‘stdout’
[10:24:21.825]   - Field: ‘earlySignal’
[10:24:21.825]   - Field: ‘lazy’
[10:24:21.825]   - Field: ‘state’
[10:24:21.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:21.825] - Launch lazy future ...
[10:24:21.825] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:21.826] Packages needed by future strategies (n = 0): <none>
[10:24:21.826] {
[10:24:21.826]     {
[10:24:21.826]         {
[10:24:21.826]             ...future.startTime <- base::Sys.time()
[10:24:21.826]             {
[10:24:21.826]                 {
[10:24:21.826]                   {
[10:24:21.826]                     {
[10:24:21.826]                       {
[10:24:21.826]                         base::local({
[10:24:21.826]                           has_future <- base::requireNamespace("future", 
[10:24:21.826]                             quietly = TRUE)
[10:24:21.826]                           if (has_future) {
[10:24:21.826]                             ns <- base::getNamespace("future")
[10:24:21.826]                             version <- ns[[".package"]][["version"]]
[10:24:21.826]                             if (is.null(version)) 
[10:24:21.826]                               version <- utils::packageVersion("future")
[10:24:21.826]                           }
[10:24:21.826]                           else {
[10:24:21.826]                             version <- NULL
[10:24:21.826]                           }
[10:24:21.826]                           if (!has_future || version < "1.8.0") {
[10:24:21.826]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:21.826]                               "", base::R.version$version.string), 
[10:24:21.826]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:21.826]                                 base::R.version$platform, 8 * 
[10:24:21.826]                                   base::.Machine$sizeof.pointer), 
[10:24:21.826]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:21.826]                                 "release", "version")], collapse = " "), 
[10:24:21.826]                               hostname = base::Sys.info()[["nodename"]])
[10:24:21.826]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:21.826]                               info)
[10:24:21.826]                             info <- base::paste(info, collapse = "; ")
[10:24:21.826]                             if (!has_future) {
[10:24:21.826]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:21.826]                                 info)
[10:24:21.826]                             }
[10:24:21.826]                             else {
[10:24:21.826]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:21.826]                                 info, version)
[10:24:21.826]                             }
[10:24:21.826]                             base::stop(msg)
[10:24:21.826]                           }
[10:24:21.826]                         })
[10:24:21.826]                       }
[10:24:21.826]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:21.826]                       base::options(mc.cores = 1L)
[10:24:21.826]                     }
[10:24:21.826]                     base::local({
[10:24:21.826]                       for (pkg in "future.apply") {
[10:24:21.826]                         base::loadNamespace(pkg)
[10:24:21.826]                         base::library(pkg, character.only = TRUE)
[10:24:21.826]                       }
[10:24:21.826]                     })
[10:24:21.826]                   }
[10:24:21.826]                   options(future.plan = NULL)
[10:24:21.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:21.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:21.826]                 }
[10:24:21.826]                 ...future.workdir <- getwd()
[10:24:21.826]             }
[10:24:21.826]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:21.826]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:21.826]         }
[10:24:21.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:21.826]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:21.826]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:21.826]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:21.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:21.826]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:21.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:21.826]             base::names(...future.oldOptions))
[10:24:21.826]     }
[10:24:21.826]     if (FALSE) {
[10:24:21.826]     }
[10:24:21.826]     else {
[10:24:21.826]         if (TRUE) {
[10:24:21.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:21.826]                 open = "w")
[10:24:21.826]         }
[10:24:21.826]         else {
[10:24:21.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:21.826]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:21.826]         }
[10:24:21.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:21.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:21.826]             base::sink(type = "output", split = FALSE)
[10:24:21.826]             base::close(...future.stdout)
[10:24:21.826]         }, add = TRUE)
[10:24:21.826]     }
[10:24:21.826]     ...future.frame <- base::sys.nframe()
[10:24:21.826]     ...future.conditions <- base::list()
[10:24:21.826]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:21.826]     if (FALSE) {
[10:24:21.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:21.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:21.826]     }
[10:24:21.826]     ...future.result <- base::tryCatch({
[10:24:21.826]         base::withCallingHandlers({
[10:24:21.826]             ...future.value <- base::withVisible(base::local({
[10:24:21.826]                 ...future.makeSendCondition <- base::local({
[10:24:21.826]                   sendCondition <- NULL
[10:24:21.826]                   function(frame = 1L) {
[10:24:21.826]                     if (is.function(sendCondition)) 
[10:24:21.826]                       return(sendCondition)
[10:24:21.826]                     ns <- getNamespace("parallel")
[10:24:21.826]                     if (exists("sendData", mode = "function", 
[10:24:21.826]                       envir = ns)) {
[10:24:21.826]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:21.826]                         envir = ns)
[10:24:21.826]                       envir <- sys.frame(frame)
[10:24:21.826]                       master <- NULL
[10:24:21.826]                       while (!identical(envir, .GlobalEnv) && 
[10:24:21.826]                         !identical(envir, emptyenv())) {
[10:24:21.826]                         if (exists("master", mode = "list", envir = envir, 
[10:24:21.826]                           inherits = FALSE)) {
[10:24:21.826]                           master <- get("master", mode = "list", 
[10:24:21.826]                             envir = envir, inherits = FALSE)
[10:24:21.826]                           if (inherits(master, c("SOCKnode", 
[10:24:21.826]                             "SOCK0node"))) {
[10:24:21.826]                             sendCondition <<- function(cond) {
[10:24:21.826]                               data <- list(type = "VALUE", value = cond, 
[10:24:21.826]                                 success = TRUE)
[10:24:21.826]                               parallel_sendData(master, data)
[10:24:21.826]                             }
[10:24:21.826]                             return(sendCondition)
[10:24:21.826]                           }
[10:24:21.826]                         }
[10:24:21.826]                         frame <- frame + 1L
[10:24:21.826]                         envir <- sys.frame(frame)
[10:24:21.826]                       }
[10:24:21.826]                     }
[10:24:21.826]                     sendCondition <<- function(cond) NULL
[10:24:21.826]                   }
[10:24:21.826]                 })
[10:24:21.826]                 withCallingHandlers({
[10:24:21.826]                   {
[10:24:21.826]                     do.call(function(...) {
[10:24:21.826]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.826]                       if (!identical(...future.globals.maxSize.org, 
[10:24:21.826]                         ...future.globals.maxSize)) {
[10:24:21.826]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.826]                         on.exit(options(oopts), add = TRUE)
[10:24:21.826]                       }
[10:24:21.826]                       {
[10:24:21.826]                         lapply(seq_along(...future.elements_ii), 
[10:24:21.826]                           FUN = function(jj) {
[10:24:21.826]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.826]                             ...future.FUN(...future.X_jj, ...)
[10:24:21.826]                           })
[10:24:21.826]                       }
[10:24:21.826]                     }, args = future.call.arguments)
[10:24:21.826]                   }
[10:24:21.826]                 }, immediateCondition = function(cond) {
[10:24:21.826]                   sendCondition <- ...future.makeSendCondition()
[10:24:21.826]                   sendCondition(cond)
[10:24:21.826]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.826]                   {
[10:24:21.826]                     inherits <- base::inherits
[10:24:21.826]                     invokeRestart <- base::invokeRestart
[10:24:21.826]                     is.null <- base::is.null
[10:24:21.826]                     muffled <- FALSE
[10:24:21.826]                     if (inherits(cond, "message")) {
[10:24:21.826]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:21.826]                       if (muffled) 
[10:24:21.826]                         invokeRestart("muffleMessage")
[10:24:21.826]                     }
[10:24:21.826]                     else if (inherits(cond, "warning")) {
[10:24:21.826]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:21.826]                       if (muffled) 
[10:24:21.826]                         invokeRestart("muffleWarning")
[10:24:21.826]                     }
[10:24:21.826]                     else if (inherits(cond, "condition")) {
[10:24:21.826]                       if (!is.null(pattern)) {
[10:24:21.826]                         computeRestarts <- base::computeRestarts
[10:24:21.826]                         grepl <- base::grepl
[10:24:21.826]                         restarts <- computeRestarts(cond)
[10:24:21.826]                         for (restart in restarts) {
[10:24:21.826]                           name <- restart$name
[10:24:21.826]                           if (is.null(name)) 
[10:24:21.826]                             next
[10:24:21.826]                           if (!grepl(pattern, name)) 
[10:24:21.826]                             next
[10:24:21.826]                           invokeRestart(restart)
[10:24:21.826]                           muffled <- TRUE
[10:24:21.826]                           break
[10:24:21.826]                         }
[10:24:21.826]                       }
[10:24:21.826]                     }
[10:24:21.826]                     invisible(muffled)
[10:24:21.826]                   }
[10:24:21.826]                   muffleCondition(cond)
[10:24:21.826]                 })
[10:24:21.826]             }))
[10:24:21.826]             future::FutureResult(value = ...future.value$value, 
[10:24:21.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:21.826]                   ...future.rng), globalenv = if (FALSE) 
[10:24:21.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:21.826]                     ...future.globalenv.names))
[10:24:21.826]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:21.826]         }, condition = base::local({
[10:24:21.826]             c <- base::c
[10:24:21.826]             inherits <- base::inherits
[10:24:21.826]             invokeRestart <- base::invokeRestart
[10:24:21.826]             length <- base::length
[10:24:21.826]             list <- base::list
[10:24:21.826]             seq.int <- base::seq.int
[10:24:21.826]             signalCondition <- base::signalCondition
[10:24:21.826]             sys.calls <- base::sys.calls
[10:24:21.826]             `[[` <- base::`[[`
[10:24:21.826]             `+` <- base::`+`
[10:24:21.826]             `<<-` <- base::`<<-`
[10:24:21.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:21.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:21.826]                   3L)]
[10:24:21.826]             }
[10:24:21.826]             function(cond) {
[10:24:21.826]                 is_error <- inherits(cond, "error")
[10:24:21.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:21.826]                   NULL)
[10:24:21.826]                 if (is_error) {
[10:24:21.826]                   sessionInformation <- function() {
[10:24:21.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:21.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:21.826]                       search = base::search(), system = base::Sys.info())
[10:24:21.826]                   }
[10:24:21.826]                   ...future.conditions[[length(...future.conditions) + 
[10:24:21.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:21.826]                     cond$call), session = sessionInformation(), 
[10:24:21.826]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:21.826]                   signalCondition(cond)
[10:24:21.826]                 }
[10:24:21.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:21.826]                 "immediateCondition"))) {
[10:24:21.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:21.826]                   ...future.conditions[[length(...future.conditions) + 
[10:24:21.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:21.826]                   if (TRUE && !signal) {
[10:24:21.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.826]                     {
[10:24:21.826]                       inherits <- base::inherits
[10:24:21.826]                       invokeRestart <- base::invokeRestart
[10:24:21.826]                       is.null <- base::is.null
[10:24:21.826]                       muffled <- FALSE
[10:24:21.826]                       if (inherits(cond, "message")) {
[10:24:21.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:21.826]                         if (muffled) 
[10:24:21.826]                           invokeRestart("muffleMessage")
[10:24:21.826]                       }
[10:24:21.826]                       else if (inherits(cond, "warning")) {
[10:24:21.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:21.826]                         if (muffled) 
[10:24:21.826]                           invokeRestart("muffleWarning")
[10:24:21.826]                       }
[10:24:21.826]                       else if (inherits(cond, "condition")) {
[10:24:21.826]                         if (!is.null(pattern)) {
[10:24:21.826]                           computeRestarts <- base::computeRestarts
[10:24:21.826]                           grepl <- base::grepl
[10:24:21.826]                           restarts <- computeRestarts(cond)
[10:24:21.826]                           for (restart in restarts) {
[10:24:21.826]                             name <- restart$name
[10:24:21.826]                             if (is.null(name)) 
[10:24:21.826]                               next
[10:24:21.826]                             if (!grepl(pattern, name)) 
[10:24:21.826]                               next
[10:24:21.826]                             invokeRestart(restart)
[10:24:21.826]                             muffled <- TRUE
[10:24:21.826]                             break
[10:24:21.826]                           }
[10:24:21.826]                         }
[10:24:21.826]                       }
[10:24:21.826]                       invisible(muffled)
[10:24:21.826]                     }
[10:24:21.826]                     muffleCondition(cond, pattern = "^muffle")
[10:24:21.826]                   }
[10:24:21.826]                 }
[10:24:21.826]                 else {
[10:24:21.826]                   if (TRUE) {
[10:24:21.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:21.826]                     {
[10:24:21.826]                       inherits <- base::inherits
[10:24:21.826]                       invokeRestart <- base::invokeRestart
[10:24:21.826]                       is.null <- base::is.null
[10:24:21.826]                       muffled <- FALSE
[10:24:21.826]                       if (inherits(cond, "message")) {
[10:24:21.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:21.826]                         if (muffled) 
[10:24:21.826]                           invokeRestart("muffleMessage")
[10:24:21.826]                       }
[10:24:21.826]                       else if (inherits(cond, "warning")) {
[10:24:21.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:21.826]                         if (muffled) 
[10:24:21.826]                           invokeRestart("muffleWarning")
[10:24:21.826]                       }
[10:24:21.826]                       else if (inherits(cond, "condition")) {
[10:24:21.826]                         if (!is.null(pattern)) {
[10:24:21.826]                           computeRestarts <- base::computeRestarts
[10:24:21.826]                           grepl <- base::grepl
[10:24:21.826]                           restarts <- computeRestarts(cond)
[10:24:21.826]                           for (restart in restarts) {
[10:24:21.826]                             name <- restart$name
[10:24:21.826]                             if (is.null(name)) 
[10:24:21.826]                               next
[10:24:21.826]                             if (!grepl(pattern, name)) 
[10:24:21.826]                               next
[10:24:21.826]                             invokeRestart(restart)
[10:24:21.826]                             muffled <- TRUE
[10:24:21.826]                             break
[10:24:21.826]                           }
[10:24:21.826]                         }
[10:24:21.826]                       }
[10:24:21.826]                       invisible(muffled)
[10:24:21.826]                     }
[10:24:21.826]                     muffleCondition(cond, pattern = "^muffle")
[10:24:21.826]                   }
[10:24:21.826]                 }
[10:24:21.826]             }
[10:24:21.826]         }))
[10:24:21.826]     }, error = function(ex) {
[10:24:21.826]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:21.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:21.826]                 ...future.rng), started = ...future.startTime, 
[10:24:21.826]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:21.826]             version = "1.8"), class = "FutureResult")
[10:24:21.826]     }, finally = {
[10:24:21.826]         if (!identical(...future.workdir, getwd())) 
[10:24:21.826]             setwd(...future.workdir)
[10:24:21.826]         {
[10:24:21.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:21.826]                 ...future.oldOptions$nwarnings <- NULL
[10:24:21.826]             }
[10:24:21.826]             base::options(...future.oldOptions)
[10:24:21.826]             if (.Platform$OS.type == "windows") {
[10:24:21.826]                 old_names <- names(...future.oldEnvVars)
[10:24:21.826]                 envs <- base::Sys.getenv()
[10:24:21.826]                 names <- names(envs)
[10:24:21.826]                 common <- intersect(names, old_names)
[10:24:21.826]                 added <- setdiff(names, old_names)
[10:24:21.826]                 removed <- setdiff(old_names, names)
[10:24:21.826]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:21.826]                   envs[common]]
[10:24:21.826]                 NAMES <- toupper(changed)
[10:24:21.826]                 args <- list()
[10:24:21.826]                 for (kk in seq_along(NAMES)) {
[10:24:21.826]                   name <- changed[[kk]]
[10:24:21.826]                   NAME <- NAMES[[kk]]
[10:24:21.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.826]                     next
[10:24:21.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:21.826]                 }
[10:24:21.826]                 NAMES <- toupper(added)
[10:24:21.826]                 for (kk in seq_along(NAMES)) {
[10:24:21.826]                   name <- added[[kk]]
[10:24:21.826]                   NAME <- NAMES[[kk]]
[10:24:21.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.826]                     next
[10:24:21.826]                   args[[name]] <- ""
[10:24:21.826]                 }
[10:24:21.826]                 NAMES <- toupper(removed)
[10:24:21.826]                 for (kk in seq_along(NAMES)) {
[10:24:21.826]                   name <- removed[[kk]]
[10:24:21.826]                   NAME <- NAMES[[kk]]
[10:24:21.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:21.826]                     next
[10:24:21.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:21.826]                 }
[10:24:21.826]                 if (length(args) > 0) 
[10:24:21.826]                   base::do.call(base::Sys.setenv, args = args)
[10:24:21.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:21.826]             }
[10:24:21.826]             else {
[10:24:21.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:21.826]             }
[10:24:21.826]             {
[10:24:21.826]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:21.826]                   0L) {
[10:24:21.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:21.826]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:21.826]                   base::options(opts)
[10:24:21.826]                 }
[10:24:21.826]                 {
[10:24:21.826]                   {
[10:24:21.826]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:21.826]                     NULL
[10:24:21.826]                   }
[10:24:21.826]                   options(future.plan = NULL)
[10:24:21.826]                   if (is.na(NA_character_)) 
[10:24:21.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:21.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:21.826]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:21.826]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:21.826]                     envir = parent.frame()) 
[10:24:21.826]                   {
[10:24:21.826]                     if (is.function(workers)) 
[10:24:21.826]                       workers <- workers()
[10:24:21.826]                     workers <- structure(as.integer(workers), 
[10:24:21.826]                       class = class(workers))
[10:24:21.826]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:21.826]                       workers >= 1)
[10:24:21.826]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:21.826]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:21.826]                     }
[10:24:21.826]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:21.826]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:21.826]                       envir = envir)
[10:24:21.826]                     if (!future$lazy) 
[10:24:21.826]                       future <- run(future)
[10:24:21.826]                     invisible(future)
[10:24:21.826]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:21.826]                 }
[10:24:21.826]             }
[10:24:21.826]         }
[10:24:21.826]     })
[10:24:21.826]     if (TRUE) {
[10:24:21.826]         base::sink(type = "output", split = FALSE)
[10:24:21.826]         if (TRUE) {
[10:24:21.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:21.826]         }
[10:24:21.826]         else {
[10:24:21.826]             ...future.result["stdout"] <- base::list(NULL)
[10:24:21.826]         }
[10:24:21.826]         base::close(...future.stdout)
[10:24:21.826]         ...future.stdout <- NULL
[10:24:21.826]     }
[10:24:21.826]     ...future.result$conditions <- ...future.conditions
[10:24:21.826]     ...future.result$finished <- base::Sys.time()
[10:24:21.826]     ...future.result
[10:24:21.826] }
[10:24:21.829] Exporting 11 global objects (94.20 KiB) to cluster node #2 ...
[10:24:21.829] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:21.870] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:21.870] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ...
[10:24:21.870] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ... DONE
[10:24:21.871] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:21.871] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:21.871] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:21.914] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:21.914] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:21.958] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:21.958] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:24:21.958] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.959] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:24:21.959] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:24:21.959] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:21.960] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.960] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:24:21.960] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:24:21.960] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:21.961] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.961] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:21.961] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:21.961] Exporting 11 global objects (94.20 KiB) to cluster node #2 ... DONE
[10:24:21.962] MultisessionFuture started
[10:24:21.962] - Launch lazy future ... done
[10:24:21.962] run() for ‘MultisessionFuture’ ... done
[10:24:21.963] Created future:
[10:24:21.963] MultisessionFuture:
[10:24:21.963] Label: ‘future_vapply-2’
[10:24:21.963] Expression:
[10:24:21.963] {
[10:24:21.963]     do.call(function(...) {
[10:24:21.963]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:21.963]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:21.963]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:21.963]             on.exit(options(oopts), add = TRUE)
[10:24:21.963]         }
[10:24:21.963]         {
[10:24:21.963]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:21.963]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:21.963]                 ...future.FUN(...future.X_jj, ...)
[10:24:21.963]             })
[10:24:21.963]         }
[10:24:21.963]     }, args = future.call.arguments)
[10:24:21.963] }
[10:24:21.963] Lazy evaluation: FALSE
[10:24:21.963] Asynchronous evaluation: TRUE
[10:24:21.963] Local evaluation: TRUE
[10:24:21.963] Environment: R_GlobalEnv
[10:24:21.963] Capture standard output: TRUE
[10:24:21.963] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:21.963] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:21.963] Packages: 1 packages (‘future.apply’)
[10:24:21.963] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:21.963] Resolved: FALSE
[10:24:21.963] Value: <not collected>
[10:24:21.963] Conditions captured: <none>
[10:24:21.963] Early signaling: FALSE
[10:24:21.963] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:21.963] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:21.974] Chunk #2 of 2 ... DONE
[10:24:21.975] Launching 2 futures (chunks) ... DONE
[10:24:21.975] Resolving 2 futures (chunks) ...
[10:24:21.975] resolve() on list ...
[10:24:21.975]  recursive: 0
[10:24:21.975]  length: 2
[10:24:21.975] 
[10:24:21.976] receiveMessageFromWorker() for ClusterFuture ...
[10:24:21.976] - Validating connection of MultisessionFuture
[10:24:21.976] - received message: FutureResult
[10:24:21.976] - Received FutureResult
[10:24:21.976] - Erased future from FutureRegistry
[10:24:21.976] result() for ClusterFuture ...
[10:24:21.976] - result already collected: FutureResult
[10:24:21.976] result() for ClusterFuture ... done
[10:24:21.976] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:21.977] Future #1
[10:24:21.977] result() for ClusterFuture ...
[10:24:21.977] - result already collected: FutureResult
[10:24:21.977] result() for ClusterFuture ... done
[10:24:21.977] result() for ClusterFuture ...
[10:24:21.977] - result already collected: FutureResult
[10:24:21.977] result() for ClusterFuture ... done
[10:24:21.977] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:21.977] - nx: 2
[10:24:21.977] - relay: TRUE
[10:24:21.977] - stdout: TRUE
[10:24:21.978] - signal: TRUE
[10:24:21.978] - resignal: FALSE
[10:24:21.978] - force: TRUE
[10:24:21.978] - relayed: [n=2] FALSE, FALSE
[10:24:21.978] - queued futures: [n=2] FALSE, FALSE
[10:24:21.978]  - until=1
[10:24:21.978]  - relaying element #1
[10:24:21.978] result() for ClusterFuture ...
[10:24:21.978] - result already collected: FutureResult
[10:24:21.978] result() for ClusterFuture ... done
[10:24:21.978] result() for ClusterFuture ...
[10:24:21.979] - result already collected: FutureResult
[10:24:21.979] result() for ClusterFuture ... done
[10:24:21.979] result() for ClusterFuture ...
[10:24:21.979] - result already collected: FutureResult
[10:24:21.979] result() for ClusterFuture ... done
[10:24:21.979] result() for ClusterFuture ...
[10:24:21.979] - result already collected: FutureResult
[10:24:21.979] result() for ClusterFuture ... done
[10:24:21.979] - relayed: [n=2] TRUE, FALSE
[10:24:21.979] - queued futures: [n=2] TRUE, FALSE
[10:24:21.979] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:21.980]  length: 1 (resolved future 1)
[10:24:22.010] receiveMessageFromWorker() for ClusterFuture ...
[10:24:22.011] - Validating connection of MultisessionFuture
[10:24:22.011] - received message: FutureResult
[10:24:22.011] - Received FutureResult
[10:24:22.011] - Erased future from FutureRegistry
[10:24:22.011] result() for ClusterFuture ...
[10:24:22.011] - result already collected: FutureResult
[10:24:22.011] result() for ClusterFuture ... done
[10:24:22.011] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:22.012] Future #2
[10:24:22.012] result() for ClusterFuture ...
[10:24:22.012] - result already collected: FutureResult
[10:24:22.012] result() for ClusterFuture ... done
[10:24:22.012] result() for ClusterFuture ...
[10:24:22.012] - result already collected: FutureResult
[10:24:22.012] result() for ClusterFuture ... done
[10:24:22.012] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:22.012] - nx: 2
[10:24:22.012] - relay: TRUE
[10:24:22.012] - stdout: TRUE
[10:24:22.012] - signal: TRUE
[10:24:22.013] - resignal: FALSE
[10:24:22.013] - force: TRUE
[10:24:22.013] - relayed: [n=2] TRUE, FALSE
[10:24:22.013] - queued futures: [n=2] TRUE, FALSE
[10:24:22.013]  - until=2
[10:24:22.013]  - relaying element #2
[10:24:22.013] result() for ClusterFuture ...
[10:24:22.013] - result already collected: FutureResult
[10:24:22.013] result() for ClusterFuture ... done
[10:24:22.013] result() for ClusterFuture ...
[10:24:22.013] - result already collected: FutureResult
[10:24:22.014] result() for ClusterFuture ... done
[10:24:22.014] result() for ClusterFuture ...
[10:24:22.014] - result already collected: FutureResult
[10:24:22.014] result() for ClusterFuture ... done
[10:24:22.014] result() for ClusterFuture ...
[10:24:22.014] - result already collected: FutureResult
[10:24:22.014] result() for ClusterFuture ... done
[10:24:22.014] - relayed: [n=2] TRUE, TRUE
[10:24:22.014] - queued futures: [n=2] TRUE, TRUE
[10:24:22.014] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:22.015]  length: 0 (resolved future 2)
[10:24:22.015] Relaying remaining futures
[10:24:22.015] signalConditionsASAP(NULL, pos=0) ...
[10:24:22.015] - nx: 2
[10:24:22.015] - relay: TRUE
[10:24:22.015] - stdout: TRUE
[10:24:22.015] - signal: TRUE
[10:24:22.015] - resignal: FALSE
[10:24:22.015] - force: TRUE
[10:24:22.015] - relayed: [n=2] TRUE, TRUE
[10:24:22.015] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:22.015] - relayed: [n=2] TRUE, TRUE
[10:24:22.016] - queued futures: [n=2] TRUE, TRUE
[10:24:22.016] signalConditionsASAP(NULL, pos=0) ... done
[10:24:22.016] resolve() on list ... DONE
[10:24:22.016] result() for ClusterFuture ...
[10:24:22.016] - result already collected: FutureResult
[10:24:22.016] result() for ClusterFuture ... done
[10:24:22.016] result() for ClusterFuture ...
[10:24:22.016] - result already collected: FutureResult
[10:24:22.016] result() for ClusterFuture ... done
[10:24:22.016] result() for ClusterFuture ...
[10:24:22.016] - result already collected: FutureResult
[10:24:22.017] result() for ClusterFuture ... done
[10:24:22.017] result() for ClusterFuture ...
[10:24:22.017] - result already collected: FutureResult
[10:24:22.017] result() for ClusterFuture ... done
[10:24:22.017]  - Number of value chunks collected: 2
[10:24:22.017] Resolving 2 futures (chunks) ... DONE
[10:24:22.017] Reducing values from 2 chunks ...
[10:24:22.017]  - Number of values collected after concatenation: 10
[10:24:22.017]  - Number of values expected: 10
[10:24:22.017] Reducing values from 2 chunks ... DONE
[10:24:22.017] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:24:22.018] future_lapply() ...
[10:24:22.024] Number of chunks: 2
[10:24:22.024] getGlobalsAndPackagesXApply() ...
[10:24:22.024]  - future.globals: TRUE
[10:24:22.024] getGlobalsAndPackages() ...
[10:24:22.024] Searching for globals...
[10:24:22.028] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:24:22.028] Searching for globals ... DONE
[10:24:22.028] Resolving globals: FALSE
[10:24:22.029] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[10:24:22.029] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:22.029] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:22.029] - packages: [1] ‘future.apply’
[10:24:22.030] getGlobalsAndPackages() ... DONE
[10:24:22.030]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:22.030]  - needed namespaces: [n=1] ‘future.apply’
[10:24:22.030] Finding globals ... DONE
[10:24:22.030]  - use_args: TRUE
[10:24:22.030]  - Getting '...' globals ...
[10:24:22.030] resolve() on list ...
[10:24:22.030]  recursive: 0
[10:24:22.030]  length: 1
[10:24:22.031]  elements: ‘...’
[10:24:22.031]  length: 0 (resolved future 1)
[10:24:22.031] resolve() on list ... DONE
[10:24:22.031]    - '...' content: [n=0] 
[10:24:22.031] List of 1
[10:24:22.031]  $ ...: list()
[10:24:22.031]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:22.031]  - attr(*, "where")=List of 1
[10:24:22.031]   ..$ ...:<environment: 0x55b93ddcd108> 
[10:24:22.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:22.031]  - attr(*, "resolved")= logi TRUE
[10:24:22.031]  - attr(*, "total_size")= num NA
[10:24:22.034]  - Getting '...' globals ... DONE
[10:24:22.034] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:22.034] List of 8
[10:24:22.034]  $ ...future.FUN:function (x, ...)  
[10:24:22.034]  $ x_FUN        :function (x)  
[10:24:22.034]  $ times        : int 4
[10:24:22.034]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:22.034]  $ stop_if_not  :function (...)  
[10:24:22.034]  $ dim          : int [1:2] 2 2
[10:24:22.034]  $ valid_types  : chr [1:2] "logical" "integer"
[10:24:22.034]  $ ...          : list()
[10:24:22.034]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:22.034]  - attr(*, "where")=List of 8
[10:24:22.034]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:22.034]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:22.034]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:22.034]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:22.034]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:22.034]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:22.034]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:22.034]   ..$ ...          :<environment: 0x55b93ddcd108> 
[10:24:22.034]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:22.034]  - attr(*, "resolved")= logi FALSE
[10:24:22.034]  - attr(*, "total_size")= num 97232
[10:24:22.039] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:22.039] getGlobalsAndPackagesXApply() ... DONE
[10:24:22.039] Number of futures (= number of chunks): 2
[10:24:22.040] Launching 2 futures (chunks) ...
[10:24:22.040] Chunk #1 of 2 ...
[10:24:22.040]  - Finding globals in 'X' for chunk #1 ...
[10:24:22.040] getGlobalsAndPackages() ...
[10:24:22.040] Searching for globals...
[10:24:22.040] 
[10:24:22.040] Searching for globals ... DONE
[10:24:22.040] - globals: [0] <none>
[10:24:22.041] getGlobalsAndPackages() ... DONE
[10:24:22.041]    + additional globals found: [n=0] 
[10:24:22.041]    + additional namespaces needed: [n=0] 
[10:24:22.041]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:22.041]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:22.041]  - seeds: <none>
[10:24:22.041]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.041] getGlobalsAndPackages() ...
[10:24:22.041] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.041] Resolving globals: FALSE
[10:24:22.042] Tweak future expression to call with '...' arguments ...
[10:24:22.042] {
[10:24:22.042]     do.call(function(...) {
[10:24:22.042]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.042]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:22.042]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.042]             on.exit(options(oopts), add = TRUE)
[10:24:22.042]         }
[10:24:22.042]         {
[10:24:22.042]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:22.042]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.042]                 ...future.FUN(...future.X_jj, ...)
[10:24:22.042]             })
[10:24:22.042]         }
[10:24:22.042]     }, args = future.call.arguments)
[10:24:22.042] }
[10:24:22.042] Tweak future expression to call with '...' arguments ... DONE
[10:24:22.042] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.043] - packages: [1] ‘future.apply’
[10:24:22.043] getGlobalsAndPackages() ... DONE
[10:24:22.043] run() for ‘Future’ ...
[10:24:22.043] - state: ‘created’
[10:24:22.043] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:22.057] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:22.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:22.057]   - Field: ‘node’
[10:24:22.057]   - Field: ‘label’
[10:24:22.057]   - Field: ‘local’
[10:24:22.057]   - Field: ‘owner’
[10:24:22.058]   - Field: ‘envir’
[10:24:22.058]   - Field: ‘workers’
[10:24:22.058]   - Field: ‘packages’
[10:24:22.058]   - Field: ‘gc’
[10:24:22.058]   - Field: ‘conditions’
[10:24:22.058]   - Field: ‘persistent’
[10:24:22.058]   - Field: ‘expr’
[10:24:22.058]   - Field: ‘uuid’
[10:24:22.058]   - Field: ‘seed’
[10:24:22.058]   - Field: ‘version’
[10:24:22.058]   - Field: ‘result’
[10:24:22.059]   - Field: ‘asynchronous’
[10:24:22.059]   - Field: ‘calls’
[10:24:22.059]   - Field: ‘globals’
[10:24:22.059]   - Field: ‘stdout’
[10:24:22.059]   - Field: ‘earlySignal’
[10:24:22.059]   - Field: ‘lazy’
[10:24:22.059]   - Field: ‘state’
[10:24:22.059] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:22.059] - Launch lazy future ...
[10:24:22.060] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:22.060] Packages needed by future strategies (n = 0): <none>
[10:24:22.060] {
[10:24:22.060]     {
[10:24:22.060]         {
[10:24:22.060]             ...future.startTime <- base::Sys.time()
[10:24:22.060]             {
[10:24:22.060]                 {
[10:24:22.060]                   {
[10:24:22.060]                     {
[10:24:22.060]                       {
[10:24:22.060]                         base::local({
[10:24:22.060]                           has_future <- base::requireNamespace("future", 
[10:24:22.060]                             quietly = TRUE)
[10:24:22.060]                           if (has_future) {
[10:24:22.060]                             ns <- base::getNamespace("future")
[10:24:22.060]                             version <- ns[[".package"]][["version"]]
[10:24:22.060]                             if (is.null(version)) 
[10:24:22.060]                               version <- utils::packageVersion("future")
[10:24:22.060]                           }
[10:24:22.060]                           else {
[10:24:22.060]                             version <- NULL
[10:24:22.060]                           }
[10:24:22.060]                           if (!has_future || version < "1.8.0") {
[10:24:22.060]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:22.060]                               "", base::R.version$version.string), 
[10:24:22.060]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:22.060]                                 base::R.version$platform, 8 * 
[10:24:22.060]                                   base::.Machine$sizeof.pointer), 
[10:24:22.060]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:22.060]                                 "release", "version")], collapse = " "), 
[10:24:22.060]                               hostname = base::Sys.info()[["nodename"]])
[10:24:22.060]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:22.060]                               info)
[10:24:22.060]                             info <- base::paste(info, collapse = "; ")
[10:24:22.060]                             if (!has_future) {
[10:24:22.060]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:22.060]                                 info)
[10:24:22.060]                             }
[10:24:22.060]                             else {
[10:24:22.060]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:22.060]                                 info, version)
[10:24:22.060]                             }
[10:24:22.060]                             base::stop(msg)
[10:24:22.060]                           }
[10:24:22.060]                         })
[10:24:22.060]                       }
[10:24:22.060]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:22.060]                       base::options(mc.cores = 1L)
[10:24:22.060]                     }
[10:24:22.060]                     base::local({
[10:24:22.060]                       for (pkg in "future.apply") {
[10:24:22.060]                         base::loadNamespace(pkg)
[10:24:22.060]                         base::library(pkg, character.only = TRUE)
[10:24:22.060]                       }
[10:24:22.060]                     })
[10:24:22.060]                   }
[10:24:22.060]                   options(future.plan = NULL)
[10:24:22.060]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:22.060]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:22.060]                 }
[10:24:22.060]                 ...future.workdir <- getwd()
[10:24:22.060]             }
[10:24:22.060]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:22.060]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:22.060]         }
[10:24:22.060]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:22.060]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:22.060]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:22.060]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:22.060]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:22.060]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:22.060]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:22.060]             base::names(...future.oldOptions))
[10:24:22.060]     }
[10:24:22.060]     if (FALSE) {
[10:24:22.060]     }
[10:24:22.060]     else {
[10:24:22.060]         if (TRUE) {
[10:24:22.060]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:22.060]                 open = "w")
[10:24:22.060]         }
[10:24:22.060]         else {
[10:24:22.060]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:22.060]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:22.060]         }
[10:24:22.060]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:22.060]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:22.060]             base::sink(type = "output", split = FALSE)
[10:24:22.060]             base::close(...future.stdout)
[10:24:22.060]         }, add = TRUE)
[10:24:22.060]     }
[10:24:22.060]     ...future.frame <- base::sys.nframe()
[10:24:22.060]     ...future.conditions <- base::list()
[10:24:22.060]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:22.060]     if (FALSE) {
[10:24:22.060]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:22.060]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:22.060]     }
[10:24:22.060]     ...future.result <- base::tryCatch({
[10:24:22.060]         base::withCallingHandlers({
[10:24:22.060]             ...future.value <- base::withVisible(base::local({
[10:24:22.060]                 ...future.makeSendCondition <- base::local({
[10:24:22.060]                   sendCondition <- NULL
[10:24:22.060]                   function(frame = 1L) {
[10:24:22.060]                     if (is.function(sendCondition)) 
[10:24:22.060]                       return(sendCondition)
[10:24:22.060]                     ns <- getNamespace("parallel")
[10:24:22.060]                     if (exists("sendData", mode = "function", 
[10:24:22.060]                       envir = ns)) {
[10:24:22.060]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:22.060]                         envir = ns)
[10:24:22.060]                       envir <- sys.frame(frame)
[10:24:22.060]                       master <- NULL
[10:24:22.060]                       while (!identical(envir, .GlobalEnv) && 
[10:24:22.060]                         !identical(envir, emptyenv())) {
[10:24:22.060]                         if (exists("master", mode = "list", envir = envir, 
[10:24:22.060]                           inherits = FALSE)) {
[10:24:22.060]                           master <- get("master", mode = "list", 
[10:24:22.060]                             envir = envir, inherits = FALSE)
[10:24:22.060]                           if (inherits(master, c("SOCKnode", 
[10:24:22.060]                             "SOCK0node"))) {
[10:24:22.060]                             sendCondition <<- function(cond) {
[10:24:22.060]                               data <- list(type = "VALUE", value = cond, 
[10:24:22.060]                                 success = TRUE)
[10:24:22.060]                               parallel_sendData(master, data)
[10:24:22.060]                             }
[10:24:22.060]                             return(sendCondition)
[10:24:22.060]                           }
[10:24:22.060]                         }
[10:24:22.060]                         frame <- frame + 1L
[10:24:22.060]                         envir <- sys.frame(frame)
[10:24:22.060]                       }
[10:24:22.060]                     }
[10:24:22.060]                     sendCondition <<- function(cond) NULL
[10:24:22.060]                   }
[10:24:22.060]                 })
[10:24:22.060]                 withCallingHandlers({
[10:24:22.060]                   {
[10:24:22.060]                     do.call(function(...) {
[10:24:22.060]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.060]                       if (!identical(...future.globals.maxSize.org, 
[10:24:22.060]                         ...future.globals.maxSize)) {
[10:24:22.060]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.060]                         on.exit(options(oopts), add = TRUE)
[10:24:22.060]                       }
[10:24:22.060]                       {
[10:24:22.060]                         lapply(seq_along(...future.elements_ii), 
[10:24:22.060]                           FUN = function(jj) {
[10:24:22.060]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.060]                             ...future.FUN(...future.X_jj, ...)
[10:24:22.060]                           })
[10:24:22.060]                       }
[10:24:22.060]                     }, args = future.call.arguments)
[10:24:22.060]                   }
[10:24:22.060]                 }, immediateCondition = function(cond) {
[10:24:22.060]                   sendCondition <- ...future.makeSendCondition()
[10:24:22.060]                   sendCondition(cond)
[10:24:22.060]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.060]                   {
[10:24:22.060]                     inherits <- base::inherits
[10:24:22.060]                     invokeRestart <- base::invokeRestart
[10:24:22.060]                     is.null <- base::is.null
[10:24:22.060]                     muffled <- FALSE
[10:24:22.060]                     if (inherits(cond, "message")) {
[10:24:22.060]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:22.060]                       if (muffled) 
[10:24:22.060]                         invokeRestart("muffleMessage")
[10:24:22.060]                     }
[10:24:22.060]                     else if (inherits(cond, "warning")) {
[10:24:22.060]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:22.060]                       if (muffled) 
[10:24:22.060]                         invokeRestart("muffleWarning")
[10:24:22.060]                     }
[10:24:22.060]                     else if (inherits(cond, "condition")) {
[10:24:22.060]                       if (!is.null(pattern)) {
[10:24:22.060]                         computeRestarts <- base::computeRestarts
[10:24:22.060]                         grepl <- base::grepl
[10:24:22.060]                         restarts <- computeRestarts(cond)
[10:24:22.060]                         for (restart in restarts) {
[10:24:22.060]                           name <- restart$name
[10:24:22.060]                           if (is.null(name)) 
[10:24:22.060]                             next
[10:24:22.060]                           if (!grepl(pattern, name)) 
[10:24:22.060]                             next
[10:24:22.060]                           invokeRestart(restart)
[10:24:22.060]                           muffled <- TRUE
[10:24:22.060]                           break
[10:24:22.060]                         }
[10:24:22.060]                       }
[10:24:22.060]                     }
[10:24:22.060]                     invisible(muffled)
[10:24:22.060]                   }
[10:24:22.060]                   muffleCondition(cond)
[10:24:22.060]                 })
[10:24:22.060]             }))
[10:24:22.060]             future::FutureResult(value = ...future.value$value, 
[10:24:22.060]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:22.060]                   ...future.rng), globalenv = if (FALSE) 
[10:24:22.060]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:22.060]                     ...future.globalenv.names))
[10:24:22.060]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:22.060]         }, condition = base::local({
[10:24:22.060]             c <- base::c
[10:24:22.060]             inherits <- base::inherits
[10:24:22.060]             invokeRestart <- base::invokeRestart
[10:24:22.060]             length <- base::length
[10:24:22.060]             list <- base::list
[10:24:22.060]             seq.int <- base::seq.int
[10:24:22.060]             signalCondition <- base::signalCondition
[10:24:22.060]             sys.calls <- base::sys.calls
[10:24:22.060]             `[[` <- base::`[[`
[10:24:22.060]             `+` <- base::`+`
[10:24:22.060]             `<<-` <- base::`<<-`
[10:24:22.060]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:22.060]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:22.060]                   3L)]
[10:24:22.060]             }
[10:24:22.060]             function(cond) {
[10:24:22.060]                 is_error <- inherits(cond, "error")
[10:24:22.060]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:22.060]                   NULL)
[10:24:22.060]                 if (is_error) {
[10:24:22.060]                   sessionInformation <- function() {
[10:24:22.060]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:22.060]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:22.060]                       search = base::search(), system = base::Sys.info())
[10:24:22.060]                   }
[10:24:22.060]                   ...future.conditions[[length(...future.conditions) + 
[10:24:22.060]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:22.060]                     cond$call), session = sessionInformation(), 
[10:24:22.060]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:22.060]                   signalCondition(cond)
[10:24:22.060]                 }
[10:24:22.060]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:22.060]                 "immediateCondition"))) {
[10:24:22.060]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:22.060]                   ...future.conditions[[length(...future.conditions) + 
[10:24:22.060]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:22.060]                   if (TRUE && !signal) {
[10:24:22.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.060]                     {
[10:24:22.060]                       inherits <- base::inherits
[10:24:22.060]                       invokeRestart <- base::invokeRestart
[10:24:22.060]                       is.null <- base::is.null
[10:24:22.060]                       muffled <- FALSE
[10:24:22.060]                       if (inherits(cond, "message")) {
[10:24:22.060]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:22.060]                         if (muffled) 
[10:24:22.060]                           invokeRestart("muffleMessage")
[10:24:22.060]                       }
[10:24:22.060]                       else if (inherits(cond, "warning")) {
[10:24:22.060]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:22.060]                         if (muffled) 
[10:24:22.060]                           invokeRestart("muffleWarning")
[10:24:22.060]                       }
[10:24:22.060]                       else if (inherits(cond, "condition")) {
[10:24:22.060]                         if (!is.null(pattern)) {
[10:24:22.060]                           computeRestarts <- base::computeRestarts
[10:24:22.060]                           grepl <- base::grepl
[10:24:22.060]                           restarts <- computeRestarts(cond)
[10:24:22.060]                           for (restart in restarts) {
[10:24:22.060]                             name <- restart$name
[10:24:22.060]                             if (is.null(name)) 
[10:24:22.060]                               next
[10:24:22.060]                             if (!grepl(pattern, name)) 
[10:24:22.060]                               next
[10:24:22.060]                             invokeRestart(restart)
[10:24:22.060]                             muffled <- TRUE
[10:24:22.060]                             break
[10:24:22.060]                           }
[10:24:22.060]                         }
[10:24:22.060]                       }
[10:24:22.060]                       invisible(muffled)
[10:24:22.060]                     }
[10:24:22.060]                     muffleCondition(cond, pattern = "^muffle")
[10:24:22.060]                   }
[10:24:22.060]                 }
[10:24:22.060]                 else {
[10:24:22.060]                   if (TRUE) {
[10:24:22.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.060]                     {
[10:24:22.060]                       inherits <- base::inherits
[10:24:22.060]                       invokeRestart <- base::invokeRestart
[10:24:22.060]                       is.null <- base::is.null
[10:24:22.060]                       muffled <- FALSE
[10:24:22.060]                       if (inherits(cond, "message")) {
[10:24:22.060]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:22.060]                         if (muffled) 
[10:24:22.060]                           invokeRestart("muffleMessage")
[10:24:22.060]                       }
[10:24:22.060]                       else if (inherits(cond, "warning")) {
[10:24:22.060]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:22.060]                         if (muffled) 
[10:24:22.060]                           invokeRestart("muffleWarning")
[10:24:22.060]                       }
[10:24:22.060]                       else if (inherits(cond, "condition")) {
[10:24:22.060]                         if (!is.null(pattern)) {
[10:24:22.060]                           computeRestarts <- base::computeRestarts
[10:24:22.060]                           grepl <- base::grepl
[10:24:22.060]                           restarts <- computeRestarts(cond)
[10:24:22.060]                           for (restart in restarts) {
[10:24:22.060]                             name <- restart$name
[10:24:22.060]                             if (is.null(name)) 
[10:24:22.060]                               next
[10:24:22.060]                             if (!grepl(pattern, name)) 
[10:24:22.060]                               next
[10:24:22.060]                             invokeRestart(restart)
[10:24:22.060]                             muffled <- TRUE
[10:24:22.060]                             break
[10:24:22.060]                           }
[10:24:22.060]                         }
[10:24:22.060]                       }
[10:24:22.060]                       invisible(muffled)
[10:24:22.060]                     }
[10:24:22.060]                     muffleCondition(cond, pattern = "^muffle")
[10:24:22.060]                   }
[10:24:22.060]                 }
[10:24:22.060]             }
[10:24:22.060]         }))
[10:24:22.060]     }, error = function(ex) {
[10:24:22.060]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:22.060]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:22.060]                 ...future.rng), started = ...future.startTime, 
[10:24:22.060]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:22.060]             version = "1.8"), class = "FutureResult")
[10:24:22.060]     }, finally = {
[10:24:22.060]         if (!identical(...future.workdir, getwd())) 
[10:24:22.060]             setwd(...future.workdir)
[10:24:22.060]         {
[10:24:22.060]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:22.060]                 ...future.oldOptions$nwarnings <- NULL
[10:24:22.060]             }
[10:24:22.060]             base::options(...future.oldOptions)
[10:24:22.060]             if (.Platform$OS.type == "windows") {
[10:24:22.060]                 old_names <- names(...future.oldEnvVars)
[10:24:22.060]                 envs <- base::Sys.getenv()
[10:24:22.060]                 names <- names(envs)
[10:24:22.060]                 common <- intersect(names, old_names)
[10:24:22.060]                 added <- setdiff(names, old_names)
[10:24:22.060]                 removed <- setdiff(old_names, names)
[10:24:22.060]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:22.060]                   envs[common]]
[10:24:22.060]                 NAMES <- toupper(changed)
[10:24:22.060]                 args <- list()
[10:24:22.060]                 for (kk in seq_along(NAMES)) {
[10:24:22.060]                   name <- changed[[kk]]
[10:24:22.060]                   NAME <- NAMES[[kk]]
[10:24:22.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.060]                     next
[10:24:22.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:22.060]                 }
[10:24:22.060]                 NAMES <- toupper(added)
[10:24:22.060]                 for (kk in seq_along(NAMES)) {
[10:24:22.060]                   name <- added[[kk]]
[10:24:22.060]                   NAME <- NAMES[[kk]]
[10:24:22.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.060]                     next
[10:24:22.060]                   args[[name]] <- ""
[10:24:22.060]                 }
[10:24:22.060]                 NAMES <- toupper(removed)
[10:24:22.060]                 for (kk in seq_along(NAMES)) {
[10:24:22.060]                   name <- removed[[kk]]
[10:24:22.060]                   NAME <- NAMES[[kk]]
[10:24:22.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.060]                     next
[10:24:22.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:22.060]                 }
[10:24:22.060]                 if (length(args) > 0) 
[10:24:22.060]                   base::do.call(base::Sys.setenv, args = args)
[10:24:22.060]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:22.060]             }
[10:24:22.060]             else {
[10:24:22.060]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:22.060]             }
[10:24:22.060]             {
[10:24:22.060]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:22.060]                   0L) {
[10:24:22.060]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:22.060]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:22.060]                   base::options(opts)
[10:24:22.060]                 }
[10:24:22.060]                 {
[10:24:22.060]                   {
[10:24:22.060]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:22.060]                     NULL
[10:24:22.060]                   }
[10:24:22.060]                   options(future.plan = NULL)
[10:24:22.060]                   if (is.na(NA_character_)) 
[10:24:22.060]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:22.060]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:22.060]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:22.060]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:22.060]                     envir = parent.frame()) 
[10:24:22.060]                   {
[10:24:22.060]                     if (is.function(workers)) 
[10:24:22.060]                       workers <- workers()
[10:24:22.060]                     workers <- structure(as.integer(workers), 
[10:24:22.060]                       class = class(workers))
[10:24:22.060]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:22.060]                       workers >= 1)
[10:24:22.060]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:22.060]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:22.060]                     }
[10:24:22.060]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:22.060]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:22.060]                       envir = envir)
[10:24:22.060]                     if (!future$lazy) 
[10:24:22.060]                       future <- run(future)
[10:24:22.060]                     invisible(future)
[10:24:22.060]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:22.060]                 }
[10:24:22.060]             }
[10:24:22.060]         }
[10:24:22.060]     })
[10:24:22.060]     if (TRUE) {
[10:24:22.060]         base::sink(type = "output", split = FALSE)
[10:24:22.060]         if (TRUE) {
[10:24:22.060]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:22.060]         }
[10:24:22.060]         else {
[10:24:22.060]             ...future.result["stdout"] <- base::list(NULL)
[10:24:22.060]         }
[10:24:22.060]         base::close(...future.stdout)
[10:24:22.060]         ...future.stdout <- NULL
[10:24:22.060]     }
[10:24:22.060]     ...future.result$conditions <- ...future.conditions
[10:24:22.060]     ...future.result$finished <- base::Sys.time()
[10:24:22.060]     ...future.result
[10:24:22.060] }
[10:24:22.063] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[10:24:22.063] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:22.106] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:22.106] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[10:24:22.106] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[10:24:22.106] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:22.107] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:22.107] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:22.150] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:22.150] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:22.194] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:22.194] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[10:24:22.194] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[10:24:22.194] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[10:24:22.195] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[10:24:22.195] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:22.195] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:22.196] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:24:22.196] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:24:22.196] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:22.196] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:22.197] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:22.197] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:22.197] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[10:24:22.198] MultisessionFuture started
[10:24:22.198] - Launch lazy future ... done
[10:24:22.198] run() for ‘MultisessionFuture’ ... done
[10:24:22.198] Created future:
[10:24:22.198] MultisessionFuture:
[10:24:22.198] Label: ‘future_vapply-1’
[10:24:22.198] Expression:
[10:24:22.198] {
[10:24:22.198]     do.call(function(...) {
[10:24:22.198]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.198]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:22.198]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.198]             on.exit(options(oopts), add = TRUE)
[10:24:22.198]         }
[10:24:22.198]         {
[10:24:22.198]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:22.198]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.198]                 ...future.FUN(...future.X_jj, ...)
[10:24:22.198]             })
[10:24:22.198]         }
[10:24:22.198]     }, args = future.call.arguments)
[10:24:22.198] }
[10:24:22.198] Lazy evaluation: FALSE
[10:24:22.198] Asynchronous evaluation: TRUE
[10:24:22.198] Local evaluation: TRUE
[10:24:22.198] Environment: R_GlobalEnv
[10:24:22.198] Capture standard output: TRUE
[10:24:22.198] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:22.198] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:22.198] Packages: 1 packages (‘future.apply’)
[10:24:22.198] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:22.198] Resolved: FALSE
[10:24:22.198] Value: <not collected>
[10:24:22.198] Conditions captured: <none>
[10:24:22.198] Early signaling: FALSE
[10:24:22.198] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:22.198] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:22.210] Chunk #1 of 2 ... DONE
[10:24:22.210] Chunk #2 of 2 ...
[10:24:22.210]  - Finding globals in 'X' for chunk #2 ...
[10:24:22.210] getGlobalsAndPackages() ...
[10:24:22.210] Searching for globals...
[10:24:22.211] 
[10:24:22.211] Searching for globals ... DONE
[10:24:22.211] - globals: [0] <none>
[10:24:22.211] getGlobalsAndPackages() ... DONE
[10:24:22.211]    + additional globals found: [n=0] 
[10:24:22.211]    + additional namespaces needed: [n=0] 
[10:24:22.211]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:22.211]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:22.211]  - seeds: <none>
[10:24:22.212]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.212] getGlobalsAndPackages() ...
[10:24:22.212] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.212] Resolving globals: FALSE
[10:24:22.212] Tweak future expression to call with '...' arguments ...
[10:24:22.212] {
[10:24:22.212]     do.call(function(...) {
[10:24:22.212]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.212]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:22.212]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.212]             on.exit(options(oopts), add = TRUE)
[10:24:22.212]         }
[10:24:22.212]         {
[10:24:22.212]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:22.212]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.212]                 ...future.FUN(...future.X_jj, ...)
[10:24:22.212]             })
[10:24:22.212]         }
[10:24:22.212]     }, args = future.call.arguments)
[10:24:22.212] }
[10:24:22.212] Tweak future expression to call with '...' arguments ... DONE
[10:24:22.213] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.213] - packages: [1] ‘future.apply’
[10:24:22.213] getGlobalsAndPackages() ... DONE
[10:24:22.213] run() for ‘Future’ ...
[10:24:22.214] - state: ‘created’
[10:24:22.214] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:22.228] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:22.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:22.228]   - Field: ‘node’
[10:24:22.228]   - Field: ‘label’
[10:24:22.229]   - Field: ‘local’
[10:24:22.229]   - Field: ‘owner’
[10:24:22.229]   - Field: ‘envir’
[10:24:22.229]   - Field: ‘workers’
[10:24:22.229]   - Field: ‘packages’
[10:24:22.229]   - Field: ‘gc’
[10:24:22.229]   - Field: ‘conditions’
[10:24:22.229]   - Field: ‘persistent’
[10:24:22.229]   - Field: ‘expr’
[10:24:22.230]   - Field: ‘uuid’
[10:24:22.230]   - Field: ‘seed’
[10:24:22.230]   - Field: ‘version’
[10:24:22.230]   - Field: ‘result’
[10:24:22.230]   - Field: ‘asynchronous’
[10:24:22.230]   - Field: ‘calls’
[10:24:22.230]   - Field: ‘globals’
[10:24:22.230]   - Field: ‘stdout’
[10:24:22.230]   - Field: ‘earlySignal’
[10:24:22.230]   - Field: ‘lazy’
[10:24:22.230]   - Field: ‘state’
[10:24:22.231] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:22.231] - Launch lazy future ...
[10:24:22.231] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:22.231] Packages needed by future strategies (n = 0): <none>
[10:24:22.232] {
[10:24:22.232]     {
[10:24:22.232]         {
[10:24:22.232]             ...future.startTime <- base::Sys.time()
[10:24:22.232]             {
[10:24:22.232]                 {
[10:24:22.232]                   {
[10:24:22.232]                     {
[10:24:22.232]                       {
[10:24:22.232]                         base::local({
[10:24:22.232]                           has_future <- base::requireNamespace("future", 
[10:24:22.232]                             quietly = TRUE)
[10:24:22.232]                           if (has_future) {
[10:24:22.232]                             ns <- base::getNamespace("future")
[10:24:22.232]                             version <- ns[[".package"]][["version"]]
[10:24:22.232]                             if (is.null(version)) 
[10:24:22.232]                               version <- utils::packageVersion("future")
[10:24:22.232]                           }
[10:24:22.232]                           else {
[10:24:22.232]                             version <- NULL
[10:24:22.232]                           }
[10:24:22.232]                           if (!has_future || version < "1.8.0") {
[10:24:22.232]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:22.232]                               "", base::R.version$version.string), 
[10:24:22.232]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:22.232]                                 base::R.version$platform, 8 * 
[10:24:22.232]                                   base::.Machine$sizeof.pointer), 
[10:24:22.232]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:22.232]                                 "release", "version")], collapse = " "), 
[10:24:22.232]                               hostname = base::Sys.info()[["nodename"]])
[10:24:22.232]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:22.232]                               info)
[10:24:22.232]                             info <- base::paste(info, collapse = "; ")
[10:24:22.232]                             if (!has_future) {
[10:24:22.232]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:22.232]                                 info)
[10:24:22.232]                             }
[10:24:22.232]                             else {
[10:24:22.232]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:22.232]                                 info, version)
[10:24:22.232]                             }
[10:24:22.232]                             base::stop(msg)
[10:24:22.232]                           }
[10:24:22.232]                         })
[10:24:22.232]                       }
[10:24:22.232]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:22.232]                       base::options(mc.cores = 1L)
[10:24:22.232]                     }
[10:24:22.232]                     base::local({
[10:24:22.232]                       for (pkg in "future.apply") {
[10:24:22.232]                         base::loadNamespace(pkg)
[10:24:22.232]                         base::library(pkg, character.only = TRUE)
[10:24:22.232]                       }
[10:24:22.232]                     })
[10:24:22.232]                   }
[10:24:22.232]                   options(future.plan = NULL)
[10:24:22.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:22.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:22.232]                 }
[10:24:22.232]                 ...future.workdir <- getwd()
[10:24:22.232]             }
[10:24:22.232]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:22.232]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:22.232]         }
[10:24:22.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:22.232]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:22.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:22.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:22.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:22.232]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:22.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:22.232]             base::names(...future.oldOptions))
[10:24:22.232]     }
[10:24:22.232]     if (FALSE) {
[10:24:22.232]     }
[10:24:22.232]     else {
[10:24:22.232]         if (TRUE) {
[10:24:22.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:22.232]                 open = "w")
[10:24:22.232]         }
[10:24:22.232]         else {
[10:24:22.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:22.232]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:22.232]         }
[10:24:22.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:22.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:22.232]             base::sink(type = "output", split = FALSE)
[10:24:22.232]             base::close(...future.stdout)
[10:24:22.232]         }, add = TRUE)
[10:24:22.232]     }
[10:24:22.232]     ...future.frame <- base::sys.nframe()
[10:24:22.232]     ...future.conditions <- base::list()
[10:24:22.232]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:22.232]     if (FALSE) {
[10:24:22.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:22.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:22.232]     }
[10:24:22.232]     ...future.result <- base::tryCatch({
[10:24:22.232]         base::withCallingHandlers({
[10:24:22.232]             ...future.value <- base::withVisible(base::local({
[10:24:22.232]                 ...future.makeSendCondition <- base::local({
[10:24:22.232]                   sendCondition <- NULL
[10:24:22.232]                   function(frame = 1L) {
[10:24:22.232]                     if (is.function(sendCondition)) 
[10:24:22.232]                       return(sendCondition)
[10:24:22.232]                     ns <- getNamespace("parallel")
[10:24:22.232]                     if (exists("sendData", mode = "function", 
[10:24:22.232]                       envir = ns)) {
[10:24:22.232]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:22.232]                         envir = ns)
[10:24:22.232]                       envir <- sys.frame(frame)
[10:24:22.232]                       master <- NULL
[10:24:22.232]                       while (!identical(envir, .GlobalEnv) && 
[10:24:22.232]                         !identical(envir, emptyenv())) {
[10:24:22.232]                         if (exists("master", mode = "list", envir = envir, 
[10:24:22.232]                           inherits = FALSE)) {
[10:24:22.232]                           master <- get("master", mode = "list", 
[10:24:22.232]                             envir = envir, inherits = FALSE)
[10:24:22.232]                           if (inherits(master, c("SOCKnode", 
[10:24:22.232]                             "SOCK0node"))) {
[10:24:22.232]                             sendCondition <<- function(cond) {
[10:24:22.232]                               data <- list(type = "VALUE", value = cond, 
[10:24:22.232]                                 success = TRUE)
[10:24:22.232]                               parallel_sendData(master, data)
[10:24:22.232]                             }
[10:24:22.232]                             return(sendCondition)
[10:24:22.232]                           }
[10:24:22.232]                         }
[10:24:22.232]                         frame <- frame + 1L
[10:24:22.232]                         envir <- sys.frame(frame)
[10:24:22.232]                       }
[10:24:22.232]                     }
[10:24:22.232]                     sendCondition <<- function(cond) NULL
[10:24:22.232]                   }
[10:24:22.232]                 })
[10:24:22.232]                 withCallingHandlers({
[10:24:22.232]                   {
[10:24:22.232]                     do.call(function(...) {
[10:24:22.232]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.232]                       if (!identical(...future.globals.maxSize.org, 
[10:24:22.232]                         ...future.globals.maxSize)) {
[10:24:22.232]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.232]                         on.exit(options(oopts), add = TRUE)
[10:24:22.232]                       }
[10:24:22.232]                       {
[10:24:22.232]                         lapply(seq_along(...future.elements_ii), 
[10:24:22.232]                           FUN = function(jj) {
[10:24:22.232]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.232]                             ...future.FUN(...future.X_jj, ...)
[10:24:22.232]                           })
[10:24:22.232]                       }
[10:24:22.232]                     }, args = future.call.arguments)
[10:24:22.232]                   }
[10:24:22.232]                 }, immediateCondition = function(cond) {
[10:24:22.232]                   sendCondition <- ...future.makeSendCondition()
[10:24:22.232]                   sendCondition(cond)
[10:24:22.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.232]                   {
[10:24:22.232]                     inherits <- base::inherits
[10:24:22.232]                     invokeRestart <- base::invokeRestart
[10:24:22.232]                     is.null <- base::is.null
[10:24:22.232]                     muffled <- FALSE
[10:24:22.232]                     if (inherits(cond, "message")) {
[10:24:22.232]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:22.232]                       if (muffled) 
[10:24:22.232]                         invokeRestart("muffleMessage")
[10:24:22.232]                     }
[10:24:22.232]                     else if (inherits(cond, "warning")) {
[10:24:22.232]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:22.232]                       if (muffled) 
[10:24:22.232]                         invokeRestart("muffleWarning")
[10:24:22.232]                     }
[10:24:22.232]                     else if (inherits(cond, "condition")) {
[10:24:22.232]                       if (!is.null(pattern)) {
[10:24:22.232]                         computeRestarts <- base::computeRestarts
[10:24:22.232]                         grepl <- base::grepl
[10:24:22.232]                         restarts <- computeRestarts(cond)
[10:24:22.232]                         for (restart in restarts) {
[10:24:22.232]                           name <- restart$name
[10:24:22.232]                           if (is.null(name)) 
[10:24:22.232]                             next
[10:24:22.232]                           if (!grepl(pattern, name)) 
[10:24:22.232]                             next
[10:24:22.232]                           invokeRestart(restart)
[10:24:22.232]                           muffled <- TRUE
[10:24:22.232]                           break
[10:24:22.232]                         }
[10:24:22.232]                       }
[10:24:22.232]                     }
[10:24:22.232]                     invisible(muffled)
[10:24:22.232]                   }
[10:24:22.232]                   muffleCondition(cond)
[10:24:22.232]                 })
[10:24:22.232]             }))
[10:24:22.232]             future::FutureResult(value = ...future.value$value, 
[10:24:22.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:22.232]                   ...future.rng), globalenv = if (FALSE) 
[10:24:22.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:22.232]                     ...future.globalenv.names))
[10:24:22.232]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:22.232]         }, condition = base::local({
[10:24:22.232]             c <- base::c
[10:24:22.232]             inherits <- base::inherits
[10:24:22.232]             invokeRestart <- base::invokeRestart
[10:24:22.232]             length <- base::length
[10:24:22.232]             list <- base::list
[10:24:22.232]             seq.int <- base::seq.int
[10:24:22.232]             signalCondition <- base::signalCondition
[10:24:22.232]             sys.calls <- base::sys.calls
[10:24:22.232]             `[[` <- base::`[[`
[10:24:22.232]             `+` <- base::`+`
[10:24:22.232]             `<<-` <- base::`<<-`
[10:24:22.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:22.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:22.232]                   3L)]
[10:24:22.232]             }
[10:24:22.232]             function(cond) {
[10:24:22.232]                 is_error <- inherits(cond, "error")
[10:24:22.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:22.232]                   NULL)
[10:24:22.232]                 if (is_error) {
[10:24:22.232]                   sessionInformation <- function() {
[10:24:22.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:22.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:22.232]                       search = base::search(), system = base::Sys.info())
[10:24:22.232]                   }
[10:24:22.232]                   ...future.conditions[[length(...future.conditions) + 
[10:24:22.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:22.232]                     cond$call), session = sessionInformation(), 
[10:24:22.232]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:22.232]                   signalCondition(cond)
[10:24:22.232]                 }
[10:24:22.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:22.232]                 "immediateCondition"))) {
[10:24:22.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:22.232]                   ...future.conditions[[length(...future.conditions) + 
[10:24:22.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:22.232]                   if (TRUE && !signal) {
[10:24:22.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.232]                     {
[10:24:22.232]                       inherits <- base::inherits
[10:24:22.232]                       invokeRestart <- base::invokeRestart
[10:24:22.232]                       is.null <- base::is.null
[10:24:22.232]                       muffled <- FALSE
[10:24:22.232]                       if (inherits(cond, "message")) {
[10:24:22.232]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:22.232]                         if (muffled) 
[10:24:22.232]                           invokeRestart("muffleMessage")
[10:24:22.232]                       }
[10:24:22.232]                       else if (inherits(cond, "warning")) {
[10:24:22.232]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:22.232]                         if (muffled) 
[10:24:22.232]                           invokeRestart("muffleWarning")
[10:24:22.232]                       }
[10:24:22.232]                       else if (inherits(cond, "condition")) {
[10:24:22.232]                         if (!is.null(pattern)) {
[10:24:22.232]                           computeRestarts <- base::computeRestarts
[10:24:22.232]                           grepl <- base::grepl
[10:24:22.232]                           restarts <- computeRestarts(cond)
[10:24:22.232]                           for (restart in restarts) {
[10:24:22.232]                             name <- restart$name
[10:24:22.232]                             if (is.null(name)) 
[10:24:22.232]                               next
[10:24:22.232]                             if (!grepl(pattern, name)) 
[10:24:22.232]                               next
[10:24:22.232]                             invokeRestart(restart)
[10:24:22.232]                             muffled <- TRUE
[10:24:22.232]                             break
[10:24:22.232]                           }
[10:24:22.232]                         }
[10:24:22.232]                       }
[10:24:22.232]                       invisible(muffled)
[10:24:22.232]                     }
[10:24:22.232]                     muffleCondition(cond, pattern = "^muffle")
[10:24:22.232]                   }
[10:24:22.232]                 }
[10:24:22.232]                 else {
[10:24:22.232]                   if (TRUE) {
[10:24:22.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.232]                     {
[10:24:22.232]                       inherits <- base::inherits
[10:24:22.232]                       invokeRestart <- base::invokeRestart
[10:24:22.232]                       is.null <- base::is.null
[10:24:22.232]                       muffled <- FALSE
[10:24:22.232]                       if (inherits(cond, "message")) {
[10:24:22.232]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:22.232]                         if (muffled) 
[10:24:22.232]                           invokeRestart("muffleMessage")
[10:24:22.232]                       }
[10:24:22.232]                       else if (inherits(cond, "warning")) {
[10:24:22.232]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:22.232]                         if (muffled) 
[10:24:22.232]                           invokeRestart("muffleWarning")
[10:24:22.232]                       }
[10:24:22.232]                       else if (inherits(cond, "condition")) {
[10:24:22.232]                         if (!is.null(pattern)) {
[10:24:22.232]                           computeRestarts <- base::computeRestarts
[10:24:22.232]                           grepl <- base::grepl
[10:24:22.232]                           restarts <- computeRestarts(cond)
[10:24:22.232]                           for (restart in restarts) {
[10:24:22.232]                             name <- restart$name
[10:24:22.232]                             if (is.null(name)) 
[10:24:22.232]                               next
[10:24:22.232]                             if (!grepl(pattern, name)) 
[10:24:22.232]                               next
[10:24:22.232]                             invokeRestart(restart)
[10:24:22.232]                             muffled <- TRUE
[10:24:22.232]                             break
[10:24:22.232]                           }
[10:24:22.232]                         }
[10:24:22.232]                       }
[10:24:22.232]                       invisible(muffled)
[10:24:22.232]                     }
[10:24:22.232]                     muffleCondition(cond, pattern = "^muffle")
[10:24:22.232]                   }
[10:24:22.232]                 }
[10:24:22.232]             }
[10:24:22.232]         }))
[10:24:22.232]     }, error = function(ex) {
[10:24:22.232]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:22.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:22.232]                 ...future.rng), started = ...future.startTime, 
[10:24:22.232]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:22.232]             version = "1.8"), class = "FutureResult")
[10:24:22.232]     }, finally = {
[10:24:22.232]         if (!identical(...future.workdir, getwd())) 
[10:24:22.232]             setwd(...future.workdir)
[10:24:22.232]         {
[10:24:22.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:22.232]                 ...future.oldOptions$nwarnings <- NULL
[10:24:22.232]             }
[10:24:22.232]             base::options(...future.oldOptions)
[10:24:22.232]             if (.Platform$OS.type == "windows") {
[10:24:22.232]                 old_names <- names(...future.oldEnvVars)
[10:24:22.232]                 envs <- base::Sys.getenv()
[10:24:22.232]                 names <- names(envs)
[10:24:22.232]                 common <- intersect(names, old_names)
[10:24:22.232]                 added <- setdiff(names, old_names)
[10:24:22.232]                 removed <- setdiff(old_names, names)
[10:24:22.232]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:22.232]                   envs[common]]
[10:24:22.232]                 NAMES <- toupper(changed)
[10:24:22.232]                 args <- list()
[10:24:22.232]                 for (kk in seq_along(NAMES)) {
[10:24:22.232]                   name <- changed[[kk]]
[10:24:22.232]                   NAME <- NAMES[[kk]]
[10:24:22.232]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.232]                     next
[10:24:22.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:22.232]                 }
[10:24:22.232]                 NAMES <- toupper(added)
[10:24:22.232]                 for (kk in seq_along(NAMES)) {
[10:24:22.232]                   name <- added[[kk]]
[10:24:22.232]                   NAME <- NAMES[[kk]]
[10:24:22.232]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.232]                     next
[10:24:22.232]                   args[[name]] <- ""
[10:24:22.232]                 }
[10:24:22.232]                 NAMES <- toupper(removed)
[10:24:22.232]                 for (kk in seq_along(NAMES)) {
[10:24:22.232]                   name <- removed[[kk]]
[10:24:22.232]                   NAME <- NAMES[[kk]]
[10:24:22.232]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.232]                     next
[10:24:22.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:22.232]                 }
[10:24:22.232]                 if (length(args) > 0) 
[10:24:22.232]                   base::do.call(base::Sys.setenv, args = args)
[10:24:22.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:22.232]             }
[10:24:22.232]             else {
[10:24:22.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:22.232]             }
[10:24:22.232]             {
[10:24:22.232]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:22.232]                   0L) {
[10:24:22.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:22.232]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:22.232]                   base::options(opts)
[10:24:22.232]                 }
[10:24:22.232]                 {
[10:24:22.232]                   {
[10:24:22.232]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:22.232]                     NULL
[10:24:22.232]                   }
[10:24:22.232]                   options(future.plan = NULL)
[10:24:22.232]                   if (is.na(NA_character_)) 
[10:24:22.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:22.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:22.232]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:22.232]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:22.232]                     envir = parent.frame()) 
[10:24:22.232]                   {
[10:24:22.232]                     if (is.function(workers)) 
[10:24:22.232]                       workers <- workers()
[10:24:22.232]                     workers <- structure(as.integer(workers), 
[10:24:22.232]                       class = class(workers))
[10:24:22.232]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:22.232]                       workers >= 1)
[10:24:22.232]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:22.232]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:22.232]                     }
[10:24:22.232]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:22.232]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:22.232]                       envir = envir)
[10:24:22.232]                     if (!future$lazy) 
[10:24:22.232]                       future <- run(future)
[10:24:22.232]                     invisible(future)
[10:24:22.232]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:22.232]                 }
[10:24:22.232]             }
[10:24:22.232]         }
[10:24:22.232]     })
[10:24:22.232]     if (TRUE) {
[10:24:22.232]         base::sink(type = "output", split = FALSE)
[10:24:22.232]         if (TRUE) {
[10:24:22.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:22.232]         }
[10:24:22.232]         else {
[10:24:22.232]             ...future.result["stdout"] <- base::list(NULL)
[10:24:22.232]         }
[10:24:22.232]         base::close(...future.stdout)
[10:24:22.232]         ...future.stdout <- NULL
[10:24:22.232]     }
[10:24:22.232]     ...future.result$conditions <- ...future.conditions
[10:24:22.232]     ...future.result$finished <- base::Sys.time()
[10:24:22.232]     ...future.result
[10:24:22.232] }
[10:24:22.234] Exporting 11 global objects (94.95 KiB) to cluster node #2 ...
[10:24:22.235] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:22.278] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:22.278] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[10:24:22.278] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[10:24:22.279] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:22.279] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:22.279] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:22.322] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:22.322] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:22.366] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:22.366] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[10:24:22.366] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[10:24:22.367] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[10:24:22.367] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[10:24:22.367] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:22.368] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:22.368] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:24:22.368] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:24:22.368] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:22.369] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:22.369] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:22.369] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:22.369] Exporting 11 global objects (94.95 KiB) to cluster node #2 ... DONE
[10:24:22.370] MultisessionFuture started
[10:24:22.370] - Launch lazy future ... done
[10:24:22.370] run() for ‘MultisessionFuture’ ... done
[10:24:22.370] Created future:
[10:24:22.370] MultisessionFuture:
[10:24:22.370] Label: ‘future_vapply-2’
[10:24:22.370] Expression:
[10:24:22.370] {
[10:24:22.370]     do.call(function(...) {
[10:24:22.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:22.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.370]             on.exit(options(oopts), add = TRUE)
[10:24:22.370]         }
[10:24:22.370]         {
[10:24:22.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:22.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.370]                 ...future.FUN(...future.X_jj, ...)
[10:24:22.370]             })
[10:24:22.370]         }
[10:24:22.370]     }, args = future.call.arguments)
[10:24:22.370] }
[10:24:22.370] Lazy evaluation: FALSE
[10:24:22.370] Asynchronous evaluation: TRUE
[10:24:22.370] Local evaluation: TRUE
[10:24:22.370] Environment: R_GlobalEnv
[10:24:22.370] Capture standard output: TRUE
[10:24:22.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:22.370] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:22.370] Packages: 1 packages (‘future.apply’)
[10:24:22.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:22.370] Resolved: FALSE
[10:24:22.370] Value: <not collected>
[10:24:22.370] Conditions captured: <none>
[10:24:22.370] Early signaling: FALSE
[10:24:22.370] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:22.370] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:22.382] Chunk #2 of 2 ... DONE
[10:24:22.382] Launching 2 futures (chunks) ... DONE
[10:24:22.382] Resolving 2 futures (chunks) ...
[10:24:22.383] resolve() on list ...
[10:24:22.383]  recursive: 0
[10:24:22.383]  length: 2
[10:24:22.383] 
[10:24:22.383] receiveMessageFromWorker() for ClusterFuture ...
[10:24:22.383] - Validating connection of MultisessionFuture
[10:24:22.384] - received message: FutureResult
[10:24:22.384] - Received FutureResult
[10:24:22.384] - Erased future from FutureRegistry
[10:24:22.384] result() for ClusterFuture ...
[10:24:22.384] - result already collected: FutureResult
[10:24:22.384] result() for ClusterFuture ... done
[10:24:22.384] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:22.384] Future #1
[10:24:22.384] result() for ClusterFuture ...
[10:24:22.384] - result already collected: FutureResult
[10:24:22.385] result() for ClusterFuture ... done
[10:24:22.387] result() for ClusterFuture ...
[10:24:22.387] - result already collected: FutureResult
[10:24:22.387] result() for ClusterFuture ... done
[10:24:22.388] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:22.388] - nx: 2
[10:24:22.388] - relay: TRUE
[10:24:22.388] - stdout: TRUE
[10:24:22.388] - signal: TRUE
[10:24:22.388] - resignal: FALSE
[10:24:22.388] - force: TRUE
[10:24:22.388] - relayed: [n=2] FALSE, FALSE
[10:24:22.388] - queued futures: [n=2] FALSE, FALSE
[10:24:22.388]  - until=1
[10:24:22.388]  - relaying element #1
[10:24:22.388] result() for ClusterFuture ...
[10:24:22.389] - result already collected: FutureResult
[10:24:22.389] result() for ClusterFuture ... done
[10:24:22.389] result() for ClusterFuture ...
[10:24:22.389] - result already collected: FutureResult
[10:24:22.389] result() for ClusterFuture ... done
[10:24:22.389] result() for ClusterFuture ...
[10:24:22.389] - result already collected: FutureResult
[10:24:22.389] result() for ClusterFuture ... done
[10:24:22.389] result() for ClusterFuture ...
[10:24:22.389] - result already collected: FutureResult
[10:24:22.389] result() for ClusterFuture ... done
[10:24:22.390] - relayed: [n=2] TRUE, FALSE
[10:24:22.390] - queued futures: [n=2] TRUE, FALSE
[10:24:22.390] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:22.390]  length: 1 (resolved future 1)
[10:24:22.419] receiveMessageFromWorker() for ClusterFuture ...
[10:24:22.419] - Validating connection of MultisessionFuture
[10:24:22.419] - received message: FutureResult
[10:24:22.419] - Received FutureResult
[10:24:22.419] - Erased future from FutureRegistry
[10:24:22.419] result() for ClusterFuture ...
[10:24:22.419] - result already collected: FutureResult
[10:24:22.419] result() for ClusterFuture ... done
[10:24:22.420] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:22.420] Future #2
[10:24:22.420] result() for ClusterFuture ...
[10:24:22.420] - result already collected: FutureResult
[10:24:22.420] result() for ClusterFuture ... done
[10:24:22.420] result() for ClusterFuture ...
[10:24:22.420] - result already collected: FutureResult
[10:24:22.420] result() for ClusterFuture ... done
[10:24:22.420] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:22.420] - nx: 2
[10:24:22.420] - relay: TRUE
[10:24:22.421] - stdout: TRUE
[10:24:22.421] - signal: TRUE
[10:24:22.421] - resignal: FALSE
[10:24:22.421] - force: TRUE
[10:24:22.421] - relayed: [n=2] TRUE, FALSE
[10:24:22.421] - queued futures: [n=2] TRUE, FALSE
[10:24:22.421]  - until=2
[10:24:22.421]  - relaying element #2
[10:24:22.421] result() for ClusterFuture ...
[10:24:22.421] - result already collected: FutureResult
[10:24:22.421] result() for ClusterFuture ... done
[10:24:22.422] result() for ClusterFuture ...
[10:24:22.422] - result already collected: FutureResult
[10:24:22.422] result() for ClusterFuture ... done
[10:24:22.422] result() for ClusterFuture ...
[10:24:22.422] - result already collected: FutureResult
[10:24:22.422] result() for ClusterFuture ... done
[10:24:22.422] result() for ClusterFuture ...
[10:24:22.422] - result already collected: FutureResult
[10:24:22.422] result() for ClusterFuture ... done
[10:24:22.422] - relayed: [n=2] TRUE, TRUE
[10:24:22.422] - queued futures: [n=2] TRUE, TRUE
[10:24:22.423] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:22.423]  length: 0 (resolved future 2)
[10:24:22.423] Relaying remaining futures
[10:24:22.423] signalConditionsASAP(NULL, pos=0) ...
[10:24:22.423] - nx: 2
[10:24:22.423] - relay: TRUE
[10:24:22.423] - stdout: TRUE
[10:24:22.423] - signal: TRUE
[10:24:22.423] - resignal: FALSE
[10:24:22.423] - force: TRUE
[10:24:22.423] - relayed: [n=2] TRUE, TRUE
[10:24:22.423] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:22.424] - relayed: [n=2] TRUE, TRUE
[10:24:22.424] - queued futures: [n=2] TRUE, TRUE
[10:24:22.424] signalConditionsASAP(NULL, pos=0) ... done
[10:24:22.424] resolve() on list ... DONE
[10:24:22.424] result() for ClusterFuture ...
[10:24:22.424] - result already collected: FutureResult
[10:24:22.424] result() for ClusterFuture ... done
[10:24:22.424] result() for ClusterFuture ...
[10:24:22.424] - result already collected: FutureResult
[10:24:22.424] result() for ClusterFuture ... done
[10:24:22.425] result() for ClusterFuture ...
[10:24:22.425] - result already collected: FutureResult
[10:24:22.425] result() for ClusterFuture ... done
[10:24:22.425] result() for ClusterFuture ...
[10:24:22.425] - result already collected: FutureResult
[10:24:22.425] result() for ClusterFuture ... done
[10:24:22.425]  - Number of value chunks collected: 2
[10:24:22.425] Resolving 2 futures (chunks) ... DONE
[10:24:22.425] Reducing values from 2 chunks ...
[10:24:22.425]  - Number of values collected after concatenation: 10
[10:24:22.426]  - Number of values expected: 10
[10:24:22.426] Reducing values from 2 chunks ... DONE
[10:24:22.426] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:24:22.427] future_lapply() ...
[10:24:22.432] Number of chunks: 2
[10:24:22.432] getGlobalsAndPackagesXApply() ...
[10:24:22.432]  - future.globals: TRUE
[10:24:22.433] getGlobalsAndPackages() ...
[10:24:22.433] Searching for globals...
[10:24:22.436] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:24:22.436] Searching for globals ... DONE
[10:24:22.436] Resolving globals: FALSE
[10:24:22.437] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[10:24:22.438] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:22.438] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:22.438] - packages: [1] ‘future.apply’
[10:24:22.438] getGlobalsAndPackages() ... DONE
[10:24:22.438]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:22.438]  - needed namespaces: [n=1] ‘future.apply’
[10:24:22.438] Finding globals ... DONE
[10:24:22.439]  - use_args: TRUE
[10:24:22.439]  - Getting '...' globals ...
[10:24:22.439] resolve() on list ...
[10:24:22.439]  recursive: 0
[10:24:22.439]  length: 1
[10:24:22.439]  elements: ‘...’
[10:24:22.439]  length: 0 (resolved future 1)
[10:24:22.439] resolve() on list ... DONE
[10:24:22.440]    - '...' content: [n=0] 
[10:24:22.440] List of 1
[10:24:22.440]  $ ...: list()
[10:24:22.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:22.440]  - attr(*, "where")=List of 1
[10:24:22.440]   ..$ ...:<environment: 0x55b93cc0b188> 
[10:24:22.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:22.440]  - attr(*, "resolved")= logi TRUE
[10:24:22.440]  - attr(*, "total_size")= num NA
[10:24:22.442]  - Getting '...' globals ... DONE
[10:24:22.442] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:22.443] List of 8
[10:24:22.443]  $ ...future.FUN:function (x, ...)  
[10:24:22.443]  $ x_FUN        :function (x)  
[10:24:22.443]  $ times        : int 4
[10:24:22.443]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:22.443]  $ stop_if_not  :function (...)  
[10:24:22.443]  $ dim          : int [1:2] 2 2
[10:24:22.443]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:22.443]  $ ...          : list()
[10:24:22.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:22.443]  - attr(*, "where")=List of 8
[10:24:22.443]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:22.443]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:22.443]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:22.443]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:22.443]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:22.443]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:22.443]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:22.443]   ..$ ...          :<environment: 0x55b93cc0b188> 
[10:24:22.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:22.443]  - attr(*, "resolved")= logi FALSE
[10:24:22.443]  - attr(*, "total_size")= num 97304
[10:24:22.448] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:22.448] getGlobalsAndPackagesXApply() ... DONE
[10:24:22.448] Number of futures (= number of chunks): 2
[10:24:22.448] Launching 2 futures (chunks) ...
[10:24:22.449] Chunk #1 of 2 ...
[10:24:22.449]  - Finding globals in 'X' for chunk #1 ...
[10:24:22.449] getGlobalsAndPackages() ...
[10:24:22.449] Searching for globals...
[10:24:22.449] 
[10:24:22.449] Searching for globals ... DONE
[10:24:22.449] - globals: [0] <none>
[10:24:22.449] getGlobalsAndPackages() ... DONE
[10:24:22.450]    + additional globals found: [n=0] 
[10:24:22.450]    + additional namespaces needed: [n=0] 
[10:24:22.450]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:22.450]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:22.450]  - seeds: <none>
[10:24:22.450]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.450] getGlobalsAndPackages() ...
[10:24:22.450] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.450] Resolving globals: FALSE
[10:24:22.450] Tweak future expression to call with '...' arguments ...
[10:24:22.451] {
[10:24:22.451]     do.call(function(...) {
[10:24:22.451]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.451]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:22.451]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.451]             on.exit(options(oopts), add = TRUE)
[10:24:22.451]         }
[10:24:22.451]         {
[10:24:22.451]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:22.451]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.451]                 ...future.FUN(...future.X_jj, ...)
[10:24:22.451]             })
[10:24:22.451]         }
[10:24:22.451]     }, args = future.call.arguments)
[10:24:22.451] }
[10:24:22.451] Tweak future expression to call with '...' arguments ... DONE
[10:24:22.451] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.451] - packages: [1] ‘future.apply’
[10:24:22.452] getGlobalsAndPackages() ... DONE
[10:24:22.452] run() for ‘Future’ ...
[10:24:22.452] - state: ‘created’
[10:24:22.452] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:22.466] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:22.466] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:22.466]   - Field: ‘node’
[10:24:22.466]   - Field: ‘label’
[10:24:22.466]   - Field: ‘local’
[10:24:22.466]   - Field: ‘owner’
[10:24:22.467]   - Field: ‘envir’
[10:24:22.467]   - Field: ‘workers’
[10:24:22.467]   - Field: ‘packages’
[10:24:22.467]   - Field: ‘gc’
[10:24:22.467]   - Field: ‘conditions’
[10:24:22.467]   - Field: ‘persistent’
[10:24:22.467]   - Field: ‘expr’
[10:24:22.467]   - Field: ‘uuid’
[10:24:22.467]   - Field: ‘seed’
[10:24:22.467]   - Field: ‘version’
[10:24:22.467]   - Field: ‘result’
[10:24:22.468]   - Field: ‘asynchronous’
[10:24:22.468]   - Field: ‘calls’
[10:24:22.468]   - Field: ‘globals’
[10:24:22.468]   - Field: ‘stdout’
[10:24:22.468]   - Field: ‘earlySignal’
[10:24:22.468]   - Field: ‘lazy’
[10:24:22.468]   - Field: ‘state’
[10:24:22.468] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:22.468] - Launch lazy future ...
[10:24:22.469] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:22.469] Packages needed by future strategies (n = 0): <none>
[10:24:22.469] {
[10:24:22.469]     {
[10:24:22.469]         {
[10:24:22.469]             ...future.startTime <- base::Sys.time()
[10:24:22.469]             {
[10:24:22.469]                 {
[10:24:22.469]                   {
[10:24:22.469]                     {
[10:24:22.469]                       {
[10:24:22.469]                         base::local({
[10:24:22.469]                           has_future <- base::requireNamespace("future", 
[10:24:22.469]                             quietly = TRUE)
[10:24:22.469]                           if (has_future) {
[10:24:22.469]                             ns <- base::getNamespace("future")
[10:24:22.469]                             version <- ns[[".package"]][["version"]]
[10:24:22.469]                             if (is.null(version)) 
[10:24:22.469]                               version <- utils::packageVersion("future")
[10:24:22.469]                           }
[10:24:22.469]                           else {
[10:24:22.469]                             version <- NULL
[10:24:22.469]                           }
[10:24:22.469]                           if (!has_future || version < "1.8.0") {
[10:24:22.469]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:22.469]                               "", base::R.version$version.string), 
[10:24:22.469]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:22.469]                                 base::R.version$platform, 8 * 
[10:24:22.469]                                   base::.Machine$sizeof.pointer), 
[10:24:22.469]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:22.469]                                 "release", "version")], collapse = " "), 
[10:24:22.469]                               hostname = base::Sys.info()[["nodename"]])
[10:24:22.469]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:22.469]                               info)
[10:24:22.469]                             info <- base::paste(info, collapse = "; ")
[10:24:22.469]                             if (!has_future) {
[10:24:22.469]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:22.469]                                 info)
[10:24:22.469]                             }
[10:24:22.469]                             else {
[10:24:22.469]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:22.469]                                 info, version)
[10:24:22.469]                             }
[10:24:22.469]                             base::stop(msg)
[10:24:22.469]                           }
[10:24:22.469]                         })
[10:24:22.469]                       }
[10:24:22.469]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:22.469]                       base::options(mc.cores = 1L)
[10:24:22.469]                     }
[10:24:22.469]                     base::local({
[10:24:22.469]                       for (pkg in "future.apply") {
[10:24:22.469]                         base::loadNamespace(pkg)
[10:24:22.469]                         base::library(pkg, character.only = TRUE)
[10:24:22.469]                       }
[10:24:22.469]                     })
[10:24:22.469]                   }
[10:24:22.469]                   options(future.plan = NULL)
[10:24:22.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:22.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:22.469]                 }
[10:24:22.469]                 ...future.workdir <- getwd()
[10:24:22.469]             }
[10:24:22.469]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:22.469]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:22.469]         }
[10:24:22.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:22.469]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:22.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:22.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:22.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:22.469]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:22.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:22.469]             base::names(...future.oldOptions))
[10:24:22.469]     }
[10:24:22.469]     if (FALSE) {
[10:24:22.469]     }
[10:24:22.469]     else {
[10:24:22.469]         if (TRUE) {
[10:24:22.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:22.469]                 open = "w")
[10:24:22.469]         }
[10:24:22.469]         else {
[10:24:22.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:22.469]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:22.469]         }
[10:24:22.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:22.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:22.469]             base::sink(type = "output", split = FALSE)
[10:24:22.469]             base::close(...future.stdout)
[10:24:22.469]         }, add = TRUE)
[10:24:22.469]     }
[10:24:22.469]     ...future.frame <- base::sys.nframe()
[10:24:22.469]     ...future.conditions <- base::list()
[10:24:22.469]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:22.469]     if (FALSE) {
[10:24:22.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:22.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:22.469]     }
[10:24:22.469]     ...future.result <- base::tryCatch({
[10:24:22.469]         base::withCallingHandlers({
[10:24:22.469]             ...future.value <- base::withVisible(base::local({
[10:24:22.469]                 ...future.makeSendCondition <- base::local({
[10:24:22.469]                   sendCondition <- NULL
[10:24:22.469]                   function(frame = 1L) {
[10:24:22.469]                     if (is.function(sendCondition)) 
[10:24:22.469]                       return(sendCondition)
[10:24:22.469]                     ns <- getNamespace("parallel")
[10:24:22.469]                     if (exists("sendData", mode = "function", 
[10:24:22.469]                       envir = ns)) {
[10:24:22.469]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:22.469]                         envir = ns)
[10:24:22.469]                       envir <- sys.frame(frame)
[10:24:22.469]                       master <- NULL
[10:24:22.469]                       while (!identical(envir, .GlobalEnv) && 
[10:24:22.469]                         !identical(envir, emptyenv())) {
[10:24:22.469]                         if (exists("master", mode = "list", envir = envir, 
[10:24:22.469]                           inherits = FALSE)) {
[10:24:22.469]                           master <- get("master", mode = "list", 
[10:24:22.469]                             envir = envir, inherits = FALSE)
[10:24:22.469]                           if (inherits(master, c("SOCKnode", 
[10:24:22.469]                             "SOCK0node"))) {
[10:24:22.469]                             sendCondition <<- function(cond) {
[10:24:22.469]                               data <- list(type = "VALUE", value = cond, 
[10:24:22.469]                                 success = TRUE)
[10:24:22.469]                               parallel_sendData(master, data)
[10:24:22.469]                             }
[10:24:22.469]                             return(sendCondition)
[10:24:22.469]                           }
[10:24:22.469]                         }
[10:24:22.469]                         frame <- frame + 1L
[10:24:22.469]                         envir <- sys.frame(frame)
[10:24:22.469]                       }
[10:24:22.469]                     }
[10:24:22.469]                     sendCondition <<- function(cond) NULL
[10:24:22.469]                   }
[10:24:22.469]                 })
[10:24:22.469]                 withCallingHandlers({
[10:24:22.469]                   {
[10:24:22.469]                     do.call(function(...) {
[10:24:22.469]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.469]                       if (!identical(...future.globals.maxSize.org, 
[10:24:22.469]                         ...future.globals.maxSize)) {
[10:24:22.469]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.469]                         on.exit(options(oopts), add = TRUE)
[10:24:22.469]                       }
[10:24:22.469]                       {
[10:24:22.469]                         lapply(seq_along(...future.elements_ii), 
[10:24:22.469]                           FUN = function(jj) {
[10:24:22.469]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.469]                             ...future.FUN(...future.X_jj, ...)
[10:24:22.469]                           })
[10:24:22.469]                       }
[10:24:22.469]                     }, args = future.call.arguments)
[10:24:22.469]                   }
[10:24:22.469]                 }, immediateCondition = function(cond) {
[10:24:22.469]                   sendCondition <- ...future.makeSendCondition()
[10:24:22.469]                   sendCondition(cond)
[10:24:22.469]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.469]                   {
[10:24:22.469]                     inherits <- base::inherits
[10:24:22.469]                     invokeRestart <- base::invokeRestart
[10:24:22.469]                     is.null <- base::is.null
[10:24:22.469]                     muffled <- FALSE
[10:24:22.469]                     if (inherits(cond, "message")) {
[10:24:22.469]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:22.469]                       if (muffled) 
[10:24:22.469]                         invokeRestart("muffleMessage")
[10:24:22.469]                     }
[10:24:22.469]                     else if (inherits(cond, "warning")) {
[10:24:22.469]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:22.469]                       if (muffled) 
[10:24:22.469]                         invokeRestart("muffleWarning")
[10:24:22.469]                     }
[10:24:22.469]                     else if (inherits(cond, "condition")) {
[10:24:22.469]                       if (!is.null(pattern)) {
[10:24:22.469]                         computeRestarts <- base::computeRestarts
[10:24:22.469]                         grepl <- base::grepl
[10:24:22.469]                         restarts <- computeRestarts(cond)
[10:24:22.469]                         for (restart in restarts) {
[10:24:22.469]                           name <- restart$name
[10:24:22.469]                           if (is.null(name)) 
[10:24:22.469]                             next
[10:24:22.469]                           if (!grepl(pattern, name)) 
[10:24:22.469]                             next
[10:24:22.469]                           invokeRestart(restart)
[10:24:22.469]                           muffled <- TRUE
[10:24:22.469]                           break
[10:24:22.469]                         }
[10:24:22.469]                       }
[10:24:22.469]                     }
[10:24:22.469]                     invisible(muffled)
[10:24:22.469]                   }
[10:24:22.469]                   muffleCondition(cond)
[10:24:22.469]                 })
[10:24:22.469]             }))
[10:24:22.469]             future::FutureResult(value = ...future.value$value, 
[10:24:22.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:22.469]                   ...future.rng), globalenv = if (FALSE) 
[10:24:22.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:22.469]                     ...future.globalenv.names))
[10:24:22.469]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:22.469]         }, condition = base::local({
[10:24:22.469]             c <- base::c
[10:24:22.469]             inherits <- base::inherits
[10:24:22.469]             invokeRestart <- base::invokeRestart
[10:24:22.469]             length <- base::length
[10:24:22.469]             list <- base::list
[10:24:22.469]             seq.int <- base::seq.int
[10:24:22.469]             signalCondition <- base::signalCondition
[10:24:22.469]             sys.calls <- base::sys.calls
[10:24:22.469]             `[[` <- base::`[[`
[10:24:22.469]             `+` <- base::`+`
[10:24:22.469]             `<<-` <- base::`<<-`
[10:24:22.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:22.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:22.469]                   3L)]
[10:24:22.469]             }
[10:24:22.469]             function(cond) {
[10:24:22.469]                 is_error <- inherits(cond, "error")
[10:24:22.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:22.469]                   NULL)
[10:24:22.469]                 if (is_error) {
[10:24:22.469]                   sessionInformation <- function() {
[10:24:22.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:22.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:22.469]                       search = base::search(), system = base::Sys.info())
[10:24:22.469]                   }
[10:24:22.469]                   ...future.conditions[[length(...future.conditions) + 
[10:24:22.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:22.469]                     cond$call), session = sessionInformation(), 
[10:24:22.469]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:22.469]                   signalCondition(cond)
[10:24:22.469]                 }
[10:24:22.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:22.469]                 "immediateCondition"))) {
[10:24:22.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:22.469]                   ...future.conditions[[length(...future.conditions) + 
[10:24:22.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:22.469]                   if (TRUE && !signal) {
[10:24:22.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.469]                     {
[10:24:22.469]                       inherits <- base::inherits
[10:24:22.469]                       invokeRestart <- base::invokeRestart
[10:24:22.469]                       is.null <- base::is.null
[10:24:22.469]                       muffled <- FALSE
[10:24:22.469]                       if (inherits(cond, "message")) {
[10:24:22.469]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:22.469]                         if (muffled) 
[10:24:22.469]                           invokeRestart("muffleMessage")
[10:24:22.469]                       }
[10:24:22.469]                       else if (inherits(cond, "warning")) {
[10:24:22.469]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:22.469]                         if (muffled) 
[10:24:22.469]                           invokeRestart("muffleWarning")
[10:24:22.469]                       }
[10:24:22.469]                       else if (inherits(cond, "condition")) {
[10:24:22.469]                         if (!is.null(pattern)) {
[10:24:22.469]                           computeRestarts <- base::computeRestarts
[10:24:22.469]                           grepl <- base::grepl
[10:24:22.469]                           restarts <- computeRestarts(cond)
[10:24:22.469]                           for (restart in restarts) {
[10:24:22.469]                             name <- restart$name
[10:24:22.469]                             if (is.null(name)) 
[10:24:22.469]                               next
[10:24:22.469]                             if (!grepl(pattern, name)) 
[10:24:22.469]                               next
[10:24:22.469]                             invokeRestart(restart)
[10:24:22.469]                             muffled <- TRUE
[10:24:22.469]                             break
[10:24:22.469]                           }
[10:24:22.469]                         }
[10:24:22.469]                       }
[10:24:22.469]                       invisible(muffled)
[10:24:22.469]                     }
[10:24:22.469]                     muffleCondition(cond, pattern = "^muffle")
[10:24:22.469]                   }
[10:24:22.469]                 }
[10:24:22.469]                 else {
[10:24:22.469]                   if (TRUE) {
[10:24:22.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.469]                     {
[10:24:22.469]                       inherits <- base::inherits
[10:24:22.469]                       invokeRestart <- base::invokeRestart
[10:24:22.469]                       is.null <- base::is.null
[10:24:22.469]                       muffled <- FALSE
[10:24:22.469]                       if (inherits(cond, "message")) {
[10:24:22.469]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:22.469]                         if (muffled) 
[10:24:22.469]                           invokeRestart("muffleMessage")
[10:24:22.469]                       }
[10:24:22.469]                       else if (inherits(cond, "warning")) {
[10:24:22.469]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:22.469]                         if (muffled) 
[10:24:22.469]                           invokeRestart("muffleWarning")
[10:24:22.469]                       }
[10:24:22.469]                       else if (inherits(cond, "condition")) {
[10:24:22.469]                         if (!is.null(pattern)) {
[10:24:22.469]                           computeRestarts <- base::computeRestarts
[10:24:22.469]                           grepl <- base::grepl
[10:24:22.469]                           restarts <- computeRestarts(cond)
[10:24:22.469]                           for (restart in restarts) {
[10:24:22.469]                             name <- restart$name
[10:24:22.469]                             if (is.null(name)) 
[10:24:22.469]                               next
[10:24:22.469]                             if (!grepl(pattern, name)) 
[10:24:22.469]                               next
[10:24:22.469]                             invokeRestart(restart)
[10:24:22.469]                             muffled <- TRUE
[10:24:22.469]                             break
[10:24:22.469]                           }
[10:24:22.469]                         }
[10:24:22.469]                       }
[10:24:22.469]                       invisible(muffled)
[10:24:22.469]                     }
[10:24:22.469]                     muffleCondition(cond, pattern = "^muffle")
[10:24:22.469]                   }
[10:24:22.469]                 }
[10:24:22.469]             }
[10:24:22.469]         }))
[10:24:22.469]     }, error = function(ex) {
[10:24:22.469]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:22.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:22.469]                 ...future.rng), started = ...future.startTime, 
[10:24:22.469]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:22.469]             version = "1.8"), class = "FutureResult")
[10:24:22.469]     }, finally = {
[10:24:22.469]         if (!identical(...future.workdir, getwd())) 
[10:24:22.469]             setwd(...future.workdir)
[10:24:22.469]         {
[10:24:22.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:22.469]                 ...future.oldOptions$nwarnings <- NULL
[10:24:22.469]             }
[10:24:22.469]             base::options(...future.oldOptions)
[10:24:22.469]             if (.Platform$OS.type == "windows") {
[10:24:22.469]                 old_names <- names(...future.oldEnvVars)
[10:24:22.469]                 envs <- base::Sys.getenv()
[10:24:22.469]                 names <- names(envs)
[10:24:22.469]                 common <- intersect(names, old_names)
[10:24:22.469]                 added <- setdiff(names, old_names)
[10:24:22.469]                 removed <- setdiff(old_names, names)
[10:24:22.469]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:22.469]                   envs[common]]
[10:24:22.469]                 NAMES <- toupper(changed)
[10:24:22.469]                 args <- list()
[10:24:22.469]                 for (kk in seq_along(NAMES)) {
[10:24:22.469]                   name <- changed[[kk]]
[10:24:22.469]                   NAME <- NAMES[[kk]]
[10:24:22.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.469]                     next
[10:24:22.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:22.469]                 }
[10:24:22.469]                 NAMES <- toupper(added)
[10:24:22.469]                 for (kk in seq_along(NAMES)) {
[10:24:22.469]                   name <- added[[kk]]
[10:24:22.469]                   NAME <- NAMES[[kk]]
[10:24:22.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.469]                     next
[10:24:22.469]                   args[[name]] <- ""
[10:24:22.469]                 }
[10:24:22.469]                 NAMES <- toupper(removed)
[10:24:22.469]                 for (kk in seq_along(NAMES)) {
[10:24:22.469]                   name <- removed[[kk]]
[10:24:22.469]                   NAME <- NAMES[[kk]]
[10:24:22.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.469]                     next
[10:24:22.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:22.469]                 }
[10:24:22.469]                 if (length(args) > 0) 
[10:24:22.469]                   base::do.call(base::Sys.setenv, args = args)
[10:24:22.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:22.469]             }
[10:24:22.469]             else {
[10:24:22.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:22.469]             }
[10:24:22.469]             {
[10:24:22.469]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:22.469]                   0L) {
[10:24:22.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:22.469]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:22.469]                   base::options(opts)
[10:24:22.469]                 }
[10:24:22.469]                 {
[10:24:22.469]                   {
[10:24:22.469]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:22.469]                     NULL
[10:24:22.469]                   }
[10:24:22.469]                   options(future.plan = NULL)
[10:24:22.469]                   if (is.na(NA_character_)) 
[10:24:22.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:22.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:22.469]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:22.469]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:22.469]                     envir = parent.frame()) 
[10:24:22.469]                   {
[10:24:22.469]                     if (is.function(workers)) 
[10:24:22.469]                       workers <- workers()
[10:24:22.469]                     workers <- structure(as.integer(workers), 
[10:24:22.469]                       class = class(workers))
[10:24:22.469]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:22.469]                       workers >= 1)
[10:24:22.469]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:22.469]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:22.469]                     }
[10:24:22.469]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:22.469]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:22.469]                       envir = envir)
[10:24:22.469]                     if (!future$lazy) 
[10:24:22.469]                       future <- run(future)
[10:24:22.469]                     invisible(future)
[10:24:22.469]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:22.469]                 }
[10:24:22.469]             }
[10:24:22.469]         }
[10:24:22.469]     })
[10:24:22.469]     if (TRUE) {
[10:24:22.469]         base::sink(type = "output", split = FALSE)
[10:24:22.469]         if (TRUE) {
[10:24:22.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:22.469]         }
[10:24:22.469]         else {
[10:24:22.469]             ...future.result["stdout"] <- base::list(NULL)
[10:24:22.469]         }
[10:24:22.469]         base::close(...future.stdout)
[10:24:22.469]         ...future.stdout <- NULL
[10:24:22.469]     }
[10:24:22.469]     ...future.result$conditions <- ...future.conditions
[10:24:22.469]     ...future.result$finished <- base::Sys.time()
[10:24:22.469]     ...future.result
[10:24:22.469] }
[10:24:22.472] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[10:24:22.472] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:22.514] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:22.514] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[10:24:22.514] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[10:24:22.515] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:22.515] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:22.515] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:22.558] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:22.558] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:22.602] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:22.602] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[10:24:22.602] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[10:24:22.602] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:24:22.603] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:24:22.603] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:22.604] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:22.604] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:24:22.604] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:24:22.604] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:22.605] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:22.605] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:22.605] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:22.605] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[10:24:22.606] MultisessionFuture started
[10:24:22.606] - Launch lazy future ... done
[10:24:22.606] run() for ‘MultisessionFuture’ ... done
[10:24:22.606] Created future:
[10:24:22.606] MultisessionFuture:
[10:24:22.606] Label: ‘future_vapply-1’
[10:24:22.606] Expression:
[10:24:22.606] {
[10:24:22.606]     do.call(function(...) {
[10:24:22.606]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.606]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:22.606]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.606]             on.exit(options(oopts), add = TRUE)
[10:24:22.606]         }
[10:24:22.606]         {
[10:24:22.606]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:22.606]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.606]                 ...future.FUN(...future.X_jj, ...)
[10:24:22.606]             })
[10:24:22.606]         }
[10:24:22.606]     }, args = future.call.arguments)
[10:24:22.606] }
[10:24:22.606] Lazy evaluation: FALSE
[10:24:22.606] Asynchronous evaluation: TRUE
[10:24:22.606] Local evaluation: TRUE
[10:24:22.606] Environment: R_GlobalEnv
[10:24:22.606] Capture standard output: TRUE
[10:24:22.606] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:22.606] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:22.606] Packages: 1 packages (‘future.apply’)
[10:24:22.606] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:22.606] Resolved: FALSE
[10:24:22.606] Value: <not collected>
[10:24:22.606] Conditions captured: <none>
[10:24:22.606] Early signaling: FALSE
[10:24:22.606] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:22.606] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:22.618] Chunk #1 of 2 ... DONE
[10:24:22.618] Chunk #2 of 2 ...
[10:24:22.618]  - Finding globals in 'X' for chunk #2 ...
[10:24:22.618] getGlobalsAndPackages() ...
[10:24:22.619] Searching for globals...
[10:24:22.619] 
[10:24:22.619] Searching for globals ... DONE
[10:24:22.619] - globals: [0] <none>
[10:24:22.619] getGlobalsAndPackages() ... DONE
[10:24:22.619]    + additional globals found: [n=0] 
[10:24:22.619]    + additional namespaces needed: [n=0] 
[10:24:22.619]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:22.620]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:22.620]  - seeds: <none>
[10:24:22.620]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.620] getGlobalsAndPackages() ...
[10:24:22.620] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.620] Resolving globals: FALSE
[10:24:22.620] Tweak future expression to call with '...' arguments ...
[10:24:22.620] {
[10:24:22.620]     do.call(function(...) {
[10:24:22.620]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.620]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:22.620]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.620]             on.exit(options(oopts), add = TRUE)
[10:24:22.620]         }
[10:24:22.620]         {
[10:24:22.620]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:22.620]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.620]                 ...future.FUN(...future.X_jj, ...)
[10:24:22.620]             })
[10:24:22.620]         }
[10:24:22.620]     }, args = future.call.arguments)
[10:24:22.620] }
[10:24:22.621] Tweak future expression to call with '...' arguments ... DONE
[10:24:22.621] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.621] - packages: [1] ‘future.apply’
[10:24:22.621] getGlobalsAndPackages() ... DONE
[10:24:22.622] run() for ‘Future’ ...
[10:24:22.622] - state: ‘created’
[10:24:22.622] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:22.636] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:22.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:22.637]   - Field: ‘node’
[10:24:22.637]   - Field: ‘label’
[10:24:22.637]   - Field: ‘local’
[10:24:22.637]   - Field: ‘owner’
[10:24:22.637]   - Field: ‘envir’
[10:24:22.637]   - Field: ‘workers’
[10:24:22.637]   - Field: ‘packages’
[10:24:22.637]   - Field: ‘gc’
[10:24:22.638]   - Field: ‘conditions’
[10:24:22.638]   - Field: ‘persistent’
[10:24:22.638]   - Field: ‘expr’
[10:24:22.638]   - Field: ‘uuid’
[10:24:22.638]   - Field: ‘seed’
[10:24:22.638]   - Field: ‘version’
[10:24:22.638]   - Field: ‘result’
[10:24:22.638]   - Field: ‘asynchronous’
[10:24:22.638]   - Field: ‘calls’
[10:24:22.638]   - Field: ‘globals’
[10:24:22.638]   - Field: ‘stdout’
[10:24:22.639]   - Field: ‘earlySignal’
[10:24:22.639]   - Field: ‘lazy’
[10:24:22.639]   - Field: ‘state’
[10:24:22.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:22.639] - Launch lazy future ...
[10:24:22.639] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:22.639] Packages needed by future strategies (n = 0): <none>
[10:24:22.640] {
[10:24:22.640]     {
[10:24:22.640]         {
[10:24:22.640]             ...future.startTime <- base::Sys.time()
[10:24:22.640]             {
[10:24:22.640]                 {
[10:24:22.640]                   {
[10:24:22.640]                     {
[10:24:22.640]                       {
[10:24:22.640]                         base::local({
[10:24:22.640]                           has_future <- base::requireNamespace("future", 
[10:24:22.640]                             quietly = TRUE)
[10:24:22.640]                           if (has_future) {
[10:24:22.640]                             ns <- base::getNamespace("future")
[10:24:22.640]                             version <- ns[[".package"]][["version"]]
[10:24:22.640]                             if (is.null(version)) 
[10:24:22.640]                               version <- utils::packageVersion("future")
[10:24:22.640]                           }
[10:24:22.640]                           else {
[10:24:22.640]                             version <- NULL
[10:24:22.640]                           }
[10:24:22.640]                           if (!has_future || version < "1.8.0") {
[10:24:22.640]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:22.640]                               "", base::R.version$version.string), 
[10:24:22.640]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:22.640]                                 base::R.version$platform, 8 * 
[10:24:22.640]                                   base::.Machine$sizeof.pointer), 
[10:24:22.640]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:22.640]                                 "release", "version")], collapse = " "), 
[10:24:22.640]                               hostname = base::Sys.info()[["nodename"]])
[10:24:22.640]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:22.640]                               info)
[10:24:22.640]                             info <- base::paste(info, collapse = "; ")
[10:24:22.640]                             if (!has_future) {
[10:24:22.640]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:22.640]                                 info)
[10:24:22.640]                             }
[10:24:22.640]                             else {
[10:24:22.640]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:22.640]                                 info, version)
[10:24:22.640]                             }
[10:24:22.640]                             base::stop(msg)
[10:24:22.640]                           }
[10:24:22.640]                         })
[10:24:22.640]                       }
[10:24:22.640]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:22.640]                       base::options(mc.cores = 1L)
[10:24:22.640]                     }
[10:24:22.640]                     base::local({
[10:24:22.640]                       for (pkg in "future.apply") {
[10:24:22.640]                         base::loadNamespace(pkg)
[10:24:22.640]                         base::library(pkg, character.only = TRUE)
[10:24:22.640]                       }
[10:24:22.640]                     })
[10:24:22.640]                   }
[10:24:22.640]                   options(future.plan = NULL)
[10:24:22.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:22.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:22.640]                 }
[10:24:22.640]                 ...future.workdir <- getwd()
[10:24:22.640]             }
[10:24:22.640]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:22.640]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:22.640]         }
[10:24:22.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:22.640]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:22.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:22.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:22.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:22.640]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:22.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:22.640]             base::names(...future.oldOptions))
[10:24:22.640]     }
[10:24:22.640]     if (FALSE) {
[10:24:22.640]     }
[10:24:22.640]     else {
[10:24:22.640]         if (TRUE) {
[10:24:22.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:22.640]                 open = "w")
[10:24:22.640]         }
[10:24:22.640]         else {
[10:24:22.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:22.640]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:22.640]         }
[10:24:22.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:22.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:22.640]             base::sink(type = "output", split = FALSE)
[10:24:22.640]             base::close(...future.stdout)
[10:24:22.640]         }, add = TRUE)
[10:24:22.640]     }
[10:24:22.640]     ...future.frame <- base::sys.nframe()
[10:24:22.640]     ...future.conditions <- base::list()
[10:24:22.640]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:22.640]     if (FALSE) {
[10:24:22.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:22.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:22.640]     }
[10:24:22.640]     ...future.result <- base::tryCatch({
[10:24:22.640]         base::withCallingHandlers({
[10:24:22.640]             ...future.value <- base::withVisible(base::local({
[10:24:22.640]                 ...future.makeSendCondition <- base::local({
[10:24:22.640]                   sendCondition <- NULL
[10:24:22.640]                   function(frame = 1L) {
[10:24:22.640]                     if (is.function(sendCondition)) 
[10:24:22.640]                       return(sendCondition)
[10:24:22.640]                     ns <- getNamespace("parallel")
[10:24:22.640]                     if (exists("sendData", mode = "function", 
[10:24:22.640]                       envir = ns)) {
[10:24:22.640]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:22.640]                         envir = ns)
[10:24:22.640]                       envir <- sys.frame(frame)
[10:24:22.640]                       master <- NULL
[10:24:22.640]                       while (!identical(envir, .GlobalEnv) && 
[10:24:22.640]                         !identical(envir, emptyenv())) {
[10:24:22.640]                         if (exists("master", mode = "list", envir = envir, 
[10:24:22.640]                           inherits = FALSE)) {
[10:24:22.640]                           master <- get("master", mode = "list", 
[10:24:22.640]                             envir = envir, inherits = FALSE)
[10:24:22.640]                           if (inherits(master, c("SOCKnode", 
[10:24:22.640]                             "SOCK0node"))) {
[10:24:22.640]                             sendCondition <<- function(cond) {
[10:24:22.640]                               data <- list(type = "VALUE", value = cond, 
[10:24:22.640]                                 success = TRUE)
[10:24:22.640]                               parallel_sendData(master, data)
[10:24:22.640]                             }
[10:24:22.640]                             return(sendCondition)
[10:24:22.640]                           }
[10:24:22.640]                         }
[10:24:22.640]                         frame <- frame + 1L
[10:24:22.640]                         envir <- sys.frame(frame)
[10:24:22.640]                       }
[10:24:22.640]                     }
[10:24:22.640]                     sendCondition <<- function(cond) NULL
[10:24:22.640]                   }
[10:24:22.640]                 })
[10:24:22.640]                 withCallingHandlers({
[10:24:22.640]                   {
[10:24:22.640]                     do.call(function(...) {
[10:24:22.640]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.640]                       if (!identical(...future.globals.maxSize.org, 
[10:24:22.640]                         ...future.globals.maxSize)) {
[10:24:22.640]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.640]                         on.exit(options(oopts), add = TRUE)
[10:24:22.640]                       }
[10:24:22.640]                       {
[10:24:22.640]                         lapply(seq_along(...future.elements_ii), 
[10:24:22.640]                           FUN = function(jj) {
[10:24:22.640]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.640]                             ...future.FUN(...future.X_jj, ...)
[10:24:22.640]                           })
[10:24:22.640]                       }
[10:24:22.640]                     }, args = future.call.arguments)
[10:24:22.640]                   }
[10:24:22.640]                 }, immediateCondition = function(cond) {
[10:24:22.640]                   sendCondition <- ...future.makeSendCondition()
[10:24:22.640]                   sendCondition(cond)
[10:24:22.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.640]                   {
[10:24:22.640]                     inherits <- base::inherits
[10:24:22.640]                     invokeRestart <- base::invokeRestart
[10:24:22.640]                     is.null <- base::is.null
[10:24:22.640]                     muffled <- FALSE
[10:24:22.640]                     if (inherits(cond, "message")) {
[10:24:22.640]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:22.640]                       if (muffled) 
[10:24:22.640]                         invokeRestart("muffleMessage")
[10:24:22.640]                     }
[10:24:22.640]                     else if (inherits(cond, "warning")) {
[10:24:22.640]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:22.640]                       if (muffled) 
[10:24:22.640]                         invokeRestart("muffleWarning")
[10:24:22.640]                     }
[10:24:22.640]                     else if (inherits(cond, "condition")) {
[10:24:22.640]                       if (!is.null(pattern)) {
[10:24:22.640]                         computeRestarts <- base::computeRestarts
[10:24:22.640]                         grepl <- base::grepl
[10:24:22.640]                         restarts <- computeRestarts(cond)
[10:24:22.640]                         for (restart in restarts) {
[10:24:22.640]                           name <- restart$name
[10:24:22.640]                           if (is.null(name)) 
[10:24:22.640]                             next
[10:24:22.640]                           if (!grepl(pattern, name)) 
[10:24:22.640]                             next
[10:24:22.640]                           invokeRestart(restart)
[10:24:22.640]                           muffled <- TRUE
[10:24:22.640]                           break
[10:24:22.640]                         }
[10:24:22.640]                       }
[10:24:22.640]                     }
[10:24:22.640]                     invisible(muffled)
[10:24:22.640]                   }
[10:24:22.640]                   muffleCondition(cond)
[10:24:22.640]                 })
[10:24:22.640]             }))
[10:24:22.640]             future::FutureResult(value = ...future.value$value, 
[10:24:22.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:22.640]                   ...future.rng), globalenv = if (FALSE) 
[10:24:22.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:22.640]                     ...future.globalenv.names))
[10:24:22.640]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:22.640]         }, condition = base::local({
[10:24:22.640]             c <- base::c
[10:24:22.640]             inherits <- base::inherits
[10:24:22.640]             invokeRestart <- base::invokeRestart
[10:24:22.640]             length <- base::length
[10:24:22.640]             list <- base::list
[10:24:22.640]             seq.int <- base::seq.int
[10:24:22.640]             signalCondition <- base::signalCondition
[10:24:22.640]             sys.calls <- base::sys.calls
[10:24:22.640]             `[[` <- base::`[[`
[10:24:22.640]             `+` <- base::`+`
[10:24:22.640]             `<<-` <- base::`<<-`
[10:24:22.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:22.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:22.640]                   3L)]
[10:24:22.640]             }
[10:24:22.640]             function(cond) {
[10:24:22.640]                 is_error <- inherits(cond, "error")
[10:24:22.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:22.640]                   NULL)
[10:24:22.640]                 if (is_error) {
[10:24:22.640]                   sessionInformation <- function() {
[10:24:22.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:22.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:22.640]                       search = base::search(), system = base::Sys.info())
[10:24:22.640]                   }
[10:24:22.640]                   ...future.conditions[[length(...future.conditions) + 
[10:24:22.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:22.640]                     cond$call), session = sessionInformation(), 
[10:24:22.640]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:22.640]                   signalCondition(cond)
[10:24:22.640]                 }
[10:24:22.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:22.640]                 "immediateCondition"))) {
[10:24:22.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:22.640]                   ...future.conditions[[length(...future.conditions) + 
[10:24:22.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:22.640]                   if (TRUE && !signal) {
[10:24:22.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.640]                     {
[10:24:22.640]                       inherits <- base::inherits
[10:24:22.640]                       invokeRestart <- base::invokeRestart
[10:24:22.640]                       is.null <- base::is.null
[10:24:22.640]                       muffled <- FALSE
[10:24:22.640]                       if (inherits(cond, "message")) {
[10:24:22.640]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:22.640]                         if (muffled) 
[10:24:22.640]                           invokeRestart("muffleMessage")
[10:24:22.640]                       }
[10:24:22.640]                       else if (inherits(cond, "warning")) {
[10:24:22.640]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:22.640]                         if (muffled) 
[10:24:22.640]                           invokeRestart("muffleWarning")
[10:24:22.640]                       }
[10:24:22.640]                       else if (inherits(cond, "condition")) {
[10:24:22.640]                         if (!is.null(pattern)) {
[10:24:22.640]                           computeRestarts <- base::computeRestarts
[10:24:22.640]                           grepl <- base::grepl
[10:24:22.640]                           restarts <- computeRestarts(cond)
[10:24:22.640]                           for (restart in restarts) {
[10:24:22.640]                             name <- restart$name
[10:24:22.640]                             if (is.null(name)) 
[10:24:22.640]                               next
[10:24:22.640]                             if (!grepl(pattern, name)) 
[10:24:22.640]                               next
[10:24:22.640]                             invokeRestart(restart)
[10:24:22.640]                             muffled <- TRUE
[10:24:22.640]                             break
[10:24:22.640]                           }
[10:24:22.640]                         }
[10:24:22.640]                       }
[10:24:22.640]                       invisible(muffled)
[10:24:22.640]                     }
[10:24:22.640]                     muffleCondition(cond, pattern = "^muffle")
[10:24:22.640]                   }
[10:24:22.640]                 }
[10:24:22.640]                 else {
[10:24:22.640]                   if (TRUE) {
[10:24:22.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.640]                     {
[10:24:22.640]                       inherits <- base::inherits
[10:24:22.640]                       invokeRestart <- base::invokeRestart
[10:24:22.640]                       is.null <- base::is.null
[10:24:22.640]                       muffled <- FALSE
[10:24:22.640]                       if (inherits(cond, "message")) {
[10:24:22.640]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:22.640]                         if (muffled) 
[10:24:22.640]                           invokeRestart("muffleMessage")
[10:24:22.640]                       }
[10:24:22.640]                       else if (inherits(cond, "warning")) {
[10:24:22.640]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:22.640]                         if (muffled) 
[10:24:22.640]                           invokeRestart("muffleWarning")
[10:24:22.640]                       }
[10:24:22.640]                       else if (inherits(cond, "condition")) {
[10:24:22.640]                         if (!is.null(pattern)) {
[10:24:22.640]                           computeRestarts <- base::computeRestarts
[10:24:22.640]                           grepl <- base::grepl
[10:24:22.640]                           restarts <- computeRestarts(cond)
[10:24:22.640]                           for (restart in restarts) {
[10:24:22.640]                             name <- restart$name
[10:24:22.640]                             if (is.null(name)) 
[10:24:22.640]                               next
[10:24:22.640]                             if (!grepl(pattern, name)) 
[10:24:22.640]                               next
[10:24:22.640]                             invokeRestart(restart)
[10:24:22.640]                             muffled <- TRUE
[10:24:22.640]                             break
[10:24:22.640]                           }
[10:24:22.640]                         }
[10:24:22.640]                       }
[10:24:22.640]                       invisible(muffled)
[10:24:22.640]                     }
[10:24:22.640]                     muffleCondition(cond, pattern = "^muffle")
[10:24:22.640]                   }
[10:24:22.640]                 }
[10:24:22.640]             }
[10:24:22.640]         }))
[10:24:22.640]     }, error = function(ex) {
[10:24:22.640]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:22.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:22.640]                 ...future.rng), started = ...future.startTime, 
[10:24:22.640]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:22.640]             version = "1.8"), class = "FutureResult")
[10:24:22.640]     }, finally = {
[10:24:22.640]         if (!identical(...future.workdir, getwd())) 
[10:24:22.640]             setwd(...future.workdir)
[10:24:22.640]         {
[10:24:22.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:22.640]                 ...future.oldOptions$nwarnings <- NULL
[10:24:22.640]             }
[10:24:22.640]             base::options(...future.oldOptions)
[10:24:22.640]             if (.Platform$OS.type == "windows") {
[10:24:22.640]                 old_names <- names(...future.oldEnvVars)
[10:24:22.640]                 envs <- base::Sys.getenv()
[10:24:22.640]                 names <- names(envs)
[10:24:22.640]                 common <- intersect(names, old_names)
[10:24:22.640]                 added <- setdiff(names, old_names)
[10:24:22.640]                 removed <- setdiff(old_names, names)
[10:24:22.640]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:22.640]                   envs[common]]
[10:24:22.640]                 NAMES <- toupper(changed)
[10:24:22.640]                 args <- list()
[10:24:22.640]                 for (kk in seq_along(NAMES)) {
[10:24:22.640]                   name <- changed[[kk]]
[10:24:22.640]                   NAME <- NAMES[[kk]]
[10:24:22.640]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.640]                     next
[10:24:22.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:22.640]                 }
[10:24:22.640]                 NAMES <- toupper(added)
[10:24:22.640]                 for (kk in seq_along(NAMES)) {
[10:24:22.640]                   name <- added[[kk]]
[10:24:22.640]                   NAME <- NAMES[[kk]]
[10:24:22.640]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.640]                     next
[10:24:22.640]                   args[[name]] <- ""
[10:24:22.640]                 }
[10:24:22.640]                 NAMES <- toupper(removed)
[10:24:22.640]                 for (kk in seq_along(NAMES)) {
[10:24:22.640]                   name <- removed[[kk]]
[10:24:22.640]                   NAME <- NAMES[[kk]]
[10:24:22.640]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.640]                     next
[10:24:22.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:22.640]                 }
[10:24:22.640]                 if (length(args) > 0) 
[10:24:22.640]                   base::do.call(base::Sys.setenv, args = args)
[10:24:22.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:22.640]             }
[10:24:22.640]             else {
[10:24:22.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:22.640]             }
[10:24:22.640]             {
[10:24:22.640]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:22.640]                   0L) {
[10:24:22.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:22.640]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:22.640]                   base::options(opts)
[10:24:22.640]                 }
[10:24:22.640]                 {
[10:24:22.640]                   {
[10:24:22.640]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:22.640]                     NULL
[10:24:22.640]                   }
[10:24:22.640]                   options(future.plan = NULL)
[10:24:22.640]                   if (is.na(NA_character_)) 
[10:24:22.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:22.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:22.640]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:22.640]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:22.640]                     envir = parent.frame()) 
[10:24:22.640]                   {
[10:24:22.640]                     if (is.function(workers)) 
[10:24:22.640]                       workers <- workers()
[10:24:22.640]                     workers <- structure(as.integer(workers), 
[10:24:22.640]                       class = class(workers))
[10:24:22.640]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:22.640]                       workers >= 1)
[10:24:22.640]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:22.640]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:22.640]                     }
[10:24:22.640]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:22.640]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:22.640]                       envir = envir)
[10:24:22.640]                     if (!future$lazy) 
[10:24:22.640]                       future <- run(future)
[10:24:22.640]                     invisible(future)
[10:24:22.640]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:22.640]                 }
[10:24:22.640]             }
[10:24:22.640]         }
[10:24:22.640]     })
[10:24:22.640]     if (TRUE) {
[10:24:22.640]         base::sink(type = "output", split = FALSE)
[10:24:22.640]         if (TRUE) {
[10:24:22.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:22.640]         }
[10:24:22.640]         else {
[10:24:22.640]             ...future.result["stdout"] <- base::list(NULL)
[10:24:22.640]         }
[10:24:22.640]         base::close(...future.stdout)
[10:24:22.640]         ...future.stdout <- NULL
[10:24:22.640]     }
[10:24:22.640]     ...future.result$conditions <- ...future.conditions
[10:24:22.640]     ...future.result$finished <- base::Sys.time()
[10:24:22.640]     ...future.result
[10:24:22.640] }
[10:24:22.643] Exporting 11 global objects (95.02 KiB) to cluster node #2 ...
[10:24:22.643] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:22.686] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:22.686] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[10:24:22.686] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[10:24:22.686] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:22.687] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:22.687] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:22.730] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:22.730] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:22.774] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:22.774] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[10:24:22.774] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[10:24:22.774] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:24:22.775] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:24:22.775] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:22.775] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:22.775] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:24:22.776] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:24:22.776] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:22.776] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:22.776] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:22.777] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:22.777] Exporting 11 global objects (95.02 KiB) to cluster node #2 ... DONE
[10:24:22.777] MultisessionFuture started
[10:24:22.778] - Launch lazy future ... done
[10:24:22.778] run() for ‘MultisessionFuture’ ... done
[10:24:22.778] Created future:
[10:24:22.778] MultisessionFuture:
[10:24:22.778] Label: ‘future_vapply-2’
[10:24:22.778] Expression:
[10:24:22.778] {
[10:24:22.778]     do.call(function(...) {
[10:24:22.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:22.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.778]             on.exit(options(oopts), add = TRUE)
[10:24:22.778]         }
[10:24:22.778]         {
[10:24:22.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:22.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.778]                 ...future.FUN(...future.X_jj, ...)
[10:24:22.778]             })
[10:24:22.778]         }
[10:24:22.778]     }, args = future.call.arguments)
[10:24:22.778] }
[10:24:22.778] Lazy evaluation: FALSE
[10:24:22.778] Asynchronous evaluation: TRUE
[10:24:22.778] Local evaluation: TRUE
[10:24:22.778] Environment: R_GlobalEnv
[10:24:22.778] Capture standard output: TRUE
[10:24:22.778] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:22.778] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:22.778] Packages: 1 packages (‘future.apply’)
[10:24:22.778] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:22.778] Resolved: FALSE
[10:24:22.778] Value: <not collected>
[10:24:22.778] Conditions captured: <none>
[10:24:22.778] Early signaling: FALSE
[10:24:22.778] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:22.778] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:22.790] Chunk #2 of 2 ... DONE
[10:24:22.790] Launching 2 futures (chunks) ... DONE
[10:24:22.790] Resolving 2 futures (chunks) ...
[10:24:22.790] resolve() on list ...
[10:24:22.790]  recursive: 0
[10:24:22.790]  length: 2
[10:24:22.790] 
[10:24:22.791] receiveMessageFromWorker() for ClusterFuture ...
[10:24:22.791] - Validating connection of MultisessionFuture
[10:24:22.791] - received message: FutureResult
[10:24:22.791] - Received FutureResult
[10:24:22.791] - Erased future from FutureRegistry
[10:24:22.791] result() for ClusterFuture ...
[10:24:22.791] - result already collected: FutureResult
[10:24:22.792] result() for ClusterFuture ... done
[10:24:22.792] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:22.792] Future #1
[10:24:22.792] result() for ClusterFuture ...
[10:24:22.792] - result already collected: FutureResult
[10:24:22.792] result() for ClusterFuture ... done
[10:24:22.792] result() for ClusterFuture ...
[10:24:22.792] - result already collected: FutureResult
[10:24:22.792] result() for ClusterFuture ... done
[10:24:22.792] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:22.792] - nx: 2
[10:24:22.793] - relay: TRUE
[10:24:22.793] - stdout: TRUE
[10:24:22.793] - signal: TRUE
[10:24:22.793] - resignal: FALSE
[10:24:22.793] - force: TRUE
[10:24:22.793] - relayed: [n=2] FALSE, FALSE
[10:24:22.793] - queued futures: [n=2] FALSE, FALSE
[10:24:22.793]  - until=1
[10:24:22.793]  - relaying element #1
[10:24:22.793] result() for ClusterFuture ...
[10:24:22.793] - result already collected: FutureResult
[10:24:22.794] result() for ClusterFuture ... done
[10:24:22.794] result() for ClusterFuture ...
[10:24:22.794] - result already collected: FutureResult
[10:24:22.794] result() for ClusterFuture ... done
[10:24:22.794] result() for ClusterFuture ...
[10:24:22.794] - result already collected: FutureResult
[10:24:22.794] result() for ClusterFuture ... done
[10:24:22.794] result() for ClusterFuture ...
[10:24:22.794] - result already collected: FutureResult
[10:24:22.794] result() for ClusterFuture ... done
[10:24:22.794] - relayed: [n=2] TRUE, FALSE
[10:24:22.795] - queued futures: [n=2] TRUE, FALSE
[10:24:22.795] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:22.795]  length: 1 (resolved future 1)
[10:24:22.836] receiveMessageFromWorker() for ClusterFuture ...
[10:24:22.837] - Validating connection of MultisessionFuture
[10:24:22.837] - received message: FutureResult
[10:24:22.837] - Received FutureResult
[10:24:22.837] - Erased future from FutureRegistry
[10:24:22.837] result() for ClusterFuture ...
[10:24:22.837] - result already collected: FutureResult
[10:24:22.837] result() for ClusterFuture ... done
[10:24:22.837] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:22.837] Future #2
[10:24:22.838] result() for ClusterFuture ...
[10:24:22.838] - result already collected: FutureResult
[10:24:22.838] result() for ClusterFuture ... done
[10:24:22.838] result() for ClusterFuture ...
[10:24:22.838] - result already collected: FutureResult
[10:24:22.838] result() for ClusterFuture ... done
[10:24:22.838] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:22.838] - nx: 2
[10:24:22.838] - relay: TRUE
[10:24:22.838] - stdout: TRUE
[10:24:22.838] - signal: TRUE
[10:24:22.838] - resignal: FALSE
[10:24:22.839] - force: TRUE
[10:24:22.839] - relayed: [n=2] TRUE, FALSE
[10:24:22.839] - queued futures: [n=2] TRUE, FALSE
[10:24:22.839]  - until=2
[10:24:22.839]  - relaying element #2
[10:24:22.839] result() for ClusterFuture ...
[10:24:22.839] - result already collected: FutureResult
[10:24:22.839] result() for ClusterFuture ... done
[10:24:22.839] result() for ClusterFuture ...
[10:24:22.839] - result already collected: FutureResult
[10:24:22.839] result() for ClusterFuture ... done
[10:24:22.840] result() for ClusterFuture ...
[10:24:22.840] - result already collected: FutureResult
[10:24:22.840] result() for ClusterFuture ... done
[10:24:22.840] result() for ClusterFuture ...
[10:24:22.840] - result already collected: FutureResult
[10:24:22.840] result() for ClusterFuture ... done
[10:24:22.840] - relayed: [n=2] TRUE, TRUE
[10:24:22.840] - queued futures: [n=2] TRUE, TRUE
[10:24:22.840] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:22.840]  length: 0 (resolved future 2)
[10:24:22.840] Relaying remaining futures
[10:24:22.841] signalConditionsASAP(NULL, pos=0) ...
[10:24:22.841] - nx: 2
[10:24:22.841] - relay: TRUE
[10:24:22.841] - stdout: TRUE
[10:24:22.841] - signal: TRUE
[10:24:22.841] - resignal: FALSE
[10:24:22.841] - force: TRUE
[10:24:22.841] - relayed: [n=2] TRUE, TRUE
[10:24:22.841] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:22.841] - relayed: [n=2] TRUE, TRUE
[10:24:22.841] - queued futures: [n=2] TRUE, TRUE
[10:24:22.842] signalConditionsASAP(NULL, pos=0) ... done
[10:24:22.842] resolve() on list ... DONE
[10:24:22.842] result() for ClusterFuture ...
[10:24:22.842] - result already collected: FutureResult
[10:24:22.842] result() for ClusterFuture ... done
[10:24:22.842] result() for ClusterFuture ...
[10:24:22.842] - result already collected: FutureResult
[10:24:22.842] result() for ClusterFuture ... done
[10:24:22.842] result() for ClusterFuture ...
[10:24:22.842] - result already collected: FutureResult
[10:24:22.842] result() for ClusterFuture ... done
[10:24:22.842] result() for ClusterFuture ...
[10:24:22.843] - result already collected: FutureResult
[10:24:22.843] result() for ClusterFuture ... done
[10:24:22.843]  - Number of value chunks collected: 2
[10:24:22.843] Resolving 2 futures (chunks) ... DONE
[10:24:22.843] Reducing values from 2 chunks ...
[10:24:22.843]  - Number of values collected after concatenation: 10
[10:24:22.843]  - Number of values expected: 10
[10:24:22.843] Reducing values from 2 chunks ... DONE
[10:24:22.843] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[10:24:22.845] future_lapply() ...
[10:24:22.850] Number of chunks: 2
[10:24:22.851] getGlobalsAndPackagesXApply() ...
[10:24:22.851]  - future.globals: TRUE
[10:24:22.851] getGlobalsAndPackages() ...
[10:24:22.851] Searching for globals...
[10:24:22.857] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[10:24:22.857] Searching for globals ... DONE
[10:24:22.857] Resolving globals: FALSE
[10:24:22.858] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[10:24:22.858] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:22.859] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:22.859] - packages: [1] ‘future.apply’
[10:24:22.859] getGlobalsAndPackages() ... DONE
[10:24:22.859]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:22.859]  - needed namespaces: [n=1] ‘future.apply’
[10:24:22.859] Finding globals ... DONE
[10:24:22.859]  - use_args: TRUE
[10:24:22.859]  - Getting '...' globals ...
[10:24:22.860] resolve() on list ...
[10:24:22.860]  recursive: 0
[10:24:22.860]  length: 1
[10:24:22.860]  elements: ‘...’
[10:24:22.860]  length: 0 (resolved future 1)
[10:24:22.860] resolve() on list ... DONE
[10:24:22.860]    - '...' content: [n=0] 
[10:24:22.860] List of 1
[10:24:22.860]  $ ...: list()
[10:24:22.860]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:22.860]  - attr(*, "where")=List of 1
[10:24:22.860]   ..$ ...:<environment: 0x55b93f1a3740> 
[10:24:22.860]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:22.860]  - attr(*, "resolved")= logi TRUE
[10:24:22.860]  - attr(*, "total_size")= num NA
[10:24:22.863]  - Getting '...' globals ... DONE
[10:24:22.863] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:22.863] List of 8
[10:24:22.863]  $ ...future.FUN:function (x, ...)  
[10:24:22.863]  $ x_FUN        :function (x)  
[10:24:22.863]  $ times        : int 4
[10:24:22.863]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:22.863]  $ stop_if_not  :function (...)  
[10:24:22.863]  $ dim          : int [1:2] 2 2
[10:24:22.863]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:22.863]  $ ...          : list()
[10:24:22.863]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:22.863]  - attr(*, "where")=List of 8
[10:24:22.863]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:22.863]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:22.863]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:22.863]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:22.863]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:22.863]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:22.863]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:22.863]   ..$ ...          :<environment: 0x55b93f1a3740> 
[10:24:22.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:22.863]  - attr(*, "resolved")= logi FALSE
[10:24:22.863]  - attr(*, "total_size")= num 105552
[10:24:22.869] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:22.869] getGlobalsAndPackagesXApply() ... DONE
[10:24:22.869] Number of futures (= number of chunks): 2
[10:24:22.869] Launching 2 futures (chunks) ...
[10:24:22.869] Chunk #1 of 2 ...
[10:24:22.869]  - Finding globals in 'X' for chunk #1 ...
[10:24:22.870] getGlobalsAndPackages() ...
[10:24:22.870] Searching for globals...
[10:24:22.870] 
[10:24:22.870] Searching for globals ... DONE
[10:24:22.870] - globals: [0] <none>
[10:24:22.870] getGlobalsAndPackages() ... DONE
[10:24:22.870]    + additional globals found: [n=0] 
[10:24:22.870]    + additional namespaces needed: [n=0] 
[10:24:22.870]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:22.871]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:22.871]  - seeds: <none>
[10:24:22.871]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.871] getGlobalsAndPackages() ...
[10:24:22.871] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.871] Resolving globals: FALSE
[10:24:22.871] Tweak future expression to call with '...' arguments ...
[10:24:22.871] {
[10:24:22.871]     do.call(function(...) {
[10:24:22.871]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.871]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:22.871]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.871]             on.exit(options(oopts), add = TRUE)
[10:24:22.871]         }
[10:24:22.871]         {
[10:24:22.871]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:22.871]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.871]                 ...future.FUN(...future.X_jj, ...)
[10:24:22.871]             })
[10:24:22.871]         }
[10:24:22.871]     }, args = future.call.arguments)
[10:24:22.871] }
[10:24:22.872] Tweak future expression to call with '...' arguments ... DONE
[10:24:22.872] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:22.872] - packages: [1] ‘future.apply’
[10:24:22.872] getGlobalsAndPackages() ... DONE
[10:24:22.873] run() for ‘Future’ ...
[10:24:22.873] - state: ‘created’
[10:24:22.873] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:22.886] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:22.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:22.887]   - Field: ‘node’
[10:24:22.887]   - Field: ‘label’
[10:24:22.887]   - Field: ‘local’
[10:24:22.887]   - Field: ‘owner’
[10:24:22.887]   - Field: ‘envir’
[10:24:22.887]   - Field: ‘workers’
[10:24:22.887]   - Field: ‘packages’
[10:24:22.887]   - Field: ‘gc’
[10:24:22.887]   - Field: ‘conditions’
[10:24:22.887]   - Field: ‘persistent’
[10:24:22.887]   - Field: ‘expr’
[10:24:22.888]   - Field: ‘uuid’
[10:24:22.888]   - Field: ‘seed’
[10:24:22.888]   - Field: ‘version’
[10:24:22.888]   - Field: ‘result’
[10:24:22.888]   - Field: ‘asynchronous’
[10:24:22.888]   - Field: ‘calls’
[10:24:22.888]   - Field: ‘globals’
[10:24:22.888]   - Field: ‘stdout’
[10:24:22.888]   - Field: ‘earlySignal’
[10:24:22.888]   - Field: ‘lazy’
[10:24:22.888]   - Field: ‘state’
[10:24:22.889] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:22.889] - Launch lazy future ...
[10:24:22.889] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:22.889] Packages needed by future strategies (n = 0): <none>
[10:24:22.890] {
[10:24:22.890]     {
[10:24:22.890]         {
[10:24:22.890]             ...future.startTime <- base::Sys.time()
[10:24:22.890]             {
[10:24:22.890]                 {
[10:24:22.890]                   {
[10:24:22.890]                     {
[10:24:22.890]                       {
[10:24:22.890]                         base::local({
[10:24:22.890]                           has_future <- base::requireNamespace("future", 
[10:24:22.890]                             quietly = TRUE)
[10:24:22.890]                           if (has_future) {
[10:24:22.890]                             ns <- base::getNamespace("future")
[10:24:22.890]                             version <- ns[[".package"]][["version"]]
[10:24:22.890]                             if (is.null(version)) 
[10:24:22.890]                               version <- utils::packageVersion("future")
[10:24:22.890]                           }
[10:24:22.890]                           else {
[10:24:22.890]                             version <- NULL
[10:24:22.890]                           }
[10:24:22.890]                           if (!has_future || version < "1.8.0") {
[10:24:22.890]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:22.890]                               "", base::R.version$version.string), 
[10:24:22.890]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:22.890]                                 base::R.version$platform, 8 * 
[10:24:22.890]                                   base::.Machine$sizeof.pointer), 
[10:24:22.890]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:22.890]                                 "release", "version")], collapse = " "), 
[10:24:22.890]                               hostname = base::Sys.info()[["nodename"]])
[10:24:22.890]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:22.890]                               info)
[10:24:22.890]                             info <- base::paste(info, collapse = "; ")
[10:24:22.890]                             if (!has_future) {
[10:24:22.890]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:22.890]                                 info)
[10:24:22.890]                             }
[10:24:22.890]                             else {
[10:24:22.890]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:22.890]                                 info, version)
[10:24:22.890]                             }
[10:24:22.890]                             base::stop(msg)
[10:24:22.890]                           }
[10:24:22.890]                         })
[10:24:22.890]                       }
[10:24:22.890]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:22.890]                       base::options(mc.cores = 1L)
[10:24:22.890]                     }
[10:24:22.890]                     base::local({
[10:24:22.890]                       for (pkg in "future.apply") {
[10:24:22.890]                         base::loadNamespace(pkg)
[10:24:22.890]                         base::library(pkg, character.only = TRUE)
[10:24:22.890]                       }
[10:24:22.890]                     })
[10:24:22.890]                   }
[10:24:22.890]                   options(future.plan = NULL)
[10:24:22.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:22.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:22.890]                 }
[10:24:22.890]                 ...future.workdir <- getwd()
[10:24:22.890]             }
[10:24:22.890]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:22.890]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:22.890]         }
[10:24:22.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:22.890]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:22.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:22.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:22.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:22.890]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:22.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:22.890]             base::names(...future.oldOptions))
[10:24:22.890]     }
[10:24:22.890]     if (FALSE) {
[10:24:22.890]     }
[10:24:22.890]     else {
[10:24:22.890]         if (TRUE) {
[10:24:22.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:22.890]                 open = "w")
[10:24:22.890]         }
[10:24:22.890]         else {
[10:24:22.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:22.890]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:22.890]         }
[10:24:22.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:22.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:22.890]             base::sink(type = "output", split = FALSE)
[10:24:22.890]             base::close(...future.stdout)
[10:24:22.890]         }, add = TRUE)
[10:24:22.890]     }
[10:24:22.890]     ...future.frame <- base::sys.nframe()
[10:24:22.890]     ...future.conditions <- base::list()
[10:24:22.890]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:22.890]     if (FALSE) {
[10:24:22.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:22.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:22.890]     }
[10:24:22.890]     ...future.result <- base::tryCatch({
[10:24:22.890]         base::withCallingHandlers({
[10:24:22.890]             ...future.value <- base::withVisible(base::local({
[10:24:22.890]                 ...future.makeSendCondition <- base::local({
[10:24:22.890]                   sendCondition <- NULL
[10:24:22.890]                   function(frame = 1L) {
[10:24:22.890]                     if (is.function(sendCondition)) 
[10:24:22.890]                       return(sendCondition)
[10:24:22.890]                     ns <- getNamespace("parallel")
[10:24:22.890]                     if (exists("sendData", mode = "function", 
[10:24:22.890]                       envir = ns)) {
[10:24:22.890]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:22.890]                         envir = ns)
[10:24:22.890]                       envir <- sys.frame(frame)
[10:24:22.890]                       master <- NULL
[10:24:22.890]                       while (!identical(envir, .GlobalEnv) && 
[10:24:22.890]                         !identical(envir, emptyenv())) {
[10:24:22.890]                         if (exists("master", mode = "list", envir = envir, 
[10:24:22.890]                           inherits = FALSE)) {
[10:24:22.890]                           master <- get("master", mode = "list", 
[10:24:22.890]                             envir = envir, inherits = FALSE)
[10:24:22.890]                           if (inherits(master, c("SOCKnode", 
[10:24:22.890]                             "SOCK0node"))) {
[10:24:22.890]                             sendCondition <<- function(cond) {
[10:24:22.890]                               data <- list(type = "VALUE", value = cond, 
[10:24:22.890]                                 success = TRUE)
[10:24:22.890]                               parallel_sendData(master, data)
[10:24:22.890]                             }
[10:24:22.890]                             return(sendCondition)
[10:24:22.890]                           }
[10:24:22.890]                         }
[10:24:22.890]                         frame <- frame + 1L
[10:24:22.890]                         envir <- sys.frame(frame)
[10:24:22.890]                       }
[10:24:22.890]                     }
[10:24:22.890]                     sendCondition <<- function(cond) NULL
[10:24:22.890]                   }
[10:24:22.890]                 })
[10:24:22.890]                 withCallingHandlers({
[10:24:22.890]                   {
[10:24:22.890]                     do.call(function(...) {
[10:24:22.890]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:22.890]                       if (!identical(...future.globals.maxSize.org, 
[10:24:22.890]                         ...future.globals.maxSize)) {
[10:24:22.890]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:22.890]                         on.exit(options(oopts), add = TRUE)
[10:24:22.890]                       }
[10:24:22.890]                       {
[10:24:22.890]                         lapply(seq_along(...future.elements_ii), 
[10:24:22.890]                           FUN = function(jj) {
[10:24:22.890]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:22.890]                             ...future.FUN(...future.X_jj, ...)
[10:24:22.890]                           })
[10:24:22.890]                       }
[10:24:22.890]                     }, args = future.call.arguments)
[10:24:22.890]                   }
[10:24:22.890]                 }, immediateCondition = function(cond) {
[10:24:22.890]                   sendCondition <- ...future.makeSendCondition()
[10:24:22.890]                   sendCondition(cond)
[10:24:22.890]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.890]                   {
[10:24:22.890]                     inherits <- base::inherits
[10:24:22.890]                     invokeRestart <- base::invokeRestart
[10:24:22.890]                     is.null <- base::is.null
[10:24:22.890]                     muffled <- FALSE
[10:24:22.890]                     if (inherits(cond, "message")) {
[10:24:22.890]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:22.890]                       if (muffled) 
[10:24:22.890]                         invokeRestart("muffleMessage")
[10:24:22.890]                     }
[10:24:22.890]                     else if (inherits(cond, "warning")) {
[10:24:22.890]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:22.890]                       if (muffled) 
[10:24:22.890]                         invokeRestart("muffleWarning")
[10:24:22.890]                     }
[10:24:22.890]                     else if (inherits(cond, "condition")) {
[10:24:22.890]                       if (!is.null(pattern)) {
[10:24:22.890]                         computeRestarts <- base::computeRestarts
[10:24:22.890]                         grepl <- base::grepl
[10:24:22.890]                         restarts <- computeRestarts(cond)
[10:24:22.890]                         for (restart in restarts) {
[10:24:22.890]                           name <- restart$name
[10:24:22.890]                           if (is.null(name)) 
[10:24:22.890]                             next
[10:24:22.890]                           if (!grepl(pattern, name)) 
[10:24:22.890]                             next
[10:24:22.890]                           invokeRestart(restart)
[10:24:22.890]                           muffled <- TRUE
[10:24:22.890]                           break
[10:24:22.890]                         }
[10:24:22.890]                       }
[10:24:22.890]                     }
[10:24:22.890]                     invisible(muffled)
[10:24:22.890]                   }
[10:24:22.890]                   muffleCondition(cond)
[10:24:22.890]                 })
[10:24:22.890]             }))
[10:24:22.890]             future::FutureResult(value = ...future.value$value, 
[10:24:22.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:22.890]                   ...future.rng), globalenv = if (FALSE) 
[10:24:22.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:22.890]                     ...future.globalenv.names))
[10:24:22.890]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:22.890]         }, condition = base::local({
[10:24:22.890]             c <- base::c
[10:24:22.890]             inherits <- base::inherits
[10:24:22.890]             invokeRestart <- base::invokeRestart
[10:24:22.890]             length <- base::length
[10:24:22.890]             list <- base::list
[10:24:22.890]             seq.int <- base::seq.int
[10:24:22.890]             signalCondition <- base::signalCondition
[10:24:22.890]             sys.calls <- base::sys.calls
[10:24:22.890]             `[[` <- base::`[[`
[10:24:22.890]             `+` <- base::`+`
[10:24:22.890]             `<<-` <- base::`<<-`
[10:24:22.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:22.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:22.890]                   3L)]
[10:24:22.890]             }
[10:24:22.890]             function(cond) {
[10:24:22.890]                 is_error <- inherits(cond, "error")
[10:24:22.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:22.890]                   NULL)
[10:24:22.890]                 if (is_error) {
[10:24:22.890]                   sessionInformation <- function() {
[10:24:22.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:22.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:22.890]                       search = base::search(), system = base::Sys.info())
[10:24:22.890]                   }
[10:24:22.890]                   ...future.conditions[[length(...future.conditions) + 
[10:24:22.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:22.890]                     cond$call), session = sessionInformation(), 
[10:24:22.890]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:22.890]                   signalCondition(cond)
[10:24:22.890]                 }
[10:24:22.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:22.890]                 "immediateCondition"))) {
[10:24:22.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:22.890]                   ...future.conditions[[length(...future.conditions) + 
[10:24:22.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:22.890]                   if (TRUE && !signal) {
[10:24:22.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.890]                     {
[10:24:22.890]                       inherits <- base::inherits
[10:24:22.890]                       invokeRestart <- base::invokeRestart
[10:24:22.890]                       is.null <- base::is.null
[10:24:22.890]                       muffled <- FALSE
[10:24:22.890]                       if (inherits(cond, "message")) {
[10:24:22.890]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:22.890]                         if (muffled) 
[10:24:22.890]                           invokeRestart("muffleMessage")
[10:24:22.890]                       }
[10:24:22.890]                       else if (inherits(cond, "warning")) {
[10:24:22.890]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:22.890]                         if (muffled) 
[10:24:22.890]                           invokeRestart("muffleWarning")
[10:24:22.890]                       }
[10:24:22.890]                       else if (inherits(cond, "condition")) {
[10:24:22.890]                         if (!is.null(pattern)) {
[10:24:22.890]                           computeRestarts <- base::computeRestarts
[10:24:22.890]                           grepl <- base::grepl
[10:24:22.890]                           restarts <- computeRestarts(cond)
[10:24:22.890]                           for (restart in restarts) {
[10:24:22.890]                             name <- restart$name
[10:24:22.890]                             if (is.null(name)) 
[10:24:22.890]                               next
[10:24:22.890]                             if (!grepl(pattern, name)) 
[10:24:22.890]                               next
[10:24:22.890]                             invokeRestart(restart)
[10:24:22.890]                             muffled <- TRUE
[10:24:22.890]                             break
[10:24:22.890]                           }
[10:24:22.890]                         }
[10:24:22.890]                       }
[10:24:22.890]                       invisible(muffled)
[10:24:22.890]                     }
[10:24:22.890]                     muffleCondition(cond, pattern = "^muffle")
[10:24:22.890]                   }
[10:24:22.890]                 }
[10:24:22.890]                 else {
[10:24:22.890]                   if (TRUE) {
[10:24:22.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:22.890]                     {
[10:24:22.890]                       inherits <- base::inherits
[10:24:22.890]                       invokeRestart <- base::invokeRestart
[10:24:22.890]                       is.null <- base::is.null
[10:24:22.890]                       muffled <- FALSE
[10:24:22.890]                       if (inherits(cond, "message")) {
[10:24:22.890]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:22.890]                         if (muffled) 
[10:24:22.890]                           invokeRestart("muffleMessage")
[10:24:22.890]                       }
[10:24:22.890]                       else if (inherits(cond, "warning")) {
[10:24:22.890]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:22.890]                         if (muffled) 
[10:24:22.890]                           invokeRestart("muffleWarning")
[10:24:22.890]                       }
[10:24:22.890]                       else if (inherits(cond, "condition")) {
[10:24:22.890]                         if (!is.null(pattern)) {
[10:24:22.890]                           computeRestarts <- base::computeRestarts
[10:24:22.890]                           grepl <- base::grepl
[10:24:22.890]                           restarts <- computeRestarts(cond)
[10:24:22.890]                           for (restart in restarts) {
[10:24:22.890]                             name <- restart$name
[10:24:22.890]                             if (is.null(name)) 
[10:24:22.890]                               next
[10:24:22.890]                             if (!grepl(pattern, name)) 
[10:24:22.890]                               next
[10:24:22.890]                             invokeRestart(restart)
[10:24:22.890]                             muffled <- TRUE
[10:24:22.890]                             break
[10:24:22.890]                           }
[10:24:22.890]                         }
[10:24:22.890]                       }
[10:24:22.890]                       invisible(muffled)
[10:24:22.890]                     }
[10:24:22.890]                     muffleCondition(cond, pattern = "^muffle")
[10:24:22.890]                   }
[10:24:22.890]                 }
[10:24:22.890]             }
[10:24:22.890]         }))
[10:24:22.890]     }, error = function(ex) {
[10:24:22.890]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:22.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:22.890]                 ...future.rng), started = ...future.startTime, 
[10:24:22.890]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:22.890]             version = "1.8"), class = "FutureResult")
[10:24:22.890]     }, finally = {
[10:24:22.890]         if (!identical(...future.workdir, getwd())) 
[10:24:22.890]             setwd(...future.workdir)
[10:24:22.890]         {
[10:24:22.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:22.890]                 ...future.oldOptions$nwarnings <- NULL
[10:24:22.890]             }
[10:24:22.890]             base::options(...future.oldOptions)
[10:24:22.890]             if (.Platform$OS.type == "windows") {
[10:24:22.890]                 old_names <- names(...future.oldEnvVars)
[10:24:22.890]                 envs <- base::Sys.getenv()
[10:24:22.890]                 names <- names(envs)
[10:24:22.890]                 common <- intersect(names, old_names)
[10:24:22.890]                 added <- setdiff(names, old_names)
[10:24:22.890]                 removed <- setdiff(old_names, names)
[10:24:22.890]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:22.890]                   envs[common]]
[10:24:22.890]                 NAMES <- toupper(changed)
[10:24:22.890]                 args <- list()
[10:24:22.890]                 for (kk in seq_along(NAMES)) {
[10:24:22.890]                   name <- changed[[kk]]
[10:24:22.890]                   NAME <- NAMES[[kk]]
[10:24:22.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.890]                     next
[10:24:22.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:22.890]                 }
[10:24:22.890]                 NAMES <- toupper(added)
[10:24:22.890]                 for (kk in seq_along(NAMES)) {
[10:24:22.890]                   name <- added[[kk]]
[10:24:22.890]                   NAME <- NAMES[[kk]]
[10:24:22.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.890]                     next
[10:24:22.890]                   args[[name]] <- ""
[10:24:22.890]                 }
[10:24:22.890]                 NAMES <- toupper(removed)
[10:24:22.890]                 for (kk in seq_along(NAMES)) {
[10:24:22.890]                   name <- removed[[kk]]
[10:24:22.890]                   NAME <- NAMES[[kk]]
[10:24:22.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:22.890]                     next
[10:24:22.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:22.890]                 }
[10:24:22.890]                 if (length(args) > 0) 
[10:24:22.890]                   base::do.call(base::Sys.setenv, args = args)
[10:24:22.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:22.890]             }
[10:24:22.890]             else {
[10:24:22.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:22.890]             }
[10:24:22.890]             {
[10:24:22.890]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:22.890]                   0L) {
[10:24:22.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:22.890]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:22.890]                   base::options(opts)
[10:24:22.890]                 }
[10:24:22.890]                 {
[10:24:22.890]                   {
[10:24:22.890]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:22.890]                     NULL
[10:24:22.890]                   }
[10:24:22.890]                   options(future.plan = NULL)
[10:24:22.890]                   if (is.na(NA_character_)) 
[10:24:22.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:22.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:22.890]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:22.890]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:22.890]                     envir = parent.frame()) 
[10:24:22.890]                   {
[10:24:22.890]                     if (is.function(workers)) 
[10:24:22.890]                       workers <- workers()
[10:24:22.890]                     workers <- structure(as.integer(workers), 
[10:24:22.890]                       class = class(workers))
[10:24:22.890]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:22.890]                       workers >= 1)
[10:24:22.890]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:22.890]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:22.890]                     }
[10:24:22.890]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:22.890]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:22.890]                       envir = envir)
[10:24:22.890]                     if (!future$lazy) 
[10:24:22.890]                       future <- run(future)
[10:24:22.890]                     invisible(future)
[10:24:22.890]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:22.890]                 }
[10:24:22.890]             }
[10:24:22.890]         }
[10:24:22.890]     })
[10:24:22.890]     if (TRUE) {
[10:24:22.890]         base::sink(type = "output", split = FALSE)
[10:24:22.890]         if (TRUE) {
[10:24:22.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:22.890]         }
[10:24:22.890]         else {
[10:24:22.890]             ...future.result["stdout"] <- base::list(NULL)
[10:24:22.890]         }
[10:24:22.890]         base::close(...future.stdout)
[10:24:22.890]         ...future.stdout <- NULL
[10:24:22.890]     }
[10:24:22.890]     ...future.result$conditions <- ...future.conditions
[10:24:22.890]     ...future.result$finished <- base::Sys.time()
[10:24:22.890]     ...future.result
[10:24:22.890] }
[10:24:22.892] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[10:24:22.893] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:22.934] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:22.934] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[10:24:22.934] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[10:24:22.935] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:22.935] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:22.935] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:22.978] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:22.978] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:23.022] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:23.022] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[10:24:23.022] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[10:24:23.022] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:24:23.023] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:24:23.023] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:23.023] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:23.024] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:24:23.024] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:24:23.024] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:23.024] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:23.025] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:23.025] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:23.025] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[10:24:23.026] MultisessionFuture started
[10:24:23.026] - Launch lazy future ... done
[10:24:23.026] run() for ‘MultisessionFuture’ ... done
[10:24:23.026] Created future:
[10:24:23.026] MultisessionFuture:
[10:24:23.026] Label: ‘future_vapply-1’
[10:24:23.026] Expression:
[10:24:23.026] {
[10:24:23.026]     do.call(function(...) {
[10:24:23.026]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.026]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.026]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.026]             on.exit(options(oopts), add = TRUE)
[10:24:23.026]         }
[10:24:23.026]         {
[10:24:23.026]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.026]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.026]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.026]             })
[10:24:23.026]         }
[10:24:23.026]     }, args = future.call.arguments)
[10:24:23.026] }
[10:24:23.026] Lazy evaluation: FALSE
[10:24:23.026] Asynchronous evaluation: TRUE
[10:24:23.026] Local evaluation: TRUE
[10:24:23.026] Environment: R_GlobalEnv
[10:24:23.026] Capture standard output: TRUE
[10:24:23.026] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:23.026] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:23.026] Packages: 1 packages (‘future.apply’)
[10:24:23.026] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:23.026] Resolved: FALSE
[10:24:23.026] Value: <not collected>
[10:24:23.026] Conditions captured: <none>
[10:24:23.026] Early signaling: FALSE
[10:24:23.026] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:23.026] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.038] Chunk #1 of 2 ... DONE
[10:24:23.038] Chunk #2 of 2 ...
[10:24:23.038]  - Finding globals in 'X' for chunk #2 ...
[10:24:23.038] getGlobalsAndPackages() ...
[10:24:23.038] Searching for globals...
[10:24:23.039] 
[10:24:23.039] Searching for globals ... DONE
[10:24:23.039] - globals: [0] <none>
[10:24:23.039] getGlobalsAndPackages() ... DONE
[10:24:23.039]    + additional globals found: [n=0] 
[10:24:23.039]    + additional namespaces needed: [n=0] 
[10:24:23.039]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:23.039]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:23.039]  - seeds: <none>
[10:24:23.040]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.040] getGlobalsAndPackages() ...
[10:24:23.040] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.040] Resolving globals: FALSE
[10:24:23.040] Tweak future expression to call with '...' arguments ...
[10:24:23.040] {
[10:24:23.040]     do.call(function(...) {
[10:24:23.040]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.040]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.040]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.040]             on.exit(options(oopts), add = TRUE)
[10:24:23.040]         }
[10:24:23.040]         {
[10:24:23.040]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.040]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.040]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.040]             })
[10:24:23.040]         }
[10:24:23.040]     }, args = future.call.arguments)
[10:24:23.040] }
[10:24:23.040] Tweak future expression to call with '...' arguments ... DONE
[10:24:23.041] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.041] - packages: [1] ‘future.apply’
[10:24:23.041] getGlobalsAndPackages() ... DONE
[10:24:23.041] run() for ‘Future’ ...
[10:24:23.042] - state: ‘created’
[10:24:23.042] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:23.055] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:23.056]   - Field: ‘node’
[10:24:23.056]   - Field: ‘label’
[10:24:23.056]   - Field: ‘local’
[10:24:23.056]   - Field: ‘owner’
[10:24:23.056]   - Field: ‘envir’
[10:24:23.056]   - Field: ‘workers’
[10:24:23.056]   - Field: ‘packages’
[10:24:23.056]   - Field: ‘gc’
[10:24:23.056]   - Field: ‘conditions’
[10:24:23.056]   - Field: ‘persistent’
[10:24:23.057]   - Field: ‘expr’
[10:24:23.057]   - Field: ‘uuid’
[10:24:23.057]   - Field: ‘seed’
[10:24:23.057]   - Field: ‘version’
[10:24:23.057]   - Field: ‘result’
[10:24:23.057]   - Field: ‘asynchronous’
[10:24:23.057]   - Field: ‘calls’
[10:24:23.057]   - Field: ‘globals’
[10:24:23.057]   - Field: ‘stdout’
[10:24:23.057]   - Field: ‘earlySignal’
[10:24:23.058]   - Field: ‘lazy’
[10:24:23.058]   - Field: ‘state’
[10:24:23.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:23.058] - Launch lazy future ...
[10:24:23.058] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:23.058] Packages needed by future strategies (n = 0): <none>
[10:24:23.059] {
[10:24:23.059]     {
[10:24:23.059]         {
[10:24:23.059]             ...future.startTime <- base::Sys.time()
[10:24:23.059]             {
[10:24:23.059]                 {
[10:24:23.059]                   {
[10:24:23.059]                     {
[10:24:23.059]                       {
[10:24:23.059]                         base::local({
[10:24:23.059]                           has_future <- base::requireNamespace("future", 
[10:24:23.059]                             quietly = TRUE)
[10:24:23.059]                           if (has_future) {
[10:24:23.059]                             ns <- base::getNamespace("future")
[10:24:23.059]                             version <- ns[[".package"]][["version"]]
[10:24:23.059]                             if (is.null(version)) 
[10:24:23.059]                               version <- utils::packageVersion("future")
[10:24:23.059]                           }
[10:24:23.059]                           else {
[10:24:23.059]                             version <- NULL
[10:24:23.059]                           }
[10:24:23.059]                           if (!has_future || version < "1.8.0") {
[10:24:23.059]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:23.059]                               "", base::R.version$version.string), 
[10:24:23.059]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:23.059]                                 base::R.version$platform, 8 * 
[10:24:23.059]                                   base::.Machine$sizeof.pointer), 
[10:24:23.059]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:23.059]                                 "release", "version")], collapse = " "), 
[10:24:23.059]                               hostname = base::Sys.info()[["nodename"]])
[10:24:23.059]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:23.059]                               info)
[10:24:23.059]                             info <- base::paste(info, collapse = "; ")
[10:24:23.059]                             if (!has_future) {
[10:24:23.059]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:23.059]                                 info)
[10:24:23.059]                             }
[10:24:23.059]                             else {
[10:24:23.059]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:23.059]                                 info, version)
[10:24:23.059]                             }
[10:24:23.059]                             base::stop(msg)
[10:24:23.059]                           }
[10:24:23.059]                         })
[10:24:23.059]                       }
[10:24:23.059]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:23.059]                       base::options(mc.cores = 1L)
[10:24:23.059]                     }
[10:24:23.059]                     base::local({
[10:24:23.059]                       for (pkg in "future.apply") {
[10:24:23.059]                         base::loadNamespace(pkg)
[10:24:23.059]                         base::library(pkg, character.only = TRUE)
[10:24:23.059]                       }
[10:24:23.059]                     })
[10:24:23.059]                   }
[10:24:23.059]                   options(future.plan = NULL)
[10:24:23.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:23.059]                 }
[10:24:23.059]                 ...future.workdir <- getwd()
[10:24:23.059]             }
[10:24:23.059]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:23.059]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:23.059]         }
[10:24:23.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:23.059]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:23.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:23.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:23.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:23.059]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:23.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:23.059]             base::names(...future.oldOptions))
[10:24:23.059]     }
[10:24:23.059]     if (FALSE) {
[10:24:23.059]     }
[10:24:23.059]     else {
[10:24:23.059]         if (TRUE) {
[10:24:23.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:23.059]                 open = "w")
[10:24:23.059]         }
[10:24:23.059]         else {
[10:24:23.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:23.059]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:23.059]         }
[10:24:23.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:23.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:23.059]             base::sink(type = "output", split = FALSE)
[10:24:23.059]             base::close(...future.stdout)
[10:24:23.059]         }, add = TRUE)
[10:24:23.059]     }
[10:24:23.059]     ...future.frame <- base::sys.nframe()
[10:24:23.059]     ...future.conditions <- base::list()
[10:24:23.059]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:23.059]     if (FALSE) {
[10:24:23.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:23.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:23.059]     }
[10:24:23.059]     ...future.result <- base::tryCatch({
[10:24:23.059]         base::withCallingHandlers({
[10:24:23.059]             ...future.value <- base::withVisible(base::local({
[10:24:23.059]                 ...future.makeSendCondition <- base::local({
[10:24:23.059]                   sendCondition <- NULL
[10:24:23.059]                   function(frame = 1L) {
[10:24:23.059]                     if (is.function(sendCondition)) 
[10:24:23.059]                       return(sendCondition)
[10:24:23.059]                     ns <- getNamespace("parallel")
[10:24:23.059]                     if (exists("sendData", mode = "function", 
[10:24:23.059]                       envir = ns)) {
[10:24:23.059]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:23.059]                         envir = ns)
[10:24:23.059]                       envir <- sys.frame(frame)
[10:24:23.059]                       master <- NULL
[10:24:23.059]                       while (!identical(envir, .GlobalEnv) && 
[10:24:23.059]                         !identical(envir, emptyenv())) {
[10:24:23.059]                         if (exists("master", mode = "list", envir = envir, 
[10:24:23.059]                           inherits = FALSE)) {
[10:24:23.059]                           master <- get("master", mode = "list", 
[10:24:23.059]                             envir = envir, inherits = FALSE)
[10:24:23.059]                           if (inherits(master, c("SOCKnode", 
[10:24:23.059]                             "SOCK0node"))) {
[10:24:23.059]                             sendCondition <<- function(cond) {
[10:24:23.059]                               data <- list(type = "VALUE", value = cond, 
[10:24:23.059]                                 success = TRUE)
[10:24:23.059]                               parallel_sendData(master, data)
[10:24:23.059]                             }
[10:24:23.059]                             return(sendCondition)
[10:24:23.059]                           }
[10:24:23.059]                         }
[10:24:23.059]                         frame <- frame + 1L
[10:24:23.059]                         envir <- sys.frame(frame)
[10:24:23.059]                       }
[10:24:23.059]                     }
[10:24:23.059]                     sendCondition <<- function(cond) NULL
[10:24:23.059]                   }
[10:24:23.059]                 })
[10:24:23.059]                 withCallingHandlers({
[10:24:23.059]                   {
[10:24:23.059]                     do.call(function(...) {
[10:24:23.059]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.059]                       if (!identical(...future.globals.maxSize.org, 
[10:24:23.059]                         ...future.globals.maxSize)) {
[10:24:23.059]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.059]                         on.exit(options(oopts), add = TRUE)
[10:24:23.059]                       }
[10:24:23.059]                       {
[10:24:23.059]                         lapply(seq_along(...future.elements_ii), 
[10:24:23.059]                           FUN = function(jj) {
[10:24:23.059]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.059]                             ...future.FUN(...future.X_jj, ...)
[10:24:23.059]                           })
[10:24:23.059]                       }
[10:24:23.059]                     }, args = future.call.arguments)
[10:24:23.059]                   }
[10:24:23.059]                 }, immediateCondition = function(cond) {
[10:24:23.059]                   sendCondition <- ...future.makeSendCondition()
[10:24:23.059]                   sendCondition(cond)
[10:24:23.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.059]                   {
[10:24:23.059]                     inherits <- base::inherits
[10:24:23.059]                     invokeRestart <- base::invokeRestart
[10:24:23.059]                     is.null <- base::is.null
[10:24:23.059]                     muffled <- FALSE
[10:24:23.059]                     if (inherits(cond, "message")) {
[10:24:23.059]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:23.059]                       if (muffled) 
[10:24:23.059]                         invokeRestart("muffleMessage")
[10:24:23.059]                     }
[10:24:23.059]                     else if (inherits(cond, "warning")) {
[10:24:23.059]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:23.059]                       if (muffled) 
[10:24:23.059]                         invokeRestart("muffleWarning")
[10:24:23.059]                     }
[10:24:23.059]                     else if (inherits(cond, "condition")) {
[10:24:23.059]                       if (!is.null(pattern)) {
[10:24:23.059]                         computeRestarts <- base::computeRestarts
[10:24:23.059]                         grepl <- base::grepl
[10:24:23.059]                         restarts <- computeRestarts(cond)
[10:24:23.059]                         for (restart in restarts) {
[10:24:23.059]                           name <- restart$name
[10:24:23.059]                           if (is.null(name)) 
[10:24:23.059]                             next
[10:24:23.059]                           if (!grepl(pattern, name)) 
[10:24:23.059]                             next
[10:24:23.059]                           invokeRestart(restart)
[10:24:23.059]                           muffled <- TRUE
[10:24:23.059]                           break
[10:24:23.059]                         }
[10:24:23.059]                       }
[10:24:23.059]                     }
[10:24:23.059]                     invisible(muffled)
[10:24:23.059]                   }
[10:24:23.059]                   muffleCondition(cond)
[10:24:23.059]                 })
[10:24:23.059]             }))
[10:24:23.059]             future::FutureResult(value = ...future.value$value, 
[10:24:23.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.059]                   ...future.rng), globalenv = if (FALSE) 
[10:24:23.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:23.059]                     ...future.globalenv.names))
[10:24:23.059]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:23.059]         }, condition = base::local({
[10:24:23.059]             c <- base::c
[10:24:23.059]             inherits <- base::inherits
[10:24:23.059]             invokeRestart <- base::invokeRestart
[10:24:23.059]             length <- base::length
[10:24:23.059]             list <- base::list
[10:24:23.059]             seq.int <- base::seq.int
[10:24:23.059]             signalCondition <- base::signalCondition
[10:24:23.059]             sys.calls <- base::sys.calls
[10:24:23.059]             `[[` <- base::`[[`
[10:24:23.059]             `+` <- base::`+`
[10:24:23.059]             `<<-` <- base::`<<-`
[10:24:23.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:23.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:23.059]                   3L)]
[10:24:23.059]             }
[10:24:23.059]             function(cond) {
[10:24:23.059]                 is_error <- inherits(cond, "error")
[10:24:23.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:23.059]                   NULL)
[10:24:23.059]                 if (is_error) {
[10:24:23.059]                   sessionInformation <- function() {
[10:24:23.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:23.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:23.059]                       search = base::search(), system = base::Sys.info())
[10:24:23.059]                   }
[10:24:23.059]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:23.059]                     cond$call), session = sessionInformation(), 
[10:24:23.059]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:23.059]                   signalCondition(cond)
[10:24:23.059]                 }
[10:24:23.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:23.059]                 "immediateCondition"))) {
[10:24:23.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:23.059]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:23.059]                   if (TRUE && !signal) {
[10:24:23.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.059]                     {
[10:24:23.059]                       inherits <- base::inherits
[10:24:23.059]                       invokeRestart <- base::invokeRestart
[10:24:23.059]                       is.null <- base::is.null
[10:24:23.059]                       muffled <- FALSE
[10:24:23.059]                       if (inherits(cond, "message")) {
[10:24:23.059]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.059]                         if (muffled) 
[10:24:23.059]                           invokeRestart("muffleMessage")
[10:24:23.059]                       }
[10:24:23.059]                       else if (inherits(cond, "warning")) {
[10:24:23.059]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.059]                         if (muffled) 
[10:24:23.059]                           invokeRestart("muffleWarning")
[10:24:23.059]                       }
[10:24:23.059]                       else if (inherits(cond, "condition")) {
[10:24:23.059]                         if (!is.null(pattern)) {
[10:24:23.059]                           computeRestarts <- base::computeRestarts
[10:24:23.059]                           grepl <- base::grepl
[10:24:23.059]                           restarts <- computeRestarts(cond)
[10:24:23.059]                           for (restart in restarts) {
[10:24:23.059]                             name <- restart$name
[10:24:23.059]                             if (is.null(name)) 
[10:24:23.059]                               next
[10:24:23.059]                             if (!grepl(pattern, name)) 
[10:24:23.059]                               next
[10:24:23.059]                             invokeRestart(restart)
[10:24:23.059]                             muffled <- TRUE
[10:24:23.059]                             break
[10:24:23.059]                           }
[10:24:23.059]                         }
[10:24:23.059]                       }
[10:24:23.059]                       invisible(muffled)
[10:24:23.059]                     }
[10:24:23.059]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.059]                   }
[10:24:23.059]                 }
[10:24:23.059]                 else {
[10:24:23.059]                   if (TRUE) {
[10:24:23.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.059]                     {
[10:24:23.059]                       inherits <- base::inherits
[10:24:23.059]                       invokeRestart <- base::invokeRestart
[10:24:23.059]                       is.null <- base::is.null
[10:24:23.059]                       muffled <- FALSE
[10:24:23.059]                       if (inherits(cond, "message")) {
[10:24:23.059]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.059]                         if (muffled) 
[10:24:23.059]                           invokeRestart("muffleMessage")
[10:24:23.059]                       }
[10:24:23.059]                       else if (inherits(cond, "warning")) {
[10:24:23.059]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.059]                         if (muffled) 
[10:24:23.059]                           invokeRestart("muffleWarning")
[10:24:23.059]                       }
[10:24:23.059]                       else if (inherits(cond, "condition")) {
[10:24:23.059]                         if (!is.null(pattern)) {
[10:24:23.059]                           computeRestarts <- base::computeRestarts
[10:24:23.059]                           grepl <- base::grepl
[10:24:23.059]                           restarts <- computeRestarts(cond)
[10:24:23.059]                           for (restart in restarts) {
[10:24:23.059]                             name <- restart$name
[10:24:23.059]                             if (is.null(name)) 
[10:24:23.059]                               next
[10:24:23.059]                             if (!grepl(pattern, name)) 
[10:24:23.059]                               next
[10:24:23.059]                             invokeRestart(restart)
[10:24:23.059]                             muffled <- TRUE
[10:24:23.059]                             break
[10:24:23.059]                           }
[10:24:23.059]                         }
[10:24:23.059]                       }
[10:24:23.059]                       invisible(muffled)
[10:24:23.059]                     }
[10:24:23.059]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.059]                   }
[10:24:23.059]                 }
[10:24:23.059]             }
[10:24:23.059]         }))
[10:24:23.059]     }, error = function(ex) {
[10:24:23.059]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:23.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.059]                 ...future.rng), started = ...future.startTime, 
[10:24:23.059]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:23.059]             version = "1.8"), class = "FutureResult")
[10:24:23.059]     }, finally = {
[10:24:23.059]         if (!identical(...future.workdir, getwd())) 
[10:24:23.059]             setwd(...future.workdir)
[10:24:23.059]         {
[10:24:23.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:23.059]                 ...future.oldOptions$nwarnings <- NULL
[10:24:23.059]             }
[10:24:23.059]             base::options(...future.oldOptions)
[10:24:23.059]             if (.Platform$OS.type == "windows") {
[10:24:23.059]                 old_names <- names(...future.oldEnvVars)
[10:24:23.059]                 envs <- base::Sys.getenv()
[10:24:23.059]                 names <- names(envs)
[10:24:23.059]                 common <- intersect(names, old_names)
[10:24:23.059]                 added <- setdiff(names, old_names)
[10:24:23.059]                 removed <- setdiff(old_names, names)
[10:24:23.059]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:23.059]                   envs[common]]
[10:24:23.059]                 NAMES <- toupper(changed)
[10:24:23.059]                 args <- list()
[10:24:23.059]                 for (kk in seq_along(NAMES)) {
[10:24:23.059]                   name <- changed[[kk]]
[10:24:23.059]                   NAME <- NAMES[[kk]]
[10:24:23.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.059]                     next
[10:24:23.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.059]                 }
[10:24:23.059]                 NAMES <- toupper(added)
[10:24:23.059]                 for (kk in seq_along(NAMES)) {
[10:24:23.059]                   name <- added[[kk]]
[10:24:23.059]                   NAME <- NAMES[[kk]]
[10:24:23.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.059]                     next
[10:24:23.059]                   args[[name]] <- ""
[10:24:23.059]                 }
[10:24:23.059]                 NAMES <- toupper(removed)
[10:24:23.059]                 for (kk in seq_along(NAMES)) {
[10:24:23.059]                   name <- removed[[kk]]
[10:24:23.059]                   NAME <- NAMES[[kk]]
[10:24:23.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.059]                     next
[10:24:23.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.059]                 }
[10:24:23.059]                 if (length(args) > 0) 
[10:24:23.059]                   base::do.call(base::Sys.setenv, args = args)
[10:24:23.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:23.059]             }
[10:24:23.059]             else {
[10:24:23.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:23.059]             }
[10:24:23.059]             {
[10:24:23.059]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:23.059]                   0L) {
[10:24:23.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:23.059]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:23.059]                   base::options(opts)
[10:24:23.059]                 }
[10:24:23.059]                 {
[10:24:23.059]                   {
[10:24:23.059]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:23.059]                     NULL
[10:24:23.059]                   }
[10:24:23.059]                   options(future.plan = NULL)
[10:24:23.059]                   if (is.na(NA_character_)) 
[10:24:23.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:23.059]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:23.059]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:23.059]                     envir = parent.frame()) 
[10:24:23.059]                   {
[10:24:23.059]                     if (is.function(workers)) 
[10:24:23.059]                       workers <- workers()
[10:24:23.059]                     workers <- structure(as.integer(workers), 
[10:24:23.059]                       class = class(workers))
[10:24:23.059]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:23.059]                       workers >= 1)
[10:24:23.059]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:23.059]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:23.059]                     }
[10:24:23.059]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:23.059]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:23.059]                       envir = envir)
[10:24:23.059]                     if (!future$lazy) 
[10:24:23.059]                       future <- run(future)
[10:24:23.059]                     invisible(future)
[10:24:23.059]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:23.059]                 }
[10:24:23.059]             }
[10:24:23.059]         }
[10:24:23.059]     })
[10:24:23.059]     if (TRUE) {
[10:24:23.059]         base::sink(type = "output", split = FALSE)
[10:24:23.059]         if (TRUE) {
[10:24:23.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:23.059]         }
[10:24:23.059]         else {
[10:24:23.059]             ...future.result["stdout"] <- base::list(NULL)
[10:24:23.059]         }
[10:24:23.059]         base::close(...future.stdout)
[10:24:23.059]         ...future.stdout <- NULL
[10:24:23.059]     }
[10:24:23.059]     ...future.result$conditions <- ...future.conditions
[10:24:23.059]     ...future.result$finished <- base::Sys.time()
[10:24:23.059]     ...future.result
[10:24:23.059] }
[10:24:23.062] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[10:24:23.062] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:23.106] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:23.106] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[10:24:23.106] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[10:24:23.106] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:23.107] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:23.107] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:23.150] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:23.150] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:23.194] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:23.194] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[10:24:23.194] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[10:24:23.194] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:24:23.195] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:24:23.195] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:23.195] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:23.196] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:24:23.196] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:24:23.196] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:23.196] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:23.197] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:23.197] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:23.197] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[10:24:23.198] MultisessionFuture started
[10:24:23.198] - Launch lazy future ... done
[10:24:23.198] run() for ‘MultisessionFuture’ ... done
[10:24:23.198] Created future:
[10:24:23.198] MultisessionFuture:
[10:24:23.198] Label: ‘future_vapply-2’
[10:24:23.198] Expression:
[10:24:23.198] {
[10:24:23.198]     do.call(function(...) {
[10:24:23.198]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.198]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.198]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.198]             on.exit(options(oopts), add = TRUE)
[10:24:23.198]         }
[10:24:23.198]         {
[10:24:23.198]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.198]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.198]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.198]             })
[10:24:23.198]         }
[10:24:23.198]     }, args = future.call.arguments)
[10:24:23.198] }
[10:24:23.198] Lazy evaluation: FALSE
[10:24:23.198] Asynchronous evaluation: TRUE
[10:24:23.198] Local evaluation: TRUE
[10:24:23.198] Environment: R_GlobalEnv
[10:24:23.198] Capture standard output: TRUE
[10:24:23.198] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:23.198] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:23.198] Packages: 1 packages (‘future.apply’)
[10:24:23.198] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:23.198] Resolved: FALSE
[10:24:23.198] Value: <not collected>
[10:24:23.198] Conditions captured: <none>
[10:24:23.198] Early signaling: FALSE
[10:24:23.198] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:23.198] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.210] Chunk #2 of 2 ... DONE
[10:24:23.210] Launching 2 futures (chunks) ... DONE
[10:24:23.210] Resolving 2 futures (chunks) ...
[10:24:23.210] resolve() on list ...
[10:24:23.210]  recursive: 0
[10:24:23.210]  length: 2
[10:24:23.211] 
[10:24:23.211] receiveMessageFromWorker() for ClusterFuture ...
[10:24:23.211] - Validating connection of MultisessionFuture
[10:24:23.211] - received message: FutureResult
[10:24:23.211] - Received FutureResult
[10:24:23.212] - Erased future from FutureRegistry
[10:24:23.212] result() for ClusterFuture ...
[10:24:23.212] - result already collected: FutureResult
[10:24:23.212] result() for ClusterFuture ... done
[10:24:23.212] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:23.212] Future #1
[10:24:23.212] result() for ClusterFuture ...
[10:24:23.212] - result already collected: FutureResult
[10:24:23.212] result() for ClusterFuture ... done
[10:24:23.212] result() for ClusterFuture ...
[10:24:23.212] - result already collected: FutureResult
[10:24:23.213] result() for ClusterFuture ... done
[10:24:23.213] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:23.213] - nx: 2
[10:24:23.213] - relay: TRUE
[10:24:23.213] - stdout: TRUE
[10:24:23.213] - signal: TRUE
[10:24:23.213] - resignal: FALSE
[10:24:23.213] - force: TRUE
[10:24:23.213] - relayed: [n=2] FALSE, FALSE
[10:24:23.213] - queued futures: [n=2] FALSE, FALSE
[10:24:23.213]  - until=1
[10:24:23.214]  - relaying element #1
[10:24:23.214] result() for ClusterFuture ...
[10:24:23.214] - result already collected: FutureResult
[10:24:23.214] result() for ClusterFuture ... done
[10:24:23.214] result() for ClusterFuture ...
[10:24:23.214] - result already collected: FutureResult
[10:24:23.214] result() for ClusterFuture ... done
[10:24:23.214] result() for ClusterFuture ...
[10:24:23.214] - result already collected: FutureResult
[10:24:23.214] result() for ClusterFuture ... done
[10:24:23.214] result() for ClusterFuture ...
[10:24:23.215] - result already collected: FutureResult
[10:24:23.215] result() for ClusterFuture ... done
[10:24:23.215] - relayed: [n=2] TRUE, FALSE
[10:24:23.215] - queued futures: [n=2] TRUE, FALSE
[10:24:23.215] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:23.215]  length: 1 (resolved future 1)
[10:24:23.257] receiveMessageFromWorker() for ClusterFuture ...
[10:24:23.257] - Validating connection of MultisessionFuture
[10:24:23.257] - received message: FutureResult
[10:24:23.257] - Received FutureResult
[10:24:23.257] - Erased future from FutureRegistry
[10:24:23.257] result() for ClusterFuture ...
[10:24:23.258] - result already collected: FutureResult
[10:24:23.258] result() for ClusterFuture ... done
[10:24:23.258] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:23.258] Future #2
[10:24:23.258] result() for ClusterFuture ...
[10:24:23.258] - result already collected: FutureResult
[10:24:23.258] result() for ClusterFuture ... done
[10:24:23.258] result() for ClusterFuture ...
[10:24:23.258] - result already collected: FutureResult
[10:24:23.258] result() for ClusterFuture ... done
[10:24:23.258] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:23.259] - nx: 2
[10:24:23.259] - relay: TRUE
[10:24:23.259] - stdout: TRUE
[10:24:23.259] - signal: TRUE
[10:24:23.259] - resignal: FALSE
[10:24:23.259] - force: TRUE
[10:24:23.259] - relayed: [n=2] TRUE, FALSE
[10:24:23.259] - queued futures: [n=2] TRUE, FALSE
[10:24:23.259]  - until=2
[10:24:23.259]  - relaying element #2
[10:24:23.259] result() for ClusterFuture ...
[10:24:23.259] - result already collected: FutureResult
[10:24:23.260] result() for ClusterFuture ... done
[10:24:23.260] result() for ClusterFuture ...
[10:24:23.260] - result already collected: FutureResult
[10:24:23.260] result() for ClusterFuture ... done
[10:24:23.260] result() for ClusterFuture ...
[10:24:23.260] - result already collected: FutureResult
[10:24:23.260] result() for ClusterFuture ... done
[10:24:23.260] result() for ClusterFuture ...
[10:24:23.260] - result already collected: FutureResult
[10:24:23.260] result() for ClusterFuture ... done
[10:24:23.260] - relayed: [n=2] TRUE, TRUE
[10:24:23.261] - queued futures: [n=2] TRUE, TRUE
[10:24:23.261] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:23.261]  length: 0 (resolved future 2)
[10:24:23.261] Relaying remaining futures
[10:24:23.261] signalConditionsASAP(NULL, pos=0) ...
[10:24:23.261] - nx: 2
[10:24:23.261] - relay: TRUE
[10:24:23.261] - stdout: TRUE
[10:24:23.261] - signal: TRUE
[10:24:23.261] - resignal: FALSE
[10:24:23.261] - force: TRUE
[10:24:23.262] - relayed: [n=2] TRUE, TRUE
[10:24:23.262] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:23.262] - relayed: [n=2] TRUE, TRUE
[10:24:23.262] - queued futures: [n=2] TRUE, TRUE
[10:24:23.262] signalConditionsASAP(NULL, pos=0) ... done
[10:24:23.262] resolve() on list ... DONE
[10:24:23.262] result() for ClusterFuture ...
[10:24:23.262] - result already collected: FutureResult
[10:24:23.262] result() for ClusterFuture ... done
[10:24:23.262] result() for ClusterFuture ...
[10:24:23.263] - result already collected: FutureResult
[10:24:23.263] result() for ClusterFuture ... done
[10:24:23.263] result() for ClusterFuture ...
[10:24:23.263] - result already collected: FutureResult
[10:24:23.263] result() for ClusterFuture ... done
[10:24:23.263] result() for ClusterFuture ...
[10:24:23.263] - result already collected: FutureResult
[10:24:23.263] result() for ClusterFuture ... done
[10:24:23.263]  - Number of value chunks collected: 2
[10:24:23.263] Resolving 2 futures (chunks) ... DONE
[10:24:23.263] Reducing values from 2 chunks ...
[10:24:23.264]  - Number of values collected after concatenation: 10
[10:24:23.264]  - Number of values expected: 10
[10:24:23.264] Reducing values from 2 chunks ... DONE
[10:24:23.264] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[10:24:23.266] future_lapply() ...
[10:24:23.271] Number of chunks: 2
[10:24:23.272] getGlobalsAndPackagesXApply() ...
[10:24:23.272]  - future.globals: TRUE
[10:24:23.272] getGlobalsAndPackages() ...
[10:24:23.272] Searching for globals...
[10:24:23.275] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[10:24:23.275] Searching for globals ... DONE
[10:24:23.276] Resolving globals: FALSE
[10:24:23.276] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[10:24:23.277] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:23.277] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:23.277] - packages: [2] ‘stats’, ‘future.apply’
[10:24:23.277] getGlobalsAndPackages() ... DONE
[10:24:23.277]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:23.277]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:24:23.278] Finding globals ... DONE
[10:24:23.278]  - use_args: TRUE
[10:24:23.278]  - Getting '...' globals ...
[10:24:23.278] resolve() on list ...
[10:24:23.278]  recursive: 0
[10:24:23.278]  length: 1
[10:24:23.278]  elements: ‘...’
[10:24:23.278]  length: 0 (resolved future 1)
[10:24:23.278] resolve() on list ... DONE
[10:24:23.279]    - '...' content: [n=0] 
[10:24:23.279] List of 1
[10:24:23.279]  $ ...: list()
[10:24:23.279]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:23.279]  - attr(*, "where")=List of 1
[10:24:23.279]   ..$ ...:<environment: 0x55b93e91d158> 
[10:24:23.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:23.279]  - attr(*, "resolved")= logi TRUE
[10:24:23.279]  - attr(*, "total_size")= num NA
[10:24:23.281]  - Getting '...' globals ... DONE
[10:24:23.281] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:23.281] List of 8
[10:24:23.281]  $ ...future.FUN:function (x, ...)  
[10:24:23.281]  $ x_FUN        :function (x, ...)  
[10:24:23.281]  $ times        : int 5
[10:24:23.281]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:23.281]  $ stop_if_not  :function (...)  
[10:24:23.281]  $ dim          : NULL
[10:24:23.281]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:23.281]  $ ...          : list()
[10:24:23.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:23.281]  - attr(*, "where")=List of 8
[10:24:23.281]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:23.281]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:23.281]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:23.281]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:23.281]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:23.281]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:23.281]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:23.281]   ..$ ...          :<environment: 0x55b93e91d158> 
[10:24:23.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:23.281]  - attr(*, "resolved")= logi FALSE
[10:24:23.281]  - attr(*, "total_size")= num 95528
[10:24:23.289] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:24:23.289] getGlobalsAndPackagesXApply() ... DONE
[10:24:23.290] Number of futures (= number of chunks): 2
[10:24:23.290] Launching 2 futures (chunks) ...
[10:24:23.290] Chunk #1 of 2 ...
[10:24:23.290]  - Finding globals in 'X' for chunk #1 ...
[10:24:23.290] getGlobalsAndPackages() ...
[10:24:23.290] Searching for globals...
[10:24:23.290] 
[10:24:23.291] Searching for globals ... DONE
[10:24:23.291] - globals: [0] <none>
[10:24:23.291] getGlobalsAndPackages() ... DONE
[10:24:23.291]    + additional globals found: [n=0] 
[10:24:23.291]    + additional namespaces needed: [n=0] 
[10:24:23.291]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:23.291]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:23.291]  - seeds: <none>
[10:24:23.291]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.291] getGlobalsAndPackages() ...
[10:24:23.292] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.292] Resolving globals: FALSE
[10:24:23.292] Tweak future expression to call with '...' arguments ...
[10:24:23.292] {
[10:24:23.292]     do.call(function(...) {
[10:24:23.292]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.292]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.292]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.292]             on.exit(options(oopts), add = TRUE)
[10:24:23.292]         }
[10:24:23.292]         {
[10:24:23.292]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.292]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.292]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.292]             })
[10:24:23.292]         }
[10:24:23.292]     }, args = future.call.arguments)
[10:24:23.292] }
[10:24:23.292] Tweak future expression to call with '...' arguments ... DONE
[10:24:23.293] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.293] - packages: [2] ‘stats’, ‘future.apply’
[10:24:23.293] getGlobalsAndPackages() ... DONE
[10:24:23.293] run() for ‘Future’ ...
[10:24:23.293] - state: ‘created’
[10:24:23.294] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:23.308] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:23.308]   - Field: ‘node’
[10:24:23.308]   - Field: ‘label’
[10:24:23.308]   - Field: ‘local’
[10:24:23.308]   - Field: ‘owner’
[10:24:23.308]   - Field: ‘envir’
[10:24:23.308]   - Field: ‘workers’
[10:24:23.308]   - Field: ‘packages’
[10:24:23.308]   - Field: ‘gc’
[10:24:23.309]   - Field: ‘conditions’
[10:24:23.309]   - Field: ‘persistent’
[10:24:23.309]   - Field: ‘expr’
[10:24:23.309]   - Field: ‘uuid’
[10:24:23.309]   - Field: ‘seed’
[10:24:23.309]   - Field: ‘version’
[10:24:23.309]   - Field: ‘result’
[10:24:23.309]   - Field: ‘asynchronous’
[10:24:23.309]   - Field: ‘calls’
[10:24:23.309]   - Field: ‘globals’
[10:24:23.310]   - Field: ‘stdout’
[10:24:23.310]   - Field: ‘earlySignal’
[10:24:23.310]   - Field: ‘lazy’
[10:24:23.310]   - Field: ‘state’
[10:24:23.310] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:23.310] - Launch lazy future ...
[10:24:23.310] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:24:23.310] Packages needed by future strategies (n = 0): <none>
[10:24:23.311] {
[10:24:23.311]     {
[10:24:23.311]         {
[10:24:23.311]             ...future.startTime <- base::Sys.time()
[10:24:23.311]             {
[10:24:23.311]                 {
[10:24:23.311]                   {
[10:24:23.311]                     {
[10:24:23.311]                       {
[10:24:23.311]                         base::local({
[10:24:23.311]                           has_future <- base::requireNamespace("future", 
[10:24:23.311]                             quietly = TRUE)
[10:24:23.311]                           if (has_future) {
[10:24:23.311]                             ns <- base::getNamespace("future")
[10:24:23.311]                             version <- ns[[".package"]][["version"]]
[10:24:23.311]                             if (is.null(version)) 
[10:24:23.311]                               version <- utils::packageVersion("future")
[10:24:23.311]                           }
[10:24:23.311]                           else {
[10:24:23.311]                             version <- NULL
[10:24:23.311]                           }
[10:24:23.311]                           if (!has_future || version < "1.8.0") {
[10:24:23.311]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:23.311]                               "", base::R.version$version.string), 
[10:24:23.311]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:23.311]                                 base::R.version$platform, 8 * 
[10:24:23.311]                                   base::.Machine$sizeof.pointer), 
[10:24:23.311]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:23.311]                                 "release", "version")], collapse = " "), 
[10:24:23.311]                               hostname = base::Sys.info()[["nodename"]])
[10:24:23.311]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:23.311]                               info)
[10:24:23.311]                             info <- base::paste(info, collapse = "; ")
[10:24:23.311]                             if (!has_future) {
[10:24:23.311]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:23.311]                                 info)
[10:24:23.311]                             }
[10:24:23.311]                             else {
[10:24:23.311]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:23.311]                                 info, version)
[10:24:23.311]                             }
[10:24:23.311]                             base::stop(msg)
[10:24:23.311]                           }
[10:24:23.311]                         })
[10:24:23.311]                       }
[10:24:23.311]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:23.311]                       base::options(mc.cores = 1L)
[10:24:23.311]                     }
[10:24:23.311]                     base::local({
[10:24:23.311]                       for (pkg in c("stats", "future.apply")) {
[10:24:23.311]                         base::loadNamespace(pkg)
[10:24:23.311]                         base::library(pkg, character.only = TRUE)
[10:24:23.311]                       }
[10:24:23.311]                     })
[10:24:23.311]                   }
[10:24:23.311]                   options(future.plan = NULL)
[10:24:23.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:23.311]                 }
[10:24:23.311]                 ...future.workdir <- getwd()
[10:24:23.311]             }
[10:24:23.311]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:23.311]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:23.311]         }
[10:24:23.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:23.311]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:23.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:23.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:23.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:23.311]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:23.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:23.311]             base::names(...future.oldOptions))
[10:24:23.311]     }
[10:24:23.311]     if (FALSE) {
[10:24:23.311]     }
[10:24:23.311]     else {
[10:24:23.311]         if (TRUE) {
[10:24:23.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:23.311]                 open = "w")
[10:24:23.311]         }
[10:24:23.311]         else {
[10:24:23.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:23.311]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:23.311]         }
[10:24:23.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:23.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:23.311]             base::sink(type = "output", split = FALSE)
[10:24:23.311]             base::close(...future.stdout)
[10:24:23.311]         }, add = TRUE)
[10:24:23.311]     }
[10:24:23.311]     ...future.frame <- base::sys.nframe()
[10:24:23.311]     ...future.conditions <- base::list()
[10:24:23.311]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:23.311]     if (FALSE) {
[10:24:23.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:23.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:23.311]     }
[10:24:23.311]     ...future.result <- base::tryCatch({
[10:24:23.311]         base::withCallingHandlers({
[10:24:23.311]             ...future.value <- base::withVisible(base::local({
[10:24:23.311]                 ...future.makeSendCondition <- base::local({
[10:24:23.311]                   sendCondition <- NULL
[10:24:23.311]                   function(frame = 1L) {
[10:24:23.311]                     if (is.function(sendCondition)) 
[10:24:23.311]                       return(sendCondition)
[10:24:23.311]                     ns <- getNamespace("parallel")
[10:24:23.311]                     if (exists("sendData", mode = "function", 
[10:24:23.311]                       envir = ns)) {
[10:24:23.311]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:23.311]                         envir = ns)
[10:24:23.311]                       envir <- sys.frame(frame)
[10:24:23.311]                       master <- NULL
[10:24:23.311]                       while (!identical(envir, .GlobalEnv) && 
[10:24:23.311]                         !identical(envir, emptyenv())) {
[10:24:23.311]                         if (exists("master", mode = "list", envir = envir, 
[10:24:23.311]                           inherits = FALSE)) {
[10:24:23.311]                           master <- get("master", mode = "list", 
[10:24:23.311]                             envir = envir, inherits = FALSE)
[10:24:23.311]                           if (inherits(master, c("SOCKnode", 
[10:24:23.311]                             "SOCK0node"))) {
[10:24:23.311]                             sendCondition <<- function(cond) {
[10:24:23.311]                               data <- list(type = "VALUE", value = cond, 
[10:24:23.311]                                 success = TRUE)
[10:24:23.311]                               parallel_sendData(master, data)
[10:24:23.311]                             }
[10:24:23.311]                             return(sendCondition)
[10:24:23.311]                           }
[10:24:23.311]                         }
[10:24:23.311]                         frame <- frame + 1L
[10:24:23.311]                         envir <- sys.frame(frame)
[10:24:23.311]                       }
[10:24:23.311]                     }
[10:24:23.311]                     sendCondition <<- function(cond) NULL
[10:24:23.311]                   }
[10:24:23.311]                 })
[10:24:23.311]                 withCallingHandlers({
[10:24:23.311]                   {
[10:24:23.311]                     do.call(function(...) {
[10:24:23.311]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.311]                       if (!identical(...future.globals.maxSize.org, 
[10:24:23.311]                         ...future.globals.maxSize)) {
[10:24:23.311]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.311]                         on.exit(options(oopts), add = TRUE)
[10:24:23.311]                       }
[10:24:23.311]                       {
[10:24:23.311]                         lapply(seq_along(...future.elements_ii), 
[10:24:23.311]                           FUN = function(jj) {
[10:24:23.311]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.311]                             ...future.FUN(...future.X_jj, ...)
[10:24:23.311]                           })
[10:24:23.311]                       }
[10:24:23.311]                     }, args = future.call.arguments)
[10:24:23.311]                   }
[10:24:23.311]                 }, immediateCondition = function(cond) {
[10:24:23.311]                   sendCondition <- ...future.makeSendCondition()
[10:24:23.311]                   sendCondition(cond)
[10:24:23.311]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.311]                   {
[10:24:23.311]                     inherits <- base::inherits
[10:24:23.311]                     invokeRestart <- base::invokeRestart
[10:24:23.311]                     is.null <- base::is.null
[10:24:23.311]                     muffled <- FALSE
[10:24:23.311]                     if (inherits(cond, "message")) {
[10:24:23.311]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:23.311]                       if (muffled) 
[10:24:23.311]                         invokeRestart("muffleMessage")
[10:24:23.311]                     }
[10:24:23.311]                     else if (inherits(cond, "warning")) {
[10:24:23.311]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:23.311]                       if (muffled) 
[10:24:23.311]                         invokeRestart("muffleWarning")
[10:24:23.311]                     }
[10:24:23.311]                     else if (inherits(cond, "condition")) {
[10:24:23.311]                       if (!is.null(pattern)) {
[10:24:23.311]                         computeRestarts <- base::computeRestarts
[10:24:23.311]                         grepl <- base::grepl
[10:24:23.311]                         restarts <- computeRestarts(cond)
[10:24:23.311]                         for (restart in restarts) {
[10:24:23.311]                           name <- restart$name
[10:24:23.311]                           if (is.null(name)) 
[10:24:23.311]                             next
[10:24:23.311]                           if (!grepl(pattern, name)) 
[10:24:23.311]                             next
[10:24:23.311]                           invokeRestart(restart)
[10:24:23.311]                           muffled <- TRUE
[10:24:23.311]                           break
[10:24:23.311]                         }
[10:24:23.311]                       }
[10:24:23.311]                     }
[10:24:23.311]                     invisible(muffled)
[10:24:23.311]                   }
[10:24:23.311]                   muffleCondition(cond)
[10:24:23.311]                 })
[10:24:23.311]             }))
[10:24:23.311]             future::FutureResult(value = ...future.value$value, 
[10:24:23.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.311]                   ...future.rng), globalenv = if (FALSE) 
[10:24:23.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:23.311]                     ...future.globalenv.names))
[10:24:23.311]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:23.311]         }, condition = base::local({
[10:24:23.311]             c <- base::c
[10:24:23.311]             inherits <- base::inherits
[10:24:23.311]             invokeRestart <- base::invokeRestart
[10:24:23.311]             length <- base::length
[10:24:23.311]             list <- base::list
[10:24:23.311]             seq.int <- base::seq.int
[10:24:23.311]             signalCondition <- base::signalCondition
[10:24:23.311]             sys.calls <- base::sys.calls
[10:24:23.311]             `[[` <- base::`[[`
[10:24:23.311]             `+` <- base::`+`
[10:24:23.311]             `<<-` <- base::`<<-`
[10:24:23.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:23.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:23.311]                   3L)]
[10:24:23.311]             }
[10:24:23.311]             function(cond) {
[10:24:23.311]                 is_error <- inherits(cond, "error")
[10:24:23.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:23.311]                   NULL)
[10:24:23.311]                 if (is_error) {
[10:24:23.311]                   sessionInformation <- function() {
[10:24:23.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:23.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:23.311]                       search = base::search(), system = base::Sys.info())
[10:24:23.311]                   }
[10:24:23.311]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:23.311]                     cond$call), session = sessionInformation(), 
[10:24:23.311]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:23.311]                   signalCondition(cond)
[10:24:23.311]                 }
[10:24:23.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:23.311]                 "immediateCondition"))) {
[10:24:23.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:23.311]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:23.311]                   if (TRUE && !signal) {
[10:24:23.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.311]                     {
[10:24:23.311]                       inherits <- base::inherits
[10:24:23.311]                       invokeRestart <- base::invokeRestart
[10:24:23.311]                       is.null <- base::is.null
[10:24:23.311]                       muffled <- FALSE
[10:24:23.311]                       if (inherits(cond, "message")) {
[10:24:23.311]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.311]                         if (muffled) 
[10:24:23.311]                           invokeRestart("muffleMessage")
[10:24:23.311]                       }
[10:24:23.311]                       else if (inherits(cond, "warning")) {
[10:24:23.311]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.311]                         if (muffled) 
[10:24:23.311]                           invokeRestart("muffleWarning")
[10:24:23.311]                       }
[10:24:23.311]                       else if (inherits(cond, "condition")) {
[10:24:23.311]                         if (!is.null(pattern)) {
[10:24:23.311]                           computeRestarts <- base::computeRestarts
[10:24:23.311]                           grepl <- base::grepl
[10:24:23.311]                           restarts <- computeRestarts(cond)
[10:24:23.311]                           for (restart in restarts) {
[10:24:23.311]                             name <- restart$name
[10:24:23.311]                             if (is.null(name)) 
[10:24:23.311]                               next
[10:24:23.311]                             if (!grepl(pattern, name)) 
[10:24:23.311]                               next
[10:24:23.311]                             invokeRestart(restart)
[10:24:23.311]                             muffled <- TRUE
[10:24:23.311]                             break
[10:24:23.311]                           }
[10:24:23.311]                         }
[10:24:23.311]                       }
[10:24:23.311]                       invisible(muffled)
[10:24:23.311]                     }
[10:24:23.311]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.311]                   }
[10:24:23.311]                 }
[10:24:23.311]                 else {
[10:24:23.311]                   if (TRUE) {
[10:24:23.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.311]                     {
[10:24:23.311]                       inherits <- base::inherits
[10:24:23.311]                       invokeRestart <- base::invokeRestart
[10:24:23.311]                       is.null <- base::is.null
[10:24:23.311]                       muffled <- FALSE
[10:24:23.311]                       if (inherits(cond, "message")) {
[10:24:23.311]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.311]                         if (muffled) 
[10:24:23.311]                           invokeRestart("muffleMessage")
[10:24:23.311]                       }
[10:24:23.311]                       else if (inherits(cond, "warning")) {
[10:24:23.311]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.311]                         if (muffled) 
[10:24:23.311]                           invokeRestart("muffleWarning")
[10:24:23.311]                       }
[10:24:23.311]                       else if (inherits(cond, "condition")) {
[10:24:23.311]                         if (!is.null(pattern)) {
[10:24:23.311]                           computeRestarts <- base::computeRestarts
[10:24:23.311]                           grepl <- base::grepl
[10:24:23.311]                           restarts <- computeRestarts(cond)
[10:24:23.311]                           for (restart in restarts) {
[10:24:23.311]                             name <- restart$name
[10:24:23.311]                             if (is.null(name)) 
[10:24:23.311]                               next
[10:24:23.311]                             if (!grepl(pattern, name)) 
[10:24:23.311]                               next
[10:24:23.311]                             invokeRestart(restart)
[10:24:23.311]                             muffled <- TRUE
[10:24:23.311]                             break
[10:24:23.311]                           }
[10:24:23.311]                         }
[10:24:23.311]                       }
[10:24:23.311]                       invisible(muffled)
[10:24:23.311]                     }
[10:24:23.311]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.311]                   }
[10:24:23.311]                 }
[10:24:23.311]             }
[10:24:23.311]         }))
[10:24:23.311]     }, error = function(ex) {
[10:24:23.311]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:23.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.311]                 ...future.rng), started = ...future.startTime, 
[10:24:23.311]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:23.311]             version = "1.8"), class = "FutureResult")
[10:24:23.311]     }, finally = {
[10:24:23.311]         if (!identical(...future.workdir, getwd())) 
[10:24:23.311]             setwd(...future.workdir)
[10:24:23.311]         {
[10:24:23.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:23.311]                 ...future.oldOptions$nwarnings <- NULL
[10:24:23.311]             }
[10:24:23.311]             base::options(...future.oldOptions)
[10:24:23.311]             if (.Platform$OS.type == "windows") {
[10:24:23.311]                 old_names <- names(...future.oldEnvVars)
[10:24:23.311]                 envs <- base::Sys.getenv()
[10:24:23.311]                 names <- names(envs)
[10:24:23.311]                 common <- intersect(names, old_names)
[10:24:23.311]                 added <- setdiff(names, old_names)
[10:24:23.311]                 removed <- setdiff(old_names, names)
[10:24:23.311]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:23.311]                   envs[common]]
[10:24:23.311]                 NAMES <- toupper(changed)
[10:24:23.311]                 args <- list()
[10:24:23.311]                 for (kk in seq_along(NAMES)) {
[10:24:23.311]                   name <- changed[[kk]]
[10:24:23.311]                   NAME <- NAMES[[kk]]
[10:24:23.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.311]                     next
[10:24:23.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.311]                 }
[10:24:23.311]                 NAMES <- toupper(added)
[10:24:23.311]                 for (kk in seq_along(NAMES)) {
[10:24:23.311]                   name <- added[[kk]]
[10:24:23.311]                   NAME <- NAMES[[kk]]
[10:24:23.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.311]                     next
[10:24:23.311]                   args[[name]] <- ""
[10:24:23.311]                 }
[10:24:23.311]                 NAMES <- toupper(removed)
[10:24:23.311]                 for (kk in seq_along(NAMES)) {
[10:24:23.311]                   name <- removed[[kk]]
[10:24:23.311]                   NAME <- NAMES[[kk]]
[10:24:23.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.311]                     next
[10:24:23.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.311]                 }
[10:24:23.311]                 if (length(args) > 0) 
[10:24:23.311]                   base::do.call(base::Sys.setenv, args = args)
[10:24:23.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:23.311]             }
[10:24:23.311]             else {
[10:24:23.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:23.311]             }
[10:24:23.311]             {
[10:24:23.311]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:23.311]                   0L) {
[10:24:23.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:23.311]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:23.311]                   base::options(opts)
[10:24:23.311]                 }
[10:24:23.311]                 {
[10:24:23.311]                   {
[10:24:23.311]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:23.311]                     NULL
[10:24:23.311]                   }
[10:24:23.311]                   options(future.plan = NULL)
[10:24:23.311]                   if (is.na(NA_character_)) 
[10:24:23.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:23.311]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:23.311]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:23.311]                     envir = parent.frame()) 
[10:24:23.311]                   {
[10:24:23.311]                     if (is.function(workers)) 
[10:24:23.311]                       workers <- workers()
[10:24:23.311]                     workers <- structure(as.integer(workers), 
[10:24:23.311]                       class = class(workers))
[10:24:23.311]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:23.311]                       workers >= 1)
[10:24:23.311]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:23.311]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:23.311]                     }
[10:24:23.311]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:23.311]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:23.311]                       envir = envir)
[10:24:23.311]                     if (!future$lazy) 
[10:24:23.311]                       future <- run(future)
[10:24:23.311]                     invisible(future)
[10:24:23.311]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:23.311]                 }
[10:24:23.311]             }
[10:24:23.311]         }
[10:24:23.311]     })
[10:24:23.311]     if (TRUE) {
[10:24:23.311]         base::sink(type = "output", split = FALSE)
[10:24:23.311]         if (TRUE) {
[10:24:23.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:23.311]         }
[10:24:23.311]         else {
[10:24:23.311]             ...future.result["stdout"] <- base::list(NULL)
[10:24:23.311]         }
[10:24:23.311]         base::close(...future.stdout)
[10:24:23.311]         ...future.stdout <- NULL
[10:24:23.311]     }
[10:24:23.311]     ...future.result$conditions <- ...future.conditions
[10:24:23.311]     ...future.result$finished <- base::Sys.time()
[10:24:23.311]     ...future.result
[10:24:23.311] }
[10:24:23.314] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[10:24:23.314] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:23.358] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:23.358] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[10:24:23.358] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[10:24:23.358] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:23.359] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:23.359] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:23.402] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:23.402] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:23.446] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:23.446] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:24:23.446] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:24:23.447] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:24:23.447] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:24:23.447] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:23.448] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:23.448] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[10:24:23.448] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[10:24:23.448] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:23.449] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:23.449] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:23.449] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:23.449] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[10:24:23.450] MultisessionFuture started
[10:24:23.450] - Launch lazy future ... done
[10:24:23.450] run() for ‘MultisessionFuture’ ... done
[10:24:23.450] Created future:
[10:24:23.450] MultisessionFuture:
[10:24:23.450] Label: ‘future_vapply-1’
[10:24:23.450] Expression:
[10:24:23.450] {
[10:24:23.450]     do.call(function(...) {
[10:24:23.450]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.450]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.450]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.450]             on.exit(options(oopts), add = TRUE)
[10:24:23.450]         }
[10:24:23.450]         {
[10:24:23.450]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.450]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.450]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.450]             })
[10:24:23.450]         }
[10:24:23.450]     }, args = future.call.arguments)
[10:24:23.450] }
[10:24:23.450] Lazy evaluation: FALSE
[10:24:23.450] Asynchronous evaluation: TRUE
[10:24:23.450] Local evaluation: TRUE
[10:24:23.450] Environment: R_GlobalEnv
[10:24:23.450] Capture standard output: TRUE
[10:24:23.450] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:23.450] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:23.450] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:24:23.450] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:23.450] Resolved: FALSE
[10:24:23.450] Value: <not collected>
[10:24:23.450] Conditions captured: <none>
[10:24:23.450] Early signaling: FALSE
[10:24:23.450] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:23.450] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.462] Chunk #1 of 2 ... DONE
[10:24:23.462] Chunk #2 of 2 ...
[10:24:23.462]  - Finding globals in 'X' for chunk #2 ...
[10:24:23.462] getGlobalsAndPackages() ...
[10:24:23.463] Searching for globals...
[10:24:23.463] 
[10:24:23.463] Searching for globals ... DONE
[10:24:23.463] - globals: [0] <none>
[10:24:23.463] getGlobalsAndPackages() ... DONE
[10:24:23.463]    + additional globals found: [n=0] 
[10:24:23.463]    + additional namespaces needed: [n=0] 
[10:24:23.463]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:23.463]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:23.464]  - seeds: <none>
[10:24:23.464]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.464] getGlobalsAndPackages() ...
[10:24:23.464] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.464] Resolving globals: FALSE
[10:24:23.464] Tweak future expression to call with '...' arguments ...
[10:24:23.464] {
[10:24:23.464]     do.call(function(...) {
[10:24:23.464]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.464]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.464]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.464]             on.exit(options(oopts), add = TRUE)
[10:24:23.464]         }
[10:24:23.464]         {
[10:24:23.464]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.464]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.464]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.464]             })
[10:24:23.464]         }
[10:24:23.464]     }, args = future.call.arguments)
[10:24:23.464] }
[10:24:23.464] Tweak future expression to call with '...' arguments ... DONE
[10:24:23.465] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.465] - packages: [2] ‘stats’, ‘future.apply’
[10:24:23.465] getGlobalsAndPackages() ... DONE
[10:24:23.466] run() for ‘Future’ ...
[10:24:23.466] - state: ‘created’
[10:24:23.466] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:23.480] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.480] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:23.480]   - Field: ‘node’
[10:24:23.480]   - Field: ‘label’
[10:24:23.480]   - Field: ‘local’
[10:24:23.480]   - Field: ‘owner’
[10:24:23.480]   - Field: ‘envir’
[10:24:23.480]   - Field: ‘workers’
[10:24:23.481]   - Field: ‘packages’
[10:24:23.481]   - Field: ‘gc’
[10:24:23.481]   - Field: ‘conditions’
[10:24:23.481]   - Field: ‘persistent’
[10:24:23.481]   - Field: ‘expr’
[10:24:23.481]   - Field: ‘uuid’
[10:24:23.481]   - Field: ‘seed’
[10:24:23.481]   - Field: ‘version’
[10:24:23.481]   - Field: ‘result’
[10:24:23.481]   - Field: ‘asynchronous’
[10:24:23.481]   - Field: ‘calls’
[10:24:23.482]   - Field: ‘globals’
[10:24:23.482]   - Field: ‘stdout’
[10:24:23.482]   - Field: ‘earlySignal’
[10:24:23.482]   - Field: ‘lazy’
[10:24:23.482]   - Field: ‘state’
[10:24:23.482] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:23.482] - Launch lazy future ...
[10:24:23.482] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:24:23.483] Packages needed by future strategies (n = 0): <none>
[10:24:23.483] {
[10:24:23.483]     {
[10:24:23.483]         {
[10:24:23.483]             ...future.startTime <- base::Sys.time()
[10:24:23.483]             {
[10:24:23.483]                 {
[10:24:23.483]                   {
[10:24:23.483]                     {
[10:24:23.483]                       {
[10:24:23.483]                         base::local({
[10:24:23.483]                           has_future <- base::requireNamespace("future", 
[10:24:23.483]                             quietly = TRUE)
[10:24:23.483]                           if (has_future) {
[10:24:23.483]                             ns <- base::getNamespace("future")
[10:24:23.483]                             version <- ns[[".package"]][["version"]]
[10:24:23.483]                             if (is.null(version)) 
[10:24:23.483]                               version <- utils::packageVersion("future")
[10:24:23.483]                           }
[10:24:23.483]                           else {
[10:24:23.483]                             version <- NULL
[10:24:23.483]                           }
[10:24:23.483]                           if (!has_future || version < "1.8.0") {
[10:24:23.483]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:23.483]                               "", base::R.version$version.string), 
[10:24:23.483]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:23.483]                                 base::R.version$platform, 8 * 
[10:24:23.483]                                   base::.Machine$sizeof.pointer), 
[10:24:23.483]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:23.483]                                 "release", "version")], collapse = " "), 
[10:24:23.483]                               hostname = base::Sys.info()[["nodename"]])
[10:24:23.483]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:23.483]                               info)
[10:24:23.483]                             info <- base::paste(info, collapse = "; ")
[10:24:23.483]                             if (!has_future) {
[10:24:23.483]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:23.483]                                 info)
[10:24:23.483]                             }
[10:24:23.483]                             else {
[10:24:23.483]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:23.483]                                 info, version)
[10:24:23.483]                             }
[10:24:23.483]                             base::stop(msg)
[10:24:23.483]                           }
[10:24:23.483]                         })
[10:24:23.483]                       }
[10:24:23.483]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:23.483]                       base::options(mc.cores = 1L)
[10:24:23.483]                     }
[10:24:23.483]                     base::local({
[10:24:23.483]                       for (pkg in c("stats", "future.apply")) {
[10:24:23.483]                         base::loadNamespace(pkg)
[10:24:23.483]                         base::library(pkg, character.only = TRUE)
[10:24:23.483]                       }
[10:24:23.483]                     })
[10:24:23.483]                   }
[10:24:23.483]                   options(future.plan = NULL)
[10:24:23.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:23.483]                 }
[10:24:23.483]                 ...future.workdir <- getwd()
[10:24:23.483]             }
[10:24:23.483]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:23.483]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:23.483]         }
[10:24:23.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:23.483]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:23.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:23.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:23.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:23.483]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:23.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:23.483]             base::names(...future.oldOptions))
[10:24:23.483]     }
[10:24:23.483]     if (FALSE) {
[10:24:23.483]     }
[10:24:23.483]     else {
[10:24:23.483]         if (TRUE) {
[10:24:23.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:23.483]                 open = "w")
[10:24:23.483]         }
[10:24:23.483]         else {
[10:24:23.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:23.483]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:23.483]         }
[10:24:23.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:23.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:23.483]             base::sink(type = "output", split = FALSE)
[10:24:23.483]             base::close(...future.stdout)
[10:24:23.483]         }, add = TRUE)
[10:24:23.483]     }
[10:24:23.483]     ...future.frame <- base::sys.nframe()
[10:24:23.483]     ...future.conditions <- base::list()
[10:24:23.483]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:23.483]     if (FALSE) {
[10:24:23.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:23.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:23.483]     }
[10:24:23.483]     ...future.result <- base::tryCatch({
[10:24:23.483]         base::withCallingHandlers({
[10:24:23.483]             ...future.value <- base::withVisible(base::local({
[10:24:23.483]                 ...future.makeSendCondition <- base::local({
[10:24:23.483]                   sendCondition <- NULL
[10:24:23.483]                   function(frame = 1L) {
[10:24:23.483]                     if (is.function(sendCondition)) 
[10:24:23.483]                       return(sendCondition)
[10:24:23.483]                     ns <- getNamespace("parallel")
[10:24:23.483]                     if (exists("sendData", mode = "function", 
[10:24:23.483]                       envir = ns)) {
[10:24:23.483]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:23.483]                         envir = ns)
[10:24:23.483]                       envir <- sys.frame(frame)
[10:24:23.483]                       master <- NULL
[10:24:23.483]                       while (!identical(envir, .GlobalEnv) && 
[10:24:23.483]                         !identical(envir, emptyenv())) {
[10:24:23.483]                         if (exists("master", mode = "list", envir = envir, 
[10:24:23.483]                           inherits = FALSE)) {
[10:24:23.483]                           master <- get("master", mode = "list", 
[10:24:23.483]                             envir = envir, inherits = FALSE)
[10:24:23.483]                           if (inherits(master, c("SOCKnode", 
[10:24:23.483]                             "SOCK0node"))) {
[10:24:23.483]                             sendCondition <<- function(cond) {
[10:24:23.483]                               data <- list(type = "VALUE", value = cond, 
[10:24:23.483]                                 success = TRUE)
[10:24:23.483]                               parallel_sendData(master, data)
[10:24:23.483]                             }
[10:24:23.483]                             return(sendCondition)
[10:24:23.483]                           }
[10:24:23.483]                         }
[10:24:23.483]                         frame <- frame + 1L
[10:24:23.483]                         envir <- sys.frame(frame)
[10:24:23.483]                       }
[10:24:23.483]                     }
[10:24:23.483]                     sendCondition <<- function(cond) NULL
[10:24:23.483]                   }
[10:24:23.483]                 })
[10:24:23.483]                 withCallingHandlers({
[10:24:23.483]                   {
[10:24:23.483]                     do.call(function(...) {
[10:24:23.483]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.483]                       if (!identical(...future.globals.maxSize.org, 
[10:24:23.483]                         ...future.globals.maxSize)) {
[10:24:23.483]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.483]                         on.exit(options(oopts), add = TRUE)
[10:24:23.483]                       }
[10:24:23.483]                       {
[10:24:23.483]                         lapply(seq_along(...future.elements_ii), 
[10:24:23.483]                           FUN = function(jj) {
[10:24:23.483]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.483]                             ...future.FUN(...future.X_jj, ...)
[10:24:23.483]                           })
[10:24:23.483]                       }
[10:24:23.483]                     }, args = future.call.arguments)
[10:24:23.483]                   }
[10:24:23.483]                 }, immediateCondition = function(cond) {
[10:24:23.483]                   sendCondition <- ...future.makeSendCondition()
[10:24:23.483]                   sendCondition(cond)
[10:24:23.483]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.483]                   {
[10:24:23.483]                     inherits <- base::inherits
[10:24:23.483]                     invokeRestart <- base::invokeRestart
[10:24:23.483]                     is.null <- base::is.null
[10:24:23.483]                     muffled <- FALSE
[10:24:23.483]                     if (inherits(cond, "message")) {
[10:24:23.483]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:23.483]                       if (muffled) 
[10:24:23.483]                         invokeRestart("muffleMessage")
[10:24:23.483]                     }
[10:24:23.483]                     else if (inherits(cond, "warning")) {
[10:24:23.483]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:23.483]                       if (muffled) 
[10:24:23.483]                         invokeRestart("muffleWarning")
[10:24:23.483]                     }
[10:24:23.483]                     else if (inherits(cond, "condition")) {
[10:24:23.483]                       if (!is.null(pattern)) {
[10:24:23.483]                         computeRestarts <- base::computeRestarts
[10:24:23.483]                         grepl <- base::grepl
[10:24:23.483]                         restarts <- computeRestarts(cond)
[10:24:23.483]                         for (restart in restarts) {
[10:24:23.483]                           name <- restart$name
[10:24:23.483]                           if (is.null(name)) 
[10:24:23.483]                             next
[10:24:23.483]                           if (!grepl(pattern, name)) 
[10:24:23.483]                             next
[10:24:23.483]                           invokeRestart(restart)
[10:24:23.483]                           muffled <- TRUE
[10:24:23.483]                           break
[10:24:23.483]                         }
[10:24:23.483]                       }
[10:24:23.483]                     }
[10:24:23.483]                     invisible(muffled)
[10:24:23.483]                   }
[10:24:23.483]                   muffleCondition(cond)
[10:24:23.483]                 })
[10:24:23.483]             }))
[10:24:23.483]             future::FutureResult(value = ...future.value$value, 
[10:24:23.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.483]                   ...future.rng), globalenv = if (FALSE) 
[10:24:23.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:23.483]                     ...future.globalenv.names))
[10:24:23.483]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:23.483]         }, condition = base::local({
[10:24:23.483]             c <- base::c
[10:24:23.483]             inherits <- base::inherits
[10:24:23.483]             invokeRestart <- base::invokeRestart
[10:24:23.483]             length <- base::length
[10:24:23.483]             list <- base::list
[10:24:23.483]             seq.int <- base::seq.int
[10:24:23.483]             signalCondition <- base::signalCondition
[10:24:23.483]             sys.calls <- base::sys.calls
[10:24:23.483]             `[[` <- base::`[[`
[10:24:23.483]             `+` <- base::`+`
[10:24:23.483]             `<<-` <- base::`<<-`
[10:24:23.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:23.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:23.483]                   3L)]
[10:24:23.483]             }
[10:24:23.483]             function(cond) {
[10:24:23.483]                 is_error <- inherits(cond, "error")
[10:24:23.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:23.483]                   NULL)
[10:24:23.483]                 if (is_error) {
[10:24:23.483]                   sessionInformation <- function() {
[10:24:23.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:23.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:23.483]                       search = base::search(), system = base::Sys.info())
[10:24:23.483]                   }
[10:24:23.483]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:23.483]                     cond$call), session = sessionInformation(), 
[10:24:23.483]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:23.483]                   signalCondition(cond)
[10:24:23.483]                 }
[10:24:23.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:23.483]                 "immediateCondition"))) {
[10:24:23.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:23.483]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:23.483]                   if (TRUE && !signal) {
[10:24:23.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.483]                     {
[10:24:23.483]                       inherits <- base::inherits
[10:24:23.483]                       invokeRestart <- base::invokeRestart
[10:24:23.483]                       is.null <- base::is.null
[10:24:23.483]                       muffled <- FALSE
[10:24:23.483]                       if (inherits(cond, "message")) {
[10:24:23.483]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.483]                         if (muffled) 
[10:24:23.483]                           invokeRestart("muffleMessage")
[10:24:23.483]                       }
[10:24:23.483]                       else if (inherits(cond, "warning")) {
[10:24:23.483]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.483]                         if (muffled) 
[10:24:23.483]                           invokeRestart("muffleWarning")
[10:24:23.483]                       }
[10:24:23.483]                       else if (inherits(cond, "condition")) {
[10:24:23.483]                         if (!is.null(pattern)) {
[10:24:23.483]                           computeRestarts <- base::computeRestarts
[10:24:23.483]                           grepl <- base::grepl
[10:24:23.483]                           restarts <- computeRestarts(cond)
[10:24:23.483]                           for (restart in restarts) {
[10:24:23.483]                             name <- restart$name
[10:24:23.483]                             if (is.null(name)) 
[10:24:23.483]                               next
[10:24:23.483]                             if (!grepl(pattern, name)) 
[10:24:23.483]                               next
[10:24:23.483]                             invokeRestart(restart)
[10:24:23.483]                             muffled <- TRUE
[10:24:23.483]                             break
[10:24:23.483]                           }
[10:24:23.483]                         }
[10:24:23.483]                       }
[10:24:23.483]                       invisible(muffled)
[10:24:23.483]                     }
[10:24:23.483]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.483]                   }
[10:24:23.483]                 }
[10:24:23.483]                 else {
[10:24:23.483]                   if (TRUE) {
[10:24:23.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.483]                     {
[10:24:23.483]                       inherits <- base::inherits
[10:24:23.483]                       invokeRestart <- base::invokeRestart
[10:24:23.483]                       is.null <- base::is.null
[10:24:23.483]                       muffled <- FALSE
[10:24:23.483]                       if (inherits(cond, "message")) {
[10:24:23.483]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.483]                         if (muffled) 
[10:24:23.483]                           invokeRestart("muffleMessage")
[10:24:23.483]                       }
[10:24:23.483]                       else if (inherits(cond, "warning")) {
[10:24:23.483]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.483]                         if (muffled) 
[10:24:23.483]                           invokeRestart("muffleWarning")
[10:24:23.483]                       }
[10:24:23.483]                       else if (inherits(cond, "condition")) {
[10:24:23.483]                         if (!is.null(pattern)) {
[10:24:23.483]                           computeRestarts <- base::computeRestarts
[10:24:23.483]                           grepl <- base::grepl
[10:24:23.483]                           restarts <- computeRestarts(cond)
[10:24:23.483]                           for (restart in restarts) {
[10:24:23.483]                             name <- restart$name
[10:24:23.483]                             if (is.null(name)) 
[10:24:23.483]                               next
[10:24:23.483]                             if (!grepl(pattern, name)) 
[10:24:23.483]                               next
[10:24:23.483]                             invokeRestart(restart)
[10:24:23.483]                             muffled <- TRUE
[10:24:23.483]                             break
[10:24:23.483]                           }
[10:24:23.483]                         }
[10:24:23.483]                       }
[10:24:23.483]                       invisible(muffled)
[10:24:23.483]                     }
[10:24:23.483]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.483]                   }
[10:24:23.483]                 }
[10:24:23.483]             }
[10:24:23.483]         }))
[10:24:23.483]     }, error = function(ex) {
[10:24:23.483]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:23.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.483]                 ...future.rng), started = ...future.startTime, 
[10:24:23.483]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:23.483]             version = "1.8"), class = "FutureResult")
[10:24:23.483]     }, finally = {
[10:24:23.483]         if (!identical(...future.workdir, getwd())) 
[10:24:23.483]             setwd(...future.workdir)
[10:24:23.483]         {
[10:24:23.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:23.483]                 ...future.oldOptions$nwarnings <- NULL
[10:24:23.483]             }
[10:24:23.483]             base::options(...future.oldOptions)
[10:24:23.483]             if (.Platform$OS.type == "windows") {
[10:24:23.483]                 old_names <- names(...future.oldEnvVars)
[10:24:23.483]                 envs <- base::Sys.getenv()
[10:24:23.483]                 names <- names(envs)
[10:24:23.483]                 common <- intersect(names, old_names)
[10:24:23.483]                 added <- setdiff(names, old_names)
[10:24:23.483]                 removed <- setdiff(old_names, names)
[10:24:23.483]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:23.483]                   envs[common]]
[10:24:23.483]                 NAMES <- toupper(changed)
[10:24:23.483]                 args <- list()
[10:24:23.483]                 for (kk in seq_along(NAMES)) {
[10:24:23.483]                   name <- changed[[kk]]
[10:24:23.483]                   NAME <- NAMES[[kk]]
[10:24:23.483]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.483]                     next
[10:24:23.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.483]                 }
[10:24:23.483]                 NAMES <- toupper(added)
[10:24:23.483]                 for (kk in seq_along(NAMES)) {
[10:24:23.483]                   name <- added[[kk]]
[10:24:23.483]                   NAME <- NAMES[[kk]]
[10:24:23.483]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.483]                     next
[10:24:23.483]                   args[[name]] <- ""
[10:24:23.483]                 }
[10:24:23.483]                 NAMES <- toupper(removed)
[10:24:23.483]                 for (kk in seq_along(NAMES)) {
[10:24:23.483]                   name <- removed[[kk]]
[10:24:23.483]                   NAME <- NAMES[[kk]]
[10:24:23.483]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.483]                     next
[10:24:23.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.483]                 }
[10:24:23.483]                 if (length(args) > 0) 
[10:24:23.483]                   base::do.call(base::Sys.setenv, args = args)
[10:24:23.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:23.483]             }
[10:24:23.483]             else {
[10:24:23.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:23.483]             }
[10:24:23.483]             {
[10:24:23.483]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:23.483]                   0L) {
[10:24:23.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:23.483]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:23.483]                   base::options(opts)
[10:24:23.483]                 }
[10:24:23.483]                 {
[10:24:23.483]                   {
[10:24:23.483]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:23.483]                     NULL
[10:24:23.483]                   }
[10:24:23.483]                   options(future.plan = NULL)
[10:24:23.483]                   if (is.na(NA_character_)) 
[10:24:23.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:23.483]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:23.483]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:23.483]                     envir = parent.frame()) 
[10:24:23.483]                   {
[10:24:23.483]                     if (is.function(workers)) 
[10:24:23.483]                       workers <- workers()
[10:24:23.483]                     workers <- structure(as.integer(workers), 
[10:24:23.483]                       class = class(workers))
[10:24:23.483]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:23.483]                       workers >= 1)
[10:24:23.483]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:23.483]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:23.483]                     }
[10:24:23.483]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:23.483]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:23.483]                       envir = envir)
[10:24:23.483]                     if (!future$lazy) 
[10:24:23.483]                       future <- run(future)
[10:24:23.483]                     invisible(future)
[10:24:23.483]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:23.483]                 }
[10:24:23.483]             }
[10:24:23.483]         }
[10:24:23.483]     })
[10:24:23.483]     if (TRUE) {
[10:24:23.483]         base::sink(type = "output", split = FALSE)
[10:24:23.483]         if (TRUE) {
[10:24:23.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:23.483]         }
[10:24:23.483]         else {
[10:24:23.483]             ...future.result["stdout"] <- base::list(NULL)
[10:24:23.483]         }
[10:24:23.483]         base::close(...future.stdout)
[10:24:23.483]         ...future.stdout <- NULL
[10:24:23.483]     }
[10:24:23.483]     ...future.result$conditions <- ...future.conditions
[10:24:23.483]     ...future.result$finished <- base::Sys.time()
[10:24:23.483]     ...future.result
[10:24:23.483] }
[10:24:23.486] Exporting 11 global objects (93.29 KiB) to cluster node #2 ...
[10:24:23.486] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:23.534] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:23.534] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ...
[10:24:23.534] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ... DONE
[10:24:23.535] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:23.535] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:23.535] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:23.578] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:23.578] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:23.622] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:23.622] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:24:23.622] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:24:23.622] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:24:23.623] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:24:23.623] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:23.623] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:23.624] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ...
[10:24:23.624] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ... DONE
[10:24:23.624] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:23.624] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:23.625] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:23.625] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:23.625] Exporting 11 global objects (93.29 KiB) to cluster node #2 ... DONE
[10:24:23.626] MultisessionFuture started
[10:24:23.626] - Launch lazy future ... done
[10:24:23.626] run() for ‘MultisessionFuture’ ... done
[10:24:23.626] Created future:
[10:24:23.626] MultisessionFuture:
[10:24:23.626] Label: ‘future_vapply-2’
[10:24:23.626] Expression:
[10:24:23.626] {
[10:24:23.626]     do.call(function(...) {
[10:24:23.626]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.626]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.626]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.626]             on.exit(options(oopts), add = TRUE)
[10:24:23.626]         }
[10:24:23.626]         {
[10:24:23.626]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.626]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.626]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.626]             })
[10:24:23.626]         }
[10:24:23.626]     }, args = future.call.arguments)
[10:24:23.626] }
[10:24:23.626] Lazy evaluation: FALSE
[10:24:23.626] Asynchronous evaluation: TRUE
[10:24:23.626] Local evaluation: TRUE
[10:24:23.626] Environment: R_GlobalEnv
[10:24:23.626] Capture standard output: TRUE
[10:24:23.626] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:23.626] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:23.626] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:24:23.626] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:23.626] Resolved: FALSE
[10:24:23.626] Value: <not collected>
[10:24:23.626] Conditions captured: <none>
[10:24:23.626] Early signaling: FALSE
[10:24:23.626] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:23.626] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.638] Chunk #2 of 2 ... DONE
[10:24:23.638] Launching 2 futures (chunks) ... DONE
[10:24:23.638] Resolving 2 futures (chunks) ...
[10:24:23.639] resolve() on list ...
[10:24:23.639]  recursive: 0
[10:24:23.639]  length: 2
[10:24:23.639] 
[10:24:23.639] receiveMessageFromWorker() for ClusterFuture ...
[10:24:23.640] - Validating connection of MultisessionFuture
[10:24:23.640] - received message: FutureResult
[10:24:23.640] - Received FutureResult
[10:24:23.640] - Erased future from FutureRegistry
[10:24:23.640] result() for ClusterFuture ...
[10:24:23.640] - result already collected: FutureResult
[10:24:23.640] result() for ClusterFuture ... done
[10:24:23.640] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:23.640] Future #1
[10:24:23.641] result() for ClusterFuture ...
[10:24:23.641] - result already collected: FutureResult
[10:24:23.641] result() for ClusterFuture ... done
[10:24:23.641] result() for ClusterFuture ...
[10:24:23.641] - result already collected: FutureResult
[10:24:23.641] result() for ClusterFuture ... done
[10:24:23.641] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:23.641] - nx: 2
[10:24:23.641] - relay: TRUE
[10:24:23.641] - stdout: TRUE
[10:24:23.641] - signal: TRUE
[10:24:23.642] - resignal: FALSE
[10:24:23.642] - force: TRUE
[10:24:23.642] - relayed: [n=2] FALSE, FALSE
[10:24:23.642] - queued futures: [n=2] FALSE, FALSE
[10:24:23.642]  - until=1
[10:24:23.642]  - relaying element #1
[10:24:23.642] result() for ClusterFuture ...
[10:24:23.642] - result already collected: FutureResult
[10:24:23.642] result() for ClusterFuture ... done
[10:24:23.642] result() for ClusterFuture ...
[10:24:23.642] - result already collected: FutureResult
[10:24:23.643] result() for ClusterFuture ... done
[10:24:23.643] result() for ClusterFuture ...
[10:24:23.643] - result already collected: FutureResult
[10:24:23.643] result() for ClusterFuture ... done
[10:24:23.643] result() for ClusterFuture ...
[10:24:23.643] - result already collected: FutureResult
[10:24:23.643] result() for ClusterFuture ... done
[10:24:23.643] - relayed: [n=2] TRUE, FALSE
[10:24:23.643] - queued futures: [n=2] TRUE, FALSE
[10:24:23.643] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:23.643]  length: 1 (resolved future 1)
[10:24:23.685] receiveMessageFromWorker() for ClusterFuture ...
[10:24:23.685] - Validating connection of MultisessionFuture
[10:24:23.686] - received message: FutureResult
[10:24:23.686] - Received FutureResult
[10:24:23.686] - Erased future from FutureRegistry
[10:24:23.686] result() for ClusterFuture ...
[10:24:23.686] - result already collected: FutureResult
[10:24:23.686] result() for ClusterFuture ... done
[10:24:23.686] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:23.686] Future #2
[10:24:23.686] result() for ClusterFuture ...
[10:24:23.686] - result already collected: FutureResult
[10:24:23.687] result() for ClusterFuture ... done
[10:24:23.687] result() for ClusterFuture ...
[10:24:23.687] - result already collected: FutureResult
[10:24:23.687] result() for ClusterFuture ... done
[10:24:23.687] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:23.687] - nx: 2
[10:24:23.687] - relay: TRUE
[10:24:23.687] - stdout: TRUE
[10:24:23.687] - signal: TRUE
[10:24:23.687] - resignal: FALSE
[10:24:23.687] - force: TRUE
[10:24:23.687] - relayed: [n=2] TRUE, FALSE
[10:24:23.688] - queued futures: [n=2] TRUE, FALSE
[10:24:23.688]  - until=2
[10:24:23.688]  - relaying element #2
[10:24:23.688] result() for ClusterFuture ...
[10:24:23.688] - result already collected: FutureResult
[10:24:23.688] result() for ClusterFuture ... done
[10:24:23.688] result() for ClusterFuture ...
[10:24:23.688] - result already collected: FutureResult
[10:24:23.688] result() for ClusterFuture ... done
[10:24:23.688] result() for ClusterFuture ...
[10:24:23.688] - result already collected: FutureResult
[10:24:23.689] result() for ClusterFuture ... done
[10:24:23.689] result() for ClusterFuture ...
[10:24:23.689] - result already collected: FutureResult
[10:24:23.689] result() for ClusterFuture ... done
[10:24:23.689] - relayed: [n=2] TRUE, TRUE
[10:24:23.689] - queued futures: [n=2] TRUE, TRUE
[10:24:23.689] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:23.689]  length: 0 (resolved future 2)
[10:24:23.689] Relaying remaining futures
[10:24:23.689] signalConditionsASAP(NULL, pos=0) ...
[10:24:23.689] - nx: 2
[10:24:23.690] - relay: TRUE
[10:24:23.690] - stdout: TRUE
[10:24:23.690] - signal: TRUE
[10:24:23.690] - resignal: FALSE
[10:24:23.690] - force: TRUE
[10:24:23.690] - relayed: [n=2] TRUE, TRUE
[10:24:23.690] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:23.690] - relayed: [n=2] TRUE, TRUE
[10:24:23.690] - queued futures: [n=2] TRUE, TRUE
[10:24:23.690] signalConditionsASAP(NULL, pos=0) ... done
[10:24:23.690] resolve() on list ... DONE
[10:24:23.691] result() for ClusterFuture ...
[10:24:23.691] - result already collected: FutureResult
[10:24:23.691] result() for ClusterFuture ... done
[10:24:23.691] result() for ClusterFuture ...
[10:24:23.691] - result already collected: FutureResult
[10:24:23.691] result() for ClusterFuture ... done
[10:24:23.691] result() for ClusterFuture ...
[10:24:23.691] - result already collected: FutureResult
[10:24:23.691] result() for ClusterFuture ... done
[10:24:23.691] result() for ClusterFuture ...
[10:24:23.691] - result already collected: FutureResult
[10:24:23.692] result() for ClusterFuture ... done
[10:24:23.692]  - Number of value chunks collected: 2
[10:24:23.692] Resolving 2 futures (chunks) ... DONE
[10:24:23.692] Reducing values from 2 chunks ...
[10:24:23.692]  - Number of values collected after concatenation: 3
[10:24:23.692]  - Number of values expected: 3
[10:24:23.692] Reducing values from 2 chunks ... DONE
[10:24:23.692] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[10:24:23.694] future_lapply() ...
[10:24:23.702] Number of chunks: 2
[10:24:23.702] getGlobalsAndPackagesXApply() ...
[10:24:23.702]  - future.globals: TRUE
[10:24:23.702] getGlobalsAndPackages() ...
[10:24:23.702] Searching for globals...
[10:24:23.707] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:24:23.707] Searching for globals ... DONE
[10:24:23.707] Resolving globals: FALSE
[10:24:23.708] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[10:24:23.708] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[10:24:23.709] - globals: [1] ‘FUN’
[10:24:23.709] - packages: [1] ‘stats’
[10:24:23.709] getGlobalsAndPackages() ... DONE
[10:24:23.709]  - globals found/used: [n=1] ‘FUN’
[10:24:23.709]  - needed namespaces: [n=1] ‘stats’
[10:24:23.709] Finding globals ... DONE
[10:24:23.709]  - use_args: TRUE
[10:24:23.709]  - Getting '...' globals ...
[10:24:23.710] resolve() on list ...
[10:24:23.710]  recursive: 0
[10:24:23.710]  length: 1
[10:24:23.710]  elements: ‘...’
[10:24:23.710]  length: 0 (resolved future 1)
[10:24:23.710] resolve() on list ... DONE
[10:24:23.710]    - '...' content: [n=0] 
[10:24:23.710] List of 1
[10:24:23.710]  $ ...: list()
[10:24:23.710]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:23.710]  - attr(*, "where")=List of 1
[10:24:23.710]   ..$ ...:<environment: 0x55b93e5bad90> 
[10:24:23.710]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:23.710]  - attr(*, "resolved")= logi TRUE
[10:24:23.710]  - attr(*, "total_size")= num NA
[10:24:23.713]  - Getting '...' globals ... DONE
[10:24:23.713] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:23.713] List of 2
[10:24:23.713]  $ ...future.FUN:function (x, na.rm = TRUE)  
[10:24:23.713]  $ ...          : list()
[10:24:23.713]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:23.713]  - attr(*, "where")=List of 2
[10:24:23.713]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:23.713]   ..$ ...          :<environment: 0x55b93e5bad90> 
[10:24:23.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:23.713]  - attr(*, "resolved")= logi FALSE
[10:24:23.713]  - attr(*, "total_size")= num 46960
[10:24:23.716] Packages to be attached in all futures: [n=1] ‘stats’
[10:24:23.716] getGlobalsAndPackagesXApply() ... DONE
[10:24:23.716] Number of futures (= number of chunks): 2
[10:24:23.716] Launching 2 futures (chunks) ...
[10:24:23.716] Chunk #1 of 2 ...
[10:24:23.716]  - Finding globals in 'X' for chunk #1 ...
[10:24:23.717] getGlobalsAndPackages() ...
[10:24:23.717] Searching for globals...
[10:24:23.717] 
[10:24:23.717] Searching for globals ... DONE
[10:24:23.717] - globals: [0] <none>
[10:24:23.717] getGlobalsAndPackages() ... DONE
[10:24:23.717]    + additional globals found: [n=0] 
[10:24:23.717]    + additional namespaces needed: [n=0] 
[10:24:23.717]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:23.718]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:23.718]  - seeds: <none>
[10:24:23.718]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.718] getGlobalsAndPackages() ...
[10:24:23.718] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.718] Resolving globals: FALSE
[10:24:23.718] Tweak future expression to call with '...' arguments ...
[10:24:23.718] {
[10:24:23.718]     do.call(function(...) {
[10:24:23.718]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.718]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.718]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.718]             on.exit(options(oopts), add = TRUE)
[10:24:23.718]         }
[10:24:23.718]         {
[10:24:23.718]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.718]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.718]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.718]             })
[10:24:23.718]         }
[10:24:23.718]     }, args = future.call.arguments)
[10:24:23.718] }
[10:24:23.719] Tweak future expression to call with '...' arguments ... DONE
[10:24:23.719] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.719] - packages: [1] ‘stats’
[10:24:23.719] getGlobalsAndPackages() ... DONE
[10:24:23.719] run() for ‘Future’ ...
[10:24:23.720] - state: ‘created’
[10:24:23.720] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:23.733] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.734] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:23.734]   - Field: ‘node’
[10:24:23.734]   - Field: ‘label’
[10:24:23.734]   - Field: ‘local’
[10:24:23.734]   - Field: ‘owner’
[10:24:23.734]   - Field: ‘envir’
[10:24:23.734]   - Field: ‘workers’
[10:24:23.734]   - Field: ‘packages’
[10:24:23.734]   - Field: ‘gc’
[10:24:23.734]   - Field: ‘conditions’
[10:24:23.735]   - Field: ‘persistent’
[10:24:23.735]   - Field: ‘expr’
[10:24:23.735]   - Field: ‘uuid’
[10:24:23.735]   - Field: ‘seed’
[10:24:23.735]   - Field: ‘version’
[10:24:23.735]   - Field: ‘result’
[10:24:23.735]   - Field: ‘asynchronous’
[10:24:23.735]   - Field: ‘calls’
[10:24:23.735]   - Field: ‘globals’
[10:24:23.735]   - Field: ‘stdout’
[10:24:23.735]   - Field: ‘earlySignal’
[10:24:23.736]   - Field: ‘lazy’
[10:24:23.736]   - Field: ‘state’
[10:24:23.736] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:23.736] - Launch lazy future ...
[10:24:23.736] Packages needed by the future expression (n = 1): ‘stats’
[10:24:23.736] Packages needed by future strategies (n = 0): <none>
[10:24:23.737] {
[10:24:23.737]     {
[10:24:23.737]         {
[10:24:23.737]             ...future.startTime <- base::Sys.time()
[10:24:23.737]             {
[10:24:23.737]                 {
[10:24:23.737]                   {
[10:24:23.737]                     {
[10:24:23.737]                       {
[10:24:23.737]                         base::local({
[10:24:23.737]                           has_future <- base::requireNamespace("future", 
[10:24:23.737]                             quietly = TRUE)
[10:24:23.737]                           if (has_future) {
[10:24:23.737]                             ns <- base::getNamespace("future")
[10:24:23.737]                             version <- ns[[".package"]][["version"]]
[10:24:23.737]                             if (is.null(version)) 
[10:24:23.737]                               version <- utils::packageVersion("future")
[10:24:23.737]                           }
[10:24:23.737]                           else {
[10:24:23.737]                             version <- NULL
[10:24:23.737]                           }
[10:24:23.737]                           if (!has_future || version < "1.8.0") {
[10:24:23.737]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:23.737]                               "", base::R.version$version.string), 
[10:24:23.737]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:23.737]                                 base::R.version$platform, 8 * 
[10:24:23.737]                                   base::.Machine$sizeof.pointer), 
[10:24:23.737]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:23.737]                                 "release", "version")], collapse = " "), 
[10:24:23.737]                               hostname = base::Sys.info()[["nodename"]])
[10:24:23.737]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:23.737]                               info)
[10:24:23.737]                             info <- base::paste(info, collapse = "; ")
[10:24:23.737]                             if (!has_future) {
[10:24:23.737]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:23.737]                                 info)
[10:24:23.737]                             }
[10:24:23.737]                             else {
[10:24:23.737]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:23.737]                                 info, version)
[10:24:23.737]                             }
[10:24:23.737]                             base::stop(msg)
[10:24:23.737]                           }
[10:24:23.737]                         })
[10:24:23.737]                       }
[10:24:23.737]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:23.737]                       base::options(mc.cores = 1L)
[10:24:23.737]                     }
[10:24:23.737]                     base::local({
[10:24:23.737]                       for (pkg in "stats") {
[10:24:23.737]                         base::loadNamespace(pkg)
[10:24:23.737]                         base::library(pkg, character.only = TRUE)
[10:24:23.737]                       }
[10:24:23.737]                     })
[10:24:23.737]                   }
[10:24:23.737]                   options(future.plan = NULL)
[10:24:23.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:23.737]                 }
[10:24:23.737]                 ...future.workdir <- getwd()
[10:24:23.737]             }
[10:24:23.737]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:23.737]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:23.737]         }
[10:24:23.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:23.737]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:23.737]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:23.737]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:23.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:23.737]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:23.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:23.737]             base::names(...future.oldOptions))
[10:24:23.737]     }
[10:24:23.737]     if (FALSE) {
[10:24:23.737]     }
[10:24:23.737]     else {
[10:24:23.737]         if (TRUE) {
[10:24:23.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:23.737]                 open = "w")
[10:24:23.737]         }
[10:24:23.737]         else {
[10:24:23.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:23.737]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:23.737]         }
[10:24:23.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:23.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:23.737]             base::sink(type = "output", split = FALSE)
[10:24:23.737]             base::close(...future.stdout)
[10:24:23.737]         }, add = TRUE)
[10:24:23.737]     }
[10:24:23.737]     ...future.frame <- base::sys.nframe()
[10:24:23.737]     ...future.conditions <- base::list()
[10:24:23.737]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:23.737]     if (FALSE) {
[10:24:23.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:23.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:23.737]     }
[10:24:23.737]     ...future.result <- base::tryCatch({
[10:24:23.737]         base::withCallingHandlers({
[10:24:23.737]             ...future.value <- base::withVisible(base::local({
[10:24:23.737]                 ...future.makeSendCondition <- base::local({
[10:24:23.737]                   sendCondition <- NULL
[10:24:23.737]                   function(frame = 1L) {
[10:24:23.737]                     if (is.function(sendCondition)) 
[10:24:23.737]                       return(sendCondition)
[10:24:23.737]                     ns <- getNamespace("parallel")
[10:24:23.737]                     if (exists("sendData", mode = "function", 
[10:24:23.737]                       envir = ns)) {
[10:24:23.737]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:23.737]                         envir = ns)
[10:24:23.737]                       envir <- sys.frame(frame)
[10:24:23.737]                       master <- NULL
[10:24:23.737]                       while (!identical(envir, .GlobalEnv) && 
[10:24:23.737]                         !identical(envir, emptyenv())) {
[10:24:23.737]                         if (exists("master", mode = "list", envir = envir, 
[10:24:23.737]                           inherits = FALSE)) {
[10:24:23.737]                           master <- get("master", mode = "list", 
[10:24:23.737]                             envir = envir, inherits = FALSE)
[10:24:23.737]                           if (inherits(master, c("SOCKnode", 
[10:24:23.737]                             "SOCK0node"))) {
[10:24:23.737]                             sendCondition <<- function(cond) {
[10:24:23.737]                               data <- list(type = "VALUE", value = cond, 
[10:24:23.737]                                 success = TRUE)
[10:24:23.737]                               parallel_sendData(master, data)
[10:24:23.737]                             }
[10:24:23.737]                             return(sendCondition)
[10:24:23.737]                           }
[10:24:23.737]                         }
[10:24:23.737]                         frame <- frame + 1L
[10:24:23.737]                         envir <- sys.frame(frame)
[10:24:23.737]                       }
[10:24:23.737]                     }
[10:24:23.737]                     sendCondition <<- function(cond) NULL
[10:24:23.737]                   }
[10:24:23.737]                 })
[10:24:23.737]                 withCallingHandlers({
[10:24:23.737]                   {
[10:24:23.737]                     do.call(function(...) {
[10:24:23.737]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.737]                       if (!identical(...future.globals.maxSize.org, 
[10:24:23.737]                         ...future.globals.maxSize)) {
[10:24:23.737]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.737]                         on.exit(options(oopts), add = TRUE)
[10:24:23.737]                       }
[10:24:23.737]                       {
[10:24:23.737]                         lapply(seq_along(...future.elements_ii), 
[10:24:23.737]                           FUN = function(jj) {
[10:24:23.737]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.737]                             ...future.FUN(...future.X_jj, ...)
[10:24:23.737]                           })
[10:24:23.737]                       }
[10:24:23.737]                     }, args = future.call.arguments)
[10:24:23.737]                   }
[10:24:23.737]                 }, immediateCondition = function(cond) {
[10:24:23.737]                   sendCondition <- ...future.makeSendCondition()
[10:24:23.737]                   sendCondition(cond)
[10:24:23.737]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.737]                   {
[10:24:23.737]                     inherits <- base::inherits
[10:24:23.737]                     invokeRestart <- base::invokeRestart
[10:24:23.737]                     is.null <- base::is.null
[10:24:23.737]                     muffled <- FALSE
[10:24:23.737]                     if (inherits(cond, "message")) {
[10:24:23.737]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:23.737]                       if (muffled) 
[10:24:23.737]                         invokeRestart("muffleMessage")
[10:24:23.737]                     }
[10:24:23.737]                     else if (inherits(cond, "warning")) {
[10:24:23.737]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:23.737]                       if (muffled) 
[10:24:23.737]                         invokeRestart("muffleWarning")
[10:24:23.737]                     }
[10:24:23.737]                     else if (inherits(cond, "condition")) {
[10:24:23.737]                       if (!is.null(pattern)) {
[10:24:23.737]                         computeRestarts <- base::computeRestarts
[10:24:23.737]                         grepl <- base::grepl
[10:24:23.737]                         restarts <- computeRestarts(cond)
[10:24:23.737]                         for (restart in restarts) {
[10:24:23.737]                           name <- restart$name
[10:24:23.737]                           if (is.null(name)) 
[10:24:23.737]                             next
[10:24:23.737]                           if (!grepl(pattern, name)) 
[10:24:23.737]                             next
[10:24:23.737]                           invokeRestart(restart)
[10:24:23.737]                           muffled <- TRUE
[10:24:23.737]                           break
[10:24:23.737]                         }
[10:24:23.737]                       }
[10:24:23.737]                     }
[10:24:23.737]                     invisible(muffled)
[10:24:23.737]                   }
[10:24:23.737]                   muffleCondition(cond)
[10:24:23.737]                 })
[10:24:23.737]             }))
[10:24:23.737]             future::FutureResult(value = ...future.value$value, 
[10:24:23.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.737]                   ...future.rng), globalenv = if (FALSE) 
[10:24:23.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:23.737]                     ...future.globalenv.names))
[10:24:23.737]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:23.737]         }, condition = base::local({
[10:24:23.737]             c <- base::c
[10:24:23.737]             inherits <- base::inherits
[10:24:23.737]             invokeRestart <- base::invokeRestart
[10:24:23.737]             length <- base::length
[10:24:23.737]             list <- base::list
[10:24:23.737]             seq.int <- base::seq.int
[10:24:23.737]             signalCondition <- base::signalCondition
[10:24:23.737]             sys.calls <- base::sys.calls
[10:24:23.737]             `[[` <- base::`[[`
[10:24:23.737]             `+` <- base::`+`
[10:24:23.737]             `<<-` <- base::`<<-`
[10:24:23.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:23.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:23.737]                   3L)]
[10:24:23.737]             }
[10:24:23.737]             function(cond) {
[10:24:23.737]                 is_error <- inherits(cond, "error")
[10:24:23.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:23.737]                   NULL)
[10:24:23.737]                 if (is_error) {
[10:24:23.737]                   sessionInformation <- function() {
[10:24:23.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:23.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:23.737]                       search = base::search(), system = base::Sys.info())
[10:24:23.737]                   }
[10:24:23.737]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:23.737]                     cond$call), session = sessionInformation(), 
[10:24:23.737]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:23.737]                   signalCondition(cond)
[10:24:23.737]                 }
[10:24:23.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:23.737]                 "immediateCondition"))) {
[10:24:23.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:23.737]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:23.737]                   if (TRUE && !signal) {
[10:24:23.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.737]                     {
[10:24:23.737]                       inherits <- base::inherits
[10:24:23.737]                       invokeRestart <- base::invokeRestart
[10:24:23.737]                       is.null <- base::is.null
[10:24:23.737]                       muffled <- FALSE
[10:24:23.737]                       if (inherits(cond, "message")) {
[10:24:23.737]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.737]                         if (muffled) 
[10:24:23.737]                           invokeRestart("muffleMessage")
[10:24:23.737]                       }
[10:24:23.737]                       else if (inherits(cond, "warning")) {
[10:24:23.737]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.737]                         if (muffled) 
[10:24:23.737]                           invokeRestart("muffleWarning")
[10:24:23.737]                       }
[10:24:23.737]                       else if (inherits(cond, "condition")) {
[10:24:23.737]                         if (!is.null(pattern)) {
[10:24:23.737]                           computeRestarts <- base::computeRestarts
[10:24:23.737]                           grepl <- base::grepl
[10:24:23.737]                           restarts <- computeRestarts(cond)
[10:24:23.737]                           for (restart in restarts) {
[10:24:23.737]                             name <- restart$name
[10:24:23.737]                             if (is.null(name)) 
[10:24:23.737]                               next
[10:24:23.737]                             if (!grepl(pattern, name)) 
[10:24:23.737]                               next
[10:24:23.737]                             invokeRestart(restart)
[10:24:23.737]                             muffled <- TRUE
[10:24:23.737]                             break
[10:24:23.737]                           }
[10:24:23.737]                         }
[10:24:23.737]                       }
[10:24:23.737]                       invisible(muffled)
[10:24:23.737]                     }
[10:24:23.737]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.737]                   }
[10:24:23.737]                 }
[10:24:23.737]                 else {
[10:24:23.737]                   if (TRUE) {
[10:24:23.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.737]                     {
[10:24:23.737]                       inherits <- base::inherits
[10:24:23.737]                       invokeRestart <- base::invokeRestart
[10:24:23.737]                       is.null <- base::is.null
[10:24:23.737]                       muffled <- FALSE
[10:24:23.737]                       if (inherits(cond, "message")) {
[10:24:23.737]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.737]                         if (muffled) 
[10:24:23.737]                           invokeRestart("muffleMessage")
[10:24:23.737]                       }
[10:24:23.737]                       else if (inherits(cond, "warning")) {
[10:24:23.737]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.737]                         if (muffled) 
[10:24:23.737]                           invokeRestart("muffleWarning")
[10:24:23.737]                       }
[10:24:23.737]                       else if (inherits(cond, "condition")) {
[10:24:23.737]                         if (!is.null(pattern)) {
[10:24:23.737]                           computeRestarts <- base::computeRestarts
[10:24:23.737]                           grepl <- base::grepl
[10:24:23.737]                           restarts <- computeRestarts(cond)
[10:24:23.737]                           for (restart in restarts) {
[10:24:23.737]                             name <- restart$name
[10:24:23.737]                             if (is.null(name)) 
[10:24:23.737]                               next
[10:24:23.737]                             if (!grepl(pattern, name)) 
[10:24:23.737]                               next
[10:24:23.737]                             invokeRestart(restart)
[10:24:23.737]                             muffled <- TRUE
[10:24:23.737]                             break
[10:24:23.737]                           }
[10:24:23.737]                         }
[10:24:23.737]                       }
[10:24:23.737]                       invisible(muffled)
[10:24:23.737]                     }
[10:24:23.737]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.737]                   }
[10:24:23.737]                 }
[10:24:23.737]             }
[10:24:23.737]         }))
[10:24:23.737]     }, error = function(ex) {
[10:24:23.737]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:23.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.737]                 ...future.rng), started = ...future.startTime, 
[10:24:23.737]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:23.737]             version = "1.8"), class = "FutureResult")
[10:24:23.737]     }, finally = {
[10:24:23.737]         if (!identical(...future.workdir, getwd())) 
[10:24:23.737]             setwd(...future.workdir)
[10:24:23.737]         {
[10:24:23.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:23.737]                 ...future.oldOptions$nwarnings <- NULL
[10:24:23.737]             }
[10:24:23.737]             base::options(...future.oldOptions)
[10:24:23.737]             if (.Platform$OS.type == "windows") {
[10:24:23.737]                 old_names <- names(...future.oldEnvVars)
[10:24:23.737]                 envs <- base::Sys.getenv()
[10:24:23.737]                 names <- names(envs)
[10:24:23.737]                 common <- intersect(names, old_names)
[10:24:23.737]                 added <- setdiff(names, old_names)
[10:24:23.737]                 removed <- setdiff(old_names, names)
[10:24:23.737]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:23.737]                   envs[common]]
[10:24:23.737]                 NAMES <- toupper(changed)
[10:24:23.737]                 args <- list()
[10:24:23.737]                 for (kk in seq_along(NAMES)) {
[10:24:23.737]                   name <- changed[[kk]]
[10:24:23.737]                   NAME <- NAMES[[kk]]
[10:24:23.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.737]                     next
[10:24:23.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.737]                 }
[10:24:23.737]                 NAMES <- toupper(added)
[10:24:23.737]                 for (kk in seq_along(NAMES)) {
[10:24:23.737]                   name <- added[[kk]]
[10:24:23.737]                   NAME <- NAMES[[kk]]
[10:24:23.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.737]                     next
[10:24:23.737]                   args[[name]] <- ""
[10:24:23.737]                 }
[10:24:23.737]                 NAMES <- toupper(removed)
[10:24:23.737]                 for (kk in seq_along(NAMES)) {
[10:24:23.737]                   name <- removed[[kk]]
[10:24:23.737]                   NAME <- NAMES[[kk]]
[10:24:23.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.737]                     next
[10:24:23.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.737]                 }
[10:24:23.737]                 if (length(args) > 0) 
[10:24:23.737]                   base::do.call(base::Sys.setenv, args = args)
[10:24:23.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:23.737]             }
[10:24:23.737]             else {
[10:24:23.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:23.737]             }
[10:24:23.737]             {
[10:24:23.737]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:23.737]                   0L) {
[10:24:23.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:23.737]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:23.737]                   base::options(opts)
[10:24:23.737]                 }
[10:24:23.737]                 {
[10:24:23.737]                   {
[10:24:23.737]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:23.737]                     NULL
[10:24:23.737]                   }
[10:24:23.737]                   options(future.plan = NULL)
[10:24:23.737]                   if (is.na(NA_character_)) 
[10:24:23.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:23.737]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:23.737]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:23.737]                     envir = parent.frame()) 
[10:24:23.737]                   {
[10:24:23.737]                     if (is.function(workers)) 
[10:24:23.737]                       workers <- workers()
[10:24:23.737]                     workers <- structure(as.integer(workers), 
[10:24:23.737]                       class = class(workers))
[10:24:23.737]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:23.737]                       workers >= 1)
[10:24:23.737]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:23.737]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:23.737]                     }
[10:24:23.737]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:23.737]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:23.737]                       envir = envir)
[10:24:23.737]                     if (!future$lazy) 
[10:24:23.737]                       future <- run(future)
[10:24:23.737]                     invisible(future)
[10:24:23.737]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:23.737]                 }
[10:24:23.737]             }
[10:24:23.737]         }
[10:24:23.737]     })
[10:24:23.737]     if (TRUE) {
[10:24:23.737]         base::sink(type = "output", split = FALSE)
[10:24:23.737]         if (TRUE) {
[10:24:23.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:23.737]         }
[10:24:23.737]         else {
[10:24:23.737]             ...future.result["stdout"] <- base::list(NULL)
[10:24:23.737]         }
[10:24:23.737]         base::close(...future.stdout)
[10:24:23.737]         ...future.stdout <- NULL
[10:24:23.737]     }
[10:24:23.737]     ...future.result$conditions <- ...future.conditions
[10:24:23.737]     ...future.result$finished <- base::Sys.time()
[10:24:23.737]     ...future.result
[10:24:23.737] }
[10:24:23.740] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[10:24:23.740] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[10:24:23.782] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[10:24:23.782] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:23.782] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:23.783] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[10:24:23.783] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[10:24:23.785] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:23.786] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:23.786] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:23.786] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:23.786] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[10:24:23.787] MultisessionFuture started
[10:24:23.787] - Launch lazy future ... done
[10:24:23.787] run() for ‘MultisessionFuture’ ... done
[10:24:23.788] Created future:
[10:24:23.788] MultisessionFuture:
[10:24:23.788] Label: ‘future_sapply-1’
[10:24:23.788] Expression:
[10:24:23.788] {
[10:24:23.788]     do.call(function(...) {
[10:24:23.788]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.788]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.788]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.788]             on.exit(options(oopts), add = TRUE)
[10:24:23.788]         }
[10:24:23.788]         {
[10:24:23.788]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.788]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.788]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.788]             })
[10:24:23.788]         }
[10:24:23.788]     }, args = future.call.arguments)
[10:24:23.788] }
[10:24:23.788] Lazy evaluation: FALSE
[10:24:23.788] Asynchronous evaluation: TRUE
[10:24:23.788] Local evaluation: TRUE
[10:24:23.788] Environment: R_GlobalEnv
[10:24:23.788] Capture standard output: TRUE
[10:24:23.788] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:23.788] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:23.788] Packages: 1 packages (‘stats’)
[10:24:23.788] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:23.788] Resolved: FALSE
[10:24:23.788] Value: <not collected>
[10:24:23.788] Conditions captured: <none>
[10:24:23.788] Early signaling: FALSE
[10:24:23.788] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:23.788] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.799] Chunk #1 of 2 ... DONE
[10:24:23.799] Chunk #2 of 2 ...
[10:24:23.799]  - Finding globals in 'X' for chunk #2 ...
[10:24:23.800] getGlobalsAndPackages() ...
[10:24:23.800] Searching for globals...
[10:24:23.800] 
[10:24:23.800] Searching for globals ... DONE
[10:24:23.800] - globals: [0] <none>
[10:24:23.800] getGlobalsAndPackages() ... DONE
[10:24:23.800]    + additional globals found: [n=0] 
[10:24:23.800]    + additional namespaces needed: [n=0] 
[10:24:23.801]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:23.801]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:23.801]  - seeds: <none>
[10:24:23.801]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.801] getGlobalsAndPackages() ...
[10:24:23.801] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.801] Resolving globals: FALSE
[10:24:23.801] Tweak future expression to call with '...' arguments ...
[10:24:23.801] {
[10:24:23.801]     do.call(function(...) {
[10:24:23.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.801]             on.exit(options(oopts), add = TRUE)
[10:24:23.801]         }
[10:24:23.801]         {
[10:24:23.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.801]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.801]             })
[10:24:23.801]         }
[10:24:23.801]     }, args = future.call.arguments)
[10:24:23.801] }
[10:24:23.802] Tweak future expression to call with '...' arguments ... DONE
[10:24:23.802] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.802] - packages: [1] ‘stats’
[10:24:23.802] getGlobalsAndPackages() ... DONE
[10:24:23.803] run() for ‘Future’ ...
[10:24:23.803] - state: ‘created’
[10:24:23.803] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:23.817] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.817] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:23.817]   - Field: ‘node’
[10:24:23.817]   - Field: ‘label’
[10:24:23.817]   - Field: ‘local’
[10:24:23.817]   - Field: ‘owner’
[10:24:23.817]   - Field: ‘envir’
[10:24:23.817]   - Field: ‘workers’
[10:24:23.818]   - Field: ‘packages’
[10:24:23.818]   - Field: ‘gc’
[10:24:23.818]   - Field: ‘conditions’
[10:24:23.818]   - Field: ‘persistent’
[10:24:23.818]   - Field: ‘expr’
[10:24:23.818]   - Field: ‘uuid’
[10:24:23.818]   - Field: ‘seed’
[10:24:23.818]   - Field: ‘version’
[10:24:23.818]   - Field: ‘result’
[10:24:23.818]   - Field: ‘asynchronous’
[10:24:23.818]   - Field: ‘calls’
[10:24:23.819]   - Field: ‘globals’
[10:24:23.819]   - Field: ‘stdout’
[10:24:23.819]   - Field: ‘earlySignal’
[10:24:23.819]   - Field: ‘lazy’
[10:24:23.819]   - Field: ‘state’
[10:24:23.819] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:23.819] - Launch lazy future ...
[10:24:23.819] Packages needed by the future expression (n = 1): ‘stats’
[10:24:23.820] Packages needed by future strategies (n = 0): <none>
[10:24:23.820] {
[10:24:23.820]     {
[10:24:23.820]         {
[10:24:23.820]             ...future.startTime <- base::Sys.time()
[10:24:23.820]             {
[10:24:23.820]                 {
[10:24:23.820]                   {
[10:24:23.820]                     {
[10:24:23.820]                       {
[10:24:23.820]                         base::local({
[10:24:23.820]                           has_future <- base::requireNamespace("future", 
[10:24:23.820]                             quietly = TRUE)
[10:24:23.820]                           if (has_future) {
[10:24:23.820]                             ns <- base::getNamespace("future")
[10:24:23.820]                             version <- ns[[".package"]][["version"]]
[10:24:23.820]                             if (is.null(version)) 
[10:24:23.820]                               version <- utils::packageVersion("future")
[10:24:23.820]                           }
[10:24:23.820]                           else {
[10:24:23.820]                             version <- NULL
[10:24:23.820]                           }
[10:24:23.820]                           if (!has_future || version < "1.8.0") {
[10:24:23.820]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:23.820]                               "", base::R.version$version.string), 
[10:24:23.820]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:23.820]                                 base::R.version$platform, 8 * 
[10:24:23.820]                                   base::.Machine$sizeof.pointer), 
[10:24:23.820]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:23.820]                                 "release", "version")], collapse = " "), 
[10:24:23.820]                               hostname = base::Sys.info()[["nodename"]])
[10:24:23.820]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:23.820]                               info)
[10:24:23.820]                             info <- base::paste(info, collapse = "; ")
[10:24:23.820]                             if (!has_future) {
[10:24:23.820]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:23.820]                                 info)
[10:24:23.820]                             }
[10:24:23.820]                             else {
[10:24:23.820]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:23.820]                                 info, version)
[10:24:23.820]                             }
[10:24:23.820]                             base::stop(msg)
[10:24:23.820]                           }
[10:24:23.820]                         })
[10:24:23.820]                       }
[10:24:23.820]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:23.820]                       base::options(mc.cores = 1L)
[10:24:23.820]                     }
[10:24:23.820]                     base::local({
[10:24:23.820]                       for (pkg in "stats") {
[10:24:23.820]                         base::loadNamespace(pkg)
[10:24:23.820]                         base::library(pkg, character.only = TRUE)
[10:24:23.820]                       }
[10:24:23.820]                     })
[10:24:23.820]                   }
[10:24:23.820]                   options(future.plan = NULL)
[10:24:23.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:23.820]                 }
[10:24:23.820]                 ...future.workdir <- getwd()
[10:24:23.820]             }
[10:24:23.820]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:23.820]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:23.820]         }
[10:24:23.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:23.820]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:23.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:23.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:23.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:23.820]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:23.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:23.820]             base::names(...future.oldOptions))
[10:24:23.820]     }
[10:24:23.820]     if (FALSE) {
[10:24:23.820]     }
[10:24:23.820]     else {
[10:24:23.820]         if (TRUE) {
[10:24:23.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:23.820]                 open = "w")
[10:24:23.820]         }
[10:24:23.820]         else {
[10:24:23.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:23.820]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:23.820]         }
[10:24:23.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:23.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:23.820]             base::sink(type = "output", split = FALSE)
[10:24:23.820]             base::close(...future.stdout)
[10:24:23.820]         }, add = TRUE)
[10:24:23.820]     }
[10:24:23.820]     ...future.frame <- base::sys.nframe()
[10:24:23.820]     ...future.conditions <- base::list()
[10:24:23.820]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:23.820]     if (FALSE) {
[10:24:23.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:23.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:23.820]     }
[10:24:23.820]     ...future.result <- base::tryCatch({
[10:24:23.820]         base::withCallingHandlers({
[10:24:23.820]             ...future.value <- base::withVisible(base::local({
[10:24:23.820]                 ...future.makeSendCondition <- base::local({
[10:24:23.820]                   sendCondition <- NULL
[10:24:23.820]                   function(frame = 1L) {
[10:24:23.820]                     if (is.function(sendCondition)) 
[10:24:23.820]                       return(sendCondition)
[10:24:23.820]                     ns <- getNamespace("parallel")
[10:24:23.820]                     if (exists("sendData", mode = "function", 
[10:24:23.820]                       envir = ns)) {
[10:24:23.820]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:23.820]                         envir = ns)
[10:24:23.820]                       envir <- sys.frame(frame)
[10:24:23.820]                       master <- NULL
[10:24:23.820]                       while (!identical(envir, .GlobalEnv) && 
[10:24:23.820]                         !identical(envir, emptyenv())) {
[10:24:23.820]                         if (exists("master", mode = "list", envir = envir, 
[10:24:23.820]                           inherits = FALSE)) {
[10:24:23.820]                           master <- get("master", mode = "list", 
[10:24:23.820]                             envir = envir, inherits = FALSE)
[10:24:23.820]                           if (inherits(master, c("SOCKnode", 
[10:24:23.820]                             "SOCK0node"))) {
[10:24:23.820]                             sendCondition <<- function(cond) {
[10:24:23.820]                               data <- list(type = "VALUE", value = cond, 
[10:24:23.820]                                 success = TRUE)
[10:24:23.820]                               parallel_sendData(master, data)
[10:24:23.820]                             }
[10:24:23.820]                             return(sendCondition)
[10:24:23.820]                           }
[10:24:23.820]                         }
[10:24:23.820]                         frame <- frame + 1L
[10:24:23.820]                         envir <- sys.frame(frame)
[10:24:23.820]                       }
[10:24:23.820]                     }
[10:24:23.820]                     sendCondition <<- function(cond) NULL
[10:24:23.820]                   }
[10:24:23.820]                 })
[10:24:23.820]                 withCallingHandlers({
[10:24:23.820]                   {
[10:24:23.820]                     do.call(function(...) {
[10:24:23.820]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.820]                       if (!identical(...future.globals.maxSize.org, 
[10:24:23.820]                         ...future.globals.maxSize)) {
[10:24:23.820]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.820]                         on.exit(options(oopts), add = TRUE)
[10:24:23.820]                       }
[10:24:23.820]                       {
[10:24:23.820]                         lapply(seq_along(...future.elements_ii), 
[10:24:23.820]                           FUN = function(jj) {
[10:24:23.820]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.820]                             ...future.FUN(...future.X_jj, ...)
[10:24:23.820]                           })
[10:24:23.820]                       }
[10:24:23.820]                     }, args = future.call.arguments)
[10:24:23.820]                   }
[10:24:23.820]                 }, immediateCondition = function(cond) {
[10:24:23.820]                   sendCondition <- ...future.makeSendCondition()
[10:24:23.820]                   sendCondition(cond)
[10:24:23.820]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.820]                   {
[10:24:23.820]                     inherits <- base::inherits
[10:24:23.820]                     invokeRestart <- base::invokeRestart
[10:24:23.820]                     is.null <- base::is.null
[10:24:23.820]                     muffled <- FALSE
[10:24:23.820]                     if (inherits(cond, "message")) {
[10:24:23.820]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:23.820]                       if (muffled) 
[10:24:23.820]                         invokeRestart("muffleMessage")
[10:24:23.820]                     }
[10:24:23.820]                     else if (inherits(cond, "warning")) {
[10:24:23.820]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:23.820]                       if (muffled) 
[10:24:23.820]                         invokeRestart("muffleWarning")
[10:24:23.820]                     }
[10:24:23.820]                     else if (inherits(cond, "condition")) {
[10:24:23.820]                       if (!is.null(pattern)) {
[10:24:23.820]                         computeRestarts <- base::computeRestarts
[10:24:23.820]                         grepl <- base::grepl
[10:24:23.820]                         restarts <- computeRestarts(cond)
[10:24:23.820]                         for (restart in restarts) {
[10:24:23.820]                           name <- restart$name
[10:24:23.820]                           if (is.null(name)) 
[10:24:23.820]                             next
[10:24:23.820]                           if (!grepl(pattern, name)) 
[10:24:23.820]                             next
[10:24:23.820]                           invokeRestart(restart)
[10:24:23.820]                           muffled <- TRUE
[10:24:23.820]                           break
[10:24:23.820]                         }
[10:24:23.820]                       }
[10:24:23.820]                     }
[10:24:23.820]                     invisible(muffled)
[10:24:23.820]                   }
[10:24:23.820]                   muffleCondition(cond)
[10:24:23.820]                 })
[10:24:23.820]             }))
[10:24:23.820]             future::FutureResult(value = ...future.value$value, 
[10:24:23.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.820]                   ...future.rng), globalenv = if (FALSE) 
[10:24:23.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:23.820]                     ...future.globalenv.names))
[10:24:23.820]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:23.820]         }, condition = base::local({
[10:24:23.820]             c <- base::c
[10:24:23.820]             inherits <- base::inherits
[10:24:23.820]             invokeRestart <- base::invokeRestart
[10:24:23.820]             length <- base::length
[10:24:23.820]             list <- base::list
[10:24:23.820]             seq.int <- base::seq.int
[10:24:23.820]             signalCondition <- base::signalCondition
[10:24:23.820]             sys.calls <- base::sys.calls
[10:24:23.820]             `[[` <- base::`[[`
[10:24:23.820]             `+` <- base::`+`
[10:24:23.820]             `<<-` <- base::`<<-`
[10:24:23.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:23.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:23.820]                   3L)]
[10:24:23.820]             }
[10:24:23.820]             function(cond) {
[10:24:23.820]                 is_error <- inherits(cond, "error")
[10:24:23.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:23.820]                   NULL)
[10:24:23.820]                 if (is_error) {
[10:24:23.820]                   sessionInformation <- function() {
[10:24:23.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:23.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:23.820]                       search = base::search(), system = base::Sys.info())
[10:24:23.820]                   }
[10:24:23.820]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:23.820]                     cond$call), session = sessionInformation(), 
[10:24:23.820]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:23.820]                   signalCondition(cond)
[10:24:23.820]                 }
[10:24:23.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:23.820]                 "immediateCondition"))) {
[10:24:23.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:23.820]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:23.820]                   if (TRUE && !signal) {
[10:24:23.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.820]                     {
[10:24:23.820]                       inherits <- base::inherits
[10:24:23.820]                       invokeRestart <- base::invokeRestart
[10:24:23.820]                       is.null <- base::is.null
[10:24:23.820]                       muffled <- FALSE
[10:24:23.820]                       if (inherits(cond, "message")) {
[10:24:23.820]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.820]                         if (muffled) 
[10:24:23.820]                           invokeRestart("muffleMessage")
[10:24:23.820]                       }
[10:24:23.820]                       else if (inherits(cond, "warning")) {
[10:24:23.820]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.820]                         if (muffled) 
[10:24:23.820]                           invokeRestart("muffleWarning")
[10:24:23.820]                       }
[10:24:23.820]                       else if (inherits(cond, "condition")) {
[10:24:23.820]                         if (!is.null(pattern)) {
[10:24:23.820]                           computeRestarts <- base::computeRestarts
[10:24:23.820]                           grepl <- base::grepl
[10:24:23.820]                           restarts <- computeRestarts(cond)
[10:24:23.820]                           for (restart in restarts) {
[10:24:23.820]                             name <- restart$name
[10:24:23.820]                             if (is.null(name)) 
[10:24:23.820]                               next
[10:24:23.820]                             if (!grepl(pattern, name)) 
[10:24:23.820]                               next
[10:24:23.820]                             invokeRestart(restart)
[10:24:23.820]                             muffled <- TRUE
[10:24:23.820]                             break
[10:24:23.820]                           }
[10:24:23.820]                         }
[10:24:23.820]                       }
[10:24:23.820]                       invisible(muffled)
[10:24:23.820]                     }
[10:24:23.820]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.820]                   }
[10:24:23.820]                 }
[10:24:23.820]                 else {
[10:24:23.820]                   if (TRUE) {
[10:24:23.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.820]                     {
[10:24:23.820]                       inherits <- base::inherits
[10:24:23.820]                       invokeRestart <- base::invokeRestart
[10:24:23.820]                       is.null <- base::is.null
[10:24:23.820]                       muffled <- FALSE
[10:24:23.820]                       if (inherits(cond, "message")) {
[10:24:23.820]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.820]                         if (muffled) 
[10:24:23.820]                           invokeRestart("muffleMessage")
[10:24:23.820]                       }
[10:24:23.820]                       else if (inherits(cond, "warning")) {
[10:24:23.820]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.820]                         if (muffled) 
[10:24:23.820]                           invokeRestart("muffleWarning")
[10:24:23.820]                       }
[10:24:23.820]                       else if (inherits(cond, "condition")) {
[10:24:23.820]                         if (!is.null(pattern)) {
[10:24:23.820]                           computeRestarts <- base::computeRestarts
[10:24:23.820]                           grepl <- base::grepl
[10:24:23.820]                           restarts <- computeRestarts(cond)
[10:24:23.820]                           for (restart in restarts) {
[10:24:23.820]                             name <- restart$name
[10:24:23.820]                             if (is.null(name)) 
[10:24:23.820]                               next
[10:24:23.820]                             if (!grepl(pattern, name)) 
[10:24:23.820]                               next
[10:24:23.820]                             invokeRestart(restart)
[10:24:23.820]                             muffled <- TRUE
[10:24:23.820]                             break
[10:24:23.820]                           }
[10:24:23.820]                         }
[10:24:23.820]                       }
[10:24:23.820]                       invisible(muffled)
[10:24:23.820]                     }
[10:24:23.820]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.820]                   }
[10:24:23.820]                 }
[10:24:23.820]             }
[10:24:23.820]         }))
[10:24:23.820]     }, error = function(ex) {
[10:24:23.820]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:23.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.820]                 ...future.rng), started = ...future.startTime, 
[10:24:23.820]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:23.820]             version = "1.8"), class = "FutureResult")
[10:24:23.820]     }, finally = {
[10:24:23.820]         if (!identical(...future.workdir, getwd())) 
[10:24:23.820]             setwd(...future.workdir)
[10:24:23.820]         {
[10:24:23.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:23.820]                 ...future.oldOptions$nwarnings <- NULL
[10:24:23.820]             }
[10:24:23.820]             base::options(...future.oldOptions)
[10:24:23.820]             if (.Platform$OS.type == "windows") {
[10:24:23.820]                 old_names <- names(...future.oldEnvVars)
[10:24:23.820]                 envs <- base::Sys.getenv()
[10:24:23.820]                 names <- names(envs)
[10:24:23.820]                 common <- intersect(names, old_names)
[10:24:23.820]                 added <- setdiff(names, old_names)
[10:24:23.820]                 removed <- setdiff(old_names, names)
[10:24:23.820]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:23.820]                   envs[common]]
[10:24:23.820]                 NAMES <- toupper(changed)
[10:24:23.820]                 args <- list()
[10:24:23.820]                 for (kk in seq_along(NAMES)) {
[10:24:23.820]                   name <- changed[[kk]]
[10:24:23.820]                   NAME <- NAMES[[kk]]
[10:24:23.820]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.820]                     next
[10:24:23.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.820]                 }
[10:24:23.820]                 NAMES <- toupper(added)
[10:24:23.820]                 for (kk in seq_along(NAMES)) {
[10:24:23.820]                   name <- added[[kk]]
[10:24:23.820]                   NAME <- NAMES[[kk]]
[10:24:23.820]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.820]                     next
[10:24:23.820]                   args[[name]] <- ""
[10:24:23.820]                 }
[10:24:23.820]                 NAMES <- toupper(removed)
[10:24:23.820]                 for (kk in seq_along(NAMES)) {
[10:24:23.820]                   name <- removed[[kk]]
[10:24:23.820]                   NAME <- NAMES[[kk]]
[10:24:23.820]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.820]                     next
[10:24:23.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.820]                 }
[10:24:23.820]                 if (length(args) > 0) 
[10:24:23.820]                   base::do.call(base::Sys.setenv, args = args)
[10:24:23.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:23.820]             }
[10:24:23.820]             else {
[10:24:23.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:23.820]             }
[10:24:23.820]             {
[10:24:23.820]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:23.820]                   0L) {
[10:24:23.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:23.820]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:23.820]                   base::options(opts)
[10:24:23.820]                 }
[10:24:23.820]                 {
[10:24:23.820]                   {
[10:24:23.820]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:23.820]                     NULL
[10:24:23.820]                   }
[10:24:23.820]                   options(future.plan = NULL)
[10:24:23.820]                   if (is.na(NA_character_)) 
[10:24:23.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:23.820]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:23.820]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:23.820]                     envir = parent.frame()) 
[10:24:23.820]                   {
[10:24:23.820]                     if (is.function(workers)) 
[10:24:23.820]                       workers <- workers()
[10:24:23.820]                     workers <- structure(as.integer(workers), 
[10:24:23.820]                       class = class(workers))
[10:24:23.820]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:23.820]                       workers >= 1)
[10:24:23.820]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:23.820]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:23.820]                     }
[10:24:23.820]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:23.820]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:23.820]                       envir = envir)
[10:24:23.820]                     if (!future$lazy) 
[10:24:23.820]                       future <- run(future)
[10:24:23.820]                     invisible(future)
[10:24:23.820]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:23.820]                 }
[10:24:23.820]             }
[10:24:23.820]         }
[10:24:23.820]     })
[10:24:23.820]     if (TRUE) {
[10:24:23.820]         base::sink(type = "output", split = FALSE)
[10:24:23.820]         if (TRUE) {
[10:24:23.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:23.820]         }
[10:24:23.820]         else {
[10:24:23.820]             ...future.result["stdout"] <- base::list(NULL)
[10:24:23.820]         }
[10:24:23.820]         base::close(...future.stdout)
[10:24:23.820]         ...future.stdout <- NULL
[10:24:23.820]     }
[10:24:23.820]     ...future.result$conditions <- ...future.conditions
[10:24:23.820]     ...future.result$finished <- base::Sys.time()
[10:24:23.820]     ...future.result
[10:24:23.820] }
[10:24:23.823] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[10:24:23.823] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[10:24:23.866] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[10:24:23.866] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:23.866] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:23.867] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[10:24:23.867] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[10:24:23.867] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:23.868] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:23.868] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:23.868] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:23.868] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[10:24:23.869] MultisessionFuture started
[10:24:23.869] - Launch lazy future ... done
[10:24:23.869] run() for ‘MultisessionFuture’ ... done
[10:24:23.869] Created future:
[10:24:23.869] MultisessionFuture:
[10:24:23.869] Label: ‘future_sapply-2’
[10:24:23.869] Expression:
[10:24:23.869] {
[10:24:23.869]     do.call(function(...) {
[10:24:23.869]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.869]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.869]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.869]             on.exit(options(oopts), add = TRUE)
[10:24:23.869]         }
[10:24:23.869]         {
[10:24:23.869]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.869]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.869]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.869]             })
[10:24:23.869]         }
[10:24:23.869]     }, args = future.call.arguments)
[10:24:23.869] }
[10:24:23.869] Lazy evaluation: FALSE
[10:24:23.869] Asynchronous evaluation: TRUE
[10:24:23.869] Local evaluation: TRUE
[10:24:23.869] Environment: R_GlobalEnv
[10:24:23.869] Capture standard output: TRUE
[10:24:23.869] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:23.869] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:23.869] Packages: 1 packages (‘stats’)
[10:24:23.869] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:23.869] Resolved: FALSE
[10:24:23.869] Value: <not collected>
[10:24:23.869] Conditions captured: <none>
[10:24:23.869] Early signaling: FALSE
[10:24:23.869] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:23.869] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.881] Chunk #2 of 2 ... DONE
[10:24:23.881] Launching 2 futures (chunks) ... DONE
[10:24:23.881] Resolving 2 futures (chunks) ...
[10:24:23.881] resolve() on list ...
[10:24:23.881]  recursive: 0
[10:24:23.882]  length: 2
[10:24:23.882] 
[10:24:23.882] receiveMessageFromWorker() for ClusterFuture ...
[10:24:23.882] - Validating connection of MultisessionFuture
[10:24:23.882] - received message: FutureResult
[10:24:23.883] - Received FutureResult
[10:24:23.883] - Erased future from FutureRegistry
[10:24:23.883] result() for ClusterFuture ...
[10:24:23.883] - result already collected: FutureResult
[10:24:23.883] result() for ClusterFuture ... done
[10:24:23.883] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:23.883] Future #1
[10:24:23.883] result() for ClusterFuture ...
[10:24:23.883] - result already collected: FutureResult
[10:24:23.883] result() for ClusterFuture ... done
[10:24:23.884] result() for ClusterFuture ...
[10:24:23.884] - result already collected: FutureResult
[10:24:23.884] result() for ClusterFuture ... done
[10:24:23.884] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:23.884] - nx: 2
[10:24:23.884] - relay: TRUE
[10:24:23.884] - stdout: TRUE
[10:24:23.884] - signal: TRUE
[10:24:23.884] - resignal: FALSE
[10:24:23.884] - force: TRUE
[10:24:23.884] - relayed: [n=2] FALSE, FALSE
[10:24:23.885] - queued futures: [n=2] FALSE, FALSE
[10:24:23.885]  - until=1
[10:24:23.885]  - relaying element #1
[10:24:23.885] result() for ClusterFuture ...
[10:24:23.885] - result already collected: FutureResult
[10:24:23.885] result() for ClusterFuture ... done
[10:24:23.885] result() for ClusterFuture ...
[10:24:23.885] - result already collected: FutureResult
[10:24:23.885] result() for ClusterFuture ... done
[10:24:23.885] result() for ClusterFuture ...
[10:24:23.886] - result already collected: FutureResult
[10:24:23.886] result() for ClusterFuture ... done
[10:24:23.886] result() for ClusterFuture ...
[10:24:23.886] - result already collected: FutureResult
[10:24:23.886] result() for ClusterFuture ... done
[10:24:23.886] - relayed: [n=2] TRUE, FALSE
[10:24:23.886] - queued futures: [n=2] TRUE, FALSE
[10:24:23.886] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:23.886]  length: 1 (resolved future 1)
[10:24:23.914] receiveMessageFromWorker() for ClusterFuture ...
[10:24:23.915] - Validating connection of MultisessionFuture
[10:24:23.915] - received message: FutureResult
[10:24:23.915] - Received FutureResult
[10:24:23.915] - Erased future from FutureRegistry
[10:24:23.915] result() for ClusterFuture ...
[10:24:23.915] - result already collected: FutureResult
[10:24:23.915] result() for ClusterFuture ... done
[10:24:23.915] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:23.916] Future #2
[10:24:23.916] result() for ClusterFuture ...
[10:24:23.916] - result already collected: FutureResult
[10:24:23.916] result() for ClusterFuture ... done
[10:24:23.916] result() for ClusterFuture ...
[10:24:23.916] - result already collected: FutureResult
[10:24:23.916] result() for ClusterFuture ... done
[10:24:23.916] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:23.916] - nx: 2
[10:24:23.916] - relay: TRUE
[10:24:23.916] - stdout: TRUE
[10:24:23.917] - signal: TRUE
[10:24:23.917] - resignal: FALSE
[10:24:23.917] - force: TRUE
[10:24:23.917] - relayed: [n=2] TRUE, FALSE
[10:24:23.917] - queued futures: [n=2] TRUE, FALSE
[10:24:23.917]  - until=2
[10:24:23.917]  - relaying element #2
[10:24:23.917] result() for ClusterFuture ...
[10:24:23.917] - result already collected: FutureResult
[10:24:23.917] result() for ClusterFuture ... done
[10:24:23.917] result() for ClusterFuture ...
[10:24:23.918] - result already collected: FutureResult
[10:24:23.918] result() for ClusterFuture ... done
[10:24:23.918] result() for ClusterFuture ...
[10:24:23.918] - result already collected: FutureResult
[10:24:23.918] result() for ClusterFuture ... done
[10:24:23.918] result() for ClusterFuture ...
[10:24:23.918] - result already collected: FutureResult
[10:24:23.918] result() for ClusterFuture ... done
[10:24:23.918] - relayed: [n=2] TRUE, TRUE
[10:24:23.918] - queued futures: [n=2] TRUE, TRUE
[10:24:23.918] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:23.919]  length: 0 (resolved future 2)
[10:24:23.919] Relaying remaining futures
[10:24:23.919] signalConditionsASAP(NULL, pos=0) ...
[10:24:23.919] - nx: 2
[10:24:23.919] - relay: TRUE
[10:24:23.919] - stdout: TRUE
[10:24:23.919] - signal: TRUE
[10:24:23.919] - resignal: FALSE
[10:24:23.919] - force: TRUE
[10:24:23.919] - relayed: [n=2] TRUE, TRUE
[10:24:23.919] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:23.920] - relayed: [n=2] TRUE, TRUE
[10:24:23.920] - queued futures: [n=2] TRUE, TRUE
[10:24:23.920] signalConditionsASAP(NULL, pos=0) ... done
[10:24:23.920] resolve() on list ... DONE
[10:24:23.920] result() for ClusterFuture ...
[10:24:23.920] - result already collected: FutureResult
[10:24:23.920] result() for ClusterFuture ... done
[10:24:23.920] result() for ClusterFuture ...
[10:24:23.920] - result already collected: FutureResult
[10:24:23.920] result() for ClusterFuture ... done
[10:24:23.921] result() for ClusterFuture ...
[10:24:23.921] - result already collected: FutureResult
[10:24:23.921] result() for ClusterFuture ... done
[10:24:23.921] result() for ClusterFuture ...
[10:24:23.921] - result already collected: FutureResult
[10:24:23.921] result() for ClusterFuture ... done
[10:24:23.921]  - Number of value chunks collected: 2
[10:24:23.921] Resolving 2 futures (chunks) ... DONE
[10:24:23.921] Reducing values from 2 chunks ...
[10:24:23.921]  - Number of values collected after concatenation: 7
[10:24:23.921]  - Number of values expected: 7
[10:24:23.922] Reducing values from 2 chunks ... DONE
[10:24:23.922] future_lapply() ... DONE
[10:24:23.922] future_lapply() ...
[10:24:23.927] Number of chunks: 2
[10:24:23.927] getGlobalsAndPackagesXApply() ...
[10:24:23.928]  - future.globals: TRUE
[10:24:23.928] getGlobalsAndPackages() ...
[10:24:23.928] Searching for globals...
[10:24:23.935] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:24:23.935] Searching for globals ... DONE
[10:24:23.935] Resolving globals: FALSE
[10:24:23.936] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[10:24:23.937] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[10:24:23.937] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:23.937] - packages: [2] ‘stats’, ‘future.apply’
[10:24:23.937] getGlobalsAndPackages() ... DONE
[10:24:23.937]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:23.937]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:24:23.938] Finding globals ... DONE
[10:24:23.938]  - use_args: TRUE
[10:24:23.938]  - Getting '...' globals ...
[10:24:23.938] resolve() on list ...
[10:24:23.938]  recursive: 0
[10:24:23.938]  length: 1
[10:24:23.938]  elements: ‘...’
[10:24:23.938]  length: 0 (resolved future 1)
[10:24:23.939] resolve() on list ... DONE
[10:24:23.939]    - '...' content: [n=0] 
[10:24:23.939] List of 1
[10:24:23.939]  $ ...: list()
[10:24:23.939]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:23.939]  - attr(*, "where")=List of 1
[10:24:23.939]   ..$ ...:<environment: 0x55b93e73d048> 
[10:24:23.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:23.939]  - attr(*, "resolved")= logi TRUE
[10:24:23.939]  - attr(*, "total_size")= num NA
[10:24:23.941]  - Getting '...' globals ... DONE
[10:24:23.942] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:23.942] List of 8
[10:24:23.942]  $ ...future.FUN:function (x, ...)  
[10:24:23.942]  $ x_FUN        :function (x, na.rm = TRUE)  
[10:24:23.942]  $ times        : int 5
[10:24:23.942]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:23.942]  $ stop_if_not  :function (...)  
[10:24:23.942]  $ dim          : NULL
[10:24:23.942]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:23.942]  $ ...          : list()
[10:24:23.942]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:23.942]  - attr(*, "where")=List of 8
[10:24:23.942]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:23.942]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:23.942]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:23.942]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:23.942]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:23.942]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:23.942]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:23.942]   ..$ ...          :<environment: 0x55b93e73d048> 
[10:24:23.942]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:23.942]  - attr(*, "resolved")= logi FALSE
[10:24:23.942]  - attr(*, "total_size")= num 141240
[10:24:23.947] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:24:23.947] getGlobalsAndPackagesXApply() ... DONE
[10:24:23.947] Number of futures (= number of chunks): 2
[10:24:23.947] Launching 2 futures (chunks) ...
[10:24:23.948] Chunk #1 of 2 ...
[10:24:23.948]  - Finding globals in 'X' for chunk #1 ...
[10:24:23.948] getGlobalsAndPackages() ...
[10:24:23.948] Searching for globals...
[10:24:23.948] 
[10:24:23.948] Searching for globals ... DONE
[10:24:23.948] - globals: [0] <none>
[10:24:23.948] getGlobalsAndPackages() ... DONE
[10:24:23.948]    + additional globals found: [n=0] 
[10:24:23.949]    + additional namespaces needed: [n=0] 
[10:24:23.949]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:23.949]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:23.949]  - seeds: <none>
[10:24:23.949]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.949] getGlobalsAndPackages() ...
[10:24:23.949] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.949] Resolving globals: FALSE
[10:24:23.949] Tweak future expression to call with '...' arguments ...
[10:24:23.950] {
[10:24:23.950]     do.call(function(...) {
[10:24:23.950]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.950]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:23.950]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.950]             on.exit(options(oopts), add = TRUE)
[10:24:23.950]         }
[10:24:23.950]         {
[10:24:23.950]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:23.950]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.950]                 ...future.FUN(...future.X_jj, ...)
[10:24:23.950]             })
[10:24:23.950]         }
[10:24:23.950]     }, args = future.call.arguments)
[10:24:23.950] }
[10:24:23.950] Tweak future expression to call with '...' arguments ... DONE
[10:24:23.950] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:23.950] - packages: [2] ‘stats’, ‘future.apply’
[10:24:23.951] getGlobalsAndPackages() ... DONE
[10:24:23.951] run() for ‘Future’ ...
[10:24:23.951] - state: ‘created’
[10:24:23.951] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:23.965] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:23.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:23.966]   - Field: ‘node’
[10:24:23.966]   - Field: ‘label’
[10:24:23.966]   - Field: ‘local’
[10:24:23.966]   - Field: ‘owner’
[10:24:23.966]   - Field: ‘envir’
[10:24:23.966]   - Field: ‘workers’
[10:24:23.966]   - Field: ‘packages’
[10:24:23.966]   - Field: ‘gc’
[10:24:23.966]   - Field: ‘conditions’
[10:24:23.966]   - Field: ‘persistent’
[10:24:23.966]   - Field: ‘expr’
[10:24:23.967]   - Field: ‘uuid’
[10:24:23.967]   - Field: ‘seed’
[10:24:23.967]   - Field: ‘version’
[10:24:23.967]   - Field: ‘result’
[10:24:23.967]   - Field: ‘asynchronous’
[10:24:23.967]   - Field: ‘calls’
[10:24:23.967]   - Field: ‘globals’
[10:24:23.967]   - Field: ‘stdout’
[10:24:23.967]   - Field: ‘earlySignal’
[10:24:23.967]   - Field: ‘lazy’
[10:24:23.967]   - Field: ‘state’
[10:24:23.968] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:23.968] - Launch lazy future ...
[10:24:23.968] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:24:23.968] Packages needed by future strategies (n = 0): <none>
[10:24:23.969] {
[10:24:23.969]     {
[10:24:23.969]         {
[10:24:23.969]             ...future.startTime <- base::Sys.time()
[10:24:23.969]             {
[10:24:23.969]                 {
[10:24:23.969]                   {
[10:24:23.969]                     {
[10:24:23.969]                       {
[10:24:23.969]                         base::local({
[10:24:23.969]                           has_future <- base::requireNamespace("future", 
[10:24:23.969]                             quietly = TRUE)
[10:24:23.969]                           if (has_future) {
[10:24:23.969]                             ns <- base::getNamespace("future")
[10:24:23.969]                             version <- ns[[".package"]][["version"]]
[10:24:23.969]                             if (is.null(version)) 
[10:24:23.969]                               version <- utils::packageVersion("future")
[10:24:23.969]                           }
[10:24:23.969]                           else {
[10:24:23.969]                             version <- NULL
[10:24:23.969]                           }
[10:24:23.969]                           if (!has_future || version < "1.8.0") {
[10:24:23.969]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:23.969]                               "", base::R.version$version.string), 
[10:24:23.969]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:23.969]                                 base::R.version$platform, 8 * 
[10:24:23.969]                                   base::.Machine$sizeof.pointer), 
[10:24:23.969]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:23.969]                                 "release", "version")], collapse = " "), 
[10:24:23.969]                               hostname = base::Sys.info()[["nodename"]])
[10:24:23.969]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:23.969]                               info)
[10:24:23.969]                             info <- base::paste(info, collapse = "; ")
[10:24:23.969]                             if (!has_future) {
[10:24:23.969]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:23.969]                                 info)
[10:24:23.969]                             }
[10:24:23.969]                             else {
[10:24:23.969]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:23.969]                                 info, version)
[10:24:23.969]                             }
[10:24:23.969]                             base::stop(msg)
[10:24:23.969]                           }
[10:24:23.969]                         })
[10:24:23.969]                       }
[10:24:23.969]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:23.969]                       base::options(mc.cores = 1L)
[10:24:23.969]                     }
[10:24:23.969]                     base::local({
[10:24:23.969]                       for (pkg in c("stats", "future.apply")) {
[10:24:23.969]                         base::loadNamespace(pkg)
[10:24:23.969]                         base::library(pkg, character.only = TRUE)
[10:24:23.969]                       }
[10:24:23.969]                     })
[10:24:23.969]                   }
[10:24:23.969]                   options(future.plan = NULL)
[10:24:23.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:23.969]                 }
[10:24:23.969]                 ...future.workdir <- getwd()
[10:24:23.969]             }
[10:24:23.969]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:23.969]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:23.969]         }
[10:24:23.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:23.969]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:23.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:23.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:23.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:23.969]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:23.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:23.969]             base::names(...future.oldOptions))
[10:24:23.969]     }
[10:24:23.969]     if (FALSE) {
[10:24:23.969]     }
[10:24:23.969]     else {
[10:24:23.969]         if (TRUE) {
[10:24:23.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:23.969]                 open = "w")
[10:24:23.969]         }
[10:24:23.969]         else {
[10:24:23.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:23.969]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:23.969]         }
[10:24:23.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:23.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:23.969]             base::sink(type = "output", split = FALSE)
[10:24:23.969]             base::close(...future.stdout)
[10:24:23.969]         }, add = TRUE)
[10:24:23.969]     }
[10:24:23.969]     ...future.frame <- base::sys.nframe()
[10:24:23.969]     ...future.conditions <- base::list()
[10:24:23.969]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:23.969]     if (FALSE) {
[10:24:23.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:23.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:23.969]     }
[10:24:23.969]     ...future.result <- base::tryCatch({
[10:24:23.969]         base::withCallingHandlers({
[10:24:23.969]             ...future.value <- base::withVisible(base::local({
[10:24:23.969]                 ...future.makeSendCondition <- base::local({
[10:24:23.969]                   sendCondition <- NULL
[10:24:23.969]                   function(frame = 1L) {
[10:24:23.969]                     if (is.function(sendCondition)) 
[10:24:23.969]                       return(sendCondition)
[10:24:23.969]                     ns <- getNamespace("parallel")
[10:24:23.969]                     if (exists("sendData", mode = "function", 
[10:24:23.969]                       envir = ns)) {
[10:24:23.969]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:23.969]                         envir = ns)
[10:24:23.969]                       envir <- sys.frame(frame)
[10:24:23.969]                       master <- NULL
[10:24:23.969]                       while (!identical(envir, .GlobalEnv) && 
[10:24:23.969]                         !identical(envir, emptyenv())) {
[10:24:23.969]                         if (exists("master", mode = "list", envir = envir, 
[10:24:23.969]                           inherits = FALSE)) {
[10:24:23.969]                           master <- get("master", mode = "list", 
[10:24:23.969]                             envir = envir, inherits = FALSE)
[10:24:23.969]                           if (inherits(master, c("SOCKnode", 
[10:24:23.969]                             "SOCK0node"))) {
[10:24:23.969]                             sendCondition <<- function(cond) {
[10:24:23.969]                               data <- list(type = "VALUE", value = cond, 
[10:24:23.969]                                 success = TRUE)
[10:24:23.969]                               parallel_sendData(master, data)
[10:24:23.969]                             }
[10:24:23.969]                             return(sendCondition)
[10:24:23.969]                           }
[10:24:23.969]                         }
[10:24:23.969]                         frame <- frame + 1L
[10:24:23.969]                         envir <- sys.frame(frame)
[10:24:23.969]                       }
[10:24:23.969]                     }
[10:24:23.969]                     sendCondition <<- function(cond) NULL
[10:24:23.969]                   }
[10:24:23.969]                 })
[10:24:23.969]                 withCallingHandlers({
[10:24:23.969]                   {
[10:24:23.969]                     do.call(function(...) {
[10:24:23.969]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:23.969]                       if (!identical(...future.globals.maxSize.org, 
[10:24:23.969]                         ...future.globals.maxSize)) {
[10:24:23.969]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:23.969]                         on.exit(options(oopts), add = TRUE)
[10:24:23.969]                       }
[10:24:23.969]                       {
[10:24:23.969]                         lapply(seq_along(...future.elements_ii), 
[10:24:23.969]                           FUN = function(jj) {
[10:24:23.969]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:23.969]                             ...future.FUN(...future.X_jj, ...)
[10:24:23.969]                           })
[10:24:23.969]                       }
[10:24:23.969]                     }, args = future.call.arguments)
[10:24:23.969]                   }
[10:24:23.969]                 }, immediateCondition = function(cond) {
[10:24:23.969]                   sendCondition <- ...future.makeSendCondition()
[10:24:23.969]                   sendCondition(cond)
[10:24:23.969]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.969]                   {
[10:24:23.969]                     inherits <- base::inherits
[10:24:23.969]                     invokeRestart <- base::invokeRestart
[10:24:23.969]                     is.null <- base::is.null
[10:24:23.969]                     muffled <- FALSE
[10:24:23.969]                     if (inherits(cond, "message")) {
[10:24:23.969]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:23.969]                       if (muffled) 
[10:24:23.969]                         invokeRestart("muffleMessage")
[10:24:23.969]                     }
[10:24:23.969]                     else if (inherits(cond, "warning")) {
[10:24:23.969]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:23.969]                       if (muffled) 
[10:24:23.969]                         invokeRestart("muffleWarning")
[10:24:23.969]                     }
[10:24:23.969]                     else if (inherits(cond, "condition")) {
[10:24:23.969]                       if (!is.null(pattern)) {
[10:24:23.969]                         computeRestarts <- base::computeRestarts
[10:24:23.969]                         grepl <- base::grepl
[10:24:23.969]                         restarts <- computeRestarts(cond)
[10:24:23.969]                         for (restart in restarts) {
[10:24:23.969]                           name <- restart$name
[10:24:23.969]                           if (is.null(name)) 
[10:24:23.969]                             next
[10:24:23.969]                           if (!grepl(pattern, name)) 
[10:24:23.969]                             next
[10:24:23.969]                           invokeRestart(restart)
[10:24:23.969]                           muffled <- TRUE
[10:24:23.969]                           break
[10:24:23.969]                         }
[10:24:23.969]                       }
[10:24:23.969]                     }
[10:24:23.969]                     invisible(muffled)
[10:24:23.969]                   }
[10:24:23.969]                   muffleCondition(cond)
[10:24:23.969]                 })
[10:24:23.969]             }))
[10:24:23.969]             future::FutureResult(value = ...future.value$value, 
[10:24:23.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.969]                   ...future.rng), globalenv = if (FALSE) 
[10:24:23.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:23.969]                     ...future.globalenv.names))
[10:24:23.969]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:23.969]         }, condition = base::local({
[10:24:23.969]             c <- base::c
[10:24:23.969]             inherits <- base::inherits
[10:24:23.969]             invokeRestart <- base::invokeRestart
[10:24:23.969]             length <- base::length
[10:24:23.969]             list <- base::list
[10:24:23.969]             seq.int <- base::seq.int
[10:24:23.969]             signalCondition <- base::signalCondition
[10:24:23.969]             sys.calls <- base::sys.calls
[10:24:23.969]             `[[` <- base::`[[`
[10:24:23.969]             `+` <- base::`+`
[10:24:23.969]             `<<-` <- base::`<<-`
[10:24:23.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:23.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:23.969]                   3L)]
[10:24:23.969]             }
[10:24:23.969]             function(cond) {
[10:24:23.969]                 is_error <- inherits(cond, "error")
[10:24:23.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:23.969]                   NULL)
[10:24:23.969]                 if (is_error) {
[10:24:23.969]                   sessionInformation <- function() {
[10:24:23.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:23.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:23.969]                       search = base::search(), system = base::Sys.info())
[10:24:23.969]                   }
[10:24:23.969]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:23.969]                     cond$call), session = sessionInformation(), 
[10:24:23.969]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:23.969]                   signalCondition(cond)
[10:24:23.969]                 }
[10:24:23.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:23.969]                 "immediateCondition"))) {
[10:24:23.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:23.969]                   ...future.conditions[[length(...future.conditions) + 
[10:24:23.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:23.969]                   if (TRUE && !signal) {
[10:24:23.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.969]                     {
[10:24:23.969]                       inherits <- base::inherits
[10:24:23.969]                       invokeRestart <- base::invokeRestart
[10:24:23.969]                       is.null <- base::is.null
[10:24:23.969]                       muffled <- FALSE
[10:24:23.969]                       if (inherits(cond, "message")) {
[10:24:23.969]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.969]                         if (muffled) 
[10:24:23.969]                           invokeRestart("muffleMessage")
[10:24:23.969]                       }
[10:24:23.969]                       else if (inherits(cond, "warning")) {
[10:24:23.969]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.969]                         if (muffled) 
[10:24:23.969]                           invokeRestart("muffleWarning")
[10:24:23.969]                       }
[10:24:23.969]                       else if (inherits(cond, "condition")) {
[10:24:23.969]                         if (!is.null(pattern)) {
[10:24:23.969]                           computeRestarts <- base::computeRestarts
[10:24:23.969]                           grepl <- base::grepl
[10:24:23.969]                           restarts <- computeRestarts(cond)
[10:24:23.969]                           for (restart in restarts) {
[10:24:23.969]                             name <- restart$name
[10:24:23.969]                             if (is.null(name)) 
[10:24:23.969]                               next
[10:24:23.969]                             if (!grepl(pattern, name)) 
[10:24:23.969]                               next
[10:24:23.969]                             invokeRestart(restart)
[10:24:23.969]                             muffled <- TRUE
[10:24:23.969]                             break
[10:24:23.969]                           }
[10:24:23.969]                         }
[10:24:23.969]                       }
[10:24:23.969]                       invisible(muffled)
[10:24:23.969]                     }
[10:24:23.969]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.969]                   }
[10:24:23.969]                 }
[10:24:23.969]                 else {
[10:24:23.969]                   if (TRUE) {
[10:24:23.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:23.969]                     {
[10:24:23.969]                       inherits <- base::inherits
[10:24:23.969]                       invokeRestart <- base::invokeRestart
[10:24:23.969]                       is.null <- base::is.null
[10:24:23.969]                       muffled <- FALSE
[10:24:23.969]                       if (inherits(cond, "message")) {
[10:24:23.969]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:23.969]                         if (muffled) 
[10:24:23.969]                           invokeRestart("muffleMessage")
[10:24:23.969]                       }
[10:24:23.969]                       else if (inherits(cond, "warning")) {
[10:24:23.969]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:23.969]                         if (muffled) 
[10:24:23.969]                           invokeRestart("muffleWarning")
[10:24:23.969]                       }
[10:24:23.969]                       else if (inherits(cond, "condition")) {
[10:24:23.969]                         if (!is.null(pattern)) {
[10:24:23.969]                           computeRestarts <- base::computeRestarts
[10:24:23.969]                           grepl <- base::grepl
[10:24:23.969]                           restarts <- computeRestarts(cond)
[10:24:23.969]                           for (restart in restarts) {
[10:24:23.969]                             name <- restart$name
[10:24:23.969]                             if (is.null(name)) 
[10:24:23.969]                               next
[10:24:23.969]                             if (!grepl(pattern, name)) 
[10:24:23.969]                               next
[10:24:23.969]                             invokeRestart(restart)
[10:24:23.969]                             muffled <- TRUE
[10:24:23.969]                             break
[10:24:23.969]                           }
[10:24:23.969]                         }
[10:24:23.969]                       }
[10:24:23.969]                       invisible(muffled)
[10:24:23.969]                     }
[10:24:23.969]                     muffleCondition(cond, pattern = "^muffle")
[10:24:23.969]                   }
[10:24:23.969]                 }
[10:24:23.969]             }
[10:24:23.969]         }))
[10:24:23.969]     }, error = function(ex) {
[10:24:23.969]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:23.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:23.969]                 ...future.rng), started = ...future.startTime, 
[10:24:23.969]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:23.969]             version = "1.8"), class = "FutureResult")
[10:24:23.969]     }, finally = {
[10:24:23.969]         if (!identical(...future.workdir, getwd())) 
[10:24:23.969]             setwd(...future.workdir)
[10:24:23.969]         {
[10:24:23.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:23.969]                 ...future.oldOptions$nwarnings <- NULL
[10:24:23.969]             }
[10:24:23.969]             base::options(...future.oldOptions)
[10:24:23.969]             if (.Platform$OS.type == "windows") {
[10:24:23.969]                 old_names <- names(...future.oldEnvVars)
[10:24:23.969]                 envs <- base::Sys.getenv()
[10:24:23.969]                 names <- names(envs)
[10:24:23.969]                 common <- intersect(names, old_names)
[10:24:23.969]                 added <- setdiff(names, old_names)
[10:24:23.969]                 removed <- setdiff(old_names, names)
[10:24:23.969]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:23.969]                   envs[common]]
[10:24:23.969]                 NAMES <- toupper(changed)
[10:24:23.969]                 args <- list()
[10:24:23.969]                 for (kk in seq_along(NAMES)) {
[10:24:23.969]                   name <- changed[[kk]]
[10:24:23.969]                   NAME <- NAMES[[kk]]
[10:24:23.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.969]                     next
[10:24:23.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.969]                 }
[10:24:23.969]                 NAMES <- toupper(added)
[10:24:23.969]                 for (kk in seq_along(NAMES)) {
[10:24:23.969]                   name <- added[[kk]]
[10:24:23.969]                   NAME <- NAMES[[kk]]
[10:24:23.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.969]                     next
[10:24:23.969]                   args[[name]] <- ""
[10:24:23.969]                 }
[10:24:23.969]                 NAMES <- toupper(removed)
[10:24:23.969]                 for (kk in seq_along(NAMES)) {
[10:24:23.969]                   name <- removed[[kk]]
[10:24:23.969]                   NAME <- NAMES[[kk]]
[10:24:23.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:23.969]                     next
[10:24:23.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:23.969]                 }
[10:24:23.969]                 if (length(args) > 0) 
[10:24:23.969]                   base::do.call(base::Sys.setenv, args = args)
[10:24:23.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:23.969]             }
[10:24:23.969]             else {
[10:24:23.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:23.969]             }
[10:24:23.969]             {
[10:24:23.969]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:23.969]                   0L) {
[10:24:23.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:23.969]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:23.969]                   base::options(opts)
[10:24:23.969]                 }
[10:24:23.969]                 {
[10:24:23.969]                   {
[10:24:23.969]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:23.969]                     NULL
[10:24:23.969]                   }
[10:24:23.969]                   options(future.plan = NULL)
[10:24:23.969]                   if (is.na(NA_character_)) 
[10:24:23.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:23.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:23.969]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:23.969]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:23.969]                     envir = parent.frame()) 
[10:24:23.969]                   {
[10:24:23.969]                     if (is.function(workers)) 
[10:24:23.969]                       workers <- workers()
[10:24:23.969]                     workers <- structure(as.integer(workers), 
[10:24:23.969]                       class = class(workers))
[10:24:23.969]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:23.969]                       workers >= 1)
[10:24:23.969]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:23.969]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:23.969]                     }
[10:24:23.969]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:23.969]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:23.969]                       envir = envir)
[10:24:23.969]                     if (!future$lazy) 
[10:24:23.969]                       future <- run(future)
[10:24:23.969]                     invisible(future)
[10:24:23.969]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:23.969]                 }
[10:24:23.969]             }
[10:24:23.969]         }
[10:24:23.969]     })
[10:24:23.969]     if (TRUE) {
[10:24:23.969]         base::sink(type = "output", split = FALSE)
[10:24:23.969]         if (TRUE) {
[10:24:23.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:23.969]         }
[10:24:23.969]         else {
[10:24:23.969]             ...future.result["stdout"] <- base::list(NULL)
[10:24:23.969]         }
[10:24:23.969]         base::close(...future.stdout)
[10:24:23.969]         ...future.stdout <- NULL
[10:24:23.969]     }
[10:24:23.969]     ...future.result$conditions <- ...future.conditions
[10:24:23.969]     ...future.result$finished <- base::Sys.time()
[10:24:23.969]     ...future.result
[10:24:23.969] }
[10:24:23.971] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[10:24:23.972] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:24.014] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:24.014] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[10:24:24.058] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[10:24:24.058] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:24.058] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:24.059] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:24.102] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:24.102] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:24.146] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:24.146] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:24:24.146] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:24:24.146] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:24:24.147] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:24:24.147] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:24.147] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:24.148] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[10:24:24.148] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[10:24:24.148] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:24.149] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:24.149] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:24.149] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:24.149] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[10:24:24.150] MultisessionFuture started
[10:24:24.150] - Launch lazy future ... done
[10:24:24.150] run() for ‘MultisessionFuture’ ... done
[10:24:24.150] Created future:
[10:24:24.151] MultisessionFuture:
[10:24:24.151] Label: ‘future_vapply-1’
[10:24:24.151] Expression:
[10:24:24.151] {
[10:24:24.151]     do.call(function(...) {
[10:24:24.151]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.151]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.151]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.151]             on.exit(options(oopts), add = TRUE)
[10:24:24.151]         }
[10:24:24.151]         {
[10:24:24.151]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.151]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.151]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.151]             })
[10:24:24.151]         }
[10:24:24.151]     }, args = future.call.arguments)
[10:24:24.151] }
[10:24:24.151] Lazy evaluation: FALSE
[10:24:24.151] Asynchronous evaluation: TRUE
[10:24:24.151] Local evaluation: TRUE
[10:24:24.151] Environment: R_GlobalEnv
[10:24:24.151] Capture standard output: TRUE
[10:24:24.151] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:24.151] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:24.151] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:24:24.151] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:24.151] Resolved: FALSE
[10:24:24.151] Value: <not collected>
[10:24:24.151] Conditions captured: <none>
[10:24:24.151] Early signaling: FALSE
[10:24:24.151] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:24.151] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:24.162] Chunk #1 of 2 ... DONE
[10:24:24.163] Chunk #2 of 2 ...
[10:24:24.163]  - Finding globals in 'X' for chunk #2 ...
[10:24:24.163] getGlobalsAndPackages() ...
[10:24:24.163] Searching for globals...
[10:24:24.163] 
[10:24:24.163] Searching for globals ... DONE
[10:24:24.163] - globals: [0] <none>
[10:24:24.163] getGlobalsAndPackages() ... DONE
[10:24:24.164]    + additional globals found: [n=0] 
[10:24:24.164]    + additional namespaces needed: [n=0] 
[10:24:24.164]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:24.164]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:24.164]  - seeds: <none>
[10:24:24.164]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.164] getGlobalsAndPackages() ...
[10:24:24.164] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.164] Resolving globals: FALSE
[10:24:24.165] Tweak future expression to call with '...' arguments ...
[10:24:24.165] {
[10:24:24.165]     do.call(function(...) {
[10:24:24.165]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.165]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.165]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.165]             on.exit(options(oopts), add = TRUE)
[10:24:24.165]         }
[10:24:24.165]         {
[10:24:24.165]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.165]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.165]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.165]             })
[10:24:24.165]         }
[10:24:24.165]     }, args = future.call.arguments)
[10:24:24.165] }
[10:24:24.165] Tweak future expression to call with '...' arguments ... DONE
[10:24:24.165] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.166] - packages: [2] ‘stats’, ‘future.apply’
[10:24:24.166] getGlobalsAndPackages() ... DONE
[10:24:24.166] run() for ‘Future’ ...
[10:24:24.166] - state: ‘created’
[10:24:24.166] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:24.180] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:24.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:24.181]   - Field: ‘node’
[10:24:24.181]   - Field: ‘label’
[10:24:24.181]   - Field: ‘local’
[10:24:24.181]   - Field: ‘owner’
[10:24:24.181]   - Field: ‘envir’
[10:24:24.181]   - Field: ‘workers’
[10:24:24.181]   - Field: ‘packages’
[10:24:24.181]   - Field: ‘gc’
[10:24:24.181]   - Field: ‘conditions’
[10:24:24.182]   - Field: ‘persistent’
[10:24:24.182]   - Field: ‘expr’
[10:24:24.182]   - Field: ‘uuid’
[10:24:24.182]   - Field: ‘seed’
[10:24:24.182]   - Field: ‘version’
[10:24:24.182]   - Field: ‘result’
[10:24:24.182]   - Field: ‘asynchronous’
[10:24:24.182]   - Field: ‘calls’
[10:24:24.182]   - Field: ‘globals’
[10:24:24.182]   - Field: ‘stdout’
[10:24:24.182]   - Field: ‘earlySignal’
[10:24:24.183]   - Field: ‘lazy’
[10:24:24.183]   - Field: ‘state’
[10:24:24.183] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:24.183] - Launch lazy future ...
[10:24:24.183] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:24:24.183] Packages needed by future strategies (n = 0): <none>
[10:24:24.184] {
[10:24:24.184]     {
[10:24:24.184]         {
[10:24:24.184]             ...future.startTime <- base::Sys.time()
[10:24:24.184]             {
[10:24:24.184]                 {
[10:24:24.184]                   {
[10:24:24.184]                     {
[10:24:24.184]                       {
[10:24:24.184]                         base::local({
[10:24:24.184]                           has_future <- base::requireNamespace("future", 
[10:24:24.184]                             quietly = TRUE)
[10:24:24.184]                           if (has_future) {
[10:24:24.184]                             ns <- base::getNamespace("future")
[10:24:24.184]                             version <- ns[[".package"]][["version"]]
[10:24:24.184]                             if (is.null(version)) 
[10:24:24.184]                               version <- utils::packageVersion("future")
[10:24:24.184]                           }
[10:24:24.184]                           else {
[10:24:24.184]                             version <- NULL
[10:24:24.184]                           }
[10:24:24.184]                           if (!has_future || version < "1.8.0") {
[10:24:24.184]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:24.184]                               "", base::R.version$version.string), 
[10:24:24.184]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:24.184]                                 base::R.version$platform, 8 * 
[10:24:24.184]                                   base::.Machine$sizeof.pointer), 
[10:24:24.184]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:24.184]                                 "release", "version")], collapse = " "), 
[10:24:24.184]                               hostname = base::Sys.info()[["nodename"]])
[10:24:24.184]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:24.184]                               info)
[10:24:24.184]                             info <- base::paste(info, collapse = "; ")
[10:24:24.184]                             if (!has_future) {
[10:24:24.184]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:24.184]                                 info)
[10:24:24.184]                             }
[10:24:24.184]                             else {
[10:24:24.184]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:24.184]                                 info, version)
[10:24:24.184]                             }
[10:24:24.184]                             base::stop(msg)
[10:24:24.184]                           }
[10:24:24.184]                         })
[10:24:24.184]                       }
[10:24:24.184]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:24.184]                       base::options(mc.cores = 1L)
[10:24:24.184]                     }
[10:24:24.184]                     base::local({
[10:24:24.184]                       for (pkg in c("stats", "future.apply")) {
[10:24:24.184]                         base::loadNamespace(pkg)
[10:24:24.184]                         base::library(pkg, character.only = TRUE)
[10:24:24.184]                       }
[10:24:24.184]                     })
[10:24:24.184]                   }
[10:24:24.184]                   options(future.plan = NULL)
[10:24:24.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:24.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:24.184]                 }
[10:24:24.184]                 ...future.workdir <- getwd()
[10:24:24.184]             }
[10:24:24.184]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:24.184]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:24.184]         }
[10:24:24.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:24.184]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:24.184]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:24.184]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:24.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:24.184]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:24.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:24.184]             base::names(...future.oldOptions))
[10:24:24.184]     }
[10:24:24.184]     if (FALSE) {
[10:24:24.184]     }
[10:24:24.184]     else {
[10:24:24.184]         if (TRUE) {
[10:24:24.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:24.184]                 open = "w")
[10:24:24.184]         }
[10:24:24.184]         else {
[10:24:24.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:24.184]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:24.184]         }
[10:24:24.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:24.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:24.184]             base::sink(type = "output", split = FALSE)
[10:24:24.184]             base::close(...future.stdout)
[10:24:24.184]         }, add = TRUE)
[10:24:24.184]     }
[10:24:24.184]     ...future.frame <- base::sys.nframe()
[10:24:24.184]     ...future.conditions <- base::list()
[10:24:24.184]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:24.184]     if (FALSE) {
[10:24:24.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:24.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:24.184]     }
[10:24:24.184]     ...future.result <- base::tryCatch({
[10:24:24.184]         base::withCallingHandlers({
[10:24:24.184]             ...future.value <- base::withVisible(base::local({
[10:24:24.184]                 ...future.makeSendCondition <- base::local({
[10:24:24.184]                   sendCondition <- NULL
[10:24:24.184]                   function(frame = 1L) {
[10:24:24.184]                     if (is.function(sendCondition)) 
[10:24:24.184]                       return(sendCondition)
[10:24:24.184]                     ns <- getNamespace("parallel")
[10:24:24.184]                     if (exists("sendData", mode = "function", 
[10:24:24.184]                       envir = ns)) {
[10:24:24.184]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:24.184]                         envir = ns)
[10:24:24.184]                       envir <- sys.frame(frame)
[10:24:24.184]                       master <- NULL
[10:24:24.184]                       while (!identical(envir, .GlobalEnv) && 
[10:24:24.184]                         !identical(envir, emptyenv())) {
[10:24:24.184]                         if (exists("master", mode = "list", envir = envir, 
[10:24:24.184]                           inherits = FALSE)) {
[10:24:24.184]                           master <- get("master", mode = "list", 
[10:24:24.184]                             envir = envir, inherits = FALSE)
[10:24:24.184]                           if (inherits(master, c("SOCKnode", 
[10:24:24.184]                             "SOCK0node"))) {
[10:24:24.184]                             sendCondition <<- function(cond) {
[10:24:24.184]                               data <- list(type = "VALUE", value = cond, 
[10:24:24.184]                                 success = TRUE)
[10:24:24.184]                               parallel_sendData(master, data)
[10:24:24.184]                             }
[10:24:24.184]                             return(sendCondition)
[10:24:24.184]                           }
[10:24:24.184]                         }
[10:24:24.184]                         frame <- frame + 1L
[10:24:24.184]                         envir <- sys.frame(frame)
[10:24:24.184]                       }
[10:24:24.184]                     }
[10:24:24.184]                     sendCondition <<- function(cond) NULL
[10:24:24.184]                   }
[10:24:24.184]                 })
[10:24:24.184]                 withCallingHandlers({
[10:24:24.184]                   {
[10:24:24.184]                     do.call(function(...) {
[10:24:24.184]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.184]                       if (!identical(...future.globals.maxSize.org, 
[10:24:24.184]                         ...future.globals.maxSize)) {
[10:24:24.184]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.184]                         on.exit(options(oopts), add = TRUE)
[10:24:24.184]                       }
[10:24:24.184]                       {
[10:24:24.184]                         lapply(seq_along(...future.elements_ii), 
[10:24:24.184]                           FUN = function(jj) {
[10:24:24.184]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.184]                             ...future.FUN(...future.X_jj, ...)
[10:24:24.184]                           })
[10:24:24.184]                       }
[10:24:24.184]                     }, args = future.call.arguments)
[10:24:24.184]                   }
[10:24:24.184]                 }, immediateCondition = function(cond) {
[10:24:24.184]                   sendCondition <- ...future.makeSendCondition()
[10:24:24.184]                   sendCondition(cond)
[10:24:24.184]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.184]                   {
[10:24:24.184]                     inherits <- base::inherits
[10:24:24.184]                     invokeRestart <- base::invokeRestart
[10:24:24.184]                     is.null <- base::is.null
[10:24:24.184]                     muffled <- FALSE
[10:24:24.184]                     if (inherits(cond, "message")) {
[10:24:24.184]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:24.184]                       if (muffled) 
[10:24:24.184]                         invokeRestart("muffleMessage")
[10:24:24.184]                     }
[10:24:24.184]                     else if (inherits(cond, "warning")) {
[10:24:24.184]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:24.184]                       if (muffled) 
[10:24:24.184]                         invokeRestart("muffleWarning")
[10:24:24.184]                     }
[10:24:24.184]                     else if (inherits(cond, "condition")) {
[10:24:24.184]                       if (!is.null(pattern)) {
[10:24:24.184]                         computeRestarts <- base::computeRestarts
[10:24:24.184]                         grepl <- base::grepl
[10:24:24.184]                         restarts <- computeRestarts(cond)
[10:24:24.184]                         for (restart in restarts) {
[10:24:24.184]                           name <- restart$name
[10:24:24.184]                           if (is.null(name)) 
[10:24:24.184]                             next
[10:24:24.184]                           if (!grepl(pattern, name)) 
[10:24:24.184]                             next
[10:24:24.184]                           invokeRestart(restart)
[10:24:24.184]                           muffled <- TRUE
[10:24:24.184]                           break
[10:24:24.184]                         }
[10:24:24.184]                       }
[10:24:24.184]                     }
[10:24:24.184]                     invisible(muffled)
[10:24:24.184]                   }
[10:24:24.184]                   muffleCondition(cond)
[10:24:24.184]                 })
[10:24:24.184]             }))
[10:24:24.184]             future::FutureResult(value = ...future.value$value, 
[10:24:24.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:24.184]                   ...future.rng), globalenv = if (FALSE) 
[10:24:24.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:24.184]                     ...future.globalenv.names))
[10:24:24.184]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:24.184]         }, condition = base::local({
[10:24:24.184]             c <- base::c
[10:24:24.184]             inherits <- base::inherits
[10:24:24.184]             invokeRestart <- base::invokeRestart
[10:24:24.184]             length <- base::length
[10:24:24.184]             list <- base::list
[10:24:24.184]             seq.int <- base::seq.int
[10:24:24.184]             signalCondition <- base::signalCondition
[10:24:24.184]             sys.calls <- base::sys.calls
[10:24:24.184]             `[[` <- base::`[[`
[10:24:24.184]             `+` <- base::`+`
[10:24:24.184]             `<<-` <- base::`<<-`
[10:24:24.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:24.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:24.184]                   3L)]
[10:24:24.184]             }
[10:24:24.184]             function(cond) {
[10:24:24.184]                 is_error <- inherits(cond, "error")
[10:24:24.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:24.184]                   NULL)
[10:24:24.184]                 if (is_error) {
[10:24:24.184]                   sessionInformation <- function() {
[10:24:24.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:24.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:24.184]                       search = base::search(), system = base::Sys.info())
[10:24:24.184]                   }
[10:24:24.184]                   ...future.conditions[[length(...future.conditions) + 
[10:24:24.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:24.184]                     cond$call), session = sessionInformation(), 
[10:24:24.184]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:24.184]                   signalCondition(cond)
[10:24:24.184]                 }
[10:24:24.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:24.184]                 "immediateCondition"))) {
[10:24:24.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:24.184]                   ...future.conditions[[length(...future.conditions) + 
[10:24:24.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:24.184]                   if (TRUE && !signal) {
[10:24:24.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.184]                     {
[10:24:24.184]                       inherits <- base::inherits
[10:24:24.184]                       invokeRestart <- base::invokeRestart
[10:24:24.184]                       is.null <- base::is.null
[10:24:24.184]                       muffled <- FALSE
[10:24:24.184]                       if (inherits(cond, "message")) {
[10:24:24.184]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:24.184]                         if (muffled) 
[10:24:24.184]                           invokeRestart("muffleMessage")
[10:24:24.184]                       }
[10:24:24.184]                       else if (inherits(cond, "warning")) {
[10:24:24.184]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:24.184]                         if (muffled) 
[10:24:24.184]                           invokeRestart("muffleWarning")
[10:24:24.184]                       }
[10:24:24.184]                       else if (inherits(cond, "condition")) {
[10:24:24.184]                         if (!is.null(pattern)) {
[10:24:24.184]                           computeRestarts <- base::computeRestarts
[10:24:24.184]                           grepl <- base::grepl
[10:24:24.184]                           restarts <- computeRestarts(cond)
[10:24:24.184]                           for (restart in restarts) {
[10:24:24.184]                             name <- restart$name
[10:24:24.184]                             if (is.null(name)) 
[10:24:24.184]                               next
[10:24:24.184]                             if (!grepl(pattern, name)) 
[10:24:24.184]                               next
[10:24:24.184]                             invokeRestart(restart)
[10:24:24.184]                             muffled <- TRUE
[10:24:24.184]                             break
[10:24:24.184]                           }
[10:24:24.184]                         }
[10:24:24.184]                       }
[10:24:24.184]                       invisible(muffled)
[10:24:24.184]                     }
[10:24:24.184]                     muffleCondition(cond, pattern = "^muffle")
[10:24:24.184]                   }
[10:24:24.184]                 }
[10:24:24.184]                 else {
[10:24:24.184]                   if (TRUE) {
[10:24:24.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.184]                     {
[10:24:24.184]                       inherits <- base::inherits
[10:24:24.184]                       invokeRestart <- base::invokeRestart
[10:24:24.184]                       is.null <- base::is.null
[10:24:24.184]                       muffled <- FALSE
[10:24:24.184]                       if (inherits(cond, "message")) {
[10:24:24.184]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:24.184]                         if (muffled) 
[10:24:24.184]                           invokeRestart("muffleMessage")
[10:24:24.184]                       }
[10:24:24.184]                       else if (inherits(cond, "warning")) {
[10:24:24.184]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:24.184]                         if (muffled) 
[10:24:24.184]                           invokeRestart("muffleWarning")
[10:24:24.184]                       }
[10:24:24.184]                       else if (inherits(cond, "condition")) {
[10:24:24.184]                         if (!is.null(pattern)) {
[10:24:24.184]                           computeRestarts <- base::computeRestarts
[10:24:24.184]                           grepl <- base::grepl
[10:24:24.184]                           restarts <- computeRestarts(cond)
[10:24:24.184]                           for (restart in restarts) {
[10:24:24.184]                             name <- restart$name
[10:24:24.184]                             if (is.null(name)) 
[10:24:24.184]                               next
[10:24:24.184]                             if (!grepl(pattern, name)) 
[10:24:24.184]                               next
[10:24:24.184]                             invokeRestart(restart)
[10:24:24.184]                             muffled <- TRUE
[10:24:24.184]                             break
[10:24:24.184]                           }
[10:24:24.184]                         }
[10:24:24.184]                       }
[10:24:24.184]                       invisible(muffled)
[10:24:24.184]                     }
[10:24:24.184]                     muffleCondition(cond, pattern = "^muffle")
[10:24:24.184]                   }
[10:24:24.184]                 }
[10:24:24.184]             }
[10:24:24.184]         }))
[10:24:24.184]     }, error = function(ex) {
[10:24:24.184]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:24.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:24.184]                 ...future.rng), started = ...future.startTime, 
[10:24:24.184]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:24.184]             version = "1.8"), class = "FutureResult")
[10:24:24.184]     }, finally = {
[10:24:24.184]         if (!identical(...future.workdir, getwd())) 
[10:24:24.184]             setwd(...future.workdir)
[10:24:24.184]         {
[10:24:24.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:24.184]                 ...future.oldOptions$nwarnings <- NULL
[10:24:24.184]             }
[10:24:24.184]             base::options(...future.oldOptions)
[10:24:24.184]             if (.Platform$OS.type == "windows") {
[10:24:24.184]                 old_names <- names(...future.oldEnvVars)
[10:24:24.184]                 envs <- base::Sys.getenv()
[10:24:24.184]                 names <- names(envs)
[10:24:24.184]                 common <- intersect(names, old_names)
[10:24:24.184]                 added <- setdiff(names, old_names)
[10:24:24.184]                 removed <- setdiff(old_names, names)
[10:24:24.184]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:24.184]                   envs[common]]
[10:24:24.184]                 NAMES <- toupper(changed)
[10:24:24.184]                 args <- list()
[10:24:24.184]                 for (kk in seq_along(NAMES)) {
[10:24:24.184]                   name <- changed[[kk]]
[10:24:24.184]                   NAME <- NAMES[[kk]]
[10:24:24.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.184]                     next
[10:24:24.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:24.184]                 }
[10:24:24.184]                 NAMES <- toupper(added)
[10:24:24.184]                 for (kk in seq_along(NAMES)) {
[10:24:24.184]                   name <- added[[kk]]
[10:24:24.184]                   NAME <- NAMES[[kk]]
[10:24:24.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.184]                     next
[10:24:24.184]                   args[[name]] <- ""
[10:24:24.184]                 }
[10:24:24.184]                 NAMES <- toupper(removed)
[10:24:24.184]                 for (kk in seq_along(NAMES)) {
[10:24:24.184]                   name <- removed[[kk]]
[10:24:24.184]                   NAME <- NAMES[[kk]]
[10:24:24.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.184]                     next
[10:24:24.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:24.184]                 }
[10:24:24.184]                 if (length(args) > 0) 
[10:24:24.184]                   base::do.call(base::Sys.setenv, args = args)
[10:24:24.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:24.184]             }
[10:24:24.184]             else {
[10:24:24.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:24.184]             }
[10:24:24.184]             {
[10:24:24.184]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:24.184]                   0L) {
[10:24:24.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:24.184]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:24.184]                   base::options(opts)
[10:24:24.184]                 }
[10:24:24.184]                 {
[10:24:24.184]                   {
[10:24:24.184]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:24.184]                     NULL
[10:24:24.184]                   }
[10:24:24.184]                   options(future.plan = NULL)
[10:24:24.184]                   if (is.na(NA_character_)) 
[10:24:24.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:24.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:24.184]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:24.184]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:24.184]                     envir = parent.frame()) 
[10:24:24.184]                   {
[10:24:24.184]                     if (is.function(workers)) 
[10:24:24.184]                       workers <- workers()
[10:24:24.184]                     workers <- structure(as.integer(workers), 
[10:24:24.184]                       class = class(workers))
[10:24:24.184]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:24.184]                       workers >= 1)
[10:24:24.184]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:24.184]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:24.184]                     }
[10:24:24.184]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:24.184]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:24.184]                       envir = envir)
[10:24:24.184]                     if (!future$lazy) 
[10:24:24.184]                       future <- run(future)
[10:24:24.184]                     invisible(future)
[10:24:24.184]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:24.184]                 }
[10:24:24.184]             }
[10:24:24.184]         }
[10:24:24.184]     })
[10:24:24.184]     if (TRUE) {
[10:24:24.184]         base::sink(type = "output", split = FALSE)
[10:24:24.184]         if (TRUE) {
[10:24:24.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:24.184]         }
[10:24:24.184]         else {
[10:24:24.184]             ...future.result["stdout"] <- base::list(NULL)
[10:24:24.184]         }
[10:24:24.184]         base::close(...future.stdout)
[10:24:24.184]         ...future.stdout <- NULL
[10:24:24.184]     }
[10:24:24.184]     ...future.result$conditions <- ...future.conditions
[10:24:24.184]     ...future.result$finished <- base::Sys.time()
[10:24:24.184]     ...future.result
[10:24:24.184] }
[10:24:24.187] Exporting 11 global objects (137.93 KiB) to cluster node #2 ...
[10:24:24.187] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:24.232] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:24.233] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ...
[10:24:24.274] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ... DONE
[10:24:24.274] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:24.274] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:24.274] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:24.318] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:24.318] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:24.362] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:24.362] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:24:24.362] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:24:24.363] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:24:24.363] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:24:24.363] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:24.364] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:24.364] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[10:24:24.364] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[10:24:24.364] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:24.365] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:24.365] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:24.365] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:24.365] Exporting 11 global objects (137.93 KiB) to cluster node #2 ... DONE
[10:24:24.366] MultisessionFuture started
[10:24:24.366] - Launch lazy future ... done
[10:24:24.366] run() for ‘MultisessionFuture’ ... done
[10:24:24.367] Created future:
[10:24:24.367] MultisessionFuture:
[10:24:24.367] Label: ‘future_vapply-2’
[10:24:24.367] Expression:
[10:24:24.367] {
[10:24:24.367]     do.call(function(...) {
[10:24:24.367]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.367]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.367]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.367]             on.exit(options(oopts), add = TRUE)
[10:24:24.367]         }
[10:24:24.367]         {
[10:24:24.367]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.367]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.367]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.367]             })
[10:24:24.367]         }
[10:24:24.367]     }, args = future.call.arguments)
[10:24:24.367] }
[10:24:24.367] Lazy evaluation: FALSE
[10:24:24.367] Asynchronous evaluation: TRUE
[10:24:24.367] Local evaluation: TRUE
[10:24:24.367] Environment: R_GlobalEnv
[10:24:24.367] Capture standard output: TRUE
[10:24:24.367] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:24.367] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:24.367] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:24:24.367] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:24.367] Resolved: FALSE
[10:24:24.367] Value: <not collected>
[10:24:24.367] Conditions captured: <none>
[10:24:24.367] Early signaling: FALSE
[10:24:24.367] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:24.367] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:24.378] Chunk #2 of 2 ... DONE
[10:24:24.379] Launching 2 futures (chunks) ... DONE
[10:24:24.379] Resolving 2 futures (chunks) ...
[10:24:24.379] resolve() on list ...
[10:24:24.379]  recursive: 0
[10:24:24.379]  length: 2
[10:24:24.379] 
[10:24:24.380] receiveMessageFromWorker() for ClusterFuture ...
[10:24:24.380] - Validating connection of MultisessionFuture
[10:24:24.380] - received message: FutureResult
[10:24:24.380] - Received FutureResult
[10:24:24.380] - Erased future from FutureRegistry
[10:24:24.380] result() for ClusterFuture ...
[10:24:24.380] - result already collected: FutureResult
[10:24:24.380] result() for ClusterFuture ... done
[10:24:24.381] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:24.381] Future #1
[10:24:24.381] result() for ClusterFuture ...
[10:24:24.381] - result already collected: FutureResult
[10:24:24.381] result() for ClusterFuture ... done
[10:24:24.381] result() for ClusterFuture ...
[10:24:24.381] - result already collected: FutureResult
[10:24:24.381] result() for ClusterFuture ... done
[10:24:24.381] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:24.381] - nx: 2
[10:24:24.382] - relay: TRUE
[10:24:24.382] - stdout: TRUE
[10:24:24.382] - signal: TRUE
[10:24:24.382] - resignal: FALSE
[10:24:24.382] - force: TRUE
[10:24:24.382] - relayed: [n=2] FALSE, FALSE
[10:24:24.382] - queued futures: [n=2] FALSE, FALSE
[10:24:24.382]  - until=1
[10:24:24.382]  - relaying element #1
[10:24:24.382] result() for ClusterFuture ...
[10:24:24.382] - result already collected: FutureResult
[10:24:24.382] result() for ClusterFuture ... done
[10:24:24.383] result() for ClusterFuture ...
[10:24:24.383] - result already collected: FutureResult
[10:24:24.383] result() for ClusterFuture ... done
[10:24:24.383] result() for ClusterFuture ...
[10:24:24.383] - result already collected: FutureResult
[10:24:24.383] result() for ClusterFuture ... done
[10:24:24.383] result() for ClusterFuture ...
[10:24:24.383] - result already collected: FutureResult
[10:24:24.383] result() for ClusterFuture ... done
[10:24:24.383] - relayed: [n=2] TRUE, FALSE
[10:24:24.383] - queued futures: [n=2] TRUE, FALSE
[10:24:24.384] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:24.384]  length: 1 (resolved future 1)
[10:24:24.415] receiveMessageFromWorker() for ClusterFuture ...
[10:24:24.415] - Validating connection of MultisessionFuture
[10:24:24.415] - received message: FutureResult
[10:24:24.415] - Received FutureResult
[10:24:24.415] - Erased future from FutureRegistry
[10:24:24.415] result() for ClusterFuture ...
[10:24:24.416] - result already collected: FutureResult
[10:24:24.416] result() for ClusterFuture ... done
[10:24:24.416] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:24.416] Future #2
[10:24:24.416] result() for ClusterFuture ...
[10:24:24.416] - result already collected: FutureResult
[10:24:24.416] result() for ClusterFuture ... done
[10:24:24.416] result() for ClusterFuture ...
[10:24:24.416] - result already collected: FutureResult
[10:24:24.416] result() for ClusterFuture ... done
[10:24:24.417] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:24.417] - nx: 2
[10:24:24.417] - relay: TRUE
[10:24:24.417] - stdout: TRUE
[10:24:24.417] - signal: TRUE
[10:24:24.417] - resignal: FALSE
[10:24:24.417] - force: TRUE
[10:24:24.417] - relayed: [n=2] TRUE, FALSE
[10:24:24.417] - queued futures: [n=2] TRUE, FALSE
[10:24:24.417]  - until=2
[10:24:24.417]  - relaying element #2
[10:24:24.418] result() for ClusterFuture ...
[10:24:24.418] - result already collected: FutureResult
[10:24:24.418] result() for ClusterFuture ... done
[10:24:24.418] result() for ClusterFuture ...
[10:24:24.418] - result already collected: FutureResult
[10:24:24.418] result() for ClusterFuture ... done
[10:24:24.418] result() for ClusterFuture ...
[10:24:24.418] - result already collected: FutureResult
[10:24:24.418] result() for ClusterFuture ... done
[10:24:24.418] result() for ClusterFuture ...
[10:24:24.419] - result already collected: FutureResult
[10:24:24.419] result() for ClusterFuture ... done
[10:24:24.419] - relayed: [n=2] TRUE, TRUE
[10:24:24.419] - queued futures: [n=2] TRUE, TRUE
[10:24:24.419] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:24.419]  length: 0 (resolved future 2)
[10:24:24.419] Relaying remaining futures
[10:24:24.419] signalConditionsASAP(NULL, pos=0) ...
[10:24:24.419] - nx: 2
[10:24:24.419] - relay: TRUE
[10:24:24.419] - stdout: TRUE
[10:24:24.419] - signal: TRUE
[10:24:24.420] - resignal: FALSE
[10:24:24.420] - force: TRUE
[10:24:24.420] - relayed: [n=2] TRUE, TRUE
[10:24:24.420] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:24.420] - relayed: [n=2] TRUE, TRUE
[10:24:24.420] - queued futures: [n=2] TRUE, TRUE
[10:24:24.420] signalConditionsASAP(NULL, pos=0) ... done
[10:24:24.420] resolve() on list ... DONE
[10:24:24.420] result() for ClusterFuture ...
[10:24:24.420] - result already collected: FutureResult
[10:24:24.421] result() for ClusterFuture ... done
[10:24:24.421] result() for ClusterFuture ...
[10:24:24.421] - result already collected: FutureResult
[10:24:24.421] result() for ClusterFuture ... done
[10:24:24.421] result() for ClusterFuture ...
[10:24:24.421] - result already collected: FutureResult
[10:24:24.421] result() for ClusterFuture ... done
[10:24:24.421] result() for ClusterFuture ...
[10:24:24.421] - result already collected: FutureResult
[10:24:24.421] result() for ClusterFuture ... done
[10:24:24.422]  - Number of value chunks collected: 2
[10:24:24.422] Resolving 2 futures (chunks) ... DONE
[10:24:24.422] Reducing values from 2 chunks ...
[10:24:24.422]  - Number of values collected after concatenation: 7
[10:24:24.422]  - Number of values expected: 7
[10:24:24.422] Reducing values from 2 chunks ... DONE
[10:24:24.422] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[10:24:24.424] future_lapply() ...
[10:24:24.428] Number of chunks: 2
[10:24:24.428] getGlobalsAndPackagesXApply() ...
[10:24:24.428]  - future.globals: TRUE
[10:24:24.428] getGlobalsAndPackages() ...
[10:24:24.428] Searching for globals...
[10:24:24.430] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[10:24:24.430] Searching for globals ... DONE
[10:24:24.430] Resolving globals: FALSE
[10:24:24.430] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[10:24:24.431] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[10:24:24.431] - globals: [1] ‘FUN’
[10:24:24.431] 
[10:24:24.431] getGlobalsAndPackages() ... DONE
[10:24:24.431]  - globals found/used: [n=1] ‘FUN’
[10:24:24.431]  - needed namespaces: [n=0] 
[10:24:24.431] Finding globals ... DONE
[10:24:24.431]  - use_args: TRUE
[10:24:24.431]  - Getting '...' globals ...
[10:24:24.432] resolve() on list ...
[10:24:24.432]  recursive: 0
[10:24:24.432]  length: 1
[10:24:24.432]  elements: ‘...’
[10:24:24.432]  length: 0 (resolved future 1)
[10:24:24.432] resolve() on list ... DONE
[10:24:24.432]    - '...' content: [n=1] ‘y’
[10:24:24.432] List of 1
[10:24:24.432]  $ ...:List of 1
[10:24:24.432]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:24.432]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:24.432]  - attr(*, "where")=List of 1
[10:24:24.432]   ..$ ...:<environment: 0x55b93d53e990> 
[10:24:24.432]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:24.432]  - attr(*, "resolved")= logi TRUE
[10:24:24.432]  - attr(*, "total_size")= num NA
[10:24:24.436]  - Getting '...' globals ... DONE
[10:24:24.436] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:24.436] List of 2
[10:24:24.436]  $ ...future.FUN:function (x, y)  
[10:24:24.436]  $ ...          :List of 1
[10:24:24.436]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:24.436]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:24.436]  - attr(*, "where")=List of 2
[10:24:24.436]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:24.436]   ..$ ...          :<environment: 0x55b93d53e990> 
[10:24:24.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:24.436]  - attr(*, "resolved")= logi FALSE
[10:24:24.436]  - attr(*, "total_size")= num 4264
[10:24:24.439] Packages to be attached in all futures: [n=0] 
[10:24:24.439] getGlobalsAndPackagesXApply() ... DONE
[10:24:24.439] Number of futures (= number of chunks): 2
[10:24:24.439] Launching 2 futures (chunks) ...
[10:24:24.439] Chunk #1 of 2 ...
[10:24:24.440]  - Finding globals in 'X' for chunk #1 ...
[10:24:24.440] getGlobalsAndPackages() ...
[10:24:24.440] Searching for globals...
[10:24:24.440] 
[10:24:24.440] Searching for globals ... DONE
[10:24:24.440] - globals: [0] <none>
[10:24:24.440] getGlobalsAndPackages() ... DONE
[10:24:24.440]    + additional globals found: [n=0] 
[10:24:24.440]    + additional namespaces needed: [n=0] 
[10:24:24.441]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:24.441]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:24.441]  - seeds: <none>
[10:24:24.441]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.441] getGlobalsAndPackages() ...
[10:24:24.441] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.441] Resolving globals: FALSE
[10:24:24.441] Tweak future expression to call with '...' arguments ...
[10:24:24.441] {
[10:24:24.441]     do.call(function(...) {
[10:24:24.441]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.441]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.441]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.441]             on.exit(options(oopts), add = TRUE)
[10:24:24.441]         }
[10:24:24.441]         {
[10:24:24.441]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.441]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.441]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.441]             })
[10:24:24.441]         }
[10:24:24.441]     }, args = future.call.arguments)
[10:24:24.441] }
[10:24:24.442] Tweak future expression to call with '...' arguments ... DONE
[10:24:24.442] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.442] 
[10:24:24.442] getGlobalsAndPackages() ... DONE
[10:24:24.443] run() for ‘Future’ ...
[10:24:24.443] - state: ‘created’
[10:24:24.443] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:24.457] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:24.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:24.457]   - Field: ‘node’
[10:24:24.457]   - Field: ‘label’
[10:24:24.457]   - Field: ‘local’
[10:24:24.457]   - Field: ‘owner’
[10:24:24.457]   - Field: ‘envir’
[10:24:24.458]   - Field: ‘workers’
[10:24:24.458]   - Field: ‘packages’
[10:24:24.458]   - Field: ‘gc’
[10:24:24.458]   - Field: ‘conditions’
[10:24:24.458]   - Field: ‘persistent’
[10:24:24.458]   - Field: ‘expr’
[10:24:24.458]   - Field: ‘uuid’
[10:24:24.458]   - Field: ‘seed’
[10:24:24.458]   - Field: ‘version’
[10:24:24.458]   - Field: ‘result’
[10:24:24.458]   - Field: ‘asynchronous’
[10:24:24.459]   - Field: ‘calls’
[10:24:24.459]   - Field: ‘globals’
[10:24:24.459]   - Field: ‘stdout’
[10:24:24.459]   - Field: ‘earlySignal’
[10:24:24.459]   - Field: ‘lazy’
[10:24:24.459]   - Field: ‘state’
[10:24:24.459] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:24.459] - Launch lazy future ...
[10:24:24.460] Packages needed by the future expression (n = 0): <none>
[10:24:24.460] Packages needed by future strategies (n = 0): <none>
[10:24:24.460] {
[10:24:24.460]     {
[10:24:24.460]         {
[10:24:24.460]             ...future.startTime <- base::Sys.time()
[10:24:24.460]             {
[10:24:24.460]                 {
[10:24:24.460]                   {
[10:24:24.460]                     {
[10:24:24.460]                       base::local({
[10:24:24.460]                         has_future <- base::requireNamespace("future", 
[10:24:24.460]                           quietly = TRUE)
[10:24:24.460]                         if (has_future) {
[10:24:24.460]                           ns <- base::getNamespace("future")
[10:24:24.460]                           version <- ns[[".package"]][["version"]]
[10:24:24.460]                           if (is.null(version)) 
[10:24:24.460]                             version <- utils::packageVersion("future")
[10:24:24.460]                         }
[10:24:24.460]                         else {
[10:24:24.460]                           version <- NULL
[10:24:24.460]                         }
[10:24:24.460]                         if (!has_future || version < "1.8.0") {
[10:24:24.460]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:24.460]                             "", base::R.version$version.string), 
[10:24:24.460]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:24.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:24.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:24.460]                               "release", "version")], collapse = " "), 
[10:24:24.460]                             hostname = base::Sys.info()[["nodename"]])
[10:24:24.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:24.460]                             info)
[10:24:24.460]                           info <- base::paste(info, collapse = "; ")
[10:24:24.460]                           if (!has_future) {
[10:24:24.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:24.460]                               info)
[10:24:24.460]                           }
[10:24:24.460]                           else {
[10:24:24.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:24.460]                               info, version)
[10:24:24.460]                           }
[10:24:24.460]                           base::stop(msg)
[10:24:24.460]                         }
[10:24:24.460]                       })
[10:24:24.460]                     }
[10:24:24.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:24.460]                     base::options(mc.cores = 1L)
[10:24:24.460]                   }
[10:24:24.460]                   options(future.plan = NULL)
[10:24:24.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:24.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:24.460]                 }
[10:24:24.460]                 ...future.workdir <- getwd()
[10:24:24.460]             }
[10:24:24.460]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:24.460]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:24.460]         }
[10:24:24.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:24.460]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:24.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:24.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:24.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:24.460]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:24.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:24.460]             base::names(...future.oldOptions))
[10:24:24.460]     }
[10:24:24.460]     if (FALSE) {
[10:24:24.460]     }
[10:24:24.460]     else {
[10:24:24.460]         if (TRUE) {
[10:24:24.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:24.460]                 open = "w")
[10:24:24.460]         }
[10:24:24.460]         else {
[10:24:24.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:24.460]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:24.460]         }
[10:24:24.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:24.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:24.460]             base::sink(type = "output", split = FALSE)
[10:24:24.460]             base::close(...future.stdout)
[10:24:24.460]         }, add = TRUE)
[10:24:24.460]     }
[10:24:24.460]     ...future.frame <- base::sys.nframe()
[10:24:24.460]     ...future.conditions <- base::list()
[10:24:24.460]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:24.460]     if (FALSE) {
[10:24:24.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:24.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:24.460]     }
[10:24:24.460]     ...future.result <- base::tryCatch({
[10:24:24.460]         base::withCallingHandlers({
[10:24:24.460]             ...future.value <- base::withVisible(base::local({
[10:24:24.460]                 ...future.makeSendCondition <- base::local({
[10:24:24.460]                   sendCondition <- NULL
[10:24:24.460]                   function(frame = 1L) {
[10:24:24.460]                     if (is.function(sendCondition)) 
[10:24:24.460]                       return(sendCondition)
[10:24:24.460]                     ns <- getNamespace("parallel")
[10:24:24.460]                     if (exists("sendData", mode = "function", 
[10:24:24.460]                       envir = ns)) {
[10:24:24.460]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:24.460]                         envir = ns)
[10:24:24.460]                       envir <- sys.frame(frame)
[10:24:24.460]                       master <- NULL
[10:24:24.460]                       while (!identical(envir, .GlobalEnv) && 
[10:24:24.460]                         !identical(envir, emptyenv())) {
[10:24:24.460]                         if (exists("master", mode = "list", envir = envir, 
[10:24:24.460]                           inherits = FALSE)) {
[10:24:24.460]                           master <- get("master", mode = "list", 
[10:24:24.460]                             envir = envir, inherits = FALSE)
[10:24:24.460]                           if (inherits(master, c("SOCKnode", 
[10:24:24.460]                             "SOCK0node"))) {
[10:24:24.460]                             sendCondition <<- function(cond) {
[10:24:24.460]                               data <- list(type = "VALUE", value = cond, 
[10:24:24.460]                                 success = TRUE)
[10:24:24.460]                               parallel_sendData(master, data)
[10:24:24.460]                             }
[10:24:24.460]                             return(sendCondition)
[10:24:24.460]                           }
[10:24:24.460]                         }
[10:24:24.460]                         frame <- frame + 1L
[10:24:24.460]                         envir <- sys.frame(frame)
[10:24:24.460]                       }
[10:24:24.460]                     }
[10:24:24.460]                     sendCondition <<- function(cond) NULL
[10:24:24.460]                   }
[10:24:24.460]                 })
[10:24:24.460]                 withCallingHandlers({
[10:24:24.460]                   {
[10:24:24.460]                     do.call(function(...) {
[10:24:24.460]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.460]                       if (!identical(...future.globals.maxSize.org, 
[10:24:24.460]                         ...future.globals.maxSize)) {
[10:24:24.460]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.460]                         on.exit(options(oopts), add = TRUE)
[10:24:24.460]                       }
[10:24:24.460]                       {
[10:24:24.460]                         lapply(seq_along(...future.elements_ii), 
[10:24:24.460]                           FUN = function(jj) {
[10:24:24.460]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.460]                             ...future.FUN(...future.X_jj, ...)
[10:24:24.460]                           })
[10:24:24.460]                       }
[10:24:24.460]                     }, args = future.call.arguments)
[10:24:24.460]                   }
[10:24:24.460]                 }, immediateCondition = function(cond) {
[10:24:24.460]                   sendCondition <- ...future.makeSendCondition()
[10:24:24.460]                   sendCondition(cond)
[10:24:24.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.460]                   {
[10:24:24.460]                     inherits <- base::inherits
[10:24:24.460]                     invokeRestart <- base::invokeRestart
[10:24:24.460]                     is.null <- base::is.null
[10:24:24.460]                     muffled <- FALSE
[10:24:24.460]                     if (inherits(cond, "message")) {
[10:24:24.460]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:24.460]                       if (muffled) 
[10:24:24.460]                         invokeRestart("muffleMessage")
[10:24:24.460]                     }
[10:24:24.460]                     else if (inherits(cond, "warning")) {
[10:24:24.460]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:24.460]                       if (muffled) 
[10:24:24.460]                         invokeRestart("muffleWarning")
[10:24:24.460]                     }
[10:24:24.460]                     else if (inherits(cond, "condition")) {
[10:24:24.460]                       if (!is.null(pattern)) {
[10:24:24.460]                         computeRestarts <- base::computeRestarts
[10:24:24.460]                         grepl <- base::grepl
[10:24:24.460]                         restarts <- computeRestarts(cond)
[10:24:24.460]                         for (restart in restarts) {
[10:24:24.460]                           name <- restart$name
[10:24:24.460]                           if (is.null(name)) 
[10:24:24.460]                             next
[10:24:24.460]                           if (!grepl(pattern, name)) 
[10:24:24.460]                             next
[10:24:24.460]                           invokeRestart(restart)
[10:24:24.460]                           muffled <- TRUE
[10:24:24.460]                           break
[10:24:24.460]                         }
[10:24:24.460]                       }
[10:24:24.460]                     }
[10:24:24.460]                     invisible(muffled)
[10:24:24.460]                   }
[10:24:24.460]                   muffleCondition(cond)
[10:24:24.460]                 })
[10:24:24.460]             }))
[10:24:24.460]             future::FutureResult(value = ...future.value$value, 
[10:24:24.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:24.460]                   ...future.rng), globalenv = if (FALSE) 
[10:24:24.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:24.460]                     ...future.globalenv.names))
[10:24:24.460]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:24.460]         }, condition = base::local({
[10:24:24.460]             c <- base::c
[10:24:24.460]             inherits <- base::inherits
[10:24:24.460]             invokeRestart <- base::invokeRestart
[10:24:24.460]             length <- base::length
[10:24:24.460]             list <- base::list
[10:24:24.460]             seq.int <- base::seq.int
[10:24:24.460]             signalCondition <- base::signalCondition
[10:24:24.460]             sys.calls <- base::sys.calls
[10:24:24.460]             `[[` <- base::`[[`
[10:24:24.460]             `+` <- base::`+`
[10:24:24.460]             `<<-` <- base::`<<-`
[10:24:24.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:24.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:24.460]                   3L)]
[10:24:24.460]             }
[10:24:24.460]             function(cond) {
[10:24:24.460]                 is_error <- inherits(cond, "error")
[10:24:24.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:24.460]                   NULL)
[10:24:24.460]                 if (is_error) {
[10:24:24.460]                   sessionInformation <- function() {
[10:24:24.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:24.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:24.460]                       search = base::search(), system = base::Sys.info())
[10:24:24.460]                   }
[10:24:24.460]                   ...future.conditions[[length(...future.conditions) + 
[10:24:24.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:24.460]                     cond$call), session = sessionInformation(), 
[10:24:24.460]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:24.460]                   signalCondition(cond)
[10:24:24.460]                 }
[10:24:24.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:24.460]                 "immediateCondition"))) {
[10:24:24.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:24.460]                   ...future.conditions[[length(...future.conditions) + 
[10:24:24.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:24.460]                   if (TRUE && !signal) {
[10:24:24.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.460]                     {
[10:24:24.460]                       inherits <- base::inherits
[10:24:24.460]                       invokeRestart <- base::invokeRestart
[10:24:24.460]                       is.null <- base::is.null
[10:24:24.460]                       muffled <- FALSE
[10:24:24.460]                       if (inherits(cond, "message")) {
[10:24:24.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:24.460]                         if (muffled) 
[10:24:24.460]                           invokeRestart("muffleMessage")
[10:24:24.460]                       }
[10:24:24.460]                       else if (inherits(cond, "warning")) {
[10:24:24.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:24.460]                         if (muffled) 
[10:24:24.460]                           invokeRestart("muffleWarning")
[10:24:24.460]                       }
[10:24:24.460]                       else if (inherits(cond, "condition")) {
[10:24:24.460]                         if (!is.null(pattern)) {
[10:24:24.460]                           computeRestarts <- base::computeRestarts
[10:24:24.460]                           grepl <- base::grepl
[10:24:24.460]                           restarts <- computeRestarts(cond)
[10:24:24.460]                           for (restart in restarts) {
[10:24:24.460]                             name <- restart$name
[10:24:24.460]                             if (is.null(name)) 
[10:24:24.460]                               next
[10:24:24.460]                             if (!grepl(pattern, name)) 
[10:24:24.460]                               next
[10:24:24.460]                             invokeRestart(restart)
[10:24:24.460]                             muffled <- TRUE
[10:24:24.460]                             break
[10:24:24.460]                           }
[10:24:24.460]                         }
[10:24:24.460]                       }
[10:24:24.460]                       invisible(muffled)
[10:24:24.460]                     }
[10:24:24.460]                     muffleCondition(cond, pattern = "^muffle")
[10:24:24.460]                   }
[10:24:24.460]                 }
[10:24:24.460]                 else {
[10:24:24.460]                   if (TRUE) {
[10:24:24.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.460]                     {
[10:24:24.460]                       inherits <- base::inherits
[10:24:24.460]                       invokeRestart <- base::invokeRestart
[10:24:24.460]                       is.null <- base::is.null
[10:24:24.460]                       muffled <- FALSE
[10:24:24.460]                       if (inherits(cond, "message")) {
[10:24:24.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:24.460]                         if (muffled) 
[10:24:24.460]                           invokeRestart("muffleMessage")
[10:24:24.460]                       }
[10:24:24.460]                       else if (inherits(cond, "warning")) {
[10:24:24.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:24.460]                         if (muffled) 
[10:24:24.460]                           invokeRestart("muffleWarning")
[10:24:24.460]                       }
[10:24:24.460]                       else if (inherits(cond, "condition")) {
[10:24:24.460]                         if (!is.null(pattern)) {
[10:24:24.460]                           computeRestarts <- base::computeRestarts
[10:24:24.460]                           grepl <- base::grepl
[10:24:24.460]                           restarts <- computeRestarts(cond)
[10:24:24.460]                           for (restart in restarts) {
[10:24:24.460]                             name <- restart$name
[10:24:24.460]                             if (is.null(name)) 
[10:24:24.460]                               next
[10:24:24.460]                             if (!grepl(pattern, name)) 
[10:24:24.460]                               next
[10:24:24.460]                             invokeRestart(restart)
[10:24:24.460]                             muffled <- TRUE
[10:24:24.460]                             break
[10:24:24.460]                           }
[10:24:24.460]                         }
[10:24:24.460]                       }
[10:24:24.460]                       invisible(muffled)
[10:24:24.460]                     }
[10:24:24.460]                     muffleCondition(cond, pattern = "^muffle")
[10:24:24.460]                   }
[10:24:24.460]                 }
[10:24:24.460]             }
[10:24:24.460]         }))
[10:24:24.460]     }, error = function(ex) {
[10:24:24.460]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:24.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:24.460]                 ...future.rng), started = ...future.startTime, 
[10:24:24.460]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:24.460]             version = "1.8"), class = "FutureResult")
[10:24:24.460]     }, finally = {
[10:24:24.460]         if (!identical(...future.workdir, getwd())) 
[10:24:24.460]             setwd(...future.workdir)
[10:24:24.460]         {
[10:24:24.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:24.460]                 ...future.oldOptions$nwarnings <- NULL
[10:24:24.460]             }
[10:24:24.460]             base::options(...future.oldOptions)
[10:24:24.460]             if (.Platform$OS.type == "windows") {
[10:24:24.460]                 old_names <- names(...future.oldEnvVars)
[10:24:24.460]                 envs <- base::Sys.getenv()
[10:24:24.460]                 names <- names(envs)
[10:24:24.460]                 common <- intersect(names, old_names)
[10:24:24.460]                 added <- setdiff(names, old_names)
[10:24:24.460]                 removed <- setdiff(old_names, names)
[10:24:24.460]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:24.460]                   envs[common]]
[10:24:24.460]                 NAMES <- toupper(changed)
[10:24:24.460]                 args <- list()
[10:24:24.460]                 for (kk in seq_along(NAMES)) {
[10:24:24.460]                   name <- changed[[kk]]
[10:24:24.460]                   NAME <- NAMES[[kk]]
[10:24:24.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.460]                     next
[10:24:24.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:24.460]                 }
[10:24:24.460]                 NAMES <- toupper(added)
[10:24:24.460]                 for (kk in seq_along(NAMES)) {
[10:24:24.460]                   name <- added[[kk]]
[10:24:24.460]                   NAME <- NAMES[[kk]]
[10:24:24.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.460]                     next
[10:24:24.460]                   args[[name]] <- ""
[10:24:24.460]                 }
[10:24:24.460]                 NAMES <- toupper(removed)
[10:24:24.460]                 for (kk in seq_along(NAMES)) {
[10:24:24.460]                   name <- removed[[kk]]
[10:24:24.460]                   NAME <- NAMES[[kk]]
[10:24:24.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.460]                     next
[10:24:24.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:24.460]                 }
[10:24:24.460]                 if (length(args) > 0) 
[10:24:24.460]                   base::do.call(base::Sys.setenv, args = args)
[10:24:24.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:24.460]             }
[10:24:24.460]             else {
[10:24:24.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:24.460]             }
[10:24:24.460]             {
[10:24:24.460]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:24.460]                   0L) {
[10:24:24.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:24.460]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:24.460]                   base::options(opts)
[10:24:24.460]                 }
[10:24:24.460]                 {
[10:24:24.460]                   {
[10:24:24.460]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:24.460]                     NULL
[10:24:24.460]                   }
[10:24:24.460]                   options(future.plan = NULL)
[10:24:24.460]                   if (is.na(NA_character_)) 
[10:24:24.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:24.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:24.460]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:24.460]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:24.460]                     envir = parent.frame()) 
[10:24:24.460]                   {
[10:24:24.460]                     if (is.function(workers)) 
[10:24:24.460]                       workers <- workers()
[10:24:24.460]                     workers <- structure(as.integer(workers), 
[10:24:24.460]                       class = class(workers))
[10:24:24.460]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:24.460]                       workers >= 1)
[10:24:24.460]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:24.460]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:24.460]                     }
[10:24:24.460]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:24.460]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:24.460]                       envir = envir)
[10:24:24.460]                     if (!future$lazy) 
[10:24:24.460]                       future <- run(future)
[10:24:24.460]                     invisible(future)
[10:24:24.460]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:24.460]                 }
[10:24:24.460]             }
[10:24:24.460]         }
[10:24:24.460]     })
[10:24:24.460]     if (TRUE) {
[10:24:24.460]         base::sink(type = "output", split = FALSE)
[10:24:24.460]         if (TRUE) {
[10:24:24.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:24.460]         }
[10:24:24.460]         else {
[10:24:24.460]             ...future.result["stdout"] <- base::list(NULL)
[10:24:24.460]         }
[10:24:24.460]         base::close(...future.stdout)
[10:24:24.460]         ...future.stdout <- NULL
[10:24:24.460]     }
[10:24:24.460]     ...future.result$conditions <- ...future.conditions
[10:24:24.460]     ...future.result$finished <- base::Sys.time()
[10:24:24.460]     ...future.result
[10:24:24.460] }
[10:24:24.463] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[10:24:24.463] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[10:24:24.464] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[10:24:24.464] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[10:24:24.464] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[10:24:24.464] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:24:24.465] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:24:24.465] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:24.465] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:24.465] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:24.466] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:24.466] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[10:24:24.467] MultisessionFuture started
[10:24:24.467] - Launch lazy future ... done
[10:24:24.467] run() for ‘MultisessionFuture’ ... done
[10:24:24.467] Created future:
[10:24:24.467] MultisessionFuture:
[10:24:24.467] Label: ‘future_sapply-1’
[10:24:24.467] Expression:
[10:24:24.467] {
[10:24:24.467]     do.call(function(...) {
[10:24:24.467]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.467]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.467]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.467]             on.exit(options(oopts), add = TRUE)
[10:24:24.467]         }
[10:24:24.467]         {
[10:24:24.467]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.467]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.467]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.467]             })
[10:24:24.467]         }
[10:24:24.467]     }, args = future.call.arguments)
[10:24:24.467] }
[10:24:24.467] Lazy evaluation: FALSE
[10:24:24.467] Asynchronous evaluation: TRUE
[10:24:24.467] Local evaluation: TRUE
[10:24:24.467] Environment: R_GlobalEnv
[10:24:24.467] Capture standard output: TRUE
[10:24:24.467] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:24.467] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:24.467] Packages: <none>
[10:24:24.467] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:24.467] Resolved: FALSE
[10:24:24.467] Value: <not collected>
[10:24:24.467] Conditions captured: <none>
[10:24:24.467] Early signaling: FALSE
[10:24:24.467] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:24.467] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:24.479] Chunk #1 of 2 ... DONE
[10:24:24.479] Chunk #2 of 2 ...
[10:24:24.479]  - Finding globals in 'X' for chunk #2 ...
[10:24:24.479] getGlobalsAndPackages() ...
[10:24:24.479] Searching for globals...
[10:24:24.479] 
[10:24:24.479] Searching for globals ... DONE
[10:24:24.479] - globals: [0] <none>
[10:24:24.479] getGlobalsAndPackages() ... DONE
[10:24:24.480]    + additional globals found: [n=0] 
[10:24:24.480]    + additional namespaces needed: [n=0] 
[10:24:24.480]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:24.480]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:24.480]  - seeds: <none>
[10:24:24.480]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.480] getGlobalsAndPackages() ...
[10:24:24.480] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.480] Resolving globals: FALSE
[10:24:24.480] Tweak future expression to call with '...' arguments ...
[10:24:24.481] {
[10:24:24.481]     do.call(function(...) {
[10:24:24.481]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.481]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.481]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.481]             on.exit(options(oopts), add = TRUE)
[10:24:24.481]         }
[10:24:24.481]         {
[10:24:24.481]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.481]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.481]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.481]             })
[10:24:24.481]         }
[10:24:24.481]     }, args = future.call.arguments)
[10:24:24.481] }
[10:24:24.481] Tweak future expression to call with '...' arguments ... DONE
[10:24:24.481] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.481] 
[10:24:24.481] getGlobalsAndPackages() ... DONE
[10:24:24.482] run() for ‘Future’ ...
[10:24:24.482] - state: ‘created’
[10:24:24.482] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:24.495] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:24.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:24.496]   - Field: ‘node’
[10:24:24.496]   - Field: ‘label’
[10:24:24.496]   - Field: ‘local’
[10:24:24.496]   - Field: ‘owner’
[10:24:24.496]   - Field: ‘envir’
[10:24:24.496]   - Field: ‘workers’
[10:24:24.496]   - Field: ‘packages’
[10:24:24.496]   - Field: ‘gc’
[10:24:24.496]   - Field: ‘conditions’
[10:24:24.496]   - Field: ‘persistent’
[10:24:24.497]   - Field: ‘expr’
[10:24:24.497]   - Field: ‘uuid’
[10:24:24.497]   - Field: ‘seed’
[10:24:24.497]   - Field: ‘version’
[10:24:24.497]   - Field: ‘result’
[10:24:24.497]   - Field: ‘asynchronous’
[10:24:24.497]   - Field: ‘calls’
[10:24:24.497]   - Field: ‘globals’
[10:24:24.497]   - Field: ‘stdout’
[10:24:24.497]   - Field: ‘earlySignal’
[10:24:24.497]   - Field: ‘lazy’
[10:24:24.498]   - Field: ‘state’
[10:24:24.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:24.498] - Launch lazy future ...
[10:24:24.498] Packages needed by the future expression (n = 0): <none>
[10:24:24.498] Packages needed by future strategies (n = 0): <none>
[10:24:24.499] {
[10:24:24.499]     {
[10:24:24.499]         {
[10:24:24.499]             ...future.startTime <- base::Sys.time()
[10:24:24.499]             {
[10:24:24.499]                 {
[10:24:24.499]                   {
[10:24:24.499]                     {
[10:24:24.499]                       base::local({
[10:24:24.499]                         has_future <- base::requireNamespace("future", 
[10:24:24.499]                           quietly = TRUE)
[10:24:24.499]                         if (has_future) {
[10:24:24.499]                           ns <- base::getNamespace("future")
[10:24:24.499]                           version <- ns[[".package"]][["version"]]
[10:24:24.499]                           if (is.null(version)) 
[10:24:24.499]                             version <- utils::packageVersion("future")
[10:24:24.499]                         }
[10:24:24.499]                         else {
[10:24:24.499]                           version <- NULL
[10:24:24.499]                         }
[10:24:24.499]                         if (!has_future || version < "1.8.0") {
[10:24:24.499]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:24.499]                             "", base::R.version$version.string), 
[10:24:24.499]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:24.499]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:24.499]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:24.499]                               "release", "version")], collapse = " "), 
[10:24:24.499]                             hostname = base::Sys.info()[["nodename"]])
[10:24:24.499]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:24.499]                             info)
[10:24:24.499]                           info <- base::paste(info, collapse = "; ")
[10:24:24.499]                           if (!has_future) {
[10:24:24.499]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:24.499]                               info)
[10:24:24.499]                           }
[10:24:24.499]                           else {
[10:24:24.499]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:24.499]                               info, version)
[10:24:24.499]                           }
[10:24:24.499]                           base::stop(msg)
[10:24:24.499]                         }
[10:24:24.499]                       })
[10:24:24.499]                     }
[10:24:24.499]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:24.499]                     base::options(mc.cores = 1L)
[10:24:24.499]                   }
[10:24:24.499]                   options(future.plan = NULL)
[10:24:24.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:24.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:24.499]                 }
[10:24:24.499]                 ...future.workdir <- getwd()
[10:24:24.499]             }
[10:24:24.499]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:24.499]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:24.499]         }
[10:24:24.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:24.499]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:24.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:24.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:24.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:24.499]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:24.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:24.499]             base::names(...future.oldOptions))
[10:24:24.499]     }
[10:24:24.499]     if (FALSE) {
[10:24:24.499]     }
[10:24:24.499]     else {
[10:24:24.499]         if (TRUE) {
[10:24:24.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:24.499]                 open = "w")
[10:24:24.499]         }
[10:24:24.499]         else {
[10:24:24.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:24.499]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:24.499]         }
[10:24:24.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:24.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:24.499]             base::sink(type = "output", split = FALSE)
[10:24:24.499]             base::close(...future.stdout)
[10:24:24.499]         }, add = TRUE)
[10:24:24.499]     }
[10:24:24.499]     ...future.frame <- base::sys.nframe()
[10:24:24.499]     ...future.conditions <- base::list()
[10:24:24.499]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:24.499]     if (FALSE) {
[10:24:24.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:24.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:24.499]     }
[10:24:24.499]     ...future.result <- base::tryCatch({
[10:24:24.499]         base::withCallingHandlers({
[10:24:24.499]             ...future.value <- base::withVisible(base::local({
[10:24:24.499]                 ...future.makeSendCondition <- base::local({
[10:24:24.499]                   sendCondition <- NULL
[10:24:24.499]                   function(frame = 1L) {
[10:24:24.499]                     if (is.function(sendCondition)) 
[10:24:24.499]                       return(sendCondition)
[10:24:24.499]                     ns <- getNamespace("parallel")
[10:24:24.499]                     if (exists("sendData", mode = "function", 
[10:24:24.499]                       envir = ns)) {
[10:24:24.499]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:24.499]                         envir = ns)
[10:24:24.499]                       envir <- sys.frame(frame)
[10:24:24.499]                       master <- NULL
[10:24:24.499]                       while (!identical(envir, .GlobalEnv) && 
[10:24:24.499]                         !identical(envir, emptyenv())) {
[10:24:24.499]                         if (exists("master", mode = "list", envir = envir, 
[10:24:24.499]                           inherits = FALSE)) {
[10:24:24.499]                           master <- get("master", mode = "list", 
[10:24:24.499]                             envir = envir, inherits = FALSE)
[10:24:24.499]                           if (inherits(master, c("SOCKnode", 
[10:24:24.499]                             "SOCK0node"))) {
[10:24:24.499]                             sendCondition <<- function(cond) {
[10:24:24.499]                               data <- list(type = "VALUE", value = cond, 
[10:24:24.499]                                 success = TRUE)
[10:24:24.499]                               parallel_sendData(master, data)
[10:24:24.499]                             }
[10:24:24.499]                             return(sendCondition)
[10:24:24.499]                           }
[10:24:24.499]                         }
[10:24:24.499]                         frame <- frame + 1L
[10:24:24.499]                         envir <- sys.frame(frame)
[10:24:24.499]                       }
[10:24:24.499]                     }
[10:24:24.499]                     sendCondition <<- function(cond) NULL
[10:24:24.499]                   }
[10:24:24.499]                 })
[10:24:24.499]                 withCallingHandlers({
[10:24:24.499]                   {
[10:24:24.499]                     do.call(function(...) {
[10:24:24.499]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.499]                       if (!identical(...future.globals.maxSize.org, 
[10:24:24.499]                         ...future.globals.maxSize)) {
[10:24:24.499]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.499]                         on.exit(options(oopts), add = TRUE)
[10:24:24.499]                       }
[10:24:24.499]                       {
[10:24:24.499]                         lapply(seq_along(...future.elements_ii), 
[10:24:24.499]                           FUN = function(jj) {
[10:24:24.499]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.499]                             ...future.FUN(...future.X_jj, ...)
[10:24:24.499]                           })
[10:24:24.499]                       }
[10:24:24.499]                     }, args = future.call.arguments)
[10:24:24.499]                   }
[10:24:24.499]                 }, immediateCondition = function(cond) {
[10:24:24.499]                   sendCondition <- ...future.makeSendCondition()
[10:24:24.499]                   sendCondition(cond)
[10:24:24.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.499]                   {
[10:24:24.499]                     inherits <- base::inherits
[10:24:24.499]                     invokeRestart <- base::invokeRestart
[10:24:24.499]                     is.null <- base::is.null
[10:24:24.499]                     muffled <- FALSE
[10:24:24.499]                     if (inherits(cond, "message")) {
[10:24:24.499]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:24.499]                       if (muffled) 
[10:24:24.499]                         invokeRestart("muffleMessage")
[10:24:24.499]                     }
[10:24:24.499]                     else if (inherits(cond, "warning")) {
[10:24:24.499]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:24.499]                       if (muffled) 
[10:24:24.499]                         invokeRestart("muffleWarning")
[10:24:24.499]                     }
[10:24:24.499]                     else if (inherits(cond, "condition")) {
[10:24:24.499]                       if (!is.null(pattern)) {
[10:24:24.499]                         computeRestarts <- base::computeRestarts
[10:24:24.499]                         grepl <- base::grepl
[10:24:24.499]                         restarts <- computeRestarts(cond)
[10:24:24.499]                         for (restart in restarts) {
[10:24:24.499]                           name <- restart$name
[10:24:24.499]                           if (is.null(name)) 
[10:24:24.499]                             next
[10:24:24.499]                           if (!grepl(pattern, name)) 
[10:24:24.499]                             next
[10:24:24.499]                           invokeRestart(restart)
[10:24:24.499]                           muffled <- TRUE
[10:24:24.499]                           break
[10:24:24.499]                         }
[10:24:24.499]                       }
[10:24:24.499]                     }
[10:24:24.499]                     invisible(muffled)
[10:24:24.499]                   }
[10:24:24.499]                   muffleCondition(cond)
[10:24:24.499]                 })
[10:24:24.499]             }))
[10:24:24.499]             future::FutureResult(value = ...future.value$value, 
[10:24:24.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:24.499]                   ...future.rng), globalenv = if (FALSE) 
[10:24:24.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:24.499]                     ...future.globalenv.names))
[10:24:24.499]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:24.499]         }, condition = base::local({
[10:24:24.499]             c <- base::c
[10:24:24.499]             inherits <- base::inherits
[10:24:24.499]             invokeRestart <- base::invokeRestart
[10:24:24.499]             length <- base::length
[10:24:24.499]             list <- base::list
[10:24:24.499]             seq.int <- base::seq.int
[10:24:24.499]             signalCondition <- base::signalCondition
[10:24:24.499]             sys.calls <- base::sys.calls
[10:24:24.499]             `[[` <- base::`[[`
[10:24:24.499]             `+` <- base::`+`
[10:24:24.499]             `<<-` <- base::`<<-`
[10:24:24.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:24.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:24.499]                   3L)]
[10:24:24.499]             }
[10:24:24.499]             function(cond) {
[10:24:24.499]                 is_error <- inherits(cond, "error")
[10:24:24.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:24.499]                   NULL)
[10:24:24.499]                 if (is_error) {
[10:24:24.499]                   sessionInformation <- function() {
[10:24:24.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:24.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:24.499]                       search = base::search(), system = base::Sys.info())
[10:24:24.499]                   }
[10:24:24.499]                   ...future.conditions[[length(...future.conditions) + 
[10:24:24.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:24.499]                     cond$call), session = sessionInformation(), 
[10:24:24.499]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:24.499]                   signalCondition(cond)
[10:24:24.499]                 }
[10:24:24.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:24.499]                 "immediateCondition"))) {
[10:24:24.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:24.499]                   ...future.conditions[[length(...future.conditions) + 
[10:24:24.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:24.499]                   if (TRUE && !signal) {
[10:24:24.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.499]                     {
[10:24:24.499]                       inherits <- base::inherits
[10:24:24.499]                       invokeRestart <- base::invokeRestart
[10:24:24.499]                       is.null <- base::is.null
[10:24:24.499]                       muffled <- FALSE
[10:24:24.499]                       if (inherits(cond, "message")) {
[10:24:24.499]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:24.499]                         if (muffled) 
[10:24:24.499]                           invokeRestart("muffleMessage")
[10:24:24.499]                       }
[10:24:24.499]                       else if (inherits(cond, "warning")) {
[10:24:24.499]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:24.499]                         if (muffled) 
[10:24:24.499]                           invokeRestart("muffleWarning")
[10:24:24.499]                       }
[10:24:24.499]                       else if (inherits(cond, "condition")) {
[10:24:24.499]                         if (!is.null(pattern)) {
[10:24:24.499]                           computeRestarts <- base::computeRestarts
[10:24:24.499]                           grepl <- base::grepl
[10:24:24.499]                           restarts <- computeRestarts(cond)
[10:24:24.499]                           for (restart in restarts) {
[10:24:24.499]                             name <- restart$name
[10:24:24.499]                             if (is.null(name)) 
[10:24:24.499]                               next
[10:24:24.499]                             if (!grepl(pattern, name)) 
[10:24:24.499]                               next
[10:24:24.499]                             invokeRestart(restart)
[10:24:24.499]                             muffled <- TRUE
[10:24:24.499]                             break
[10:24:24.499]                           }
[10:24:24.499]                         }
[10:24:24.499]                       }
[10:24:24.499]                       invisible(muffled)
[10:24:24.499]                     }
[10:24:24.499]                     muffleCondition(cond, pattern = "^muffle")
[10:24:24.499]                   }
[10:24:24.499]                 }
[10:24:24.499]                 else {
[10:24:24.499]                   if (TRUE) {
[10:24:24.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.499]                     {
[10:24:24.499]                       inherits <- base::inherits
[10:24:24.499]                       invokeRestart <- base::invokeRestart
[10:24:24.499]                       is.null <- base::is.null
[10:24:24.499]                       muffled <- FALSE
[10:24:24.499]                       if (inherits(cond, "message")) {
[10:24:24.499]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:24.499]                         if (muffled) 
[10:24:24.499]                           invokeRestart("muffleMessage")
[10:24:24.499]                       }
[10:24:24.499]                       else if (inherits(cond, "warning")) {
[10:24:24.499]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:24.499]                         if (muffled) 
[10:24:24.499]                           invokeRestart("muffleWarning")
[10:24:24.499]                       }
[10:24:24.499]                       else if (inherits(cond, "condition")) {
[10:24:24.499]                         if (!is.null(pattern)) {
[10:24:24.499]                           computeRestarts <- base::computeRestarts
[10:24:24.499]                           grepl <- base::grepl
[10:24:24.499]                           restarts <- computeRestarts(cond)
[10:24:24.499]                           for (restart in restarts) {
[10:24:24.499]                             name <- restart$name
[10:24:24.499]                             if (is.null(name)) 
[10:24:24.499]                               next
[10:24:24.499]                             if (!grepl(pattern, name)) 
[10:24:24.499]                               next
[10:24:24.499]                             invokeRestart(restart)
[10:24:24.499]                             muffled <- TRUE
[10:24:24.499]                             break
[10:24:24.499]                           }
[10:24:24.499]                         }
[10:24:24.499]                       }
[10:24:24.499]                       invisible(muffled)
[10:24:24.499]                     }
[10:24:24.499]                     muffleCondition(cond, pattern = "^muffle")
[10:24:24.499]                   }
[10:24:24.499]                 }
[10:24:24.499]             }
[10:24:24.499]         }))
[10:24:24.499]     }, error = function(ex) {
[10:24:24.499]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:24.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:24.499]                 ...future.rng), started = ...future.startTime, 
[10:24:24.499]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:24.499]             version = "1.8"), class = "FutureResult")
[10:24:24.499]     }, finally = {
[10:24:24.499]         if (!identical(...future.workdir, getwd())) 
[10:24:24.499]             setwd(...future.workdir)
[10:24:24.499]         {
[10:24:24.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:24.499]                 ...future.oldOptions$nwarnings <- NULL
[10:24:24.499]             }
[10:24:24.499]             base::options(...future.oldOptions)
[10:24:24.499]             if (.Platform$OS.type == "windows") {
[10:24:24.499]                 old_names <- names(...future.oldEnvVars)
[10:24:24.499]                 envs <- base::Sys.getenv()
[10:24:24.499]                 names <- names(envs)
[10:24:24.499]                 common <- intersect(names, old_names)
[10:24:24.499]                 added <- setdiff(names, old_names)
[10:24:24.499]                 removed <- setdiff(old_names, names)
[10:24:24.499]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:24.499]                   envs[common]]
[10:24:24.499]                 NAMES <- toupper(changed)
[10:24:24.499]                 args <- list()
[10:24:24.499]                 for (kk in seq_along(NAMES)) {
[10:24:24.499]                   name <- changed[[kk]]
[10:24:24.499]                   NAME <- NAMES[[kk]]
[10:24:24.499]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.499]                     next
[10:24:24.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:24.499]                 }
[10:24:24.499]                 NAMES <- toupper(added)
[10:24:24.499]                 for (kk in seq_along(NAMES)) {
[10:24:24.499]                   name <- added[[kk]]
[10:24:24.499]                   NAME <- NAMES[[kk]]
[10:24:24.499]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.499]                     next
[10:24:24.499]                   args[[name]] <- ""
[10:24:24.499]                 }
[10:24:24.499]                 NAMES <- toupper(removed)
[10:24:24.499]                 for (kk in seq_along(NAMES)) {
[10:24:24.499]                   name <- removed[[kk]]
[10:24:24.499]                   NAME <- NAMES[[kk]]
[10:24:24.499]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.499]                     next
[10:24:24.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:24.499]                 }
[10:24:24.499]                 if (length(args) > 0) 
[10:24:24.499]                   base::do.call(base::Sys.setenv, args = args)
[10:24:24.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:24.499]             }
[10:24:24.499]             else {
[10:24:24.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:24.499]             }
[10:24:24.499]             {
[10:24:24.499]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:24.499]                   0L) {
[10:24:24.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:24.499]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:24.499]                   base::options(opts)
[10:24:24.499]                 }
[10:24:24.499]                 {
[10:24:24.499]                   {
[10:24:24.499]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:24.499]                     NULL
[10:24:24.499]                   }
[10:24:24.499]                   options(future.plan = NULL)
[10:24:24.499]                   if (is.na(NA_character_)) 
[10:24:24.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:24.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:24.499]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:24.499]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:24.499]                     envir = parent.frame()) 
[10:24:24.499]                   {
[10:24:24.499]                     if (is.function(workers)) 
[10:24:24.499]                       workers <- workers()
[10:24:24.499]                     workers <- structure(as.integer(workers), 
[10:24:24.499]                       class = class(workers))
[10:24:24.499]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:24.499]                       workers >= 1)
[10:24:24.499]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:24.499]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:24.499]                     }
[10:24:24.499]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:24.499]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:24.499]                       envir = envir)
[10:24:24.499]                     if (!future$lazy) 
[10:24:24.499]                       future <- run(future)
[10:24:24.499]                     invisible(future)
[10:24:24.499]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:24.499]                 }
[10:24:24.499]             }
[10:24:24.499]         }
[10:24:24.499]     })
[10:24:24.499]     if (TRUE) {
[10:24:24.499]         base::sink(type = "output", split = FALSE)
[10:24:24.499]         if (TRUE) {
[10:24:24.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:24.499]         }
[10:24:24.499]         else {
[10:24:24.499]             ...future.result["stdout"] <- base::list(NULL)
[10:24:24.499]         }
[10:24:24.499]         base::close(...future.stdout)
[10:24:24.499]         ...future.stdout <- NULL
[10:24:24.499]     }
[10:24:24.499]     ...future.result$conditions <- ...future.conditions
[10:24:24.499]     ...future.result$finished <- base::Sys.time()
[10:24:24.499]     ...future.result
[10:24:24.499] }
[10:24:24.501] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[10:24:24.502] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[10:24:24.502] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[10:24:24.502] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[10:24:24.502] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[10:24:24.503] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:24:24.503] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:24:24.503] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:24.503] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:24.503] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:24.504] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:24.504] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[10:24:24.504] MultisessionFuture started
[10:24:24.504] - Launch lazy future ... done
[10:24:24.504] run() for ‘MultisessionFuture’ ... done
[10:24:24.505] Created future:
[10:24:24.505] MultisessionFuture:
[10:24:24.505] Label: ‘future_sapply-2’
[10:24:24.505] Expression:
[10:24:24.505] {
[10:24:24.505]     do.call(function(...) {
[10:24:24.505]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.505]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.505]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.505]             on.exit(options(oopts), add = TRUE)
[10:24:24.505]         }
[10:24:24.505]         {
[10:24:24.505]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.505]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.505]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.505]             })
[10:24:24.505]         }
[10:24:24.505]     }, args = future.call.arguments)
[10:24:24.505] }
[10:24:24.505] Lazy evaluation: FALSE
[10:24:24.505] Asynchronous evaluation: TRUE
[10:24:24.505] Local evaluation: TRUE
[10:24:24.505] Environment: R_GlobalEnv
[10:24:24.505] Capture standard output: TRUE
[10:24:24.505] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:24.505] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:24.505] Packages: <none>
[10:24:24.505] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:24.505] Resolved: FALSE
[10:24:24.505] Value: <not collected>
[10:24:24.505] Conditions captured: <none>
[10:24:24.505] Early signaling: FALSE
[10:24:24.505] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:24.505] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:24.516] Chunk #2 of 2 ... DONE
[10:24:24.516] Launching 2 futures (chunks) ... DONE
[10:24:24.516] Resolving 2 futures (chunks) ...
[10:24:24.516] resolve() on list ...
[10:24:24.517]  recursive: 0
[10:24:24.517]  length: 2
[10:24:24.517] 
[10:24:24.517] receiveMessageFromWorker() for ClusterFuture ...
[10:24:24.517] - Validating connection of MultisessionFuture
[10:24:24.518] - received message: FutureResult
[10:24:24.518] - Received FutureResult
[10:24:24.518] - Erased future from FutureRegistry
[10:24:24.518] result() for ClusterFuture ...
[10:24:24.518] - result already collected: FutureResult
[10:24:24.518] result() for ClusterFuture ... done
[10:24:24.518] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:24.518] Future #1
[10:24:24.518] result() for ClusterFuture ...
[10:24:24.518] - result already collected: FutureResult
[10:24:24.519] result() for ClusterFuture ... done
[10:24:24.519] result() for ClusterFuture ...
[10:24:24.519] - result already collected: FutureResult
[10:24:24.519] result() for ClusterFuture ... done
[10:24:24.519] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:24.519] - nx: 2
[10:24:24.519] - relay: TRUE
[10:24:24.519] - stdout: TRUE
[10:24:24.519] - signal: TRUE
[10:24:24.519] - resignal: FALSE
[10:24:24.519] - force: TRUE
[10:24:24.519] - relayed: [n=2] FALSE, FALSE
[10:24:24.520] - queued futures: [n=2] FALSE, FALSE
[10:24:24.520]  - until=1
[10:24:24.520]  - relaying element #1
[10:24:24.520] result() for ClusterFuture ...
[10:24:24.520] - result already collected: FutureResult
[10:24:24.520] result() for ClusterFuture ... done
[10:24:24.520] result() for ClusterFuture ...
[10:24:24.520] - result already collected: FutureResult
[10:24:24.520] result() for ClusterFuture ... done
[10:24:24.520] result() for ClusterFuture ...
[10:24:24.521] - result already collected: FutureResult
[10:24:24.521] result() for ClusterFuture ... done
[10:24:24.521] result() for ClusterFuture ...
[10:24:24.521] - result already collected: FutureResult
[10:24:24.521] result() for ClusterFuture ... done
[10:24:24.521] - relayed: [n=2] TRUE, FALSE
[10:24:24.521] - queued futures: [n=2] TRUE, FALSE
[10:24:24.521] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:24.521]  length: 1 (resolved future 1)
[10:24:24.551] receiveMessageFromWorker() for ClusterFuture ...
[10:24:24.551] - Validating connection of MultisessionFuture
[10:24:24.551] - received message: FutureResult
[10:24:24.551] - Received FutureResult
[10:24:24.551] - Erased future from FutureRegistry
[10:24:24.551] result() for ClusterFuture ...
[10:24:24.551] - result already collected: FutureResult
[10:24:24.551] result() for ClusterFuture ... done
[10:24:24.552] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:24.552] Future #2
[10:24:24.552] result() for ClusterFuture ...
[10:24:24.552] - result already collected: FutureResult
[10:24:24.552] result() for ClusterFuture ... done
[10:24:24.552] result() for ClusterFuture ...
[10:24:24.552] - result already collected: FutureResult
[10:24:24.552] result() for ClusterFuture ... done
[10:24:24.552] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:24.552] - nx: 2
[10:24:24.553] - relay: TRUE
[10:24:24.553] - stdout: TRUE
[10:24:24.553] - signal: TRUE
[10:24:24.553] - resignal: FALSE
[10:24:24.553] - force: TRUE
[10:24:24.553] - relayed: [n=2] TRUE, FALSE
[10:24:24.553] - queued futures: [n=2] TRUE, FALSE
[10:24:24.553]  - until=2
[10:24:24.553]  - relaying element #2
[10:24:24.553] result() for ClusterFuture ...
[10:24:24.553] - result already collected: FutureResult
[10:24:24.554] result() for ClusterFuture ... done
[10:24:24.554] result() for ClusterFuture ...
[10:24:24.554] - result already collected: FutureResult
[10:24:24.554] result() for ClusterFuture ... done
[10:24:24.554] result() for ClusterFuture ...
[10:24:24.554] - result already collected: FutureResult
[10:24:24.554] result() for ClusterFuture ... done
[10:24:24.554] result() for ClusterFuture ...
[10:24:24.554] - result already collected: FutureResult
[10:24:24.554] result() for ClusterFuture ... done
[10:24:24.554] - relayed: [n=2] TRUE, TRUE
[10:24:24.555] - queued futures: [n=2] TRUE, TRUE
[10:24:24.555] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:24.555]  length: 0 (resolved future 2)
[10:24:24.555] Relaying remaining futures
[10:24:24.555] signalConditionsASAP(NULL, pos=0) ...
[10:24:24.555] - nx: 2
[10:24:24.555] - relay: TRUE
[10:24:24.555] - stdout: TRUE
[10:24:24.555] - signal: TRUE
[10:24:24.555] - resignal: FALSE
[10:24:24.555] - force: TRUE
[10:24:24.555] - relayed: [n=2] TRUE, TRUE
[10:24:24.556] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:24.556] - relayed: [n=2] TRUE, TRUE
[10:24:24.556] - queued futures: [n=2] TRUE, TRUE
[10:24:24.556] signalConditionsASAP(NULL, pos=0) ... done
[10:24:24.556] resolve() on list ... DONE
[10:24:24.556] result() for ClusterFuture ...
[10:24:24.556] - result already collected: FutureResult
[10:24:24.556] result() for ClusterFuture ... done
[10:24:24.556] result() for ClusterFuture ...
[10:24:24.556] - result already collected: FutureResult
[10:24:24.556] result() for ClusterFuture ... done
[10:24:24.557] result() for ClusterFuture ...
[10:24:24.557] - result already collected: FutureResult
[10:24:24.557] result() for ClusterFuture ... done
[10:24:24.557] result() for ClusterFuture ...
[10:24:24.557] - result already collected: FutureResult
[10:24:24.557] result() for ClusterFuture ... done
[10:24:24.557]  - Number of value chunks collected: 2
[10:24:24.557] Resolving 2 futures (chunks) ... DONE
[10:24:24.557] Reducing values from 2 chunks ...
[10:24:24.557]  - Number of values collected after concatenation: 4
[10:24:24.558]  - Number of values expected: 4
[10:24:24.558] Reducing values from 2 chunks ... DONE
[10:24:24.558] future_lapply() ... DONE
[10:24:24.558] future_lapply() ...
[10:24:24.563] Number of chunks: 2
[10:24:24.564] getGlobalsAndPackagesXApply() ...
[10:24:24.564]  - future.globals: TRUE
[10:24:24.564] getGlobalsAndPackages() ...
[10:24:24.564] Searching for globals...
[10:24:24.567] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[10:24:24.568] Searching for globals ... DONE
[10:24:24.570] Resolving globals: FALSE
[10:24:24.571] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[10:24:24.572] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:24.572] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:24.572] - packages: [1] ‘future.apply’
[10:24:24.572] getGlobalsAndPackages() ... DONE
[10:24:24.572]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:24.572]  - needed namespaces: [n=1] ‘future.apply’
[10:24:24.572] Finding globals ... DONE
[10:24:24.573]  - use_args: TRUE
[10:24:24.573]  - Getting '...' globals ...
[10:24:24.573] resolve() on list ...
[10:24:24.573]  recursive: 0
[10:24:24.573]  length: 1
[10:24:24.573]  elements: ‘...’
[10:24:24.573]  length: 0 (resolved future 1)
[10:24:24.573] resolve() on list ... DONE
[10:24:24.574]    - '...' content: [n=1] ‘y’
[10:24:24.574] List of 1
[10:24:24.574]  $ ...:List of 1
[10:24:24.574]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:24.574]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:24.574]  - attr(*, "where")=List of 1
[10:24:24.574]   ..$ ...:<environment: 0x55b93ebe3248> 
[10:24:24.574]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:24.574]  - attr(*, "resolved")= logi TRUE
[10:24:24.574]  - attr(*, "total_size")= num NA
[10:24:24.577]  - Getting '...' globals ... DONE
[10:24:24.577] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:24.577] List of 8
[10:24:24.577]  $ ...future.FUN:function (x, ...)  
[10:24:24.577]  $ x_FUN        :function (x, y)  
[10:24:24.577]  $ times        : int 15
[10:24:24.577]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:24.577]  $ stop_if_not  :function (...)  
[10:24:24.577]  $ dim          : int [1:2] 3 5
[10:24:24.577]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:24.577]  $ ...          :List of 1
[10:24:24.577]   ..$ y: num [1:5] 2 4 6 8 10
[10:24:24.577]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:24.577]  - attr(*, "where")=List of 8
[10:24:24.577]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:24.577]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:24.577]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:24.577]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:24.577]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:24.577]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:24.577]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:24.577]   ..$ ...          :<environment: 0x55b93ebe3248> 
[10:24:24.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:24.577]  - attr(*, "resolved")= logi FALSE
[10:24:24.577]  - attr(*, "total_size")= num 98600
[10:24:24.583] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:24.583] getGlobalsAndPackagesXApply() ... DONE
[10:24:24.583] Number of futures (= number of chunks): 2
[10:24:24.583] Launching 2 futures (chunks) ...
[10:24:24.584] Chunk #1 of 2 ...
[10:24:24.584]  - Finding globals in 'X' for chunk #1 ...
[10:24:24.584] getGlobalsAndPackages() ...
[10:24:24.584] Searching for globals...
[10:24:24.584] 
[10:24:24.584] Searching for globals ... DONE
[10:24:24.584] - globals: [0] <none>
[10:24:24.584] getGlobalsAndPackages() ... DONE
[10:24:24.584]    + additional globals found: [n=0] 
[10:24:24.585]    + additional namespaces needed: [n=0] 
[10:24:24.585]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:24.585]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:24.585]  - seeds: <none>
[10:24:24.585]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.585] getGlobalsAndPackages() ...
[10:24:24.585] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.585] Resolving globals: FALSE
[10:24:24.585] Tweak future expression to call with '...' arguments ...
[10:24:24.585] {
[10:24:24.585]     do.call(function(...) {
[10:24:24.585]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.585]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.585]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.585]             on.exit(options(oopts), add = TRUE)
[10:24:24.585]         }
[10:24:24.585]         {
[10:24:24.585]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.585]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.585]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.585]             })
[10:24:24.585]         }
[10:24:24.585]     }, args = future.call.arguments)
[10:24:24.585] }
[10:24:24.586] Tweak future expression to call with '...' arguments ... DONE
[10:24:24.586] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.586] - packages: [1] ‘future.apply’
[10:24:24.587] getGlobalsAndPackages() ... DONE
[10:24:24.587] run() for ‘Future’ ...
[10:24:24.587] - state: ‘created’
[10:24:24.587] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:24.601] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:24.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:24.601]   - Field: ‘node’
[10:24:24.602]   - Field: ‘label’
[10:24:24.602]   - Field: ‘local’
[10:24:24.602]   - Field: ‘owner’
[10:24:24.602]   - Field: ‘envir’
[10:24:24.602]   - Field: ‘workers’
[10:24:24.602]   - Field: ‘packages’
[10:24:24.602]   - Field: ‘gc’
[10:24:24.602]   - Field: ‘conditions’
[10:24:24.602]   - Field: ‘persistent’
[10:24:24.602]   - Field: ‘expr’
[10:24:24.602]   - Field: ‘uuid’
[10:24:24.603]   - Field: ‘seed’
[10:24:24.603]   - Field: ‘version’
[10:24:24.603]   - Field: ‘result’
[10:24:24.603]   - Field: ‘asynchronous’
[10:24:24.603]   - Field: ‘calls’
[10:24:24.603]   - Field: ‘globals’
[10:24:24.603]   - Field: ‘stdout’
[10:24:24.603]   - Field: ‘earlySignal’
[10:24:24.603]   - Field: ‘lazy’
[10:24:24.603]   - Field: ‘state’
[10:24:24.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:24.604] - Launch lazy future ...
[10:24:24.604] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:24.604] Packages needed by future strategies (n = 0): <none>
[10:24:24.605] {
[10:24:24.605]     {
[10:24:24.605]         {
[10:24:24.605]             ...future.startTime <- base::Sys.time()
[10:24:24.605]             {
[10:24:24.605]                 {
[10:24:24.605]                   {
[10:24:24.605]                     {
[10:24:24.605]                       {
[10:24:24.605]                         base::local({
[10:24:24.605]                           has_future <- base::requireNamespace("future", 
[10:24:24.605]                             quietly = TRUE)
[10:24:24.605]                           if (has_future) {
[10:24:24.605]                             ns <- base::getNamespace("future")
[10:24:24.605]                             version <- ns[[".package"]][["version"]]
[10:24:24.605]                             if (is.null(version)) 
[10:24:24.605]                               version <- utils::packageVersion("future")
[10:24:24.605]                           }
[10:24:24.605]                           else {
[10:24:24.605]                             version <- NULL
[10:24:24.605]                           }
[10:24:24.605]                           if (!has_future || version < "1.8.0") {
[10:24:24.605]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:24.605]                               "", base::R.version$version.string), 
[10:24:24.605]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:24.605]                                 base::R.version$platform, 8 * 
[10:24:24.605]                                   base::.Machine$sizeof.pointer), 
[10:24:24.605]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:24.605]                                 "release", "version")], collapse = " "), 
[10:24:24.605]                               hostname = base::Sys.info()[["nodename"]])
[10:24:24.605]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:24.605]                               info)
[10:24:24.605]                             info <- base::paste(info, collapse = "; ")
[10:24:24.605]                             if (!has_future) {
[10:24:24.605]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:24.605]                                 info)
[10:24:24.605]                             }
[10:24:24.605]                             else {
[10:24:24.605]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:24.605]                                 info, version)
[10:24:24.605]                             }
[10:24:24.605]                             base::stop(msg)
[10:24:24.605]                           }
[10:24:24.605]                         })
[10:24:24.605]                       }
[10:24:24.605]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:24.605]                       base::options(mc.cores = 1L)
[10:24:24.605]                     }
[10:24:24.605]                     base::local({
[10:24:24.605]                       for (pkg in "future.apply") {
[10:24:24.605]                         base::loadNamespace(pkg)
[10:24:24.605]                         base::library(pkg, character.only = TRUE)
[10:24:24.605]                       }
[10:24:24.605]                     })
[10:24:24.605]                   }
[10:24:24.605]                   options(future.plan = NULL)
[10:24:24.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:24.605]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:24.605]                 }
[10:24:24.605]                 ...future.workdir <- getwd()
[10:24:24.605]             }
[10:24:24.605]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:24.605]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:24.605]         }
[10:24:24.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:24.605]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:24.605]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:24.605]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:24.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:24.605]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:24.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:24.605]             base::names(...future.oldOptions))
[10:24:24.605]     }
[10:24:24.605]     if (FALSE) {
[10:24:24.605]     }
[10:24:24.605]     else {
[10:24:24.605]         if (TRUE) {
[10:24:24.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:24.605]                 open = "w")
[10:24:24.605]         }
[10:24:24.605]         else {
[10:24:24.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:24.605]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:24.605]         }
[10:24:24.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:24.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:24.605]             base::sink(type = "output", split = FALSE)
[10:24:24.605]             base::close(...future.stdout)
[10:24:24.605]         }, add = TRUE)
[10:24:24.605]     }
[10:24:24.605]     ...future.frame <- base::sys.nframe()
[10:24:24.605]     ...future.conditions <- base::list()
[10:24:24.605]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:24.605]     if (FALSE) {
[10:24:24.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:24.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:24.605]     }
[10:24:24.605]     ...future.result <- base::tryCatch({
[10:24:24.605]         base::withCallingHandlers({
[10:24:24.605]             ...future.value <- base::withVisible(base::local({
[10:24:24.605]                 ...future.makeSendCondition <- base::local({
[10:24:24.605]                   sendCondition <- NULL
[10:24:24.605]                   function(frame = 1L) {
[10:24:24.605]                     if (is.function(sendCondition)) 
[10:24:24.605]                       return(sendCondition)
[10:24:24.605]                     ns <- getNamespace("parallel")
[10:24:24.605]                     if (exists("sendData", mode = "function", 
[10:24:24.605]                       envir = ns)) {
[10:24:24.605]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:24.605]                         envir = ns)
[10:24:24.605]                       envir <- sys.frame(frame)
[10:24:24.605]                       master <- NULL
[10:24:24.605]                       while (!identical(envir, .GlobalEnv) && 
[10:24:24.605]                         !identical(envir, emptyenv())) {
[10:24:24.605]                         if (exists("master", mode = "list", envir = envir, 
[10:24:24.605]                           inherits = FALSE)) {
[10:24:24.605]                           master <- get("master", mode = "list", 
[10:24:24.605]                             envir = envir, inherits = FALSE)
[10:24:24.605]                           if (inherits(master, c("SOCKnode", 
[10:24:24.605]                             "SOCK0node"))) {
[10:24:24.605]                             sendCondition <<- function(cond) {
[10:24:24.605]                               data <- list(type = "VALUE", value = cond, 
[10:24:24.605]                                 success = TRUE)
[10:24:24.605]                               parallel_sendData(master, data)
[10:24:24.605]                             }
[10:24:24.605]                             return(sendCondition)
[10:24:24.605]                           }
[10:24:24.605]                         }
[10:24:24.605]                         frame <- frame + 1L
[10:24:24.605]                         envir <- sys.frame(frame)
[10:24:24.605]                       }
[10:24:24.605]                     }
[10:24:24.605]                     sendCondition <<- function(cond) NULL
[10:24:24.605]                   }
[10:24:24.605]                 })
[10:24:24.605]                 withCallingHandlers({
[10:24:24.605]                   {
[10:24:24.605]                     do.call(function(...) {
[10:24:24.605]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.605]                       if (!identical(...future.globals.maxSize.org, 
[10:24:24.605]                         ...future.globals.maxSize)) {
[10:24:24.605]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.605]                         on.exit(options(oopts), add = TRUE)
[10:24:24.605]                       }
[10:24:24.605]                       {
[10:24:24.605]                         lapply(seq_along(...future.elements_ii), 
[10:24:24.605]                           FUN = function(jj) {
[10:24:24.605]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.605]                             ...future.FUN(...future.X_jj, ...)
[10:24:24.605]                           })
[10:24:24.605]                       }
[10:24:24.605]                     }, args = future.call.arguments)
[10:24:24.605]                   }
[10:24:24.605]                 }, immediateCondition = function(cond) {
[10:24:24.605]                   sendCondition <- ...future.makeSendCondition()
[10:24:24.605]                   sendCondition(cond)
[10:24:24.605]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.605]                   {
[10:24:24.605]                     inherits <- base::inherits
[10:24:24.605]                     invokeRestart <- base::invokeRestart
[10:24:24.605]                     is.null <- base::is.null
[10:24:24.605]                     muffled <- FALSE
[10:24:24.605]                     if (inherits(cond, "message")) {
[10:24:24.605]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:24.605]                       if (muffled) 
[10:24:24.605]                         invokeRestart("muffleMessage")
[10:24:24.605]                     }
[10:24:24.605]                     else if (inherits(cond, "warning")) {
[10:24:24.605]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:24.605]                       if (muffled) 
[10:24:24.605]                         invokeRestart("muffleWarning")
[10:24:24.605]                     }
[10:24:24.605]                     else if (inherits(cond, "condition")) {
[10:24:24.605]                       if (!is.null(pattern)) {
[10:24:24.605]                         computeRestarts <- base::computeRestarts
[10:24:24.605]                         grepl <- base::grepl
[10:24:24.605]                         restarts <- computeRestarts(cond)
[10:24:24.605]                         for (restart in restarts) {
[10:24:24.605]                           name <- restart$name
[10:24:24.605]                           if (is.null(name)) 
[10:24:24.605]                             next
[10:24:24.605]                           if (!grepl(pattern, name)) 
[10:24:24.605]                             next
[10:24:24.605]                           invokeRestart(restart)
[10:24:24.605]                           muffled <- TRUE
[10:24:24.605]                           break
[10:24:24.605]                         }
[10:24:24.605]                       }
[10:24:24.605]                     }
[10:24:24.605]                     invisible(muffled)
[10:24:24.605]                   }
[10:24:24.605]                   muffleCondition(cond)
[10:24:24.605]                 })
[10:24:24.605]             }))
[10:24:24.605]             future::FutureResult(value = ...future.value$value, 
[10:24:24.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:24.605]                   ...future.rng), globalenv = if (FALSE) 
[10:24:24.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:24.605]                     ...future.globalenv.names))
[10:24:24.605]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:24.605]         }, condition = base::local({
[10:24:24.605]             c <- base::c
[10:24:24.605]             inherits <- base::inherits
[10:24:24.605]             invokeRestart <- base::invokeRestart
[10:24:24.605]             length <- base::length
[10:24:24.605]             list <- base::list
[10:24:24.605]             seq.int <- base::seq.int
[10:24:24.605]             signalCondition <- base::signalCondition
[10:24:24.605]             sys.calls <- base::sys.calls
[10:24:24.605]             `[[` <- base::`[[`
[10:24:24.605]             `+` <- base::`+`
[10:24:24.605]             `<<-` <- base::`<<-`
[10:24:24.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:24.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:24.605]                   3L)]
[10:24:24.605]             }
[10:24:24.605]             function(cond) {
[10:24:24.605]                 is_error <- inherits(cond, "error")
[10:24:24.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:24.605]                   NULL)
[10:24:24.605]                 if (is_error) {
[10:24:24.605]                   sessionInformation <- function() {
[10:24:24.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:24.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:24.605]                       search = base::search(), system = base::Sys.info())
[10:24:24.605]                   }
[10:24:24.605]                   ...future.conditions[[length(...future.conditions) + 
[10:24:24.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:24.605]                     cond$call), session = sessionInformation(), 
[10:24:24.605]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:24.605]                   signalCondition(cond)
[10:24:24.605]                 }
[10:24:24.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:24.605]                 "immediateCondition"))) {
[10:24:24.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:24.605]                   ...future.conditions[[length(...future.conditions) + 
[10:24:24.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:24.605]                   if (TRUE && !signal) {
[10:24:24.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.605]                     {
[10:24:24.605]                       inherits <- base::inherits
[10:24:24.605]                       invokeRestart <- base::invokeRestart
[10:24:24.605]                       is.null <- base::is.null
[10:24:24.605]                       muffled <- FALSE
[10:24:24.605]                       if (inherits(cond, "message")) {
[10:24:24.605]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:24.605]                         if (muffled) 
[10:24:24.605]                           invokeRestart("muffleMessage")
[10:24:24.605]                       }
[10:24:24.605]                       else if (inherits(cond, "warning")) {
[10:24:24.605]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:24.605]                         if (muffled) 
[10:24:24.605]                           invokeRestart("muffleWarning")
[10:24:24.605]                       }
[10:24:24.605]                       else if (inherits(cond, "condition")) {
[10:24:24.605]                         if (!is.null(pattern)) {
[10:24:24.605]                           computeRestarts <- base::computeRestarts
[10:24:24.605]                           grepl <- base::grepl
[10:24:24.605]                           restarts <- computeRestarts(cond)
[10:24:24.605]                           for (restart in restarts) {
[10:24:24.605]                             name <- restart$name
[10:24:24.605]                             if (is.null(name)) 
[10:24:24.605]                               next
[10:24:24.605]                             if (!grepl(pattern, name)) 
[10:24:24.605]                               next
[10:24:24.605]                             invokeRestart(restart)
[10:24:24.605]                             muffled <- TRUE
[10:24:24.605]                             break
[10:24:24.605]                           }
[10:24:24.605]                         }
[10:24:24.605]                       }
[10:24:24.605]                       invisible(muffled)
[10:24:24.605]                     }
[10:24:24.605]                     muffleCondition(cond, pattern = "^muffle")
[10:24:24.605]                   }
[10:24:24.605]                 }
[10:24:24.605]                 else {
[10:24:24.605]                   if (TRUE) {
[10:24:24.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.605]                     {
[10:24:24.605]                       inherits <- base::inherits
[10:24:24.605]                       invokeRestart <- base::invokeRestart
[10:24:24.605]                       is.null <- base::is.null
[10:24:24.605]                       muffled <- FALSE
[10:24:24.605]                       if (inherits(cond, "message")) {
[10:24:24.605]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:24.605]                         if (muffled) 
[10:24:24.605]                           invokeRestart("muffleMessage")
[10:24:24.605]                       }
[10:24:24.605]                       else if (inherits(cond, "warning")) {
[10:24:24.605]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:24.605]                         if (muffled) 
[10:24:24.605]                           invokeRestart("muffleWarning")
[10:24:24.605]                       }
[10:24:24.605]                       else if (inherits(cond, "condition")) {
[10:24:24.605]                         if (!is.null(pattern)) {
[10:24:24.605]                           computeRestarts <- base::computeRestarts
[10:24:24.605]                           grepl <- base::grepl
[10:24:24.605]                           restarts <- computeRestarts(cond)
[10:24:24.605]                           for (restart in restarts) {
[10:24:24.605]                             name <- restart$name
[10:24:24.605]                             if (is.null(name)) 
[10:24:24.605]                               next
[10:24:24.605]                             if (!grepl(pattern, name)) 
[10:24:24.605]                               next
[10:24:24.605]                             invokeRestart(restart)
[10:24:24.605]                             muffled <- TRUE
[10:24:24.605]                             break
[10:24:24.605]                           }
[10:24:24.605]                         }
[10:24:24.605]                       }
[10:24:24.605]                       invisible(muffled)
[10:24:24.605]                     }
[10:24:24.605]                     muffleCondition(cond, pattern = "^muffle")
[10:24:24.605]                   }
[10:24:24.605]                 }
[10:24:24.605]             }
[10:24:24.605]         }))
[10:24:24.605]     }, error = function(ex) {
[10:24:24.605]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:24.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:24.605]                 ...future.rng), started = ...future.startTime, 
[10:24:24.605]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:24.605]             version = "1.8"), class = "FutureResult")
[10:24:24.605]     }, finally = {
[10:24:24.605]         if (!identical(...future.workdir, getwd())) 
[10:24:24.605]             setwd(...future.workdir)
[10:24:24.605]         {
[10:24:24.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:24.605]                 ...future.oldOptions$nwarnings <- NULL
[10:24:24.605]             }
[10:24:24.605]             base::options(...future.oldOptions)
[10:24:24.605]             if (.Platform$OS.type == "windows") {
[10:24:24.605]                 old_names <- names(...future.oldEnvVars)
[10:24:24.605]                 envs <- base::Sys.getenv()
[10:24:24.605]                 names <- names(envs)
[10:24:24.605]                 common <- intersect(names, old_names)
[10:24:24.605]                 added <- setdiff(names, old_names)
[10:24:24.605]                 removed <- setdiff(old_names, names)
[10:24:24.605]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:24.605]                   envs[common]]
[10:24:24.605]                 NAMES <- toupper(changed)
[10:24:24.605]                 args <- list()
[10:24:24.605]                 for (kk in seq_along(NAMES)) {
[10:24:24.605]                   name <- changed[[kk]]
[10:24:24.605]                   NAME <- NAMES[[kk]]
[10:24:24.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.605]                     next
[10:24:24.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:24.605]                 }
[10:24:24.605]                 NAMES <- toupper(added)
[10:24:24.605]                 for (kk in seq_along(NAMES)) {
[10:24:24.605]                   name <- added[[kk]]
[10:24:24.605]                   NAME <- NAMES[[kk]]
[10:24:24.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.605]                     next
[10:24:24.605]                   args[[name]] <- ""
[10:24:24.605]                 }
[10:24:24.605]                 NAMES <- toupper(removed)
[10:24:24.605]                 for (kk in seq_along(NAMES)) {
[10:24:24.605]                   name <- removed[[kk]]
[10:24:24.605]                   NAME <- NAMES[[kk]]
[10:24:24.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.605]                     next
[10:24:24.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:24.605]                 }
[10:24:24.605]                 if (length(args) > 0) 
[10:24:24.605]                   base::do.call(base::Sys.setenv, args = args)
[10:24:24.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:24.605]             }
[10:24:24.605]             else {
[10:24:24.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:24.605]             }
[10:24:24.605]             {
[10:24:24.605]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:24.605]                   0L) {
[10:24:24.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:24.605]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:24.605]                   base::options(opts)
[10:24:24.605]                 }
[10:24:24.605]                 {
[10:24:24.605]                   {
[10:24:24.605]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:24.605]                     NULL
[10:24:24.605]                   }
[10:24:24.605]                   options(future.plan = NULL)
[10:24:24.605]                   if (is.na(NA_character_)) 
[10:24:24.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:24.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:24.605]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:24.605]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:24.605]                     envir = parent.frame()) 
[10:24:24.605]                   {
[10:24:24.605]                     if (is.function(workers)) 
[10:24:24.605]                       workers <- workers()
[10:24:24.605]                     workers <- structure(as.integer(workers), 
[10:24:24.605]                       class = class(workers))
[10:24:24.605]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:24.605]                       workers >= 1)
[10:24:24.605]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:24.605]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:24.605]                     }
[10:24:24.605]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:24.605]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:24.605]                       envir = envir)
[10:24:24.605]                     if (!future$lazy) 
[10:24:24.605]                       future <- run(future)
[10:24:24.605]                     invisible(future)
[10:24:24.605]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:24.605]                 }
[10:24:24.605]             }
[10:24:24.605]         }
[10:24:24.605]     })
[10:24:24.605]     if (TRUE) {
[10:24:24.605]         base::sink(type = "output", split = FALSE)
[10:24:24.605]         if (TRUE) {
[10:24:24.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:24.605]         }
[10:24:24.605]         else {
[10:24:24.605]             ...future.result["stdout"] <- base::list(NULL)
[10:24:24.605]         }
[10:24:24.605]         base::close(...future.stdout)
[10:24:24.605]         ...future.stdout <- NULL
[10:24:24.605]     }
[10:24:24.605]     ...future.result$conditions <- ...future.conditions
[10:24:24.605]     ...future.result$finished <- base::Sys.time()
[10:24:24.605]     ...future.result
[10:24:24.605] }
[10:24:24.607] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[10:24:24.608] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:24.650] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:24.650] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[10:24:24.650] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[10:24:24.651] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:24.651] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:24.651] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:24.694] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:24.694] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:24.738] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:24.738] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[10:24:24.738] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[10:24:24.738] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:24:24.739] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:24:24.739] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[10:24:24.739] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[10:24:24.739] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:24:24.740] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:24:24.740] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:24.740] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:24.740] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:24.741] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:24.741] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[10:24:24.742] MultisessionFuture started
[10:24:24.742] - Launch lazy future ... done
[10:24:24.742] run() for ‘MultisessionFuture’ ... done
[10:24:24.742] Created future:
[10:24:24.742] MultisessionFuture:
[10:24:24.742] Label: ‘future_vapply-1’
[10:24:24.742] Expression:
[10:24:24.742] {
[10:24:24.742]     do.call(function(...) {
[10:24:24.742]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.742]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.742]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.742]             on.exit(options(oopts), add = TRUE)
[10:24:24.742]         }
[10:24:24.742]         {
[10:24:24.742]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.742]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.742]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.742]             })
[10:24:24.742]         }
[10:24:24.742]     }, args = future.call.arguments)
[10:24:24.742] }
[10:24:24.742] Lazy evaluation: FALSE
[10:24:24.742] Asynchronous evaluation: TRUE
[10:24:24.742] Local evaluation: TRUE
[10:24:24.742] Environment: R_GlobalEnv
[10:24:24.742] Capture standard output: TRUE
[10:24:24.742] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:24.742] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:24.742] Packages: 1 packages (‘future.apply’)
[10:24:24.742] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:24.742] Resolved: FALSE
[10:24:24.742] Value: <not collected>
[10:24:24.742] Conditions captured: <none>
[10:24:24.742] Early signaling: FALSE
[10:24:24.742] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:24.742] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:24.754] Chunk #1 of 2 ... DONE
[10:24:24.754] Chunk #2 of 2 ...
[10:24:24.754]  - Finding globals in 'X' for chunk #2 ...
[10:24:24.754] getGlobalsAndPackages() ...
[10:24:24.754] Searching for globals...
[10:24:24.754] 
[10:24:24.755] Searching for globals ... DONE
[10:24:24.755] - globals: [0] <none>
[10:24:24.755] getGlobalsAndPackages() ... DONE
[10:24:24.755]    + additional globals found: [n=0] 
[10:24:24.755]    + additional namespaces needed: [n=0] 
[10:24:24.755]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:24.755]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:24.755]  - seeds: <none>
[10:24:24.755]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.755] getGlobalsAndPackages() ...
[10:24:24.756] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.756] Resolving globals: FALSE
[10:24:24.756] Tweak future expression to call with '...' arguments ...
[10:24:24.756] {
[10:24:24.756]     do.call(function(...) {
[10:24:24.756]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.756]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.756]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.756]             on.exit(options(oopts), add = TRUE)
[10:24:24.756]         }
[10:24:24.756]         {
[10:24:24.756]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.756]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.756]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.756]             })
[10:24:24.756]         }
[10:24:24.756]     }, args = future.call.arguments)
[10:24:24.756] }
[10:24:24.756] Tweak future expression to call with '...' arguments ... DONE
[10:24:24.757] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.757] - packages: [1] ‘future.apply’
[10:24:24.757] getGlobalsAndPackages() ... DONE
[10:24:24.757] run() for ‘Future’ ...
[10:24:24.757] - state: ‘created’
[10:24:24.757] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:24.771] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:24.772] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:24.772]   - Field: ‘node’
[10:24:24.772]   - Field: ‘label’
[10:24:24.772]   - Field: ‘local’
[10:24:24.772]   - Field: ‘owner’
[10:24:24.772]   - Field: ‘envir’
[10:24:24.772]   - Field: ‘workers’
[10:24:24.772]   - Field: ‘packages’
[10:24:24.772]   - Field: ‘gc’
[10:24:24.772]   - Field: ‘conditions’
[10:24:24.772]   - Field: ‘persistent’
[10:24:24.773]   - Field: ‘expr’
[10:24:24.773]   - Field: ‘uuid’
[10:24:24.773]   - Field: ‘seed’
[10:24:24.773]   - Field: ‘version’
[10:24:24.773]   - Field: ‘result’
[10:24:24.773]   - Field: ‘asynchronous’
[10:24:24.773]   - Field: ‘calls’
[10:24:24.773]   - Field: ‘globals’
[10:24:24.773]   - Field: ‘stdout’
[10:24:24.773]   - Field: ‘earlySignal’
[10:24:24.774]   - Field: ‘lazy’
[10:24:24.774]   - Field: ‘state’
[10:24:24.774] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:24.774] - Launch lazy future ...
[10:24:24.774] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:24.774] Packages needed by future strategies (n = 0): <none>
[10:24:24.775] {
[10:24:24.775]     {
[10:24:24.775]         {
[10:24:24.775]             ...future.startTime <- base::Sys.time()
[10:24:24.775]             {
[10:24:24.775]                 {
[10:24:24.775]                   {
[10:24:24.775]                     {
[10:24:24.775]                       {
[10:24:24.775]                         base::local({
[10:24:24.775]                           has_future <- base::requireNamespace("future", 
[10:24:24.775]                             quietly = TRUE)
[10:24:24.775]                           if (has_future) {
[10:24:24.775]                             ns <- base::getNamespace("future")
[10:24:24.775]                             version <- ns[[".package"]][["version"]]
[10:24:24.775]                             if (is.null(version)) 
[10:24:24.775]                               version <- utils::packageVersion("future")
[10:24:24.775]                           }
[10:24:24.775]                           else {
[10:24:24.775]                             version <- NULL
[10:24:24.775]                           }
[10:24:24.775]                           if (!has_future || version < "1.8.0") {
[10:24:24.775]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:24.775]                               "", base::R.version$version.string), 
[10:24:24.775]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:24.775]                                 base::R.version$platform, 8 * 
[10:24:24.775]                                   base::.Machine$sizeof.pointer), 
[10:24:24.775]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:24.775]                                 "release", "version")], collapse = " "), 
[10:24:24.775]                               hostname = base::Sys.info()[["nodename"]])
[10:24:24.775]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:24.775]                               info)
[10:24:24.775]                             info <- base::paste(info, collapse = "; ")
[10:24:24.775]                             if (!has_future) {
[10:24:24.775]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:24.775]                                 info)
[10:24:24.775]                             }
[10:24:24.775]                             else {
[10:24:24.775]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:24.775]                                 info, version)
[10:24:24.775]                             }
[10:24:24.775]                             base::stop(msg)
[10:24:24.775]                           }
[10:24:24.775]                         })
[10:24:24.775]                       }
[10:24:24.775]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:24.775]                       base::options(mc.cores = 1L)
[10:24:24.775]                     }
[10:24:24.775]                     base::local({
[10:24:24.775]                       for (pkg in "future.apply") {
[10:24:24.775]                         base::loadNamespace(pkg)
[10:24:24.775]                         base::library(pkg, character.only = TRUE)
[10:24:24.775]                       }
[10:24:24.775]                     })
[10:24:24.775]                   }
[10:24:24.775]                   options(future.plan = NULL)
[10:24:24.775]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:24.775]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:24.775]                 }
[10:24:24.775]                 ...future.workdir <- getwd()
[10:24:24.775]             }
[10:24:24.775]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:24.775]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:24.775]         }
[10:24:24.775]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:24.775]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:24.775]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:24.775]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:24.775]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:24.775]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:24.775]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:24.775]             base::names(...future.oldOptions))
[10:24:24.775]     }
[10:24:24.775]     if (FALSE) {
[10:24:24.775]     }
[10:24:24.775]     else {
[10:24:24.775]         if (TRUE) {
[10:24:24.775]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:24.775]                 open = "w")
[10:24:24.775]         }
[10:24:24.775]         else {
[10:24:24.775]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:24.775]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:24.775]         }
[10:24:24.775]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:24.775]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:24.775]             base::sink(type = "output", split = FALSE)
[10:24:24.775]             base::close(...future.stdout)
[10:24:24.775]         }, add = TRUE)
[10:24:24.775]     }
[10:24:24.775]     ...future.frame <- base::sys.nframe()
[10:24:24.775]     ...future.conditions <- base::list()
[10:24:24.775]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:24.775]     if (FALSE) {
[10:24:24.775]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:24.775]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:24.775]     }
[10:24:24.775]     ...future.result <- base::tryCatch({
[10:24:24.775]         base::withCallingHandlers({
[10:24:24.775]             ...future.value <- base::withVisible(base::local({
[10:24:24.775]                 ...future.makeSendCondition <- base::local({
[10:24:24.775]                   sendCondition <- NULL
[10:24:24.775]                   function(frame = 1L) {
[10:24:24.775]                     if (is.function(sendCondition)) 
[10:24:24.775]                       return(sendCondition)
[10:24:24.775]                     ns <- getNamespace("parallel")
[10:24:24.775]                     if (exists("sendData", mode = "function", 
[10:24:24.775]                       envir = ns)) {
[10:24:24.775]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:24.775]                         envir = ns)
[10:24:24.775]                       envir <- sys.frame(frame)
[10:24:24.775]                       master <- NULL
[10:24:24.775]                       while (!identical(envir, .GlobalEnv) && 
[10:24:24.775]                         !identical(envir, emptyenv())) {
[10:24:24.775]                         if (exists("master", mode = "list", envir = envir, 
[10:24:24.775]                           inherits = FALSE)) {
[10:24:24.775]                           master <- get("master", mode = "list", 
[10:24:24.775]                             envir = envir, inherits = FALSE)
[10:24:24.775]                           if (inherits(master, c("SOCKnode", 
[10:24:24.775]                             "SOCK0node"))) {
[10:24:24.775]                             sendCondition <<- function(cond) {
[10:24:24.775]                               data <- list(type = "VALUE", value = cond, 
[10:24:24.775]                                 success = TRUE)
[10:24:24.775]                               parallel_sendData(master, data)
[10:24:24.775]                             }
[10:24:24.775]                             return(sendCondition)
[10:24:24.775]                           }
[10:24:24.775]                         }
[10:24:24.775]                         frame <- frame + 1L
[10:24:24.775]                         envir <- sys.frame(frame)
[10:24:24.775]                       }
[10:24:24.775]                     }
[10:24:24.775]                     sendCondition <<- function(cond) NULL
[10:24:24.775]                   }
[10:24:24.775]                 })
[10:24:24.775]                 withCallingHandlers({
[10:24:24.775]                   {
[10:24:24.775]                     do.call(function(...) {
[10:24:24.775]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.775]                       if (!identical(...future.globals.maxSize.org, 
[10:24:24.775]                         ...future.globals.maxSize)) {
[10:24:24.775]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.775]                         on.exit(options(oopts), add = TRUE)
[10:24:24.775]                       }
[10:24:24.775]                       {
[10:24:24.775]                         lapply(seq_along(...future.elements_ii), 
[10:24:24.775]                           FUN = function(jj) {
[10:24:24.775]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.775]                             ...future.FUN(...future.X_jj, ...)
[10:24:24.775]                           })
[10:24:24.775]                       }
[10:24:24.775]                     }, args = future.call.arguments)
[10:24:24.775]                   }
[10:24:24.775]                 }, immediateCondition = function(cond) {
[10:24:24.775]                   sendCondition <- ...future.makeSendCondition()
[10:24:24.775]                   sendCondition(cond)
[10:24:24.775]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.775]                   {
[10:24:24.775]                     inherits <- base::inherits
[10:24:24.775]                     invokeRestart <- base::invokeRestart
[10:24:24.775]                     is.null <- base::is.null
[10:24:24.775]                     muffled <- FALSE
[10:24:24.775]                     if (inherits(cond, "message")) {
[10:24:24.775]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:24.775]                       if (muffled) 
[10:24:24.775]                         invokeRestart("muffleMessage")
[10:24:24.775]                     }
[10:24:24.775]                     else if (inherits(cond, "warning")) {
[10:24:24.775]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:24.775]                       if (muffled) 
[10:24:24.775]                         invokeRestart("muffleWarning")
[10:24:24.775]                     }
[10:24:24.775]                     else if (inherits(cond, "condition")) {
[10:24:24.775]                       if (!is.null(pattern)) {
[10:24:24.775]                         computeRestarts <- base::computeRestarts
[10:24:24.775]                         grepl <- base::grepl
[10:24:24.775]                         restarts <- computeRestarts(cond)
[10:24:24.775]                         for (restart in restarts) {
[10:24:24.775]                           name <- restart$name
[10:24:24.775]                           if (is.null(name)) 
[10:24:24.775]                             next
[10:24:24.775]                           if (!grepl(pattern, name)) 
[10:24:24.775]                             next
[10:24:24.775]                           invokeRestart(restart)
[10:24:24.775]                           muffled <- TRUE
[10:24:24.775]                           break
[10:24:24.775]                         }
[10:24:24.775]                       }
[10:24:24.775]                     }
[10:24:24.775]                     invisible(muffled)
[10:24:24.775]                   }
[10:24:24.775]                   muffleCondition(cond)
[10:24:24.775]                 })
[10:24:24.775]             }))
[10:24:24.775]             future::FutureResult(value = ...future.value$value, 
[10:24:24.775]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:24.775]                   ...future.rng), globalenv = if (FALSE) 
[10:24:24.775]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:24.775]                     ...future.globalenv.names))
[10:24:24.775]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:24.775]         }, condition = base::local({
[10:24:24.775]             c <- base::c
[10:24:24.775]             inherits <- base::inherits
[10:24:24.775]             invokeRestart <- base::invokeRestart
[10:24:24.775]             length <- base::length
[10:24:24.775]             list <- base::list
[10:24:24.775]             seq.int <- base::seq.int
[10:24:24.775]             signalCondition <- base::signalCondition
[10:24:24.775]             sys.calls <- base::sys.calls
[10:24:24.775]             `[[` <- base::`[[`
[10:24:24.775]             `+` <- base::`+`
[10:24:24.775]             `<<-` <- base::`<<-`
[10:24:24.775]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:24.775]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:24.775]                   3L)]
[10:24:24.775]             }
[10:24:24.775]             function(cond) {
[10:24:24.775]                 is_error <- inherits(cond, "error")
[10:24:24.775]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:24.775]                   NULL)
[10:24:24.775]                 if (is_error) {
[10:24:24.775]                   sessionInformation <- function() {
[10:24:24.775]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:24.775]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:24.775]                       search = base::search(), system = base::Sys.info())
[10:24:24.775]                   }
[10:24:24.775]                   ...future.conditions[[length(...future.conditions) + 
[10:24:24.775]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:24.775]                     cond$call), session = sessionInformation(), 
[10:24:24.775]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:24.775]                   signalCondition(cond)
[10:24:24.775]                 }
[10:24:24.775]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:24.775]                 "immediateCondition"))) {
[10:24:24.775]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:24.775]                   ...future.conditions[[length(...future.conditions) + 
[10:24:24.775]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:24.775]                   if (TRUE && !signal) {
[10:24:24.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.775]                     {
[10:24:24.775]                       inherits <- base::inherits
[10:24:24.775]                       invokeRestart <- base::invokeRestart
[10:24:24.775]                       is.null <- base::is.null
[10:24:24.775]                       muffled <- FALSE
[10:24:24.775]                       if (inherits(cond, "message")) {
[10:24:24.775]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:24.775]                         if (muffled) 
[10:24:24.775]                           invokeRestart("muffleMessage")
[10:24:24.775]                       }
[10:24:24.775]                       else if (inherits(cond, "warning")) {
[10:24:24.775]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:24.775]                         if (muffled) 
[10:24:24.775]                           invokeRestart("muffleWarning")
[10:24:24.775]                       }
[10:24:24.775]                       else if (inherits(cond, "condition")) {
[10:24:24.775]                         if (!is.null(pattern)) {
[10:24:24.775]                           computeRestarts <- base::computeRestarts
[10:24:24.775]                           grepl <- base::grepl
[10:24:24.775]                           restarts <- computeRestarts(cond)
[10:24:24.775]                           for (restart in restarts) {
[10:24:24.775]                             name <- restart$name
[10:24:24.775]                             if (is.null(name)) 
[10:24:24.775]                               next
[10:24:24.775]                             if (!grepl(pattern, name)) 
[10:24:24.775]                               next
[10:24:24.775]                             invokeRestart(restart)
[10:24:24.775]                             muffled <- TRUE
[10:24:24.775]                             break
[10:24:24.775]                           }
[10:24:24.775]                         }
[10:24:24.775]                       }
[10:24:24.775]                       invisible(muffled)
[10:24:24.775]                     }
[10:24:24.775]                     muffleCondition(cond, pattern = "^muffle")
[10:24:24.775]                   }
[10:24:24.775]                 }
[10:24:24.775]                 else {
[10:24:24.775]                   if (TRUE) {
[10:24:24.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:24.775]                     {
[10:24:24.775]                       inherits <- base::inherits
[10:24:24.775]                       invokeRestart <- base::invokeRestart
[10:24:24.775]                       is.null <- base::is.null
[10:24:24.775]                       muffled <- FALSE
[10:24:24.775]                       if (inherits(cond, "message")) {
[10:24:24.775]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:24.775]                         if (muffled) 
[10:24:24.775]                           invokeRestart("muffleMessage")
[10:24:24.775]                       }
[10:24:24.775]                       else if (inherits(cond, "warning")) {
[10:24:24.775]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:24.775]                         if (muffled) 
[10:24:24.775]                           invokeRestart("muffleWarning")
[10:24:24.775]                       }
[10:24:24.775]                       else if (inherits(cond, "condition")) {
[10:24:24.775]                         if (!is.null(pattern)) {
[10:24:24.775]                           computeRestarts <- base::computeRestarts
[10:24:24.775]                           grepl <- base::grepl
[10:24:24.775]                           restarts <- computeRestarts(cond)
[10:24:24.775]                           for (restart in restarts) {
[10:24:24.775]                             name <- restart$name
[10:24:24.775]                             if (is.null(name)) 
[10:24:24.775]                               next
[10:24:24.775]                             if (!grepl(pattern, name)) 
[10:24:24.775]                               next
[10:24:24.775]                             invokeRestart(restart)
[10:24:24.775]                             muffled <- TRUE
[10:24:24.775]                             break
[10:24:24.775]                           }
[10:24:24.775]                         }
[10:24:24.775]                       }
[10:24:24.775]                       invisible(muffled)
[10:24:24.775]                     }
[10:24:24.775]                     muffleCondition(cond, pattern = "^muffle")
[10:24:24.775]                   }
[10:24:24.775]                 }
[10:24:24.775]             }
[10:24:24.775]         }))
[10:24:24.775]     }, error = function(ex) {
[10:24:24.775]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:24.775]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:24.775]                 ...future.rng), started = ...future.startTime, 
[10:24:24.775]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:24.775]             version = "1.8"), class = "FutureResult")
[10:24:24.775]     }, finally = {
[10:24:24.775]         if (!identical(...future.workdir, getwd())) 
[10:24:24.775]             setwd(...future.workdir)
[10:24:24.775]         {
[10:24:24.775]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:24.775]                 ...future.oldOptions$nwarnings <- NULL
[10:24:24.775]             }
[10:24:24.775]             base::options(...future.oldOptions)
[10:24:24.775]             if (.Platform$OS.type == "windows") {
[10:24:24.775]                 old_names <- names(...future.oldEnvVars)
[10:24:24.775]                 envs <- base::Sys.getenv()
[10:24:24.775]                 names <- names(envs)
[10:24:24.775]                 common <- intersect(names, old_names)
[10:24:24.775]                 added <- setdiff(names, old_names)
[10:24:24.775]                 removed <- setdiff(old_names, names)
[10:24:24.775]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:24.775]                   envs[common]]
[10:24:24.775]                 NAMES <- toupper(changed)
[10:24:24.775]                 args <- list()
[10:24:24.775]                 for (kk in seq_along(NAMES)) {
[10:24:24.775]                   name <- changed[[kk]]
[10:24:24.775]                   NAME <- NAMES[[kk]]
[10:24:24.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.775]                     next
[10:24:24.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:24.775]                 }
[10:24:24.775]                 NAMES <- toupper(added)
[10:24:24.775]                 for (kk in seq_along(NAMES)) {
[10:24:24.775]                   name <- added[[kk]]
[10:24:24.775]                   NAME <- NAMES[[kk]]
[10:24:24.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.775]                     next
[10:24:24.775]                   args[[name]] <- ""
[10:24:24.775]                 }
[10:24:24.775]                 NAMES <- toupper(removed)
[10:24:24.775]                 for (kk in seq_along(NAMES)) {
[10:24:24.775]                   name <- removed[[kk]]
[10:24:24.775]                   NAME <- NAMES[[kk]]
[10:24:24.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:24.775]                     next
[10:24:24.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:24.775]                 }
[10:24:24.775]                 if (length(args) > 0) 
[10:24:24.775]                   base::do.call(base::Sys.setenv, args = args)
[10:24:24.775]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:24.775]             }
[10:24:24.775]             else {
[10:24:24.775]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:24.775]             }
[10:24:24.775]             {
[10:24:24.775]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:24.775]                   0L) {
[10:24:24.775]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:24.775]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:24.775]                   base::options(opts)
[10:24:24.775]                 }
[10:24:24.775]                 {
[10:24:24.775]                   {
[10:24:24.775]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:24.775]                     NULL
[10:24:24.775]                   }
[10:24:24.775]                   options(future.plan = NULL)
[10:24:24.775]                   if (is.na(NA_character_)) 
[10:24:24.775]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:24.775]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:24.775]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:24.775]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:24.775]                     envir = parent.frame()) 
[10:24:24.775]                   {
[10:24:24.775]                     if (is.function(workers)) 
[10:24:24.775]                       workers <- workers()
[10:24:24.775]                     workers <- structure(as.integer(workers), 
[10:24:24.775]                       class = class(workers))
[10:24:24.775]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:24.775]                       workers >= 1)
[10:24:24.775]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:24.775]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:24.775]                     }
[10:24:24.775]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:24.775]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:24.775]                       envir = envir)
[10:24:24.775]                     if (!future$lazy) 
[10:24:24.775]                       future <- run(future)
[10:24:24.775]                     invisible(future)
[10:24:24.775]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:24.775]                 }
[10:24:24.775]             }
[10:24:24.775]         }
[10:24:24.775]     })
[10:24:24.775]     if (TRUE) {
[10:24:24.775]         base::sink(type = "output", split = FALSE)
[10:24:24.775]         if (TRUE) {
[10:24:24.775]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:24.775]         }
[10:24:24.775]         else {
[10:24:24.775]             ...future.result["stdout"] <- base::list(NULL)
[10:24:24.775]         }
[10:24:24.775]         base::close(...future.stdout)
[10:24:24.775]         ...future.stdout <- NULL
[10:24:24.775]     }
[10:24:24.775]     ...future.result$conditions <- ...future.conditions
[10:24:24.775]     ...future.result$finished <- base::Sys.time()
[10:24:24.775]     ...future.result
[10:24:24.775] }
[10:24:24.778] Exporting 11 global objects (96.29 KiB) to cluster node #2 ...
[10:24:24.778] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:24.822] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:24.822] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ...
[10:24:24.822] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ... DONE
[10:24:24.822] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:24.823] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:24.823] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:24.866] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:24.866] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:24.910] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:24.910] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[10:24:24.910] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[10:24:24.910] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:24:24.911] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:24:24.911] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[10:24:24.911] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[10:24:24.912] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:24:24.912] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:24:24.912] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:24.912] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:24.913] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:24.913] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:24.913] Exporting 11 global objects (96.29 KiB) to cluster node #2 ... DONE
[10:24:24.914] MultisessionFuture started
[10:24:24.914] - Launch lazy future ... done
[10:24:24.914] run() for ‘MultisessionFuture’ ... done
[10:24:24.914] Created future:
[10:24:24.914] MultisessionFuture:
[10:24:24.914] Label: ‘future_vapply-2’
[10:24:24.914] Expression:
[10:24:24.914] {
[10:24:24.914]     do.call(function(...) {
[10:24:24.914]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.914]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.914]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.914]             on.exit(options(oopts), add = TRUE)
[10:24:24.914]         }
[10:24:24.914]         {
[10:24:24.914]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.914]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.914]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.914]             })
[10:24:24.914]         }
[10:24:24.914]     }, args = future.call.arguments)
[10:24:24.914] }
[10:24:24.914] Lazy evaluation: FALSE
[10:24:24.914] Asynchronous evaluation: TRUE
[10:24:24.914] Local evaluation: TRUE
[10:24:24.914] Environment: R_GlobalEnv
[10:24:24.914] Capture standard output: TRUE
[10:24:24.914] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:24.914] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:24.914] Packages: 1 packages (‘future.apply’)
[10:24:24.914] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:24.914] Resolved: FALSE
[10:24:24.914] Value: <not collected>
[10:24:24.914] Conditions captured: <none>
[10:24:24.914] Early signaling: FALSE
[10:24:24.914] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:24.914] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:24.926] Chunk #2 of 2 ... DONE
[10:24:24.926] Launching 2 futures (chunks) ... DONE
[10:24:24.926] Resolving 2 futures (chunks) ...
[10:24:24.926] resolve() on list ...
[10:24:24.926]  recursive: 0
[10:24:24.927]  length: 2
[10:24:24.927] 
[10:24:24.927] receiveMessageFromWorker() for ClusterFuture ...
[10:24:24.927] - Validating connection of MultisessionFuture
[10:24:24.927] - received message: FutureResult
[10:24:24.928] - Received FutureResult
[10:24:24.928] - Erased future from FutureRegistry
[10:24:24.928] result() for ClusterFuture ...
[10:24:24.928] - result already collected: FutureResult
[10:24:24.928] result() for ClusterFuture ... done
[10:24:24.928] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:24.928] Future #1
[10:24:24.928] result() for ClusterFuture ...
[10:24:24.929] - result already collected: FutureResult
[10:24:24.929] result() for ClusterFuture ... done
[10:24:24.929] result() for ClusterFuture ...
[10:24:24.929] - result already collected: FutureResult
[10:24:24.929] result() for ClusterFuture ... done
[10:24:24.929] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:24.929] - nx: 2
[10:24:24.929] - relay: TRUE
[10:24:24.929] - stdout: TRUE
[10:24:24.929] - signal: TRUE
[10:24:24.930] - resignal: FALSE
[10:24:24.930] - force: TRUE
[10:24:24.930] - relayed: [n=2] FALSE, FALSE
[10:24:24.930] - queued futures: [n=2] FALSE, FALSE
[10:24:24.930]  - until=1
[10:24:24.930]  - relaying element #1
[10:24:24.930] result() for ClusterFuture ...
[10:24:24.930] - result already collected: FutureResult
[10:24:24.930] result() for ClusterFuture ... done
[10:24:24.930] result() for ClusterFuture ...
[10:24:24.930] - result already collected: FutureResult
[10:24:24.931] result() for ClusterFuture ... done
[10:24:24.931] result() for ClusterFuture ...
[10:24:24.931] - result already collected: FutureResult
[10:24:24.931] result() for ClusterFuture ... done
[10:24:24.931] result() for ClusterFuture ...
[10:24:24.931] - result already collected: FutureResult
[10:24:24.931] result() for ClusterFuture ... done
[10:24:24.931] - relayed: [n=2] TRUE, FALSE
[10:24:24.931] - queued futures: [n=2] TRUE, FALSE
[10:24:24.931] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:24.931]  length: 1 (resolved future 1)
[10:24:24.963] receiveMessageFromWorker() for ClusterFuture ...
[10:24:24.963] - Validating connection of MultisessionFuture
[10:24:24.963] - received message: FutureResult
[10:24:24.963] - Received FutureResult
[10:24:24.963] - Erased future from FutureRegistry
[10:24:24.963] result() for ClusterFuture ...
[10:24:24.963] - result already collected: FutureResult
[10:24:24.964] result() for ClusterFuture ... done
[10:24:24.964] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:24.964] Future #2
[10:24:24.964] result() for ClusterFuture ...
[10:24:24.964] - result already collected: FutureResult
[10:24:24.964] result() for ClusterFuture ... done
[10:24:24.964] result() for ClusterFuture ...
[10:24:24.964] - result already collected: FutureResult
[10:24:24.964] result() for ClusterFuture ... done
[10:24:24.965] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:24.965] - nx: 2
[10:24:24.965] - relay: TRUE
[10:24:24.965] - stdout: TRUE
[10:24:24.965] - signal: TRUE
[10:24:24.965] - resignal: FALSE
[10:24:24.965] - force: TRUE
[10:24:24.965] - relayed: [n=2] TRUE, FALSE
[10:24:24.965] - queued futures: [n=2] TRUE, FALSE
[10:24:24.966]  - until=2
[10:24:24.966]  - relaying element #2
[10:24:24.966] result() for ClusterFuture ...
[10:24:24.966] - result already collected: FutureResult
[10:24:24.966] result() for ClusterFuture ... done
[10:24:24.966] result() for ClusterFuture ...
[10:24:24.966] - result already collected: FutureResult
[10:24:24.966] result() for ClusterFuture ... done
[10:24:24.966] result() for ClusterFuture ...
[10:24:24.966] - result already collected: FutureResult
[10:24:24.967] result() for ClusterFuture ... done
[10:24:24.967] result() for ClusterFuture ...
[10:24:24.967] - result already collected: FutureResult
[10:24:24.967] result() for ClusterFuture ... done
[10:24:24.967] - relayed: [n=2] TRUE, TRUE
[10:24:24.967] - queued futures: [n=2] TRUE, TRUE
[10:24:24.967] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:24.967]  length: 0 (resolved future 2)
[10:24:24.967] Relaying remaining futures
[10:24:24.967] signalConditionsASAP(NULL, pos=0) ...
[10:24:24.967] - nx: 2
[10:24:24.968] - relay: TRUE
[10:24:24.968] - stdout: TRUE
[10:24:24.968] - signal: TRUE
[10:24:24.968] - resignal: FALSE
[10:24:24.968] - force: TRUE
[10:24:24.968] - relayed: [n=2] TRUE, TRUE
[10:24:24.968] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:24.968] - relayed: [n=2] TRUE, TRUE
[10:24:24.968] - queued futures: [n=2] TRUE, TRUE
[10:24:24.968] signalConditionsASAP(NULL, pos=0) ... done
[10:24:24.968] resolve() on list ... DONE
[10:24:24.969] result() for ClusterFuture ...
[10:24:24.969] - result already collected: FutureResult
[10:24:24.969] result() for ClusterFuture ... done
[10:24:24.969] result() for ClusterFuture ...
[10:24:24.969] - result already collected: FutureResult
[10:24:24.969] result() for ClusterFuture ... done
[10:24:24.969] result() for ClusterFuture ...
[10:24:24.969] - result already collected: FutureResult
[10:24:24.969] result() for ClusterFuture ... done
[10:24:24.969] result() for ClusterFuture ...
[10:24:24.970] - result already collected: FutureResult
[10:24:24.970] result() for ClusterFuture ... done
[10:24:24.970]  - Number of value chunks collected: 2
[10:24:24.970] Resolving 2 futures (chunks) ... DONE
[10:24:24.970] Reducing values from 2 chunks ...
[10:24:24.970]  - Number of values collected after concatenation: 4
[10:24:24.970]  - Number of values expected: 4
[10:24:24.970] Reducing values from 2 chunks ... DONE
[10:24:24.970] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[10:24:24.972] future_lapply() ...
[10:24:24.977] Number of chunks: 2
[10:24:24.977] getGlobalsAndPackagesXApply() ...
[10:24:24.977]  - future.globals: TRUE
[10:24:24.978] getGlobalsAndPackages() ...
[10:24:24.978] Searching for globals...
[10:24:24.981] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:24.981] Searching for globals ... DONE
[10:24:24.981] Resolving globals: FALSE
[10:24:24.982] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[10:24:24.982] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:24.982] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:24.982] - packages: [1] ‘future.apply’
[10:24:24.983] getGlobalsAndPackages() ... DONE
[10:24:24.983]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:24.983]  - needed namespaces: [n=1] ‘future.apply’
[10:24:24.983] Finding globals ... DONE
[10:24:24.983]  - use_args: TRUE
[10:24:24.983]  - Getting '...' globals ...
[10:24:24.983] resolve() on list ...
[10:24:24.983]  recursive: 0
[10:24:24.984]  length: 1
[10:24:24.984]  elements: ‘...’
[10:24:24.984]  length: 0 (resolved future 1)
[10:24:24.984] resolve() on list ... DONE
[10:24:24.984]    - '...' content: [n=0] 
[10:24:24.984] List of 1
[10:24:24.984]  $ ...: list()
[10:24:24.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:24.984]  - attr(*, "where")=List of 1
[10:24:24.984]   ..$ ...:<environment: 0x55b93f369e30> 
[10:24:24.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:24.984]  - attr(*, "resolved")= logi TRUE
[10:24:24.984]  - attr(*, "total_size")= num NA
[10:24:24.987]  - Getting '...' globals ... DONE
[10:24:24.987] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:24.987] List of 8
[10:24:24.987]  $ ...future.FUN:function (x, ...)  
[10:24:24.987]  $ x_FUN        :function (x)  
[10:24:24.987]  $ times        : int 1
[10:24:24.987]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:24.987]  $ stop_if_not  :function (...)  
[10:24:24.987]  $ dim          : NULL
[10:24:24.987]  $ valid_types  : chr "logical"
[10:24:24.987]  $ ...          : list()
[10:24:24.987]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:24.987]  - attr(*, "where")=List of 8
[10:24:24.987]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:24.987]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:24.987]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:24.987]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:24.987]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:24.987]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:24.987]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:24.987]   ..$ ...          :<environment: 0x55b93f369e30> 
[10:24:24.987]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:24.987]  - attr(*, "resolved")= logi FALSE
[10:24:24.987]  - attr(*, "total_size")= num 94200
[10:24:24.992] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:24.992] getGlobalsAndPackagesXApply() ... DONE
[10:24:24.992] Number of futures (= number of chunks): 2
[10:24:24.993] Launching 2 futures (chunks) ...
[10:24:24.993] Chunk #1 of 2 ...
[10:24:24.993]  - Finding globals in 'X' for chunk #1 ...
[10:24:24.993] getGlobalsAndPackages() ...
[10:24:24.993] Searching for globals...
[10:24:24.993] 
[10:24:24.993] Searching for globals ... DONE
[10:24:24.994] - globals: [0] <none>
[10:24:24.994] getGlobalsAndPackages() ... DONE
[10:24:24.994]    + additional globals found: [n=0] 
[10:24:24.994]    + additional namespaces needed: [n=0] 
[10:24:24.994]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:24.997]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:24.997]  - seeds: <none>
[10:24:24.997]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.997] getGlobalsAndPackages() ...
[10:24:24.997] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.997] Resolving globals: FALSE
[10:24:24.997] Tweak future expression to call with '...' arguments ...
[10:24:24.997] {
[10:24:24.997]     do.call(function(...) {
[10:24:24.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:24.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:24.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:24.997]             on.exit(options(oopts), add = TRUE)
[10:24:24.997]         }
[10:24:24.997]         {
[10:24:24.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:24.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:24.997]                 ...future.FUN(...future.X_jj, ...)
[10:24:24.997]             })
[10:24:24.997]         }
[10:24:24.997]     }, args = future.call.arguments)
[10:24:24.997] }
[10:24:24.998] Tweak future expression to call with '...' arguments ... DONE
[10:24:24.998] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:24.998] - packages: [1] ‘future.apply’
[10:24:24.998] getGlobalsAndPackages() ... DONE
[10:24:24.999] run() for ‘Future’ ...
[10:24:24.999] - state: ‘created’
[10:24:24.999] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:25.013] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:25.013] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:25.013]   - Field: ‘node’
[10:24:25.013]   - Field: ‘label’
[10:24:25.013]   - Field: ‘local’
[10:24:25.013]   - Field: ‘owner’
[10:24:25.014]   - Field: ‘envir’
[10:24:25.014]   - Field: ‘workers’
[10:24:25.014]   - Field: ‘packages’
[10:24:25.014]   - Field: ‘gc’
[10:24:25.014]   - Field: ‘conditions’
[10:24:25.014]   - Field: ‘persistent’
[10:24:25.014]   - Field: ‘expr’
[10:24:25.014]   - Field: ‘uuid’
[10:24:25.014]   - Field: ‘seed’
[10:24:25.014]   - Field: ‘version’
[10:24:25.014]   - Field: ‘result’
[10:24:25.015]   - Field: ‘asynchronous’
[10:24:25.015]   - Field: ‘calls’
[10:24:25.015]   - Field: ‘globals’
[10:24:25.015]   - Field: ‘stdout’
[10:24:25.015]   - Field: ‘earlySignal’
[10:24:25.015]   - Field: ‘lazy’
[10:24:25.015]   - Field: ‘state’
[10:24:25.015] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:25.015] - Launch lazy future ...
[10:24:25.016] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:25.016] Packages needed by future strategies (n = 0): <none>
[10:24:25.016] {
[10:24:25.016]     {
[10:24:25.016]         {
[10:24:25.016]             ...future.startTime <- base::Sys.time()
[10:24:25.016]             {
[10:24:25.016]                 {
[10:24:25.016]                   {
[10:24:25.016]                     {
[10:24:25.016]                       {
[10:24:25.016]                         base::local({
[10:24:25.016]                           has_future <- base::requireNamespace("future", 
[10:24:25.016]                             quietly = TRUE)
[10:24:25.016]                           if (has_future) {
[10:24:25.016]                             ns <- base::getNamespace("future")
[10:24:25.016]                             version <- ns[[".package"]][["version"]]
[10:24:25.016]                             if (is.null(version)) 
[10:24:25.016]                               version <- utils::packageVersion("future")
[10:24:25.016]                           }
[10:24:25.016]                           else {
[10:24:25.016]                             version <- NULL
[10:24:25.016]                           }
[10:24:25.016]                           if (!has_future || version < "1.8.0") {
[10:24:25.016]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:25.016]                               "", base::R.version$version.string), 
[10:24:25.016]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:25.016]                                 base::R.version$platform, 8 * 
[10:24:25.016]                                   base::.Machine$sizeof.pointer), 
[10:24:25.016]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:25.016]                                 "release", "version")], collapse = " "), 
[10:24:25.016]                               hostname = base::Sys.info()[["nodename"]])
[10:24:25.016]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:25.016]                               info)
[10:24:25.016]                             info <- base::paste(info, collapse = "; ")
[10:24:25.016]                             if (!has_future) {
[10:24:25.016]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:25.016]                                 info)
[10:24:25.016]                             }
[10:24:25.016]                             else {
[10:24:25.016]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:25.016]                                 info, version)
[10:24:25.016]                             }
[10:24:25.016]                             base::stop(msg)
[10:24:25.016]                           }
[10:24:25.016]                         })
[10:24:25.016]                       }
[10:24:25.016]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:25.016]                       base::options(mc.cores = 1L)
[10:24:25.016]                     }
[10:24:25.016]                     base::local({
[10:24:25.016]                       for (pkg in "future.apply") {
[10:24:25.016]                         base::loadNamespace(pkg)
[10:24:25.016]                         base::library(pkg, character.only = TRUE)
[10:24:25.016]                       }
[10:24:25.016]                     })
[10:24:25.016]                   }
[10:24:25.016]                   options(future.plan = NULL)
[10:24:25.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:25.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:25.016]                 }
[10:24:25.016]                 ...future.workdir <- getwd()
[10:24:25.016]             }
[10:24:25.016]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:25.016]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:25.016]         }
[10:24:25.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:25.016]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:25.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:25.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:25.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:25.016]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:25.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:25.016]             base::names(...future.oldOptions))
[10:24:25.016]     }
[10:24:25.016]     if (FALSE) {
[10:24:25.016]     }
[10:24:25.016]     else {
[10:24:25.016]         if (TRUE) {
[10:24:25.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:25.016]                 open = "w")
[10:24:25.016]         }
[10:24:25.016]         else {
[10:24:25.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:25.016]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:25.016]         }
[10:24:25.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:25.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:25.016]             base::sink(type = "output", split = FALSE)
[10:24:25.016]             base::close(...future.stdout)
[10:24:25.016]         }, add = TRUE)
[10:24:25.016]     }
[10:24:25.016]     ...future.frame <- base::sys.nframe()
[10:24:25.016]     ...future.conditions <- base::list()
[10:24:25.016]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:25.016]     if (FALSE) {
[10:24:25.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:25.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:25.016]     }
[10:24:25.016]     ...future.result <- base::tryCatch({
[10:24:25.016]         base::withCallingHandlers({
[10:24:25.016]             ...future.value <- base::withVisible(base::local({
[10:24:25.016]                 ...future.makeSendCondition <- base::local({
[10:24:25.016]                   sendCondition <- NULL
[10:24:25.016]                   function(frame = 1L) {
[10:24:25.016]                     if (is.function(sendCondition)) 
[10:24:25.016]                       return(sendCondition)
[10:24:25.016]                     ns <- getNamespace("parallel")
[10:24:25.016]                     if (exists("sendData", mode = "function", 
[10:24:25.016]                       envir = ns)) {
[10:24:25.016]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:25.016]                         envir = ns)
[10:24:25.016]                       envir <- sys.frame(frame)
[10:24:25.016]                       master <- NULL
[10:24:25.016]                       while (!identical(envir, .GlobalEnv) && 
[10:24:25.016]                         !identical(envir, emptyenv())) {
[10:24:25.016]                         if (exists("master", mode = "list", envir = envir, 
[10:24:25.016]                           inherits = FALSE)) {
[10:24:25.016]                           master <- get("master", mode = "list", 
[10:24:25.016]                             envir = envir, inherits = FALSE)
[10:24:25.016]                           if (inherits(master, c("SOCKnode", 
[10:24:25.016]                             "SOCK0node"))) {
[10:24:25.016]                             sendCondition <<- function(cond) {
[10:24:25.016]                               data <- list(type = "VALUE", value = cond, 
[10:24:25.016]                                 success = TRUE)
[10:24:25.016]                               parallel_sendData(master, data)
[10:24:25.016]                             }
[10:24:25.016]                             return(sendCondition)
[10:24:25.016]                           }
[10:24:25.016]                         }
[10:24:25.016]                         frame <- frame + 1L
[10:24:25.016]                         envir <- sys.frame(frame)
[10:24:25.016]                       }
[10:24:25.016]                     }
[10:24:25.016]                     sendCondition <<- function(cond) NULL
[10:24:25.016]                   }
[10:24:25.016]                 })
[10:24:25.016]                 withCallingHandlers({
[10:24:25.016]                   {
[10:24:25.016]                     do.call(function(...) {
[10:24:25.016]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.016]                       if (!identical(...future.globals.maxSize.org, 
[10:24:25.016]                         ...future.globals.maxSize)) {
[10:24:25.016]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.016]                         on.exit(options(oopts), add = TRUE)
[10:24:25.016]                       }
[10:24:25.016]                       {
[10:24:25.016]                         lapply(seq_along(...future.elements_ii), 
[10:24:25.016]                           FUN = function(jj) {
[10:24:25.016]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.016]                             ...future.FUN(...future.X_jj, ...)
[10:24:25.016]                           })
[10:24:25.016]                       }
[10:24:25.016]                     }, args = future.call.arguments)
[10:24:25.016]                   }
[10:24:25.016]                 }, immediateCondition = function(cond) {
[10:24:25.016]                   sendCondition <- ...future.makeSendCondition()
[10:24:25.016]                   sendCondition(cond)
[10:24:25.016]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.016]                   {
[10:24:25.016]                     inherits <- base::inherits
[10:24:25.016]                     invokeRestart <- base::invokeRestart
[10:24:25.016]                     is.null <- base::is.null
[10:24:25.016]                     muffled <- FALSE
[10:24:25.016]                     if (inherits(cond, "message")) {
[10:24:25.016]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:25.016]                       if (muffled) 
[10:24:25.016]                         invokeRestart("muffleMessage")
[10:24:25.016]                     }
[10:24:25.016]                     else if (inherits(cond, "warning")) {
[10:24:25.016]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:25.016]                       if (muffled) 
[10:24:25.016]                         invokeRestart("muffleWarning")
[10:24:25.016]                     }
[10:24:25.016]                     else if (inherits(cond, "condition")) {
[10:24:25.016]                       if (!is.null(pattern)) {
[10:24:25.016]                         computeRestarts <- base::computeRestarts
[10:24:25.016]                         grepl <- base::grepl
[10:24:25.016]                         restarts <- computeRestarts(cond)
[10:24:25.016]                         for (restart in restarts) {
[10:24:25.016]                           name <- restart$name
[10:24:25.016]                           if (is.null(name)) 
[10:24:25.016]                             next
[10:24:25.016]                           if (!grepl(pattern, name)) 
[10:24:25.016]                             next
[10:24:25.016]                           invokeRestart(restart)
[10:24:25.016]                           muffled <- TRUE
[10:24:25.016]                           break
[10:24:25.016]                         }
[10:24:25.016]                       }
[10:24:25.016]                     }
[10:24:25.016]                     invisible(muffled)
[10:24:25.016]                   }
[10:24:25.016]                   muffleCondition(cond)
[10:24:25.016]                 })
[10:24:25.016]             }))
[10:24:25.016]             future::FutureResult(value = ...future.value$value, 
[10:24:25.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:25.016]                   ...future.rng), globalenv = if (FALSE) 
[10:24:25.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:25.016]                     ...future.globalenv.names))
[10:24:25.016]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:25.016]         }, condition = base::local({
[10:24:25.016]             c <- base::c
[10:24:25.016]             inherits <- base::inherits
[10:24:25.016]             invokeRestart <- base::invokeRestart
[10:24:25.016]             length <- base::length
[10:24:25.016]             list <- base::list
[10:24:25.016]             seq.int <- base::seq.int
[10:24:25.016]             signalCondition <- base::signalCondition
[10:24:25.016]             sys.calls <- base::sys.calls
[10:24:25.016]             `[[` <- base::`[[`
[10:24:25.016]             `+` <- base::`+`
[10:24:25.016]             `<<-` <- base::`<<-`
[10:24:25.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:25.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:25.016]                   3L)]
[10:24:25.016]             }
[10:24:25.016]             function(cond) {
[10:24:25.016]                 is_error <- inherits(cond, "error")
[10:24:25.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:25.016]                   NULL)
[10:24:25.016]                 if (is_error) {
[10:24:25.016]                   sessionInformation <- function() {
[10:24:25.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:25.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:25.016]                       search = base::search(), system = base::Sys.info())
[10:24:25.016]                   }
[10:24:25.016]                   ...future.conditions[[length(...future.conditions) + 
[10:24:25.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:25.016]                     cond$call), session = sessionInformation(), 
[10:24:25.016]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:25.016]                   signalCondition(cond)
[10:24:25.016]                 }
[10:24:25.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:25.016]                 "immediateCondition"))) {
[10:24:25.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:25.016]                   ...future.conditions[[length(...future.conditions) + 
[10:24:25.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:25.016]                   if (TRUE && !signal) {
[10:24:25.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.016]                     {
[10:24:25.016]                       inherits <- base::inherits
[10:24:25.016]                       invokeRestart <- base::invokeRestart
[10:24:25.016]                       is.null <- base::is.null
[10:24:25.016]                       muffled <- FALSE
[10:24:25.016]                       if (inherits(cond, "message")) {
[10:24:25.016]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:25.016]                         if (muffled) 
[10:24:25.016]                           invokeRestart("muffleMessage")
[10:24:25.016]                       }
[10:24:25.016]                       else if (inherits(cond, "warning")) {
[10:24:25.016]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:25.016]                         if (muffled) 
[10:24:25.016]                           invokeRestart("muffleWarning")
[10:24:25.016]                       }
[10:24:25.016]                       else if (inherits(cond, "condition")) {
[10:24:25.016]                         if (!is.null(pattern)) {
[10:24:25.016]                           computeRestarts <- base::computeRestarts
[10:24:25.016]                           grepl <- base::grepl
[10:24:25.016]                           restarts <- computeRestarts(cond)
[10:24:25.016]                           for (restart in restarts) {
[10:24:25.016]                             name <- restart$name
[10:24:25.016]                             if (is.null(name)) 
[10:24:25.016]                               next
[10:24:25.016]                             if (!grepl(pattern, name)) 
[10:24:25.016]                               next
[10:24:25.016]                             invokeRestart(restart)
[10:24:25.016]                             muffled <- TRUE
[10:24:25.016]                             break
[10:24:25.016]                           }
[10:24:25.016]                         }
[10:24:25.016]                       }
[10:24:25.016]                       invisible(muffled)
[10:24:25.016]                     }
[10:24:25.016]                     muffleCondition(cond, pattern = "^muffle")
[10:24:25.016]                   }
[10:24:25.016]                 }
[10:24:25.016]                 else {
[10:24:25.016]                   if (TRUE) {
[10:24:25.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.016]                     {
[10:24:25.016]                       inherits <- base::inherits
[10:24:25.016]                       invokeRestart <- base::invokeRestart
[10:24:25.016]                       is.null <- base::is.null
[10:24:25.016]                       muffled <- FALSE
[10:24:25.016]                       if (inherits(cond, "message")) {
[10:24:25.016]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:25.016]                         if (muffled) 
[10:24:25.016]                           invokeRestart("muffleMessage")
[10:24:25.016]                       }
[10:24:25.016]                       else if (inherits(cond, "warning")) {
[10:24:25.016]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:25.016]                         if (muffled) 
[10:24:25.016]                           invokeRestart("muffleWarning")
[10:24:25.016]                       }
[10:24:25.016]                       else if (inherits(cond, "condition")) {
[10:24:25.016]                         if (!is.null(pattern)) {
[10:24:25.016]                           computeRestarts <- base::computeRestarts
[10:24:25.016]                           grepl <- base::grepl
[10:24:25.016]                           restarts <- computeRestarts(cond)
[10:24:25.016]                           for (restart in restarts) {
[10:24:25.016]                             name <- restart$name
[10:24:25.016]                             if (is.null(name)) 
[10:24:25.016]                               next
[10:24:25.016]                             if (!grepl(pattern, name)) 
[10:24:25.016]                               next
[10:24:25.016]                             invokeRestart(restart)
[10:24:25.016]                             muffled <- TRUE
[10:24:25.016]                             break
[10:24:25.016]                           }
[10:24:25.016]                         }
[10:24:25.016]                       }
[10:24:25.016]                       invisible(muffled)
[10:24:25.016]                     }
[10:24:25.016]                     muffleCondition(cond, pattern = "^muffle")
[10:24:25.016]                   }
[10:24:25.016]                 }
[10:24:25.016]             }
[10:24:25.016]         }))
[10:24:25.016]     }, error = function(ex) {
[10:24:25.016]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:25.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:25.016]                 ...future.rng), started = ...future.startTime, 
[10:24:25.016]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:25.016]             version = "1.8"), class = "FutureResult")
[10:24:25.016]     }, finally = {
[10:24:25.016]         if (!identical(...future.workdir, getwd())) 
[10:24:25.016]             setwd(...future.workdir)
[10:24:25.016]         {
[10:24:25.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:25.016]                 ...future.oldOptions$nwarnings <- NULL
[10:24:25.016]             }
[10:24:25.016]             base::options(...future.oldOptions)
[10:24:25.016]             if (.Platform$OS.type == "windows") {
[10:24:25.016]                 old_names <- names(...future.oldEnvVars)
[10:24:25.016]                 envs <- base::Sys.getenv()
[10:24:25.016]                 names <- names(envs)
[10:24:25.016]                 common <- intersect(names, old_names)
[10:24:25.016]                 added <- setdiff(names, old_names)
[10:24:25.016]                 removed <- setdiff(old_names, names)
[10:24:25.016]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:25.016]                   envs[common]]
[10:24:25.016]                 NAMES <- toupper(changed)
[10:24:25.016]                 args <- list()
[10:24:25.016]                 for (kk in seq_along(NAMES)) {
[10:24:25.016]                   name <- changed[[kk]]
[10:24:25.016]                   NAME <- NAMES[[kk]]
[10:24:25.016]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.016]                     next
[10:24:25.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:25.016]                 }
[10:24:25.016]                 NAMES <- toupper(added)
[10:24:25.016]                 for (kk in seq_along(NAMES)) {
[10:24:25.016]                   name <- added[[kk]]
[10:24:25.016]                   NAME <- NAMES[[kk]]
[10:24:25.016]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.016]                     next
[10:24:25.016]                   args[[name]] <- ""
[10:24:25.016]                 }
[10:24:25.016]                 NAMES <- toupper(removed)
[10:24:25.016]                 for (kk in seq_along(NAMES)) {
[10:24:25.016]                   name <- removed[[kk]]
[10:24:25.016]                   NAME <- NAMES[[kk]]
[10:24:25.016]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.016]                     next
[10:24:25.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:25.016]                 }
[10:24:25.016]                 if (length(args) > 0) 
[10:24:25.016]                   base::do.call(base::Sys.setenv, args = args)
[10:24:25.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:25.016]             }
[10:24:25.016]             else {
[10:24:25.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:25.016]             }
[10:24:25.016]             {
[10:24:25.016]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:25.016]                   0L) {
[10:24:25.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:25.016]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:25.016]                   base::options(opts)
[10:24:25.016]                 }
[10:24:25.016]                 {
[10:24:25.016]                   {
[10:24:25.016]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:25.016]                     NULL
[10:24:25.016]                   }
[10:24:25.016]                   options(future.plan = NULL)
[10:24:25.016]                   if (is.na(NA_character_)) 
[10:24:25.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:25.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:25.016]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:25.016]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:25.016]                     envir = parent.frame()) 
[10:24:25.016]                   {
[10:24:25.016]                     if (is.function(workers)) 
[10:24:25.016]                       workers <- workers()
[10:24:25.016]                     workers <- structure(as.integer(workers), 
[10:24:25.016]                       class = class(workers))
[10:24:25.016]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:25.016]                       workers >= 1)
[10:24:25.016]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:25.016]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:25.016]                     }
[10:24:25.016]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:25.016]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:25.016]                       envir = envir)
[10:24:25.016]                     if (!future$lazy) 
[10:24:25.016]                       future <- run(future)
[10:24:25.016]                     invisible(future)
[10:24:25.016]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:25.016]                 }
[10:24:25.016]             }
[10:24:25.016]         }
[10:24:25.016]     })
[10:24:25.016]     if (TRUE) {
[10:24:25.016]         base::sink(type = "output", split = FALSE)
[10:24:25.016]         if (TRUE) {
[10:24:25.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:25.016]         }
[10:24:25.016]         else {
[10:24:25.016]             ...future.result["stdout"] <- base::list(NULL)
[10:24:25.016]         }
[10:24:25.016]         base::close(...future.stdout)
[10:24:25.016]         ...future.stdout <- NULL
[10:24:25.016]     }
[10:24:25.016]     ...future.result$conditions <- ...future.conditions
[10:24:25.016]     ...future.result$finished <- base::Sys.time()
[10:24:25.016]     ...future.result
[10:24:25.016] }
[10:24:25.019] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[10:24:25.019] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:25.062] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:25.062] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[10:24:25.062] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[10:24:25.063] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:25.063] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:25.063] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:25.106] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:25.106] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:25.150] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:25.150] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:24:25.150] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.150] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[10:24:25.151] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[10:24:25.151] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:25.151] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.152] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[10:24:25.152] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[10:24:25.152] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:25.153] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.153] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:25.153] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.153] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[10:24:25.154] MultisessionFuture started
[10:24:25.154] - Launch lazy future ... done
[10:24:25.154] run() for ‘MultisessionFuture’ ... done
[10:24:25.155] Created future:
[10:24:25.155] MultisessionFuture:
[10:24:25.155] Label: ‘future_vapply-1’
[10:24:25.155] Expression:
[10:24:25.155] {
[10:24:25.155]     do.call(function(...) {
[10:24:25.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:25.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.155]             on.exit(options(oopts), add = TRUE)
[10:24:25.155]         }
[10:24:25.155]         {
[10:24:25.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:25.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.155]                 ...future.FUN(...future.X_jj, ...)
[10:24:25.155]             })
[10:24:25.155]         }
[10:24:25.155]     }, args = future.call.arguments)
[10:24:25.155] }
[10:24:25.155] Lazy evaluation: FALSE
[10:24:25.155] Asynchronous evaluation: TRUE
[10:24:25.155] Local evaluation: TRUE
[10:24:25.155] Environment: R_GlobalEnv
[10:24:25.155] Capture standard output: TRUE
[10:24:25.155] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:25.155] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:25.155] Packages: 1 packages (‘future.apply’)
[10:24:25.155] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:25.155] Resolved: FALSE
[10:24:25.155] Value: <not collected>
[10:24:25.155] Conditions captured: <none>
[10:24:25.155] Early signaling: FALSE
[10:24:25.155] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:25.155] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:25.166] Chunk #1 of 2 ... DONE
[10:24:25.167] Chunk #2 of 2 ...
[10:24:25.167]  - Finding globals in 'X' for chunk #2 ...
[10:24:25.167] getGlobalsAndPackages() ...
[10:24:25.167] Searching for globals...
[10:24:25.167] 
[10:24:25.167] Searching for globals ... DONE
[10:24:25.167] - globals: [0] <none>
[10:24:25.167] getGlobalsAndPackages() ... DONE
[10:24:25.168]    + additional globals found: [n=0] 
[10:24:25.168]    + additional namespaces needed: [n=0] 
[10:24:25.168]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:25.168]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:25.168]  - seeds: <none>
[10:24:25.168]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.168] getGlobalsAndPackages() ...
[10:24:25.168] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.168] Resolving globals: FALSE
[10:24:25.168] Tweak future expression to call with '...' arguments ...
[10:24:25.169] {
[10:24:25.169]     do.call(function(...) {
[10:24:25.169]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.169]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:25.169]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.169]             on.exit(options(oopts), add = TRUE)
[10:24:25.169]         }
[10:24:25.169]         {
[10:24:25.169]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:25.169]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.169]                 ...future.FUN(...future.X_jj, ...)
[10:24:25.169]             })
[10:24:25.169]         }
[10:24:25.169]     }, args = future.call.arguments)
[10:24:25.169] }
[10:24:25.169] Tweak future expression to call with '...' arguments ... DONE
[10:24:25.169] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.170] - packages: [1] ‘future.apply’
[10:24:25.170] getGlobalsAndPackages() ... DONE
[10:24:25.170] run() for ‘Future’ ...
[10:24:25.170] - state: ‘created’
[10:24:25.170] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:25.184] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:25.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:25.185]   - Field: ‘node’
[10:24:25.185]   - Field: ‘label’
[10:24:25.185]   - Field: ‘local’
[10:24:25.185]   - Field: ‘owner’
[10:24:25.185]   - Field: ‘envir’
[10:24:25.185]   - Field: ‘workers’
[10:24:25.185]   - Field: ‘packages’
[10:24:25.185]   - Field: ‘gc’
[10:24:25.185]   - Field: ‘conditions’
[10:24:25.185]   - Field: ‘persistent’
[10:24:25.186]   - Field: ‘expr’
[10:24:25.186]   - Field: ‘uuid’
[10:24:25.186]   - Field: ‘seed’
[10:24:25.186]   - Field: ‘version’
[10:24:25.186]   - Field: ‘result’
[10:24:25.186]   - Field: ‘asynchronous’
[10:24:25.186]   - Field: ‘calls’
[10:24:25.186]   - Field: ‘globals’
[10:24:25.186]   - Field: ‘stdout’
[10:24:25.186]   - Field: ‘earlySignal’
[10:24:25.186]   - Field: ‘lazy’
[10:24:25.187]   - Field: ‘state’
[10:24:25.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:25.187] - Launch lazy future ...
[10:24:25.187] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:25.187] Packages needed by future strategies (n = 0): <none>
[10:24:25.188] {
[10:24:25.188]     {
[10:24:25.188]         {
[10:24:25.188]             ...future.startTime <- base::Sys.time()
[10:24:25.188]             {
[10:24:25.188]                 {
[10:24:25.188]                   {
[10:24:25.188]                     {
[10:24:25.188]                       {
[10:24:25.188]                         base::local({
[10:24:25.188]                           has_future <- base::requireNamespace("future", 
[10:24:25.188]                             quietly = TRUE)
[10:24:25.188]                           if (has_future) {
[10:24:25.188]                             ns <- base::getNamespace("future")
[10:24:25.188]                             version <- ns[[".package"]][["version"]]
[10:24:25.188]                             if (is.null(version)) 
[10:24:25.188]                               version <- utils::packageVersion("future")
[10:24:25.188]                           }
[10:24:25.188]                           else {
[10:24:25.188]                             version <- NULL
[10:24:25.188]                           }
[10:24:25.188]                           if (!has_future || version < "1.8.0") {
[10:24:25.188]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:25.188]                               "", base::R.version$version.string), 
[10:24:25.188]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:25.188]                                 base::R.version$platform, 8 * 
[10:24:25.188]                                   base::.Machine$sizeof.pointer), 
[10:24:25.188]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:25.188]                                 "release", "version")], collapse = " "), 
[10:24:25.188]                               hostname = base::Sys.info()[["nodename"]])
[10:24:25.188]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:25.188]                               info)
[10:24:25.188]                             info <- base::paste(info, collapse = "; ")
[10:24:25.188]                             if (!has_future) {
[10:24:25.188]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:25.188]                                 info)
[10:24:25.188]                             }
[10:24:25.188]                             else {
[10:24:25.188]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:25.188]                                 info, version)
[10:24:25.188]                             }
[10:24:25.188]                             base::stop(msg)
[10:24:25.188]                           }
[10:24:25.188]                         })
[10:24:25.188]                       }
[10:24:25.188]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:25.188]                       base::options(mc.cores = 1L)
[10:24:25.188]                     }
[10:24:25.188]                     base::local({
[10:24:25.188]                       for (pkg in "future.apply") {
[10:24:25.188]                         base::loadNamespace(pkg)
[10:24:25.188]                         base::library(pkg, character.only = TRUE)
[10:24:25.188]                       }
[10:24:25.188]                     })
[10:24:25.188]                   }
[10:24:25.188]                   options(future.plan = NULL)
[10:24:25.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:25.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:25.188]                 }
[10:24:25.188]                 ...future.workdir <- getwd()
[10:24:25.188]             }
[10:24:25.188]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:25.188]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:25.188]         }
[10:24:25.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:25.188]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:25.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:25.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:25.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:25.188]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:25.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:25.188]             base::names(...future.oldOptions))
[10:24:25.188]     }
[10:24:25.188]     if (FALSE) {
[10:24:25.188]     }
[10:24:25.188]     else {
[10:24:25.188]         if (TRUE) {
[10:24:25.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:25.188]                 open = "w")
[10:24:25.188]         }
[10:24:25.188]         else {
[10:24:25.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:25.188]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:25.188]         }
[10:24:25.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:25.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:25.188]             base::sink(type = "output", split = FALSE)
[10:24:25.188]             base::close(...future.stdout)
[10:24:25.188]         }, add = TRUE)
[10:24:25.188]     }
[10:24:25.188]     ...future.frame <- base::sys.nframe()
[10:24:25.188]     ...future.conditions <- base::list()
[10:24:25.188]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:25.188]     if (FALSE) {
[10:24:25.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:25.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:25.188]     }
[10:24:25.188]     ...future.result <- base::tryCatch({
[10:24:25.188]         base::withCallingHandlers({
[10:24:25.188]             ...future.value <- base::withVisible(base::local({
[10:24:25.188]                 ...future.makeSendCondition <- base::local({
[10:24:25.188]                   sendCondition <- NULL
[10:24:25.188]                   function(frame = 1L) {
[10:24:25.188]                     if (is.function(sendCondition)) 
[10:24:25.188]                       return(sendCondition)
[10:24:25.188]                     ns <- getNamespace("parallel")
[10:24:25.188]                     if (exists("sendData", mode = "function", 
[10:24:25.188]                       envir = ns)) {
[10:24:25.188]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:25.188]                         envir = ns)
[10:24:25.188]                       envir <- sys.frame(frame)
[10:24:25.188]                       master <- NULL
[10:24:25.188]                       while (!identical(envir, .GlobalEnv) && 
[10:24:25.188]                         !identical(envir, emptyenv())) {
[10:24:25.188]                         if (exists("master", mode = "list", envir = envir, 
[10:24:25.188]                           inherits = FALSE)) {
[10:24:25.188]                           master <- get("master", mode = "list", 
[10:24:25.188]                             envir = envir, inherits = FALSE)
[10:24:25.188]                           if (inherits(master, c("SOCKnode", 
[10:24:25.188]                             "SOCK0node"))) {
[10:24:25.188]                             sendCondition <<- function(cond) {
[10:24:25.188]                               data <- list(type = "VALUE", value = cond, 
[10:24:25.188]                                 success = TRUE)
[10:24:25.188]                               parallel_sendData(master, data)
[10:24:25.188]                             }
[10:24:25.188]                             return(sendCondition)
[10:24:25.188]                           }
[10:24:25.188]                         }
[10:24:25.188]                         frame <- frame + 1L
[10:24:25.188]                         envir <- sys.frame(frame)
[10:24:25.188]                       }
[10:24:25.188]                     }
[10:24:25.188]                     sendCondition <<- function(cond) NULL
[10:24:25.188]                   }
[10:24:25.188]                 })
[10:24:25.188]                 withCallingHandlers({
[10:24:25.188]                   {
[10:24:25.188]                     do.call(function(...) {
[10:24:25.188]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.188]                       if (!identical(...future.globals.maxSize.org, 
[10:24:25.188]                         ...future.globals.maxSize)) {
[10:24:25.188]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.188]                         on.exit(options(oopts), add = TRUE)
[10:24:25.188]                       }
[10:24:25.188]                       {
[10:24:25.188]                         lapply(seq_along(...future.elements_ii), 
[10:24:25.188]                           FUN = function(jj) {
[10:24:25.188]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.188]                             ...future.FUN(...future.X_jj, ...)
[10:24:25.188]                           })
[10:24:25.188]                       }
[10:24:25.188]                     }, args = future.call.arguments)
[10:24:25.188]                   }
[10:24:25.188]                 }, immediateCondition = function(cond) {
[10:24:25.188]                   sendCondition <- ...future.makeSendCondition()
[10:24:25.188]                   sendCondition(cond)
[10:24:25.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.188]                   {
[10:24:25.188]                     inherits <- base::inherits
[10:24:25.188]                     invokeRestart <- base::invokeRestart
[10:24:25.188]                     is.null <- base::is.null
[10:24:25.188]                     muffled <- FALSE
[10:24:25.188]                     if (inherits(cond, "message")) {
[10:24:25.188]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:25.188]                       if (muffled) 
[10:24:25.188]                         invokeRestart("muffleMessage")
[10:24:25.188]                     }
[10:24:25.188]                     else if (inherits(cond, "warning")) {
[10:24:25.188]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:25.188]                       if (muffled) 
[10:24:25.188]                         invokeRestart("muffleWarning")
[10:24:25.188]                     }
[10:24:25.188]                     else if (inherits(cond, "condition")) {
[10:24:25.188]                       if (!is.null(pattern)) {
[10:24:25.188]                         computeRestarts <- base::computeRestarts
[10:24:25.188]                         grepl <- base::grepl
[10:24:25.188]                         restarts <- computeRestarts(cond)
[10:24:25.188]                         for (restart in restarts) {
[10:24:25.188]                           name <- restart$name
[10:24:25.188]                           if (is.null(name)) 
[10:24:25.188]                             next
[10:24:25.188]                           if (!grepl(pattern, name)) 
[10:24:25.188]                             next
[10:24:25.188]                           invokeRestart(restart)
[10:24:25.188]                           muffled <- TRUE
[10:24:25.188]                           break
[10:24:25.188]                         }
[10:24:25.188]                       }
[10:24:25.188]                     }
[10:24:25.188]                     invisible(muffled)
[10:24:25.188]                   }
[10:24:25.188]                   muffleCondition(cond)
[10:24:25.188]                 })
[10:24:25.188]             }))
[10:24:25.188]             future::FutureResult(value = ...future.value$value, 
[10:24:25.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:25.188]                   ...future.rng), globalenv = if (FALSE) 
[10:24:25.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:25.188]                     ...future.globalenv.names))
[10:24:25.188]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:25.188]         }, condition = base::local({
[10:24:25.188]             c <- base::c
[10:24:25.188]             inherits <- base::inherits
[10:24:25.188]             invokeRestart <- base::invokeRestart
[10:24:25.188]             length <- base::length
[10:24:25.188]             list <- base::list
[10:24:25.188]             seq.int <- base::seq.int
[10:24:25.188]             signalCondition <- base::signalCondition
[10:24:25.188]             sys.calls <- base::sys.calls
[10:24:25.188]             `[[` <- base::`[[`
[10:24:25.188]             `+` <- base::`+`
[10:24:25.188]             `<<-` <- base::`<<-`
[10:24:25.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:25.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:25.188]                   3L)]
[10:24:25.188]             }
[10:24:25.188]             function(cond) {
[10:24:25.188]                 is_error <- inherits(cond, "error")
[10:24:25.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:25.188]                   NULL)
[10:24:25.188]                 if (is_error) {
[10:24:25.188]                   sessionInformation <- function() {
[10:24:25.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:25.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:25.188]                       search = base::search(), system = base::Sys.info())
[10:24:25.188]                   }
[10:24:25.188]                   ...future.conditions[[length(...future.conditions) + 
[10:24:25.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:25.188]                     cond$call), session = sessionInformation(), 
[10:24:25.188]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:25.188]                   signalCondition(cond)
[10:24:25.188]                 }
[10:24:25.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:25.188]                 "immediateCondition"))) {
[10:24:25.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:25.188]                   ...future.conditions[[length(...future.conditions) + 
[10:24:25.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:25.188]                   if (TRUE && !signal) {
[10:24:25.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.188]                     {
[10:24:25.188]                       inherits <- base::inherits
[10:24:25.188]                       invokeRestart <- base::invokeRestart
[10:24:25.188]                       is.null <- base::is.null
[10:24:25.188]                       muffled <- FALSE
[10:24:25.188]                       if (inherits(cond, "message")) {
[10:24:25.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:25.188]                         if (muffled) 
[10:24:25.188]                           invokeRestart("muffleMessage")
[10:24:25.188]                       }
[10:24:25.188]                       else if (inherits(cond, "warning")) {
[10:24:25.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:25.188]                         if (muffled) 
[10:24:25.188]                           invokeRestart("muffleWarning")
[10:24:25.188]                       }
[10:24:25.188]                       else if (inherits(cond, "condition")) {
[10:24:25.188]                         if (!is.null(pattern)) {
[10:24:25.188]                           computeRestarts <- base::computeRestarts
[10:24:25.188]                           grepl <- base::grepl
[10:24:25.188]                           restarts <- computeRestarts(cond)
[10:24:25.188]                           for (restart in restarts) {
[10:24:25.188]                             name <- restart$name
[10:24:25.188]                             if (is.null(name)) 
[10:24:25.188]                               next
[10:24:25.188]                             if (!grepl(pattern, name)) 
[10:24:25.188]                               next
[10:24:25.188]                             invokeRestart(restart)
[10:24:25.188]                             muffled <- TRUE
[10:24:25.188]                             break
[10:24:25.188]                           }
[10:24:25.188]                         }
[10:24:25.188]                       }
[10:24:25.188]                       invisible(muffled)
[10:24:25.188]                     }
[10:24:25.188]                     muffleCondition(cond, pattern = "^muffle")
[10:24:25.188]                   }
[10:24:25.188]                 }
[10:24:25.188]                 else {
[10:24:25.188]                   if (TRUE) {
[10:24:25.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.188]                     {
[10:24:25.188]                       inherits <- base::inherits
[10:24:25.188]                       invokeRestart <- base::invokeRestart
[10:24:25.188]                       is.null <- base::is.null
[10:24:25.188]                       muffled <- FALSE
[10:24:25.188]                       if (inherits(cond, "message")) {
[10:24:25.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:25.188]                         if (muffled) 
[10:24:25.188]                           invokeRestart("muffleMessage")
[10:24:25.188]                       }
[10:24:25.188]                       else if (inherits(cond, "warning")) {
[10:24:25.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:25.188]                         if (muffled) 
[10:24:25.188]                           invokeRestart("muffleWarning")
[10:24:25.188]                       }
[10:24:25.188]                       else if (inherits(cond, "condition")) {
[10:24:25.188]                         if (!is.null(pattern)) {
[10:24:25.188]                           computeRestarts <- base::computeRestarts
[10:24:25.188]                           grepl <- base::grepl
[10:24:25.188]                           restarts <- computeRestarts(cond)
[10:24:25.188]                           for (restart in restarts) {
[10:24:25.188]                             name <- restart$name
[10:24:25.188]                             if (is.null(name)) 
[10:24:25.188]                               next
[10:24:25.188]                             if (!grepl(pattern, name)) 
[10:24:25.188]                               next
[10:24:25.188]                             invokeRestart(restart)
[10:24:25.188]                             muffled <- TRUE
[10:24:25.188]                             break
[10:24:25.188]                           }
[10:24:25.188]                         }
[10:24:25.188]                       }
[10:24:25.188]                       invisible(muffled)
[10:24:25.188]                     }
[10:24:25.188]                     muffleCondition(cond, pattern = "^muffle")
[10:24:25.188]                   }
[10:24:25.188]                 }
[10:24:25.188]             }
[10:24:25.188]         }))
[10:24:25.188]     }, error = function(ex) {
[10:24:25.188]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:25.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:25.188]                 ...future.rng), started = ...future.startTime, 
[10:24:25.188]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:25.188]             version = "1.8"), class = "FutureResult")
[10:24:25.188]     }, finally = {
[10:24:25.188]         if (!identical(...future.workdir, getwd())) 
[10:24:25.188]             setwd(...future.workdir)
[10:24:25.188]         {
[10:24:25.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:25.188]                 ...future.oldOptions$nwarnings <- NULL
[10:24:25.188]             }
[10:24:25.188]             base::options(...future.oldOptions)
[10:24:25.188]             if (.Platform$OS.type == "windows") {
[10:24:25.188]                 old_names <- names(...future.oldEnvVars)
[10:24:25.188]                 envs <- base::Sys.getenv()
[10:24:25.188]                 names <- names(envs)
[10:24:25.188]                 common <- intersect(names, old_names)
[10:24:25.188]                 added <- setdiff(names, old_names)
[10:24:25.188]                 removed <- setdiff(old_names, names)
[10:24:25.188]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:25.188]                   envs[common]]
[10:24:25.188]                 NAMES <- toupper(changed)
[10:24:25.188]                 args <- list()
[10:24:25.188]                 for (kk in seq_along(NAMES)) {
[10:24:25.188]                   name <- changed[[kk]]
[10:24:25.188]                   NAME <- NAMES[[kk]]
[10:24:25.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.188]                     next
[10:24:25.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:25.188]                 }
[10:24:25.188]                 NAMES <- toupper(added)
[10:24:25.188]                 for (kk in seq_along(NAMES)) {
[10:24:25.188]                   name <- added[[kk]]
[10:24:25.188]                   NAME <- NAMES[[kk]]
[10:24:25.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.188]                     next
[10:24:25.188]                   args[[name]] <- ""
[10:24:25.188]                 }
[10:24:25.188]                 NAMES <- toupper(removed)
[10:24:25.188]                 for (kk in seq_along(NAMES)) {
[10:24:25.188]                   name <- removed[[kk]]
[10:24:25.188]                   NAME <- NAMES[[kk]]
[10:24:25.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.188]                     next
[10:24:25.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:25.188]                 }
[10:24:25.188]                 if (length(args) > 0) 
[10:24:25.188]                   base::do.call(base::Sys.setenv, args = args)
[10:24:25.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:25.188]             }
[10:24:25.188]             else {
[10:24:25.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:25.188]             }
[10:24:25.188]             {
[10:24:25.188]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:25.188]                   0L) {
[10:24:25.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:25.188]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:25.188]                   base::options(opts)
[10:24:25.188]                 }
[10:24:25.188]                 {
[10:24:25.188]                   {
[10:24:25.188]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:25.188]                     NULL
[10:24:25.188]                   }
[10:24:25.188]                   options(future.plan = NULL)
[10:24:25.188]                   if (is.na(NA_character_)) 
[10:24:25.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:25.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:25.188]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:25.188]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:25.188]                     envir = parent.frame()) 
[10:24:25.188]                   {
[10:24:25.188]                     if (is.function(workers)) 
[10:24:25.188]                       workers <- workers()
[10:24:25.188]                     workers <- structure(as.integer(workers), 
[10:24:25.188]                       class = class(workers))
[10:24:25.188]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:25.188]                       workers >= 1)
[10:24:25.188]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:25.188]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:25.188]                     }
[10:24:25.188]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:25.188]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:25.188]                       envir = envir)
[10:24:25.188]                     if (!future$lazy) 
[10:24:25.188]                       future <- run(future)
[10:24:25.188]                     invisible(future)
[10:24:25.188]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:25.188]                 }
[10:24:25.188]             }
[10:24:25.188]         }
[10:24:25.188]     })
[10:24:25.188]     if (TRUE) {
[10:24:25.188]         base::sink(type = "output", split = FALSE)
[10:24:25.188]         if (TRUE) {
[10:24:25.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:25.188]         }
[10:24:25.188]         else {
[10:24:25.188]             ...future.result["stdout"] <- base::list(NULL)
[10:24:25.188]         }
[10:24:25.188]         base::close(...future.stdout)
[10:24:25.188]         ...future.stdout <- NULL
[10:24:25.188]     }
[10:24:25.188]     ...future.result$conditions <- ...future.conditions
[10:24:25.188]     ...future.result$finished <- base::Sys.time()
[10:24:25.188]     ...future.result
[10:24:25.188] }
[10:24:25.191] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[10:24:25.191] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:25.238] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:25.238] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[10:24:25.238] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[10:24:25.238] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:25.239] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:25.239] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:25.282] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:25.282] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:25.326] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:25.326] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:24:25.326] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:24:25.326] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[10:24:25.327] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[10:24:25.327] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:25.327] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:25.328] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[10:24:25.328] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[10:24:25.328] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:25.328] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:25.329] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:25.329] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:25.329] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[10:24:25.330] MultisessionFuture started
[10:24:25.330] - Launch lazy future ... done
[10:24:25.330] run() for ‘MultisessionFuture’ ... done
[10:24:25.330] Created future:
[10:24:25.330] MultisessionFuture:
[10:24:25.330] Label: ‘future_vapply-2’
[10:24:25.330] Expression:
[10:24:25.330] {
[10:24:25.330]     do.call(function(...) {
[10:24:25.330]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.330]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:25.330]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.330]             on.exit(options(oopts), add = TRUE)
[10:24:25.330]         }
[10:24:25.330]         {
[10:24:25.330]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:25.330]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.330]                 ...future.FUN(...future.X_jj, ...)
[10:24:25.330]             })
[10:24:25.330]         }
[10:24:25.330]     }, args = future.call.arguments)
[10:24:25.330] }
[10:24:25.330] Lazy evaluation: FALSE
[10:24:25.330] Asynchronous evaluation: TRUE
[10:24:25.330] Local evaluation: TRUE
[10:24:25.330] Environment: R_GlobalEnv
[10:24:25.330] Capture standard output: TRUE
[10:24:25.330] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:25.330] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:25.330] Packages: 1 packages (‘future.apply’)
[10:24:25.330] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:25.330] Resolved: FALSE
[10:24:25.330] Value: <not collected>
[10:24:25.330] Conditions captured: <none>
[10:24:25.330] Early signaling: FALSE
[10:24:25.330] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:25.330] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:25.342] Chunk #2 of 2 ... DONE
[10:24:25.342] Launching 2 futures (chunks) ... DONE
[10:24:25.342] Resolving 2 futures (chunks) ...
[10:24:25.342] resolve() on list ...
[10:24:25.343]  recursive: 0
[10:24:25.343]  length: 2
[10:24:25.343] 
[10:24:25.343] receiveMessageFromWorker() for ClusterFuture ...
[10:24:25.343] - Validating connection of MultisessionFuture
[10:24:25.344] - received message: FutureResult
[10:24:25.344] - Received FutureResult
[10:24:25.344] - Erased future from FutureRegistry
[10:24:25.344] result() for ClusterFuture ...
[10:24:25.344] - result already collected: FutureResult
[10:24:25.344] result() for ClusterFuture ... done
[10:24:25.344] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:25.344] Future #1
[10:24:25.344] result() for ClusterFuture ...
[10:24:25.344] - result already collected: FutureResult
[10:24:25.345] result() for ClusterFuture ... done
[10:24:25.345] result() for ClusterFuture ...
[10:24:25.345] - result already collected: FutureResult
[10:24:25.345] result() for ClusterFuture ... done
[10:24:25.345] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:25.345] - nx: 2
[10:24:25.345] - relay: TRUE
[10:24:25.345] - stdout: TRUE
[10:24:25.345] - signal: TRUE
[10:24:25.345] - resignal: FALSE
[10:24:25.345] - force: TRUE
[10:24:25.346] - relayed: [n=2] FALSE, FALSE
[10:24:25.346] - queued futures: [n=2] FALSE, FALSE
[10:24:25.346]  - until=1
[10:24:25.346]  - relaying element #1
[10:24:25.346] result() for ClusterFuture ...
[10:24:25.346] - result already collected: FutureResult
[10:24:25.346] result() for ClusterFuture ... done
[10:24:25.346] result() for ClusterFuture ...
[10:24:25.346] - result already collected: FutureResult
[10:24:25.346] result() for ClusterFuture ... done
[10:24:25.347] result() for ClusterFuture ...
[10:24:25.347] - result already collected: FutureResult
[10:24:25.347] result() for ClusterFuture ... done
[10:24:25.347] result() for ClusterFuture ...
[10:24:25.347] - result already collected: FutureResult
[10:24:25.347] result() for ClusterFuture ... done
[10:24:25.347] - relayed: [n=2] TRUE, FALSE
[10:24:25.347] - queued futures: [n=2] TRUE, FALSE
[10:24:25.347] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:25.347]  length: 1 (resolved future 1)
[10:24:25.378] receiveMessageFromWorker() for ClusterFuture ...
[10:24:25.379] - Validating connection of MultisessionFuture
[10:24:25.379] - received message: FutureResult
[10:24:25.379] - Received FutureResult
[10:24:25.379] - Erased future from FutureRegistry
[10:24:25.379] result() for ClusterFuture ...
[10:24:25.379] - result already collected: FutureResult
[10:24:25.379] result() for ClusterFuture ... done
[10:24:25.379] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:25.379] Future #2
[10:24:25.380] result() for ClusterFuture ...
[10:24:25.380] - result already collected: FutureResult
[10:24:25.380] result() for ClusterFuture ... done
[10:24:25.380] result() for ClusterFuture ...
[10:24:25.380] - result already collected: FutureResult
[10:24:25.380] result() for ClusterFuture ... done
[10:24:25.380] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:25.380] - nx: 2
[10:24:25.380] - relay: TRUE
[10:24:25.380] - stdout: TRUE
[10:24:25.380] - signal: TRUE
[10:24:25.381] - resignal: FALSE
[10:24:25.381] - force: TRUE
[10:24:25.381] - relayed: [n=2] TRUE, FALSE
[10:24:25.381] - queued futures: [n=2] TRUE, FALSE
[10:24:25.381]  - until=2
[10:24:25.381]  - relaying element #2
[10:24:25.381] result() for ClusterFuture ...
[10:24:25.381] - result already collected: FutureResult
[10:24:25.381] result() for ClusterFuture ... done
[10:24:25.381] result() for ClusterFuture ...
[10:24:25.381] - result already collected: FutureResult
[10:24:25.382] result() for ClusterFuture ... done
[10:24:25.382] result() for ClusterFuture ...
[10:24:25.382] - result already collected: FutureResult
[10:24:25.382] result() for ClusterFuture ... done
[10:24:25.382] result() for ClusterFuture ...
[10:24:25.382] - result already collected: FutureResult
[10:24:25.382] result() for ClusterFuture ... done
[10:24:25.382] - relayed: [n=2] TRUE, TRUE
[10:24:25.382] - queued futures: [n=2] TRUE, TRUE
[10:24:25.382] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:25.383]  length: 0 (resolved future 2)
[10:24:25.383] Relaying remaining futures
[10:24:25.383] signalConditionsASAP(NULL, pos=0) ...
[10:24:25.383] - nx: 2
[10:24:25.383] - relay: TRUE
[10:24:25.383] - stdout: TRUE
[10:24:25.383] - signal: TRUE
[10:24:25.383] - resignal: FALSE
[10:24:25.383] - force: TRUE
[10:24:25.383] - relayed: [n=2] TRUE, TRUE
[10:24:25.383] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:25.383] - relayed: [n=2] TRUE, TRUE
[10:24:25.384] - queued futures: [n=2] TRUE, TRUE
[10:24:25.384] signalConditionsASAP(NULL, pos=0) ... done
[10:24:25.384] resolve() on list ... DONE
[10:24:25.384] result() for ClusterFuture ...
[10:24:25.384] - result already collected: FutureResult
[10:24:25.384] result() for ClusterFuture ... done
[10:24:25.384] result() for ClusterFuture ...
[10:24:25.384] - result already collected: FutureResult
[10:24:25.384] result() for ClusterFuture ... done
[10:24:25.384] result() for ClusterFuture ...
[10:24:25.384] - result already collected: FutureResult
[10:24:25.385] result() for ClusterFuture ... done
[10:24:25.385] result() for ClusterFuture ...
[10:24:25.385] - result already collected: FutureResult
[10:24:25.385] result() for ClusterFuture ... done
[10:24:25.385]  - Number of value chunks collected: 2
[10:24:25.385] Resolving 2 futures (chunks) ... DONE
[10:24:25.385] Reducing values from 2 chunks ...
[10:24:25.385]  - Number of values collected after concatenation: 11
[10:24:25.385]  - Number of values expected: 11
[10:24:25.385] Reducing values from 2 chunks ... DONE
[10:24:25.386] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[10:24:25.386] future_lapply() ...
[10:24:25.392] Number of chunks: 2
[10:24:25.392] getGlobalsAndPackagesXApply() ...
[10:24:25.392]  - future.globals: TRUE
[10:24:25.392] getGlobalsAndPackages() ...
[10:24:25.392] Searching for globals...
[10:24:25.395] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:25.395] Searching for globals ... DONE
[10:24:25.395] Resolving globals: FALSE
[10:24:25.396] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[10:24:25.397] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:25.397] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:25.397] - packages: [1] ‘future.apply’
[10:24:25.397] getGlobalsAndPackages() ... DONE
[10:24:25.397]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:25.397]  - needed namespaces: [n=1] ‘future.apply’
[10:24:25.397] Finding globals ... DONE
[10:24:25.397]  - use_args: TRUE
[10:24:25.397]  - Getting '...' globals ...
[10:24:25.398] resolve() on list ...
[10:24:25.398]  recursive: 0
[10:24:25.398]  length: 1
[10:24:25.398]  elements: ‘...’
[10:24:25.398]  length: 0 (resolved future 1)
[10:24:25.398] resolve() on list ... DONE
[10:24:25.398]    - '...' content: [n=0] 
[10:24:25.398] List of 1
[10:24:25.398]  $ ...: list()
[10:24:25.398]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:25.398]  - attr(*, "where")=List of 1
[10:24:25.398]   ..$ ...:<environment: 0x55b93e6496f0> 
[10:24:25.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:25.398]  - attr(*, "resolved")= logi TRUE
[10:24:25.398]  - attr(*, "total_size")= num NA
[10:24:25.401]  - Getting '...' globals ... DONE
[10:24:25.401] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:25.401] List of 8
[10:24:25.401]  $ ...future.FUN:function (x, ...)  
[10:24:25.401]  $ x_FUN        :function (x)  
[10:24:25.401]  $ times        : int 1
[10:24:25.401]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:25.401]  $ stop_if_not  :function (...)  
[10:24:25.401]  $ dim          : NULL
[10:24:25.401]  $ valid_types  : chr [1:2] "logical" "integer"
[10:24:25.401]  $ ...          : list()
[10:24:25.401]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:25.401]  - attr(*, "where")=List of 8
[10:24:25.401]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:25.401]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:25.401]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:25.401]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:25.401]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:25.401]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:25.401]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:25.401]   ..$ ...          :<environment: 0x55b93e6496f0> 
[10:24:25.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:25.401]  - attr(*, "resolved")= logi FALSE
[10:24:25.401]  - attr(*, "total_size")= num 94264
[10:24:25.407] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:25.407] getGlobalsAndPackagesXApply() ... DONE
[10:24:25.407] Number of futures (= number of chunks): 2
[10:24:25.407] Launching 2 futures (chunks) ...
[10:24:25.407] Chunk #1 of 2 ...
[10:24:25.407]  - Finding globals in 'X' for chunk #1 ...
[10:24:25.407] getGlobalsAndPackages() ...
[10:24:25.407] Searching for globals...
[10:24:25.408] 
[10:24:25.408] Searching for globals ... DONE
[10:24:25.408] - globals: [0] <none>
[10:24:25.408] getGlobalsAndPackages() ... DONE
[10:24:25.408]    + additional globals found: [n=0] 
[10:24:25.408]    + additional namespaces needed: [n=0] 
[10:24:25.408]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:25.408]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:25.408]  - seeds: <none>
[10:24:25.409]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.409] getGlobalsAndPackages() ...
[10:24:25.409] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.409] Resolving globals: FALSE
[10:24:25.409] Tweak future expression to call with '...' arguments ...
[10:24:25.409] {
[10:24:25.409]     do.call(function(...) {
[10:24:25.409]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.409]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:25.409]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.409]             on.exit(options(oopts), add = TRUE)
[10:24:25.409]         }
[10:24:25.409]         {
[10:24:25.409]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:25.409]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.409]                 ...future.FUN(...future.X_jj, ...)
[10:24:25.409]             })
[10:24:25.409]         }
[10:24:25.409]     }, args = future.call.arguments)
[10:24:25.409] }
[10:24:25.409] Tweak future expression to call with '...' arguments ... DONE
[10:24:25.410] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.410] - packages: [1] ‘future.apply’
[10:24:25.410] getGlobalsAndPackages() ... DONE
[10:24:25.410] run() for ‘Future’ ...
[10:24:25.411] - state: ‘created’
[10:24:25.411] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:25.425] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:25.425] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:25.425]   - Field: ‘node’
[10:24:25.425]   - Field: ‘label’
[10:24:25.425]   - Field: ‘local’
[10:24:25.425]   - Field: ‘owner’
[10:24:25.425]   - Field: ‘envir’
[10:24:25.425]   - Field: ‘workers’
[10:24:25.425]   - Field: ‘packages’
[10:24:25.426]   - Field: ‘gc’
[10:24:25.426]   - Field: ‘conditions’
[10:24:25.426]   - Field: ‘persistent’
[10:24:25.426]   - Field: ‘expr’
[10:24:25.426]   - Field: ‘uuid’
[10:24:25.426]   - Field: ‘seed’
[10:24:25.426]   - Field: ‘version’
[10:24:25.426]   - Field: ‘result’
[10:24:25.426]   - Field: ‘asynchronous’
[10:24:25.426]   - Field: ‘calls’
[10:24:25.426]   - Field: ‘globals’
[10:24:25.427]   - Field: ‘stdout’
[10:24:25.427]   - Field: ‘earlySignal’
[10:24:25.427]   - Field: ‘lazy’
[10:24:25.427]   - Field: ‘state’
[10:24:25.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:25.427] - Launch lazy future ...
[10:24:25.427] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:25.427] Packages needed by future strategies (n = 0): <none>
[10:24:25.428] {
[10:24:25.428]     {
[10:24:25.428]         {
[10:24:25.428]             ...future.startTime <- base::Sys.time()
[10:24:25.428]             {
[10:24:25.428]                 {
[10:24:25.428]                   {
[10:24:25.428]                     {
[10:24:25.428]                       {
[10:24:25.428]                         base::local({
[10:24:25.428]                           has_future <- base::requireNamespace("future", 
[10:24:25.428]                             quietly = TRUE)
[10:24:25.428]                           if (has_future) {
[10:24:25.428]                             ns <- base::getNamespace("future")
[10:24:25.428]                             version <- ns[[".package"]][["version"]]
[10:24:25.428]                             if (is.null(version)) 
[10:24:25.428]                               version <- utils::packageVersion("future")
[10:24:25.428]                           }
[10:24:25.428]                           else {
[10:24:25.428]                             version <- NULL
[10:24:25.428]                           }
[10:24:25.428]                           if (!has_future || version < "1.8.0") {
[10:24:25.428]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:25.428]                               "", base::R.version$version.string), 
[10:24:25.428]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:25.428]                                 base::R.version$platform, 8 * 
[10:24:25.428]                                   base::.Machine$sizeof.pointer), 
[10:24:25.428]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:25.428]                                 "release", "version")], collapse = " "), 
[10:24:25.428]                               hostname = base::Sys.info()[["nodename"]])
[10:24:25.428]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:25.428]                               info)
[10:24:25.428]                             info <- base::paste(info, collapse = "; ")
[10:24:25.428]                             if (!has_future) {
[10:24:25.428]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:25.428]                                 info)
[10:24:25.428]                             }
[10:24:25.428]                             else {
[10:24:25.428]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:25.428]                                 info, version)
[10:24:25.428]                             }
[10:24:25.428]                             base::stop(msg)
[10:24:25.428]                           }
[10:24:25.428]                         })
[10:24:25.428]                       }
[10:24:25.428]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:25.428]                       base::options(mc.cores = 1L)
[10:24:25.428]                     }
[10:24:25.428]                     base::local({
[10:24:25.428]                       for (pkg in "future.apply") {
[10:24:25.428]                         base::loadNamespace(pkg)
[10:24:25.428]                         base::library(pkg, character.only = TRUE)
[10:24:25.428]                       }
[10:24:25.428]                     })
[10:24:25.428]                   }
[10:24:25.428]                   options(future.plan = NULL)
[10:24:25.428]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:25.428]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:25.428]                 }
[10:24:25.428]                 ...future.workdir <- getwd()
[10:24:25.428]             }
[10:24:25.428]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:25.428]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:25.428]         }
[10:24:25.428]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:25.428]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:25.428]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:25.428]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:25.428]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:25.428]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:25.428]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:25.428]             base::names(...future.oldOptions))
[10:24:25.428]     }
[10:24:25.428]     if (FALSE) {
[10:24:25.428]     }
[10:24:25.428]     else {
[10:24:25.428]         if (TRUE) {
[10:24:25.428]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:25.428]                 open = "w")
[10:24:25.428]         }
[10:24:25.428]         else {
[10:24:25.428]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:25.428]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:25.428]         }
[10:24:25.428]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:25.428]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:25.428]             base::sink(type = "output", split = FALSE)
[10:24:25.428]             base::close(...future.stdout)
[10:24:25.428]         }, add = TRUE)
[10:24:25.428]     }
[10:24:25.428]     ...future.frame <- base::sys.nframe()
[10:24:25.428]     ...future.conditions <- base::list()
[10:24:25.428]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:25.428]     if (FALSE) {
[10:24:25.428]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:25.428]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:25.428]     }
[10:24:25.428]     ...future.result <- base::tryCatch({
[10:24:25.428]         base::withCallingHandlers({
[10:24:25.428]             ...future.value <- base::withVisible(base::local({
[10:24:25.428]                 ...future.makeSendCondition <- base::local({
[10:24:25.428]                   sendCondition <- NULL
[10:24:25.428]                   function(frame = 1L) {
[10:24:25.428]                     if (is.function(sendCondition)) 
[10:24:25.428]                       return(sendCondition)
[10:24:25.428]                     ns <- getNamespace("parallel")
[10:24:25.428]                     if (exists("sendData", mode = "function", 
[10:24:25.428]                       envir = ns)) {
[10:24:25.428]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:25.428]                         envir = ns)
[10:24:25.428]                       envir <- sys.frame(frame)
[10:24:25.428]                       master <- NULL
[10:24:25.428]                       while (!identical(envir, .GlobalEnv) && 
[10:24:25.428]                         !identical(envir, emptyenv())) {
[10:24:25.428]                         if (exists("master", mode = "list", envir = envir, 
[10:24:25.428]                           inherits = FALSE)) {
[10:24:25.428]                           master <- get("master", mode = "list", 
[10:24:25.428]                             envir = envir, inherits = FALSE)
[10:24:25.428]                           if (inherits(master, c("SOCKnode", 
[10:24:25.428]                             "SOCK0node"))) {
[10:24:25.428]                             sendCondition <<- function(cond) {
[10:24:25.428]                               data <- list(type = "VALUE", value = cond, 
[10:24:25.428]                                 success = TRUE)
[10:24:25.428]                               parallel_sendData(master, data)
[10:24:25.428]                             }
[10:24:25.428]                             return(sendCondition)
[10:24:25.428]                           }
[10:24:25.428]                         }
[10:24:25.428]                         frame <- frame + 1L
[10:24:25.428]                         envir <- sys.frame(frame)
[10:24:25.428]                       }
[10:24:25.428]                     }
[10:24:25.428]                     sendCondition <<- function(cond) NULL
[10:24:25.428]                   }
[10:24:25.428]                 })
[10:24:25.428]                 withCallingHandlers({
[10:24:25.428]                   {
[10:24:25.428]                     do.call(function(...) {
[10:24:25.428]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.428]                       if (!identical(...future.globals.maxSize.org, 
[10:24:25.428]                         ...future.globals.maxSize)) {
[10:24:25.428]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.428]                         on.exit(options(oopts), add = TRUE)
[10:24:25.428]                       }
[10:24:25.428]                       {
[10:24:25.428]                         lapply(seq_along(...future.elements_ii), 
[10:24:25.428]                           FUN = function(jj) {
[10:24:25.428]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.428]                             ...future.FUN(...future.X_jj, ...)
[10:24:25.428]                           })
[10:24:25.428]                       }
[10:24:25.428]                     }, args = future.call.arguments)
[10:24:25.428]                   }
[10:24:25.428]                 }, immediateCondition = function(cond) {
[10:24:25.428]                   sendCondition <- ...future.makeSendCondition()
[10:24:25.428]                   sendCondition(cond)
[10:24:25.428]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.428]                   {
[10:24:25.428]                     inherits <- base::inherits
[10:24:25.428]                     invokeRestart <- base::invokeRestart
[10:24:25.428]                     is.null <- base::is.null
[10:24:25.428]                     muffled <- FALSE
[10:24:25.428]                     if (inherits(cond, "message")) {
[10:24:25.428]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:25.428]                       if (muffled) 
[10:24:25.428]                         invokeRestart("muffleMessage")
[10:24:25.428]                     }
[10:24:25.428]                     else if (inherits(cond, "warning")) {
[10:24:25.428]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:25.428]                       if (muffled) 
[10:24:25.428]                         invokeRestart("muffleWarning")
[10:24:25.428]                     }
[10:24:25.428]                     else if (inherits(cond, "condition")) {
[10:24:25.428]                       if (!is.null(pattern)) {
[10:24:25.428]                         computeRestarts <- base::computeRestarts
[10:24:25.428]                         grepl <- base::grepl
[10:24:25.428]                         restarts <- computeRestarts(cond)
[10:24:25.428]                         for (restart in restarts) {
[10:24:25.428]                           name <- restart$name
[10:24:25.428]                           if (is.null(name)) 
[10:24:25.428]                             next
[10:24:25.428]                           if (!grepl(pattern, name)) 
[10:24:25.428]                             next
[10:24:25.428]                           invokeRestart(restart)
[10:24:25.428]                           muffled <- TRUE
[10:24:25.428]                           break
[10:24:25.428]                         }
[10:24:25.428]                       }
[10:24:25.428]                     }
[10:24:25.428]                     invisible(muffled)
[10:24:25.428]                   }
[10:24:25.428]                   muffleCondition(cond)
[10:24:25.428]                 })
[10:24:25.428]             }))
[10:24:25.428]             future::FutureResult(value = ...future.value$value, 
[10:24:25.428]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:25.428]                   ...future.rng), globalenv = if (FALSE) 
[10:24:25.428]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:25.428]                     ...future.globalenv.names))
[10:24:25.428]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:25.428]         }, condition = base::local({
[10:24:25.428]             c <- base::c
[10:24:25.428]             inherits <- base::inherits
[10:24:25.428]             invokeRestart <- base::invokeRestart
[10:24:25.428]             length <- base::length
[10:24:25.428]             list <- base::list
[10:24:25.428]             seq.int <- base::seq.int
[10:24:25.428]             signalCondition <- base::signalCondition
[10:24:25.428]             sys.calls <- base::sys.calls
[10:24:25.428]             `[[` <- base::`[[`
[10:24:25.428]             `+` <- base::`+`
[10:24:25.428]             `<<-` <- base::`<<-`
[10:24:25.428]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:25.428]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:25.428]                   3L)]
[10:24:25.428]             }
[10:24:25.428]             function(cond) {
[10:24:25.428]                 is_error <- inherits(cond, "error")
[10:24:25.428]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:25.428]                   NULL)
[10:24:25.428]                 if (is_error) {
[10:24:25.428]                   sessionInformation <- function() {
[10:24:25.428]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:25.428]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:25.428]                       search = base::search(), system = base::Sys.info())
[10:24:25.428]                   }
[10:24:25.428]                   ...future.conditions[[length(...future.conditions) + 
[10:24:25.428]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:25.428]                     cond$call), session = sessionInformation(), 
[10:24:25.428]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:25.428]                   signalCondition(cond)
[10:24:25.428]                 }
[10:24:25.428]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:25.428]                 "immediateCondition"))) {
[10:24:25.428]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:25.428]                   ...future.conditions[[length(...future.conditions) + 
[10:24:25.428]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:25.428]                   if (TRUE && !signal) {
[10:24:25.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.428]                     {
[10:24:25.428]                       inherits <- base::inherits
[10:24:25.428]                       invokeRestart <- base::invokeRestart
[10:24:25.428]                       is.null <- base::is.null
[10:24:25.428]                       muffled <- FALSE
[10:24:25.428]                       if (inherits(cond, "message")) {
[10:24:25.428]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:25.428]                         if (muffled) 
[10:24:25.428]                           invokeRestart("muffleMessage")
[10:24:25.428]                       }
[10:24:25.428]                       else if (inherits(cond, "warning")) {
[10:24:25.428]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:25.428]                         if (muffled) 
[10:24:25.428]                           invokeRestart("muffleWarning")
[10:24:25.428]                       }
[10:24:25.428]                       else if (inherits(cond, "condition")) {
[10:24:25.428]                         if (!is.null(pattern)) {
[10:24:25.428]                           computeRestarts <- base::computeRestarts
[10:24:25.428]                           grepl <- base::grepl
[10:24:25.428]                           restarts <- computeRestarts(cond)
[10:24:25.428]                           for (restart in restarts) {
[10:24:25.428]                             name <- restart$name
[10:24:25.428]                             if (is.null(name)) 
[10:24:25.428]                               next
[10:24:25.428]                             if (!grepl(pattern, name)) 
[10:24:25.428]                               next
[10:24:25.428]                             invokeRestart(restart)
[10:24:25.428]                             muffled <- TRUE
[10:24:25.428]                             break
[10:24:25.428]                           }
[10:24:25.428]                         }
[10:24:25.428]                       }
[10:24:25.428]                       invisible(muffled)
[10:24:25.428]                     }
[10:24:25.428]                     muffleCondition(cond, pattern = "^muffle")
[10:24:25.428]                   }
[10:24:25.428]                 }
[10:24:25.428]                 else {
[10:24:25.428]                   if (TRUE) {
[10:24:25.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.428]                     {
[10:24:25.428]                       inherits <- base::inherits
[10:24:25.428]                       invokeRestart <- base::invokeRestart
[10:24:25.428]                       is.null <- base::is.null
[10:24:25.428]                       muffled <- FALSE
[10:24:25.428]                       if (inherits(cond, "message")) {
[10:24:25.428]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:25.428]                         if (muffled) 
[10:24:25.428]                           invokeRestart("muffleMessage")
[10:24:25.428]                       }
[10:24:25.428]                       else if (inherits(cond, "warning")) {
[10:24:25.428]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:25.428]                         if (muffled) 
[10:24:25.428]                           invokeRestart("muffleWarning")
[10:24:25.428]                       }
[10:24:25.428]                       else if (inherits(cond, "condition")) {
[10:24:25.428]                         if (!is.null(pattern)) {
[10:24:25.428]                           computeRestarts <- base::computeRestarts
[10:24:25.428]                           grepl <- base::grepl
[10:24:25.428]                           restarts <- computeRestarts(cond)
[10:24:25.428]                           for (restart in restarts) {
[10:24:25.428]                             name <- restart$name
[10:24:25.428]                             if (is.null(name)) 
[10:24:25.428]                               next
[10:24:25.428]                             if (!grepl(pattern, name)) 
[10:24:25.428]                               next
[10:24:25.428]                             invokeRestart(restart)
[10:24:25.428]                             muffled <- TRUE
[10:24:25.428]                             break
[10:24:25.428]                           }
[10:24:25.428]                         }
[10:24:25.428]                       }
[10:24:25.428]                       invisible(muffled)
[10:24:25.428]                     }
[10:24:25.428]                     muffleCondition(cond, pattern = "^muffle")
[10:24:25.428]                   }
[10:24:25.428]                 }
[10:24:25.428]             }
[10:24:25.428]         }))
[10:24:25.428]     }, error = function(ex) {
[10:24:25.428]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:25.428]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:25.428]                 ...future.rng), started = ...future.startTime, 
[10:24:25.428]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:25.428]             version = "1.8"), class = "FutureResult")
[10:24:25.428]     }, finally = {
[10:24:25.428]         if (!identical(...future.workdir, getwd())) 
[10:24:25.428]             setwd(...future.workdir)
[10:24:25.428]         {
[10:24:25.428]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:25.428]                 ...future.oldOptions$nwarnings <- NULL
[10:24:25.428]             }
[10:24:25.428]             base::options(...future.oldOptions)
[10:24:25.428]             if (.Platform$OS.type == "windows") {
[10:24:25.428]                 old_names <- names(...future.oldEnvVars)
[10:24:25.428]                 envs <- base::Sys.getenv()
[10:24:25.428]                 names <- names(envs)
[10:24:25.428]                 common <- intersect(names, old_names)
[10:24:25.428]                 added <- setdiff(names, old_names)
[10:24:25.428]                 removed <- setdiff(old_names, names)
[10:24:25.428]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:25.428]                   envs[common]]
[10:24:25.428]                 NAMES <- toupper(changed)
[10:24:25.428]                 args <- list()
[10:24:25.428]                 for (kk in seq_along(NAMES)) {
[10:24:25.428]                   name <- changed[[kk]]
[10:24:25.428]                   NAME <- NAMES[[kk]]
[10:24:25.428]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.428]                     next
[10:24:25.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:25.428]                 }
[10:24:25.428]                 NAMES <- toupper(added)
[10:24:25.428]                 for (kk in seq_along(NAMES)) {
[10:24:25.428]                   name <- added[[kk]]
[10:24:25.428]                   NAME <- NAMES[[kk]]
[10:24:25.428]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.428]                     next
[10:24:25.428]                   args[[name]] <- ""
[10:24:25.428]                 }
[10:24:25.428]                 NAMES <- toupper(removed)
[10:24:25.428]                 for (kk in seq_along(NAMES)) {
[10:24:25.428]                   name <- removed[[kk]]
[10:24:25.428]                   NAME <- NAMES[[kk]]
[10:24:25.428]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.428]                     next
[10:24:25.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:25.428]                 }
[10:24:25.428]                 if (length(args) > 0) 
[10:24:25.428]                   base::do.call(base::Sys.setenv, args = args)
[10:24:25.428]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:25.428]             }
[10:24:25.428]             else {
[10:24:25.428]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:25.428]             }
[10:24:25.428]             {
[10:24:25.428]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:25.428]                   0L) {
[10:24:25.428]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:25.428]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:25.428]                   base::options(opts)
[10:24:25.428]                 }
[10:24:25.428]                 {
[10:24:25.428]                   {
[10:24:25.428]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:25.428]                     NULL
[10:24:25.428]                   }
[10:24:25.428]                   options(future.plan = NULL)
[10:24:25.428]                   if (is.na(NA_character_)) 
[10:24:25.428]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:25.428]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:25.428]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:25.428]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:25.428]                     envir = parent.frame()) 
[10:24:25.428]                   {
[10:24:25.428]                     if (is.function(workers)) 
[10:24:25.428]                       workers <- workers()
[10:24:25.428]                     workers <- structure(as.integer(workers), 
[10:24:25.428]                       class = class(workers))
[10:24:25.428]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:25.428]                       workers >= 1)
[10:24:25.428]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:25.428]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:25.428]                     }
[10:24:25.428]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:25.428]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:25.428]                       envir = envir)
[10:24:25.428]                     if (!future$lazy) 
[10:24:25.428]                       future <- run(future)
[10:24:25.428]                     invisible(future)
[10:24:25.428]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:25.428]                 }
[10:24:25.428]             }
[10:24:25.428]         }
[10:24:25.428]     })
[10:24:25.428]     if (TRUE) {
[10:24:25.428]         base::sink(type = "output", split = FALSE)
[10:24:25.428]         if (TRUE) {
[10:24:25.428]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:25.428]         }
[10:24:25.428]         else {
[10:24:25.428]             ...future.result["stdout"] <- base::list(NULL)
[10:24:25.428]         }
[10:24:25.428]         base::close(...future.stdout)
[10:24:25.428]         ...future.stdout <- NULL
[10:24:25.428]     }
[10:24:25.428]     ...future.result$conditions <- ...future.conditions
[10:24:25.428]     ...future.result$finished <- base::Sys.time()
[10:24:25.428]     ...future.result
[10:24:25.428] }
[10:24:25.431] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[10:24:25.431] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:25.474] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:25.474] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[10:24:25.474] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[10:24:25.475] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:25.475] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:25.475] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:25.518] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:25.518] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:25.562] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:25.562] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:24:25.562] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.562] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[10:24:25.563] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[10:24:25.563] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:25.563] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.564] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:24:25.564] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:24:25.564] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:25.565] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.565] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:25.565] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.565] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[10:24:25.566] MultisessionFuture started
[10:24:25.566] - Launch lazy future ... done
[10:24:25.566] run() for ‘MultisessionFuture’ ... done
[10:24:25.566] Created future:
[10:24:25.567] MultisessionFuture:
[10:24:25.567] Label: ‘future_vapply-1’
[10:24:25.567] Expression:
[10:24:25.567] {
[10:24:25.567]     do.call(function(...) {
[10:24:25.567]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.567]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:25.567]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.567]             on.exit(options(oopts), add = TRUE)
[10:24:25.567]         }
[10:24:25.567]         {
[10:24:25.567]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:25.567]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.567]                 ...future.FUN(...future.X_jj, ...)
[10:24:25.567]             })
[10:24:25.567]         }
[10:24:25.567]     }, args = future.call.arguments)
[10:24:25.567] }
[10:24:25.567] Lazy evaluation: FALSE
[10:24:25.567] Asynchronous evaluation: TRUE
[10:24:25.567] Local evaluation: TRUE
[10:24:25.567] Environment: R_GlobalEnv
[10:24:25.567] Capture standard output: TRUE
[10:24:25.567] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:25.567] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:25.567] Packages: 1 packages (‘future.apply’)
[10:24:25.567] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:25.567] Resolved: FALSE
[10:24:25.567] Value: <not collected>
[10:24:25.567] Conditions captured: <none>
[10:24:25.567] Early signaling: FALSE
[10:24:25.567] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:25.567] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:25.578] Chunk #1 of 2 ... DONE
[10:24:25.578] Chunk #2 of 2 ...
[10:24:25.578]  - Finding globals in 'X' for chunk #2 ...
[10:24:25.579] getGlobalsAndPackages() ...
[10:24:25.579] Searching for globals...
[10:24:25.579] 
[10:24:25.579] Searching for globals ... DONE
[10:24:25.579] - globals: [0] <none>
[10:24:25.579] getGlobalsAndPackages() ... DONE
[10:24:25.579]    + additional globals found: [n=0] 
[10:24:25.579]    + additional namespaces needed: [n=0] 
[10:24:25.580]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:25.583]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:25.583]  - seeds: <none>
[10:24:25.583]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.583] getGlobalsAndPackages() ...
[10:24:25.583] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.583] Resolving globals: FALSE
[10:24:25.583] Tweak future expression to call with '...' arguments ...
[10:24:25.583] {
[10:24:25.583]     do.call(function(...) {
[10:24:25.583]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.583]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:25.583]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.583]             on.exit(options(oopts), add = TRUE)
[10:24:25.583]         }
[10:24:25.583]         {
[10:24:25.583]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:25.583]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.583]                 ...future.FUN(...future.X_jj, ...)
[10:24:25.583]             })
[10:24:25.583]         }
[10:24:25.583]     }, args = future.call.arguments)
[10:24:25.583] }
[10:24:25.584] Tweak future expression to call with '...' arguments ... DONE
[10:24:25.584] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.584] - packages: [1] ‘future.apply’
[10:24:25.584] getGlobalsAndPackages() ... DONE
[10:24:25.585] run() for ‘Future’ ...
[10:24:25.585] - state: ‘created’
[10:24:25.585] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:25.599] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:25.599] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:25.599]   - Field: ‘node’
[10:24:25.600]   - Field: ‘label’
[10:24:25.600]   - Field: ‘local’
[10:24:25.600]   - Field: ‘owner’
[10:24:25.600]   - Field: ‘envir’
[10:24:25.600]   - Field: ‘workers’
[10:24:25.600]   - Field: ‘packages’
[10:24:25.600]   - Field: ‘gc’
[10:24:25.600]   - Field: ‘conditions’
[10:24:25.600]   - Field: ‘persistent’
[10:24:25.600]   - Field: ‘expr’
[10:24:25.600]   - Field: ‘uuid’
[10:24:25.601]   - Field: ‘seed’
[10:24:25.601]   - Field: ‘version’
[10:24:25.601]   - Field: ‘result’
[10:24:25.601]   - Field: ‘asynchronous’
[10:24:25.601]   - Field: ‘calls’
[10:24:25.601]   - Field: ‘globals’
[10:24:25.601]   - Field: ‘stdout’
[10:24:25.601]   - Field: ‘earlySignal’
[10:24:25.601]   - Field: ‘lazy’
[10:24:25.601]   - Field: ‘state’
[10:24:25.602] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:25.602] - Launch lazy future ...
[10:24:25.602] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:25.602] Packages needed by future strategies (n = 0): <none>
[10:24:25.603] {
[10:24:25.603]     {
[10:24:25.603]         {
[10:24:25.603]             ...future.startTime <- base::Sys.time()
[10:24:25.603]             {
[10:24:25.603]                 {
[10:24:25.603]                   {
[10:24:25.603]                     {
[10:24:25.603]                       {
[10:24:25.603]                         base::local({
[10:24:25.603]                           has_future <- base::requireNamespace("future", 
[10:24:25.603]                             quietly = TRUE)
[10:24:25.603]                           if (has_future) {
[10:24:25.603]                             ns <- base::getNamespace("future")
[10:24:25.603]                             version <- ns[[".package"]][["version"]]
[10:24:25.603]                             if (is.null(version)) 
[10:24:25.603]                               version <- utils::packageVersion("future")
[10:24:25.603]                           }
[10:24:25.603]                           else {
[10:24:25.603]                             version <- NULL
[10:24:25.603]                           }
[10:24:25.603]                           if (!has_future || version < "1.8.0") {
[10:24:25.603]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:25.603]                               "", base::R.version$version.string), 
[10:24:25.603]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:25.603]                                 base::R.version$platform, 8 * 
[10:24:25.603]                                   base::.Machine$sizeof.pointer), 
[10:24:25.603]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:25.603]                                 "release", "version")], collapse = " "), 
[10:24:25.603]                               hostname = base::Sys.info()[["nodename"]])
[10:24:25.603]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:25.603]                               info)
[10:24:25.603]                             info <- base::paste(info, collapse = "; ")
[10:24:25.603]                             if (!has_future) {
[10:24:25.603]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:25.603]                                 info)
[10:24:25.603]                             }
[10:24:25.603]                             else {
[10:24:25.603]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:25.603]                                 info, version)
[10:24:25.603]                             }
[10:24:25.603]                             base::stop(msg)
[10:24:25.603]                           }
[10:24:25.603]                         })
[10:24:25.603]                       }
[10:24:25.603]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:25.603]                       base::options(mc.cores = 1L)
[10:24:25.603]                     }
[10:24:25.603]                     base::local({
[10:24:25.603]                       for (pkg in "future.apply") {
[10:24:25.603]                         base::loadNamespace(pkg)
[10:24:25.603]                         base::library(pkg, character.only = TRUE)
[10:24:25.603]                       }
[10:24:25.603]                     })
[10:24:25.603]                   }
[10:24:25.603]                   options(future.plan = NULL)
[10:24:25.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:25.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:25.603]                 }
[10:24:25.603]                 ...future.workdir <- getwd()
[10:24:25.603]             }
[10:24:25.603]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:25.603]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:25.603]         }
[10:24:25.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:25.603]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:25.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:25.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:25.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:25.603]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:25.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:25.603]             base::names(...future.oldOptions))
[10:24:25.603]     }
[10:24:25.603]     if (FALSE) {
[10:24:25.603]     }
[10:24:25.603]     else {
[10:24:25.603]         if (TRUE) {
[10:24:25.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:25.603]                 open = "w")
[10:24:25.603]         }
[10:24:25.603]         else {
[10:24:25.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:25.603]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:25.603]         }
[10:24:25.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:25.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:25.603]             base::sink(type = "output", split = FALSE)
[10:24:25.603]             base::close(...future.stdout)
[10:24:25.603]         }, add = TRUE)
[10:24:25.603]     }
[10:24:25.603]     ...future.frame <- base::sys.nframe()
[10:24:25.603]     ...future.conditions <- base::list()
[10:24:25.603]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:25.603]     if (FALSE) {
[10:24:25.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:25.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:25.603]     }
[10:24:25.603]     ...future.result <- base::tryCatch({
[10:24:25.603]         base::withCallingHandlers({
[10:24:25.603]             ...future.value <- base::withVisible(base::local({
[10:24:25.603]                 ...future.makeSendCondition <- base::local({
[10:24:25.603]                   sendCondition <- NULL
[10:24:25.603]                   function(frame = 1L) {
[10:24:25.603]                     if (is.function(sendCondition)) 
[10:24:25.603]                       return(sendCondition)
[10:24:25.603]                     ns <- getNamespace("parallel")
[10:24:25.603]                     if (exists("sendData", mode = "function", 
[10:24:25.603]                       envir = ns)) {
[10:24:25.603]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:25.603]                         envir = ns)
[10:24:25.603]                       envir <- sys.frame(frame)
[10:24:25.603]                       master <- NULL
[10:24:25.603]                       while (!identical(envir, .GlobalEnv) && 
[10:24:25.603]                         !identical(envir, emptyenv())) {
[10:24:25.603]                         if (exists("master", mode = "list", envir = envir, 
[10:24:25.603]                           inherits = FALSE)) {
[10:24:25.603]                           master <- get("master", mode = "list", 
[10:24:25.603]                             envir = envir, inherits = FALSE)
[10:24:25.603]                           if (inherits(master, c("SOCKnode", 
[10:24:25.603]                             "SOCK0node"))) {
[10:24:25.603]                             sendCondition <<- function(cond) {
[10:24:25.603]                               data <- list(type = "VALUE", value = cond, 
[10:24:25.603]                                 success = TRUE)
[10:24:25.603]                               parallel_sendData(master, data)
[10:24:25.603]                             }
[10:24:25.603]                             return(sendCondition)
[10:24:25.603]                           }
[10:24:25.603]                         }
[10:24:25.603]                         frame <- frame + 1L
[10:24:25.603]                         envir <- sys.frame(frame)
[10:24:25.603]                       }
[10:24:25.603]                     }
[10:24:25.603]                     sendCondition <<- function(cond) NULL
[10:24:25.603]                   }
[10:24:25.603]                 })
[10:24:25.603]                 withCallingHandlers({
[10:24:25.603]                   {
[10:24:25.603]                     do.call(function(...) {
[10:24:25.603]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.603]                       if (!identical(...future.globals.maxSize.org, 
[10:24:25.603]                         ...future.globals.maxSize)) {
[10:24:25.603]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.603]                         on.exit(options(oopts), add = TRUE)
[10:24:25.603]                       }
[10:24:25.603]                       {
[10:24:25.603]                         lapply(seq_along(...future.elements_ii), 
[10:24:25.603]                           FUN = function(jj) {
[10:24:25.603]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.603]                             ...future.FUN(...future.X_jj, ...)
[10:24:25.603]                           })
[10:24:25.603]                       }
[10:24:25.603]                     }, args = future.call.arguments)
[10:24:25.603]                   }
[10:24:25.603]                 }, immediateCondition = function(cond) {
[10:24:25.603]                   sendCondition <- ...future.makeSendCondition()
[10:24:25.603]                   sendCondition(cond)
[10:24:25.603]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.603]                   {
[10:24:25.603]                     inherits <- base::inherits
[10:24:25.603]                     invokeRestart <- base::invokeRestart
[10:24:25.603]                     is.null <- base::is.null
[10:24:25.603]                     muffled <- FALSE
[10:24:25.603]                     if (inherits(cond, "message")) {
[10:24:25.603]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:25.603]                       if (muffled) 
[10:24:25.603]                         invokeRestart("muffleMessage")
[10:24:25.603]                     }
[10:24:25.603]                     else if (inherits(cond, "warning")) {
[10:24:25.603]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:25.603]                       if (muffled) 
[10:24:25.603]                         invokeRestart("muffleWarning")
[10:24:25.603]                     }
[10:24:25.603]                     else if (inherits(cond, "condition")) {
[10:24:25.603]                       if (!is.null(pattern)) {
[10:24:25.603]                         computeRestarts <- base::computeRestarts
[10:24:25.603]                         grepl <- base::grepl
[10:24:25.603]                         restarts <- computeRestarts(cond)
[10:24:25.603]                         for (restart in restarts) {
[10:24:25.603]                           name <- restart$name
[10:24:25.603]                           if (is.null(name)) 
[10:24:25.603]                             next
[10:24:25.603]                           if (!grepl(pattern, name)) 
[10:24:25.603]                             next
[10:24:25.603]                           invokeRestart(restart)
[10:24:25.603]                           muffled <- TRUE
[10:24:25.603]                           break
[10:24:25.603]                         }
[10:24:25.603]                       }
[10:24:25.603]                     }
[10:24:25.603]                     invisible(muffled)
[10:24:25.603]                   }
[10:24:25.603]                   muffleCondition(cond)
[10:24:25.603]                 })
[10:24:25.603]             }))
[10:24:25.603]             future::FutureResult(value = ...future.value$value, 
[10:24:25.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:25.603]                   ...future.rng), globalenv = if (FALSE) 
[10:24:25.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:25.603]                     ...future.globalenv.names))
[10:24:25.603]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:25.603]         }, condition = base::local({
[10:24:25.603]             c <- base::c
[10:24:25.603]             inherits <- base::inherits
[10:24:25.603]             invokeRestart <- base::invokeRestart
[10:24:25.603]             length <- base::length
[10:24:25.603]             list <- base::list
[10:24:25.603]             seq.int <- base::seq.int
[10:24:25.603]             signalCondition <- base::signalCondition
[10:24:25.603]             sys.calls <- base::sys.calls
[10:24:25.603]             `[[` <- base::`[[`
[10:24:25.603]             `+` <- base::`+`
[10:24:25.603]             `<<-` <- base::`<<-`
[10:24:25.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:25.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:25.603]                   3L)]
[10:24:25.603]             }
[10:24:25.603]             function(cond) {
[10:24:25.603]                 is_error <- inherits(cond, "error")
[10:24:25.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:25.603]                   NULL)
[10:24:25.603]                 if (is_error) {
[10:24:25.603]                   sessionInformation <- function() {
[10:24:25.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:25.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:25.603]                       search = base::search(), system = base::Sys.info())
[10:24:25.603]                   }
[10:24:25.603]                   ...future.conditions[[length(...future.conditions) + 
[10:24:25.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:25.603]                     cond$call), session = sessionInformation(), 
[10:24:25.603]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:25.603]                   signalCondition(cond)
[10:24:25.603]                 }
[10:24:25.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:25.603]                 "immediateCondition"))) {
[10:24:25.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:25.603]                   ...future.conditions[[length(...future.conditions) + 
[10:24:25.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:25.603]                   if (TRUE && !signal) {
[10:24:25.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.603]                     {
[10:24:25.603]                       inherits <- base::inherits
[10:24:25.603]                       invokeRestart <- base::invokeRestart
[10:24:25.603]                       is.null <- base::is.null
[10:24:25.603]                       muffled <- FALSE
[10:24:25.603]                       if (inherits(cond, "message")) {
[10:24:25.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:25.603]                         if (muffled) 
[10:24:25.603]                           invokeRestart("muffleMessage")
[10:24:25.603]                       }
[10:24:25.603]                       else if (inherits(cond, "warning")) {
[10:24:25.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:25.603]                         if (muffled) 
[10:24:25.603]                           invokeRestart("muffleWarning")
[10:24:25.603]                       }
[10:24:25.603]                       else if (inherits(cond, "condition")) {
[10:24:25.603]                         if (!is.null(pattern)) {
[10:24:25.603]                           computeRestarts <- base::computeRestarts
[10:24:25.603]                           grepl <- base::grepl
[10:24:25.603]                           restarts <- computeRestarts(cond)
[10:24:25.603]                           for (restart in restarts) {
[10:24:25.603]                             name <- restart$name
[10:24:25.603]                             if (is.null(name)) 
[10:24:25.603]                               next
[10:24:25.603]                             if (!grepl(pattern, name)) 
[10:24:25.603]                               next
[10:24:25.603]                             invokeRestart(restart)
[10:24:25.603]                             muffled <- TRUE
[10:24:25.603]                             break
[10:24:25.603]                           }
[10:24:25.603]                         }
[10:24:25.603]                       }
[10:24:25.603]                       invisible(muffled)
[10:24:25.603]                     }
[10:24:25.603]                     muffleCondition(cond, pattern = "^muffle")
[10:24:25.603]                   }
[10:24:25.603]                 }
[10:24:25.603]                 else {
[10:24:25.603]                   if (TRUE) {
[10:24:25.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.603]                     {
[10:24:25.603]                       inherits <- base::inherits
[10:24:25.603]                       invokeRestart <- base::invokeRestart
[10:24:25.603]                       is.null <- base::is.null
[10:24:25.603]                       muffled <- FALSE
[10:24:25.603]                       if (inherits(cond, "message")) {
[10:24:25.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:25.603]                         if (muffled) 
[10:24:25.603]                           invokeRestart("muffleMessage")
[10:24:25.603]                       }
[10:24:25.603]                       else if (inherits(cond, "warning")) {
[10:24:25.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:25.603]                         if (muffled) 
[10:24:25.603]                           invokeRestart("muffleWarning")
[10:24:25.603]                       }
[10:24:25.603]                       else if (inherits(cond, "condition")) {
[10:24:25.603]                         if (!is.null(pattern)) {
[10:24:25.603]                           computeRestarts <- base::computeRestarts
[10:24:25.603]                           grepl <- base::grepl
[10:24:25.603]                           restarts <- computeRestarts(cond)
[10:24:25.603]                           for (restart in restarts) {
[10:24:25.603]                             name <- restart$name
[10:24:25.603]                             if (is.null(name)) 
[10:24:25.603]                               next
[10:24:25.603]                             if (!grepl(pattern, name)) 
[10:24:25.603]                               next
[10:24:25.603]                             invokeRestart(restart)
[10:24:25.603]                             muffled <- TRUE
[10:24:25.603]                             break
[10:24:25.603]                           }
[10:24:25.603]                         }
[10:24:25.603]                       }
[10:24:25.603]                       invisible(muffled)
[10:24:25.603]                     }
[10:24:25.603]                     muffleCondition(cond, pattern = "^muffle")
[10:24:25.603]                   }
[10:24:25.603]                 }
[10:24:25.603]             }
[10:24:25.603]         }))
[10:24:25.603]     }, error = function(ex) {
[10:24:25.603]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:25.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:25.603]                 ...future.rng), started = ...future.startTime, 
[10:24:25.603]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:25.603]             version = "1.8"), class = "FutureResult")
[10:24:25.603]     }, finally = {
[10:24:25.603]         if (!identical(...future.workdir, getwd())) 
[10:24:25.603]             setwd(...future.workdir)
[10:24:25.603]         {
[10:24:25.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:25.603]                 ...future.oldOptions$nwarnings <- NULL
[10:24:25.603]             }
[10:24:25.603]             base::options(...future.oldOptions)
[10:24:25.603]             if (.Platform$OS.type == "windows") {
[10:24:25.603]                 old_names <- names(...future.oldEnvVars)
[10:24:25.603]                 envs <- base::Sys.getenv()
[10:24:25.603]                 names <- names(envs)
[10:24:25.603]                 common <- intersect(names, old_names)
[10:24:25.603]                 added <- setdiff(names, old_names)
[10:24:25.603]                 removed <- setdiff(old_names, names)
[10:24:25.603]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:25.603]                   envs[common]]
[10:24:25.603]                 NAMES <- toupper(changed)
[10:24:25.603]                 args <- list()
[10:24:25.603]                 for (kk in seq_along(NAMES)) {
[10:24:25.603]                   name <- changed[[kk]]
[10:24:25.603]                   NAME <- NAMES[[kk]]
[10:24:25.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.603]                     next
[10:24:25.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:25.603]                 }
[10:24:25.603]                 NAMES <- toupper(added)
[10:24:25.603]                 for (kk in seq_along(NAMES)) {
[10:24:25.603]                   name <- added[[kk]]
[10:24:25.603]                   NAME <- NAMES[[kk]]
[10:24:25.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.603]                     next
[10:24:25.603]                   args[[name]] <- ""
[10:24:25.603]                 }
[10:24:25.603]                 NAMES <- toupper(removed)
[10:24:25.603]                 for (kk in seq_along(NAMES)) {
[10:24:25.603]                   name <- removed[[kk]]
[10:24:25.603]                   NAME <- NAMES[[kk]]
[10:24:25.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.603]                     next
[10:24:25.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:25.603]                 }
[10:24:25.603]                 if (length(args) > 0) 
[10:24:25.603]                   base::do.call(base::Sys.setenv, args = args)
[10:24:25.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:25.603]             }
[10:24:25.603]             else {
[10:24:25.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:25.603]             }
[10:24:25.603]             {
[10:24:25.603]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:25.603]                   0L) {
[10:24:25.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:25.603]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:25.603]                   base::options(opts)
[10:24:25.603]                 }
[10:24:25.603]                 {
[10:24:25.603]                   {
[10:24:25.603]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:25.603]                     NULL
[10:24:25.603]                   }
[10:24:25.603]                   options(future.plan = NULL)
[10:24:25.603]                   if (is.na(NA_character_)) 
[10:24:25.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:25.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:25.603]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:25.603]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:25.603]                     envir = parent.frame()) 
[10:24:25.603]                   {
[10:24:25.603]                     if (is.function(workers)) 
[10:24:25.603]                       workers <- workers()
[10:24:25.603]                     workers <- structure(as.integer(workers), 
[10:24:25.603]                       class = class(workers))
[10:24:25.603]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:25.603]                       workers >= 1)
[10:24:25.603]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:25.603]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:25.603]                     }
[10:24:25.603]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:25.603]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:25.603]                       envir = envir)
[10:24:25.603]                     if (!future$lazy) 
[10:24:25.603]                       future <- run(future)
[10:24:25.603]                     invisible(future)
[10:24:25.603]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:25.603]                 }
[10:24:25.603]             }
[10:24:25.603]         }
[10:24:25.603]     })
[10:24:25.603]     if (TRUE) {
[10:24:25.603]         base::sink(type = "output", split = FALSE)
[10:24:25.603]         if (TRUE) {
[10:24:25.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:25.603]         }
[10:24:25.603]         else {
[10:24:25.603]             ...future.result["stdout"] <- base::list(NULL)
[10:24:25.603]         }
[10:24:25.603]         base::close(...future.stdout)
[10:24:25.603]         ...future.stdout <- NULL
[10:24:25.603]     }
[10:24:25.603]     ...future.result$conditions <- ...future.conditions
[10:24:25.603]     ...future.result$finished <- base::Sys.time()
[10:24:25.603]     ...future.result
[10:24:25.603] }
[10:24:25.605] Exporting 11 global objects (92.05 KiB) to cluster node #2 ...
[10:24:25.606] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:25.654] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:25.654] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[10:24:25.654] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[10:24:25.654] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:25.655] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:25.655] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:25.698] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:25.698] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:25.742] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:25.742] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:24:25.742] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:24:25.742] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[10:24:25.743] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[10:24:25.743] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:25.743] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:25.744] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:24:25.744] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:24:25.744] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:25.744] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:25.745] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:25.745] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:25.745] Exporting 11 global objects (92.05 KiB) to cluster node #2 ... DONE
[10:24:25.746] MultisessionFuture started
[10:24:25.746] - Launch lazy future ... done
[10:24:25.746] run() for ‘MultisessionFuture’ ... done
[10:24:25.746] Created future:
[10:24:25.746] MultisessionFuture:
[10:24:25.746] Label: ‘future_vapply-2’
[10:24:25.746] Expression:
[10:24:25.746] {
[10:24:25.746]     do.call(function(...) {
[10:24:25.746]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.746]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:25.746]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.746]             on.exit(options(oopts), add = TRUE)
[10:24:25.746]         }
[10:24:25.746]         {
[10:24:25.746]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:25.746]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.746]                 ...future.FUN(...future.X_jj, ...)
[10:24:25.746]             })
[10:24:25.746]         }
[10:24:25.746]     }, args = future.call.arguments)
[10:24:25.746] }
[10:24:25.746] Lazy evaluation: FALSE
[10:24:25.746] Asynchronous evaluation: TRUE
[10:24:25.746] Local evaluation: TRUE
[10:24:25.746] Environment: R_GlobalEnv
[10:24:25.746] Capture standard output: TRUE
[10:24:25.746] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:25.746] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:25.746] Packages: 1 packages (‘future.apply’)
[10:24:25.746] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:25.746] Resolved: FALSE
[10:24:25.746] Value: <not collected>
[10:24:25.746] Conditions captured: <none>
[10:24:25.746] Early signaling: FALSE
[10:24:25.746] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:25.746] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:25.758] Chunk #2 of 2 ... DONE
[10:24:25.758] Launching 2 futures (chunks) ... DONE
[10:24:25.758] Resolving 2 futures (chunks) ...
[10:24:25.759] resolve() on list ...
[10:24:25.759]  recursive: 0
[10:24:25.759]  length: 2
[10:24:25.759] 
[10:24:25.759] receiveMessageFromWorker() for ClusterFuture ...
[10:24:25.760] - Validating connection of MultisessionFuture
[10:24:25.760] - received message: FutureResult
[10:24:25.760] - Received FutureResult
[10:24:25.760] - Erased future from FutureRegistry
[10:24:25.760] result() for ClusterFuture ...
[10:24:25.760] - result already collected: FutureResult
[10:24:25.760] result() for ClusterFuture ... done
[10:24:25.760] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:25.760] Future #1
[10:24:25.761] result() for ClusterFuture ...
[10:24:25.761] - result already collected: FutureResult
[10:24:25.761] result() for ClusterFuture ... done
[10:24:25.761] result() for ClusterFuture ...
[10:24:25.761] - result already collected: FutureResult
[10:24:25.761] result() for ClusterFuture ... done
[10:24:25.761] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:25.761] - nx: 2
[10:24:25.761] - relay: TRUE
[10:24:25.761] - stdout: TRUE
[10:24:25.761] - signal: TRUE
[10:24:25.762] - resignal: FALSE
[10:24:25.762] - force: TRUE
[10:24:25.762] - relayed: [n=2] FALSE, FALSE
[10:24:25.762] - queued futures: [n=2] FALSE, FALSE
[10:24:25.762]  - until=1
[10:24:25.762]  - relaying element #1
[10:24:25.762] result() for ClusterFuture ...
[10:24:25.762] - result already collected: FutureResult
[10:24:25.762] result() for ClusterFuture ... done
[10:24:25.762] result() for ClusterFuture ...
[10:24:25.762] - result already collected: FutureResult
[10:24:25.763] result() for ClusterFuture ... done
[10:24:25.763] result() for ClusterFuture ...
[10:24:25.763] - result already collected: FutureResult
[10:24:25.763] result() for ClusterFuture ... done
[10:24:25.763] result() for ClusterFuture ...
[10:24:25.763] - result already collected: FutureResult
[10:24:25.763] result() for ClusterFuture ... done
[10:24:25.763] - relayed: [n=2] TRUE, FALSE
[10:24:25.763] - queued futures: [n=2] TRUE, FALSE
[10:24:25.763] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:25.764]  length: 1 (resolved future 1)
[10:24:25.794] receiveMessageFromWorker() for ClusterFuture ...
[10:24:25.795] - Validating connection of MultisessionFuture
[10:24:25.795] - received message: FutureResult
[10:24:25.795] - Received FutureResult
[10:24:25.795] - Erased future from FutureRegistry
[10:24:25.795] result() for ClusterFuture ...
[10:24:25.795] - result already collected: FutureResult
[10:24:25.795] result() for ClusterFuture ... done
[10:24:25.795] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:25.795] Future #2
[10:24:25.796] result() for ClusterFuture ...
[10:24:25.796] - result already collected: FutureResult
[10:24:25.796] result() for ClusterFuture ... done
[10:24:25.796] result() for ClusterFuture ...
[10:24:25.796] - result already collected: FutureResult
[10:24:25.796] result() for ClusterFuture ... done
[10:24:25.796] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:25.796] - nx: 2
[10:24:25.796] - relay: TRUE
[10:24:25.796] - stdout: TRUE
[10:24:25.796] - signal: TRUE
[10:24:25.797] - resignal: FALSE
[10:24:25.797] - force: TRUE
[10:24:25.797] - relayed: [n=2] TRUE, FALSE
[10:24:25.797] - queued futures: [n=2] TRUE, FALSE
[10:24:25.797]  - until=2
[10:24:25.797]  - relaying element #2
[10:24:25.797] result() for ClusterFuture ...
[10:24:25.797] - result already collected: FutureResult
[10:24:25.797] result() for ClusterFuture ... done
[10:24:25.797] result() for ClusterFuture ...
[10:24:25.797] - result already collected: FutureResult
[10:24:25.798] result() for ClusterFuture ... done
[10:24:25.798] result() for ClusterFuture ...
[10:24:25.798] - result already collected: FutureResult
[10:24:25.798] result() for ClusterFuture ... done
[10:24:25.798] result() for ClusterFuture ...
[10:24:25.798] - result already collected: FutureResult
[10:24:25.798] result() for ClusterFuture ... done
[10:24:25.798] - relayed: [n=2] TRUE, TRUE
[10:24:25.798] - queued futures: [n=2] TRUE, TRUE
[10:24:25.798] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:24:25.798]  length: 0 (resolved future 2)
[10:24:25.799] Relaying remaining futures
[10:24:25.799] signalConditionsASAP(NULL, pos=0) ...
[10:24:25.799] - nx: 2
[10:24:25.799] - relay: TRUE
[10:24:25.799] - stdout: TRUE
[10:24:25.799] - signal: TRUE
[10:24:25.799] - resignal: FALSE
[10:24:25.799] - force: TRUE
[10:24:25.799] - relayed: [n=2] TRUE, TRUE
[10:24:25.799] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:25.799] - relayed: [n=2] TRUE, TRUE
[10:24:25.800] - queued futures: [n=2] TRUE, TRUE
[10:24:25.800] signalConditionsASAP(NULL, pos=0) ... done
[10:24:25.800] resolve() on list ... DONE
[10:24:25.800] result() for ClusterFuture ...
[10:24:25.800] - result already collected: FutureResult
[10:24:25.800] result() for ClusterFuture ... done
[10:24:25.800] result() for ClusterFuture ...
[10:24:25.800] - result already collected: FutureResult
[10:24:25.800] result() for ClusterFuture ... done
[10:24:25.800] result() for ClusterFuture ...
[10:24:25.801] - result already collected: FutureResult
[10:24:25.801] result() for ClusterFuture ... done
[10:24:25.801] result() for ClusterFuture ...
[10:24:25.801] - result already collected: FutureResult
[10:24:25.801] result() for ClusterFuture ... done
[10:24:25.801]  - Number of value chunks collected: 2
[10:24:25.801] Resolving 2 futures (chunks) ... DONE
[10:24:25.801] Reducing values from 2 chunks ...
[10:24:25.801]  - Number of values collected after concatenation: 3
[10:24:25.801]  - Number of values expected: 3
[10:24:25.801] Reducing values from 2 chunks ... DONE
[10:24:25.802] future_lapply() ... DONE
- exceptions ...
[10:24:25.802] future_lapply() ...
[10:24:25.807] Number of chunks: 2
[10:24:25.807] getGlobalsAndPackagesXApply() ...
[10:24:25.807]  - future.globals: TRUE
[10:24:25.807] getGlobalsAndPackages() ...
[10:24:25.807] Searching for globals...
[10:24:25.811] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:24:25.811] Searching for globals ... DONE
[10:24:25.811] Resolving globals: FALSE
[10:24:25.812] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[10:24:25.812] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:24:25.812] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:25.813] - packages: [1] ‘future.apply’
[10:24:25.813] getGlobalsAndPackages() ... DONE
[10:24:25.813]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:24:25.813]  - needed namespaces: [n=1] ‘future.apply’
[10:24:25.813] Finding globals ... DONE
[10:24:25.813]  - use_args: TRUE
[10:24:25.813]  - Getting '...' globals ...
[10:24:25.814] resolve() on list ...
[10:24:25.814]  recursive: 0
[10:24:25.814]  length: 1
[10:24:25.814]  elements: ‘...’
[10:24:25.814]  length: 0 (resolved future 1)
[10:24:25.814] resolve() on list ... DONE
[10:24:25.814]    - '...' content: [n=0] 
[10:24:25.814] List of 1
[10:24:25.814]  $ ...: list()
[10:24:25.814]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:25.814]  - attr(*, "where")=List of 1
[10:24:25.814]   ..$ ...:<environment: 0x55b93dc05118> 
[10:24:25.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:25.814]  - attr(*, "resolved")= logi TRUE
[10:24:25.814]  - attr(*, "total_size")= num NA
[10:24:25.817]  - Getting '...' globals ... DONE
[10:24:25.817] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:24:25.817] List of 8
[10:24:25.817]  $ ...future.FUN:function (x, ...)  
[10:24:25.817]  $ x_FUN        :function (x)  
[10:24:25.817]  $ times        : int 2
[10:24:25.817]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:24:25.817]  $ stop_if_not  :function (...)  
[10:24:25.817]  $ dim          : NULL
[10:24:25.817]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:24:25.817]  $ ...          : list()
[10:24:25.817]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:25.817]  - attr(*, "where")=List of 8
[10:24:25.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:25.817]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:24:25.817]   ..$ times        :<environment: R_EmptyEnv> 
[10:24:25.817]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:24:25.817]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:24:25.817]   ..$ dim          :<environment: R_EmptyEnv> 
[10:24:25.817]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:24:25.817]   ..$ ...          :<environment: 0x55b93dc05118> 
[10:24:25.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:25.817]  - attr(*, "resolved")= logi FALSE
[10:24:25.817]  - attr(*, "total_size")= num 95128
[10:24:25.822] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:24:25.823] getGlobalsAndPackagesXApply() ... DONE
[10:24:25.823] Number of futures (= number of chunks): 2
[10:24:25.823] Launching 2 futures (chunks) ...
[10:24:25.823] Chunk #1 of 2 ...
[10:24:25.823]  - Finding globals in 'X' for chunk #1 ...
[10:24:25.823] getGlobalsAndPackages() ...
[10:24:25.823] Searching for globals...
[10:24:25.823] 
[10:24:25.824] Searching for globals ... DONE
[10:24:25.824] - globals: [0] <none>
[10:24:25.824] getGlobalsAndPackages() ... DONE
[10:24:25.824]    + additional globals found: [n=0] 
[10:24:25.824]    + additional namespaces needed: [n=0] 
[10:24:25.824]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:25.824]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:25.824]  - seeds: <none>
[10:24:25.824]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.824] getGlobalsAndPackages() ...
[10:24:25.824] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.825] Resolving globals: FALSE
[10:24:25.825] Tweak future expression to call with '...' arguments ...
[10:24:25.825] {
[10:24:25.825]     do.call(function(...) {
[10:24:25.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:25.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.825]             on.exit(options(oopts), add = TRUE)
[10:24:25.825]         }
[10:24:25.825]         {
[10:24:25.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:25.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.825]                 ...future.FUN(...future.X_jj, ...)
[10:24:25.825]             })
[10:24:25.825]         }
[10:24:25.825]     }, args = future.call.arguments)
[10:24:25.825] }
[10:24:25.825] Tweak future expression to call with '...' arguments ... DONE
[10:24:25.826] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.826] - packages: [1] ‘future.apply’
[10:24:25.826] getGlobalsAndPackages() ... DONE
[10:24:25.826] run() for ‘Future’ ...
[10:24:25.826] - state: ‘created’
[10:24:25.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:25.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:25.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:25.840]   - Field: ‘node’
[10:24:25.840]   - Field: ‘label’
[10:24:25.840]   - Field: ‘local’
[10:24:25.840]   - Field: ‘owner’
[10:24:25.841]   - Field: ‘envir’
[10:24:25.841]   - Field: ‘workers’
[10:24:25.841]   - Field: ‘packages’
[10:24:25.841]   - Field: ‘gc’
[10:24:25.841]   - Field: ‘conditions’
[10:24:25.841]   - Field: ‘persistent’
[10:24:25.841]   - Field: ‘expr’
[10:24:25.841]   - Field: ‘uuid’
[10:24:25.841]   - Field: ‘seed’
[10:24:25.841]   - Field: ‘version’
[10:24:25.842]   - Field: ‘result’
[10:24:25.842]   - Field: ‘asynchronous’
[10:24:25.842]   - Field: ‘calls’
[10:24:25.842]   - Field: ‘globals’
[10:24:25.842]   - Field: ‘stdout’
[10:24:25.842]   - Field: ‘earlySignal’
[10:24:25.842]   - Field: ‘lazy’
[10:24:25.842]   - Field: ‘state’
[10:24:25.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:25.842] - Launch lazy future ...
[10:24:25.843] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:25.843] Packages needed by future strategies (n = 0): <none>
[10:24:25.843] {
[10:24:25.843]     {
[10:24:25.843]         {
[10:24:25.843]             ...future.startTime <- base::Sys.time()
[10:24:25.843]             {
[10:24:25.843]                 {
[10:24:25.843]                   {
[10:24:25.843]                     {
[10:24:25.843]                       {
[10:24:25.843]                         base::local({
[10:24:25.843]                           has_future <- base::requireNamespace("future", 
[10:24:25.843]                             quietly = TRUE)
[10:24:25.843]                           if (has_future) {
[10:24:25.843]                             ns <- base::getNamespace("future")
[10:24:25.843]                             version <- ns[[".package"]][["version"]]
[10:24:25.843]                             if (is.null(version)) 
[10:24:25.843]                               version <- utils::packageVersion("future")
[10:24:25.843]                           }
[10:24:25.843]                           else {
[10:24:25.843]                             version <- NULL
[10:24:25.843]                           }
[10:24:25.843]                           if (!has_future || version < "1.8.0") {
[10:24:25.843]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:25.843]                               "", base::R.version$version.string), 
[10:24:25.843]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:25.843]                                 base::R.version$platform, 8 * 
[10:24:25.843]                                   base::.Machine$sizeof.pointer), 
[10:24:25.843]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:25.843]                                 "release", "version")], collapse = " "), 
[10:24:25.843]                               hostname = base::Sys.info()[["nodename"]])
[10:24:25.843]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:25.843]                               info)
[10:24:25.843]                             info <- base::paste(info, collapse = "; ")
[10:24:25.843]                             if (!has_future) {
[10:24:25.843]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:25.843]                                 info)
[10:24:25.843]                             }
[10:24:25.843]                             else {
[10:24:25.843]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:25.843]                                 info, version)
[10:24:25.843]                             }
[10:24:25.843]                             base::stop(msg)
[10:24:25.843]                           }
[10:24:25.843]                         })
[10:24:25.843]                       }
[10:24:25.843]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:25.843]                       base::options(mc.cores = 1L)
[10:24:25.843]                     }
[10:24:25.843]                     base::local({
[10:24:25.843]                       for (pkg in "future.apply") {
[10:24:25.843]                         base::loadNamespace(pkg)
[10:24:25.843]                         base::library(pkg, character.only = TRUE)
[10:24:25.843]                       }
[10:24:25.843]                     })
[10:24:25.843]                   }
[10:24:25.843]                   options(future.plan = NULL)
[10:24:25.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:25.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:25.843]                 }
[10:24:25.843]                 ...future.workdir <- getwd()
[10:24:25.843]             }
[10:24:25.843]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:25.843]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:25.843]         }
[10:24:25.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:25.843]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:25.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:25.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:25.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:25.843]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:25.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:25.843]             base::names(...future.oldOptions))
[10:24:25.843]     }
[10:24:25.843]     if (FALSE) {
[10:24:25.843]     }
[10:24:25.843]     else {
[10:24:25.843]         if (TRUE) {
[10:24:25.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:25.843]                 open = "w")
[10:24:25.843]         }
[10:24:25.843]         else {
[10:24:25.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:25.843]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:25.843]         }
[10:24:25.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:25.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:25.843]             base::sink(type = "output", split = FALSE)
[10:24:25.843]             base::close(...future.stdout)
[10:24:25.843]         }, add = TRUE)
[10:24:25.843]     }
[10:24:25.843]     ...future.frame <- base::sys.nframe()
[10:24:25.843]     ...future.conditions <- base::list()
[10:24:25.843]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:25.843]     if (FALSE) {
[10:24:25.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:25.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:25.843]     }
[10:24:25.843]     ...future.result <- base::tryCatch({
[10:24:25.843]         base::withCallingHandlers({
[10:24:25.843]             ...future.value <- base::withVisible(base::local({
[10:24:25.843]                 ...future.makeSendCondition <- base::local({
[10:24:25.843]                   sendCondition <- NULL
[10:24:25.843]                   function(frame = 1L) {
[10:24:25.843]                     if (is.function(sendCondition)) 
[10:24:25.843]                       return(sendCondition)
[10:24:25.843]                     ns <- getNamespace("parallel")
[10:24:25.843]                     if (exists("sendData", mode = "function", 
[10:24:25.843]                       envir = ns)) {
[10:24:25.843]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:25.843]                         envir = ns)
[10:24:25.843]                       envir <- sys.frame(frame)
[10:24:25.843]                       master <- NULL
[10:24:25.843]                       while (!identical(envir, .GlobalEnv) && 
[10:24:25.843]                         !identical(envir, emptyenv())) {
[10:24:25.843]                         if (exists("master", mode = "list", envir = envir, 
[10:24:25.843]                           inherits = FALSE)) {
[10:24:25.843]                           master <- get("master", mode = "list", 
[10:24:25.843]                             envir = envir, inherits = FALSE)
[10:24:25.843]                           if (inherits(master, c("SOCKnode", 
[10:24:25.843]                             "SOCK0node"))) {
[10:24:25.843]                             sendCondition <<- function(cond) {
[10:24:25.843]                               data <- list(type = "VALUE", value = cond, 
[10:24:25.843]                                 success = TRUE)
[10:24:25.843]                               parallel_sendData(master, data)
[10:24:25.843]                             }
[10:24:25.843]                             return(sendCondition)
[10:24:25.843]                           }
[10:24:25.843]                         }
[10:24:25.843]                         frame <- frame + 1L
[10:24:25.843]                         envir <- sys.frame(frame)
[10:24:25.843]                       }
[10:24:25.843]                     }
[10:24:25.843]                     sendCondition <<- function(cond) NULL
[10:24:25.843]                   }
[10:24:25.843]                 })
[10:24:25.843]                 withCallingHandlers({
[10:24:25.843]                   {
[10:24:25.843]                     do.call(function(...) {
[10:24:25.843]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.843]                       if (!identical(...future.globals.maxSize.org, 
[10:24:25.843]                         ...future.globals.maxSize)) {
[10:24:25.843]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.843]                         on.exit(options(oopts), add = TRUE)
[10:24:25.843]                       }
[10:24:25.843]                       {
[10:24:25.843]                         lapply(seq_along(...future.elements_ii), 
[10:24:25.843]                           FUN = function(jj) {
[10:24:25.843]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.843]                             ...future.FUN(...future.X_jj, ...)
[10:24:25.843]                           })
[10:24:25.843]                       }
[10:24:25.843]                     }, args = future.call.arguments)
[10:24:25.843]                   }
[10:24:25.843]                 }, immediateCondition = function(cond) {
[10:24:25.843]                   sendCondition <- ...future.makeSendCondition()
[10:24:25.843]                   sendCondition(cond)
[10:24:25.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.843]                   {
[10:24:25.843]                     inherits <- base::inherits
[10:24:25.843]                     invokeRestart <- base::invokeRestart
[10:24:25.843]                     is.null <- base::is.null
[10:24:25.843]                     muffled <- FALSE
[10:24:25.843]                     if (inherits(cond, "message")) {
[10:24:25.843]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:25.843]                       if (muffled) 
[10:24:25.843]                         invokeRestart("muffleMessage")
[10:24:25.843]                     }
[10:24:25.843]                     else if (inherits(cond, "warning")) {
[10:24:25.843]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:25.843]                       if (muffled) 
[10:24:25.843]                         invokeRestart("muffleWarning")
[10:24:25.843]                     }
[10:24:25.843]                     else if (inherits(cond, "condition")) {
[10:24:25.843]                       if (!is.null(pattern)) {
[10:24:25.843]                         computeRestarts <- base::computeRestarts
[10:24:25.843]                         grepl <- base::grepl
[10:24:25.843]                         restarts <- computeRestarts(cond)
[10:24:25.843]                         for (restart in restarts) {
[10:24:25.843]                           name <- restart$name
[10:24:25.843]                           if (is.null(name)) 
[10:24:25.843]                             next
[10:24:25.843]                           if (!grepl(pattern, name)) 
[10:24:25.843]                             next
[10:24:25.843]                           invokeRestart(restart)
[10:24:25.843]                           muffled <- TRUE
[10:24:25.843]                           break
[10:24:25.843]                         }
[10:24:25.843]                       }
[10:24:25.843]                     }
[10:24:25.843]                     invisible(muffled)
[10:24:25.843]                   }
[10:24:25.843]                   muffleCondition(cond)
[10:24:25.843]                 })
[10:24:25.843]             }))
[10:24:25.843]             future::FutureResult(value = ...future.value$value, 
[10:24:25.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:25.843]                   ...future.rng), globalenv = if (FALSE) 
[10:24:25.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:25.843]                     ...future.globalenv.names))
[10:24:25.843]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:25.843]         }, condition = base::local({
[10:24:25.843]             c <- base::c
[10:24:25.843]             inherits <- base::inherits
[10:24:25.843]             invokeRestart <- base::invokeRestart
[10:24:25.843]             length <- base::length
[10:24:25.843]             list <- base::list
[10:24:25.843]             seq.int <- base::seq.int
[10:24:25.843]             signalCondition <- base::signalCondition
[10:24:25.843]             sys.calls <- base::sys.calls
[10:24:25.843]             `[[` <- base::`[[`
[10:24:25.843]             `+` <- base::`+`
[10:24:25.843]             `<<-` <- base::`<<-`
[10:24:25.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:25.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:25.843]                   3L)]
[10:24:25.843]             }
[10:24:25.843]             function(cond) {
[10:24:25.843]                 is_error <- inherits(cond, "error")
[10:24:25.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:25.843]                   NULL)
[10:24:25.843]                 if (is_error) {
[10:24:25.843]                   sessionInformation <- function() {
[10:24:25.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:25.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:25.843]                       search = base::search(), system = base::Sys.info())
[10:24:25.843]                   }
[10:24:25.843]                   ...future.conditions[[length(...future.conditions) + 
[10:24:25.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:25.843]                     cond$call), session = sessionInformation(), 
[10:24:25.843]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:25.843]                   signalCondition(cond)
[10:24:25.843]                 }
[10:24:25.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:25.843]                 "immediateCondition"))) {
[10:24:25.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:25.843]                   ...future.conditions[[length(...future.conditions) + 
[10:24:25.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:25.843]                   if (TRUE && !signal) {
[10:24:25.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.843]                     {
[10:24:25.843]                       inherits <- base::inherits
[10:24:25.843]                       invokeRestart <- base::invokeRestart
[10:24:25.843]                       is.null <- base::is.null
[10:24:25.843]                       muffled <- FALSE
[10:24:25.843]                       if (inherits(cond, "message")) {
[10:24:25.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:25.843]                         if (muffled) 
[10:24:25.843]                           invokeRestart("muffleMessage")
[10:24:25.843]                       }
[10:24:25.843]                       else if (inherits(cond, "warning")) {
[10:24:25.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:25.843]                         if (muffled) 
[10:24:25.843]                           invokeRestart("muffleWarning")
[10:24:25.843]                       }
[10:24:25.843]                       else if (inherits(cond, "condition")) {
[10:24:25.843]                         if (!is.null(pattern)) {
[10:24:25.843]                           computeRestarts <- base::computeRestarts
[10:24:25.843]                           grepl <- base::grepl
[10:24:25.843]                           restarts <- computeRestarts(cond)
[10:24:25.843]                           for (restart in restarts) {
[10:24:25.843]                             name <- restart$name
[10:24:25.843]                             if (is.null(name)) 
[10:24:25.843]                               next
[10:24:25.843]                             if (!grepl(pattern, name)) 
[10:24:25.843]                               next
[10:24:25.843]                             invokeRestart(restart)
[10:24:25.843]                             muffled <- TRUE
[10:24:25.843]                             break
[10:24:25.843]                           }
[10:24:25.843]                         }
[10:24:25.843]                       }
[10:24:25.843]                       invisible(muffled)
[10:24:25.843]                     }
[10:24:25.843]                     muffleCondition(cond, pattern = "^muffle")
[10:24:25.843]                   }
[10:24:25.843]                 }
[10:24:25.843]                 else {
[10:24:25.843]                   if (TRUE) {
[10:24:25.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:25.843]                     {
[10:24:25.843]                       inherits <- base::inherits
[10:24:25.843]                       invokeRestart <- base::invokeRestart
[10:24:25.843]                       is.null <- base::is.null
[10:24:25.843]                       muffled <- FALSE
[10:24:25.843]                       if (inherits(cond, "message")) {
[10:24:25.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:25.843]                         if (muffled) 
[10:24:25.843]                           invokeRestart("muffleMessage")
[10:24:25.843]                       }
[10:24:25.843]                       else if (inherits(cond, "warning")) {
[10:24:25.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:25.843]                         if (muffled) 
[10:24:25.843]                           invokeRestart("muffleWarning")
[10:24:25.843]                       }
[10:24:25.843]                       else if (inherits(cond, "condition")) {
[10:24:25.843]                         if (!is.null(pattern)) {
[10:24:25.843]                           computeRestarts <- base::computeRestarts
[10:24:25.843]                           grepl <- base::grepl
[10:24:25.843]                           restarts <- computeRestarts(cond)
[10:24:25.843]                           for (restart in restarts) {
[10:24:25.843]                             name <- restart$name
[10:24:25.843]                             if (is.null(name)) 
[10:24:25.843]                               next
[10:24:25.843]                             if (!grepl(pattern, name)) 
[10:24:25.843]                               next
[10:24:25.843]                             invokeRestart(restart)
[10:24:25.843]                             muffled <- TRUE
[10:24:25.843]                             break
[10:24:25.843]                           }
[10:24:25.843]                         }
[10:24:25.843]                       }
[10:24:25.843]                       invisible(muffled)
[10:24:25.843]                     }
[10:24:25.843]                     muffleCondition(cond, pattern = "^muffle")
[10:24:25.843]                   }
[10:24:25.843]                 }
[10:24:25.843]             }
[10:24:25.843]         }))
[10:24:25.843]     }, error = function(ex) {
[10:24:25.843]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:25.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:25.843]                 ...future.rng), started = ...future.startTime, 
[10:24:25.843]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:25.843]             version = "1.8"), class = "FutureResult")
[10:24:25.843]     }, finally = {
[10:24:25.843]         if (!identical(...future.workdir, getwd())) 
[10:24:25.843]             setwd(...future.workdir)
[10:24:25.843]         {
[10:24:25.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:25.843]                 ...future.oldOptions$nwarnings <- NULL
[10:24:25.843]             }
[10:24:25.843]             base::options(...future.oldOptions)
[10:24:25.843]             if (.Platform$OS.type == "windows") {
[10:24:25.843]                 old_names <- names(...future.oldEnvVars)
[10:24:25.843]                 envs <- base::Sys.getenv()
[10:24:25.843]                 names <- names(envs)
[10:24:25.843]                 common <- intersect(names, old_names)
[10:24:25.843]                 added <- setdiff(names, old_names)
[10:24:25.843]                 removed <- setdiff(old_names, names)
[10:24:25.843]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:25.843]                   envs[common]]
[10:24:25.843]                 NAMES <- toupper(changed)
[10:24:25.843]                 args <- list()
[10:24:25.843]                 for (kk in seq_along(NAMES)) {
[10:24:25.843]                   name <- changed[[kk]]
[10:24:25.843]                   NAME <- NAMES[[kk]]
[10:24:25.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.843]                     next
[10:24:25.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:25.843]                 }
[10:24:25.843]                 NAMES <- toupper(added)
[10:24:25.843]                 for (kk in seq_along(NAMES)) {
[10:24:25.843]                   name <- added[[kk]]
[10:24:25.843]                   NAME <- NAMES[[kk]]
[10:24:25.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.843]                     next
[10:24:25.843]                   args[[name]] <- ""
[10:24:25.843]                 }
[10:24:25.843]                 NAMES <- toupper(removed)
[10:24:25.843]                 for (kk in seq_along(NAMES)) {
[10:24:25.843]                   name <- removed[[kk]]
[10:24:25.843]                   NAME <- NAMES[[kk]]
[10:24:25.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:25.843]                     next
[10:24:25.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:25.843]                 }
[10:24:25.843]                 if (length(args) > 0) 
[10:24:25.843]                   base::do.call(base::Sys.setenv, args = args)
[10:24:25.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:25.843]             }
[10:24:25.843]             else {
[10:24:25.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:25.843]             }
[10:24:25.843]             {
[10:24:25.843]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:25.843]                   0L) {
[10:24:25.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:25.843]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:25.843]                   base::options(opts)
[10:24:25.843]                 }
[10:24:25.843]                 {
[10:24:25.843]                   {
[10:24:25.843]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:25.843]                     NULL
[10:24:25.843]                   }
[10:24:25.843]                   options(future.plan = NULL)
[10:24:25.843]                   if (is.na(NA_character_)) 
[10:24:25.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:25.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:25.843]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:25.843]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:25.843]                     envir = parent.frame()) 
[10:24:25.843]                   {
[10:24:25.843]                     if (is.function(workers)) 
[10:24:25.843]                       workers <- workers()
[10:24:25.843]                     workers <- structure(as.integer(workers), 
[10:24:25.843]                       class = class(workers))
[10:24:25.843]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:25.843]                       workers >= 1)
[10:24:25.843]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:25.843]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:25.843]                     }
[10:24:25.843]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:25.843]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:25.843]                       envir = envir)
[10:24:25.843]                     if (!future$lazy) 
[10:24:25.843]                       future <- run(future)
[10:24:25.843]                     invisible(future)
[10:24:25.843]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:25.843]                 }
[10:24:25.843]             }
[10:24:25.843]         }
[10:24:25.843]     })
[10:24:25.843]     if (TRUE) {
[10:24:25.843]         base::sink(type = "output", split = FALSE)
[10:24:25.843]         if (TRUE) {
[10:24:25.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:25.843]         }
[10:24:25.843]         else {
[10:24:25.843]             ...future.result["stdout"] <- base::list(NULL)
[10:24:25.843]         }
[10:24:25.843]         base::close(...future.stdout)
[10:24:25.843]         ...future.stdout <- NULL
[10:24:25.843]     }
[10:24:25.843]     ...future.result$conditions <- ...future.conditions
[10:24:25.843]     ...future.result$finished <- base::Sys.time()
[10:24:25.843]     ...future.result
[10:24:25.843] }
[10:24:25.846] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[10:24:25.846] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:24:25.890] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:24:25.890] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[10:24:25.890] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[10:24:25.890] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:24:25.891] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:24:25.891] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:24:25.934] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:24:25.934] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:24:25.978] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:24:25.978] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:24:25.978] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.978] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:24:25.979] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:24:25.979] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:25.979] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.979] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:24:25.980] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:24:25.980] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:25.980] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.980] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:25.980] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:25.981] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[10:24:25.981] MultisessionFuture started
[10:24:25.981] - Launch lazy future ... done
[10:24:25.981] run() for ‘MultisessionFuture’ ... done
[10:24:25.981] Created future:
[10:24:25.982] MultisessionFuture:
[10:24:25.982] Label: ‘future_vapply-1’
[10:24:25.982] Expression:
[10:24:25.982] {
[10:24:25.982]     do.call(function(...) {
[10:24:25.982]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.982]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:25.982]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.982]             on.exit(options(oopts), add = TRUE)
[10:24:25.982]         }
[10:24:25.982]         {
[10:24:25.982]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:25.982]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.982]                 ...future.FUN(...future.X_jj, ...)
[10:24:25.982]             })
[10:24:25.982]         }
[10:24:25.982]     }, args = future.call.arguments)
[10:24:25.982] }
[10:24:25.982] Lazy evaluation: FALSE
[10:24:25.982] Asynchronous evaluation: TRUE
[10:24:25.982] Local evaluation: TRUE
[10:24:25.982] Environment: R_GlobalEnv
[10:24:25.982] Capture standard output: TRUE
[10:24:25.982] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:25.982] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:25.982] Packages: 1 packages (‘future.apply’)
[10:24:25.982] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:25.982] Resolved: FALSE
[10:24:25.982] Value: <not collected>
[10:24:25.982] Conditions captured: <none>
[10:24:25.982] Early signaling: FALSE
[10:24:25.982] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:25.982] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:25.993] Chunk #1 of 2 ... DONE
[10:24:25.993] Chunk #2 of 2 ...
[10:24:25.994]  - Finding globals in 'X' for chunk #2 ...
[10:24:25.994] getGlobalsAndPackages() ...
[10:24:25.994] Searching for globals...
[10:24:25.994] 
[10:24:25.994] Searching for globals ... DONE
[10:24:25.994] - globals: [0] <none>
[10:24:25.995] getGlobalsAndPackages() ... DONE
[10:24:25.995]    + additional globals found: [n=0] 
[10:24:25.995]    + additional namespaces needed: [n=0] 
[10:24:25.995]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:25.995]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:25.995]  - seeds: <none>
[10:24:25.995]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.995] getGlobalsAndPackages() ...
[10:24:25.995] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.995] Resolving globals: FALSE
[10:24:25.995] Tweak future expression to call with '...' arguments ...
[10:24:25.996] {
[10:24:25.996]     do.call(function(...) {
[10:24:25.996]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:25.996]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:25.996]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:25.996]             on.exit(options(oopts), add = TRUE)
[10:24:25.996]         }
[10:24:25.996]         {
[10:24:25.996]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:25.996]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:25.996]                 ...future.FUN(...future.X_jj, ...)
[10:24:25.996]             })
[10:24:25.996]         }
[10:24:25.996]     }, args = future.call.arguments)
[10:24:25.996] }
[10:24:25.996] Tweak future expression to call with '...' arguments ... DONE
[10:24:25.996] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:25.997] - packages: [1] ‘future.apply’
[10:24:25.997] getGlobalsAndPackages() ... DONE
[10:24:25.997] run() for ‘Future’ ...
[10:24:25.997] - state: ‘created’
[10:24:25.997] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:26.011] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:26.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:26.011]   - Field: ‘node’
[10:24:26.011]   - Field: ‘label’
[10:24:26.011]   - Field: ‘local’
[10:24:26.012]   - Field: ‘owner’
[10:24:26.012]   - Field: ‘envir’
[10:24:26.012]   - Field: ‘workers’
[10:24:26.012]   - Field: ‘packages’
[10:24:26.012]   - Field: ‘gc’
[10:24:26.012]   - Field: ‘conditions’
[10:24:26.012]   - Field: ‘persistent’
[10:24:26.012]   - Field: ‘expr’
[10:24:26.012]   - Field: ‘uuid’
[10:24:26.012]   - Field: ‘seed’
[10:24:26.012]   - Field: ‘version’
[10:24:26.013]   - Field: ‘result’
[10:24:26.013]   - Field: ‘asynchronous’
[10:24:26.013]   - Field: ‘calls’
[10:24:26.013]   - Field: ‘globals’
[10:24:26.013]   - Field: ‘stdout’
[10:24:26.013]   - Field: ‘earlySignal’
[10:24:26.013]   - Field: ‘lazy’
[10:24:26.013]   - Field: ‘state’
[10:24:26.013] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:26.013] - Launch lazy future ...
[10:24:26.014] Packages needed by the future expression (n = 1): ‘future.apply’
[10:24:26.014] Packages needed by future strategies (n = 0): <none>
[10:24:26.014] {
[10:24:26.014]     {
[10:24:26.014]         {
[10:24:26.014]             ...future.startTime <- base::Sys.time()
[10:24:26.014]             {
[10:24:26.014]                 {
[10:24:26.014]                   {
[10:24:26.014]                     {
[10:24:26.014]                       {
[10:24:26.014]                         base::local({
[10:24:26.014]                           has_future <- base::requireNamespace("future", 
[10:24:26.014]                             quietly = TRUE)
[10:24:26.014]                           if (has_future) {
[10:24:26.014]                             ns <- base::getNamespace("future")
[10:24:26.014]                             version <- ns[[".package"]][["version"]]
[10:24:26.014]                             if (is.null(version)) 
[10:24:26.014]                               version <- utils::packageVersion("future")
[10:24:26.014]                           }
[10:24:26.014]                           else {
[10:24:26.014]                             version <- NULL
[10:24:26.014]                           }
[10:24:26.014]                           if (!has_future || version < "1.8.0") {
[10:24:26.014]                             info <- base::c(r_version = base::gsub("R version ", 
[10:24:26.014]                               "", base::R.version$version.string), 
[10:24:26.014]                               platform = base::sprintf("%s (%s-bit)", 
[10:24:26.014]                                 base::R.version$platform, 8 * 
[10:24:26.014]                                   base::.Machine$sizeof.pointer), 
[10:24:26.014]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:26.014]                                 "release", "version")], collapse = " "), 
[10:24:26.014]                               hostname = base::Sys.info()[["nodename"]])
[10:24:26.014]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:24:26.014]                               info)
[10:24:26.014]                             info <- base::paste(info, collapse = "; ")
[10:24:26.014]                             if (!has_future) {
[10:24:26.014]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:26.014]                                 info)
[10:24:26.014]                             }
[10:24:26.014]                             else {
[10:24:26.014]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:26.014]                                 info, version)
[10:24:26.014]                             }
[10:24:26.014]                             base::stop(msg)
[10:24:26.014]                           }
[10:24:26.014]                         })
[10:24:26.014]                       }
[10:24:26.014]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:26.014]                       base::options(mc.cores = 1L)
[10:24:26.014]                     }
[10:24:26.014]                     base::local({
[10:24:26.014]                       for (pkg in "future.apply") {
[10:24:26.014]                         base::loadNamespace(pkg)
[10:24:26.014]                         base::library(pkg, character.only = TRUE)
[10:24:26.014]                       }
[10:24:26.014]                     })
[10:24:26.014]                   }
[10:24:26.014]                   options(future.plan = NULL)
[10:24:26.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:26.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:26.014]                 }
[10:24:26.014]                 ...future.workdir <- getwd()
[10:24:26.014]             }
[10:24:26.014]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:26.014]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:26.014]         }
[10:24:26.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:26.014]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:26.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:26.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:26.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:26.014]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:26.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:26.014]             base::names(...future.oldOptions))
[10:24:26.014]     }
[10:24:26.014]     if (FALSE) {
[10:24:26.014]     }
[10:24:26.014]     else {
[10:24:26.014]         if (TRUE) {
[10:24:26.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:26.014]                 open = "w")
[10:24:26.014]         }
[10:24:26.014]         else {
[10:24:26.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:26.014]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:26.014]         }
[10:24:26.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:26.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:26.014]             base::sink(type = "output", split = FALSE)
[10:24:26.014]             base::close(...future.stdout)
[10:24:26.014]         }, add = TRUE)
[10:24:26.014]     }
[10:24:26.014]     ...future.frame <- base::sys.nframe()
[10:24:26.014]     ...future.conditions <- base::list()
[10:24:26.014]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:26.014]     if (FALSE) {
[10:24:26.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:26.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:26.014]     }
[10:24:26.014]     ...future.result <- base::tryCatch({
[10:24:26.014]         base::withCallingHandlers({
[10:24:26.014]             ...future.value <- base::withVisible(base::local({
[10:24:26.014]                 ...future.makeSendCondition <- base::local({
[10:24:26.014]                   sendCondition <- NULL
[10:24:26.014]                   function(frame = 1L) {
[10:24:26.014]                     if (is.function(sendCondition)) 
[10:24:26.014]                       return(sendCondition)
[10:24:26.014]                     ns <- getNamespace("parallel")
[10:24:26.014]                     if (exists("sendData", mode = "function", 
[10:24:26.014]                       envir = ns)) {
[10:24:26.014]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:26.014]                         envir = ns)
[10:24:26.014]                       envir <- sys.frame(frame)
[10:24:26.014]                       master <- NULL
[10:24:26.014]                       while (!identical(envir, .GlobalEnv) && 
[10:24:26.014]                         !identical(envir, emptyenv())) {
[10:24:26.014]                         if (exists("master", mode = "list", envir = envir, 
[10:24:26.014]                           inherits = FALSE)) {
[10:24:26.014]                           master <- get("master", mode = "list", 
[10:24:26.014]                             envir = envir, inherits = FALSE)
[10:24:26.014]                           if (inherits(master, c("SOCKnode", 
[10:24:26.014]                             "SOCK0node"))) {
[10:24:26.014]                             sendCondition <<- function(cond) {
[10:24:26.014]                               data <- list(type = "VALUE", value = cond, 
[10:24:26.014]                                 success = TRUE)
[10:24:26.014]                               parallel_sendData(master, data)
[10:24:26.014]                             }
[10:24:26.014]                             return(sendCondition)
[10:24:26.014]                           }
[10:24:26.014]                         }
[10:24:26.014]                         frame <- frame + 1L
[10:24:26.014]                         envir <- sys.frame(frame)
[10:24:26.014]                       }
[10:24:26.014]                     }
[10:24:26.014]                     sendCondition <<- function(cond) NULL
[10:24:26.014]                   }
[10:24:26.014]                 })
[10:24:26.014]                 withCallingHandlers({
[10:24:26.014]                   {
[10:24:26.014]                     do.call(function(...) {
[10:24:26.014]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:26.014]                       if (!identical(...future.globals.maxSize.org, 
[10:24:26.014]                         ...future.globals.maxSize)) {
[10:24:26.014]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:26.014]                         on.exit(options(oopts), add = TRUE)
[10:24:26.014]                       }
[10:24:26.014]                       {
[10:24:26.014]                         lapply(seq_along(...future.elements_ii), 
[10:24:26.014]                           FUN = function(jj) {
[10:24:26.014]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:26.014]                             ...future.FUN(...future.X_jj, ...)
[10:24:26.014]                           })
[10:24:26.014]                       }
[10:24:26.014]                     }, args = future.call.arguments)
[10:24:26.014]                   }
[10:24:26.014]                 }, immediateCondition = function(cond) {
[10:24:26.014]                   sendCondition <- ...future.makeSendCondition()
[10:24:26.014]                   sendCondition(cond)
[10:24:26.014]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:26.014]                   {
[10:24:26.014]                     inherits <- base::inherits
[10:24:26.014]                     invokeRestart <- base::invokeRestart
[10:24:26.014]                     is.null <- base::is.null
[10:24:26.014]                     muffled <- FALSE
[10:24:26.014]                     if (inherits(cond, "message")) {
[10:24:26.014]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:26.014]                       if (muffled) 
[10:24:26.014]                         invokeRestart("muffleMessage")
[10:24:26.014]                     }
[10:24:26.014]                     else if (inherits(cond, "warning")) {
[10:24:26.014]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:26.014]                       if (muffled) 
[10:24:26.014]                         invokeRestart("muffleWarning")
[10:24:26.014]                     }
[10:24:26.014]                     else if (inherits(cond, "condition")) {
[10:24:26.014]                       if (!is.null(pattern)) {
[10:24:26.014]                         computeRestarts <- base::computeRestarts
[10:24:26.014]                         grepl <- base::grepl
[10:24:26.014]                         restarts <- computeRestarts(cond)
[10:24:26.014]                         for (restart in restarts) {
[10:24:26.014]                           name <- restart$name
[10:24:26.014]                           if (is.null(name)) 
[10:24:26.014]                             next
[10:24:26.014]                           if (!grepl(pattern, name)) 
[10:24:26.014]                             next
[10:24:26.014]                           invokeRestart(restart)
[10:24:26.014]                           muffled <- TRUE
[10:24:26.014]                           break
[10:24:26.014]                         }
[10:24:26.014]                       }
[10:24:26.014]                     }
[10:24:26.014]                     invisible(muffled)
[10:24:26.014]                   }
[10:24:26.014]                   muffleCondition(cond)
[10:24:26.014]                 })
[10:24:26.014]             }))
[10:24:26.014]             future::FutureResult(value = ...future.value$value, 
[10:24:26.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:26.014]                   ...future.rng), globalenv = if (FALSE) 
[10:24:26.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:26.014]                     ...future.globalenv.names))
[10:24:26.014]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:26.014]         }, condition = base::local({
[10:24:26.014]             c <- base::c
[10:24:26.014]             inherits <- base::inherits
[10:24:26.014]             invokeRestart <- base::invokeRestart
[10:24:26.014]             length <- base::length
[10:24:26.014]             list <- base::list
[10:24:26.014]             seq.int <- base::seq.int
[10:24:26.014]             signalCondition <- base::signalCondition
[10:24:26.014]             sys.calls <- base::sys.calls
[10:24:26.014]             `[[` <- base::`[[`
[10:24:26.014]             `+` <- base::`+`
[10:24:26.014]             `<<-` <- base::`<<-`
[10:24:26.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:26.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:26.014]                   3L)]
[10:24:26.014]             }
[10:24:26.014]             function(cond) {
[10:24:26.014]                 is_error <- inherits(cond, "error")
[10:24:26.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:26.014]                   NULL)
[10:24:26.014]                 if (is_error) {
[10:24:26.014]                   sessionInformation <- function() {
[10:24:26.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:26.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:26.014]                       search = base::search(), system = base::Sys.info())
[10:24:26.014]                   }
[10:24:26.014]                   ...future.conditions[[length(...future.conditions) + 
[10:24:26.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:26.014]                     cond$call), session = sessionInformation(), 
[10:24:26.014]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:26.014]                   signalCondition(cond)
[10:24:26.014]                 }
[10:24:26.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:26.014]                 "immediateCondition"))) {
[10:24:26.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:26.014]                   ...future.conditions[[length(...future.conditions) + 
[10:24:26.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:26.014]                   if (TRUE && !signal) {
[10:24:26.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:26.014]                     {
[10:24:26.014]                       inherits <- base::inherits
[10:24:26.014]                       invokeRestart <- base::invokeRestart
[10:24:26.014]                       is.null <- base::is.null
[10:24:26.014]                       muffled <- FALSE
[10:24:26.014]                       if (inherits(cond, "message")) {
[10:24:26.014]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:26.014]                         if (muffled) 
[10:24:26.014]                           invokeRestart("muffleMessage")
[10:24:26.014]                       }
[10:24:26.014]                       else if (inherits(cond, "warning")) {
[10:24:26.014]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:26.014]                         if (muffled) 
[10:24:26.014]                           invokeRestart("muffleWarning")
[10:24:26.014]                       }
[10:24:26.014]                       else if (inherits(cond, "condition")) {
[10:24:26.014]                         if (!is.null(pattern)) {
[10:24:26.014]                           computeRestarts <- base::computeRestarts
[10:24:26.014]                           grepl <- base::grepl
[10:24:26.014]                           restarts <- computeRestarts(cond)
[10:24:26.014]                           for (restart in restarts) {
[10:24:26.014]                             name <- restart$name
[10:24:26.014]                             if (is.null(name)) 
[10:24:26.014]                               next
[10:24:26.014]                             if (!grepl(pattern, name)) 
[10:24:26.014]                               next
[10:24:26.014]                             invokeRestart(restart)
[10:24:26.014]                             muffled <- TRUE
[10:24:26.014]                             break
[10:24:26.014]                           }
[10:24:26.014]                         }
[10:24:26.014]                       }
[10:24:26.014]                       invisible(muffled)
[10:24:26.014]                     }
[10:24:26.014]                     muffleCondition(cond, pattern = "^muffle")
[10:24:26.014]                   }
[10:24:26.014]                 }
[10:24:26.014]                 else {
[10:24:26.014]                   if (TRUE) {
[10:24:26.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:26.014]                     {
[10:24:26.014]                       inherits <- base::inherits
[10:24:26.014]                       invokeRestart <- base::invokeRestart
[10:24:26.014]                       is.null <- base::is.null
[10:24:26.014]                       muffled <- FALSE
[10:24:26.014]                       if (inherits(cond, "message")) {
[10:24:26.014]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:26.014]                         if (muffled) 
[10:24:26.014]                           invokeRestart("muffleMessage")
[10:24:26.014]                       }
[10:24:26.014]                       else if (inherits(cond, "warning")) {
[10:24:26.014]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:26.014]                         if (muffled) 
[10:24:26.014]                           invokeRestart("muffleWarning")
[10:24:26.014]                       }
[10:24:26.014]                       else if (inherits(cond, "condition")) {
[10:24:26.014]                         if (!is.null(pattern)) {
[10:24:26.014]                           computeRestarts <- base::computeRestarts
[10:24:26.014]                           grepl <- base::grepl
[10:24:26.014]                           restarts <- computeRestarts(cond)
[10:24:26.014]                           for (restart in restarts) {
[10:24:26.014]                             name <- restart$name
[10:24:26.014]                             if (is.null(name)) 
[10:24:26.014]                               next
[10:24:26.014]                             if (!grepl(pattern, name)) 
[10:24:26.014]                               next
[10:24:26.014]                             invokeRestart(restart)
[10:24:26.014]                             muffled <- TRUE
[10:24:26.014]                             break
[10:24:26.014]                           }
[10:24:26.014]                         }
[10:24:26.014]                       }
[10:24:26.014]                       invisible(muffled)
[10:24:26.014]                     }
[10:24:26.014]                     muffleCondition(cond, pattern = "^muffle")
[10:24:26.014]                   }
[10:24:26.014]                 }
[10:24:26.014]             }
[10:24:26.014]         }))
[10:24:26.014]     }, error = function(ex) {
[10:24:26.014]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:26.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:26.014]                 ...future.rng), started = ...future.startTime, 
[10:24:26.014]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:26.014]             version = "1.8"), class = "FutureResult")
[10:24:26.014]     }, finally = {
[10:24:26.014]         if (!identical(...future.workdir, getwd())) 
[10:24:26.014]             setwd(...future.workdir)
[10:24:26.014]         {
[10:24:26.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:26.014]                 ...future.oldOptions$nwarnings <- NULL
[10:24:26.014]             }
[10:24:26.014]             base::options(...future.oldOptions)
[10:24:26.014]             if (.Platform$OS.type == "windows") {
[10:24:26.014]                 old_names <- names(...future.oldEnvVars)
[10:24:26.014]                 envs <- base::Sys.getenv()
[10:24:26.014]                 names <- names(envs)
[10:24:26.014]                 common <- intersect(names, old_names)
[10:24:26.014]                 added <- setdiff(names, old_names)
[10:24:26.014]                 removed <- setdiff(old_names, names)
[10:24:26.014]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:26.014]                   envs[common]]
[10:24:26.014]                 NAMES <- toupper(changed)
[10:24:26.014]                 args <- list()
[10:24:26.014]                 for (kk in seq_along(NAMES)) {
[10:24:26.014]                   name <- changed[[kk]]
[10:24:26.014]                   NAME <- NAMES[[kk]]
[10:24:26.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:26.014]                     next
[10:24:26.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:26.014]                 }
[10:24:26.014]                 NAMES <- toupper(added)
[10:24:26.014]                 for (kk in seq_along(NAMES)) {
[10:24:26.014]                   name <- added[[kk]]
[10:24:26.014]                   NAME <- NAMES[[kk]]
[10:24:26.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:26.014]                     next
[10:24:26.014]                   args[[name]] <- ""
[10:24:26.014]                 }
[10:24:26.014]                 NAMES <- toupper(removed)
[10:24:26.014]                 for (kk in seq_along(NAMES)) {
[10:24:26.014]                   name <- removed[[kk]]
[10:24:26.014]                   NAME <- NAMES[[kk]]
[10:24:26.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:26.014]                     next
[10:24:26.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:26.014]                 }
[10:24:26.014]                 if (length(args) > 0) 
[10:24:26.014]                   base::do.call(base::Sys.setenv, args = args)
[10:24:26.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:26.014]             }
[10:24:26.014]             else {
[10:24:26.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:26.014]             }
[10:24:26.014]             {
[10:24:26.014]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:26.014]                   0L) {
[10:24:26.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:26.014]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:26.014]                   base::options(opts)
[10:24:26.014]                 }
[10:24:26.014]                 {
[10:24:26.014]                   {
[10:24:26.014]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:26.014]                     NULL
[10:24:26.014]                   }
[10:24:26.014]                   options(future.plan = NULL)
[10:24:26.014]                   if (is.na(NA_character_)) 
[10:24:26.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:26.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:26.014]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:26.014]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:26.014]                     envir = parent.frame()) 
[10:24:26.014]                   {
[10:24:26.014]                     if (is.function(workers)) 
[10:24:26.014]                       workers <- workers()
[10:24:26.014]                     workers <- structure(as.integer(workers), 
[10:24:26.014]                       class = class(workers))
[10:24:26.014]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:26.014]                       workers >= 1)
[10:24:26.014]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:26.014]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:26.014]                     }
[10:24:26.014]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:26.014]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:26.014]                       envir = envir)
[10:24:26.014]                     if (!future$lazy) 
[10:24:26.014]                       future <- run(future)
[10:24:26.014]                     invisible(future)
[10:24:26.014]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:26.014]                 }
[10:24:26.014]             }
[10:24:26.014]         }
[10:24:26.014]     })
[10:24:26.014]     if (TRUE) {
[10:24:26.014]         base::sink(type = "output", split = FALSE)
[10:24:26.014]         if (TRUE) {
[10:24:26.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:26.014]         }
[10:24:26.014]         else {
[10:24:26.014]             ...future.result["stdout"] <- base::list(NULL)
[10:24:26.014]         }
[10:24:26.014]         base::close(...future.stdout)
[10:24:26.014]         ...future.stdout <- NULL
[10:24:26.014]     }
[10:24:26.014]     ...future.result$conditions <- ...future.conditions
[10:24:26.014]     ...future.result$finished <- base::Sys.time()
[10:24:26.014]     ...future.result
[10:24:26.014] }
[10:24:26.017] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[10:24:26.017] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:24:26.062] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:24:26.062] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[10:24:26.062] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[10:24:26.063] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:24:26.063] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:24:26.063] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:24:26.106] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:24:26.106] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:24:26.150] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:24:26.150] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:24:26.150] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:24:26.150] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:24:26.151] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:24:26.151] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:26.151] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:26.152] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:24:26.152] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:24:26.152] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:26.153] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:26.153] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:26.153] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:26.153] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[10:24:26.154] MultisessionFuture started
[10:24:26.154] - Launch lazy future ... done
[10:24:26.154] run() for ‘MultisessionFuture’ ... done
[10:24:26.154] Created future:
[10:24:26.154] MultisessionFuture:
[10:24:26.154] Label: ‘future_vapply-2’
[10:24:26.154] Expression:
[10:24:26.154] {
[10:24:26.154]     do.call(function(...) {
[10:24:26.154]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:26.154]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:26.154]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:26.154]             on.exit(options(oopts), add = TRUE)
[10:24:26.154]         }
[10:24:26.154]         {
[10:24:26.154]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:26.154]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:26.154]                 ...future.FUN(...future.X_jj, ...)
[10:24:26.154]             })
[10:24:26.154]         }
[10:24:26.154]     }, args = future.call.arguments)
[10:24:26.154] }
[10:24:26.154] Lazy evaluation: FALSE
[10:24:26.154] Asynchronous evaluation: TRUE
[10:24:26.154] Local evaluation: TRUE
[10:24:26.154] Environment: R_GlobalEnv
[10:24:26.154] Capture standard output: TRUE
[10:24:26.154] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:26.154] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:24:26.154] Packages: 1 packages (‘future.apply’)
[10:24:26.154] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:26.154] Resolved: FALSE
[10:24:26.154] Value: <not collected>
[10:24:26.154] Conditions captured: <none>
[10:24:26.154] Early signaling: FALSE
[10:24:26.154] Owner process: d9e52b82-5ca1-d211-b26b-877e131c4a5e
[10:24:26.154] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:26.166] Chunk #2 of 2 ... DONE
[10:24:26.166] Launching 2 futures (chunks) ... DONE
[10:24:26.166] Resolving 2 futures (chunks) ...
[10:24:26.167] resolve() on list ...
[10:24:26.167]  recursive: 0
[10:24:26.167]  length: 2
[10:24:26.167] 
[10:24:26.167] receiveMessageFromWorker() for ClusterFuture ...
[10:24:26.167] - Validating connection of MultisessionFuture
[10:24:26.171] - received message: FutureResult
[10:24:26.171] - Received FutureResult
[10:24:26.171] - Erased future from FutureRegistry
[10:24:26.171] result() for ClusterFuture ...
[10:24:26.171] - result already collected: FutureResult
[10:24:26.171] result() for ClusterFuture ... done
[10:24:26.171] signalConditions() ...
[10:24:26.172]  - include = ‘immediateCondition’
[10:24:26.172]  - exclude = 
[10:24:26.172]  - resignal = FALSE
[10:24:26.172]  - Number of conditions: 1
[10:24:26.172] signalConditions() ... done
[10:24:26.172] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:26.172] Future #1
[10:24:26.172] result() for ClusterFuture ...
[10:24:26.172] - result already collected: FutureResult
[10:24:26.172] result() for ClusterFuture ... done
[10:24:26.172] result() for ClusterFuture ...
[10:24:26.173] - result already collected: FutureResult
[10:24:26.173] result() for ClusterFuture ... done
[10:24:26.173] signalConditions() ...
[10:24:26.173]  - include = ‘immediateCondition’
[10:24:26.173]  - exclude = 
[10:24:26.173]  - resignal = FALSE
[10:24:26.173]  - Number of conditions: 1
[10:24:26.173] signalConditions() ... done
[10:24:26.173] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:26.173] - nx: 2
[10:24:26.173] - relay: TRUE
[10:24:26.174] - stdout: TRUE
[10:24:26.174] - signal: TRUE
[10:24:26.174] - resignal: FALSE
[10:24:26.174] - force: TRUE
[10:24:26.174] - relayed: [n=2] FALSE, FALSE
[10:24:26.174] - queued futures: [n=2] FALSE, FALSE
[10:24:26.174]  - until=1
[10:24:26.174]  - relaying element #1
[10:24:26.174] result() for ClusterFuture ...
[10:24:26.174] - result already collected: FutureResult
[10:24:26.174] result() for ClusterFuture ... done
[10:24:26.175] result() for ClusterFuture ...
[10:24:26.175] - result already collected: FutureResult
[10:24:26.175] result() for ClusterFuture ... done
[10:24:26.175] signalConditions() ...
[10:24:26.175]  - include = ‘immediateCondition’
[10:24:26.175]  - exclude = 
[10:24:26.175]  - resignal = FALSE
[10:24:26.175]  - Number of conditions: 1
[10:24:26.175] signalConditions() ... done
[10:24:26.175] result() for ClusterFuture ...
[10:24:26.175] - result already collected: FutureResult
[10:24:26.176] result() for ClusterFuture ... done
[10:24:26.176] signalConditions() ...
[10:24:26.176]  - include = ‘immediateCondition’
[10:24:26.176]  - exclude = 
[10:24:26.176]  - resignal = FALSE
[10:24:26.176]  - Number of conditions: 1
[10:24:26.176] signalConditions() ... done
[10:24:26.176] result() for ClusterFuture ...
[10:24:26.176] - result already collected: FutureResult
[10:24:26.176] result() for ClusterFuture ... done
[10:24:26.176] signalConditions() ...
[10:24:26.176]  - include = ‘condition’
[10:24:26.177]  - exclude = ‘immediateCondition’
[10:24:26.177]  - resignal = TRUE
[10:24:26.177]  - Number of conditions: 1
[10:24:26.177]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:24:26.177] signalConditions() ... done
[10:24:26.177] - relayed: [n=2] FALSE, FALSE
[10:24:26.177] - queued futures: [n=2] TRUE, FALSE
[10:24:26.177] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:26.177] plan(): Setting new future strategy stack:
[10:24:26.177] List of future strategies:
[10:24:26.177] 1. sequential:
[10:24:26.177]    - args: function (..., envir = parent.frame())
[10:24:26.177]    - tweaked: FALSE
[10:24:26.177]    - call: plan(sequential)
[10:24:26.178] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[10:24:26.179] plan(): Setting new future strategy stack:
[10:24:26.179] List of future strategies:
[10:24:26.179] 1. FutureStrategy:
[10:24:26.179]    - args: function (..., envir = parent.frame())
[10:24:26.179]    - tweaked: FALSE
[10:24:26.179]    - call: future::plan(oplan)
[10:24:26.180] plan(): nbrOfWorkers() = 1
> 
