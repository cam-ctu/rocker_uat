
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:03:12.267] plan(): Setting new future strategy stack:
[16:03:12.267] List of future strategies:
[16:03:12.267] 1. sequential:
[16:03:12.267]    - args: function (..., envir = parent.frame())
[16:03:12.267]    - tweaked: FALSE
[16:03:12.267]    - call: future::plan("sequential")
[16:03:12.281] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:03:12.383] plan(): Setting new future strategy stack:
[16:03:12.383] List of future strategies:
[16:03:12.383] 1. sequential:
[16:03:12.383]    - args: function (..., envir = parent.frame())
[16:03:12.383]    - tweaked: FALSE
[16:03:12.383]    - call: plan(strategy)
[16:03:12.395] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[16:03:12.400] future_lapply() ...
[16:03:12.406] Number of chunks: 1
[16:03:12.407] getGlobalsAndPackagesXApply() ...
[16:03:12.407]  - future.globals: TRUE
[16:03:12.407] getGlobalsAndPackages() ...
[16:03:12.407] Searching for globals...
[16:03:12.411] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:12.412] Searching for globals ... DONE
[16:03:12.412] Resolving globals: FALSE
[16:03:12.413] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[16:03:12.414] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:12.414] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.414] - packages: [1] ‘future.apply’
[16:03:12.414] getGlobalsAndPackages() ... DONE
[16:03:12.414]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.414]  - needed namespaces: [n=1] ‘future.apply’
[16:03:12.415] Finding globals ... DONE
[16:03:12.415]  - use_args: TRUE
[16:03:12.415]  - Getting '...' globals ...
[16:03:12.416] resolve() on list ...
[16:03:12.416]  recursive: 0
[16:03:12.416]  length: 1
[16:03:12.416]  elements: ‘...’
[16:03:12.416]  length: 0 (resolved future 1)
[16:03:12.416] resolve() on list ... DONE
[16:03:12.416]    - '...' content: [n=0] 
[16:03:12.417] List of 1
[16:03:12.417]  $ ...: list()
[16:03:12.417]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.417]  - attr(*, "where")=List of 1
[16:03:12.417]   ..$ ...:<environment: 0x564e4172bc50> 
[16:03:12.417]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.417]  - attr(*, "resolved")= logi TRUE
[16:03:12.417]  - attr(*, "total_size")= num NA
[16:03:12.419]  - Getting '...' globals ... DONE
[16:03:12.419] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:12.419] List of 8
[16:03:12.419]  $ ...future.FUN:function (x, ...)  
[16:03:12.419]  $ x_FUN        :function (x)  
[16:03:12.419]  $ times        : int 1
[16:03:12.419]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.419]  $ stop_if_not  :function (...)  
[16:03:12.419]  $ dim          : NULL
[16:03:12.419]  $ valid_types  : chr "character"
[16:03:12.419]  $ ...          : list()
[16:03:12.419]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.419]  - attr(*, "where")=List of 8
[16:03:12.419]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.419]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:12.419]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:12.419]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:12.419]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:12.419]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:12.419]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:12.419]   ..$ ...          :<environment: 0x564e4172bc50> 
[16:03:12.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.419]  - attr(*, "resolved")= logi FALSE
[16:03:12.419]  - attr(*, "total_size")= num 94208
[16:03:12.428] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:12.428] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.428] Number of futures (= number of chunks): 1
[16:03:12.428] Launching 1 futures (chunks) ...
[16:03:12.428] Chunk #1 of 1 ...
[16:03:12.429]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.429] getGlobalsAndPackages() ...
[16:03:12.429] Searching for globals...
[16:03:12.429] 
[16:03:12.429] Searching for globals ... DONE
[16:03:12.429] - globals: [0] <none>
[16:03:12.430] getGlobalsAndPackages() ... DONE
[16:03:12.430]    + additional globals found: [n=0] 
[16:03:12.430]    + additional namespaces needed: [n=0] 
[16:03:12.430]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.430]  - seeds: <none>
[16:03:12.430]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.430] getGlobalsAndPackages() ...
[16:03:12.430] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.430] Resolving globals: FALSE
[16:03:12.431] Tweak future expression to call with '...' arguments ...
[16:03:12.431] {
[16:03:12.431]     do.call(function(...) {
[16:03:12.431]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.431]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.431]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.431]             on.exit(options(oopts), add = TRUE)
[16:03:12.431]         }
[16:03:12.431]         {
[16:03:12.431]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.431]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.431]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.431]             })
[16:03:12.431]         }
[16:03:12.431]     }, args = future.call.arguments)
[16:03:12.431] }
[16:03:12.431] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.431] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.432] - packages: [1] ‘future.apply’
[16:03:12.432] getGlobalsAndPackages() ... DONE
[16:03:12.432] run() for ‘Future’ ...
[16:03:12.433] - state: ‘created’
[16:03:12.433] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.433] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.433]   - Field: ‘label’
[16:03:12.433]   - Field: ‘local’
[16:03:12.434]   - Field: ‘owner’
[16:03:12.434]   - Field: ‘envir’
[16:03:12.434]   - Field: ‘packages’
[16:03:12.434]   - Field: ‘gc’
[16:03:12.434]   - Field: ‘conditions’
[16:03:12.434]   - Field: ‘expr’
[16:03:12.434]   - Field: ‘uuid’
[16:03:12.434]   - Field: ‘seed’
[16:03:12.434]   - Field: ‘version’
[16:03:12.434]   - Field: ‘result’
[16:03:12.434]   - Field: ‘asynchronous’
[16:03:12.434]   - Field: ‘calls’
[16:03:12.435]   - Field: ‘globals’
[16:03:12.435]   - Field: ‘stdout’
[16:03:12.435]   - Field: ‘earlySignal’
[16:03:12.435]   - Field: ‘lazy’
[16:03:12.435]   - Field: ‘state’
[16:03:12.435] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.435] - Launch lazy future ...
[16:03:12.436] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:12.436] Packages needed by future strategies (n = 0): <none>
[16:03:12.437] {
[16:03:12.437]     {
[16:03:12.437]         {
[16:03:12.437]             ...future.startTime <- base::Sys.time()
[16:03:12.437]             {
[16:03:12.437]                 {
[16:03:12.437]                   {
[16:03:12.437]                     {
[16:03:12.437]                       base::local({
[16:03:12.437]                         has_future <- base::requireNamespace("future", 
[16:03:12.437]                           quietly = TRUE)
[16:03:12.437]                         if (has_future) {
[16:03:12.437]                           ns <- base::getNamespace("future")
[16:03:12.437]                           version <- ns[[".package"]][["version"]]
[16:03:12.437]                           if (is.null(version)) 
[16:03:12.437]                             version <- utils::packageVersion("future")
[16:03:12.437]                         }
[16:03:12.437]                         else {
[16:03:12.437]                           version <- NULL
[16:03:12.437]                         }
[16:03:12.437]                         if (!has_future || version < "1.8.0") {
[16:03:12.437]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.437]                             "", base::R.version$version.string), 
[16:03:12.437]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:12.437]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.437]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.437]                               "release", "version")], collapse = " "), 
[16:03:12.437]                             hostname = base::Sys.info()[["nodename"]])
[16:03:12.437]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.437]                             info)
[16:03:12.437]                           info <- base::paste(info, collapse = "; ")
[16:03:12.437]                           if (!has_future) {
[16:03:12.437]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.437]                               info)
[16:03:12.437]                           }
[16:03:12.437]                           else {
[16:03:12.437]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.437]                               info, version)
[16:03:12.437]                           }
[16:03:12.437]                           base::stop(msg)
[16:03:12.437]                         }
[16:03:12.437]                       })
[16:03:12.437]                     }
[16:03:12.437]                     base::local({
[16:03:12.437]                       for (pkg in "future.apply") {
[16:03:12.437]                         base::loadNamespace(pkg)
[16:03:12.437]                         base::library(pkg, character.only = TRUE)
[16:03:12.437]                       }
[16:03:12.437]                     })
[16:03:12.437]                   }
[16:03:12.437]                   options(future.plan = NULL)
[16:03:12.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.437]                 }
[16:03:12.437]                 ...future.workdir <- getwd()
[16:03:12.437]             }
[16:03:12.437]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.437]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.437]         }
[16:03:12.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.437]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.437]             base::names(...future.oldOptions))
[16:03:12.437]     }
[16:03:12.437]     if (FALSE) {
[16:03:12.437]     }
[16:03:12.437]     else {
[16:03:12.437]         if (TRUE) {
[16:03:12.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.437]                 open = "w")
[16:03:12.437]         }
[16:03:12.437]         else {
[16:03:12.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.437]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.437]         }
[16:03:12.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.437]             base::sink(type = "output", split = FALSE)
[16:03:12.437]             base::close(...future.stdout)
[16:03:12.437]         }, add = TRUE)
[16:03:12.437]     }
[16:03:12.437]     ...future.frame <- base::sys.nframe()
[16:03:12.437]     ...future.conditions <- base::list()
[16:03:12.437]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.437]     if (FALSE) {
[16:03:12.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.437]     }
[16:03:12.437]     ...future.result <- base::tryCatch({
[16:03:12.437]         base::withCallingHandlers({
[16:03:12.437]             ...future.value <- base::withVisible(base::local({
[16:03:12.437]                 do.call(function(...) {
[16:03:12.437]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.437]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.437]                     ...future.globals.maxSize)) {
[16:03:12.437]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.437]                     on.exit(options(oopts), add = TRUE)
[16:03:12.437]                   }
[16:03:12.437]                   {
[16:03:12.437]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.437]                       FUN = function(jj) {
[16:03:12.437]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.437]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.437]                       })
[16:03:12.437]                   }
[16:03:12.437]                 }, args = future.call.arguments)
[16:03:12.437]             }))
[16:03:12.437]             future::FutureResult(value = ...future.value$value, 
[16:03:12.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.437]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.437]                     ...future.globalenv.names))
[16:03:12.437]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.437]         }, condition = base::local({
[16:03:12.437]             c <- base::c
[16:03:12.437]             inherits <- base::inherits
[16:03:12.437]             invokeRestart <- base::invokeRestart
[16:03:12.437]             length <- base::length
[16:03:12.437]             list <- base::list
[16:03:12.437]             seq.int <- base::seq.int
[16:03:12.437]             signalCondition <- base::signalCondition
[16:03:12.437]             sys.calls <- base::sys.calls
[16:03:12.437]             `[[` <- base::`[[`
[16:03:12.437]             `+` <- base::`+`
[16:03:12.437]             `<<-` <- base::`<<-`
[16:03:12.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.437]                   3L)]
[16:03:12.437]             }
[16:03:12.437]             function(cond) {
[16:03:12.437]                 is_error <- inherits(cond, "error")
[16:03:12.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.437]                   NULL)
[16:03:12.437]                 if (is_error) {
[16:03:12.437]                   sessionInformation <- function() {
[16:03:12.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.437]                       search = base::search(), system = base::Sys.info())
[16:03:12.437]                   }
[16:03:12.437]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.437]                     cond$call), session = sessionInformation(), 
[16:03:12.437]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.437]                   signalCondition(cond)
[16:03:12.437]                 }
[16:03:12.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.437]                 "immediateCondition"))) {
[16:03:12.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.437]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.437]                   if (TRUE && !signal) {
[16:03:12.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.437]                     {
[16:03:12.437]                       inherits <- base::inherits
[16:03:12.437]                       invokeRestart <- base::invokeRestart
[16:03:12.437]                       is.null <- base::is.null
[16:03:12.437]                       muffled <- FALSE
[16:03:12.437]                       if (inherits(cond, "message")) {
[16:03:12.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.437]                         if (muffled) 
[16:03:12.437]                           invokeRestart("muffleMessage")
[16:03:12.437]                       }
[16:03:12.437]                       else if (inherits(cond, "warning")) {
[16:03:12.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.437]                         if (muffled) 
[16:03:12.437]                           invokeRestart("muffleWarning")
[16:03:12.437]                       }
[16:03:12.437]                       else if (inherits(cond, "condition")) {
[16:03:12.437]                         if (!is.null(pattern)) {
[16:03:12.437]                           computeRestarts <- base::computeRestarts
[16:03:12.437]                           grepl <- base::grepl
[16:03:12.437]                           restarts <- computeRestarts(cond)
[16:03:12.437]                           for (restart in restarts) {
[16:03:12.437]                             name <- restart$name
[16:03:12.437]                             if (is.null(name)) 
[16:03:12.437]                               next
[16:03:12.437]                             if (!grepl(pattern, name)) 
[16:03:12.437]                               next
[16:03:12.437]                             invokeRestart(restart)
[16:03:12.437]                             muffled <- TRUE
[16:03:12.437]                             break
[16:03:12.437]                           }
[16:03:12.437]                         }
[16:03:12.437]                       }
[16:03:12.437]                       invisible(muffled)
[16:03:12.437]                     }
[16:03:12.437]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.437]                   }
[16:03:12.437]                 }
[16:03:12.437]                 else {
[16:03:12.437]                   if (TRUE) {
[16:03:12.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.437]                     {
[16:03:12.437]                       inherits <- base::inherits
[16:03:12.437]                       invokeRestart <- base::invokeRestart
[16:03:12.437]                       is.null <- base::is.null
[16:03:12.437]                       muffled <- FALSE
[16:03:12.437]                       if (inherits(cond, "message")) {
[16:03:12.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.437]                         if (muffled) 
[16:03:12.437]                           invokeRestart("muffleMessage")
[16:03:12.437]                       }
[16:03:12.437]                       else if (inherits(cond, "warning")) {
[16:03:12.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.437]                         if (muffled) 
[16:03:12.437]                           invokeRestart("muffleWarning")
[16:03:12.437]                       }
[16:03:12.437]                       else if (inherits(cond, "condition")) {
[16:03:12.437]                         if (!is.null(pattern)) {
[16:03:12.437]                           computeRestarts <- base::computeRestarts
[16:03:12.437]                           grepl <- base::grepl
[16:03:12.437]                           restarts <- computeRestarts(cond)
[16:03:12.437]                           for (restart in restarts) {
[16:03:12.437]                             name <- restart$name
[16:03:12.437]                             if (is.null(name)) 
[16:03:12.437]                               next
[16:03:12.437]                             if (!grepl(pattern, name)) 
[16:03:12.437]                               next
[16:03:12.437]                             invokeRestart(restart)
[16:03:12.437]                             muffled <- TRUE
[16:03:12.437]                             break
[16:03:12.437]                           }
[16:03:12.437]                         }
[16:03:12.437]                       }
[16:03:12.437]                       invisible(muffled)
[16:03:12.437]                     }
[16:03:12.437]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.437]                   }
[16:03:12.437]                 }
[16:03:12.437]             }
[16:03:12.437]         }))
[16:03:12.437]     }, error = function(ex) {
[16:03:12.437]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.437]                 ...future.rng), started = ...future.startTime, 
[16:03:12.437]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.437]             version = "1.8"), class = "FutureResult")
[16:03:12.437]     }, finally = {
[16:03:12.437]         if (!identical(...future.workdir, getwd())) 
[16:03:12.437]             setwd(...future.workdir)
[16:03:12.437]         {
[16:03:12.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.437]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.437]             }
[16:03:12.437]             base::options(...future.oldOptions)
[16:03:12.437]             if (.Platform$OS.type == "windows") {
[16:03:12.437]                 old_names <- names(...future.oldEnvVars)
[16:03:12.437]                 envs <- base::Sys.getenv()
[16:03:12.437]                 names <- names(envs)
[16:03:12.437]                 common <- intersect(names, old_names)
[16:03:12.437]                 added <- setdiff(names, old_names)
[16:03:12.437]                 removed <- setdiff(old_names, names)
[16:03:12.437]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.437]                   envs[common]]
[16:03:12.437]                 NAMES <- toupper(changed)
[16:03:12.437]                 args <- list()
[16:03:12.437]                 for (kk in seq_along(NAMES)) {
[16:03:12.437]                   name <- changed[[kk]]
[16:03:12.437]                   NAME <- NAMES[[kk]]
[16:03:12.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.437]                     next
[16:03:12.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.437]                 }
[16:03:12.437]                 NAMES <- toupper(added)
[16:03:12.437]                 for (kk in seq_along(NAMES)) {
[16:03:12.437]                   name <- added[[kk]]
[16:03:12.437]                   NAME <- NAMES[[kk]]
[16:03:12.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.437]                     next
[16:03:12.437]                   args[[name]] <- ""
[16:03:12.437]                 }
[16:03:12.437]                 NAMES <- toupper(removed)
[16:03:12.437]                 for (kk in seq_along(NAMES)) {
[16:03:12.437]                   name <- removed[[kk]]
[16:03:12.437]                   NAME <- NAMES[[kk]]
[16:03:12.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.437]                     next
[16:03:12.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.437]                 }
[16:03:12.437]                 if (length(args) > 0) 
[16:03:12.437]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.437]             }
[16:03:12.437]             else {
[16:03:12.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.437]             }
[16:03:12.437]             {
[16:03:12.437]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.437]                   0L) {
[16:03:12.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.437]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.437]                   base::options(opts)
[16:03:12.437]                 }
[16:03:12.437]                 {
[16:03:12.437]                   {
[16:03:12.437]                     NULL
[16:03:12.437]                     RNGkind("Mersenne-Twister")
[16:03:12.437]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.437]                       inherits = FALSE)
[16:03:12.437]                   }
[16:03:12.437]                   options(future.plan = NULL)
[16:03:12.437]                   if (is.na(NA_character_)) 
[16:03:12.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.437]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.437]                   {
[16:03:12.437]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.437]                     if (!future$lazy) 
[16:03:12.437]                       future <- run(future)
[16:03:12.437]                     invisible(future)
[16:03:12.437]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.437]                 }
[16:03:12.437]             }
[16:03:12.437]         }
[16:03:12.437]     })
[16:03:12.437]     if (TRUE) {
[16:03:12.437]         base::sink(type = "output", split = FALSE)
[16:03:12.437]         if (TRUE) {
[16:03:12.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.437]         }
[16:03:12.437]         else {
[16:03:12.437]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.437]         }
[16:03:12.437]         base::close(...future.stdout)
[16:03:12.437]         ...future.stdout <- NULL
[16:03:12.437]     }
[16:03:12.437]     ...future.result$conditions <- ...future.conditions
[16:03:12.437]     ...future.result$finished <- base::Sys.time()
[16:03:12.437]     ...future.result
[16:03:12.437] }
[16:03:12.439] assign_globals() ...
[16:03:12.439] List of 11
[16:03:12.439]  $ ...future.FUN            :function (x, ...)  
[16:03:12.439]  $ x_FUN                    :function (x)  
[16:03:12.439]  $ times                    : int 1
[16:03:12.439]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.439]  $ stop_if_not              :function (...)  
[16:03:12.439]  $ dim                      : NULL
[16:03:12.439]  $ valid_types              : chr "character"
[16:03:12.439]  $ future.call.arguments    : list()
[16:03:12.439]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.439]  $ ...future.elements_ii    :List of 2
[16:03:12.439]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:03:12.439]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[16:03:12.439]  $ ...future.seeds_ii       : NULL
[16:03:12.439]  $ ...future.globals.maxSize: NULL
[16:03:12.439]  - attr(*, "where")=List of 11
[16:03:12.439]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.439]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:12.439]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:12.439]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:12.439]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:12.439]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:12.439]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:12.439]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.439]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.439]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.439]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.439]  - attr(*, "resolved")= logi FALSE
[16:03:12.439]  - attr(*, "total_size")= num 94208
[16:03:12.439]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.439]  - attr(*, "already-done")= logi TRUE
[16:03:12.446] - copied ‘...future.FUN’ to environment
[16:03:12.447] - copied ‘x_FUN’ to environment
[16:03:12.447] - copied ‘times’ to environment
[16:03:12.447] - copied ‘stopf’ to environment
[16:03:12.447] - copied ‘stop_if_not’ to environment
[16:03:12.447] - copied ‘dim’ to environment
[16:03:12.447] - copied ‘valid_types’ to environment
[16:03:12.447] - copied ‘future.call.arguments’ to environment
[16:03:12.448] - copied ‘...future.elements_ii’ to environment
[16:03:12.448] - copied ‘...future.seeds_ii’ to environment
[16:03:12.448] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.448] assign_globals() ... done
[16:03:12.448] plan(): Setting new future strategy stack:
[16:03:12.448] List of future strategies:
[16:03:12.448] 1. sequential:
[16:03:12.448]    - args: function (..., envir = parent.frame())
[16:03:12.448]    - tweaked: FALSE
[16:03:12.448]    - call: NULL
[16:03:12.449] plan(): nbrOfWorkers() = 1
[16:03:12.450] plan(): Setting new future strategy stack:
[16:03:12.450] List of future strategies:
[16:03:12.450] 1. sequential:
[16:03:12.450]    - args: function (..., envir = parent.frame())
[16:03:12.450]    - tweaked: FALSE
[16:03:12.450]    - call: plan(strategy)
[16:03:12.450] plan(): nbrOfWorkers() = 1
[16:03:12.450] SequentialFuture started (and completed)
[16:03:12.451] - Launch lazy future ... done
[16:03:12.451] run() for ‘SequentialFuture’ ... done
[16:03:12.451] Created future:
[16:03:12.451] SequentialFuture:
[16:03:12.451] Label: ‘future_vapply-1’
[16:03:12.451] Expression:
[16:03:12.451] {
[16:03:12.451]     do.call(function(...) {
[16:03:12.451]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.451]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.451]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.451]             on.exit(options(oopts), add = TRUE)
[16:03:12.451]         }
[16:03:12.451]         {
[16:03:12.451]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.451]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.451]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.451]             })
[16:03:12.451]         }
[16:03:12.451]     }, args = future.call.arguments)
[16:03:12.451] }
[16:03:12.451] Lazy evaluation: FALSE
[16:03:12.451] Asynchronous evaluation: FALSE
[16:03:12.451] Local evaluation: TRUE
[16:03:12.451] Environment: R_GlobalEnv
[16:03:12.451] Capture standard output: TRUE
[16:03:12.451] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.451] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:12.451] Packages: 1 packages (‘future.apply’)
[16:03:12.451] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.451] Resolved: TRUE
[16:03:12.451] Value: 232 bytes of class ‘list’
[16:03:12.451] Early signaling: FALSE
[16:03:12.451] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.451] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.453] Chunk #1 of 1 ... DONE
[16:03:12.453] Launching 1 futures (chunks) ... DONE
[16:03:12.453] Resolving 1 futures (chunks) ...
[16:03:12.453] resolve() on list ...
[16:03:12.453]  recursive: 0
[16:03:12.453]  length: 1
[16:03:12.453] 
[16:03:12.454] resolved() for ‘SequentialFuture’ ...
[16:03:12.454] - state: ‘finished’
[16:03:12.454] - run: TRUE
[16:03:12.454] - result: ‘FutureResult’
[16:03:12.454] resolved() for ‘SequentialFuture’ ... done
[16:03:12.454] Future #1
[16:03:12.456] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.456] - nx: 1
[16:03:12.456] - relay: TRUE
[16:03:12.456] - stdout: TRUE
[16:03:12.456] - signal: TRUE
[16:03:12.456] - resignal: FALSE
[16:03:12.457] - force: TRUE
[16:03:12.457] - relayed: [n=1] FALSE
[16:03:12.457] - queued futures: [n=1] FALSE
[16:03:12.457]  - until=1
[16:03:12.457]  - relaying element #1
[16:03:12.457] - relayed: [n=1] TRUE
[16:03:12.457] - queued futures: [n=1] TRUE
[16:03:12.457] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.458]  length: 0 (resolved future 1)
[16:03:12.458] Relaying remaining futures
[16:03:12.458] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.458] - nx: 1
[16:03:12.458] - relay: TRUE
[16:03:12.458] - stdout: TRUE
[16:03:12.458] - signal: TRUE
[16:03:12.458] - resignal: FALSE
[16:03:12.458] - force: TRUE
[16:03:12.458] - relayed: [n=1] TRUE
[16:03:12.458] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.459] - relayed: [n=1] TRUE
[16:03:12.459] - queued futures: [n=1] TRUE
[16:03:12.459] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.459] resolve() on list ... DONE
[16:03:12.459]  - Number of value chunks collected: 1
[16:03:12.459] Resolving 1 futures (chunks) ... DONE
[16:03:12.459] Reducing values from 1 chunks ...
[16:03:12.459]  - Number of values collected after concatenation: 2
[16:03:12.459]  - Number of values expected: 2
[16:03:12.460] Reducing values from 1 chunks ... DONE
[16:03:12.460] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[16:03:12.461] future_lapply() ...
[16:03:12.462] Number of chunks: 1
[16:03:12.462] getGlobalsAndPackagesXApply() ...
[16:03:12.463]  - future.globals: TRUE
[16:03:12.463] getGlobalsAndPackages() ...
[16:03:12.463] Searching for globals...
[16:03:12.466] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[16:03:12.466] Searching for globals ... DONE
[16:03:12.466] Resolving globals: FALSE
[16:03:12.467] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[16:03:12.467] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:12.468] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.468] - packages: [1] ‘future.apply’
[16:03:12.468] getGlobalsAndPackages() ... DONE
[16:03:12.468]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.468]  - needed namespaces: [n=1] ‘future.apply’
[16:03:12.468] Finding globals ... DONE
[16:03:12.468]  - use_args: TRUE
[16:03:12.468]  - Getting '...' globals ...
[16:03:12.468] resolve() on list ...
[16:03:12.469]  recursive: 0
[16:03:12.469]  length: 1
[16:03:12.469]  elements: ‘...’
[16:03:12.469]  length: 0 (resolved future 1)
[16:03:12.469] resolve() on list ... DONE
[16:03:12.469]    - '...' content: [n=0] 
[16:03:12.469] List of 1
[16:03:12.469]  $ ...: list()
[16:03:12.469]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.469]  - attr(*, "where")=List of 1
[16:03:12.469]   ..$ ...:<environment: 0x564e41feae30> 
[16:03:12.469]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.469]  - attr(*, "resolved")= logi TRUE
[16:03:12.469]  - attr(*, "total_size")= num NA
[16:03:12.471]  - Getting '...' globals ... DONE
[16:03:12.472] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:12.472] List of 8
[16:03:12.472]  $ ...future.FUN:function (x, ...)  
[16:03:12.472]  $ x_FUN        :function (x)  
[16:03:12.472]  $ times        : int 0
[16:03:12.472]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.472]  $ stop_if_not  :function (...)  
[16:03:12.472]  $ dim          : NULL
[16:03:12.472]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:12.472]  $ ...          : list()
[16:03:12.472]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.472]  - attr(*, "where")=List of 8
[16:03:12.472]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.472]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:12.472]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:12.472]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:12.472]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:12.472]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:12.472]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:12.472]   ..$ ...          :<environment: 0x564e41feae30> 
[16:03:12.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.472]  - attr(*, "resolved")= logi FALSE
[16:03:12.472]  - attr(*, "total_size")= num 95472
[16:03:12.478] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:12.478] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.478] Number of futures (= number of chunks): 1
[16:03:12.478] Launching 1 futures (chunks) ...
[16:03:12.478] Chunk #1 of 1 ...
[16:03:12.479]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.479] getGlobalsAndPackages() ...
[16:03:12.479] Searching for globals...
[16:03:12.479] 
[16:03:12.479] Searching for globals ... DONE
[16:03:12.479] - globals: [0] <none>
[16:03:12.479] getGlobalsAndPackages() ... DONE
[16:03:12.479]    + additional globals found: [n=0] 
[16:03:12.479]    + additional namespaces needed: [n=0] 
[16:03:12.480]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.480]  - seeds: <none>
[16:03:12.480]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.480] getGlobalsAndPackages() ...
[16:03:12.480] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.480] Resolving globals: FALSE
[16:03:12.480] Tweak future expression to call with '...' arguments ...
[16:03:12.480] {
[16:03:12.480]     do.call(function(...) {
[16:03:12.480]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.480]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.480]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.480]             on.exit(options(oopts), add = TRUE)
[16:03:12.480]         }
[16:03:12.480]         {
[16:03:12.480]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.480]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.480]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.480]             })
[16:03:12.480]         }
[16:03:12.480]     }, args = future.call.arguments)
[16:03:12.480] }
[16:03:12.480] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.481] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.481] - packages: [1] ‘future.apply’
[16:03:12.481] getGlobalsAndPackages() ... DONE
[16:03:12.481] run() for ‘Future’ ...
[16:03:12.481] - state: ‘created’
[16:03:12.482] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.482] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.482]   - Field: ‘label’
[16:03:12.482]   - Field: ‘local’
[16:03:12.482]   - Field: ‘owner’
[16:03:12.482]   - Field: ‘envir’
[16:03:12.482]   - Field: ‘packages’
[16:03:12.483]   - Field: ‘gc’
[16:03:12.483]   - Field: ‘conditions’
[16:03:12.483]   - Field: ‘expr’
[16:03:12.483]   - Field: ‘uuid’
[16:03:12.483]   - Field: ‘seed’
[16:03:12.483]   - Field: ‘version’
[16:03:12.483]   - Field: ‘result’
[16:03:12.483]   - Field: ‘asynchronous’
[16:03:12.483]   - Field: ‘calls’
[16:03:12.483]   - Field: ‘globals’
[16:03:12.484]   - Field: ‘stdout’
[16:03:12.484]   - Field: ‘earlySignal’
[16:03:12.484]   - Field: ‘lazy’
[16:03:12.484]   - Field: ‘state’
[16:03:12.484] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.484] - Launch lazy future ...
[16:03:12.484] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:12.484] Packages needed by future strategies (n = 0): <none>
[16:03:12.485] {
[16:03:12.485]     {
[16:03:12.485]         {
[16:03:12.485]             ...future.startTime <- base::Sys.time()
[16:03:12.485]             {
[16:03:12.485]                 {
[16:03:12.485]                   {
[16:03:12.485]                     {
[16:03:12.485]                       base::local({
[16:03:12.485]                         has_future <- base::requireNamespace("future", 
[16:03:12.485]                           quietly = TRUE)
[16:03:12.485]                         if (has_future) {
[16:03:12.485]                           ns <- base::getNamespace("future")
[16:03:12.485]                           version <- ns[[".package"]][["version"]]
[16:03:12.485]                           if (is.null(version)) 
[16:03:12.485]                             version <- utils::packageVersion("future")
[16:03:12.485]                         }
[16:03:12.485]                         else {
[16:03:12.485]                           version <- NULL
[16:03:12.485]                         }
[16:03:12.485]                         if (!has_future || version < "1.8.0") {
[16:03:12.485]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.485]                             "", base::R.version$version.string), 
[16:03:12.485]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:12.485]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.485]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.485]                               "release", "version")], collapse = " "), 
[16:03:12.485]                             hostname = base::Sys.info()[["nodename"]])
[16:03:12.485]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.485]                             info)
[16:03:12.485]                           info <- base::paste(info, collapse = "; ")
[16:03:12.485]                           if (!has_future) {
[16:03:12.485]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.485]                               info)
[16:03:12.485]                           }
[16:03:12.485]                           else {
[16:03:12.485]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.485]                               info, version)
[16:03:12.485]                           }
[16:03:12.485]                           base::stop(msg)
[16:03:12.485]                         }
[16:03:12.485]                       })
[16:03:12.485]                     }
[16:03:12.485]                     base::local({
[16:03:12.485]                       for (pkg in "future.apply") {
[16:03:12.485]                         base::loadNamespace(pkg)
[16:03:12.485]                         base::library(pkg, character.only = TRUE)
[16:03:12.485]                       }
[16:03:12.485]                     })
[16:03:12.485]                   }
[16:03:12.485]                   options(future.plan = NULL)
[16:03:12.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.485]                 }
[16:03:12.485]                 ...future.workdir <- getwd()
[16:03:12.485]             }
[16:03:12.485]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.485]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.485]         }
[16:03:12.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.485]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.485]             base::names(...future.oldOptions))
[16:03:12.485]     }
[16:03:12.485]     if (FALSE) {
[16:03:12.485]     }
[16:03:12.485]     else {
[16:03:12.485]         if (TRUE) {
[16:03:12.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.485]                 open = "w")
[16:03:12.485]         }
[16:03:12.485]         else {
[16:03:12.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.485]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.485]         }
[16:03:12.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.485]             base::sink(type = "output", split = FALSE)
[16:03:12.485]             base::close(...future.stdout)
[16:03:12.485]         }, add = TRUE)
[16:03:12.485]     }
[16:03:12.485]     ...future.frame <- base::sys.nframe()
[16:03:12.485]     ...future.conditions <- base::list()
[16:03:12.485]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.485]     if (FALSE) {
[16:03:12.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.485]     }
[16:03:12.485]     ...future.result <- base::tryCatch({
[16:03:12.485]         base::withCallingHandlers({
[16:03:12.485]             ...future.value <- base::withVisible(base::local({
[16:03:12.485]                 do.call(function(...) {
[16:03:12.485]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.485]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.485]                     ...future.globals.maxSize)) {
[16:03:12.485]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.485]                     on.exit(options(oopts), add = TRUE)
[16:03:12.485]                   }
[16:03:12.485]                   {
[16:03:12.485]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.485]                       FUN = function(jj) {
[16:03:12.485]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.485]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.485]                       })
[16:03:12.485]                   }
[16:03:12.485]                 }, args = future.call.arguments)
[16:03:12.485]             }))
[16:03:12.485]             future::FutureResult(value = ...future.value$value, 
[16:03:12.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.485]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.485]                     ...future.globalenv.names))
[16:03:12.485]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.485]         }, condition = base::local({
[16:03:12.485]             c <- base::c
[16:03:12.485]             inherits <- base::inherits
[16:03:12.485]             invokeRestart <- base::invokeRestart
[16:03:12.485]             length <- base::length
[16:03:12.485]             list <- base::list
[16:03:12.485]             seq.int <- base::seq.int
[16:03:12.485]             signalCondition <- base::signalCondition
[16:03:12.485]             sys.calls <- base::sys.calls
[16:03:12.485]             `[[` <- base::`[[`
[16:03:12.485]             `+` <- base::`+`
[16:03:12.485]             `<<-` <- base::`<<-`
[16:03:12.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.485]                   3L)]
[16:03:12.485]             }
[16:03:12.485]             function(cond) {
[16:03:12.485]                 is_error <- inherits(cond, "error")
[16:03:12.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.485]                   NULL)
[16:03:12.485]                 if (is_error) {
[16:03:12.485]                   sessionInformation <- function() {
[16:03:12.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.485]                       search = base::search(), system = base::Sys.info())
[16:03:12.485]                   }
[16:03:12.485]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.485]                     cond$call), session = sessionInformation(), 
[16:03:12.485]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.485]                   signalCondition(cond)
[16:03:12.485]                 }
[16:03:12.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.485]                 "immediateCondition"))) {
[16:03:12.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.485]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.485]                   if (TRUE && !signal) {
[16:03:12.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.485]                     {
[16:03:12.485]                       inherits <- base::inherits
[16:03:12.485]                       invokeRestart <- base::invokeRestart
[16:03:12.485]                       is.null <- base::is.null
[16:03:12.485]                       muffled <- FALSE
[16:03:12.485]                       if (inherits(cond, "message")) {
[16:03:12.485]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.485]                         if (muffled) 
[16:03:12.485]                           invokeRestart("muffleMessage")
[16:03:12.485]                       }
[16:03:12.485]                       else if (inherits(cond, "warning")) {
[16:03:12.485]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.485]                         if (muffled) 
[16:03:12.485]                           invokeRestart("muffleWarning")
[16:03:12.485]                       }
[16:03:12.485]                       else if (inherits(cond, "condition")) {
[16:03:12.485]                         if (!is.null(pattern)) {
[16:03:12.485]                           computeRestarts <- base::computeRestarts
[16:03:12.485]                           grepl <- base::grepl
[16:03:12.485]                           restarts <- computeRestarts(cond)
[16:03:12.485]                           for (restart in restarts) {
[16:03:12.485]                             name <- restart$name
[16:03:12.485]                             if (is.null(name)) 
[16:03:12.485]                               next
[16:03:12.485]                             if (!grepl(pattern, name)) 
[16:03:12.485]                               next
[16:03:12.485]                             invokeRestart(restart)
[16:03:12.485]                             muffled <- TRUE
[16:03:12.485]                             break
[16:03:12.485]                           }
[16:03:12.485]                         }
[16:03:12.485]                       }
[16:03:12.485]                       invisible(muffled)
[16:03:12.485]                     }
[16:03:12.485]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.485]                   }
[16:03:12.485]                 }
[16:03:12.485]                 else {
[16:03:12.485]                   if (TRUE) {
[16:03:12.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.485]                     {
[16:03:12.485]                       inherits <- base::inherits
[16:03:12.485]                       invokeRestart <- base::invokeRestart
[16:03:12.485]                       is.null <- base::is.null
[16:03:12.485]                       muffled <- FALSE
[16:03:12.485]                       if (inherits(cond, "message")) {
[16:03:12.485]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.485]                         if (muffled) 
[16:03:12.485]                           invokeRestart("muffleMessage")
[16:03:12.485]                       }
[16:03:12.485]                       else if (inherits(cond, "warning")) {
[16:03:12.485]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.485]                         if (muffled) 
[16:03:12.485]                           invokeRestart("muffleWarning")
[16:03:12.485]                       }
[16:03:12.485]                       else if (inherits(cond, "condition")) {
[16:03:12.485]                         if (!is.null(pattern)) {
[16:03:12.485]                           computeRestarts <- base::computeRestarts
[16:03:12.485]                           grepl <- base::grepl
[16:03:12.485]                           restarts <- computeRestarts(cond)
[16:03:12.485]                           for (restart in restarts) {
[16:03:12.485]                             name <- restart$name
[16:03:12.485]                             if (is.null(name)) 
[16:03:12.485]                               next
[16:03:12.485]                             if (!grepl(pattern, name)) 
[16:03:12.485]                               next
[16:03:12.485]                             invokeRestart(restart)
[16:03:12.485]                             muffled <- TRUE
[16:03:12.485]                             break
[16:03:12.485]                           }
[16:03:12.485]                         }
[16:03:12.485]                       }
[16:03:12.485]                       invisible(muffled)
[16:03:12.485]                     }
[16:03:12.485]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.485]                   }
[16:03:12.485]                 }
[16:03:12.485]             }
[16:03:12.485]         }))
[16:03:12.485]     }, error = function(ex) {
[16:03:12.485]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.485]                 ...future.rng), started = ...future.startTime, 
[16:03:12.485]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.485]             version = "1.8"), class = "FutureResult")
[16:03:12.485]     }, finally = {
[16:03:12.485]         if (!identical(...future.workdir, getwd())) 
[16:03:12.485]             setwd(...future.workdir)
[16:03:12.485]         {
[16:03:12.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.485]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.485]             }
[16:03:12.485]             base::options(...future.oldOptions)
[16:03:12.485]             if (.Platform$OS.type == "windows") {
[16:03:12.485]                 old_names <- names(...future.oldEnvVars)
[16:03:12.485]                 envs <- base::Sys.getenv()
[16:03:12.485]                 names <- names(envs)
[16:03:12.485]                 common <- intersect(names, old_names)
[16:03:12.485]                 added <- setdiff(names, old_names)
[16:03:12.485]                 removed <- setdiff(old_names, names)
[16:03:12.485]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.485]                   envs[common]]
[16:03:12.485]                 NAMES <- toupper(changed)
[16:03:12.485]                 args <- list()
[16:03:12.485]                 for (kk in seq_along(NAMES)) {
[16:03:12.485]                   name <- changed[[kk]]
[16:03:12.485]                   NAME <- NAMES[[kk]]
[16:03:12.485]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.485]                     next
[16:03:12.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.485]                 }
[16:03:12.485]                 NAMES <- toupper(added)
[16:03:12.485]                 for (kk in seq_along(NAMES)) {
[16:03:12.485]                   name <- added[[kk]]
[16:03:12.485]                   NAME <- NAMES[[kk]]
[16:03:12.485]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.485]                     next
[16:03:12.485]                   args[[name]] <- ""
[16:03:12.485]                 }
[16:03:12.485]                 NAMES <- toupper(removed)
[16:03:12.485]                 for (kk in seq_along(NAMES)) {
[16:03:12.485]                   name <- removed[[kk]]
[16:03:12.485]                   NAME <- NAMES[[kk]]
[16:03:12.485]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.485]                     next
[16:03:12.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.485]                 }
[16:03:12.485]                 if (length(args) > 0) 
[16:03:12.485]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.485]             }
[16:03:12.485]             else {
[16:03:12.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.485]             }
[16:03:12.485]             {
[16:03:12.485]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.485]                   0L) {
[16:03:12.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.485]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.485]                   base::options(opts)
[16:03:12.485]                 }
[16:03:12.485]                 {
[16:03:12.485]                   {
[16:03:12.485]                     NULL
[16:03:12.485]                     RNGkind("Mersenne-Twister")
[16:03:12.485]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.485]                       inherits = FALSE)
[16:03:12.485]                   }
[16:03:12.485]                   options(future.plan = NULL)
[16:03:12.485]                   if (is.na(NA_character_)) 
[16:03:12.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.485]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.485]                   {
[16:03:12.485]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.485]                     if (!future$lazy) 
[16:03:12.485]                       future <- run(future)
[16:03:12.485]                     invisible(future)
[16:03:12.485]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.485]                 }
[16:03:12.485]             }
[16:03:12.485]         }
[16:03:12.485]     })
[16:03:12.485]     if (TRUE) {
[16:03:12.485]         base::sink(type = "output", split = FALSE)
[16:03:12.485]         if (TRUE) {
[16:03:12.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.485]         }
[16:03:12.485]         else {
[16:03:12.485]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.485]         }
[16:03:12.485]         base::close(...future.stdout)
[16:03:12.485]         ...future.stdout <- NULL
[16:03:12.485]     }
[16:03:12.485]     ...future.result$conditions <- ...future.conditions
[16:03:12.485]     ...future.result$finished <- base::Sys.time()
[16:03:12.485]     ...future.result
[16:03:12.485] }
[16:03:12.486] assign_globals() ...
[16:03:12.487] List of 11
[16:03:12.487]  $ ...future.FUN            :function (x, ...)  
[16:03:12.487]  $ x_FUN                    :function (x)  
[16:03:12.487]  $ times                    : int 0
[16:03:12.487]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.487]  $ stop_if_not              :function (...)  
[16:03:12.487]  $ dim                      : NULL
[16:03:12.487]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:12.487]  $ future.call.arguments    : list()
[16:03:12.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.487]  $ ...future.elements_ii    :List of 10
[16:03:12.487]   ..$ : int 1
[16:03:12.487]   ..$ : int 2
[16:03:12.487]   ..$ : int 3
[16:03:12.487]   ..$ : int 4
[16:03:12.487]   ..$ : int 5
[16:03:12.487]   ..$ : int 6
[16:03:12.487]   ..$ : int 7
[16:03:12.487]   ..$ : int 8
[16:03:12.487]   ..$ : int 9
[16:03:12.487]   ..$ : int 10
[16:03:12.487]  $ ...future.seeds_ii       : NULL
[16:03:12.487]  $ ...future.globals.maxSize: NULL
[16:03:12.487]  - attr(*, "where")=List of 11
[16:03:12.487]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.487]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:12.487]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:12.487]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:12.487]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:12.487]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:12.487]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:12.487]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.487]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.487]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.487]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.487]  - attr(*, "resolved")= logi FALSE
[16:03:12.487]  - attr(*, "total_size")= num 95472
[16:03:12.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.487]  - attr(*, "already-done")= logi TRUE
[16:03:12.496] - copied ‘...future.FUN’ to environment
[16:03:12.496] - reassign environment for ‘x_FUN’
[16:03:12.496] - copied ‘x_FUN’ to environment
[16:03:12.496] - copied ‘times’ to environment
[16:03:12.496] - copied ‘stopf’ to environment
[16:03:12.497] - copied ‘stop_if_not’ to environment
[16:03:12.497] - copied ‘dim’ to environment
[16:03:12.497] - copied ‘valid_types’ to environment
[16:03:12.497] - copied ‘future.call.arguments’ to environment
[16:03:12.497] - copied ‘...future.elements_ii’ to environment
[16:03:12.497] - copied ‘...future.seeds_ii’ to environment
[16:03:12.497] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.497] assign_globals() ... done
[16:03:12.498] plan(): Setting new future strategy stack:
[16:03:12.498] List of future strategies:
[16:03:12.498] 1. sequential:
[16:03:12.498]    - args: function (..., envir = parent.frame())
[16:03:12.498]    - tweaked: FALSE
[16:03:12.498]    - call: NULL
[16:03:12.498] plan(): nbrOfWorkers() = 1
[16:03:12.500] plan(): Setting new future strategy stack:
[16:03:12.500] List of future strategies:
[16:03:12.500] 1. sequential:
[16:03:12.500]    - args: function (..., envir = parent.frame())
[16:03:12.500]    - tweaked: FALSE
[16:03:12.500]    - call: plan(strategy)
[16:03:12.501] plan(): nbrOfWorkers() = 1
[16:03:12.501] SequentialFuture started (and completed)
[16:03:12.501] - Launch lazy future ... done
[16:03:12.501] run() for ‘SequentialFuture’ ... done
[16:03:12.501] Created future:
[16:03:12.501] SequentialFuture:
[16:03:12.501] Label: ‘future_vapply-1’
[16:03:12.501] Expression:
[16:03:12.501] {
[16:03:12.501]     do.call(function(...) {
[16:03:12.501]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.501]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.501]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.501]             on.exit(options(oopts), add = TRUE)
[16:03:12.501]         }
[16:03:12.501]         {
[16:03:12.501]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.501]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.501]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.501]             })
[16:03:12.501]         }
[16:03:12.501]     }, args = future.call.arguments)
[16:03:12.501] }
[16:03:12.501] Lazy evaluation: FALSE
[16:03:12.501] Asynchronous evaluation: FALSE
[16:03:12.501] Local evaluation: TRUE
[16:03:12.501] Environment: R_GlobalEnv
[16:03:12.501] Capture standard output: TRUE
[16:03:12.501] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.501] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:12.501] Packages: 1 packages (‘future.apply’)
[16:03:12.501] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.501] Resolved: TRUE
[16:03:12.501] Value: 480 bytes of class ‘list’
[16:03:12.501] Early signaling: FALSE
[16:03:12.501] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.501] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.503] Chunk #1 of 1 ... DONE
[16:03:12.503] Launching 1 futures (chunks) ... DONE
[16:03:12.503] Resolving 1 futures (chunks) ...
[16:03:12.503] resolve() on list ...
[16:03:12.503]  recursive: 0
[16:03:12.503]  length: 1
[16:03:12.503] 
[16:03:12.503] resolved() for ‘SequentialFuture’ ...
[16:03:12.503] - state: ‘finished’
[16:03:12.503] - run: TRUE
[16:03:12.503] - result: ‘FutureResult’
[16:03:12.504] resolved() for ‘SequentialFuture’ ... done
[16:03:12.504] Future #1
[16:03:12.504] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.504] - nx: 1
[16:03:12.504] - relay: TRUE
[16:03:12.504] - stdout: TRUE
[16:03:12.504] - signal: TRUE
[16:03:12.504] - resignal: FALSE
[16:03:12.504] - force: TRUE
[16:03:12.504] - relayed: [n=1] FALSE
[16:03:12.504] - queued futures: [n=1] FALSE
[16:03:12.505]  - until=1
[16:03:12.505]  - relaying element #1
[16:03:12.505] - relayed: [n=1] TRUE
[16:03:12.505] - queued futures: [n=1] TRUE
[16:03:12.505] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.505]  length: 0 (resolved future 1)
[16:03:12.505] Relaying remaining futures
[16:03:12.505] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.505] - nx: 1
[16:03:12.506] - relay: TRUE
[16:03:12.506] - stdout: TRUE
[16:03:12.506] - signal: TRUE
[16:03:12.506] - resignal: FALSE
[16:03:12.506] - force: TRUE
[16:03:12.506] - relayed: [n=1] TRUE
[16:03:12.506] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.506] - relayed: [n=1] TRUE
[16:03:12.506] - queued futures: [n=1] TRUE
[16:03:12.506] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.506] resolve() on list ... DONE
[16:03:12.507]  - Number of value chunks collected: 1
[16:03:12.507] Resolving 1 futures (chunks) ... DONE
[16:03:12.507] Reducing values from 1 chunks ...
[16:03:12.507]  - Number of values collected after concatenation: 10
[16:03:12.507]  - Number of values expected: 10
[16:03:12.507] Reducing values from 1 chunks ... DONE
[16:03:12.507] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[16:03:12.508] future_lapply() ...
[16:03:12.510] Number of chunks: 1
[16:03:12.510] getGlobalsAndPackagesXApply() ...
[16:03:12.510]  - future.globals: TRUE
[16:03:12.510] getGlobalsAndPackages() ...
[16:03:12.510] Searching for globals...
[16:03:12.513] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[16:03:12.513] Searching for globals ... DONE
[16:03:12.514] Resolving globals: FALSE
[16:03:12.514] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[16:03:12.515] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:12.515] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.515] - packages: [1] ‘future.apply’
[16:03:12.515] getGlobalsAndPackages() ... DONE
[16:03:12.515]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.515]  - needed namespaces: [n=1] ‘future.apply’
[16:03:12.515] Finding globals ... DONE
[16:03:12.516]  - use_args: TRUE
[16:03:12.516]  - Getting '...' globals ...
[16:03:12.516] resolve() on list ...
[16:03:12.516]  recursive: 0
[16:03:12.516]  length: 1
[16:03:12.516]  elements: ‘...’
[16:03:12.516]  length: 0 (resolved future 1)
[16:03:12.516] resolve() on list ... DONE
[16:03:12.516]    - '...' content: [n=0] 
[16:03:12.517] List of 1
[16:03:12.517]  $ ...: list()
[16:03:12.517]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.517]  - attr(*, "where")=List of 1
[16:03:12.517]   ..$ ...:<environment: 0x564e422e0320> 
[16:03:12.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.517]  - attr(*, "resolved")= logi TRUE
[16:03:12.517]  - attr(*, "total_size")= num NA
[16:03:12.519]  - Getting '...' globals ... DONE
[16:03:12.519] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:12.519] List of 8
[16:03:12.519]  $ ...future.FUN:function (x, ...)  
[16:03:12.519]  $ x_FUN        :function (x)  
[16:03:12.519]  $ times        : int 0
[16:03:12.519]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.519]  $ stop_if_not  :function (...)  
[16:03:12.519]  $ dim          : NULL
[16:03:12.519]  $ valid_types  : chr [1:2] "logical" "integer"
[16:03:12.519]  $ ...          : list()
[16:03:12.519]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.519]  - attr(*, "where")=List of 8
[16:03:12.519]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.519]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:12.519]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:12.519]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:12.519]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:12.519]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:12.519]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:12.519]   ..$ ...          :<environment: 0x564e422e0320> 
[16:03:12.519]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.519]  - attr(*, "resolved")= logi FALSE
[16:03:12.519]  - attr(*, "total_size")= num 95400
[16:03:12.526] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:12.526] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.526] Number of futures (= number of chunks): 1
[16:03:12.526] Launching 1 futures (chunks) ...
[16:03:12.526] Chunk #1 of 1 ...
[16:03:12.526]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.526] getGlobalsAndPackages() ...
[16:03:12.526] Searching for globals...
[16:03:12.527] 
[16:03:12.527] Searching for globals ... DONE
[16:03:12.527] - globals: [0] <none>
[16:03:12.527] getGlobalsAndPackages() ... DONE
[16:03:12.527]    + additional globals found: [n=0] 
[16:03:12.527]    + additional namespaces needed: [n=0] 
[16:03:12.527]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.527]  - seeds: <none>
[16:03:12.527]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.528] getGlobalsAndPackages() ...
[16:03:12.528] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.528] Resolving globals: FALSE
[16:03:12.528] Tweak future expression to call with '...' arguments ...
[16:03:12.528] {
[16:03:12.528]     do.call(function(...) {
[16:03:12.528]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.528]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.528]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.528]             on.exit(options(oopts), add = TRUE)
[16:03:12.528]         }
[16:03:12.528]         {
[16:03:12.528]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.528]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.528]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.528]             })
[16:03:12.528]         }
[16:03:12.528]     }, args = future.call.arguments)
[16:03:12.528] }
[16:03:12.528] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.529] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.529] - packages: [1] ‘future.apply’
[16:03:12.529] getGlobalsAndPackages() ... DONE
[16:03:12.529] run() for ‘Future’ ...
[16:03:12.529] - state: ‘created’
[16:03:12.529] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.530] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.530] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.530]   - Field: ‘label’
[16:03:12.530]   - Field: ‘local’
[16:03:12.530]   - Field: ‘owner’
[16:03:12.530]   - Field: ‘envir’
[16:03:12.530]   - Field: ‘packages’
[16:03:12.530]   - Field: ‘gc’
[16:03:12.531]   - Field: ‘conditions’
[16:03:12.531]   - Field: ‘expr’
[16:03:12.531]   - Field: ‘uuid’
[16:03:12.531]   - Field: ‘seed’
[16:03:12.531]   - Field: ‘version’
[16:03:12.531]   - Field: ‘result’
[16:03:12.531]   - Field: ‘asynchronous’
[16:03:12.531]   - Field: ‘calls’
[16:03:12.531]   - Field: ‘globals’
[16:03:12.531]   - Field: ‘stdout’
[16:03:12.531]   - Field: ‘earlySignal’
[16:03:12.532]   - Field: ‘lazy’
[16:03:12.532]   - Field: ‘state’
[16:03:12.532] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.532] - Launch lazy future ...
[16:03:12.532] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:12.532] Packages needed by future strategies (n = 0): <none>
[16:03:12.533] {
[16:03:12.533]     {
[16:03:12.533]         {
[16:03:12.533]             ...future.startTime <- base::Sys.time()
[16:03:12.533]             {
[16:03:12.533]                 {
[16:03:12.533]                   {
[16:03:12.533]                     {
[16:03:12.533]                       base::local({
[16:03:12.533]                         has_future <- base::requireNamespace("future", 
[16:03:12.533]                           quietly = TRUE)
[16:03:12.533]                         if (has_future) {
[16:03:12.533]                           ns <- base::getNamespace("future")
[16:03:12.533]                           version <- ns[[".package"]][["version"]]
[16:03:12.533]                           if (is.null(version)) 
[16:03:12.533]                             version <- utils::packageVersion("future")
[16:03:12.533]                         }
[16:03:12.533]                         else {
[16:03:12.533]                           version <- NULL
[16:03:12.533]                         }
[16:03:12.533]                         if (!has_future || version < "1.8.0") {
[16:03:12.533]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.533]                             "", base::R.version$version.string), 
[16:03:12.533]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:12.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.533]                               "release", "version")], collapse = " "), 
[16:03:12.533]                             hostname = base::Sys.info()[["nodename"]])
[16:03:12.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.533]                             info)
[16:03:12.533]                           info <- base::paste(info, collapse = "; ")
[16:03:12.533]                           if (!has_future) {
[16:03:12.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.533]                               info)
[16:03:12.533]                           }
[16:03:12.533]                           else {
[16:03:12.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.533]                               info, version)
[16:03:12.533]                           }
[16:03:12.533]                           base::stop(msg)
[16:03:12.533]                         }
[16:03:12.533]                       })
[16:03:12.533]                     }
[16:03:12.533]                     base::local({
[16:03:12.533]                       for (pkg in "future.apply") {
[16:03:12.533]                         base::loadNamespace(pkg)
[16:03:12.533]                         base::library(pkg, character.only = TRUE)
[16:03:12.533]                       }
[16:03:12.533]                     })
[16:03:12.533]                   }
[16:03:12.533]                   options(future.plan = NULL)
[16:03:12.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.533]                 }
[16:03:12.533]                 ...future.workdir <- getwd()
[16:03:12.533]             }
[16:03:12.533]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.533]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.533]         }
[16:03:12.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.533]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.533]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.533]             base::names(...future.oldOptions))
[16:03:12.533]     }
[16:03:12.533]     if (FALSE) {
[16:03:12.533]     }
[16:03:12.533]     else {
[16:03:12.533]         if (TRUE) {
[16:03:12.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.533]                 open = "w")
[16:03:12.533]         }
[16:03:12.533]         else {
[16:03:12.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.533]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.533]         }
[16:03:12.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.533]             base::sink(type = "output", split = FALSE)
[16:03:12.533]             base::close(...future.stdout)
[16:03:12.533]         }, add = TRUE)
[16:03:12.533]     }
[16:03:12.533]     ...future.frame <- base::sys.nframe()
[16:03:12.533]     ...future.conditions <- base::list()
[16:03:12.533]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.533]     if (FALSE) {
[16:03:12.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.533]     }
[16:03:12.533]     ...future.result <- base::tryCatch({
[16:03:12.533]         base::withCallingHandlers({
[16:03:12.533]             ...future.value <- base::withVisible(base::local({
[16:03:12.533]                 do.call(function(...) {
[16:03:12.533]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.533]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.533]                     ...future.globals.maxSize)) {
[16:03:12.533]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.533]                     on.exit(options(oopts), add = TRUE)
[16:03:12.533]                   }
[16:03:12.533]                   {
[16:03:12.533]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.533]                       FUN = function(jj) {
[16:03:12.533]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.533]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.533]                       })
[16:03:12.533]                   }
[16:03:12.533]                 }, args = future.call.arguments)
[16:03:12.533]             }))
[16:03:12.533]             future::FutureResult(value = ...future.value$value, 
[16:03:12.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.533]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.533]                     ...future.globalenv.names))
[16:03:12.533]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.533]         }, condition = base::local({
[16:03:12.533]             c <- base::c
[16:03:12.533]             inherits <- base::inherits
[16:03:12.533]             invokeRestart <- base::invokeRestart
[16:03:12.533]             length <- base::length
[16:03:12.533]             list <- base::list
[16:03:12.533]             seq.int <- base::seq.int
[16:03:12.533]             signalCondition <- base::signalCondition
[16:03:12.533]             sys.calls <- base::sys.calls
[16:03:12.533]             `[[` <- base::`[[`
[16:03:12.533]             `+` <- base::`+`
[16:03:12.533]             `<<-` <- base::`<<-`
[16:03:12.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.533]                   3L)]
[16:03:12.533]             }
[16:03:12.533]             function(cond) {
[16:03:12.533]                 is_error <- inherits(cond, "error")
[16:03:12.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.533]                   NULL)
[16:03:12.533]                 if (is_error) {
[16:03:12.533]                   sessionInformation <- function() {
[16:03:12.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.533]                       search = base::search(), system = base::Sys.info())
[16:03:12.533]                   }
[16:03:12.533]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.533]                     cond$call), session = sessionInformation(), 
[16:03:12.533]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.533]                   signalCondition(cond)
[16:03:12.533]                 }
[16:03:12.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.533]                 "immediateCondition"))) {
[16:03:12.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.533]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.533]                   if (TRUE && !signal) {
[16:03:12.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.533]                     {
[16:03:12.533]                       inherits <- base::inherits
[16:03:12.533]                       invokeRestart <- base::invokeRestart
[16:03:12.533]                       is.null <- base::is.null
[16:03:12.533]                       muffled <- FALSE
[16:03:12.533]                       if (inherits(cond, "message")) {
[16:03:12.533]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.533]                         if (muffled) 
[16:03:12.533]                           invokeRestart("muffleMessage")
[16:03:12.533]                       }
[16:03:12.533]                       else if (inherits(cond, "warning")) {
[16:03:12.533]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.533]                         if (muffled) 
[16:03:12.533]                           invokeRestart("muffleWarning")
[16:03:12.533]                       }
[16:03:12.533]                       else if (inherits(cond, "condition")) {
[16:03:12.533]                         if (!is.null(pattern)) {
[16:03:12.533]                           computeRestarts <- base::computeRestarts
[16:03:12.533]                           grepl <- base::grepl
[16:03:12.533]                           restarts <- computeRestarts(cond)
[16:03:12.533]                           for (restart in restarts) {
[16:03:12.533]                             name <- restart$name
[16:03:12.533]                             if (is.null(name)) 
[16:03:12.533]                               next
[16:03:12.533]                             if (!grepl(pattern, name)) 
[16:03:12.533]                               next
[16:03:12.533]                             invokeRestart(restart)
[16:03:12.533]                             muffled <- TRUE
[16:03:12.533]                             break
[16:03:12.533]                           }
[16:03:12.533]                         }
[16:03:12.533]                       }
[16:03:12.533]                       invisible(muffled)
[16:03:12.533]                     }
[16:03:12.533]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.533]                   }
[16:03:12.533]                 }
[16:03:12.533]                 else {
[16:03:12.533]                   if (TRUE) {
[16:03:12.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.533]                     {
[16:03:12.533]                       inherits <- base::inherits
[16:03:12.533]                       invokeRestart <- base::invokeRestart
[16:03:12.533]                       is.null <- base::is.null
[16:03:12.533]                       muffled <- FALSE
[16:03:12.533]                       if (inherits(cond, "message")) {
[16:03:12.533]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.533]                         if (muffled) 
[16:03:12.533]                           invokeRestart("muffleMessage")
[16:03:12.533]                       }
[16:03:12.533]                       else if (inherits(cond, "warning")) {
[16:03:12.533]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.533]                         if (muffled) 
[16:03:12.533]                           invokeRestart("muffleWarning")
[16:03:12.533]                       }
[16:03:12.533]                       else if (inherits(cond, "condition")) {
[16:03:12.533]                         if (!is.null(pattern)) {
[16:03:12.533]                           computeRestarts <- base::computeRestarts
[16:03:12.533]                           grepl <- base::grepl
[16:03:12.533]                           restarts <- computeRestarts(cond)
[16:03:12.533]                           for (restart in restarts) {
[16:03:12.533]                             name <- restart$name
[16:03:12.533]                             if (is.null(name)) 
[16:03:12.533]                               next
[16:03:12.533]                             if (!grepl(pattern, name)) 
[16:03:12.533]                               next
[16:03:12.533]                             invokeRestart(restart)
[16:03:12.533]                             muffled <- TRUE
[16:03:12.533]                             break
[16:03:12.533]                           }
[16:03:12.533]                         }
[16:03:12.533]                       }
[16:03:12.533]                       invisible(muffled)
[16:03:12.533]                     }
[16:03:12.533]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.533]                   }
[16:03:12.533]                 }
[16:03:12.533]             }
[16:03:12.533]         }))
[16:03:12.533]     }, error = function(ex) {
[16:03:12.533]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.533]                 ...future.rng), started = ...future.startTime, 
[16:03:12.533]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.533]             version = "1.8"), class = "FutureResult")
[16:03:12.533]     }, finally = {
[16:03:12.533]         if (!identical(...future.workdir, getwd())) 
[16:03:12.533]             setwd(...future.workdir)
[16:03:12.533]         {
[16:03:12.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.533]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.533]             }
[16:03:12.533]             base::options(...future.oldOptions)
[16:03:12.533]             if (.Platform$OS.type == "windows") {
[16:03:12.533]                 old_names <- names(...future.oldEnvVars)
[16:03:12.533]                 envs <- base::Sys.getenv()
[16:03:12.533]                 names <- names(envs)
[16:03:12.533]                 common <- intersect(names, old_names)
[16:03:12.533]                 added <- setdiff(names, old_names)
[16:03:12.533]                 removed <- setdiff(old_names, names)
[16:03:12.533]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.533]                   envs[common]]
[16:03:12.533]                 NAMES <- toupper(changed)
[16:03:12.533]                 args <- list()
[16:03:12.533]                 for (kk in seq_along(NAMES)) {
[16:03:12.533]                   name <- changed[[kk]]
[16:03:12.533]                   NAME <- NAMES[[kk]]
[16:03:12.533]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.533]                     next
[16:03:12.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.533]                 }
[16:03:12.533]                 NAMES <- toupper(added)
[16:03:12.533]                 for (kk in seq_along(NAMES)) {
[16:03:12.533]                   name <- added[[kk]]
[16:03:12.533]                   NAME <- NAMES[[kk]]
[16:03:12.533]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.533]                     next
[16:03:12.533]                   args[[name]] <- ""
[16:03:12.533]                 }
[16:03:12.533]                 NAMES <- toupper(removed)
[16:03:12.533]                 for (kk in seq_along(NAMES)) {
[16:03:12.533]                   name <- removed[[kk]]
[16:03:12.533]                   NAME <- NAMES[[kk]]
[16:03:12.533]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.533]                     next
[16:03:12.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.533]                 }
[16:03:12.533]                 if (length(args) > 0) 
[16:03:12.533]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.533]             }
[16:03:12.533]             else {
[16:03:12.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.533]             }
[16:03:12.533]             {
[16:03:12.533]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.533]                   0L) {
[16:03:12.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.533]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.533]                   base::options(opts)
[16:03:12.533]                 }
[16:03:12.533]                 {
[16:03:12.533]                   {
[16:03:12.533]                     NULL
[16:03:12.533]                     RNGkind("Mersenne-Twister")
[16:03:12.533]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.533]                       inherits = FALSE)
[16:03:12.533]                   }
[16:03:12.533]                   options(future.plan = NULL)
[16:03:12.533]                   if (is.na(NA_character_)) 
[16:03:12.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.533]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.533]                   {
[16:03:12.533]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.533]                     if (!future$lazy) 
[16:03:12.533]                       future <- run(future)
[16:03:12.533]                     invisible(future)
[16:03:12.533]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.533]                 }
[16:03:12.533]             }
[16:03:12.533]         }
[16:03:12.533]     })
[16:03:12.533]     if (TRUE) {
[16:03:12.533]         base::sink(type = "output", split = FALSE)
[16:03:12.533]         if (TRUE) {
[16:03:12.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.533]         }
[16:03:12.533]         else {
[16:03:12.533]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.533]         }
[16:03:12.533]         base::close(...future.stdout)
[16:03:12.533]         ...future.stdout <- NULL
[16:03:12.533]     }
[16:03:12.533]     ...future.result$conditions <- ...future.conditions
[16:03:12.533]     ...future.result$finished <- base::Sys.time()
[16:03:12.533]     ...future.result
[16:03:12.533] }
[16:03:12.534] assign_globals() ...
[16:03:12.534] List of 11
[16:03:12.534]  $ ...future.FUN            :function (x, ...)  
[16:03:12.534]  $ x_FUN                    :function (x)  
[16:03:12.534]  $ times                    : int 0
[16:03:12.534]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.534]  $ stop_if_not              :function (...)  
[16:03:12.534]  $ dim                      : NULL
[16:03:12.534]  $ valid_types              : chr [1:2] "logical" "integer"
[16:03:12.534]  $ future.call.arguments    : list()
[16:03:12.534]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.534]  $ ...future.elements_ii    :List of 10
[16:03:12.534]   ..$ : int 1
[16:03:12.534]   ..$ : int 2
[16:03:12.534]   ..$ : int 3
[16:03:12.534]   ..$ : int 4
[16:03:12.534]   ..$ : int 5
[16:03:12.534]   ..$ : int 6
[16:03:12.534]   ..$ : int 7
[16:03:12.534]   ..$ : int 8
[16:03:12.534]   ..$ : int 9
[16:03:12.534]   ..$ : int 10
[16:03:12.534]  $ ...future.seeds_ii       : NULL
[16:03:12.534]  $ ...future.globals.maxSize: NULL
[16:03:12.534]  - attr(*, "where")=List of 11
[16:03:12.534]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.534]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:12.534]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:12.534]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:12.534]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:12.534]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:12.534]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:12.534]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.534]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.534]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.534]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.534]  - attr(*, "resolved")= logi FALSE
[16:03:12.534]  - attr(*, "total_size")= num 95400
[16:03:12.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.534]  - attr(*, "already-done")= logi TRUE
[16:03:12.545] - copied ‘...future.FUN’ to environment
[16:03:12.545] - reassign environment for ‘x_FUN’
[16:03:12.545] - copied ‘x_FUN’ to environment
[16:03:12.545] - copied ‘times’ to environment
[16:03:12.545] - copied ‘stopf’ to environment
[16:03:12.545] - copied ‘stop_if_not’ to environment
[16:03:12.546] - copied ‘dim’ to environment
[16:03:12.546] - copied ‘valid_types’ to environment
[16:03:12.546] - copied ‘future.call.arguments’ to environment
[16:03:12.546] - copied ‘...future.elements_ii’ to environment
[16:03:12.546] - copied ‘...future.seeds_ii’ to environment
[16:03:12.546] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.546] assign_globals() ... done
[16:03:12.546] plan(): Setting new future strategy stack:
[16:03:12.547] List of future strategies:
[16:03:12.547] 1. sequential:
[16:03:12.547]    - args: function (..., envir = parent.frame())
[16:03:12.547]    - tweaked: FALSE
[16:03:12.547]    - call: NULL
[16:03:12.547] plan(): nbrOfWorkers() = 1
[16:03:12.548] plan(): Setting new future strategy stack:
[16:03:12.548] List of future strategies:
[16:03:12.548] 1. sequential:
[16:03:12.548]    - args: function (..., envir = parent.frame())
[16:03:12.548]    - tweaked: FALSE
[16:03:12.548]    - call: plan(strategy)
[16:03:12.548] plan(): nbrOfWorkers() = 1
[16:03:12.548] SequentialFuture started (and completed)
[16:03:12.548] - Launch lazy future ... done
[16:03:12.549] run() for ‘SequentialFuture’ ... done
[16:03:12.549] Created future:
[16:03:12.549] SequentialFuture:
[16:03:12.549] Label: ‘future_vapply-1’
[16:03:12.549] Expression:
[16:03:12.549] {
[16:03:12.549]     do.call(function(...) {
[16:03:12.549]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.549]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.549]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.549]             on.exit(options(oopts), add = TRUE)
[16:03:12.549]         }
[16:03:12.549]         {
[16:03:12.549]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.549]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.549]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.549]             })
[16:03:12.549]         }
[16:03:12.549]     }, args = future.call.arguments)
[16:03:12.549] }
[16:03:12.549] Lazy evaluation: FALSE
[16:03:12.549] Asynchronous evaluation: FALSE
[16:03:12.549] Local evaluation: TRUE
[16:03:12.549] Environment: R_GlobalEnv
[16:03:12.549] Capture standard output: TRUE
[16:03:12.549] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.549] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:12.549] Packages: 1 packages (‘future.apply’)
[16:03:12.549] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.549] Resolved: TRUE
[16:03:12.549] Value: 480 bytes of class ‘list’
[16:03:12.549] Early signaling: FALSE
[16:03:12.549] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.549] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.550] Chunk #1 of 1 ... DONE
[16:03:12.550] Launching 1 futures (chunks) ... DONE
[16:03:12.550] Resolving 1 futures (chunks) ...
[16:03:12.550] resolve() on list ...
[16:03:12.550]  recursive: 0
[16:03:12.550]  length: 1
[16:03:12.550] 
[16:03:12.550] resolved() for ‘SequentialFuture’ ...
[16:03:12.551] - state: ‘finished’
[16:03:12.551] - run: TRUE
[16:03:12.551] - result: ‘FutureResult’
[16:03:12.551] resolved() for ‘SequentialFuture’ ... done
[16:03:12.551] Future #1
[16:03:12.551] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.551] - nx: 1
[16:03:12.551] - relay: TRUE
[16:03:12.551] - stdout: TRUE
[16:03:12.551] - signal: TRUE
[16:03:12.552] - resignal: FALSE
[16:03:12.552] - force: TRUE
[16:03:12.552] - relayed: [n=1] FALSE
[16:03:12.552] - queued futures: [n=1] FALSE
[16:03:12.552]  - until=1
[16:03:12.552]  - relaying element #1
[16:03:12.552] - relayed: [n=1] TRUE
[16:03:12.552] - queued futures: [n=1] TRUE
[16:03:12.552] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.552]  length: 0 (resolved future 1)
[16:03:12.552] Relaying remaining futures
[16:03:12.553] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.553] - nx: 1
[16:03:12.553] - relay: TRUE
[16:03:12.553] - stdout: TRUE
[16:03:12.553] - signal: TRUE
[16:03:12.553] - resignal: FALSE
[16:03:12.553] - force: TRUE
[16:03:12.553] - relayed: [n=1] TRUE
[16:03:12.553] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.553] - relayed: [n=1] TRUE
[16:03:12.553] - queued futures: [n=1] TRUE
[16:03:12.554] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.554] resolve() on list ... DONE
[16:03:12.554]  - Number of value chunks collected: 1
[16:03:12.554] Resolving 1 futures (chunks) ... DONE
[16:03:12.554] Reducing values from 1 chunks ...
[16:03:12.554]  - Number of values collected after concatenation: 10
[16:03:12.554]  - Number of values expected: 10
[16:03:12.554] Reducing values from 1 chunks ... DONE
[16:03:12.554] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[16:03:12.555] future_lapply() ...
[16:03:12.557] Number of chunks: 1
[16:03:12.557] getGlobalsAndPackagesXApply() ...
[16:03:12.557]  - future.globals: TRUE
[16:03:12.557] getGlobalsAndPackages() ...
[16:03:12.557] Searching for globals...
[16:03:12.560] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:12.560] Searching for globals ... DONE
[16:03:12.560] Resolving globals: FALSE
[16:03:12.561] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[16:03:12.561] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:12.561] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.561] - packages: [1] ‘future.apply’
[16:03:12.562] getGlobalsAndPackages() ... DONE
[16:03:12.562]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.562]  - needed namespaces: [n=1] ‘future.apply’
[16:03:12.562] Finding globals ... DONE
[16:03:12.562]  - use_args: TRUE
[16:03:12.562]  - Getting '...' globals ...
[16:03:12.562] resolve() on list ...
[16:03:12.562]  recursive: 0
[16:03:12.562]  length: 1
[16:03:12.563]  elements: ‘...’
[16:03:12.563]  length: 0 (resolved future 1)
[16:03:12.563] resolve() on list ... DONE
[16:03:12.563]    - '...' content: [n=0] 
[16:03:12.563] List of 1
[16:03:12.563]  $ ...: list()
[16:03:12.563]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.563]  - attr(*, "where")=List of 1
[16:03:12.563]   ..$ ...:<environment: 0x564e429b5cc0> 
[16:03:12.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.563]  - attr(*, "resolved")= logi TRUE
[16:03:12.563]  - attr(*, "total_size")= num NA
[16:03:12.567]  - Getting '...' globals ... DONE
[16:03:12.567] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:12.567] List of 8
[16:03:12.567]  $ ...future.FUN:function (x, ...)  
[16:03:12.567]  $ x_FUN        :function (x)  
[16:03:12.567]  $ times        : int 1
[16:03:12.567]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.567]  $ stop_if_not  :function (...)  
[16:03:12.567]  $ dim          : NULL
[16:03:12.567]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:12.567]  $ ...          : list()
[16:03:12.567]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.567]  - attr(*, "where")=List of 8
[16:03:12.567]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.567]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:12.567]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:12.567]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:12.567]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:12.567]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:12.567]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:12.567]   ..$ ...          :<environment: 0x564e429b5cc0> 
[16:03:12.567]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.567]  - attr(*, "resolved")= logi FALSE
[16:03:12.567]  - attr(*, "total_size")= num 94336
[16:03:12.572] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:12.572] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.572] Number of futures (= number of chunks): 1
[16:03:12.573] Launching 1 futures (chunks) ...
[16:03:12.573] Chunk #1 of 1 ...
[16:03:12.573]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.573] getGlobalsAndPackages() ...
[16:03:12.573] Searching for globals...
[16:03:12.573] 
[16:03:12.573] Searching for globals ... DONE
[16:03:12.573] - globals: [0] <none>
[16:03:12.573] getGlobalsAndPackages() ... DONE
[16:03:12.574]    + additional globals found: [n=0] 
[16:03:12.574]    + additional namespaces needed: [n=0] 
[16:03:12.574]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.574]  - seeds: <none>
[16:03:12.574]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.574] getGlobalsAndPackages() ...
[16:03:12.574] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.574] Resolving globals: FALSE
[16:03:12.574] Tweak future expression to call with '...' arguments ...
[16:03:12.574] {
[16:03:12.574]     do.call(function(...) {
[16:03:12.574]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.574]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.574]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.574]             on.exit(options(oopts), add = TRUE)
[16:03:12.574]         }
[16:03:12.574]         {
[16:03:12.574]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.574]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.574]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.574]             })
[16:03:12.574]         }
[16:03:12.574]     }, args = future.call.arguments)
[16:03:12.574] }
[16:03:12.575] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.575] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.575] - packages: [1] ‘future.apply’
[16:03:12.575] getGlobalsAndPackages() ... DONE
[16:03:12.576] run() for ‘Future’ ...
[16:03:12.576] - state: ‘created’
[16:03:12.576] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.576] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.576] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.576]   - Field: ‘label’
[16:03:12.576]   - Field: ‘local’
[16:03:12.577]   - Field: ‘owner’
[16:03:12.577]   - Field: ‘envir’
[16:03:12.577]   - Field: ‘packages’
[16:03:12.577]   - Field: ‘gc’
[16:03:12.577]   - Field: ‘conditions’
[16:03:12.577]   - Field: ‘expr’
[16:03:12.577]   - Field: ‘uuid’
[16:03:12.577]   - Field: ‘seed’
[16:03:12.577]   - Field: ‘version’
[16:03:12.577]   - Field: ‘result’
[16:03:12.577]   - Field: ‘asynchronous’
[16:03:12.578]   - Field: ‘calls’
[16:03:12.578]   - Field: ‘globals’
[16:03:12.578]   - Field: ‘stdout’
[16:03:12.578]   - Field: ‘earlySignal’
[16:03:12.578]   - Field: ‘lazy’
[16:03:12.578]   - Field: ‘state’
[16:03:12.578] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.578] - Launch lazy future ...
[16:03:12.578] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:12.578] Packages needed by future strategies (n = 0): <none>
[16:03:12.579] {
[16:03:12.579]     {
[16:03:12.579]         {
[16:03:12.579]             ...future.startTime <- base::Sys.time()
[16:03:12.579]             {
[16:03:12.579]                 {
[16:03:12.579]                   {
[16:03:12.579]                     {
[16:03:12.579]                       base::local({
[16:03:12.579]                         has_future <- base::requireNamespace("future", 
[16:03:12.579]                           quietly = TRUE)
[16:03:12.579]                         if (has_future) {
[16:03:12.579]                           ns <- base::getNamespace("future")
[16:03:12.579]                           version <- ns[[".package"]][["version"]]
[16:03:12.579]                           if (is.null(version)) 
[16:03:12.579]                             version <- utils::packageVersion("future")
[16:03:12.579]                         }
[16:03:12.579]                         else {
[16:03:12.579]                           version <- NULL
[16:03:12.579]                         }
[16:03:12.579]                         if (!has_future || version < "1.8.0") {
[16:03:12.579]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.579]                             "", base::R.version$version.string), 
[16:03:12.579]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:12.579]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.579]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.579]                               "release", "version")], collapse = " "), 
[16:03:12.579]                             hostname = base::Sys.info()[["nodename"]])
[16:03:12.579]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.579]                             info)
[16:03:12.579]                           info <- base::paste(info, collapse = "; ")
[16:03:12.579]                           if (!has_future) {
[16:03:12.579]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.579]                               info)
[16:03:12.579]                           }
[16:03:12.579]                           else {
[16:03:12.579]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.579]                               info, version)
[16:03:12.579]                           }
[16:03:12.579]                           base::stop(msg)
[16:03:12.579]                         }
[16:03:12.579]                       })
[16:03:12.579]                     }
[16:03:12.579]                     base::local({
[16:03:12.579]                       for (pkg in "future.apply") {
[16:03:12.579]                         base::loadNamespace(pkg)
[16:03:12.579]                         base::library(pkg, character.only = TRUE)
[16:03:12.579]                       }
[16:03:12.579]                     })
[16:03:12.579]                   }
[16:03:12.579]                   options(future.plan = NULL)
[16:03:12.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.579]                 }
[16:03:12.579]                 ...future.workdir <- getwd()
[16:03:12.579]             }
[16:03:12.579]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.579]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.579]         }
[16:03:12.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.579]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.579]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.579]             base::names(...future.oldOptions))
[16:03:12.579]     }
[16:03:12.579]     if (FALSE) {
[16:03:12.579]     }
[16:03:12.579]     else {
[16:03:12.579]         if (TRUE) {
[16:03:12.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.579]                 open = "w")
[16:03:12.579]         }
[16:03:12.579]         else {
[16:03:12.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.579]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.579]         }
[16:03:12.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.579]             base::sink(type = "output", split = FALSE)
[16:03:12.579]             base::close(...future.stdout)
[16:03:12.579]         }, add = TRUE)
[16:03:12.579]     }
[16:03:12.579]     ...future.frame <- base::sys.nframe()
[16:03:12.579]     ...future.conditions <- base::list()
[16:03:12.579]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.579]     if (FALSE) {
[16:03:12.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.579]     }
[16:03:12.579]     ...future.result <- base::tryCatch({
[16:03:12.579]         base::withCallingHandlers({
[16:03:12.579]             ...future.value <- base::withVisible(base::local({
[16:03:12.579]                 do.call(function(...) {
[16:03:12.579]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.579]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.579]                     ...future.globals.maxSize)) {
[16:03:12.579]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.579]                     on.exit(options(oopts), add = TRUE)
[16:03:12.579]                   }
[16:03:12.579]                   {
[16:03:12.579]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.579]                       FUN = function(jj) {
[16:03:12.579]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.579]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.579]                       })
[16:03:12.579]                   }
[16:03:12.579]                 }, args = future.call.arguments)
[16:03:12.579]             }))
[16:03:12.579]             future::FutureResult(value = ...future.value$value, 
[16:03:12.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.579]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.579]                     ...future.globalenv.names))
[16:03:12.579]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.579]         }, condition = base::local({
[16:03:12.579]             c <- base::c
[16:03:12.579]             inherits <- base::inherits
[16:03:12.579]             invokeRestart <- base::invokeRestart
[16:03:12.579]             length <- base::length
[16:03:12.579]             list <- base::list
[16:03:12.579]             seq.int <- base::seq.int
[16:03:12.579]             signalCondition <- base::signalCondition
[16:03:12.579]             sys.calls <- base::sys.calls
[16:03:12.579]             `[[` <- base::`[[`
[16:03:12.579]             `+` <- base::`+`
[16:03:12.579]             `<<-` <- base::`<<-`
[16:03:12.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.579]                   3L)]
[16:03:12.579]             }
[16:03:12.579]             function(cond) {
[16:03:12.579]                 is_error <- inherits(cond, "error")
[16:03:12.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.579]                   NULL)
[16:03:12.579]                 if (is_error) {
[16:03:12.579]                   sessionInformation <- function() {
[16:03:12.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.579]                       search = base::search(), system = base::Sys.info())
[16:03:12.579]                   }
[16:03:12.579]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.579]                     cond$call), session = sessionInformation(), 
[16:03:12.579]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.579]                   signalCondition(cond)
[16:03:12.579]                 }
[16:03:12.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.579]                 "immediateCondition"))) {
[16:03:12.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.579]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.579]                   if (TRUE && !signal) {
[16:03:12.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.579]                     {
[16:03:12.579]                       inherits <- base::inherits
[16:03:12.579]                       invokeRestart <- base::invokeRestart
[16:03:12.579]                       is.null <- base::is.null
[16:03:12.579]                       muffled <- FALSE
[16:03:12.579]                       if (inherits(cond, "message")) {
[16:03:12.579]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.579]                         if (muffled) 
[16:03:12.579]                           invokeRestart("muffleMessage")
[16:03:12.579]                       }
[16:03:12.579]                       else if (inherits(cond, "warning")) {
[16:03:12.579]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.579]                         if (muffled) 
[16:03:12.579]                           invokeRestart("muffleWarning")
[16:03:12.579]                       }
[16:03:12.579]                       else if (inherits(cond, "condition")) {
[16:03:12.579]                         if (!is.null(pattern)) {
[16:03:12.579]                           computeRestarts <- base::computeRestarts
[16:03:12.579]                           grepl <- base::grepl
[16:03:12.579]                           restarts <- computeRestarts(cond)
[16:03:12.579]                           for (restart in restarts) {
[16:03:12.579]                             name <- restart$name
[16:03:12.579]                             if (is.null(name)) 
[16:03:12.579]                               next
[16:03:12.579]                             if (!grepl(pattern, name)) 
[16:03:12.579]                               next
[16:03:12.579]                             invokeRestart(restart)
[16:03:12.579]                             muffled <- TRUE
[16:03:12.579]                             break
[16:03:12.579]                           }
[16:03:12.579]                         }
[16:03:12.579]                       }
[16:03:12.579]                       invisible(muffled)
[16:03:12.579]                     }
[16:03:12.579]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.579]                   }
[16:03:12.579]                 }
[16:03:12.579]                 else {
[16:03:12.579]                   if (TRUE) {
[16:03:12.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.579]                     {
[16:03:12.579]                       inherits <- base::inherits
[16:03:12.579]                       invokeRestart <- base::invokeRestart
[16:03:12.579]                       is.null <- base::is.null
[16:03:12.579]                       muffled <- FALSE
[16:03:12.579]                       if (inherits(cond, "message")) {
[16:03:12.579]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.579]                         if (muffled) 
[16:03:12.579]                           invokeRestart("muffleMessage")
[16:03:12.579]                       }
[16:03:12.579]                       else if (inherits(cond, "warning")) {
[16:03:12.579]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.579]                         if (muffled) 
[16:03:12.579]                           invokeRestart("muffleWarning")
[16:03:12.579]                       }
[16:03:12.579]                       else if (inherits(cond, "condition")) {
[16:03:12.579]                         if (!is.null(pattern)) {
[16:03:12.579]                           computeRestarts <- base::computeRestarts
[16:03:12.579]                           grepl <- base::grepl
[16:03:12.579]                           restarts <- computeRestarts(cond)
[16:03:12.579]                           for (restart in restarts) {
[16:03:12.579]                             name <- restart$name
[16:03:12.579]                             if (is.null(name)) 
[16:03:12.579]                               next
[16:03:12.579]                             if (!grepl(pattern, name)) 
[16:03:12.579]                               next
[16:03:12.579]                             invokeRestart(restart)
[16:03:12.579]                             muffled <- TRUE
[16:03:12.579]                             break
[16:03:12.579]                           }
[16:03:12.579]                         }
[16:03:12.579]                       }
[16:03:12.579]                       invisible(muffled)
[16:03:12.579]                     }
[16:03:12.579]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.579]                   }
[16:03:12.579]                 }
[16:03:12.579]             }
[16:03:12.579]         }))
[16:03:12.579]     }, error = function(ex) {
[16:03:12.579]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.579]                 ...future.rng), started = ...future.startTime, 
[16:03:12.579]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.579]             version = "1.8"), class = "FutureResult")
[16:03:12.579]     }, finally = {
[16:03:12.579]         if (!identical(...future.workdir, getwd())) 
[16:03:12.579]             setwd(...future.workdir)
[16:03:12.579]         {
[16:03:12.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.579]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.579]             }
[16:03:12.579]             base::options(...future.oldOptions)
[16:03:12.579]             if (.Platform$OS.type == "windows") {
[16:03:12.579]                 old_names <- names(...future.oldEnvVars)
[16:03:12.579]                 envs <- base::Sys.getenv()
[16:03:12.579]                 names <- names(envs)
[16:03:12.579]                 common <- intersect(names, old_names)
[16:03:12.579]                 added <- setdiff(names, old_names)
[16:03:12.579]                 removed <- setdiff(old_names, names)
[16:03:12.579]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.579]                   envs[common]]
[16:03:12.579]                 NAMES <- toupper(changed)
[16:03:12.579]                 args <- list()
[16:03:12.579]                 for (kk in seq_along(NAMES)) {
[16:03:12.579]                   name <- changed[[kk]]
[16:03:12.579]                   NAME <- NAMES[[kk]]
[16:03:12.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.579]                     next
[16:03:12.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.579]                 }
[16:03:12.579]                 NAMES <- toupper(added)
[16:03:12.579]                 for (kk in seq_along(NAMES)) {
[16:03:12.579]                   name <- added[[kk]]
[16:03:12.579]                   NAME <- NAMES[[kk]]
[16:03:12.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.579]                     next
[16:03:12.579]                   args[[name]] <- ""
[16:03:12.579]                 }
[16:03:12.579]                 NAMES <- toupper(removed)
[16:03:12.579]                 for (kk in seq_along(NAMES)) {
[16:03:12.579]                   name <- removed[[kk]]
[16:03:12.579]                   NAME <- NAMES[[kk]]
[16:03:12.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.579]                     next
[16:03:12.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.579]                 }
[16:03:12.579]                 if (length(args) > 0) 
[16:03:12.579]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.579]             }
[16:03:12.579]             else {
[16:03:12.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.579]             }
[16:03:12.579]             {
[16:03:12.579]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.579]                   0L) {
[16:03:12.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.579]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.579]                   base::options(opts)
[16:03:12.579]                 }
[16:03:12.579]                 {
[16:03:12.579]                   {
[16:03:12.579]                     NULL
[16:03:12.579]                     RNGkind("Mersenne-Twister")
[16:03:12.579]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.579]                       inherits = FALSE)
[16:03:12.579]                   }
[16:03:12.579]                   options(future.plan = NULL)
[16:03:12.579]                   if (is.na(NA_character_)) 
[16:03:12.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.579]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.579]                   {
[16:03:12.579]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.579]                     if (!future$lazy) 
[16:03:12.579]                       future <- run(future)
[16:03:12.579]                     invisible(future)
[16:03:12.579]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.579]                 }
[16:03:12.579]             }
[16:03:12.579]         }
[16:03:12.579]     })
[16:03:12.579]     if (TRUE) {
[16:03:12.579]         base::sink(type = "output", split = FALSE)
[16:03:12.579]         if (TRUE) {
[16:03:12.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.579]         }
[16:03:12.579]         else {
[16:03:12.579]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.579]         }
[16:03:12.579]         base::close(...future.stdout)
[16:03:12.579]         ...future.stdout <- NULL
[16:03:12.579]     }
[16:03:12.579]     ...future.result$conditions <- ...future.conditions
[16:03:12.579]     ...future.result$finished <- base::Sys.time()
[16:03:12.579]     ...future.result
[16:03:12.579] }
[16:03:12.581] assign_globals() ...
[16:03:12.581] List of 11
[16:03:12.581]  $ ...future.FUN            :function (x, ...)  
[16:03:12.581]  $ x_FUN                    :function (x)  
[16:03:12.581]  $ times                    : int 1
[16:03:12.581]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.581]  $ stop_if_not              :function (...)  
[16:03:12.581]  $ dim                      : NULL
[16:03:12.581]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:12.581]  $ future.call.arguments    : list()
[16:03:12.581]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.581]  $ ...future.elements_ii    :List of 10
[16:03:12.581]   ..$ : int 1
[16:03:12.581]   ..$ : int 2
[16:03:12.581]   ..$ : int 3
[16:03:12.581]   ..$ : int 4
[16:03:12.581]   ..$ : int 5
[16:03:12.581]   ..$ : int 6
[16:03:12.581]   ..$ : int 7
[16:03:12.581]   ..$ : int 8
[16:03:12.581]   ..$ : int 9
[16:03:12.581]   ..$ : int 10
[16:03:12.581]  $ ...future.seeds_ii       : NULL
[16:03:12.581]  $ ...future.globals.maxSize: NULL
[16:03:12.581]  - attr(*, "where")=List of 11
[16:03:12.581]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.581]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:12.581]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:12.581]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:12.581]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:12.581]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:12.581]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:12.581]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.581]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.581]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.581]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.581]  - attr(*, "resolved")= logi FALSE
[16:03:12.581]  - attr(*, "total_size")= num 94336
[16:03:12.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.581]  - attr(*, "already-done")= logi TRUE
[16:03:12.591] - copied ‘...future.FUN’ to environment
[16:03:12.592] - copied ‘x_FUN’ to environment
[16:03:12.592] - copied ‘times’ to environment
[16:03:12.592] - copied ‘stopf’ to environment
[16:03:12.592] - copied ‘stop_if_not’ to environment
[16:03:12.592] - copied ‘dim’ to environment
[16:03:12.592] - copied ‘valid_types’ to environment
[16:03:12.592] - copied ‘future.call.arguments’ to environment
[16:03:12.592] - copied ‘...future.elements_ii’ to environment
[16:03:12.592] - copied ‘...future.seeds_ii’ to environment
[16:03:12.592] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.593] assign_globals() ... done
[16:03:12.593] plan(): Setting new future strategy stack:
[16:03:12.593] List of future strategies:
[16:03:12.593] 1. sequential:
[16:03:12.593]    - args: function (..., envir = parent.frame())
[16:03:12.593]    - tweaked: FALSE
[16:03:12.593]    - call: NULL
[16:03:12.593] plan(): nbrOfWorkers() = 1
[16:03:12.594] plan(): Setting new future strategy stack:
[16:03:12.594] List of future strategies:
[16:03:12.594] 1. sequential:
[16:03:12.594]    - args: function (..., envir = parent.frame())
[16:03:12.594]    - tweaked: FALSE
[16:03:12.594]    - call: plan(strategy)
[16:03:12.594] plan(): nbrOfWorkers() = 1
[16:03:12.595] SequentialFuture started (and completed)
[16:03:12.595] - Launch lazy future ... done
[16:03:12.595] run() for ‘SequentialFuture’ ... done
[16:03:12.595] Created future:
[16:03:12.595] SequentialFuture:
[16:03:12.595] Label: ‘future_vapply-1’
[16:03:12.595] Expression:
[16:03:12.595] {
[16:03:12.595]     do.call(function(...) {
[16:03:12.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.595]             on.exit(options(oopts), add = TRUE)
[16:03:12.595]         }
[16:03:12.595]         {
[16:03:12.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.595]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.595]             })
[16:03:12.595]         }
[16:03:12.595]     }, args = future.call.arguments)
[16:03:12.595] }
[16:03:12.595] Lazy evaluation: FALSE
[16:03:12.595] Asynchronous evaluation: FALSE
[16:03:12.595] Local evaluation: TRUE
[16:03:12.595] Environment: R_GlobalEnv
[16:03:12.595] Capture standard output: TRUE
[16:03:12.595] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.595] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:12.595] Packages: 1 packages (‘future.apply’)
[16:03:12.595] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.595] Resolved: TRUE
[16:03:12.595] Value: 560 bytes of class ‘list’
[16:03:12.595] Early signaling: FALSE
[16:03:12.595] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.595] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.596] Chunk #1 of 1 ... DONE
[16:03:12.596] Launching 1 futures (chunks) ... DONE
[16:03:12.596] Resolving 1 futures (chunks) ...
[16:03:12.596] resolve() on list ...
[16:03:12.596]  recursive: 0
[16:03:12.597]  length: 1
[16:03:12.597] 
[16:03:12.597] resolved() for ‘SequentialFuture’ ...
[16:03:12.597] - state: ‘finished’
[16:03:12.597] - run: TRUE
[16:03:12.597] - result: ‘FutureResult’
[16:03:12.597] resolved() for ‘SequentialFuture’ ... done
[16:03:12.597] Future #1
[16:03:12.597] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.597] - nx: 1
[16:03:12.598] - relay: TRUE
[16:03:12.598] - stdout: TRUE
[16:03:12.598] - signal: TRUE
[16:03:12.598] - resignal: FALSE
[16:03:12.598] - force: TRUE
[16:03:12.598] - relayed: [n=1] FALSE
[16:03:12.598] - queued futures: [n=1] FALSE
[16:03:12.598]  - until=1
[16:03:12.598]  - relaying element #1
[16:03:12.598] - relayed: [n=1] TRUE
[16:03:12.598] - queued futures: [n=1] TRUE
[16:03:12.599] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.599]  length: 0 (resolved future 1)
[16:03:12.599] Relaying remaining futures
[16:03:12.599] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.599] - nx: 1
[16:03:12.599] - relay: TRUE
[16:03:12.599] - stdout: TRUE
[16:03:12.599] - signal: TRUE
[16:03:12.599] - resignal: FALSE
[16:03:12.599] - force: TRUE
[16:03:12.599] - relayed: [n=1] TRUE
[16:03:12.599] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.600] - relayed: [n=1] TRUE
[16:03:12.600] - queued futures: [n=1] TRUE
[16:03:12.600] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.600] resolve() on list ... DONE
[16:03:12.600]  - Number of value chunks collected: 1
[16:03:12.600] Resolving 1 futures (chunks) ... DONE
[16:03:12.600] Reducing values from 1 chunks ...
[16:03:12.600]  - Number of values collected after concatenation: 10
[16:03:12.600]  - Number of values expected: 10
[16:03:12.600] Reducing values from 1 chunks ... DONE
[16:03:12.601] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[16:03:12.601] future_lapply() ...
[16:03:12.603] Number of chunks: 1
[16:03:12.603] getGlobalsAndPackagesXApply() ...
[16:03:12.603]  - future.globals: TRUE
[16:03:12.603] getGlobalsAndPackages() ...
[16:03:12.603] Searching for globals...
[16:03:12.608] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[16:03:12.608] Searching for globals ... DONE
[16:03:12.608] Resolving globals: FALSE
[16:03:12.609] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[16:03:12.609] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:12.610] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.610] - packages: [1] ‘future.apply’
[16:03:12.610] getGlobalsAndPackages() ... DONE
[16:03:12.610]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.610]  - needed namespaces: [n=1] ‘future.apply’
[16:03:12.610] Finding globals ... DONE
[16:03:12.610]  - use_args: TRUE
[16:03:12.610]  - Getting '...' globals ...
[16:03:12.611] resolve() on list ...
[16:03:12.611]  recursive: 0
[16:03:12.611]  length: 1
[16:03:12.611]  elements: ‘...’
[16:03:12.611]  length: 0 (resolved future 1)
[16:03:12.611] resolve() on list ... DONE
[16:03:12.611]    - '...' content: [n=0] 
[16:03:12.611] List of 1
[16:03:12.611]  $ ...: list()
[16:03:12.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.611]  - attr(*, "where")=List of 1
[16:03:12.611]   ..$ ...:<environment: 0x564e42c1e680> 
[16:03:12.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.611]  - attr(*, "resolved")= logi TRUE
[16:03:12.611]  - attr(*, "total_size")= num NA
[16:03:12.614]  - Getting '...' globals ... DONE
[16:03:12.614] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:12.614] List of 8
[16:03:12.614]  $ ...future.FUN:function (x, ...)  
[16:03:12.614]  $ x_FUN        :function (x)  
[16:03:12.614]  $ times        : int 2
[16:03:12.614]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.614]  $ stop_if_not  :function (...)  
[16:03:12.614]  $ dim          : NULL
[16:03:12.614]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:12.614]  $ ...          : list()
[16:03:12.614]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.614]  - attr(*, "where")=List of 8
[16:03:12.614]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.614]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:12.614]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:12.614]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:12.614]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:12.614]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:12.614]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:12.614]   ..$ ...          :<environment: 0x564e42c1e680> 
[16:03:12.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.614]  - attr(*, "resolved")= logi FALSE
[16:03:12.614]  - attr(*, "total_size")= num 96456
[16:03:12.619] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:12.619] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.619] Number of futures (= number of chunks): 1
[16:03:12.619] Launching 1 futures (chunks) ...
[16:03:12.620] Chunk #1 of 1 ...
[16:03:12.620]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.620] getGlobalsAndPackages() ...
[16:03:12.620] Searching for globals...
[16:03:12.620] 
[16:03:12.620] Searching for globals ... DONE
[16:03:12.620] - globals: [0] <none>
[16:03:12.620] getGlobalsAndPackages() ... DONE
[16:03:12.620]    + additional globals found: [n=0] 
[16:03:12.621]    + additional namespaces needed: [n=0] 
[16:03:12.621]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.621]  - seeds: <none>
[16:03:12.621]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.621] getGlobalsAndPackages() ...
[16:03:12.621] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.621] Resolving globals: FALSE
[16:03:12.621] Tweak future expression to call with '...' arguments ...
[16:03:12.621] {
[16:03:12.621]     do.call(function(...) {
[16:03:12.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.621]             on.exit(options(oopts), add = TRUE)
[16:03:12.621]         }
[16:03:12.621]         {
[16:03:12.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.621]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.621]             })
[16:03:12.621]         }
[16:03:12.621]     }, args = future.call.arguments)
[16:03:12.621] }
[16:03:12.622] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.622] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.622] - packages: [1] ‘future.apply’
[16:03:12.622] getGlobalsAndPackages() ... DONE
[16:03:12.622] run() for ‘Future’ ...
[16:03:12.623] - state: ‘created’
[16:03:12.623] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.623] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.623] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.623]   - Field: ‘label’
[16:03:12.623]   - Field: ‘local’
[16:03:12.623]   - Field: ‘owner’
[16:03:12.624]   - Field: ‘envir’
[16:03:12.624]   - Field: ‘packages’
[16:03:12.624]   - Field: ‘gc’
[16:03:12.624]   - Field: ‘conditions’
[16:03:12.624]   - Field: ‘expr’
[16:03:12.624]   - Field: ‘uuid’
[16:03:12.624]   - Field: ‘seed’
[16:03:12.624]   - Field: ‘version’
[16:03:12.624]   - Field: ‘result’
[16:03:12.624]   - Field: ‘asynchronous’
[16:03:12.624]   - Field: ‘calls’
[16:03:12.625]   - Field: ‘globals’
[16:03:12.625]   - Field: ‘stdout’
[16:03:12.625]   - Field: ‘earlySignal’
[16:03:12.625]   - Field: ‘lazy’
[16:03:12.625]   - Field: ‘state’
[16:03:12.625] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.625] - Launch lazy future ...
[16:03:12.625] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:12.625] Packages needed by future strategies (n = 0): <none>
[16:03:12.626] {
[16:03:12.626]     {
[16:03:12.626]         {
[16:03:12.626]             ...future.startTime <- base::Sys.time()
[16:03:12.626]             {
[16:03:12.626]                 {
[16:03:12.626]                   {
[16:03:12.626]                     {
[16:03:12.626]                       base::local({
[16:03:12.626]                         has_future <- base::requireNamespace("future", 
[16:03:12.626]                           quietly = TRUE)
[16:03:12.626]                         if (has_future) {
[16:03:12.626]                           ns <- base::getNamespace("future")
[16:03:12.626]                           version <- ns[[".package"]][["version"]]
[16:03:12.626]                           if (is.null(version)) 
[16:03:12.626]                             version <- utils::packageVersion("future")
[16:03:12.626]                         }
[16:03:12.626]                         else {
[16:03:12.626]                           version <- NULL
[16:03:12.626]                         }
[16:03:12.626]                         if (!has_future || version < "1.8.0") {
[16:03:12.626]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.626]                             "", base::R.version$version.string), 
[16:03:12.626]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:12.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.626]                               "release", "version")], collapse = " "), 
[16:03:12.626]                             hostname = base::Sys.info()[["nodename"]])
[16:03:12.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.626]                             info)
[16:03:12.626]                           info <- base::paste(info, collapse = "; ")
[16:03:12.626]                           if (!has_future) {
[16:03:12.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.626]                               info)
[16:03:12.626]                           }
[16:03:12.626]                           else {
[16:03:12.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.626]                               info, version)
[16:03:12.626]                           }
[16:03:12.626]                           base::stop(msg)
[16:03:12.626]                         }
[16:03:12.626]                       })
[16:03:12.626]                     }
[16:03:12.626]                     base::local({
[16:03:12.626]                       for (pkg in "future.apply") {
[16:03:12.626]                         base::loadNamespace(pkg)
[16:03:12.626]                         base::library(pkg, character.only = TRUE)
[16:03:12.626]                       }
[16:03:12.626]                     })
[16:03:12.626]                   }
[16:03:12.626]                   options(future.plan = NULL)
[16:03:12.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.626]                 }
[16:03:12.626]                 ...future.workdir <- getwd()
[16:03:12.626]             }
[16:03:12.626]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.626]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.626]         }
[16:03:12.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.626]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.626]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.626]             base::names(...future.oldOptions))
[16:03:12.626]     }
[16:03:12.626]     if (FALSE) {
[16:03:12.626]     }
[16:03:12.626]     else {
[16:03:12.626]         if (TRUE) {
[16:03:12.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.626]                 open = "w")
[16:03:12.626]         }
[16:03:12.626]         else {
[16:03:12.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.626]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.626]         }
[16:03:12.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.626]             base::sink(type = "output", split = FALSE)
[16:03:12.626]             base::close(...future.stdout)
[16:03:12.626]         }, add = TRUE)
[16:03:12.626]     }
[16:03:12.626]     ...future.frame <- base::sys.nframe()
[16:03:12.626]     ...future.conditions <- base::list()
[16:03:12.626]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.626]     if (FALSE) {
[16:03:12.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.626]     }
[16:03:12.626]     ...future.result <- base::tryCatch({
[16:03:12.626]         base::withCallingHandlers({
[16:03:12.626]             ...future.value <- base::withVisible(base::local({
[16:03:12.626]                 do.call(function(...) {
[16:03:12.626]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.626]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.626]                     ...future.globals.maxSize)) {
[16:03:12.626]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.626]                     on.exit(options(oopts), add = TRUE)
[16:03:12.626]                   }
[16:03:12.626]                   {
[16:03:12.626]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.626]                       FUN = function(jj) {
[16:03:12.626]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.626]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.626]                       })
[16:03:12.626]                   }
[16:03:12.626]                 }, args = future.call.arguments)
[16:03:12.626]             }))
[16:03:12.626]             future::FutureResult(value = ...future.value$value, 
[16:03:12.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.626]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.626]                     ...future.globalenv.names))
[16:03:12.626]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.626]         }, condition = base::local({
[16:03:12.626]             c <- base::c
[16:03:12.626]             inherits <- base::inherits
[16:03:12.626]             invokeRestart <- base::invokeRestart
[16:03:12.626]             length <- base::length
[16:03:12.626]             list <- base::list
[16:03:12.626]             seq.int <- base::seq.int
[16:03:12.626]             signalCondition <- base::signalCondition
[16:03:12.626]             sys.calls <- base::sys.calls
[16:03:12.626]             `[[` <- base::`[[`
[16:03:12.626]             `+` <- base::`+`
[16:03:12.626]             `<<-` <- base::`<<-`
[16:03:12.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.626]                   3L)]
[16:03:12.626]             }
[16:03:12.626]             function(cond) {
[16:03:12.626]                 is_error <- inherits(cond, "error")
[16:03:12.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.626]                   NULL)
[16:03:12.626]                 if (is_error) {
[16:03:12.626]                   sessionInformation <- function() {
[16:03:12.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.626]                       search = base::search(), system = base::Sys.info())
[16:03:12.626]                   }
[16:03:12.626]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.626]                     cond$call), session = sessionInformation(), 
[16:03:12.626]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.626]                   signalCondition(cond)
[16:03:12.626]                 }
[16:03:12.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.626]                 "immediateCondition"))) {
[16:03:12.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.626]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.626]                   if (TRUE && !signal) {
[16:03:12.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.626]                     {
[16:03:12.626]                       inherits <- base::inherits
[16:03:12.626]                       invokeRestart <- base::invokeRestart
[16:03:12.626]                       is.null <- base::is.null
[16:03:12.626]                       muffled <- FALSE
[16:03:12.626]                       if (inherits(cond, "message")) {
[16:03:12.626]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.626]                         if (muffled) 
[16:03:12.626]                           invokeRestart("muffleMessage")
[16:03:12.626]                       }
[16:03:12.626]                       else if (inherits(cond, "warning")) {
[16:03:12.626]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.626]                         if (muffled) 
[16:03:12.626]                           invokeRestart("muffleWarning")
[16:03:12.626]                       }
[16:03:12.626]                       else if (inherits(cond, "condition")) {
[16:03:12.626]                         if (!is.null(pattern)) {
[16:03:12.626]                           computeRestarts <- base::computeRestarts
[16:03:12.626]                           grepl <- base::grepl
[16:03:12.626]                           restarts <- computeRestarts(cond)
[16:03:12.626]                           for (restart in restarts) {
[16:03:12.626]                             name <- restart$name
[16:03:12.626]                             if (is.null(name)) 
[16:03:12.626]                               next
[16:03:12.626]                             if (!grepl(pattern, name)) 
[16:03:12.626]                               next
[16:03:12.626]                             invokeRestart(restart)
[16:03:12.626]                             muffled <- TRUE
[16:03:12.626]                             break
[16:03:12.626]                           }
[16:03:12.626]                         }
[16:03:12.626]                       }
[16:03:12.626]                       invisible(muffled)
[16:03:12.626]                     }
[16:03:12.626]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.626]                   }
[16:03:12.626]                 }
[16:03:12.626]                 else {
[16:03:12.626]                   if (TRUE) {
[16:03:12.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.626]                     {
[16:03:12.626]                       inherits <- base::inherits
[16:03:12.626]                       invokeRestart <- base::invokeRestart
[16:03:12.626]                       is.null <- base::is.null
[16:03:12.626]                       muffled <- FALSE
[16:03:12.626]                       if (inherits(cond, "message")) {
[16:03:12.626]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.626]                         if (muffled) 
[16:03:12.626]                           invokeRestart("muffleMessage")
[16:03:12.626]                       }
[16:03:12.626]                       else if (inherits(cond, "warning")) {
[16:03:12.626]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.626]                         if (muffled) 
[16:03:12.626]                           invokeRestart("muffleWarning")
[16:03:12.626]                       }
[16:03:12.626]                       else if (inherits(cond, "condition")) {
[16:03:12.626]                         if (!is.null(pattern)) {
[16:03:12.626]                           computeRestarts <- base::computeRestarts
[16:03:12.626]                           grepl <- base::grepl
[16:03:12.626]                           restarts <- computeRestarts(cond)
[16:03:12.626]                           for (restart in restarts) {
[16:03:12.626]                             name <- restart$name
[16:03:12.626]                             if (is.null(name)) 
[16:03:12.626]                               next
[16:03:12.626]                             if (!grepl(pattern, name)) 
[16:03:12.626]                               next
[16:03:12.626]                             invokeRestart(restart)
[16:03:12.626]                             muffled <- TRUE
[16:03:12.626]                             break
[16:03:12.626]                           }
[16:03:12.626]                         }
[16:03:12.626]                       }
[16:03:12.626]                       invisible(muffled)
[16:03:12.626]                     }
[16:03:12.626]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.626]                   }
[16:03:12.626]                 }
[16:03:12.626]             }
[16:03:12.626]         }))
[16:03:12.626]     }, error = function(ex) {
[16:03:12.626]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.626]                 ...future.rng), started = ...future.startTime, 
[16:03:12.626]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.626]             version = "1.8"), class = "FutureResult")
[16:03:12.626]     }, finally = {
[16:03:12.626]         if (!identical(...future.workdir, getwd())) 
[16:03:12.626]             setwd(...future.workdir)
[16:03:12.626]         {
[16:03:12.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.626]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.626]             }
[16:03:12.626]             base::options(...future.oldOptions)
[16:03:12.626]             if (.Platform$OS.type == "windows") {
[16:03:12.626]                 old_names <- names(...future.oldEnvVars)
[16:03:12.626]                 envs <- base::Sys.getenv()
[16:03:12.626]                 names <- names(envs)
[16:03:12.626]                 common <- intersect(names, old_names)
[16:03:12.626]                 added <- setdiff(names, old_names)
[16:03:12.626]                 removed <- setdiff(old_names, names)
[16:03:12.626]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.626]                   envs[common]]
[16:03:12.626]                 NAMES <- toupper(changed)
[16:03:12.626]                 args <- list()
[16:03:12.626]                 for (kk in seq_along(NAMES)) {
[16:03:12.626]                   name <- changed[[kk]]
[16:03:12.626]                   NAME <- NAMES[[kk]]
[16:03:12.626]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.626]                     next
[16:03:12.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.626]                 }
[16:03:12.626]                 NAMES <- toupper(added)
[16:03:12.626]                 for (kk in seq_along(NAMES)) {
[16:03:12.626]                   name <- added[[kk]]
[16:03:12.626]                   NAME <- NAMES[[kk]]
[16:03:12.626]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.626]                     next
[16:03:12.626]                   args[[name]] <- ""
[16:03:12.626]                 }
[16:03:12.626]                 NAMES <- toupper(removed)
[16:03:12.626]                 for (kk in seq_along(NAMES)) {
[16:03:12.626]                   name <- removed[[kk]]
[16:03:12.626]                   NAME <- NAMES[[kk]]
[16:03:12.626]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.626]                     next
[16:03:12.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.626]                 }
[16:03:12.626]                 if (length(args) > 0) 
[16:03:12.626]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.626]             }
[16:03:12.626]             else {
[16:03:12.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.626]             }
[16:03:12.626]             {
[16:03:12.626]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.626]                   0L) {
[16:03:12.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.626]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.626]                   base::options(opts)
[16:03:12.626]                 }
[16:03:12.626]                 {
[16:03:12.626]                   {
[16:03:12.626]                     NULL
[16:03:12.626]                     RNGkind("Mersenne-Twister")
[16:03:12.626]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.626]                       inherits = FALSE)
[16:03:12.626]                   }
[16:03:12.626]                   options(future.plan = NULL)
[16:03:12.626]                   if (is.na(NA_character_)) 
[16:03:12.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.626]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.626]                   {
[16:03:12.626]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.626]                     if (!future$lazy) 
[16:03:12.626]                       future <- run(future)
[16:03:12.626]                     invisible(future)
[16:03:12.626]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.626]                 }
[16:03:12.626]             }
[16:03:12.626]         }
[16:03:12.626]     })
[16:03:12.626]     if (TRUE) {
[16:03:12.626]         base::sink(type = "output", split = FALSE)
[16:03:12.626]         if (TRUE) {
[16:03:12.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.626]         }
[16:03:12.626]         else {
[16:03:12.626]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.626]         }
[16:03:12.626]         base::close(...future.stdout)
[16:03:12.626]         ...future.stdout <- NULL
[16:03:12.626]     }
[16:03:12.626]     ...future.result$conditions <- ...future.conditions
[16:03:12.626]     ...future.result$finished <- base::Sys.time()
[16:03:12.626]     ...future.result
[16:03:12.626] }
[16:03:12.628] assign_globals() ...
[16:03:12.628] List of 11
[16:03:12.628]  $ ...future.FUN            :function (x, ...)  
[16:03:12.628]  $ x_FUN                    :function (x)  
[16:03:12.628]  $ times                    : int 2
[16:03:12.628]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.628]  $ stop_if_not              :function (...)  
[16:03:12.628]  $ dim                      : NULL
[16:03:12.628]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:12.628]  $ future.call.arguments    : list()
[16:03:12.628]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.628]  $ ...future.elements_ii    :List of 10
[16:03:12.628]   ..$ : int 1
[16:03:12.628]   ..$ : int 2
[16:03:12.628]   ..$ : int 3
[16:03:12.628]   ..$ : int 4
[16:03:12.628]   ..$ : int 5
[16:03:12.628]   ..$ : int 6
[16:03:12.628]   ..$ : int 7
[16:03:12.628]   ..$ : int 8
[16:03:12.628]   ..$ : int 9
[16:03:12.628]   ..$ : int 10
[16:03:12.628]  $ ...future.seeds_ii       : NULL
[16:03:12.628]  $ ...future.globals.maxSize: NULL
[16:03:12.628]  - attr(*, "where")=List of 11
[16:03:12.628]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.628]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:12.628]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:12.628]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:12.628]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:12.628]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:12.628]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:12.628]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.628]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.628]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.628]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.628]  - attr(*, "resolved")= logi FALSE
[16:03:12.628]  - attr(*, "total_size")= num 96456
[16:03:12.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.628]  - attr(*, "already-done")= logi TRUE
[16:03:12.639] - copied ‘...future.FUN’ to environment
[16:03:12.639] - reassign environment for ‘x_FUN’
[16:03:12.639] - copied ‘x_FUN’ to environment
[16:03:12.639] - copied ‘times’ to environment
[16:03:12.639] - copied ‘stopf’ to environment
[16:03:12.639] - copied ‘stop_if_not’ to environment
[16:03:12.639] - copied ‘dim’ to environment
[16:03:12.639] - copied ‘valid_types’ to environment
[16:03:12.639] - copied ‘future.call.arguments’ to environment
[16:03:12.639] - copied ‘...future.elements_ii’ to environment
[16:03:12.640] - copied ‘...future.seeds_ii’ to environment
[16:03:12.640] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.640] assign_globals() ... done
[16:03:12.640] plan(): Setting new future strategy stack:
[16:03:12.640] List of future strategies:
[16:03:12.640] 1. sequential:
[16:03:12.640]    - args: function (..., envir = parent.frame())
[16:03:12.640]    - tweaked: FALSE
[16:03:12.640]    - call: NULL
[16:03:12.640] plan(): nbrOfWorkers() = 1
[16:03:12.641] plan(): Setting new future strategy stack:
[16:03:12.641] List of future strategies:
[16:03:12.641] 1. sequential:
[16:03:12.641]    - args: function (..., envir = parent.frame())
[16:03:12.641]    - tweaked: FALSE
[16:03:12.641]    - call: plan(strategy)
[16:03:12.642] plan(): nbrOfWorkers() = 1
[16:03:12.642] SequentialFuture started (and completed)
[16:03:12.642] - Launch lazy future ... done
[16:03:12.642] run() for ‘SequentialFuture’ ... done
[16:03:12.642] Created future:
[16:03:12.642] SequentialFuture:
[16:03:12.642] Label: ‘future_vapply-1’
[16:03:12.642] Expression:
[16:03:12.642] {
[16:03:12.642]     do.call(function(...) {
[16:03:12.642]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.642]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.642]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.642]             on.exit(options(oopts), add = TRUE)
[16:03:12.642]         }
[16:03:12.642]         {
[16:03:12.642]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.642]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.642]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.642]             })
[16:03:12.642]         }
[16:03:12.642]     }, args = future.call.arguments)
[16:03:12.642] }
[16:03:12.642] Lazy evaluation: FALSE
[16:03:12.642] Asynchronous evaluation: FALSE
[16:03:12.642] Local evaluation: TRUE
[16:03:12.642] Environment: R_GlobalEnv
[16:03:12.642] Capture standard output: TRUE
[16:03:12.642] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.642] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:12.642] Packages: 1 packages (‘future.apply’)
[16:03:12.642] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.642] Resolved: TRUE
[16:03:12.642] Value: 640 bytes of class ‘list’
[16:03:12.642] Early signaling: FALSE
[16:03:12.642] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.642] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.643] Chunk #1 of 1 ... DONE
[16:03:12.643] Launching 1 futures (chunks) ... DONE
[16:03:12.644] Resolving 1 futures (chunks) ...
[16:03:12.644] resolve() on list ...
[16:03:12.644]  recursive: 0
[16:03:12.644]  length: 1
[16:03:12.644] 
[16:03:12.644] resolved() for ‘SequentialFuture’ ...
[16:03:12.644] - state: ‘finished’
[16:03:12.644] - run: TRUE
[16:03:12.644] - result: ‘FutureResult’
[16:03:12.644] resolved() for ‘SequentialFuture’ ... done
[16:03:12.644] Future #1
[16:03:12.645] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.645] - nx: 1
[16:03:12.645] - relay: TRUE
[16:03:12.645] - stdout: TRUE
[16:03:12.645] - signal: TRUE
[16:03:12.645] - resignal: FALSE
[16:03:12.645] - force: TRUE
[16:03:12.645] - relayed: [n=1] FALSE
[16:03:12.645] - queued futures: [n=1] FALSE
[16:03:12.645]  - until=1
[16:03:12.645]  - relaying element #1
[16:03:12.646] - relayed: [n=1] TRUE
[16:03:12.646] - queued futures: [n=1] TRUE
[16:03:12.646] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.646]  length: 0 (resolved future 1)
[16:03:12.646] Relaying remaining futures
[16:03:12.646] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.646] - nx: 1
[16:03:12.646] - relay: TRUE
[16:03:12.646] - stdout: TRUE
[16:03:12.646] - signal: TRUE
[16:03:12.647] - resignal: FALSE
[16:03:12.647] - force: TRUE
[16:03:12.647] - relayed: [n=1] TRUE
[16:03:12.647] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.647] - relayed: [n=1] TRUE
[16:03:12.647] - queued futures: [n=1] TRUE
[16:03:12.647] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.647] resolve() on list ... DONE
[16:03:12.647]  - Number of value chunks collected: 1
[16:03:12.647] Resolving 1 futures (chunks) ... DONE
[16:03:12.648] Reducing values from 1 chunks ...
[16:03:12.648]  - Number of values collected after concatenation: 10
[16:03:12.648]  - Number of values expected: 10
[16:03:12.648] Reducing values from 1 chunks ... DONE
[16:03:12.648] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:03:12.649] future_lapply() ...
[16:03:12.652] Number of chunks: 1
[16:03:12.652] getGlobalsAndPackagesXApply() ...
[16:03:12.652]  - future.globals: TRUE
[16:03:12.652] getGlobalsAndPackages() ...
[16:03:12.652] Searching for globals...
[16:03:12.655] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:03:12.655] Searching for globals ... DONE
[16:03:12.656] Resolving globals: FALSE
[16:03:12.656] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[16:03:12.657] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:12.657] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.657] - packages: [1] ‘future.apply’
[16:03:12.657] getGlobalsAndPackages() ... DONE
[16:03:12.657]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.657]  - needed namespaces: [n=1] ‘future.apply’
[16:03:12.657] Finding globals ... DONE
[16:03:12.658]  - use_args: TRUE
[16:03:12.658]  - Getting '...' globals ...
[16:03:12.658] resolve() on list ...
[16:03:12.658]  recursive: 0
[16:03:12.658]  length: 1
[16:03:12.658]  elements: ‘...’
[16:03:12.658]  length: 0 (resolved future 1)
[16:03:12.658] resolve() on list ... DONE
[16:03:12.658]    - '...' content: [n=0] 
[16:03:12.659] List of 1
[16:03:12.659]  $ ...: list()
[16:03:12.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.659]  - attr(*, "where")=List of 1
[16:03:12.659]   ..$ ...:<environment: 0x564e43066698> 
[16:03:12.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.659]  - attr(*, "resolved")= logi TRUE
[16:03:12.659]  - attr(*, "total_size")= num NA
[16:03:12.661]  - Getting '...' globals ... DONE
[16:03:12.661] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:12.661] List of 8
[16:03:12.661]  $ ...future.FUN:function (x, ...)  
[16:03:12.661]  $ x_FUN        :function (x)  
[16:03:12.661]  $ times        : int 4
[16:03:12.661]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.661]  $ stop_if_not  :function (...)  
[16:03:12.661]  $ dim          : int [1:2] 2 2
[16:03:12.661]  $ valid_types  : chr [1:2] "logical" "integer"
[16:03:12.661]  $ ...          : list()
[16:03:12.661]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.661]  - attr(*, "where")=List of 8
[16:03:12.661]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.661]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:12.661]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:12.661]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:12.661]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:12.661]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:12.661]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:12.661]   ..$ ...          :<environment: 0x564e43066698> 
[16:03:12.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.661]  - attr(*, "resolved")= logi FALSE
[16:03:12.661]  - attr(*, "total_size")= num 97232
[16:03:12.666] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:12.666] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.667] Number of futures (= number of chunks): 1
[16:03:12.667] Launching 1 futures (chunks) ...
[16:03:12.667] Chunk #1 of 1 ...
[16:03:12.667]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.667] getGlobalsAndPackages() ...
[16:03:12.667] Searching for globals...
[16:03:12.667] 
[16:03:12.668] Searching for globals ... DONE
[16:03:12.668] - globals: [0] <none>
[16:03:12.668] getGlobalsAndPackages() ... DONE
[16:03:12.668]    + additional globals found: [n=0] 
[16:03:12.668]    + additional namespaces needed: [n=0] 
[16:03:12.668]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.668]  - seeds: <none>
[16:03:12.668]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.668] getGlobalsAndPackages() ...
[16:03:12.668] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.670] Resolving globals: FALSE
[16:03:12.670] Tweak future expression to call with '...' arguments ...
[16:03:12.670] {
[16:03:12.670]     do.call(function(...) {
[16:03:12.670]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.670]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.670]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.670]             on.exit(options(oopts), add = TRUE)
[16:03:12.670]         }
[16:03:12.670]         {
[16:03:12.670]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.670]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.670]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.670]             })
[16:03:12.670]         }
[16:03:12.670]     }, args = future.call.arguments)
[16:03:12.670] }
[16:03:12.670] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.671] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.671] - packages: [1] ‘future.apply’
[16:03:12.671] getGlobalsAndPackages() ... DONE
[16:03:12.671] run() for ‘Future’ ...
[16:03:12.671] - state: ‘created’
[16:03:12.671] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.672] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.672] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.672]   - Field: ‘label’
[16:03:12.672]   - Field: ‘local’
[16:03:12.672]   - Field: ‘owner’
[16:03:12.672]   - Field: ‘envir’
[16:03:12.672]   - Field: ‘packages’
[16:03:12.672]   - Field: ‘gc’
[16:03:12.672]   - Field: ‘conditions’
[16:03:12.673]   - Field: ‘expr’
[16:03:12.673]   - Field: ‘uuid’
[16:03:12.673]   - Field: ‘seed’
[16:03:12.673]   - Field: ‘version’
[16:03:12.673]   - Field: ‘result’
[16:03:12.673]   - Field: ‘asynchronous’
[16:03:12.673]   - Field: ‘calls’
[16:03:12.673]   - Field: ‘globals’
[16:03:12.673]   - Field: ‘stdout’
[16:03:12.673]   - Field: ‘earlySignal’
[16:03:12.673]   - Field: ‘lazy’
[16:03:12.674]   - Field: ‘state’
[16:03:12.674] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.674] - Launch lazy future ...
[16:03:12.674] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:12.674] Packages needed by future strategies (n = 0): <none>
[16:03:12.674] {
[16:03:12.674]     {
[16:03:12.674]         {
[16:03:12.674]             ...future.startTime <- base::Sys.time()
[16:03:12.674]             {
[16:03:12.674]                 {
[16:03:12.674]                   {
[16:03:12.674]                     {
[16:03:12.674]                       base::local({
[16:03:12.674]                         has_future <- base::requireNamespace("future", 
[16:03:12.674]                           quietly = TRUE)
[16:03:12.674]                         if (has_future) {
[16:03:12.674]                           ns <- base::getNamespace("future")
[16:03:12.674]                           version <- ns[[".package"]][["version"]]
[16:03:12.674]                           if (is.null(version)) 
[16:03:12.674]                             version <- utils::packageVersion("future")
[16:03:12.674]                         }
[16:03:12.674]                         else {
[16:03:12.674]                           version <- NULL
[16:03:12.674]                         }
[16:03:12.674]                         if (!has_future || version < "1.8.0") {
[16:03:12.674]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.674]                             "", base::R.version$version.string), 
[16:03:12.674]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:12.674]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.674]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.674]                               "release", "version")], collapse = " "), 
[16:03:12.674]                             hostname = base::Sys.info()[["nodename"]])
[16:03:12.674]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.674]                             info)
[16:03:12.674]                           info <- base::paste(info, collapse = "; ")
[16:03:12.674]                           if (!has_future) {
[16:03:12.674]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.674]                               info)
[16:03:12.674]                           }
[16:03:12.674]                           else {
[16:03:12.674]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.674]                               info, version)
[16:03:12.674]                           }
[16:03:12.674]                           base::stop(msg)
[16:03:12.674]                         }
[16:03:12.674]                       })
[16:03:12.674]                     }
[16:03:12.674]                     base::local({
[16:03:12.674]                       for (pkg in "future.apply") {
[16:03:12.674]                         base::loadNamespace(pkg)
[16:03:12.674]                         base::library(pkg, character.only = TRUE)
[16:03:12.674]                       }
[16:03:12.674]                     })
[16:03:12.674]                   }
[16:03:12.674]                   options(future.plan = NULL)
[16:03:12.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.674]                 }
[16:03:12.674]                 ...future.workdir <- getwd()
[16:03:12.674]             }
[16:03:12.674]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.674]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.674]         }
[16:03:12.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.674]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.674]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.674]             base::names(...future.oldOptions))
[16:03:12.674]     }
[16:03:12.674]     if (FALSE) {
[16:03:12.674]     }
[16:03:12.674]     else {
[16:03:12.674]         if (TRUE) {
[16:03:12.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.674]                 open = "w")
[16:03:12.674]         }
[16:03:12.674]         else {
[16:03:12.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.674]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.674]         }
[16:03:12.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.674]             base::sink(type = "output", split = FALSE)
[16:03:12.674]             base::close(...future.stdout)
[16:03:12.674]         }, add = TRUE)
[16:03:12.674]     }
[16:03:12.674]     ...future.frame <- base::sys.nframe()
[16:03:12.674]     ...future.conditions <- base::list()
[16:03:12.674]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.674]     if (FALSE) {
[16:03:12.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.674]     }
[16:03:12.674]     ...future.result <- base::tryCatch({
[16:03:12.674]         base::withCallingHandlers({
[16:03:12.674]             ...future.value <- base::withVisible(base::local({
[16:03:12.674]                 do.call(function(...) {
[16:03:12.674]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.674]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.674]                     ...future.globals.maxSize)) {
[16:03:12.674]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.674]                     on.exit(options(oopts), add = TRUE)
[16:03:12.674]                   }
[16:03:12.674]                   {
[16:03:12.674]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.674]                       FUN = function(jj) {
[16:03:12.674]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.674]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.674]                       })
[16:03:12.674]                   }
[16:03:12.674]                 }, args = future.call.arguments)
[16:03:12.674]             }))
[16:03:12.674]             future::FutureResult(value = ...future.value$value, 
[16:03:12.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.674]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.674]                     ...future.globalenv.names))
[16:03:12.674]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.674]         }, condition = base::local({
[16:03:12.674]             c <- base::c
[16:03:12.674]             inherits <- base::inherits
[16:03:12.674]             invokeRestart <- base::invokeRestart
[16:03:12.674]             length <- base::length
[16:03:12.674]             list <- base::list
[16:03:12.674]             seq.int <- base::seq.int
[16:03:12.674]             signalCondition <- base::signalCondition
[16:03:12.674]             sys.calls <- base::sys.calls
[16:03:12.674]             `[[` <- base::`[[`
[16:03:12.674]             `+` <- base::`+`
[16:03:12.674]             `<<-` <- base::`<<-`
[16:03:12.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.674]                   3L)]
[16:03:12.674]             }
[16:03:12.674]             function(cond) {
[16:03:12.674]                 is_error <- inherits(cond, "error")
[16:03:12.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.674]                   NULL)
[16:03:12.674]                 if (is_error) {
[16:03:12.674]                   sessionInformation <- function() {
[16:03:12.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.674]                       search = base::search(), system = base::Sys.info())
[16:03:12.674]                   }
[16:03:12.674]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.674]                     cond$call), session = sessionInformation(), 
[16:03:12.674]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.674]                   signalCondition(cond)
[16:03:12.674]                 }
[16:03:12.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.674]                 "immediateCondition"))) {
[16:03:12.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.674]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.674]                   if (TRUE && !signal) {
[16:03:12.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.674]                     {
[16:03:12.674]                       inherits <- base::inherits
[16:03:12.674]                       invokeRestart <- base::invokeRestart
[16:03:12.674]                       is.null <- base::is.null
[16:03:12.674]                       muffled <- FALSE
[16:03:12.674]                       if (inherits(cond, "message")) {
[16:03:12.674]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.674]                         if (muffled) 
[16:03:12.674]                           invokeRestart("muffleMessage")
[16:03:12.674]                       }
[16:03:12.674]                       else if (inherits(cond, "warning")) {
[16:03:12.674]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.674]                         if (muffled) 
[16:03:12.674]                           invokeRestart("muffleWarning")
[16:03:12.674]                       }
[16:03:12.674]                       else if (inherits(cond, "condition")) {
[16:03:12.674]                         if (!is.null(pattern)) {
[16:03:12.674]                           computeRestarts <- base::computeRestarts
[16:03:12.674]                           grepl <- base::grepl
[16:03:12.674]                           restarts <- computeRestarts(cond)
[16:03:12.674]                           for (restart in restarts) {
[16:03:12.674]                             name <- restart$name
[16:03:12.674]                             if (is.null(name)) 
[16:03:12.674]                               next
[16:03:12.674]                             if (!grepl(pattern, name)) 
[16:03:12.674]                               next
[16:03:12.674]                             invokeRestart(restart)
[16:03:12.674]                             muffled <- TRUE
[16:03:12.674]                             break
[16:03:12.674]                           }
[16:03:12.674]                         }
[16:03:12.674]                       }
[16:03:12.674]                       invisible(muffled)
[16:03:12.674]                     }
[16:03:12.674]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.674]                   }
[16:03:12.674]                 }
[16:03:12.674]                 else {
[16:03:12.674]                   if (TRUE) {
[16:03:12.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.674]                     {
[16:03:12.674]                       inherits <- base::inherits
[16:03:12.674]                       invokeRestart <- base::invokeRestart
[16:03:12.674]                       is.null <- base::is.null
[16:03:12.674]                       muffled <- FALSE
[16:03:12.674]                       if (inherits(cond, "message")) {
[16:03:12.674]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.674]                         if (muffled) 
[16:03:12.674]                           invokeRestart("muffleMessage")
[16:03:12.674]                       }
[16:03:12.674]                       else if (inherits(cond, "warning")) {
[16:03:12.674]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.674]                         if (muffled) 
[16:03:12.674]                           invokeRestart("muffleWarning")
[16:03:12.674]                       }
[16:03:12.674]                       else if (inherits(cond, "condition")) {
[16:03:12.674]                         if (!is.null(pattern)) {
[16:03:12.674]                           computeRestarts <- base::computeRestarts
[16:03:12.674]                           grepl <- base::grepl
[16:03:12.674]                           restarts <- computeRestarts(cond)
[16:03:12.674]                           for (restart in restarts) {
[16:03:12.674]                             name <- restart$name
[16:03:12.674]                             if (is.null(name)) 
[16:03:12.674]                               next
[16:03:12.674]                             if (!grepl(pattern, name)) 
[16:03:12.674]                               next
[16:03:12.674]                             invokeRestart(restart)
[16:03:12.674]                             muffled <- TRUE
[16:03:12.674]                             break
[16:03:12.674]                           }
[16:03:12.674]                         }
[16:03:12.674]                       }
[16:03:12.674]                       invisible(muffled)
[16:03:12.674]                     }
[16:03:12.674]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.674]                   }
[16:03:12.674]                 }
[16:03:12.674]             }
[16:03:12.674]         }))
[16:03:12.674]     }, error = function(ex) {
[16:03:12.674]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.674]                 ...future.rng), started = ...future.startTime, 
[16:03:12.674]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.674]             version = "1.8"), class = "FutureResult")
[16:03:12.674]     }, finally = {
[16:03:12.674]         if (!identical(...future.workdir, getwd())) 
[16:03:12.674]             setwd(...future.workdir)
[16:03:12.674]         {
[16:03:12.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.674]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.674]             }
[16:03:12.674]             base::options(...future.oldOptions)
[16:03:12.674]             if (.Platform$OS.type == "windows") {
[16:03:12.674]                 old_names <- names(...future.oldEnvVars)
[16:03:12.674]                 envs <- base::Sys.getenv()
[16:03:12.674]                 names <- names(envs)
[16:03:12.674]                 common <- intersect(names, old_names)
[16:03:12.674]                 added <- setdiff(names, old_names)
[16:03:12.674]                 removed <- setdiff(old_names, names)
[16:03:12.674]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.674]                   envs[common]]
[16:03:12.674]                 NAMES <- toupper(changed)
[16:03:12.674]                 args <- list()
[16:03:12.674]                 for (kk in seq_along(NAMES)) {
[16:03:12.674]                   name <- changed[[kk]]
[16:03:12.674]                   NAME <- NAMES[[kk]]
[16:03:12.674]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.674]                     next
[16:03:12.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.674]                 }
[16:03:12.674]                 NAMES <- toupper(added)
[16:03:12.674]                 for (kk in seq_along(NAMES)) {
[16:03:12.674]                   name <- added[[kk]]
[16:03:12.674]                   NAME <- NAMES[[kk]]
[16:03:12.674]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.674]                     next
[16:03:12.674]                   args[[name]] <- ""
[16:03:12.674]                 }
[16:03:12.674]                 NAMES <- toupper(removed)
[16:03:12.674]                 for (kk in seq_along(NAMES)) {
[16:03:12.674]                   name <- removed[[kk]]
[16:03:12.674]                   NAME <- NAMES[[kk]]
[16:03:12.674]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.674]                     next
[16:03:12.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.674]                 }
[16:03:12.674]                 if (length(args) > 0) 
[16:03:12.674]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.674]             }
[16:03:12.674]             else {
[16:03:12.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.674]             }
[16:03:12.674]             {
[16:03:12.674]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.674]                   0L) {
[16:03:12.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.674]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.674]                   base::options(opts)
[16:03:12.674]                 }
[16:03:12.674]                 {
[16:03:12.674]                   {
[16:03:12.674]                     NULL
[16:03:12.674]                     RNGkind("Mersenne-Twister")
[16:03:12.674]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.674]                       inherits = FALSE)
[16:03:12.674]                   }
[16:03:12.674]                   options(future.plan = NULL)
[16:03:12.674]                   if (is.na(NA_character_)) 
[16:03:12.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.674]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.674]                   {
[16:03:12.674]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.674]                     if (!future$lazy) 
[16:03:12.674]                       future <- run(future)
[16:03:12.674]                     invisible(future)
[16:03:12.674]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.674]                 }
[16:03:12.674]             }
[16:03:12.674]         }
[16:03:12.674]     })
[16:03:12.674]     if (TRUE) {
[16:03:12.674]         base::sink(type = "output", split = FALSE)
[16:03:12.674]         if (TRUE) {
[16:03:12.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.674]         }
[16:03:12.674]         else {
[16:03:12.674]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.674]         }
[16:03:12.674]         base::close(...future.stdout)
[16:03:12.674]         ...future.stdout <- NULL
[16:03:12.674]     }
[16:03:12.674]     ...future.result$conditions <- ...future.conditions
[16:03:12.674]     ...future.result$finished <- base::Sys.time()
[16:03:12.674]     ...future.result
[16:03:12.674] }
[16:03:12.676] assign_globals() ...
[16:03:12.676] List of 11
[16:03:12.676]  $ ...future.FUN            :function (x, ...)  
[16:03:12.676]  $ x_FUN                    :function (x)  
[16:03:12.676]  $ times                    : int 4
[16:03:12.676]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.676]  $ stop_if_not              :function (...)  
[16:03:12.676]  $ dim                      : int [1:2] 2 2
[16:03:12.676]  $ valid_types              : chr [1:2] "logical" "integer"
[16:03:12.676]  $ future.call.arguments    : list()
[16:03:12.676]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.676]  $ ...future.elements_ii    :List of 10
[16:03:12.676]   ..$ : int 1
[16:03:12.676]   ..$ : int 2
[16:03:12.676]   ..$ : int 3
[16:03:12.676]   ..$ : int 4
[16:03:12.676]   ..$ : int 5
[16:03:12.676]   ..$ : int 6
[16:03:12.676]   ..$ : int 7
[16:03:12.676]   ..$ : int 8
[16:03:12.676]   ..$ : int 9
[16:03:12.676]   ..$ : int 10
[16:03:12.676]  $ ...future.seeds_ii       : NULL
[16:03:12.676]  $ ...future.globals.maxSize: NULL
[16:03:12.676]  - attr(*, "where")=List of 11
[16:03:12.676]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.676]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:12.676]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:12.676]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:12.676]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:12.676]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:12.676]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:12.676]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.676]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.676]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.676]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.676]  - attr(*, "resolved")= logi FALSE
[16:03:12.676]  - attr(*, "total_size")= num 97232
[16:03:12.676]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.676]  - attr(*, "already-done")= logi TRUE
[16:03:12.686] - copied ‘...future.FUN’ to environment
[16:03:12.686] - reassign environment for ‘x_FUN’
[16:03:12.686] - copied ‘x_FUN’ to environment
[16:03:12.686] - copied ‘times’ to environment
[16:03:12.686] - copied ‘stopf’ to environment
[16:03:12.686] - copied ‘stop_if_not’ to environment
[16:03:12.686] - copied ‘dim’ to environment
[16:03:12.686] - copied ‘valid_types’ to environment
[16:03:12.686] - copied ‘future.call.arguments’ to environment
[16:03:12.687] - copied ‘...future.elements_ii’ to environment
[16:03:12.687] - copied ‘...future.seeds_ii’ to environment
[16:03:12.687] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.687] assign_globals() ... done
[16:03:12.687] plan(): Setting new future strategy stack:
[16:03:12.687] List of future strategies:
[16:03:12.687] 1. sequential:
[16:03:12.687]    - args: function (..., envir = parent.frame())
[16:03:12.687]    - tweaked: FALSE
[16:03:12.687]    - call: NULL
[16:03:12.688] plan(): nbrOfWorkers() = 1
[16:03:12.688] plan(): Setting new future strategy stack:
[16:03:12.689] List of future strategies:
[16:03:12.689] 1. sequential:
[16:03:12.689]    - args: function (..., envir = parent.frame())
[16:03:12.689]    - tweaked: FALSE
[16:03:12.689]    - call: plan(strategy)
[16:03:12.689] plan(): nbrOfWorkers() = 1
[16:03:12.689] SequentialFuture started (and completed)
[16:03:12.689] - Launch lazy future ... done
[16:03:12.689] run() for ‘SequentialFuture’ ... done
[16:03:12.689] Created future:
[16:03:12.689] SequentialFuture:
[16:03:12.689] Label: ‘future_vapply-1’
[16:03:12.689] Expression:
[16:03:12.689] {
[16:03:12.689]     do.call(function(...) {
[16:03:12.689]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.689]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.689]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.689]             on.exit(options(oopts), add = TRUE)
[16:03:12.689]         }
[16:03:12.689]         {
[16:03:12.689]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.689]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.689]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.689]             })
[16:03:12.689]         }
[16:03:12.689]     }, args = future.call.arguments)
[16:03:12.689] }
[16:03:12.689] Lazy evaluation: FALSE
[16:03:12.689] Asynchronous evaluation: FALSE
[16:03:12.689] Local evaluation: TRUE
[16:03:12.689] Environment: R_GlobalEnv
[16:03:12.689] Capture standard output: TRUE
[16:03:12.689] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.689] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:12.689] Packages: 1 packages (‘future.apply’)
[16:03:12.689] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.689] Resolved: TRUE
[16:03:12.689] Value: 2.27 KiB of class ‘list’
[16:03:12.689] Early signaling: FALSE
[16:03:12.689] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.689] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.692] Chunk #1 of 1 ... DONE
[16:03:12.692] Launching 1 futures (chunks) ... DONE
[16:03:12.692] Resolving 1 futures (chunks) ...
[16:03:12.692] resolve() on list ...
[16:03:12.692]  recursive: 0
[16:03:12.692]  length: 1
[16:03:12.692] 
[16:03:12.693] resolved() for ‘SequentialFuture’ ...
[16:03:12.693] - state: ‘finished’
[16:03:12.693] - run: TRUE
[16:03:12.693] - result: ‘FutureResult’
[16:03:12.693] resolved() for ‘SequentialFuture’ ... done
[16:03:12.693] Future #1
[16:03:12.693] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.693] - nx: 1
[16:03:12.693] - relay: TRUE
[16:03:12.693] - stdout: TRUE
[16:03:12.693] - signal: TRUE
[16:03:12.693] - resignal: FALSE
[16:03:12.694] - force: TRUE
[16:03:12.694] - relayed: [n=1] FALSE
[16:03:12.694] - queued futures: [n=1] FALSE
[16:03:12.694]  - until=1
[16:03:12.694]  - relaying element #1
[16:03:12.694] - relayed: [n=1] TRUE
[16:03:12.694] - queued futures: [n=1] TRUE
[16:03:12.694] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.694]  length: 0 (resolved future 1)
[16:03:12.694] Relaying remaining futures
[16:03:12.695] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.695] - nx: 1
[16:03:12.695] - relay: TRUE
[16:03:12.695] - stdout: TRUE
[16:03:12.695] - signal: TRUE
[16:03:12.695] - resignal: FALSE
[16:03:12.695] - force: TRUE
[16:03:12.695] - relayed: [n=1] TRUE
[16:03:12.695] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.695] - relayed: [n=1] TRUE
[16:03:12.695] - queued futures: [n=1] TRUE
[16:03:12.696] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.696] resolve() on list ... DONE
[16:03:12.696]  - Number of value chunks collected: 1
[16:03:12.696] Resolving 1 futures (chunks) ... DONE
[16:03:12.696] Reducing values from 1 chunks ...
[16:03:12.696]  - Number of values collected after concatenation: 10
[16:03:12.696]  - Number of values expected: 10
[16:03:12.696] Reducing values from 1 chunks ... DONE
[16:03:12.696] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:03:12.697] future_lapply() ...
[16:03:12.699] Number of chunks: 1
[16:03:12.699] getGlobalsAndPackagesXApply() ...
[16:03:12.699]  - future.globals: TRUE
[16:03:12.699] getGlobalsAndPackages() ...
[16:03:12.699] Searching for globals...
[16:03:12.702] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:03:12.702] Searching for globals ... DONE
[16:03:12.703] Resolving globals: FALSE
[16:03:12.703] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[16:03:12.704] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:12.704] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.704] - packages: [1] ‘future.apply’
[16:03:12.704] getGlobalsAndPackages() ... DONE
[16:03:12.704]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.704]  - needed namespaces: [n=1] ‘future.apply’
[16:03:12.704] Finding globals ... DONE
[16:03:12.705]  - use_args: TRUE
[16:03:12.705]  - Getting '...' globals ...
[16:03:12.705] resolve() on list ...
[16:03:12.705]  recursive: 0
[16:03:12.705]  length: 1
[16:03:12.705]  elements: ‘...’
[16:03:12.705]  length: 0 (resolved future 1)
[16:03:12.705] resolve() on list ... DONE
[16:03:12.705]    - '...' content: [n=0] 
[16:03:12.706] List of 1
[16:03:12.706]  $ ...: list()
[16:03:12.706]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.706]  - attr(*, "where")=List of 1
[16:03:12.706]   ..$ ...:<environment: 0x564e41447f28> 
[16:03:12.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.706]  - attr(*, "resolved")= logi TRUE
[16:03:12.706]  - attr(*, "total_size")= num NA
[16:03:12.708]  - Getting '...' globals ... DONE
[16:03:12.708] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:12.708] List of 8
[16:03:12.708]  $ ...future.FUN:function (x, ...)  
[16:03:12.708]  $ x_FUN        :function (x)  
[16:03:12.708]  $ times        : int 4
[16:03:12.708]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.708]  $ stop_if_not  :function (...)  
[16:03:12.708]  $ dim          : int [1:2] 2 2
[16:03:12.708]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:12.708]  $ ...          : list()
[16:03:12.708]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.708]  - attr(*, "where")=List of 8
[16:03:12.708]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.708]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:12.708]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:12.708]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:12.708]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:12.708]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:12.708]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:12.708]   ..$ ...          :<environment: 0x564e41447f28> 
[16:03:12.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.708]  - attr(*, "resolved")= logi FALSE
[16:03:12.708]  - attr(*, "total_size")= num 97304
[16:03:12.715] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:12.715] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.715] Number of futures (= number of chunks): 1
[16:03:12.715] Launching 1 futures (chunks) ...
[16:03:12.715] Chunk #1 of 1 ...
[16:03:12.715]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.715] getGlobalsAndPackages() ...
[16:03:12.715] Searching for globals...
[16:03:12.716] 
[16:03:12.716] Searching for globals ... DONE
[16:03:12.716] - globals: [0] <none>
[16:03:12.716] getGlobalsAndPackages() ... DONE
[16:03:12.716]    + additional globals found: [n=0] 
[16:03:12.716]    + additional namespaces needed: [n=0] 
[16:03:12.716]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.716]  - seeds: <none>
[16:03:12.716]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.716] getGlobalsAndPackages() ...
[16:03:12.717] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.717] Resolving globals: FALSE
[16:03:12.717] Tweak future expression to call with '...' arguments ...
[16:03:12.717] {
[16:03:12.717]     do.call(function(...) {
[16:03:12.717]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.717]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.717]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.717]             on.exit(options(oopts), add = TRUE)
[16:03:12.717]         }
[16:03:12.717]         {
[16:03:12.717]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.717]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.717]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.717]             })
[16:03:12.717]         }
[16:03:12.717]     }, args = future.call.arguments)
[16:03:12.717] }
[16:03:12.717] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.718] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.718] - packages: [1] ‘future.apply’
[16:03:12.718] getGlobalsAndPackages() ... DONE
[16:03:12.718] run() for ‘Future’ ...
[16:03:12.718] - state: ‘created’
[16:03:12.718] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.719] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.719]   - Field: ‘label’
[16:03:12.719]   - Field: ‘local’
[16:03:12.719]   - Field: ‘owner’
[16:03:12.719]   - Field: ‘envir’
[16:03:12.719]   - Field: ‘packages’
[16:03:12.719]   - Field: ‘gc’
[16:03:12.719]   - Field: ‘conditions’
[16:03:12.719]   - Field: ‘expr’
[16:03:12.720]   - Field: ‘uuid’
[16:03:12.720]   - Field: ‘seed’
[16:03:12.720]   - Field: ‘version’
[16:03:12.720]   - Field: ‘result’
[16:03:12.720]   - Field: ‘asynchronous’
[16:03:12.720]   - Field: ‘calls’
[16:03:12.720]   - Field: ‘globals’
[16:03:12.720]   - Field: ‘stdout’
[16:03:12.720]   - Field: ‘earlySignal’
[16:03:12.720]   - Field: ‘lazy’
[16:03:12.720]   - Field: ‘state’
[16:03:12.720] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.721] - Launch lazy future ...
[16:03:12.721] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:12.721] Packages needed by future strategies (n = 0): <none>
[16:03:12.721] {
[16:03:12.721]     {
[16:03:12.721]         {
[16:03:12.721]             ...future.startTime <- base::Sys.time()
[16:03:12.721]             {
[16:03:12.721]                 {
[16:03:12.721]                   {
[16:03:12.721]                     {
[16:03:12.721]                       base::local({
[16:03:12.721]                         has_future <- base::requireNamespace("future", 
[16:03:12.721]                           quietly = TRUE)
[16:03:12.721]                         if (has_future) {
[16:03:12.721]                           ns <- base::getNamespace("future")
[16:03:12.721]                           version <- ns[[".package"]][["version"]]
[16:03:12.721]                           if (is.null(version)) 
[16:03:12.721]                             version <- utils::packageVersion("future")
[16:03:12.721]                         }
[16:03:12.721]                         else {
[16:03:12.721]                           version <- NULL
[16:03:12.721]                         }
[16:03:12.721]                         if (!has_future || version < "1.8.0") {
[16:03:12.721]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.721]                             "", base::R.version$version.string), 
[16:03:12.721]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:12.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.721]                               "release", "version")], collapse = " "), 
[16:03:12.721]                             hostname = base::Sys.info()[["nodename"]])
[16:03:12.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.721]                             info)
[16:03:12.721]                           info <- base::paste(info, collapse = "; ")
[16:03:12.721]                           if (!has_future) {
[16:03:12.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.721]                               info)
[16:03:12.721]                           }
[16:03:12.721]                           else {
[16:03:12.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.721]                               info, version)
[16:03:12.721]                           }
[16:03:12.721]                           base::stop(msg)
[16:03:12.721]                         }
[16:03:12.721]                       })
[16:03:12.721]                     }
[16:03:12.721]                     base::local({
[16:03:12.721]                       for (pkg in "future.apply") {
[16:03:12.721]                         base::loadNamespace(pkg)
[16:03:12.721]                         base::library(pkg, character.only = TRUE)
[16:03:12.721]                       }
[16:03:12.721]                     })
[16:03:12.721]                   }
[16:03:12.721]                   options(future.plan = NULL)
[16:03:12.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.721]                 }
[16:03:12.721]                 ...future.workdir <- getwd()
[16:03:12.721]             }
[16:03:12.721]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.721]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.721]         }
[16:03:12.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.721]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.721]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.721]             base::names(...future.oldOptions))
[16:03:12.721]     }
[16:03:12.721]     if (FALSE) {
[16:03:12.721]     }
[16:03:12.721]     else {
[16:03:12.721]         if (TRUE) {
[16:03:12.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.721]                 open = "w")
[16:03:12.721]         }
[16:03:12.721]         else {
[16:03:12.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.721]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.721]         }
[16:03:12.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.721]             base::sink(type = "output", split = FALSE)
[16:03:12.721]             base::close(...future.stdout)
[16:03:12.721]         }, add = TRUE)
[16:03:12.721]     }
[16:03:12.721]     ...future.frame <- base::sys.nframe()
[16:03:12.721]     ...future.conditions <- base::list()
[16:03:12.721]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.721]     if (FALSE) {
[16:03:12.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.721]     }
[16:03:12.721]     ...future.result <- base::tryCatch({
[16:03:12.721]         base::withCallingHandlers({
[16:03:12.721]             ...future.value <- base::withVisible(base::local({
[16:03:12.721]                 do.call(function(...) {
[16:03:12.721]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.721]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.721]                     ...future.globals.maxSize)) {
[16:03:12.721]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.721]                     on.exit(options(oopts), add = TRUE)
[16:03:12.721]                   }
[16:03:12.721]                   {
[16:03:12.721]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.721]                       FUN = function(jj) {
[16:03:12.721]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.721]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.721]                       })
[16:03:12.721]                   }
[16:03:12.721]                 }, args = future.call.arguments)
[16:03:12.721]             }))
[16:03:12.721]             future::FutureResult(value = ...future.value$value, 
[16:03:12.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.721]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.721]                     ...future.globalenv.names))
[16:03:12.721]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.721]         }, condition = base::local({
[16:03:12.721]             c <- base::c
[16:03:12.721]             inherits <- base::inherits
[16:03:12.721]             invokeRestart <- base::invokeRestart
[16:03:12.721]             length <- base::length
[16:03:12.721]             list <- base::list
[16:03:12.721]             seq.int <- base::seq.int
[16:03:12.721]             signalCondition <- base::signalCondition
[16:03:12.721]             sys.calls <- base::sys.calls
[16:03:12.721]             `[[` <- base::`[[`
[16:03:12.721]             `+` <- base::`+`
[16:03:12.721]             `<<-` <- base::`<<-`
[16:03:12.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.721]                   3L)]
[16:03:12.721]             }
[16:03:12.721]             function(cond) {
[16:03:12.721]                 is_error <- inherits(cond, "error")
[16:03:12.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.721]                   NULL)
[16:03:12.721]                 if (is_error) {
[16:03:12.721]                   sessionInformation <- function() {
[16:03:12.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.721]                       search = base::search(), system = base::Sys.info())
[16:03:12.721]                   }
[16:03:12.721]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.721]                     cond$call), session = sessionInformation(), 
[16:03:12.721]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.721]                   signalCondition(cond)
[16:03:12.721]                 }
[16:03:12.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.721]                 "immediateCondition"))) {
[16:03:12.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.721]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.721]                   if (TRUE && !signal) {
[16:03:12.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.721]                     {
[16:03:12.721]                       inherits <- base::inherits
[16:03:12.721]                       invokeRestart <- base::invokeRestart
[16:03:12.721]                       is.null <- base::is.null
[16:03:12.721]                       muffled <- FALSE
[16:03:12.721]                       if (inherits(cond, "message")) {
[16:03:12.721]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.721]                         if (muffled) 
[16:03:12.721]                           invokeRestart("muffleMessage")
[16:03:12.721]                       }
[16:03:12.721]                       else if (inherits(cond, "warning")) {
[16:03:12.721]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.721]                         if (muffled) 
[16:03:12.721]                           invokeRestart("muffleWarning")
[16:03:12.721]                       }
[16:03:12.721]                       else if (inherits(cond, "condition")) {
[16:03:12.721]                         if (!is.null(pattern)) {
[16:03:12.721]                           computeRestarts <- base::computeRestarts
[16:03:12.721]                           grepl <- base::grepl
[16:03:12.721]                           restarts <- computeRestarts(cond)
[16:03:12.721]                           for (restart in restarts) {
[16:03:12.721]                             name <- restart$name
[16:03:12.721]                             if (is.null(name)) 
[16:03:12.721]                               next
[16:03:12.721]                             if (!grepl(pattern, name)) 
[16:03:12.721]                               next
[16:03:12.721]                             invokeRestart(restart)
[16:03:12.721]                             muffled <- TRUE
[16:03:12.721]                             break
[16:03:12.721]                           }
[16:03:12.721]                         }
[16:03:12.721]                       }
[16:03:12.721]                       invisible(muffled)
[16:03:12.721]                     }
[16:03:12.721]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.721]                   }
[16:03:12.721]                 }
[16:03:12.721]                 else {
[16:03:12.721]                   if (TRUE) {
[16:03:12.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.721]                     {
[16:03:12.721]                       inherits <- base::inherits
[16:03:12.721]                       invokeRestart <- base::invokeRestart
[16:03:12.721]                       is.null <- base::is.null
[16:03:12.721]                       muffled <- FALSE
[16:03:12.721]                       if (inherits(cond, "message")) {
[16:03:12.721]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.721]                         if (muffled) 
[16:03:12.721]                           invokeRestart("muffleMessage")
[16:03:12.721]                       }
[16:03:12.721]                       else if (inherits(cond, "warning")) {
[16:03:12.721]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.721]                         if (muffled) 
[16:03:12.721]                           invokeRestart("muffleWarning")
[16:03:12.721]                       }
[16:03:12.721]                       else if (inherits(cond, "condition")) {
[16:03:12.721]                         if (!is.null(pattern)) {
[16:03:12.721]                           computeRestarts <- base::computeRestarts
[16:03:12.721]                           grepl <- base::grepl
[16:03:12.721]                           restarts <- computeRestarts(cond)
[16:03:12.721]                           for (restart in restarts) {
[16:03:12.721]                             name <- restart$name
[16:03:12.721]                             if (is.null(name)) 
[16:03:12.721]                               next
[16:03:12.721]                             if (!grepl(pattern, name)) 
[16:03:12.721]                               next
[16:03:12.721]                             invokeRestart(restart)
[16:03:12.721]                             muffled <- TRUE
[16:03:12.721]                             break
[16:03:12.721]                           }
[16:03:12.721]                         }
[16:03:12.721]                       }
[16:03:12.721]                       invisible(muffled)
[16:03:12.721]                     }
[16:03:12.721]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.721]                   }
[16:03:12.721]                 }
[16:03:12.721]             }
[16:03:12.721]         }))
[16:03:12.721]     }, error = function(ex) {
[16:03:12.721]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.721]                 ...future.rng), started = ...future.startTime, 
[16:03:12.721]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.721]             version = "1.8"), class = "FutureResult")
[16:03:12.721]     }, finally = {
[16:03:12.721]         if (!identical(...future.workdir, getwd())) 
[16:03:12.721]             setwd(...future.workdir)
[16:03:12.721]         {
[16:03:12.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.721]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.721]             }
[16:03:12.721]             base::options(...future.oldOptions)
[16:03:12.721]             if (.Platform$OS.type == "windows") {
[16:03:12.721]                 old_names <- names(...future.oldEnvVars)
[16:03:12.721]                 envs <- base::Sys.getenv()
[16:03:12.721]                 names <- names(envs)
[16:03:12.721]                 common <- intersect(names, old_names)
[16:03:12.721]                 added <- setdiff(names, old_names)
[16:03:12.721]                 removed <- setdiff(old_names, names)
[16:03:12.721]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.721]                   envs[common]]
[16:03:12.721]                 NAMES <- toupper(changed)
[16:03:12.721]                 args <- list()
[16:03:12.721]                 for (kk in seq_along(NAMES)) {
[16:03:12.721]                   name <- changed[[kk]]
[16:03:12.721]                   NAME <- NAMES[[kk]]
[16:03:12.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.721]                     next
[16:03:12.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.721]                 }
[16:03:12.721]                 NAMES <- toupper(added)
[16:03:12.721]                 for (kk in seq_along(NAMES)) {
[16:03:12.721]                   name <- added[[kk]]
[16:03:12.721]                   NAME <- NAMES[[kk]]
[16:03:12.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.721]                     next
[16:03:12.721]                   args[[name]] <- ""
[16:03:12.721]                 }
[16:03:12.721]                 NAMES <- toupper(removed)
[16:03:12.721]                 for (kk in seq_along(NAMES)) {
[16:03:12.721]                   name <- removed[[kk]]
[16:03:12.721]                   NAME <- NAMES[[kk]]
[16:03:12.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.721]                     next
[16:03:12.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.721]                 }
[16:03:12.721]                 if (length(args) > 0) 
[16:03:12.721]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.721]             }
[16:03:12.721]             else {
[16:03:12.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.721]             }
[16:03:12.721]             {
[16:03:12.721]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.721]                   0L) {
[16:03:12.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.721]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.721]                   base::options(opts)
[16:03:12.721]                 }
[16:03:12.721]                 {
[16:03:12.721]                   {
[16:03:12.721]                     NULL
[16:03:12.721]                     RNGkind("Mersenne-Twister")
[16:03:12.721]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.721]                       inherits = FALSE)
[16:03:12.721]                   }
[16:03:12.721]                   options(future.plan = NULL)
[16:03:12.721]                   if (is.na(NA_character_)) 
[16:03:12.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.721]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.721]                   {
[16:03:12.721]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.721]                     if (!future$lazy) 
[16:03:12.721]                       future <- run(future)
[16:03:12.721]                     invisible(future)
[16:03:12.721]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.721]                 }
[16:03:12.721]             }
[16:03:12.721]         }
[16:03:12.721]     })
[16:03:12.721]     if (TRUE) {
[16:03:12.721]         base::sink(type = "output", split = FALSE)
[16:03:12.721]         if (TRUE) {
[16:03:12.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.721]         }
[16:03:12.721]         else {
[16:03:12.721]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.721]         }
[16:03:12.721]         base::close(...future.stdout)
[16:03:12.721]         ...future.stdout <- NULL
[16:03:12.721]     }
[16:03:12.721]     ...future.result$conditions <- ...future.conditions
[16:03:12.721]     ...future.result$finished <- base::Sys.time()
[16:03:12.721]     ...future.result
[16:03:12.721] }
[16:03:12.723] assign_globals() ...
[16:03:12.723] List of 11
[16:03:12.723]  $ ...future.FUN            :function (x, ...)  
[16:03:12.723]  $ x_FUN                    :function (x)  
[16:03:12.723]  $ times                    : int 4
[16:03:12.723]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.723]  $ stop_if_not              :function (...)  
[16:03:12.723]  $ dim                      : int [1:2] 2 2
[16:03:12.723]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:12.723]  $ future.call.arguments    : list()
[16:03:12.723]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.723]  $ ...future.elements_ii    :List of 10
[16:03:12.723]   ..$ : int 1
[16:03:12.723]   ..$ : int 2
[16:03:12.723]   ..$ : int 3
[16:03:12.723]   ..$ : int 4
[16:03:12.723]   ..$ : int 5
[16:03:12.723]   ..$ : int 6
[16:03:12.723]   ..$ : int 7
[16:03:12.723]   ..$ : int 8
[16:03:12.723]   ..$ : int 9
[16:03:12.723]   ..$ : int 10
[16:03:12.723]  $ ...future.seeds_ii       : NULL
[16:03:12.723]  $ ...future.globals.maxSize: NULL
[16:03:12.723]  - attr(*, "where")=List of 11
[16:03:12.723]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.723]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:12.723]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:12.723]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:12.723]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:12.723]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:12.723]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:12.723]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.723]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.723]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.723]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.723]  - attr(*, "resolved")= logi FALSE
[16:03:12.723]  - attr(*, "total_size")= num 97304
[16:03:12.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.723]  - attr(*, "already-done")= logi TRUE
[16:03:12.757] - copied ‘...future.FUN’ to environment
[16:03:12.757] - reassign environment for ‘x_FUN’
[16:03:12.757] - copied ‘x_FUN’ to environment
[16:03:12.757] - copied ‘times’ to environment
[16:03:12.757] - copied ‘stopf’ to environment
[16:03:12.758] - copied ‘stop_if_not’ to environment
[16:03:12.758] - copied ‘dim’ to environment
[16:03:12.758] - copied ‘valid_types’ to environment
[16:03:12.758] - copied ‘future.call.arguments’ to environment
[16:03:12.758] - copied ‘...future.elements_ii’ to environment
[16:03:12.758] - copied ‘...future.seeds_ii’ to environment
[16:03:12.758] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.758] assign_globals() ... done
[16:03:12.759] plan(): Setting new future strategy stack:
[16:03:12.759] List of future strategies:
[16:03:12.759] 1. sequential:
[16:03:12.759]    - args: function (..., envir = parent.frame())
[16:03:12.759]    - tweaked: FALSE
[16:03:12.759]    - call: NULL
[16:03:12.759] plan(): nbrOfWorkers() = 1
[16:03:12.760] plan(): Setting new future strategy stack:
[16:03:12.760] List of future strategies:
[16:03:12.760] 1. sequential:
[16:03:12.760]    - args: function (..., envir = parent.frame())
[16:03:12.760]    - tweaked: FALSE
[16:03:12.760]    - call: plan(strategy)
[16:03:12.760] plan(): nbrOfWorkers() = 1
[16:03:12.760] SequentialFuture started (and completed)
[16:03:12.761] - Launch lazy future ... done
[16:03:12.761] run() for ‘SequentialFuture’ ... done
[16:03:12.761] Created future:
[16:03:12.761] SequentialFuture:
[16:03:12.761] Label: ‘future_vapply-1’
[16:03:12.761] Expression:
[16:03:12.761] {
[16:03:12.761]     do.call(function(...) {
[16:03:12.761]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.761]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.761]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.761]             on.exit(options(oopts), add = TRUE)
[16:03:12.761]         }
[16:03:12.761]         {
[16:03:12.761]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.761]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.761]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.761]             })
[16:03:12.761]         }
[16:03:12.761]     }, args = future.call.arguments)
[16:03:12.761] }
[16:03:12.761] Lazy evaluation: FALSE
[16:03:12.761] Asynchronous evaluation: FALSE
[16:03:12.761] Local evaluation: TRUE
[16:03:12.761] Environment: R_GlobalEnv
[16:03:12.761] Capture standard output: TRUE
[16:03:12.761] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.761] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:12.761] Packages: 1 packages (‘future.apply’)
[16:03:12.761] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.761] Resolved: TRUE
[16:03:12.761] Value: 2.27 KiB of class ‘list’
[16:03:12.761] Early signaling: FALSE
[16:03:12.761] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.761] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.762] Chunk #1 of 1 ... DONE
[16:03:12.762] Launching 1 futures (chunks) ... DONE
[16:03:12.762] Resolving 1 futures (chunks) ...
[16:03:12.762] resolve() on list ...
[16:03:12.762]  recursive: 0
[16:03:12.762]  length: 1
[16:03:12.763] 
[16:03:12.763] resolved() for ‘SequentialFuture’ ...
[16:03:12.763] - state: ‘finished’
[16:03:12.763] - run: TRUE
[16:03:12.763] - result: ‘FutureResult’
[16:03:12.763] resolved() for ‘SequentialFuture’ ... done
[16:03:12.763] Future #1
[16:03:12.763] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.763] - nx: 1
[16:03:12.764] - relay: TRUE
[16:03:12.764] - stdout: TRUE
[16:03:12.764] - signal: TRUE
[16:03:12.764] - resignal: FALSE
[16:03:12.764] - force: TRUE
[16:03:12.764] - relayed: [n=1] FALSE
[16:03:12.764] - queued futures: [n=1] FALSE
[16:03:12.764]  - until=1
[16:03:12.764]  - relaying element #1
[16:03:12.764] - relayed: [n=1] TRUE
[16:03:12.764] - queued futures: [n=1] TRUE
[16:03:12.765] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.765]  length: 0 (resolved future 1)
[16:03:12.765] Relaying remaining futures
[16:03:12.765] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.765] - nx: 1
[16:03:12.765] - relay: TRUE
[16:03:12.765] - stdout: TRUE
[16:03:12.765] - signal: TRUE
[16:03:12.765] - resignal: FALSE
[16:03:12.765] - force: TRUE
[16:03:12.765] - relayed: [n=1] TRUE
[16:03:12.766] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.766] - relayed: [n=1] TRUE
[16:03:12.766] - queued futures: [n=1] TRUE
[16:03:12.766] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.766] resolve() on list ... DONE
[16:03:12.766]  - Number of value chunks collected: 1
[16:03:12.766] Resolving 1 futures (chunks) ... DONE
[16:03:12.766] Reducing values from 1 chunks ...
[16:03:12.766]  - Number of values collected after concatenation: 10
[16:03:12.766]  - Number of values expected: 10
[16:03:12.767] Reducing values from 1 chunks ... DONE
[16:03:12.767] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[16:03:12.768] future_lapply() ...
[16:03:12.770] Number of chunks: 1
[16:03:12.770] getGlobalsAndPackagesXApply() ...
[16:03:12.770]  - future.globals: TRUE
[16:03:12.770] getGlobalsAndPackages() ...
[16:03:12.770] Searching for globals...
[16:03:12.774] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[16:03:12.774] Searching for globals ... DONE
[16:03:12.774] Resolving globals: FALSE
[16:03:12.775] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[16:03:12.776] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:12.776] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.776] - packages: [1] ‘future.apply’
[16:03:12.776] getGlobalsAndPackages() ... DONE
[16:03:12.776]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.776]  - needed namespaces: [n=1] ‘future.apply’
[16:03:12.776] Finding globals ... DONE
[16:03:12.776]  - use_args: TRUE
[16:03:12.777]  - Getting '...' globals ...
[16:03:12.778] resolve() on list ...
[16:03:12.778]  recursive: 0
[16:03:12.778]  length: 1
[16:03:12.778]  elements: ‘...’
[16:03:12.778]  length: 0 (resolved future 1)
[16:03:12.778] resolve() on list ... DONE
[16:03:12.778]    - '...' content: [n=0] 
[16:03:12.778] List of 1
[16:03:12.778]  $ ...: list()
[16:03:12.778]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.778]  - attr(*, "where")=List of 1
[16:03:12.778]   ..$ ...:<environment: 0x564e42a894d8> 
[16:03:12.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.778]  - attr(*, "resolved")= logi TRUE
[16:03:12.778]  - attr(*, "total_size")= num NA
[16:03:12.781]  - Getting '...' globals ... DONE
[16:03:12.781] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:12.781] List of 8
[16:03:12.781]  $ ...future.FUN:function (x, ...)  
[16:03:12.781]  $ x_FUN        :function (x)  
[16:03:12.781]  $ times        : int 4
[16:03:12.781]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.781]  $ stop_if_not  :function (...)  
[16:03:12.781]  $ dim          : int [1:2] 2 2
[16:03:12.781]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:12.781]  $ ...          : list()
[16:03:12.781]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.781]  - attr(*, "where")=List of 8
[16:03:12.781]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.781]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:12.781]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:12.781]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:12.781]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:12.781]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:12.781]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:12.781]   ..$ ...          :<environment: 0x564e42a894d8> 
[16:03:12.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.781]  - attr(*, "resolved")= logi FALSE
[16:03:12.781]  - attr(*, "total_size")= num 105552
[16:03:12.786] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:12.786] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.787] Number of futures (= number of chunks): 1
[16:03:12.787] Launching 1 futures (chunks) ...
[16:03:12.787] Chunk #1 of 1 ...
[16:03:12.787]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.787] getGlobalsAndPackages() ...
[16:03:12.787] Searching for globals...
[16:03:12.787] 
[16:03:12.787] Searching for globals ... DONE
[16:03:12.787] - globals: [0] <none>
[16:03:12.788] getGlobalsAndPackages() ... DONE
[16:03:12.788]    + additional globals found: [n=0] 
[16:03:12.788]    + additional namespaces needed: [n=0] 
[16:03:12.788]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.788]  - seeds: <none>
[16:03:12.788]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.788] getGlobalsAndPackages() ...
[16:03:12.788] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.788] Resolving globals: FALSE
[16:03:12.788] Tweak future expression to call with '...' arguments ...
[16:03:12.789] {
[16:03:12.789]     do.call(function(...) {
[16:03:12.789]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.789]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.789]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.789]             on.exit(options(oopts), add = TRUE)
[16:03:12.789]         }
[16:03:12.789]         {
[16:03:12.789]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.789]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.789]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.789]             })
[16:03:12.789]         }
[16:03:12.789]     }, args = future.call.arguments)
[16:03:12.789] }
[16:03:12.789] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.789] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.789] - packages: [1] ‘future.apply’
[16:03:12.789] getGlobalsAndPackages() ... DONE
[16:03:12.790] run() for ‘Future’ ...
[16:03:12.790] - state: ‘created’
[16:03:12.790] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.790] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.790] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.790]   - Field: ‘label’
[16:03:12.791]   - Field: ‘local’
[16:03:12.791]   - Field: ‘owner’
[16:03:12.791]   - Field: ‘envir’
[16:03:12.791]   - Field: ‘packages’
[16:03:12.791]   - Field: ‘gc’
[16:03:12.791]   - Field: ‘conditions’
[16:03:12.791]   - Field: ‘expr’
[16:03:12.791]   - Field: ‘uuid’
[16:03:12.791]   - Field: ‘seed’
[16:03:12.791]   - Field: ‘version’
[16:03:12.791]   - Field: ‘result’
[16:03:12.792]   - Field: ‘asynchronous’
[16:03:12.792]   - Field: ‘calls’
[16:03:12.792]   - Field: ‘globals’
[16:03:12.792]   - Field: ‘stdout’
[16:03:12.792]   - Field: ‘earlySignal’
[16:03:12.792]   - Field: ‘lazy’
[16:03:12.792]   - Field: ‘state’
[16:03:12.792] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.792] - Launch lazy future ...
[16:03:12.792] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:12.793] Packages needed by future strategies (n = 0): <none>
[16:03:12.793] {
[16:03:12.793]     {
[16:03:12.793]         {
[16:03:12.793]             ...future.startTime <- base::Sys.time()
[16:03:12.793]             {
[16:03:12.793]                 {
[16:03:12.793]                   {
[16:03:12.793]                     {
[16:03:12.793]                       base::local({
[16:03:12.793]                         has_future <- base::requireNamespace("future", 
[16:03:12.793]                           quietly = TRUE)
[16:03:12.793]                         if (has_future) {
[16:03:12.793]                           ns <- base::getNamespace("future")
[16:03:12.793]                           version <- ns[[".package"]][["version"]]
[16:03:12.793]                           if (is.null(version)) 
[16:03:12.793]                             version <- utils::packageVersion("future")
[16:03:12.793]                         }
[16:03:12.793]                         else {
[16:03:12.793]                           version <- NULL
[16:03:12.793]                         }
[16:03:12.793]                         if (!has_future || version < "1.8.0") {
[16:03:12.793]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.793]                             "", base::R.version$version.string), 
[16:03:12.793]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:12.793]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.793]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.793]                               "release", "version")], collapse = " "), 
[16:03:12.793]                             hostname = base::Sys.info()[["nodename"]])
[16:03:12.793]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.793]                             info)
[16:03:12.793]                           info <- base::paste(info, collapse = "; ")
[16:03:12.793]                           if (!has_future) {
[16:03:12.793]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.793]                               info)
[16:03:12.793]                           }
[16:03:12.793]                           else {
[16:03:12.793]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.793]                               info, version)
[16:03:12.793]                           }
[16:03:12.793]                           base::stop(msg)
[16:03:12.793]                         }
[16:03:12.793]                       })
[16:03:12.793]                     }
[16:03:12.793]                     base::local({
[16:03:12.793]                       for (pkg in "future.apply") {
[16:03:12.793]                         base::loadNamespace(pkg)
[16:03:12.793]                         base::library(pkg, character.only = TRUE)
[16:03:12.793]                       }
[16:03:12.793]                     })
[16:03:12.793]                   }
[16:03:12.793]                   options(future.plan = NULL)
[16:03:12.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.793]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.793]                 }
[16:03:12.793]                 ...future.workdir <- getwd()
[16:03:12.793]             }
[16:03:12.793]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.793]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.793]         }
[16:03:12.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.793]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.793]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.793]             base::names(...future.oldOptions))
[16:03:12.793]     }
[16:03:12.793]     if (FALSE) {
[16:03:12.793]     }
[16:03:12.793]     else {
[16:03:12.793]         if (TRUE) {
[16:03:12.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.793]                 open = "w")
[16:03:12.793]         }
[16:03:12.793]         else {
[16:03:12.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.793]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.793]         }
[16:03:12.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.793]             base::sink(type = "output", split = FALSE)
[16:03:12.793]             base::close(...future.stdout)
[16:03:12.793]         }, add = TRUE)
[16:03:12.793]     }
[16:03:12.793]     ...future.frame <- base::sys.nframe()
[16:03:12.793]     ...future.conditions <- base::list()
[16:03:12.793]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.793]     if (FALSE) {
[16:03:12.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.793]     }
[16:03:12.793]     ...future.result <- base::tryCatch({
[16:03:12.793]         base::withCallingHandlers({
[16:03:12.793]             ...future.value <- base::withVisible(base::local({
[16:03:12.793]                 do.call(function(...) {
[16:03:12.793]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.793]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.793]                     ...future.globals.maxSize)) {
[16:03:12.793]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.793]                     on.exit(options(oopts), add = TRUE)
[16:03:12.793]                   }
[16:03:12.793]                   {
[16:03:12.793]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.793]                       FUN = function(jj) {
[16:03:12.793]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.793]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.793]                       })
[16:03:12.793]                   }
[16:03:12.793]                 }, args = future.call.arguments)
[16:03:12.793]             }))
[16:03:12.793]             future::FutureResult(value = ...future.value$value, 
[16:03:12.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.793]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.793]                     ...future.globalenv.names))
[16:03:12.793]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.793]         }, condition = base::local({
[16:03:12.793]             c <- base::c
[16:03:12.793]             inherits <- base::inherits
[16:03:12.793]             invokeRestart <- base::invokeRestart
[16:03:12.793]             length <- base::length
[16:03:12.793]             list <- base::list
[16:03:12.793]             seq.int <- base::seq.int
[16:03:12.793]             signalCondition <- base::signalCondition
[16:03:12.793]             sys.calls <- base::sys.calls
[16:03:12.793]             `[[` <- base::`[[`
[16:03:12.793]             `+` <- base::`+`
[16:03:12.793]             `<<-` <- base::`<<-`
[16:03:12.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.793]                   3L)]
[16:03:12.793]             }
[16:03:12.793]             function(cond) {
[16:03:12.793]                 is_error <- inherits(cond, "error")
[16:03:12.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.793]                   NULL)
[16:03:12.793]                 if (is_error) {
[16:03:12.793]                   sessionInformation <- function() {
[16:03:12.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.793]                       search = base::search(), system = base::Sys.info())
[16:03:12.793]                   }
[16:03:12.793]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.793]                     cond$call), session = sessionInformation(), 
[16:03:12.793]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.793]                   signalCondition(cond)
[16:03:12.793]                 }
[16:03:12.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.793]                 "immediateCondition"))) {
[16:03:12.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.793]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.793]                   if (TRUE && !signal) {
[16:03:12.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.793]                     {
[16:03:12.793]                       inherits <- base::inherits
[16:03:12.793]                       invokeRestart <- base::invokeRestart
[16:03:12.793]                       is.null <- base::is.null
[16:03:12.793]                       muffled <- FALSE
[16:03:12.793]                       if (inherits(cond, "message")) {
[16:03:12.793]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.793]                         if (muffled) 
[16:03:12.793]                           invokeRestart("muffleMessage")
[16:03:12.793]                       }
[16:03:12.793]                       else if (inherits(cond, "warning")) {
[16:03:12.793]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.793]                         if (muffled) 
[16:03:12.793]                           invokeRestart("muffleWarning")
[16:03:12.793]                       }
[16:03:12.793]                       else if (inherits(cond, "condition")) {
[16:03:12.793]                         if (!is.null(pattern)) {
[16:03:12.793]                           computeRestarts <- base::computeRestarts
[16:03:12.793]                           grepl <- base::grepl
[16:03:12.793]                           restarts <- computeRestarts(cond)
[16:03:12.793]                           for (restart in restarts) {
[16:03:12.793]                             name <- restart$name
[16:03:12.793]                             if (is.null(name)) 
[16:03:12.793]                               next
[16:03:12.793]                             if (!grepl(pattern, name)) 
[16:03:12.793]                               next
[16:03:12.793]                             invokeRestart(restart)
[16:03:12.793]                             muffled <- TRUE
[16:03:12.793]                             break
[16:03:12.793]                           }
[16:03:12.793]                         }
[16:03:12.793]                       }
[16:03:12.793]                       invisible(muffled)
[16:03:12.793]                     }
[16:03:12.793]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.793]                   }
[16:03:12.793]                 }
[16:03:12.793]                 else {
[16:03:12.793]                   if (TRUE) {
[16:03:12.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.793]                     {
[16:03:12.793]                       inherits <- base::inherits
[16:03:12.793]                       invokeRestart <- base::invokeRestart
[16:03:12.793]                       is.null <- base::is.null
[16:03:12.793]                       muffled <- FALSE
[16:03:12.793]                       if (inherits(cond, "message")) {
[16:03:12.793]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.793]                         if (muffled) 
[16:03:12.793]                           invokeRestart("muffleMessage")
[16:03:12.793]                       }
[16:03:12.793]                       else if (inherits(cond, "warning")) {
[16:03:12.793]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.793]                         if (muffled) 
[16:03:12.793]                           invokeRestart("muffleWarning")
[16:03:12.793]                       }
[16:03:12.793]                       else if (inherits(cond, "condition")) {
[16:03:12.793]                         if (!is.null(pattern)) {
[16:03:12.793]                           computeRestarts <- base::computeRestarts
[16:03:12.793]                           grepl <- base::grepl
[16:03:12.793]                           restarts <- computeRestarts(cond)
[16:03:12.793]                           for (restart in restarts) {
[16:03:12.793]                             name <- restart$name
[16:03:12.793]                             if (is.null(name)) 
[16:03:12.793]                               next
[16:03:12.793]                             if (!grepl(pattern, name)) 
[16:03:12.793]                               next
[16:03:12.793]                             invokeRestart(restart)
[16:03:12.793]                             muffled <- TRUE
[16:03:12.793]                             break
[16:03:12.793]                           }
[16:03:12.793]                         }
[16:03:12.793]                       }
[16:03:12.793]                       invisible(muffled)
[16:03:12.793]                     }
[16:03:12.793]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.793]                   }
[16:03:12.793]                 }
[16:03:12.793]             }
[16:03:12.793]         }))
[16:03:12.793]     }, error = function(ex) {
[16:03:12.793]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.793]                 ...future.rng), started = ...future.startTime, 
[16:03:12.793]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.793]             version = "1.8"), class = "FutureResult")
[16:03:12.793]     }, finally = {
[16:03:12.793]         if (!identical(...future.workdir, getwd())) 
[16:03:12.793]             setwd(...future.workdir)
[16:03:12.793]         {
[16:03:12.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.793]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.793]             }
[16:03:12.793]             base::options(...future.oldOptions)
[16:03:12.793]             if (.Platform$OS.type == "windows") {
[16:03:12.793]                 old_names <- names(...future.oldEnvVars)
[16:03:12.793]                 envs <- base::Sys.getenv()
[16:03:12.793]                 names <- names(envs)
[16:03:12.793]                 common <- intersect(names, old_names)
[16:03:12.793]                 added <- setdiff(names, old_names)
[16:03:12.793]                 removed <- setdiff(old_names, names)
[16:03:12.793]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.793]                   envs[common]]
[16:03:12.793]                 NAMES <- toupper(changed)
[16:03:12.793]                 args <- list()
[16:03:12.793]                 for (kk in seq_along(NAMES)) {
[16:03:12.793]                   name <- changed[[kk]]
[16:03:12.793]                   NAME <- NAMES[[kk]]
[16:03:12.793]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.793]                     next
[16:03:12.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.793]                 }
[16:03:12.793]                 NAMES <- toupper(added)
[16:03:12.793]                 for (kk in seq_along(NAMES)) {
[16:03:12.793]                   name <- added[[kk]]
[16:03:12.793]                   NAME <- NAMES[[kk]]
[16:03:12.793]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.793]                     next
[16:03:12.793]                   args[[name]] <- ""
[16:03:12.793]                 }
[16:03:12.793]                 NAMES <- toupper(removed)
[16:03:12.793]                 for (kk in seq_along(NAMES)) {
[16:03:12.793]                   name <- removed[[kk]]
[16:03:12.793]                   NAME <- NAMES[[kk]]
[16:03:12.793]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.793]                     next
[16:03:12.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.793]                 }
[16:03:12.793]                 if (length(args) > 0) 
[16:03:12.793]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.793]             }
[16:03:12.793]             else {
[16:03:12.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.793]             }
[16:03:12.793]             {
[16:03:12.793]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.793]                   0L) {
[16:03:12.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.793]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.793]                   base::options(opts)
[16:03:12.793]                 }
[16:03:12.793]                 {
[16:03:12.793]                   {
[16:03:12.793]                     NULL
[16:03:12.793]                     RNGkind("Mersenne-Twister")
[16:03:12.793]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.793]                       inherits = FALSE)
[16:03:12.793]                   }
[16:03:12.793]                   options(future.plan = NULL)
[16:03:12.793]                   if (is.na(NA_character_)) 
[16:03:12.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.793]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.793]                   {
[16:03:12.793]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.793]                     if (!future$lazy) 
[16:03:12.793]                       future <- run(future)
[16:03:12.793]                     invisible(future)
[16:03:12.793]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.793]                 }
[16:03:12.793]             }
[16:03:12.793]         }
[16:03:12.793]     })
[16:03:12.793]     if (TRUE) {
[16:03:12.793]         base::sink(type = "output", split = FALSE)
[16:03:12.793]         if (TRUE) {
[16:03:12.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.793]         }
[16:03:12.793]         else {
[16:03:12.793]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.793]         }
[16:03:12.793]         base::close(...future.stdout)
[16:03:12.793]         ...future.stdout <- NULL
[16:03:12.793]     }
[16:03:12.793]     ...future.result$conditions <- ...future.conditions
[16:03:12.793]     ...future.result$finished <- base::Sys.time()
[16:03:12.793]     ...future.result
[16:03:12.793] }
[16:03:12.795] assign_globals() ...
[16:03:12.795] List of 11
[16:03:12.795]  $ ...future.FUN            :function (x, ...)  
[16:03:12.795]  $ x_FUN                    :function (x)  
[16:03:12.795]  $ times                    : int 4
[16:03:12.795]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.795]  $ stop_if_not              :function (...)  
[16:03:12.795]  $ dim                      : int [1:2] 2 2
[16:03:12.795]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:12.795]  $ future.call.arguments    : list()
[16:03:12.795]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.795]  $ ...future.elements_ii    :List of 10
[16:03:12.795]   ..$ : int 1
[16:03:12.795]   ..$ : int 2
[16:03:12.795]   ..$ : int 3
[16:03:12.795]   ..$ : int 4
[16:03:12.795]   ..$ : int 5
[16:03:12.795]   ..$ : int 6
[16:03:12.795]   ..$ : int 7
[16:03:12.795]   ..$ : int 8
[16:03:12.795]   ..$ : int 9
[16:03:12.795]   ..$ : int 10
[16:03:12.795]  $ ...future.seeds_ii       : NULL
[16:03:12.795]  $ ...future.globals.maxSize: NULL
[16:03:12.795]  - attr(*, "where")=List of 11
[16:03:12.795]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.795]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:12.795]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:12.795]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:12.795]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:12.795]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:12.795]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:12.795]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.795]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.795]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.795]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.795]  - attr(*, "resolved")= logi FALSE
[16:03:12.795]  - attr(*, "total_size")= num 105552
[16:03:12.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.795]  - attr(*, "already-done")= logi TRUE
[16:03:12.806] - copied ‘...future.FUN’ to environment
[16:03:12.806] - reassign environment for ‘x_FUN’
[16:03:12.806] - copied ‘x_FUN’ to environment
[16:03:12.806] - copied ‘times’ to environment
[16:03:12.806] - copied ‘stopf’ to environment
[16:03:12.806] - copied ‘stop_if_not’ to environment
[16:03:12.806] - copied ‘dim’ to environment
[16:03:12.806] - copied ‘valid_types’ to environment
[16:03:12.806] - copied ‘future.call.arguments’ to environment
[16:03:12.806] - copied ‘...future.elements_ii’ to environment
[16:03:12.807] - copied ‘...future.seeds_ii’ to environment
[16:03:12.807] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.807] assign_globals() ... done
[16:03:12.807] plan(): Setting new future strategy stack:
[16:03:12.807] List of future strategies:
[16:03:12.807] 1. sequential:
[16:03:12.807]    - args: function (..., envir = parent.frame())
[16:03:12.807]    - tweaked: FALSE
[16:03:12.807]    - call: NULL
[16:03:12.808] plan(): nbrOfWorkers() = 1
[16:03:12.808] plan(): Setting new future strategy stack:
[16:03:12.808] List of future strategies:
[16:03:12.808] 1. sequential:
[16:03:12.808]    - args: function (..., envir = parent.frame())
[16:03:12.808]    - tweaked: FALSE
[16:03:12.808]    - call: plan(strategy)
[16:03:12.809] plan(): nbrOfWorkers() = 1
[16:03:12.809] SequentialFuture started (and completed)
[16:03:12.809] - Launch lazy future ... done
[16:03:12.809] run() for ‘SequentialFuture’ ... done
[16:03:12.809] Created future:
[16:03:12.809] SequentialFuture:
[16:03:12.809] Label: ‘future_vapply-1’
[16:03:12.809] Expression:
[16:03:12.809] {
[16:03:12.809]     do.call(function(...) {
[16:03:12.809]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.809]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.809]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.809]             on.exit(options(oopts), add = TRUE)
[16:03:12.809]         }
[16:03:12.809]         {
[16:03:12.809]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.809]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.809]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.809]             })
[16:03:12.809]         }
[16:03:12.809]     }, args = future.call.arguments)
[16:03:12.809] }
[16:03:12.809] Lazy evaluation: FALSE
[16:03:12.809] Asynchronous evaluation: FALSE
[16:03:12.809] Local evaluation: TRUE
[16:03:12.809] Environment: R_GlobalEnv
[16:03:12.809] Capture standard output: TRUE
[16:03:12.809] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.809] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:12.809] Packages: 1 packages (‘future.apply’)
[16:03:12.809] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.809] Resolved: TRUE
[16:03:12.809] Value: 7.42 KiB of class ‘list’
[16:03:12.809] Early signaling: FALSE
[16:03:12.809] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.809] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.810] Chunk #1 of 1 ... DONE
[16:03:12.810] Launching 1 futures (chunks) ... DONE
[16:03:12.811] Resolving 1 futures (chunks) ...
[16:03:12.811] resolve() on list ...
[16:03:12.811]  recursive: 0
[16:03:12.811]  length: 1
[16:03:12.811] 
[16:03:12.811] resolved() for ‘SequentialFuture’ ...
[16:03:12.811] - state: ‘finished’
[16:03:12.811] - run: TRUE
[16:03:12.811] - result: ‘FutureResult’
[16:03:12.811] resolved() for ‘SequentialFuture’ ... done
[16:03:12.812] Future #1
[16:03:12.812] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.812] - nx: 1
[16:03:12.812] - relay: TRUE
[16:03:12.812] - stdout: TRUE
[16:03:12.812] - signal: TRUE
[16:03:12.812] - resignal: FALSE
[16:03:12.812] - force: TRUE
[16:03:12.812] - relayed: [n=1] FALSE
[16:03:12.812] - queued futures: [n=1] FALSE
[16:03:12.812]  - until=1
[16:03:12.813]  - relaying element #1
[16:03:12.813] - relayed: [n=1] TRUE
[16:03:12.813] - queued futures: [n=1] TRUE
[16:03:12.813] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.813]  length: 0 (resolved future 1)
[16:03:12.813] Relaying remaining futures
[16:03:12.813] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.813] - nx: 1
[16:03:12.813] - relay: TRUE
[16:03:12.813] - stdout: TRUE
[16:03:12.813] - signal: TRUE
[16:03:12.814] - resignal: FALSE
[16:03:12.814] - force: TRUE
[16:03:12.814] - relayed: [n=1] TRUE
[16:03:12.814] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.814] - relayed: [n=1] TRUE
[16:03:12.814] - queued futures: [n=1] TRUE
[16:03:12.814] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.814] resolve() on list ... DONE
[16:03:12.814]  - Number of value chunks collected: 1
[16:03:12.814] Resolving 1 futures (chunks) ... DONE
[16:03:12.814] Reducing values from 1 chunks ...
[16:03:12.815]  - Number of values collected after concatenation: 10
[16:03:12.815]  - Number of values expected: 10
[16:03:12.815] Reducing values from 1 chunks ... DONE
[16:03:12.815] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[16:03:12.819] future_lapply() ...
[16:03:12.820] Number of chunks: 1
[16:03:12.820] getGlobalsAndPackagesXApply() ...
[16:03:12.820]  - future.globals: TRUE
[16:03:12.821] getGlobalsAndPackages() ...
[16:03:12.821] Searching for globals...
[16:03:12.825] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[16:03:12.825] Searching for globals ... DONE
[16:03:12.825] Resolving globals: FALSE
[16:03:12.826] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[16:03:12.826] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:12.827] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.827] - packages: [2] ‘stats’, ‘future.apply’
[16:03:12.827] getGlobalsAndPackages() ... DONE
[16:03:12.827]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.827]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:03:12.827] Finding globals ... DONE
[16:03:12.827]  - use_args: TRUE
[16:03:12.827]  - Getting '...' globals ...
[16:03:12.828] resolve() on list ...
[16:03:12.828]  recursive: 0
[16:03:12.828]  length: 1
[16:03:12.828]  elements: ‘...’
[16:03:12.828]  length: 0 (resolved future 1)
[16:03:12.828] resolve() on list ... DONE
[16:03:12.828]    - '...' content: [n=0] 
[16:03:12.828] List of 1
[16:03:12.828]  $ ...: list()
[16:03:12.828]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.828]  - attr(*, "where")=List of 1
[16:03:12.828]   ..$ ...:<environment: 0x564e42d1bfc8> 
[16:03:12.828]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.828]  - attr(*, "resolved")= logi TRUE
[16:03:12.828]  - attr(*, "total_size")= num NA
[16:03:12.831]  - Getting '...' globals ... DONE
[16:03:12.831] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:12.831] List of 8
[16:03:12.831]  $ ...future.FUN:function (x, ...)  
[16:03:12.831]  $ x_FUN        :function (x, ...)  
[16:03:12.831]  $ times        : int 5
[16:03:12.831]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.831]  $ stop_if_not  :function (...)  
[16:03:12.831]  $ dim          : NULL
[16:03:12.831]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:12.831]  $ ...          : list()
[16:03:12.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.831]  - attr(*, "where")=List of 8
[16:03:12.831]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.831]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:12.831]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:12.831]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:12.831]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:12.831]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:12.831]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:12.831]   ..$ ...          :<environment: 0x564e42d1bfc8> 
[16:03:12.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.831]  - attr(*, "resolved")= logi FALSE
[16:03:12.831]  - attr(*, "total_size")= num 95528
[16:03:12.836] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:03:12.836] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.836] Number of futures (= number of chunks): 1
[16:03:12.836] Launching 1 futures (chunks) ...
[16:03:12.836] Chunk #1 of 1 ...
[16:03:12.836]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.837] getGlobalsAndPackages() ...
[16:03:12.837] Searching for globals...
[16:03:12.837] 
[16:03:12.837] Searching for globals ... DONE
[16:03:12.837] - globals: [0] <none>
[16:03:12.837] getGlobalsAndPackages() ... DONE
[16:03:12.837]    + additional globals found: [n=0] 
[16:03:12.837]    + additional namespaces needed: [n=0] 
[16:03:12.837]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.837]  - seeds: <none>
[16:03:12.838]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.838] getGlobalsAndPackages() ...
[16:03:12.838] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.838] Resolving globals: FALSE
[16:03:12.838] Tweak future expression to call with '...' arguments ...
[16:03:12.838] {
[16:03:12.838]     do.call(function(...) {
[16:03:12.838]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.838]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.838]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.838]             on.exit(options(oopts), add = TRUE)
[16:03:12.838]         }
[16:03:12.838]         {
[16:03:12.838]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.838]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.838]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.838]             })
[16:03:12.838]         }
[16:03:12.838]     }, args = future.call.arguments)
[16:03:12.838] }
[16:03:12.838] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.839] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.839] - packages: [2] ‘stats’, ‘future.apply’
[16:03:12.839] getGlobalsAndPackages() ... DONE
[16:03:12.839] run() for ‘Future’ ...
[16:03:12.839] - state: ‘created’
[16:03:12.840] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.840] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.840] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.840]   - Field: ‘label’
[16:03:12.840]   - Field: ‘local’
[16:03:12.840]   - Field: ‘owner’
[16:03:12.840]   - Field: ‘envir’
[16:03:12.840]   - Field: ‘packages’
[16:03:12.840]   - Field: ‘gc’
[16:03:12.841]   - Field: ‘conditions’
[16:03:12.841]   - Field: ‘expr’
[16:03:12.841]   - Field: ‘uuid’
[16:03:12.841]   - Field: ‘seed’
[16:03:12.841]   - Field: ‘version’
[16:03:12.841]   - Field: ‘result’
[16:03:12.841]   - Field: ‘asynchronous’
[16:03:12.841]   - Field: ‘calls’
[16:03:12.841]   - Field: ‘globals’
[16:03:12.841]   - Field: ‘stdout’
[16:03:12.841]   - Field: ‘earlySignal’
[16:03:12.842]   - Field: ‘lazy’
[16:03:12.842]   - Field: ‘state’
[16:03:12.842] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.842] - Launch lazy future ...
[16:03:12.842] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:03:12.842] Packages needed by future strategies (n = 0): <none>
[16:03:12.843] {
[16:03:12.843]     {
[16:03:12.843]         {
[16:03:12.843]             ...future.startTime <- base::Sys.time()
[16:03:12.843]             {
[16:03:12.843]                 {
[16:03:12.843]                   {
[16:03:12.843]                     {
[16:03:12.843]                       base::local({
[16:03:12.843]                         has_future <- base::requireNamespace("future", 
[16:03:12.843]                           quietly = TRUE)
[16:03:12.843]                         if (has_future) {
[16:03:12.843]                           ns <- base::getNamespace("future")
[16:03:12.843]                           version <- ns[[".package"]][["version"]]
[16:03:12.843]                           if (is.null(version)) 
[16:03:12.843]                             version <- utils::packageVersion("future")
[16:03:12.843]                         }
[16:03:12.843]                         else {
[16:03:12.843]                           version <- NULL
[16:03:12.843]                         }
[16:03:12.843]                         if (!has_future || version < "1.8.0") {
[16:03:12.843]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.843]                             "", base::R.version$version.string), 
[16:03:12.843]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:12.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.843]                               "release", "version")], collapse = " "), 
[16:03:12.843]                             hostname = base::Sys.info()[["nodename"]])
[16:03:12.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.843]                             info)
[16:03:12.843]                           info <- base::paste(info, collapse = "; ")
[16:03:12.843]                           if (!has_future) {
[16:03:12.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.843]                               info)
[16:03:12.843]                           }
[16:03:12.843]                           else {
[16:03:12.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.843]                               info, version)
[16:03:12.843]                           }
[16:03:12.843]                           base::stop(msg)
[16:03:12.843]                         }
[16:03:12.843]                       })
[16:03:12.843]                     }
[16:03:12.843]                     base::local({
[16:03:12.843]                       for (pkg in c("stats", "future.apply")) {
[16:03:12.843]                         base::loadNamespace(pkg)
[16:03:12.843]                         base::library(pkg, character.only = TRUE)
[16:03:12.843]                       }
[16:03:12.843]                     })
[16:03:12.843]                   }
[16:03:12.843]                   options(future.plan = NULL)
[16:03:12.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.843]                 }
[16:03:12.843]                 ...future.workdir <- getwd()
[16:03:12.843]             }
[16:03:12.843]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.843]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.843]         }
[16:03:12.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.843]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.843]             base::names(...future.oldOptions))
[16:03:12.843]     }
[16:03:12.843]     if (FALSE) {
[16:03:12.843]     }
[16:03:12.843]     else {
[16:03:12.843]         if (TRUE) {
[16:03:12.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.843]                 open = "w")
[16:03:12.843]         }
[16:03:12.843]         else {
[16:03:12.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.843]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.843]         }
[16:03:12.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.843]             base::sink(type = "output", split = FALSE)
[16:03:12.843]             base::close(...future.stdout)
[16:03:12.843]         }, add = TRUE)
[16:03:12.843]     }
[16:03:12.843]     ...future.frame <- base::sys.nframe()
[16:03:12.843]     ...future.conditions <- base::list()
[16:03:12.843]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.843]     if (FALSE) {
[16:03:12.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.843]     }
[16:03:12.843]     ...future.result <- base::tryCatch({
[16:03:12.843]         base::withCallingHandlers({
[16:03:12.843]             ...future.value <- base::withVisible(base::local({
[16:03:12.843]                 do.call(function(...) {
[16:03:12.843]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.843]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.843]                     ...future.globals.maxSize)) {
[16:03:12.843]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.843]                     on.exit(options(oopts), add = TRUE)
[16:03:12.843]                   }
[16:03:12.843]                   {
[16:03:12.843]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.843]                       FUN = function(jj) {
[16:03:12.843]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.843]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.843]                       })
[16:03:12.843]                   }
[16:03:12.843]                 }, args = future.call.arguments)
[16:03:12.843]             }))
[16:03:12.843]             future::FutureResult(value = ...future.value$value, 
[16:03:12.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.843]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.843]                     ...future.globalenv.names))
[16:03:12.843]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.843]         }, condition = base::local({
[16:03:12.843]             c <- base::c
[16:03:12.843]             inherits <- base::inherits
[16:03:12.843]             invokeRestart <- base::invokeRestart
[16:03:12.843]             length <- base::length
[16:03:12.843]             list <- base::list
[16:03:12.843]             seq.int <- base::seq.int
[16:03:12.843]             signalCondition <- base::signalCondition
[16:03:12.843]             sys.calls <- base::sys.calls
[16:03:12.843]             `[[` <- base::`[[`
[16:03:12.843]             `+` <- base::`+`
[16:03:12.843]             `<<-` <- base::`<<-`
[16:03:12.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.843]                   3L)]
[16:03:12.843]             }
[16:03:12.843]             function(cond) {
[16:03:12.843]                 is_error <- inherits(cond, "error")
[16:03:12.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.843]                   NULL)
[16:03:12.843]                 if (is_error) {
[16:03:12.843]                   sessionInformation <- function() {
[16:03:12.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.843]                       search = base::search(), system = base::Sys.info())
[16:03:12.843]                   }
[16:03:12.843]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.843]                     cond$call), session = sessionInformation(), 
[16:03:12.843]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.843]                   signalCondition(cond)
[16:03:12.843]                 }
[16:03:12.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.843]                 "immediateCondition"))) {
[16:03:12.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.843]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.843]                   if (TRUE && !signal) {
[16:03:12.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.843]                     {
[16:03:12.843]                       inherits <- base::inherits
[16:03:12.843]                       invokeRestart <- base::invokeRestart
[16:03:12.843]                       is.null <- base::is.null
[16:03:12.843]                       muffled <- FALSE
[16:03:12.843]                       if (inherits(cond, "message")) {
[16:03:12.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.843]                         if (muffled) 
[16:03:12.843]                           invokeRestart("muffleMessage")
[16:03:12.843]                       }
[16:03:12.843]                       else if (inherits(cond, "warning")) {
[16:03:12.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.843]                         if (muffled) 
[16:03:12.843]                           invokeRestart("muffleWarning")
[16:03:12.843]                       }
[16:03:12.843]                       else if (inherits(cond, "condition")) {
[16:03:12.843]                         if (!is.null(pattern)) {
[16:03:12.843]                           computeRestarts <- base::computeRestarts
[16:03:12.843]                           grepl <- base::grepl
[16:03:12.843]                           restarts <- computeRestarts(cond)
[16:03:12.843]                           for (restart in restarts) {
[16:03:12.843]                             name <- restart$name
[16:03:12.843]                             if (is.null(name)) 
[16:03:12.843]                               next
[16:03:12.843]                             if (!grepl(pattern, name)) 
[16:03:12.843]                               next
[16:03:12.843]                             invokeRestart(restart)
[16:03:12.843]                             muffled <- TRUE
[16:03:12.843]                             break
[16:03:12.843]                           }
[16:03:12.843]                         }
[16:03:12.843]                       }
[16:03:12.843]                       invisible(muffled)
[16:03:12.843]                     }
[16:03:12.843]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.843]                   }
[16:03:12.843]                 }
[16:03:12.843]                 else {
[16:03:12.843]                   if (TRUE) {
[16:03:12.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.843]                     {
[16:03:12.843]                       inherits <- base::inherits
[16:03:12.843]                       invokeRestart <- base::invokeRestart
[16:03:12.843]                       is.null <- base::is.null
[16:03:12.843]                       muffled <- FALSE
[16:03:12.843]                       if (inherits(cond, "message")) {
[16:03:12.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.843]                         if (muffled) 
[16:03:12.843]                           invokeRestart("muffleMessage")
[16:03:12.843]                       }
[16:03:12.843]                       else if (inherits(cond, "warning")) {
[16:03:12.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.843]                         if (muffled) 
[16:03:12.843]                           invokeRestart("muffleWarning")
[16:03:12.843]                       }
[16:03:12.843]                       else if (inherits(cond, "condition")) {
[16:03:12.843]                         if (!is.null(pattern)) {
[16:03:12.843]                           computeRestarts <- base::computeRestarts
[16:03:12.843]                           grepl <- base::grepl
[16:03:12.843]                           restarts <- computeRestarts(cond)
[16:03:12.843]                           for (restart in restarts) {
[16:03:12.843]                             name <- restart$name
[16:03:12.843]                             if (is.null(name)) 
[16:03:12.843]                               next
[16:03:12.843]                             if (!grepl(pattern, name)) 
[16:03:12.843]                               next
[16:03:12.843]                             invokeRestart(restart)
[16:03:12.843]                             muffled <- TRUE
[16:03:12.843]                             break
[16:03:12.843]                           }
[16:03:12.843]                         }
[16:03:12.843]                       }
[16:03:12.843]                       invisible(muffled)
[16:03:12.843]                     }
[16:03:12.843]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.843]                   }
[16:03:12.843]                 }
[16:03:12.843]             }
[16:03:12.843]         }))
[16:03:12.843]     }, error = function(ex) {
[16:03:12.843]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.843]                 ...future.rng), started = ...future.startTime, 
[16:03:12.843]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.843]             version = "1.8"), class = "FutureResult")
[16:03:12.843]     }, finally = {
[16:03:12.843]         if (!identical(...future.workdir, getwd())) 
[16:03:12.843]             setwd(...future.workdir)
[16:03:12.843]         {
[16:03:12.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.843]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.843]             }
[16:03:12.843]             base::options(...future.oldOptions)
[16:03:12.843]             if (.Platform$OS.type == "windows") {
[16:03:12.843]                 old_names <- names(...future.oldEnvVars)
[16:03:12.843]                 envs <- base::Sys.getenv()
[16:03:12.843]                 names <- names(envs)
[16:03:12.843]                 common <- intersect(names, old_names)
[16:03:12.843]                 added <- setdiff(names, old_names)
[16:03:12.843]                 removed <- setdiff(old_names, names)
[16:03:12.843]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.843]                   envs[common]]
[16:03:12.843]                 NAMES <- toupper(changed)
[16:03:12.843]                 args <- list()
[16:03:12.843]                 for (kk in seq_along(NAMES)) {
[16:03:12.843]                   name <- changed[[kk]]
[16:03:12.843]                   NAME <- NAMES[[kk]]
[16:03:12.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.843]                     next
[16:03:12.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.843]                 }
[16:03:12.843]                 NAMES <- toupper(added)
[16:03:12.843]                 for (kk in seq_along(NAMES)) {
[16:03:12.843]                   name <- added[[kk]]
[16:03:12.843]                   NAME <- NAMES[[kk]]
[16:03:12.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.843]                     next
[16:03:12.843]                   args[[name]] <- ""
[16:03:12.843]                 }
[16:03:12.843]                 NAMES <- toupper(removed)
[16:03:12.843]                 for (kk in seq_along(NAMES)) {
[16:03:12.843]                   name <- removed[[kk]]
[16:03:12.843]                   NAME <- NAMES[[kk]]
[16:03:12.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.843]                     next
[16:03:12.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.843]                 }
[16:03:12.843]                 if (length(args) > 0) 
[16:03:12.843]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.843]             }
[16:03:12.843]             else {
[16:03:12.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.843]             }
[16:03:12.843]             {
[16:03:12.843]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.843]                   0L) {
[16:03:12.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.843]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.843]                   base::options(opts)
[16:03:12.843]                 }
[16:03:12.843]                 {
[16:03:12.843]                   {
[16:03:12.843]                     NULL
[16:03:12.843]                     RNGkind("Mersenne-Twister")
[16:03:12.843]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.843]                       inherits = FALSE)
[16:03:12.843]                   }
[16:03:12.843]                   options(future.plan = NULL)
[16:03:12.843]                   if (is.na(NA_character_)) 
[16:03:12.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.843]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.843]                   {
[16:03:12.843]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.843]                     if (!future$lazy) 
[16:03:12.843]                       future <- run(future)
[16:03:12.843]                     invisible(future)
[16:03:12.843]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.843]                 }
[16:03:12.843]             }
[16:03:12.843]         }
[16:03:12.843]     })
[16:03:12.843]     if (TRUE) {
[16:03:12.843]         base::sink(type = "output", split = FALSE)
[16:03:12.843]         if (TRUE) {
[16:03:12.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.843]         }
[16:03:12.843]         else {
[16:03:12.843]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.843]         }
[16:03:12.843]         base::close(...future.stdout)
[16:03:12.843]         ...future.stdout <- NULL
[16:03:12.843]     }
[16:03:12.843]     ...future.result$conditions <- ...future.conditions
[16:03:12.843]     ...future.result$finished <- base::Sys.time()
[16:03:12.843]     ...future.result
[16:03:12.843] }
[16:03:12.844] assign_globals() ...
[16:03:12.845] List of 11
[16:03:12.845]  $ ...future.FUN            :function (x, ...)  
[16:03:12.845]  $ x_FUN                    :function (x, ...)  
[16:03:12.845]  $ times                    : int 5
[16:03:12.845]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.845]  $ stop_if_not              :function (...)  
[16:03:12.845]  $ dim                      : NULL
[16:03:12.845]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:12.845]  $ future.call.arguments    : list()
[16:03:12.845]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.845]  $ ...future.elements_ii    :List of 3
[16:03:12.845]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:03:12.845]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:03:12.845]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:03:12.845]  $ ...future.seeds_ii       : NULL
[16:03:12.845]  $ ...future.globals.maxSize: NULL
[16:03:12.845]  - attr(*, "where")=List of 11
[16:03:12.845]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.845]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:12.845]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:12.845]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:12.845]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:12.845]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:12.845]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:12.845]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.845]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.845]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.845]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.845]  - attr(*, "resolved")= logi FALSE
[16:03:12.845]  - attr(*, "total_size")= num 95528
[16:03:12.845]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.845]  - attr(*, "already-done")= logi TRUE
[16:03:12.853] - copied ‘...future.FUN’ to environment
[16:03:12.853] - copied ‘x_FUN’ to environment
[16:03:12.853] - copied ‘times’ to environment
[16:03:12.854] - copied ‘stopf’ to environment
[16:03:12.854] - copied ‘stop_if_not’ to environment
[16:03:12.854] - copied ‘dim’ to environment
[16:03:12.854] - copied ‘valid_types’ to environment
[16:03:12.854] - copied ‘future.call.arguments’ to environment
[16:03:12.854] - copied ‘...future.elements_ii’ to environment
[16:03:12.854] - copied ‘...future.seeds_ii’ to environment
[16:03:12.854] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.854] assign_globals() ... done
[16:03:12.855] plan(): Setting new future strategy stack:
[16:03:12.855] List of future strategies:
[16:03:12.855] 1. sequential:
[16:03:12.855]    - args: function (..., envir = parent.frame())
[16:03:12.855]    - tweaked: FALSE
[16:03:12.855]    - call: NULL
[16:03:12.855] plan(): nbrOfWorkers() = 1
[16:03:12.856] plan(): Setting new future strategy stack:
[16:03:12.856] List of future strategies:
[16:03:12.856] 1. sequential:
[16:03:12.856]    - args: function (..., envir = parent.frame())
[16:03:12.856]    - tweaked: FALSE
[16:03:12.856]    - call: plan(strategy)
[16:03:12.857] plan(): nbrOfWorkers() = 1
[16:03:12.857] SequentialFuture started (and completed)
[16:03:12.857] - Launch lazy future ... done
[16:03:12.857] run() for ‘SequentialFuture’ ... done
[16:03:12.857] Created future:
[16:03:12.857] SequentialFuture:
[16:03:12.857] Label: ‘future_vapply-1’
[16:03:12.857] Expression:
[16:03:12.857] {
[16:03:12.857]     do.call(function(...) {
[16:03:12.857]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.857]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.857]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.857]             on.exit(options(oopts), add = TRUE)
[16:03:12.857]         }
[16:03:12.857]         {
[16:03:12.857]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.857]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.857]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.857]             })
[16:03:12.857]         }
[16:03:12.857]     }, args = future.call.arguments)
[16:03:12.857] }
[16:03:12.857] Lazy evaluation: FALSE
[16:03:12.857] Asynchronous evaluation: FALSE
[16:03:12.857] Local evaluation: TRUE
[16:03:12.857] Environment: R_GlobalEnv
[16:03:12.857] Capture standard output: TRUE
[16:03:12.857] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.857] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:12.857] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:03:12.857] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.857] Resolved: TRUE
[16:03:12.857] Value: 1.71 KiB of class ‘list’
[16:03:12.857] Early signaling: FALSE
[16:03:12.857] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.857] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.858] Chunk #1 of 1 ... DONE
[16:03:12.858] Launching 1 futures (chunks) ... DONE
[16:03:12.858] Resolving 1 futures (chunks) ...
[16:03:12.859] resolve() on list ...
[16:03:12.859]  recursive: 0
[16:03:12.859]  length: 1
[16:03:12.859] 
[16:03:12.859] resolved() for ‘SequentialFuture’ ...
[16:03:12.859] - state: ‘finished’
[16:03:12.859] - run: TRUE
[16:03:12.859] - result: ‘FutureResult’
[16:03:12.859] resolved() for ‘SequentialFuture’ ... done
[16:03:12.859] Future #1
[16:03:12.860] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.860] - nx: 1
[16:03:12.860] - relay: TRUE
[16:03:12.860] - stdout: TRUE
[16:03:12.860] - signal: TRUE
[16:03:12.860] - resignal: FALSE
[16:03:12.860] - force: TRUE
[16:03:12.860] - relayed: [n=1] FALSE
[16:03:12.860] - queued futures: [n=1] FALSE
[16:03:12.860]  - until=1
[16:03:12.860]  - relaying element #1
[16:03:12.861] - relayed: [n=1] TRUE
[16:03:12.861] - queued futures: [n=1] TRUE
[16:03:12.861] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.861]  length: 0 (resolved future 1)
[16:03:12.861] Relaying remaining futures
[16:03:12.861] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.861] - nx: 1
[16:03:12.861] - relay: TRUE
[16:03:12.861] - stdout: TRUE
[16:03:12.861] - signal: TRUE
[16:03:12.861] - resignal: FALSE
[16:03:12.861] - force: TRUE
[16:03:12.862] - relayed: [n=1] TRUE
[16:03:12.862] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.862] - relayed: [n=1] TRUE
[16:03:12.862] - queued futures: [n=1] TRUE
[16:03:12.862] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.862] resolve() on list ... DONE
[16:03:12.862]  - Number of value chunks collected: 1
[16:03:12.862] Resolving 1 futures (chunks) ... DONE
[16:03:12.862] Reducing values from 1 chunks ...
[16:03:12.862]  - Number of values collected after concatenation: 3
[16:03:12.863]  - Number of values expected: 3
[16:03:12.863] Reducing values from 1 chunks ... DONE
[16:03:12.863] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[16:03:12.864] future_lapply() ...
[16:03:12.869] Number of chunks: 1
[16:03:12.869] getGlobalsAndPackagesXApply() ...
[16:03:12.869]  - future.globals: TRUE
[16:03:12.869] getGlobalsAndPackages() ...
[16:03:12.869] Searching for globals...
[16:03:12.874] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:03:12.874] Searching for globals ... DONE
[16:03:12.874] Resolving globals: FALSE
[16:03:12.875] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[16:03:12.875] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[16:03:12.875] - globals: [1] ‘FUN’
[16:03:12.875] - packages: [1] ‘stats’
[16:03:12.876] getGlobalsAndPackages() ... DONE
[16:03:12.876]  - globals found/used: [n=1] ‘FUN’
[16:03:12.876]  - needed namespaces: [n=1] ‘stats’
[16:03:12.876] Finding globals ... DONE
[16:03:12.876]  - use_args: TRUE
[16:03:12.876]  - Getting '...' globals ...
[16:03:12.876] resolve() on list ...
[16:03:12.876]  recursive: 0
[16:03:12.876]  length: 1
[16:03:12.877]  elements: ‘...’
[16:03:12.877]  length: 0 (resolved future 1)
[16:03:12.877] resolve() on list ... DONE
[16:03:12.877]    - '...' content: [n=0] 
[16:03:12.877] List of 1
[16:03:12.877]  $ ...: list()
[16:03:12.877]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.877]  - attr(*, "where")=List of 1
[16:03:12.877]   ..$ ...:<environment: 0x564e42fbd6a8> 
[16:03:12.877]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.877]  - attr(*, "resolved")= logi TRUE
[16:03:12.877]  - attr(*, "total_size")= num NA
[16:03:12.879]  - Getting '...' globals ... DONE
[16:03:12.879] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:12.880] List of 2
[16:03:12.880]  $ ...future.FUN:function (x, na.rm = TRUE)  
[16:03:12.880]  $ ...          : list()
[16:03:12.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.880]  - attr(*, "where")=List of 2
[16:03:12.880]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.880]   ..$ ...          :<environment: 0x564e42fbd6a8> 
[16:03:12.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.880]  - attr(*, "resolved")= logi FALSE
[16:03:12.880]  - attr(*, "total_size")= num 46960
[16:03:12.882] Packages to be attached in all futures: [n=1] ‘stats’
[16:03:12.882] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.882] Number of futures (= number of chunks): 1
[16:03:12.882] Launching 1 futures (chunks) ...
[16:03:12.882] Chunk #1 of 1 ...
[16:03:12.883]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.883] getGlobalsAndPackages() ...
[16:03:12.883] Searching for globals...
[16:03:12.883] 
[16:03:12.883] Searching for globals ... DONE
[16:03:12.883] - globals: [0] <none>
[16:03:12.883] getGlobalsAndPackages() ... DONE
[16:03:12.883]    + additional globals found: [n=0] 
[16:03:12.884]    + additional namespaces needed: [n=0] 
[16:03:12.884]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.884]  - seeds: <none>
[16:03:12.884]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.884] getGlobalsAndPackages() ...
[16:03:12.884] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.884] Resolving globals: FALSE
[16:03:12.884] Tweak future expression to call with '...' arguments ...
[16:03:12.884] {
[16:03:12.884]     do.call(function(...) {
[16:03:12.884]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.884]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.884]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.884]             on.exit(options(oopts), add = TRUE)
[16:03:12.884]         }
[16:03:12.884]         {
[16:03:12.884]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.884]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.884]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.884]             })
[16:03:12.884]         }
[16:03:12.884]     }, args = future.call.arguments)
[16:03:12.884] }
[16:03:12.885] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.886] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.886] - packages: [1] ‘stats’
[16:03:12.886] getGlobalsAndPackages() ... DONE
[16:03:12.886] run() for ‘Future’ ...
[16:03:12.886] - state: ‘created’
[16:03:12.887] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.887] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.887] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.887]   - Field: ‘label’
[16:03:12.887]   - Field: ‘local’
[16:03:12.887]   - Field: ‘owner’
[16:03:12.887]   - Field: ‘envir’
[16:03:12.887]   - Field: ‘packages’
[16:03:12.888]   - Field: ‘gc’
[16:03:12.888]   - Field: ‘conditions’
[16:03:12.888]   - Field: ‘expr’
[16:03:12.888]   - Field: ‘uuid’
[16:03:12.888]   - Field: ‘seed’
[16:03:12.888]   - Field: ‘version’
[16:03:12.888]   - Field: ‘result’
[16:03:12.888]   - Field: ‘asynchronous’
[16:03:12.888]   - Field: ‘calls’
[16:03:12.888]   - Field: ‘globals’
[16:03:12.888]   - Field: ‘stdout’
[16:03:12.888]   - Field: ‘earlySignal’
[16:03:12.889]   - Field: ‘lazy’
[16:03:12.889]   - Field: ‘state’
[16:03:12.889] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.889] - Launch lazy future ...
[16:03:12.889] Packages needed by the future expression (n = 1): ‘stats’
[16:03:12.889] Packages needed by future strategies (n = 0): <none>
[16:03:12.890] {
[16:03:12.890]     {
[16:03:12.890]         {
[16:03:12.890]             ...future.startTime <- base::Sys.time()
[16:03:12.890]             {
[16:03:12.890]                 {
[16:03:12.890]                   {
[16:03:12.890]                     {
[16:03:12.890]                       base::local({
[16:03:12.890]                         has_future <- base::requireNamespace("future", 
[16:03:12.890]                           quietly = TRUE)
[16:03:12.890]                         if (has_future) {
[16:03:12.890]                           ns <- base::getNamespace("future")
[16:03:12.890]                           version <- ns[[".package"]][["version"]]
[16:03:12.890]                           if (is.null(version)) 
[16:03:12.890]                             version <- utils::packageVersion("future")
[16:03:12.890]                         }
[16:03:12.890]                         else {
[16:03:12.890]                           version <- NULL
[16:03:12.890]                         }
[16:03:12.890]                         if (!has_future || version < "1.8.0") {
[16:03:12.890]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.890]                             "", base::R.version$version.string), 
[16:03:12.890]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:12.890]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.890]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.890]                               "release", "version")], collapse = " "), 
[16:03:12.890]                             hostname = base::Sys.info()[["nodename"]])
[16:03:12.890]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.890]                             info)
[16:03:12.890]                           info <- base::paste(info, collapse = "; ")
[16:03:12.890]                           if (!has_future) {
[16:03:12.890]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.890]                               info)
[16:03:12.890]                           }
[16:03:12.890]                           else {
[16:03:12.890]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.890]                               info, version)
[16:03:12.890]                           }
[16:03:12.890]                           base::stop(msg)
[16:03:12.890]                         }
[16:03:12.890]                       })
[16:03:12.890]                     }
[16:03:12.890]                     base::local({
[16:03:12.890]                       for (pkg in "stats") {
[16:03:12.890]                         base::loadNamespace(pkg)
[16:03:12.890]                         base::library(pkg, character.only = TRUE)
[16:03:12.890]                       }
[16:03:12.890]                     })
[16:03:12.890]                   }
[16:03:12.890]                   options(future.plan = NULL)
[16:03:12.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.890]                 }
[16:03:12.890]                 ...future.workdir <- getwd()
[16:03:12.890]             }
[16:03:12.890]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.890]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.890]         }
[16:03:12.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.890]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.890]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.890]             base::names(...future.oldOptions))
[16:03:12.890]     }
[16:03:12.890]     if (FALSE) {
[16:03:12.890]     }
[16:03:12.890]     else {
[16:03:12.890]         if (TRUE) {
[16:03:12.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.890]                 open = "w")
[16:03:12.890]         }
[16:03:12.890]         else {
[16:03:12.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.890]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.890]         }
[16:03:12.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.890]             base::sink(type = "output", split = FALSE)
[16:03:12.890]             base::close(...future.stdout)
[16:03:12.890]         }, add = TRUE)
[16:03:12.890]     }
[16:03:12.890]     ...future.frame <- base::sys.nframe()
[16:03:12.890]     ...future.conditions <- base::list()
[16:03:12.890]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.890]     if (FALSE) {
[16:03:12.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.890]     }
[16:03:12.890]     ...future.result <- base::tryCatch({
[16:03:12.890]         base::withCallingHandlers({
[16:03:12.890]             ...future.value <- base::withVisible(base::local({
[16:03:12.890]                 do.call(function(...) {
[16:03:12.890]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.890]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.890]                     ...future.globals.maxSize)) {
[16:03:12.890]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.890]                     on.exit(options(oopts), add = TRUE)
[16:03:12.890]                   }
[16:03:12.890]                   {
[16:03:12.890]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.890]                       FUN = function(jj) {
[16:03:12.890]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.890]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.890]                       })
[16:03:12.890]                   }
[16:03:12.890]                 }, args = future.call.arguments)
[16:03:12.890]             }))
[16:03:12.890]             future::FutureResult(value = ...future.value$value, 
[16:03:12.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.890]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.890]                     ...future.globalenv.names))
[16:03:12.890]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.890]         }, condition = base::local({
[16:03:12.890]             c <- base::c
[16:03:12.890]             inherits <- base::inherits
[16:03:12.890]             invokeRestart <- base::invokeRestart
[16:03:12.890]             length <- base::length
[16:03:12.890]             list <- base::list
[16:03:12.890]             seq.int <- base::seq.int
[16:03:12.890]             signalCondition <- base::signalCondition
[16:03:12.890]             sys.calls <- base::sys.calls
[16:03:12.890]             `[[` <- base::`[[`
[16:03:12.890]             `+` <- base::`+`
[16:03:12.890]             `<<-` <- base::`<<-`
[16:03:12.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.890]                   3L)]
[16:03:12.890]             }
[16:03:12.890]             function(cond) {
[16:03:12.890]                 is_error <- inherits(cond, "error")
[16:03:12.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.890]                   NULL)
[16:03:12.890]                 if (is_error) {
[16:03:12.890]                   sessionInformation <- function() {
[16:03:12.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.890]                       search = base::search(), system = base::Sys.info())
[16:03:12.890]                   }
[16:03:12.890]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.890]                     cond$call), session = sessionInformation(), 
[16:03:12.890]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.890]                   signalCondition(cond)
[16:03:12.890]                 }
[16:03:12.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.890]                 "immediateCondition"))) {
[16:03:12.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.890]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.890]                   if (TRUE && !signal) {
[16:03:12.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.890]                     {
[16:03:12.890]                       inherits <- base::inherits
[16:03:12.890]                       invokeRestart <- base::invokeRestart
[16:03:12.890]                       is.null <- base::is.null
[16:03:12.890]                       muffled <- FALSE
[16:03:12.890]                       if (inherits(cond, "message")) {
[16:03:12.890]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.890]                         if (muffled) 
[16:03:12.890]                           invokeRestart("muffleMessage")
[16:03:12.890]                       }
[16:03:12.890]                       else if (inherits(cond, "warning")) {
[16:03:12.890]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.890]                         if (muffled) 
[16:03:12.890]                           invokeRestart("muffleWarning")
[16:03:12.890]                       }
[16:03:12.890]                       else if (inherits(cond, "condition")) {
[16:03:12.890]                         if (!is.null(pattern)) {
[16:03:12.890]                           computeRestarts <- base::computeRestarts
[16:03:12.890]                           grepl <- base::grepl
[16:03:12.890]                           restarts <- computeRestarts(cond)
[16:03:12.890]                           for (restart in restarts) {
[16:03:12.890]                             name <- restart$name
[16:03:12.890]                             if (is.null(name)) 
[16:03:12.890]                               next
[16:03:12.890]                             if (!grepl(pattern, name)) 
[16:03:12.890]                               next
[16:03:12.890]                             invokeRestart(restart)
[16:03:12.890]                             muffled <- TRUE
[16:03:12.890]                             break
[16:03:12.890]                           }
[16:03:12.890]                         }
[16:03:12.890]                       }
[16:03:12.890]                       invisible(muffled)
[16:03:12.890]                     }
[16:03:12.890]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.890]                   }
[16:03:12.890]                 }
[16:03:12.890]                 else {
[16:03:12.890]                   if (TRUE) {
[16:03:12.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.890]                     {
[16:03:12.890]                       inherits <- base::inherits
[16:03:12.890]                       invokeRestart <- base::invokeRestart
[16:03:12.890]                       is.null <- base::is.null
[16:03:12.890]                       muffled <- FALSE
[16:03:12.890]                       if (inherits(cond, "message")) {
[16:03:12.890]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.890]                         if (muffled) 
[16:03:12.890]                           invokeRestart("muffleMessage")
[16:03:12.890]                       }
[16:03:12.890]                       else if (inherits(cond, "warning")) {
[16:03:12.890]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.890]                         if (muffled) 
[16:03:12.890]                           invokeRestart("muffleWarning")
[16:03:12.890]                       }
[16:03:12.890]                       else if (inherits(cond, "condition")) {
[16:03:12.890]                         if (!is.null(pattern)) {
[16:03:12.890]                           computeRestarts <- base::computeRestarts
[16:03:12.890]                           grepl <- base::grepl
[16:03:12.890]                           restarts <- computeRestarts(cond)
[16:03:12.890]                           for (restart in restarts) {
[16:03:12.890]                             name <- restart$name
[16:03:12.890]                             if (is.null(name)) 
[16:03:12.890]                               next
[16:03:12.890]                             if (!grepl(pattern, name)) 
[16:03:12.890]                               next
[16:03:12.890]                             invokeRestart(restart)
[16:03:12.890]                             muffled <- TRUE
[16:03:12.890]                             break
[16:03:12.890]                           }
[16:03:12.890]                         }
[16:03:12.890]                       }
[16:03:12.890]                       invisible(muffled)
[16:03:12.890]                     }
[16:03:12.890]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.890]                   }
[16:03:12.890]                 }
[16:03:12.890]             }
[16:03:12.890]         }))
[16:03:12.890]     }, error = function(ex) {
[16:03:12.890]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.890]                 ...future.rng), started = ...future.startTime, 
[16:03:12.890]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.890]             version = "1.8"), class = "FutureResult")
[16:03:12.890]     }, finally = {
[16:03:12.890]         if (!identical(...future.workdir, getwd())) 
[16:03:12.890]             setwd(...future.workdir)
[16:03:12.890]         {
[16:03:12.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.890]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.890]             }
[16:03:12.890]             base::options(...future.oldOptions)
[16:03:12.890]             if (.Platform$OS.type == "windows") {
[16:03:12.890]                 old_names <- names(...future.oldEnvVars)
[16:03:12.890]                 envs <- base::Sys.getenv()
[16:03:12.890]                 names <- names(envs)
[16:03:12.890]                 common <- intersect(names, old_names)
[16:03:12.890]                 added <- setdiff(names, old_names)
[16:03:12.890]                 removed <- setdiff(old_names, names)
[16:03:12.890]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.890]                   envs[common]]
[16:03:12.890]                 NAMES <- toupper(changed)
[16:03:12.890]                 args <- list()
[16:03:12.890]                 for (kk in seq_along(NAMES)) {
[16:03:12.890]                   name <- changed[[kk]]
[16:03:12.890]                   NAME <- NAMES[[kk]]
[16:03:12.890]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.890]                     next
[16:03:12.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.890]                 }
[16:03:12.890]                 NAMES <- toupper(added)
[16:03:12.890]                 for (kk in seq_along(NAMES)) {
[16:03:12.890]                   name <- added[[kk]]
[16:03:12.890]                   NAME <- NAMES[[kk]]
[16:03:12.890]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.890]                     next
[16:03:12.890]                   args[[name]] <- ""
[16:03:12.890]                 }
[16:03:12.890]                 NAMES <- toupper(removed)
[16:03:12.890]                 for (kk in seq_along(NAMES)) {
[16:03:12.890]                   name <- removed[[kk]]
[16:03:12.890]                   NAME <- NAMES[[kk]]
[16:03:12.890]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.890]                     next
[16:03:12.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.890]                 }
[16:03:12.890]                 if (length(args) > 0) 
[16:03:12.890]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.890]             }
[16:03:12.890]             else {
[16:03:12.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.890]             }
[16:03:12.890]             {
[16:03:12.890]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.890]                   0L) {
[16:03:12.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.890]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.890]                   base::options(opts)
[16:03:12.890]                 }
[16:03:12.890]                 {
[16:03:12.890]                   {
[16:03:12.890]                     NULL
[16:03:12.890]                     RNGkind("Mersenne-Twister")
[16:03:12.890]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.890]                       inherits = FALSE)
[16:03:12.890]                   }
[16:03:12.890]                   options(future.plan = NULL)
[16:03:12.890]                   if (is.na(NA_character_)) 
[16:03:12.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.890]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.890]                   {
[16:03:12.890]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.890]                     if (!future$lazy) 
[16:03:12.890]                       future <- run(future)
[16:03:12.890]                     invisible(future)
[16:03:12.890]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.890]                 }
[16:03:12.890]             }
[16:03:12.890]         }
[16:03:12.890]     })
[16:03:12.890]     if (TRUE) {
[16:03:12.890]         base::sink(type = "output", split = FALSE)
[16:03:12.890]         if (TRUE) {
[16:03:12.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.890]         }
[16:03:12.890]         else {
[16:03:12.890]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.890]         }
[16:03:12.890]         base::close(...future.stdout)
[16:03:12.890]         ...future.stdout <- NULL
[16:03:12.890]     }
[16:03:12.890]     ...future.result$conditions <- ...future.conditions
[16:03:12.890]     ...future.result$finished <- base::Sys.time()
[16:03:12.890]     ...future.result
[16:03:12.890] }
[16:03:12.891] assign_globals() ...
[16:03:12.891] List of 5
[16:03:12.891]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[16:03:12.891]  $ future.call.arguments    : list()
[16:03:12.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.891]  $ ...future.elements_ii    :List of 7
[16:03:12.891]   ..$ : int [1:3] 1 2 3
[16:03:12.891]   ..$ : int [1:4] 1 2 3 4
[16:03:12.891]   ..$ : int [1:5] 1 2 3 4 5
[16:03:12.891]   ..$ : int [1:6] 1 2 3 4 5 6
[16:03:12.891]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:03:12.891]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:03:12.891]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:03:12.891]  $ ...future.seeds_ii       : NULL
[16:03:12.891]  $ ...future.globals.maxSize: NULL
[16:03:12.891]  - attr(*, "where")=List of 5
[16:03:12.891]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.891]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.891]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.891]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.891]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.891]  - attr(*, "resolved")= logi FALSE
[16:03:12.891]  - attr(*, "total_size")= num 46960
[16:03:12.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.891]  - attr(*, "already-done")= logi TRUE
[16:03:12.897] - copied ‘...future.FUN’ to environment
[16:03:12.898] - copied ‘future.call.arguments’ to environment
[16:03:12.898] - copied ‘...future.elements_ii’ to environment
[16:03:12.898] - copied ‘...future.seeds_ii’ to environment
[16:03:12.898] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.898] assign_globals() ... done
[16:03:12.898] plan(): Setting new future strategy stack:
[16:03:12.898] List of future strategies:
[16:03:12.898] 1. sequential:
[16:03:12.898]    - args: function (..., envir = parent.frame())
[16:03:12.898]    - tweaked: FALSE
[16:03:12.898]    - call: NULL
[16:03:12.899] plan(): nbrOfWorkers() = 1
[16:03:12.899] plan(): Setting new future strategy stack:
[16:03:12.900] List of future strategies:
[16:03:12.900] 1. sequential:
[16:03:12.900]    - args: function (..., envir = parent.frame())
[16:03:12.900]    - tweaked: FALSE
[16:03:12.900]    - call: plan(strategy)
[16:03:12.900] plan(): nbrOfWorkers() = 1
[16:03:12.900] SequentialFuture started (and completed)
[16:03:12.900] - Launch lazy future ... done
[16:03:12.900] run() for ‘SequentialFuture’ ... done
[16:03:12.900] Created future:
[16:03:12.900] SequentialFuture:
[16:03:12.900] Label: ‘future_sapply-1’
[16:03:12.900] Expression:
[16:03:12.900] {
[16:03:12.900]     do.call(function(...) {
[16:03:12.900]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.900]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.900]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.900]             on.exit(options(oopts), add = TRUE)
[16:03:12.900]         }
[16:03:12.900]         {
[16:03:12.900]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.900]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.900]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.900]             })
[16:03:12.900]         }
[16:03:12.900]     }, args = future.call.arguments)
[16:03:12.900] }
[16:03:12.900] Lazy evaluation: FALSE
[16:03:12.900] Asynchronous evaluation: FALSE
[16:03:12.900] Local evaluation: TRUE
[16:03:12.900] Environment: R_GlobalEnv
[16:03:12.900] Capture standard output: TRUE
[16:03:12.900] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.900] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:12.900] Packages: 1 packages (‘stats’)
[16:03:12.900] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.900] Resolved: TRUE
[16:03:12.900] Value: 672 bytes of class ‘list’
[16:03:12.900] Early signaling: FALSE
[16:03:12.900] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.900] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.901] Chunk #1 of 1 ... DONE
[16:03:12.902] Launching 1 futures (chunks) ... DONE
[16:03:12.902] Resolving 1 futures (chunks) ...
[16:03:12.902] resolve() on list ...
[16:03:12.902]  recursive: 0
[16:03:12.902]  length: 1
[16:03:12.902] 
[16:03:12.902] resolved() for ‘SequentialFuture’ ...
[16:03:12.902] - state: ‘finished’
[16:03:12.902] - run: TRUE
[16:03:12.902] - result: ‘FutureResult’
[16:03:12.902] resolved() for ‘SequentialFuture’ ... done
[16:03:12.903] Future #1
[16:03:12.903] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.903] - nx: 1
[16:03:12.903] - relay: TRUE
[16:03:12.903] - stdout: TRUE
[16:03:12.903] - signal: TRUE
[16:03:12.903] - resignal: FALSE
[16:03:12.903] - force: TRUE
[16:03:12.903] - relayed: [n=1] FALSE
[16:03:12.903] - queued futures: [n=1] FALSE
[16:03:12.903]  - until=1
[16:03:12.904]  - relaying element #1
[16:03:12.904] - relayed: [n=1] TRUE
[16:03:12.904] - queued futures: [n=1] TRUE
[16:03:12.904] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.904]  length: 0 (resolved future 1)
[16:03:12.904] Relaying remaining futures
[16:03:12.904] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.904] - nx: 1
[16:03:12.904] - relay: TRUE
[16:03:12.904] - stdout: TRUE
[16:03:12.904] - signal: TRUE
[16:03:12.905] - resignal: FALSE
[16:03:12.905] - force: TRUE
[16:03:12.905] - relayed: [n=1] TRUE
[16:03:12.905] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.905] - relayed: [n=1] TRUE
[16:03:12.905] - queued futures: [n=1] TRUE
[16:03:12.905] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.905] resolve() on list ... DONE
[16:03:12.905]  - Number of value chunks collected: 1
[16:03:12.905] Resolving 1 futures (chunks) ... DONE
[16:03:12.905] Reducing values from 1 chunks ...
[16:03:12.906]  - Number of values collected after concatenation: 7
[16:03:12.906]  - Number of values expected: 7
[16:03:12.906] Reducing values from 1 chunks ... DONE
[16:03:12.906] future_lapply() ... DONE
[16:03:12.906] future_lapply() ...
[16:03:12.909] Number of chunks: 1
[16:03:12.909] getGlobalsAndPackagesXApply() ...
[16:03:12.909]  - future.globals: TRUE
[16:03:12.909] getGlobalsAndPackages() ...
[16:03:12.909] Searching for globals...
[16:03:12.916] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:03:12.916] Searching for globals ... DONE
[16:03:12.916] Resolving globals: FALSE
[16:03:12.917] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[16:03:12.918] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[16:03:12.918] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.918] - packages: [2] ‘stats’, ‘future.apply’
[16:03:12.918] getGlobalsAndPackages() ... DONE
[16:03:12.918]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:12.918]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:03:12.918] Finding globals ... DONE
[16:03:12.919]  - use_args: TRUE
[16:03:12.919]  - Getting '...' globals ...
[16:03:12.919] resolve() on list ...
[16:03:12.919]  recursive: 0
[16:03:12.919]  length: 1
[16:03:12.919]  elements: ‘...’
[16:03:12.919]  length: 0 (resolved future 1)
[16:03:12.919] resolve() on list ... DONE
[16:03:12.920]    - '...' content: [n=0] 
[16:03:12.920] List of 1
[16:03:12.920]  $ ...: list()
[16:03:12.920]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.920]  - attr(*, "where")=List of 1
[16:03:12.920]   ..$ ...:<environment: 0x564e42fc6720> 
[16:03:12.920]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.920]  - attr(*, "resolved")= logi TRUE
[16:03:12.920]  - attr(*, "total_size")= num NA
[16:03:12.922]  - Getting '...' globals ... DONE
[16:03:12.922] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:12.922] List of 8
[16:03:12.922]  $ ...future.FUN:function (x, ...)  
[16:03:12.922]  $ x_FUN        :function (x, na.rm = TRUE)  
[16:03:12.922]  $ times        : int 5
[16:03:12.922]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.922]  $ stop_if_not  :function (...)  
[16:03:12.922]  $ dim          : NULL
[16:03:12.922]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:12.922]  $ ...          : list()
[16:03:12.922]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.922]  - attr(*, "where")=List of 8
[16:03:12.922]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.922]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:12.922]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:12.922]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:12.922]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:12.922]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:12.922]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:12.922]   ..$ ...          :<environment: 0x564e42fc6720> 
[16:03:12.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.922]  - attr(*, "resolved")= logi FALSE
[16:03:12.922]  - attr(*, "total_size")= num 141240
[16:03:12.928] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:03:12.928] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.929] Number of futures (= number of chunks): 1
[16:03:12.929] Launching 1 futures (chunks) ...
[16:03:12.929] Chunk #1 of 1 ...
[16:03:12.929]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.929] getGlobalsAndPackages() ...
[16:03:12.929] Searching for globals...
[16:03:12.929] 
[16:03:12.929] Searching for globals ... DONE
[16:03:12.930] - globals: [0] <none>
[16:03:12.930] getGlobalsAndPackages() ... DONE
[16:03:12.930]    + additional globals found: [n=0] 
[16:03:12.930]    + additional namespaces needed: [n=0] 
[16:03:12.930]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.930]  - seeds: <none>
[16:03:12.930]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.930] getGlobalsAndPackages() ...
[16:03:12.930] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.930] Resolving globals: FALSE
[16:03:12.930] Tweak future expression to call with '...' arguments ...
[16:03:12.931] {
[16:03:12.931]     do.call(function(...) {
[16:03:12.931]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.931]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.931]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.931]             on.exit(options(oopts), add = TRUE)
[16:03:12.931]         }
[16:03:12.931]         {
[16:03:12.931]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.931]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.931]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.931]             })
[16:03:12.931]         }
[16:03:12.931]     }, args = future.call.arguments)
[16:03:12.931] }
[16:03:12.931] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.931] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.931] - packages: [2] ‘stats’, ‘future.apply’
[16:03:12.932] getGlobalsAndPackages() ... DONE
[16:03:12.932] run() for ‘Future’ ...
[16:03:12.932] - state: ‘created’
[16:03:12.932] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.932] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.932]   - Field: ‘label’
[16:03:12.933]   - Field: ‘local’
[16:03:12.933]   - Field: ‘owner’
[16:03:12.933]   - Field: ‘envir’
[16:03:12.933]   - Field: ‘packages’
[16:03:12.933]   - Field: ‘gc’
[16:03:12.933]   - Field: ‘conditions’
[16:03:12.933]   - Field: ‘expr’
[16:03:12.933]   - Field: ‘uuid’
[16:03:12.933]   - Field: ‘seed’
[16:03:12.933]   - Field: ‘version’
[16:03:12.934]   - Field: ‘result’
[16:03:12.934]   - Field: ‘asynchronous’
[16:03:12.934]   - Field: ‘calls’
[16:03:12.934]   - Field: ‘globals’
[16:03:12.934]   - Field: ‘stdout’
[16:03:12.934]   - Field: ‘earlySignal’
[16:03:12.934]   - Field: ‘lazy’
[16:03:12.934]   - Field: ‘state’
[16:03:12.934] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.934] - Launch lazy future ...
[16:03:12.934] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:03:12.935] Packages needed by future strategies (n = 0): <none>
[16:03:12.935] {
[16:03:12.935]     {
[16:03:12.935]         {
[16:03:12.935]             ...future.startTime <- base::Sys.time()
[16:03:12.935]             {
[16:03:12.935]                 {
[16:03:12.935]                   {
[16:03:12.935]                     {
[16:03:12.935]                       base::local({
[16:03:12.935]                         has_future <- base::requireNamespace("future", 
[16:03:12.935]                           quietly = TRUE)
[16:03:12.935]                         if (has_future) {
[16:03:12.935]                           ns <- base::getNamespace("future")
[16:03:12.935]                           version <- ns[[".package"]][["version"]]
[16:03:12.935]                           if (is.null(version)) 
[16:03:12.935]                             version <- utils::packageVersion("future")
[16:03:12.935]                         }
[16:03:12.935]                         else {
[16:03:12.935]                           version <- NULL
[16:03:12.935]                         }
[16:03:12.935]                         if (!has_future || version < "1.8.0") {
[16:03:12.935]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.935]                             "", base::R.version$version.string), 
[16:03:12.935]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:12.935]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.935]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.935]                               "release", "version")], collapse = " "), 
[16:03:12.935]                             hostname = base::Sys.info()[["nodename"]])
[16:03:12.935]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.935]                             info)
[16:03:12.935]                           info <- base::paste(info, collapse = "; ")
[16:03:12.935]                           if (!has_future) {
[16:03:12.935]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.935]                               info)
[16:03:12.935]                           }
[16:03:12.935]                           else {
[16:03:12.935]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.935]                               info, version)
[16:03:12.935]                           }
[16:03:12.935]                           base::stop(msg)
[16:03:12.935]                         }
[16:03:12.935]                       })
[16:03:12.935]                     }
[16:03:12.935]                     base::local({
[16:03:12.935]                       for (pkg in c("stats", "future.apply")) {
[16:03:12.935]                         base::loadNamespace(pkg)
[16:03:12.935]                         base::library(pkg, character.only = TRUE)
[16:03:12.935]                       }
[16:03:12.935]                     })
[16:03:12.935]                   }
[16:03:12.935]                   options(future.plan = NULL)
[16:03:12.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.935]                 }
[16:03:12.935]                 ...future.workdir <- getwd()
[16:03:12.935]             }
[16:03:12.935]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.935]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.935]         }
[16:03:12.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.935]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.935]             base::names(...future.oldOptions))
[16:03:12.935]     }
[16:03:12.935]     if (FALSE) {
[16:03:12.935]     }
[16:03:12.935]     else {
[16:03:12.935]         if (TRUE) {
[16:03:12.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.935]                 open = "w")
[16:03:12.935]         }
[16:03:12.935]         else {
[16:03:12.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.935]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.935]         }
[16:03:12.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.935]             base::sink(type = "output", split = FALSE)
[16:03:12.935]             base::close(...future.stdout)
[16:03:12.935]         }, add = TRUE)
[16:03:12.935]     }
[16:03:12.935]     ...future.frame <- base::sys.nframe()
[16:03:12.935]     ...future.conditions <- base::list()
[16:03:12.935]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.935]     if (FALSE) {
[16:03:12.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.935]     }
[16:03:12.935]     ...future.result <- base::tryCatch({
[16:03:12.935]         base::withCallingHandlers({
[16:03:12.935]             ...future.value <- base::withVisible(base::local({
[16:03:12.935]                 do.call(function(...) {
[16:03:12.935]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.935]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.935]                     ...future.globals.maxSize)) {
[16:03:12.935]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.935]                     on.exit(options(oopts), add = TRUE)
[16:03:12.935]                   }
[16:03:12.935]                   {
[16:03:12.935]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.935]                       FUN = function(jj) {
[16:03:12.935]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.935]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.935]                       })
[16:03:12.935]                   }
[16:03:12.935]                 }, args = future.call.arguments)
[16:03:12.935]             }))
[16:03:12.935]             future::FutureResult(value = ...future.value$value, 
[16:03:12.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.935]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.935]                     ...future.globalenv.names))
[16:03:12.935]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.935]         }, condition = base::local({
[16:03:12.935]             c <- base::c
[16:03:12.935]             inherits <- base::inherits
[16:03:12.935]             invokeRestart <- base::invokeRestart
[16:03:12.935]             length <- base::length
[16:03:12.935]             list <- base::list
[16:03:12.935]             seq.int <- base::seq.int
[16:03:12.935]             signalCondition <- base::signalCondition
[16:03:12.935]             sys.calls <- base::sys.calls
[16:03:12.935]             `[[` <- base::`[[`
[16:03:12.935]             `+` <- base::`+`
[16:03:12.935]             `<<-` <- base::`<<-`
[16:03:12.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.935]                   3L)]
[16:03:12.935]             }
[16:03:12.935]             function(cond) {
[16:03:12.935]                 is_error <- inherits(cond, "error")
[16:03:12.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.935]                   NULL)
[16:03:12.935]                 if (is_error) {
[16:03:12.935]                   sessionInformation <- function() {
[16:03:12.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.935]                       search = base::search(), system = base::Sys.info())
[16:03:12.935]                   }
[16:03:12.935]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.935]                     cond$call), session = sessionInformation(), 
[16:03:12.935]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.935]                   signalCondition(cond)
[16:03:12.935]                 }
[16:03:12.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.935]                 "immediateCondition"))) {
[16:03:12.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.935]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.935]                   if (TRUE && !signal) {
[16:03:12.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.935]                     {
[16:03:12.935]                       inherits <- base::inherits
[16:03:12.935]                       invokeRestart <- base::invokeRestart
[16:03:12.935]                       is.null <- base::is.null
[16:03:12.935]                       muffled <- FALSE
[16:03:12.935]                       if (inherits(cond, "message")) {
[16:03:12.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.935]                         if (muffled) 
[16:03:12.935]                           invokeRestart("muffleMessage")
[16:03:12.935]                       }
[16:03:12.935]                       else if (inherits(cond, "warning")) {
[16:03:12.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.935]                         if (muffled) 
[16:03:12.935]                           invokeRestart("muffleWarning")
[16:03:12.935]                       }
[16:03:12.935]                       else if (inherits(cond, "condition")) {
[16:03:12.935]                         if (!is.null(pattern)) {
[16:03:12.935]                           computeRestarts <- base::computeRestarts
[16:03:12.935]                           grepl <- base::grepl
[16:03:12.935]                           restarts <- computeRestarts(cond)
[16:03:12.935]                           for (restart in restarts) {
[16:03:12.935]                             name <- restart$name
[16:03:12.935]                             if (is.null(name)) 
[16:03:12.935]                               next
[16:03:12.935]                             if (!grepl(pattern, name)) 
[16:03:12.935]                               next
[16:03:12.935]                             invokeRestart(restart)
[16:03:12.935]                             muffled <- TRUE
[16:03:12.935]                             break
[16:03:12.935]                           }
[16:03:12.935]                         }
[16:03:12.935]                       }
[16:03:12.935]                       invisible(muffled)
[16:03:12.935]                     }
[16:03:12.935]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.935]                   }
[16:03:12.935]                 }
[16:03:12.935]                 else {
[16:03:12.935]                   if (TRUE) {
[16:03:12.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.935]                     {
[16:03:12.935]                       inherits <- base::inherits
[16:03:12.935]                       invokeRestart <- base::invokeRestart
[16:03:12.935]                       is.null <- base::is.null
[16:03:12.935]                       muffled <- FALSE
[16:03:12.935]                       if (inherits(cond, "message")) {
[16:03:12.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.935]                         if (muffled) 
[16:03:12.935]                           invokeRestart("muffleMessage")
[16:03:12.935]                       }
[16:03:12.935]                       else if (inherits(cond, "warning")) {
[16:03:12.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.935]                         if (muffled) 
[16:03:12.935]                           invokeRestart("muffleWarning")
[16:03:12.935]                       }
[16:03:12.935]                       else if (inherits(cond, "condition")) {
[16:03:12.935]                         if (!is.null(pattern)) {
[16:03:12.935]                           computeRestarts <- base::computeRestarts
[16:03:12.935]                           grepl <- base::grepl
[16:03:12.935]                           restarts <- computeRestarts(cond)
[16:03:12.935]                           for (restart in restarts) {
[16:03:12.935]                             name <- restart$name
[16:03:12.935]                             if (is.null(name)) 
[16:03:12.935]                               next
[16:03:12.935]                             if (!grepl(pattern, name)) 
[16:03:12.935]                               next
[16:03:12.935]                             invokeRestart(restart)
[16:03:12.935]                             muffled <- TRUE
[16:03:12.935]                             break
[16:03:12.935]                           }
[16:03:12.935]                         }
[16:03:12.935]                       }
[16:03:12.935]                       invisible(muffled)
[16:03:12.935]                     }
[16:03:12.935]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.935]                   }
[16:03:12.935]                 }
[16:03:12.935]             }
[16:03:12.935]         }))
[16:03:12.935]     }, error = function(ex) {
[16:03:12.935]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.935]                 ...future.rng), started = ...future.startTime, 
[16:03:12.935]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.935]             version = "1.8"), class = "FutureResult")
[16:03:12.935]     }, finally = {
[16:03:12.935]         if (!identical(...future.workdir, getwd())) 
[16:03:12.935]             setwd(...future.workdir)
[16:03:12.935]         {
[16:03:12.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.935]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.935]             }
[16:03:12.935]             base::options(...future.oldOptions)
[16:03:12.935]             if (.Platform$OS.type == "windows") {
[16:03:12.935]                 old_names <- names(...future.oldEnvVars)
[16:03:12.935]                 envs <- base::Sys.getenv()
[16:03:12.935]                 names <- names(envs)
[16:03:12.935]                 common <- intersect(names, old_names)
[16:03:12.935]                 added <- setdiff(names, old_names)
[16:03:12.935]                 removed <- setdiff(old_names, names)
[16:03:12.935]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.935]                   envs[common]]
[16:03:12.935]                 NAMES <- toupper(changed)
[16:03:12.935]                 args <- list()
[16:03:12.935]                 for (kk in seq_along(NAMES)) {
[16:03:12.935]                   name <- changed[[kk]]
[16:03:12.935]                   NAME <- NAMES[[kk]]
[16:03:12.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.935]                     next
[16:03:12.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.935]                 }
[16:03:12.935]                 NAMES <- toupper(added)
[16:03:12.935]                 for (kk in seq_along(NAMES)) {
[16:03:12.935]                   name <- added[[kk]]
[16:03:12.935]                   NAME <- NAMES[[kk]]
[16:03:12.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.935]                     next
[16:03:12.935]                   args[[name]] <- ""
[16:03:12.935]                 }
[16:03:12.935]                 NAMES <- toupper(removed)
[16:03:12.935]                 for (kk in seq_along(NAMES)) {
[16:03:12.935]                   name <- removed[[kk]]
[16:03:12.935]                   NAME <- NAMES[[kk]]
[16:03:12.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.935]                     next
[16:03:12.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.935]                 }
[16:03:12.935]                 if (length(args) > 0) 
[16:03:12.935]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.935]             }
[16:03:12.935]             else {
[16:03:12.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.935]             }
[16:03:12.935]             {
[16:03:12.935]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.935]                   0L) {
[16:03:12.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.935]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.935]                   base::options(opts)
[16:03:12.935]                 }
[16:03:12.935]                 {
[16:03:12.935]                   {
[16:03:12.935]                     NULL
[16:03:12.935]                     RNGkind("Mersenne-Twister")
[16:03:12.935]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.935]                       inherits = FALSE)
[16:03:12.935]                   }
[16:03:12.935]                   options(future.plan = NULL)
[16:03:12.935]                   if (is.na(NA_character_)) 
[16:03:12.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.935]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.935]                   {
[16:03:12.935]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.935]                     if (!future$lazy) 
[16:03:12.935]                       future <- run(future)
[16:03:12.935]                     invisible(future)
[16:03:12.935]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.935]                 }
[16:03:12.935]             }
[16:03:12.935]         }
[16:03:12.935]     })
[16:03:12.935]     if (TRUE) {
[16:03:12.935]         base::sink(type = "output", split = FALSE)
[16:03:12.935]         if (TRUE) {
[16:03:12.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.935]         }
[16:03:12.935]         else {
[16:03:12.935]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.935]         }
[16:03:12.935]         base::close(...future.stdout)
[16:03:12.935]         ...future.stdout <- NULL
[16:03:12.935]     }
[16:03:12.935]     ...future.result$conditions <- ...future.conditions
[16:03:12.935]     ...future.result$finished <- base::Sys.time()
[16:03:12.935]     ...future.result
[16:03:12.935] }
[16:03:12.937] assign_globals() ...
[16:03:12.937] List of 11
[16:03:12.937]  $ ...future.FUN            :function (x, ...)  
[16:03:12.937]  $ x_FUN                    :function (x, na.rm = TRUE)  
[16:03:12.937]  $ times                    : int 5
[16:03:12.937]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:12.937]  $ stop_if_not              :function (...)  
[16:03:12.937]  $ dim                      : NULL
[16:03:12.937]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:12.937]  $ future.call.arguments    : list()
[16:03:12.937]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.937]  $ ...future.elements_ii    :List of 7
[16:03:12.937]   ..$ : int [1:3] 1 2 3
[16:03:12.937]   ..$ : int [1:4] 1 2 3 4
[16:03:12.937]   ..$ : int [1:5] 1 2 3 4 5
[16:03:12.937]   ..$ : int [1:6] 1 2 3 4 5 6
[16:03:12.937]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:03:12.937]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:03:12.937]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:03:12.937]  $ ...future.seeds_ii       : NULL
[16:03:12.937]  $ ...future.globals.maxSize: NULL
[16:03:12.937]  - attr(*, "where")=List of 11
[16:03:12.937]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.937]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:12.937]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:12.937]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:12.937]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:12.937]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:12.937]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:12.937]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.937]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.937]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.937]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.937]  - attr(*, "resolved")= logi FALSE
[16:03:12.937]  - attr(*, "total_size")= num 141240
[16:03:12.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.937]  - attr(*, "already-done")= logi TRUE
[16:03:12.946] - copied ‘...future.FUN’ to environment
[16:03:12.946] - copied ‘x_FUN’ to environment
[16:03:12.946] - copied ‘times’ to environment
[16:03:12.946] - copied ‘stopf’ to environment
[16:03:12.946] - copied ‘stop_if_not’ to environment
[16:03:12.946] - copied ‘dim’ to environment
[16:03:12.946] - copied ‘valid_types’ to environment
[16:03:12.947] - copied ‘future.call.arguments’ to environment
[16:03:12.947] - copied ‘...future.elements_ii’ to environment
[16:03:12.947] - copied ‘...future.seeds_ii’ to environment
[16:03:12.947] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.947] assign_globals() ... done
[16:03:12.947] plan(): Setting new future strategy stack:
[16:03:12.949] List of future strategies:
[16:03:12.949] 1. sequential:
[16:03:12.949]    - args: function (..., envir = parent.frame())
[16:03:12.949]    - tweaked: FALSE
[16:03:12.949]    - call: NULL
[16:03:12.949] plan(): nbrOfWorkers() = 1
[16:03:12.950] plan(): Setting new future strategy stack:
[16:03:12.950] List of future strategies:
[16:03:12.950] 1. sequential:
[16:03:12.950]    - args: function (..., envir = parent.frame())
[16:03:12.950]    - tweaked: FALSE
[16:03:12.950]    - call: plan(strategy)
[16:03:12.951] plan(): nbrOfWorkers() = 1
[16:03:12.951] SequentialFuture started (and completed)
[16:03:12.951] - Launch lazy future ... done
[16:03:12.951] run() for ‘SequentialFuture’ ... done
[16:03:12.951] Created future:
[16:03:12.952] SequentialFuture:
[16:03:12.952] Label: ‘future_vapply-1’
[16:03:12.952] Expression:
[16:03:12.952] {
[16:03:12.952]     do.call(function(...) {
[16:03:12.952]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.952]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.952]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.952]             on.exit(options(oopts), add = TRUE)
[16:03:12.952]         }
[16:03:12.952]         {
[16:03:12.952]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.952]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.952]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.952]             })
[16:03:12.952]         }
[16:03:12.952]     }, args = future.call.arguments)
[16:03:12.952] }
[16:03:12.952] Lazy evaluation: FALSE
[16:03:12.952] Asynchronous evaluation: FALSE
[16:03:12.952] Local evaluation: TRUE
[16:03:12.952] Environment: R_GlobalEnv
[16:03:12.952] Capture standard output: TRUE
[16:03:12.952] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.952] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:12.952] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:03:12.952] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.952] Resolved: TRUE
[16:03:12.952] Value: 672 bytes of class ‘list’
[16:03:12.952] Early signaling: FALSE
[16:03:12.952] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.952] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.953] Chunk #1 of 1 ... DONE
[16:03:12.953] Launching 1 futures (chunks) ... DONE
[16:03:12.953] Resolving 1 futures (chunks) ...
[16:03:12.953] resolve() on list ...
[16:03:12.953]  recursive: 0
[16:03:12.953]  length: 1
[16:03:12.953] 
[16:03:12.953] resolved() for ‘SequentialFuture’ ...
[16:03:12.953] - state: ‘finished’
[16:03:12.954] - run: TRUE
[16:03:12.954] - result: ‘FutureResult’
[16:03:12.954] resolved() for ‘SequentialFuture’ ... done
[16:03:12.954] Future #1
[16:03:12.954] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.954] - nx: 1
[16:03:12.954] - relay: TRUE
[16:03:12.954] - stdout: TRUE
[16:03:12.954] - signal: TRUE
[16:03:12.954] - resignal: FALSE
[16:03:12.954] - force: TRUE
[16:03:12.955] - relayed: [n=1] FALSE
[16:03:12.955] - queued futures: [n=1] FALSE
[16:03:12.955]  - until=1
[16:03:12.955]  - relaying element #1
[16:03:12.955] - relayed: [n=1] TRUE
[16:03:12.955] - queued futures: [n=1] TRUE
[16:03:12.955] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.955]  length: 0 (resolved future 1)
[16:03:12.955] Relaying remaining futures
[16:03:12.956] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.956] - nx: 1
[16:03:12.956] - relay: TRUE
[16:03:12.956] - stdout: TRUE
[16:03:12.956] - signal: TRUE
[16:03:12.956] - resignal: FALSE
[16:03:12.956] - force: TRUE
[16:03:12.956] - relayed: [n=1] TRUE
[16:03:12.956] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.956] - relayed: [n=1] TRUE
[16:03:12.956] - queued futures: [n=1] TRUE
[16:03:12.957] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.957] resolve() on list ... DONE
[16:03:12.957]  - Number of value chunks collected: 1
[16:03:12.957] Resolving 1 futures (chunks) ... DONE
[16:03:12.957] Reducing values from 1 chunks ...
[16:03:12.957]  - Number of values collected after concatenation: 7
[16:03:12.957]  - Number of values expected: 7
[16:03:12.957] Reducing values from 1 chunks ... DONE
[16:03:12.957] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[16:03:12.959] future_lapply() ...
[16:03:12.959] Number of chunks: 1
[16:03:12.960] getGlobalsAndPackagesXApply() ...
[16:03:12.960]  - future.globals: TRUE
[16:03:12.960] getGlobalsAndPackages() ...
[16:03:12.960] Searching for globals...
[16:03:12.961] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[16:03:12.961] Searching for globals ... DONE
[16:03:12.961] Resolving globals: FALSE
[16:03:12.961] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[16:03:12.962] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[16:03:12.962] - globals: [1] ‘FUN’
[16:03:12.962] 
[16:03:12.962] getGlobalsAndPackages() ... DONE
[16:03:12.962]  - globals found/used: [n=1] ‘FUN’
[16:03:12.962]  - needed namespaces: [n=0] 
[16:03:12.962] Finding globals ... DONE
[16:03:12.963]  - use_args: TRUE
[16:03:12.963]  - Getting '...' globals ...
[16:03:12.963] resolve() on list ...
[16:03:12.963]  recursive: 0
[16:03:12.963]  length: 1
[16:03:12.963]  elements: ‘...’
[16:03:12.963]  length: 0 (resolved future 1)
[16:03:12.963] resolve() on list ... DONE
[16:03:12.963]    - '...' content: [n=1] ‘y’
[16:03:12.964] List of 1
[16:03:12.964]  $ ...:List of 1
[16:03:12.964]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:12.964]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.964]  - attr(*, "where")=List of 1
[16:03:12.964]   ..$ ...:<environment: 0x564e422ae230> 
[16:03:12.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.964]  - attr(*, "resolved")= logi TRUE
[16:03:12.964]  - attr(*, "total_size")= num NA
[16:03:12.966]  - Getting '...' globals ... DONE
[16:03:12.967] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:12.967] List of 2
[16:03:12.967]  $ ...future.FUN:function (x, y)  
[16:03:12.967]  $ ...          :List of 1
[16:03:12.967]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:12.967]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.967]  - attr(*, "where")=List of 2
[16:03:12.967]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:12.967]   ..$ ...          :<environment: 0x564e422ae230> 
[16:03:12.967]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.967]  - attr(*, "resolved")= logi FALSE
[16:03:12.967]  - attr(*, "total_size")= num 4264
[16:03:12.970] Packages to be attached in all futures: [n=0] 
[16:03:12.970] getGlobalsAndPackagesXApply() ... DONE
[16:03:12.971] Number of futures (= number of chunks): 1
[16:03:12.971] Launching 1 futures (chunks) ...
[16:03:12.971] Chunk #1 of 1 ...
[16:03:12.972]  - Finding globals in 'X' for chunk #1 ...
[16:03:12.972] getGlobalsAndPackages() ...
[16:03:12.972] Searching for globals...
[16:03:12.972] 
[16:03:12.972] Searching for globals ... DONE
[16:03:12.972] - globals: [0] <none>
[16:03:12.972] getGlobalsAndPackages() ... DONE
[16:03:12.972]    + additional globals found: [n=0] 
[16:03:12.973]    + additional namespaces needed: [n=0] 
[16:03:12.973]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:12.973]  - seeds: <none>
[16:03:12.973]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.973] getGlobalsAndPackages() ...
[16:03:12.973] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.973] Resolving globals: FALSE
[16:03:12.973] Tweak future expression to call with '...' arguments ...
[16:03:12.973] {
[16:03:12.973]     do.call(function(...) {
[16:03:12.973]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.973]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.973]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.973]             on.exit(options(oopts), add = TRUE)
[16:03:12.973]         }
[16:03:12.973]         {
[16:03:12.973]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.973]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.973]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.973]             })
[16:03:12.973]         }
[16:03:12.973]     }, args = future.call.arguments)
[16:03:12.973] }
[16:03:12.974] Tweak future expression to call with '...' arguments ... DONE
[16:03:12.974] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:12.974] 
[16:03:12.974] getGlobalsAndPackages() ... DONE
[16:03:12.974] run() for ‘Future’ ...
[16:03:12.975] - state: ‘created’
[16:03:12.975] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:12.975] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.975] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:12.975]   - Field: ‘label’
[16:03:12.975]   - Field: ‘local’
[16:03:12.975]   - Field: ‘owner’
[16:03:12.975]   - Field: ‘envir’
[16:03:12.976]   - Field: ‘packages’
[16:03:12.976]   - Field: ‘gc’
[16:03:12.976]   - Field: ‘conditions’
[16:03:12.976]   - Field: ‘expr’
[16:03:12.976]   - Field: ‘uuid’
[16:03:12.976]   - Field: ‘seed’
[16:03:12.976]   - Field: ‘version’
[16:03:12.976]   - Field: ‘result’
[16:03:12.976]   - Field: ‘asynchronous’
[16:03:12.976]   - Field: ‘calls’
[16:03:12.976]   - Field: ‘globals’
[16:03:12.977]   - Field: ‘stdout’
[16:03:12.977]   - Field: ‘earlySignal’
[16:03:12.977]   - Field: ‘lazy’
[16:03:12.977]   - Field: ‘state’
[16:03:12.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:12.977] - Launch lazy future ...
[16:03:12.977] Packages needed by the future expression (n = 0): <none>
[16:03:12.977] Packages needed by future strategies (n = 0): <none>
[16:03:12.978] {
[16:03:12.978]     {
[16:03:12.978]         {
[16:03:12.978]             ...future.startTime <- base::Sys.time()
[16:03:12.978]             {
[16:03:12.978]                 {
[16:03:12.978]                   {
[16:03:12.978]                     base::local({
[16:03:12.978]                       has_future <- base::requireNamespace("future", 
[16:03:12.978]                         quietly = TRUE)
[16:03:12.978]                       if (has_future) {
[16:03:12.978]                         ns <- base::getNamespace("future")
[16:03:12.978]                         version <- ns[[".package"]][["version"]]
[16:03:12.978]                         if (is.null(version)) 
[16:03:12.978]                           version <- utils::packageVersion("future")
[16:03:12.978]                       }
[16:03:12.978]                       else {
[16:03:12.978]                         version <- NULL
[16:03:12.978]                       }
[16:03:12.978]                       if (!has_future || version < "1.8.0") {
[16:03:12.978]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:12.978]                           "", base::R.version$version.string), 
[16:03:12.978]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:12.978]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:12.978]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:12.978]                             "release", "version")], collapse = " "), 
[16:03:12.978]                           hostname = base::Sys.info()[["nodename"]])
[16:03:12.978]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:12.978]                           info)
[16:03:12.978]                         info <- base::paste(info, collapse = "; ")
[16:03:12.978]                         if (!has_future) {
[16:03:12.978]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:12.978]                             info)
[16:03:12.978]                         }
[16:03:12.978]                         else {
[16:03:12.978]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:12.978]                             info, version)
[16:03:12.978]                         }
[16:03:12.978]                         base::stop(msg)
[16:03:12.978]                       }
[16:03:12.978]                     })
[16:03:12.978]                   }
[16:03:12.978]                   options(future.plan = NULL)
[16:03:12.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:12.978]                 }
[16:03:12.978]                 ...future.workdir <- getwd()
[16:03:12.978]             }
[16:03:12.978]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:12.978]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:12.978]         }
[16:03:12.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:12.978]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:12.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:12.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:12.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:12.978]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:12.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:12.978]             base::names(...future.oldOptions))
[16:03:12.978]     }
[16:03:12.978]     if (FALSE) {
[16:03:12.978]     }
[16:03:12.978]     else {
[16:03:12.978]         if (TRUE) {
[16:03:12.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:12.978]                 open = "w")
[16:03:12.978]         }
[16:03:12.978]         else {
[16:03:12.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:12.978]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:12.978]         }
[16:03:12.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:12.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:12.978]             base::sink(type = "output", split = FALSE)
[16:03:12.978]             base::close(...future.stdout)
[16:03:12.978]         }, add = TRUE)
[16:03:12.978]     }
[16:03:12.978]     ...future.frame <- base::sys.nframe()
[16:03:12.978]     ...future.conditions <- base::list()
[16:03:12.978]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:12.978]     if (FALSE) {
[16:03:12.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:12.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:12.978]     }
[16:03:12.978]     ...future.result <- base::tryCatch({
[16:03:12.978]         base::withCallingHandlers({
[16:03:12.978]             ...future.value <- base::withVisible(base::local({
[16:03:12.978]                 do.call(function(...) {
[16:03:12.978]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.978]                   if (!identical(...future.globals.maxSize.org, 
[16:03:12.978]                     ...future.globals.maxSize)) {
[16:03:12.978]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.978]                     on.exit(options(oopts), add = TRUE)
[16:03:12.978]                   }
[16:03:12.978]                   {
[16:03:12.978]                     lapply(seq_along(...future.elements_ii), 
[16:03:12.978]                       FUN = function(jj) {
[16:03:12.978]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.978]                         ...future.FUN(...future.X_jj, ...)
[16:03:12.978]                       })
[16:03:12.978]                   }
[16:03:12.978]                 }, args = future.call.arguments)
[16:03:12.978]             }))
[16:03:12.978]             future::FutureResult(value = ...future.value$value, 
[16:03:12.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.978]                   ...future.rng), globalenv = if (FALSE) 
[16:03:12.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:12.978]                     ...future.globalenv.names))
[16:03:12.978]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:12.978]         }, condition = base::local({
[16:03:12.978]             c <- base::c
[16:03:12.978]             inherits <- base::inherits
[16:03:12.978]             invokeRestart <- base::invokeRestart
[16:03:12.978]             length <- base::length
[16:03:12.978]             list <- base::list
[16:03:12.978]             seq.int <- base::seq.int
[16:03:12.978]             signalCondition <- base::signalCondition
[16:03:12.978]             sys.calls <- base::sys.calls
[16:03:12.978]             `[[` <- base::`[[`
[16:03:12.978]             `+` <- base::`+`
[16:03:12.978]             `<<-` <- base::`<<-`
[16:03:12.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:12.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:12.978]                   3L)]
[16:03:12.978]             }
[16:03:12.978]             function(cond) {
[16:03:12.978]                 is_error <- inherits(cond, "error")
[16:03:12.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:12.978]                   NULL)
[16:03:12.978]                 if (is_error) {
[16:03:12.978]                   sessionInformation <- function() {
[16:03:12.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:12.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:12.978]                       search = base::search(), system = base::Sys.info())
[16:03:12.978]                   }
[16:03:12.978]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:12.978]                     cond$call), session = sessionInformation(), 
[16:03:12.978]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:12.978]                   signalCondition(cond)
[16:03:12.978]                 }
[16:03:12.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:12.978]                 "immediateCondition"))) {
[16:03:12.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:12.978]                   ...future.conditions[[length(...future.conditions) + 
[16:03:12.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:12.978]                   if (TRUE && !signal) {
[16:03:12.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.978]                     {
[16:03:12.978]                       inherits <- base::inherits
[16:03:12.978]                       invokeRestart <- base::invokeRestart
[16:03:12.978]                       is.null <- base::is.null
[16:03:12.978]                       muffled <- FALSE
[16:03:12.978]                       if (inherits(cond, "message")) {
[16:03:12.978]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.978]                         if (muffled) 
[16:03:12.978]                           invokeRestart("muffleMessage")
[16:03:12.978]                       }
[16:03:12.978]                       else if (inherits(cond, "warning")) {
[16:03:12.978]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.978]                         if (muffled) 
[16:03:12.978]                           invokeRestart("muffleWarning")
[16:03:12.978]                       }
[16:03:12.978]                       else if (inherits(cond, "condition")) {
[16:03:12.978]                         if (!is.null(pattern)) {
[16:03:12.978]                           computeRestarts <- base::computeRestarts
[16:03:12.978]                           grepl <- base::grepl
[16:03:12.978]                           restarts <- computeRestarts(cond)
[16:03:12.978]                           for (restart in restarts) {
[16:03:12.978]                             name <- restart$name
[16:03:12.978]                             if (is.null(name)) 
[16:03:12.978]                               next
[16:03:12.978]                             if (!grepl(pattern, name)) 
[16:03:12.978]                               next
[16:03:12.978]                             invokeRestart(restart)
[16:03:12.978]                             muffled <- TRUE
[16:03:12.978]                             break
[16:03:12.978]                           }
[16:03:12.978]                         }
[16:03:12.978]                       }
[16:03:12.978]                       invisible(muffled)
[16:03:12.978]                     }
[16:03:12.978]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.978]                   }
[16:03:12.978]                 }
[16:03:12.978]                 else {
[16:03:12.978]                   if (TRUE) {
[16:03:12.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:12.978]                     {
[16:03:12.978]                       inherits <- base::inherits
[16:03:12.978]                       invokeRestart <- base::invokeRestart
[16:03:12.978]                       is.null <- base::is.null
[16:03:12.978]                       muffled <- FALSE
[16:03:12.978]                       if (inherits(cond, "message")) {
[16:03:12.978]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:12.978]                         if (muffled) 
[16:03:12.978]                           invokeRestart("muffleMessage")
[16:03:12.978]                       }
[16:03:12.978]                       else if (inherits(cond, "warning")) {
[16:03:12.978]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:12.978]                         if (muffled) 
[16:03:12.978]                           invokeRestart("muffleWarning")
[16:03:12.978]                       }
[16:03:12.978]                       else if (inherits(cond, "condition")) {
[16:03:12.978]                         if (!is.null(pattern)) {
[16:03:12.978]                           computeRestarts <- base::computeRestarts
[16:03:12.978]                           grepl <- base::grepl
[16:03:12.978]                           restarts <- computeRestarts(cond)
[16:03:12.978]                           for (restart in restarts) {
[16:03:12.978]                             name <- restart$name
[16:03:12.978]                             if (is.null(name)) 
[16:03:12.978]                               next
[16:03:12.978]                             if (!grepl(pattern, name)) 
[16:03:12.978]                               next
[16:03:12.978]                             invokeRestart(restart)
[16:03:12.978]                             muffled <- TRUE
[16:03:12.978]                             break
[16:03:12.978]                           }
[16:03:12.978]                         }
[16:03:12.978]                       }
[16:03:12.978]                       invisible(muffled)
[16:03:12.978]                     }
[16:03:12.978]                     muffleCondition(cond, pattern = "^muffle")
[16:03:12.978]                   }
[16:03:12.978]                 }
[16:03:12.978]             }
[16:03:12.978]         }))
[16:03:12.978]     }, error = function(ex) {
[16:03:12.978]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:12.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:12.978]                 ...future.rng), started = ...future.startTime, 
[16:03:12.978]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:12.978]             version = "1.8"), class = "FutureResult")
[16:03:12.978]     }, finally = {
[16:03:12.978]         if (!identical(...future.workdir, getwd())) 
[16:03:12.978]             setwd(...future.workdir)
[16:03:12.978]         {
[16:03:12.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:12.978]                 ...future.oldOptions$nwarnings <- NULL
[16:03:12.978]             }
[16:03:12.978]             base::options(...future.oldOptions)
[16:03:12.978]             if (.Platform$OS.type == "windows") {
[16:03:12.978]                 old_names <- names(...future.oldEnvVars)
[16:03:12.978]                 envs <- base::Sys.getenv()
[16:03:12.978]                 names <- names(envs)
[16:03:12.978]                 common <- intersect(names, old_names)
[16:03:12.978]                 added <- setdiff(names, old_names)
[16:03:12.978]                 removed <- setdiff(old_names, names)
[16:03:12.978]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:12.978]                   envs[common]]
[16:03:12.978]                 NAMES <- toupper(changed)
[16:03:12.978]                 args <- list()
[16:03:12.978]                 for (kk in seq_along(NAMES)) {
[16:03:12.978]                   name <- changed[[kk]]
[16:03:12.978]                   NAME <- NAMES[[kk]]
[16:03:12.978]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.978]                     next
[16:03:12.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.978]                 }
[16:03:12.978]                 NAMES <- toupper(added)
[16:03:12.978]                 for (kk in seq_along(NAMES)) {
[16:03:12.978]                   name <- added[[kk]]
[16:03:12.978]                   NAME <- NAMES[[kk]]
[16:03:12.978]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.978]                     next
[16:03:12.978]                   args[[name]] <- ""
[16:03:12.978]                 }
[16:03:12.978]                 NAMES <- toupper(removed)
[16:03:12.978]                 for (kk in seq_along(NAMES)) {
[16:03:12.978]                   name <- removed[[kk]]
[16:03:12.978]                   NAME <- NAMES[[kk]]
[16:03:12.978]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:12.978]                     next
[16:03:12.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:12.978]                 }
[16:03:12.978]                 if (length(args) > 0) 
[16:03:12.978]                   base::do.call(base::Sys.setenv, args = args)
[16:03:12.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:12.978]             }
[16:03:12.978]             else {
[16:03:12.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:12.978]             }
[16:03:12.978]             {
[16:03:12.978]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:12.978]                   0L) {
[16:03:12.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:12.978]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:12.978]                   base::options(opts)
[16:03:12.978]                 }
[16:03:12.978]                 {
[16:03:12.978]                   {
[16:03:12.978]                     NULL
[16:03:12.978]                     RNGkind("Mersenne-Twister")
[16:03:12.978]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:12.978]                       inherits = FALSE)
[16:03:12.978]                   }
[16:03:12.978]                   options(future.plan = NULL)
[16:03:12.978]                   if (is.na(NA_character_)) 
[16:03:12.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:12.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:12.978]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:12.978]                   {
[16:03:12.978]                     future <- SequentialFuture(..., envir = envir)
[16:03:12.978]                     if (!future$lazy) 
[16:03:12.978]                       future <- run(future)
[16:03:12.978]                     invisible(future)
[16:03:12.978]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:12.978]                 }
[16:03:12.978]             }
[16:03:12.978]         }
[16:03:12.978]     })
[16:03:12.978]     if (TRUE) {
[16:03:12.978]         base::sink(type = "output", split = FALSE)
[16:03:12.978]         if (TRUE) {
[16:03:12.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:12.978]         }
[16:03:12.978]         else {
[16:03:12.978]             ...future.result["stdout"] <- base::list(NULL)
[16:03:12.978]         }
[16:03:12.978]         base::close(...future.stdout)
[16:03:12.978]         ...future.stdout <- NULL
[16:03:12.978]     }
[16:03:12.978]     ...future.result$conditions <- ...future.conditions
[16:03:12.978]     ...future.result$finished <- base::Sys.time()
[16:03:12.978]     ...future.result
[16:03:12.978] }
[16:03:12.979] assign_globals() ...
[16:03:12.979] List of 5
[16:03:12.979]  $ ...future.FUN            :function (x, y)  
[16:03:12.979]  $ future.call.arguments    :List of 1
[16:03:12.979]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:12.979]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:12.979]  $ ...future.elements_ii    :List of 4
[16:03:12.979]   ..$ A: num 50
[16:03:12.979]   ..$ B: num 60
[16:03:12.979]   ..$ C: num 70
[16:03:12.979]   ..$ D: num 80
[16:03:12.979]  $ ...future.seeds_ii       : NULL
[16:03:12.979]  $ ...future.globals.maxSize: NULL
[16:03:12.979]  - attr(*, "where")=List of 5
[16:03:12.979]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:12.979]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:12.979]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:12.979]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:12.979]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:12.979]  - attr(*, "resolved")= logi FALSE
[16:03:12.979]  - attr(*, "total_size")= num 4264
[16:03:12.979]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:12.979]  - attr(*, "already-done")= logi TRUE
[16:03:12.985] - reassign environment for ‘...future.FUN’
[16:03:12.985] - copied ‘...future.FUN’ to environment
[16:03:12.985] - copied ‘future.call.arguments’ to environment
[16:03:12.985] - copied ‘...future.elements_ii’ to environment
[16:03:12.985] - copied ‘...future.seeds_ii’ to environment
[16:03:12.986] - copied ‘...future.globals.maxSize’ to environment
[16:03:12.986] assign_globals() ... done
[16:03:12.986] plan(): Setting new future strategy stack:
[16:03:12.986] List of future strategies:
[16:03:12.986] 1. sequential:
[16:03:12.986]    - args: function (..., envir = parent.frame())
[16:03:12.986]    - tweaked: FALSE
[16:03:12.986]    - call: NULL
[16:03:12.986] plan(): nbrOfWorkers() = 1
[16:03:12.987] plan(): Setting new future strategy stack:
[16:03:12.987] List of future strategies:
[16:03:12.987] 1. sequential:
[16:03:12.987]    - args: function (..., envir = parent.frame())
[16:03:12.987]    - tweaked: FALSE
[16:03:12.987]    - call: plan(strategy)
[16:03:12.988] plan(): nbrOfWorkers() = 1
[16:03:12.988] SequentialFuture started (and completed)
[16:03:12.988] - Launch lazy future ... done
[16:03:12.988] run() for ‘SequentialFuture’ ... done
[16:03:12.988] Created future:
[16:03:12.988] SequentialFuture:
[16:03:12.988] Label: ‘future_sapply-1’
[16:03:12.988] Expression:
[16:03:12.988] {
[16:03:12.988]     do.call(function(...) {
[16:03:12.988]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:12.988]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:12.988]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:12.988]             on.exit(options(oopts), add = TRUE)
[16:03:12.988]         }
[16:03:12.988]         {
[16:03:12.988]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:12.988]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:12.988]                 ...future.FUN(...future.X_jj, ...)
[16:03:12.988]             })
[16:03:12.988]         }
[16:03:12.988]     }, args = future.call.arguments)
[16:03:12.988] }
[16:03:12.988] Lazy evaluation: FALSE
[16:03:12.988] Asynchronous evaluation: FALSE
[16:03:12.988] Local evaluation: TRUE
[16:03:12.988] Environment: R_GlobalEnv
[16:03:12.988] Capture standard output: TRUE
[16:03:12.988] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:12.988] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:12.988] Packages: <none>
[16:03:12.988] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:12.988] Resolved: TRUE
[16:03:12.988] Value: 1.34 KiB of class ‘list’
[16:03:12.988] Early signaling: FALSE
[16:03:12.988] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:12.988] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:12.989] Chunk #1 of 1 ... DONE
[16:03:12.989] Launching 1 futures (chunks) ... DONE
[16:03:12.989] Resolving 1 futures (chunks) ...
[16:03:12.989] resolve() on list ...
[16:03:12.989]  recursive: 0
[16:03:12.990]  length: 1
[16:03:12.990] 
[16:03:12.990] resolved() for ‘SequentialFuture’ ...
[16:03:12.990] - state: ‘finished’
[16:03:12.990] - run: TRUE
[16:03:12.990] - result: ‘FutureResult’
[16:03:12.990] resolved() for ‘SequentialFuture’ ... done
[16:03:12.990] Future #1
[16:03:12.990] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:12.990] - nx: 1
[16:03:12.990] - relay: TRUE
[16:03:12.991] - stdout: TRUE
[16:03:12.991] - signal: TRUE
[16:03:12.991] - resignal: FALSE
[16:03:12.991] - force: TRUE
[16:03:12.991] - relayed: [n=1] FALSE
[16:03:12.991] - queued futures: [n=1] FALSE
[16:03:12.991]  - until=1
[16:03:12.991]  - relaying element #1
[16:03:12.991] - relayed: [n=1] TRUE
[16:03:12.991] - queued futures: [n=1] TRUE
[16:03:12.992] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:12.992]  length: 0 (resolved future 1)
[16:03:12.992] Relaying remaining futures
[16:03:12.992] signalConditionsASAP(NULL, pos=0) ...
[16:03:12.992] - nx: 1
[16:03:12.992] - relay: TRUE
[16:03:12.992] - stdout: TRUE
[16:03:12.992] - signal: TRUE
[16:03:12.992] - resignal: FALSE
[16:03:12.992] - force: TRUE
[16:03:12.992] - relayed: [n=1] TRUE
[16:03:12.992] - queued futures: [n=1] TRUE
 - flush all
[16:03:12.993] - relayed: [n=1] TRUE
[16:03:12.993] - queued futures: [n=1] TRUE
[16:03:12.993] signalConditionsASAP(NULL, pos=0) ... done
[16:03:12.994] resolve() on list ... DONE
[16:03:12.994]  - Number of value chunks collected: 1
[16:03:12.994] Resolving 1 futures (chunks) ... DONE
[16:03:12.994] Reducing values from 1 chunks ...
[16:03:12.994]  - Number of values collected after concatenation: 4
[16:03:12.995]  - Number of values expected: 4
[16:03:12.995] Reducing values from 1 chunks ... DONE
[16:03:12.995] future_lapply() ... DONE
[16:03:12.995] future_lapply() ...
[16:03:12.997] Number of chunks: 1
[16:03:12.997] getGlobalsAndPackagesXApply() ...
[16:03:12.997]  - future.globals: TRUE
[16:03:12.997] getGlobalsAndPackages() ...
[16:03:12.997] Searching for globals...
[16:03:13.001] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[16:03:13.001] Searching for globals ... DONE
[16:03:13.001] Resolving globals: FALSE
[16:03:13.002] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[16:03:13.002] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:13.002] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.002] - packages: [1] ‘future.apply’
[16:03:13.002] getGlobalsAndPackages() ... DONE
[16:03:13.003]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.003]  - needed namespaces: [n=1] ‘future.apply’
[16:03:13.003] Finding globals ... DONE
[16:03:13.003]  - use_args: TRUE
[16:03:13.003]  - Getting '...' globals ...
[16:03:13.003] resolve() on list ...
[16:03:13.003]  recursive: 0
[16:03:13.003]  length: 1
[16:03:13.004]  elements: ‘...’
[16:03:13.004]  length: 0 (resolved future 1)
[16:03:13.004] resolve() on list ... DONE
[16:03:13.004]    - '...' content: [n=1] ‘y’
[16:03:13.004] List of 1
[16:03:13.004]  $ ...:List of 1
[16:03:13.004]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:13.004]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.004]  - attr(*, "where")=List of 1
[16:03:13.004]   ..$ ...:<environment: 0x564e42b14df0> 
[16:03:13.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.004]  - attr(*, "resolved")= logi TRUE
[16:03:13.004]  - attr(*, "total_size")= num NA
[16:03:13.007]  - Getting '...' globals ... DONE
[16:03:13.007] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:13.007] List of 8
[16:03:13.007]  $ ...future.FUN:function (x, ...)  
[16:03:13.007]  $ x_FUN        :function (x, y)  
[16:03:13.007]  $ times        : int 15
[16:03:13.007]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.007]  $ stop_if_not  :function (...)  
[16:03:13.007]  $ dim          : int [1:2] 3 5
[16:03:13.007]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:13.007]  $ ...          :List of 1
[16:03:13.007]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:13.007]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.007]  - attr(*, "where")=List of 8
[16:03:13.007]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:13.007]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:13.007]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:13.007]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:13.007]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:13.007]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:13.007]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:13.007]   ..$ ...          :<environment: 0x564e42b14df0> 
[16:03:13.007]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.007]  - attr(*, "resolved")= logi FALSE
[16:03:13.007]  - attr(*, "total_size")= num 98600
[16:03:13.014] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:13.014] getGlobalsAndPackagesXApply() ... DONE
[16:03:13.014] Number of futures (= number of chunks): 1
[16:03:13.014] Launching 1 futures (chunks) ...
[16:03:13.014] Chunk #1 of 1 ...
[16:03:13.014]  - Finding globals in 'X' for chunk #1 ...
[16:03:13.014] getGlobalsAndPackages() ...
[16:03:13.015] Searching for globals...
[16:03:13.015] 
[16:03:13.015] Searching for globals ... DONE
[16:03:13.015] - globals: [0] <none>
[16:03:13.015] getGlobalsAndPackages() ... DONE
[16:03:13.015]    + additional globals found: [n=0] 
[16:03:13.015]    + additional namespaces needed: [n=0] 
[16:03:13.015]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:13.015]  - seeds: <none>
[16:03:13.016]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.016] getGlobalsAndPackages() ...
[16:03:13.016] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.016] Resolving globals: FALSE
[16:03:13.016] Tweak future expression to call with '...' arguments ...
[16:03:13.016] {
[16:03:13.016]     do.call(function(...) {
[16:03:13.016]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.016]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.016]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.016]             on.exit(options(oopts), add = TRUE)
[16:03:13.016]         }
[16:03:13.016]         {
[16:03:13.016]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.016]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.016]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.016]             })
[16:03:13.016]         }
[16:03:13.016]     }, args = future.call.arguments)
[16:03:13.016] }
[16:03:13.016] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.017] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.017] - packages: [1] ‘future.apply’
[16:03:13.017] getGlobalsAndPackages() ... DONE
[16:03:13.017] run() for ‘Future’ ...
[16:03:13.017] - state: ‘created’
[16:03:13.018] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:13.018] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:13.018] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:13.018]   - Field: ‘label’
[16:03:13.018]   - Field: ‘local’
[16:03:13.018]   - Field: ‘owner’
[16:03:13.018]   - Field: ‘envir’
[16:03:13.018]   - Field: ‘packages’
[16:03:13.018]   - Field: ‘gc’
[16:03:13.019]   - Field: ‘conditions’
[16:03:13.019]   - Field: ‘expr’
[16:03:13.019]   - Field: ‘uuid’
[16:03:13.019]   - Field: ‘seed’
[16:03:13.019]   - Field: ‘version’
[16:03:13.019]   - Field: ‘result’
[16:03:13.019]   - Field: ‘asynchronous’
[16:03:13.019]   - Field: ‘calls’
[16:03:13.019]   - Field: ‘globals’
[16:03:13.019]   - Field: ‘stdout’
[16:03:13.019]   - Field: ‘earlySignal’
[16:03:13.020]   - Field: ‘lazy’
[16:03:13.020]   - Field: ‘state’
[16:03:13.020] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:13.020] - Launch lazy future ...
[16:03:13.020] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.020] Packages needed by future strategies (n = 0): <none>
[16:03:13.021] {
[16:03:13.021]     {
[16:03:13.021]         {
[16:03:13.021]             ...future.startTime <- base::Sys.time()
[16:03:13.021]             {
[16:03:13.021]                 {
[16:03:13.021]                   {
[16:03:13.021]                     {
[16:03:13.021]                       base::local({
[16:03:13.021]                         has_future <- base::requireNamespace("future", 
[16:03:13.021]                           quietly = TRUE)
[16:03:13.021]                         if (has_future) {
[16:03:13.021]                           ns <- base::getNamespace("future")
[16:03:13.021]                           version <- ns[[".package"]][["version"]]
[16:03:13.021]                           if (is.null(version)) 
[16:03:13.021]                             version <- utils::packageVersion("future")
[16:03:13.021]                         }
[16:03:13.021]                         else {
[16:03:13.021]                           version <- NULL
[16:03:13.021]                         }
[16:03:13.021]                         if (!has_future || version < "1.8.0") {
[16:03:13.021]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.021]                             "", base::R.version$version.string), 
[16:03:13.021]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:13.021]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:13.021]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.021]                               "release", "version")], collapse = " "), 
[16:03:13.021]                             hostname = base::Sys.info()[["nodename"]])
[16:03:13.021]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.021]                             info)
[16:03:13.021]                           info <- base::paste(info, collapse = "; ")
[16:03:13.021]                           if (!has_future) {
[16:03:13.021]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.021]                               info)
[16:03:13.021]                           }
[16:03:13.021]                           else {
[16:03:13.021]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.021]                               info, version)
[16:03:13.021]                           }
[16:03:13.021]                           base::stop(msg)
[16:03:13.021]                         }
[16:03:13.021]                       })
[16:03:13.021]                     }
[16:03:13.021]                     base::local({
[16:03:13.021]                       for (pkg in "future.apply") {
[16:03:13.021]                         base::loadNamespace(pkg)
[16:03:13.021]                         base::library(pkg, character.only = TRUE)
[16:03:13.021]                       }
[16:03:13.021]                     })
[16:03:13.021]                   }
[16:03:13.021]                   options(future.plan = NULL)
[16:03:13.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.021]                 }
[16:03:13.021]                 ...future.workdir <- getwd()
[16:03:13.021]             }
[16:03:13.021]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.021]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.021]         }
[16:03:13.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.021]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:13.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.021]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.021]             base::names(...future.oldOptions))
[16:03:13.021]     }
[16:03:13.021]     if (FALSE) {
[16:03:13.021]     }
[16:03:13.021]     else {
[16:03:13.021]         if (TRUE) {
[16:03:13.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.021]                 open = "w")
[16:03:13.021]         }
[16:03:13.021]         else {
[16:03:13.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.021]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.021]         }
[16:03:13.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.021]             base::sink(type = "output", split = FALSE)
[16:03:13.021]             base::close(...future.stdout)
[16:03:13.021]         }, add = TRUE)
[16:03:13.021]     }
[16:03:13.021]     ...future.frame <- base::sys.nframe()
[16:03:13.021]     ...future.conditions <- base::list()
[16:03:13.021]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.021]     if (FALSE) {
[16:03:13.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.021]     }
[16:03:13.021]     ...future.result <- base::tryCatch({
[16:03:13.021]         base::withCallingHandlers({
[16:03:13.021]             ...future.value <- base::withVisible(base::local({
[16:03:13.021]                 do.call(function(...) {
[16:03:13.021]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.021]                   if (!identical(...future.globals.maxSize.org, 
[16:03:13.021]                     ...future.globals.maxSize)) {
[16:03:13.021]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.021]                     on.exit(options(oopts), add = TRUE)
[16:03:13.021]                   }
[16:03:13.021]                   {
[16:03:13.021]                     lapply(seq_along(...future.elements_ii), 
[16:03:13.021]                       FUN = function(jj) {
[16:03:13.021]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.021]                         ...future.FUN(...future.X_jj, ...)
[16:03:13.021]                       })
[16:03:13.021]                   }
[16:03:13.021]                 }, args = future.call.arguments)
[16:03:13.021]             }))
[16:03:13.021]             future::FutureResult(value = ...future.value$value, 
[16:03:13.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.021]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.021]                     ...future.globalenv.names))
[16:03:13.021]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.021]         }, condition = base::local({
[16:03:13.021]             c <- base::c
[16:03:13.021]             inherits <- base::inherits
[16:03:13.021]             invokeRestart <- base::invokeRestart
[16:03:13.021]             length <- base::length
[16:03:13.021]             list <- base::list
[16:03:13.021]             seq.int <- base::seq.int
[16:03:13.021]             signalCondition <- base::signalCondition
[16:03:13.021]             sys.calls <- base::sys.calls
[16:03:13.021]             `[[` <- base::`[[`
[16:03:13.021]             `+` <- base::`+`
[16:03:13.021]             `<<-` <- base::`<<-`
[16:03:13.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.021]                   3L)]
[16:03:13.021]             }
[16:03:13.021]             function(cond) {
[16:03:13.021]                 is_error <- inherits(cond, "error")
[16:03:13.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.021]                   NULL)
[16:03:13.021]                 if (is_error) {
[16:03:13.021]                   sessionInformation <- function() {
[16:03:13.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.021]                       search = base::search(), system = base::Sys.info())
[16:03:13.021]                   }
[16:03:13.021]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.021]                     cond$call), session = sessionInformation(), 
[16:03:13.021]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.021]                   signalCondition(cond)
[16:03:13.021]                 }
[16:03:13.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.021]                 "immediateCondition"))) {
[16:03:13.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.021]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.021]                   if (TRUE && !signal) {
[16:03:13.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.021]                     {
[16:03:13.021]                       inherits <- base::inherits
[16:03:13.021]                       invokeRestart <- base::invokeRestart
[16:03:13.021]                       is.null <- base::is.null
[16:03:13.021]                       muffled <- FALSE
[16:03:13.021]                       if (inherits(cond, "message")) {
[16:03:13.021]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.021]                         if (muffled) 
[16:03:13.021]                           invokeRestart("muffleMessage")
[16:03:13.021]                       }
[16:03:13.021]                       else if (inherits(cond, "warning")) {
[16:03:13.021]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.021]                         if (muffled) 
[16:03:13.021]                           invokeRestart("muffleWarning")
[16:03:13.021]                       }
[16:03:13.021]                       else if (inherits(cond, "condition")) {
[16:03:13.021]                         if (!is.null(pattern)) {
[16:03:13.021]                           computeRestarts <- base::computeRestarts
[16:03:13.021]                           grepl <- base::grepl
[16:03:13.021]                           restarts <- computeRestarts(cond)
[16:03:13.021]                           for (restart in restarts) {
[16:03:13.021]                             name <- restart$name
[16:03:13.021]                             if (is.null(name)) 
[16:03:13.021]                               next
[16:03:13.021]                             if (!grepl(pattern, name)) 
[16:03:13.021]                               next
[16:03:13.021]                             invokeRestart(restart)
[16:03:13.021]                             muffled <- TRUE
[16:03:13.021]                             break
[16:03:13.021]                           }
[16:03:13.021]                         }
[16:03:13.021]                       }
[16:03:13.021]                       invisible(muffled)
[16:03:13.021]                     }
[16:03:13.021]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.021]                   }
[16:03:13.021]                 }
[16:03:13.021]                 else {
[16:03:13.021]                   if (TRUE) {
[16:03:13.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.021]                     {
[16:03:13.021]                       inherits <- base::inherits
[16:03:13.021]                       invokeRestart <- base::invokeRestart
[16:03:13.021]                       is.null <- base::is.null
[16:03:13.021]                       muffled <- FALSE
[16:03:13.021]                       if (inherits(cond, "message")) {
[16:03:13.021]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.021]                         if (muffled) 
[16:03:13.021]                           invokeRestart("muffleMessage")
[16:03:13.021]                       }
[16:03:13.021]                       else if (inherits(cond, "warning")) {
[16:03:13.021]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.021]                         if (muffled) 
[16:03:13.021]                           invokeRestart("muffleWarning")
[16:03:13.021]                       }
[16:03:13.021]                       else if (inherits(cond, "condition")) {
[16:03:13.021]                         if (!is.null(pattern)) {
[16:03:13.021]                           computeRestarts <- base::computeRestarts
[16:03:13.021]                           grepl <- base::grepl
[16:03:13.021]                           restarts <- computeRestarts(cond)
[16:03:13.021]                           for (restart in restarts) {
[16:03:13.021]                             name <- restart$name
[16:03:13.021]                             if (is.null(name)) 
[16:03:13.021]                               next
[16:03:13.021]                             if (!grepl(pattern, name)) 
[16:03:13.021]                               next
[16:03:13.021]                             invokeRestart(restart)
[16:03:13.021]                             muffled <- TRUE
[16:03:13.021]                             break
[16:03:13.021]                           }
[16:03:13.021]                         }
[16:03:13.021]                       }
[16:03:13.021]                       invisible(muffled)
[16:03:13.021]                     }
[16:03:13.021]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.021]                   }
[16:03:13.021]                 }
[16:03:13.021]             }
[16:03:13.021]         }))
[16:03:13.021]     }, error = function(ex) {
[16:03:13.021]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.021]                 ...future.rng), started = ...future.startTime, 
[16:03:13.021]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.021]             version = "1.8"), class = "FutureResult")
[16:03:13.021]     }, finally = {
[16:03:13.021]         if (!identical(...future.workdir, getwd())) 
[16:03:13.021]             setwd(...future.workdir)
[16:03:13.021]         {
[16:03:13.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.021]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.021]             }
[16:03:13.021]             base::options(...future.oldOptions)
[16:03:13.021]             if (.Platform$OS.type == "windows") {
[16:03:13.021]                 old_names <- names(...future.oldEnvVars)
[16:03:13.021]                 envs <- base::Sys.getenv()
[16:03:13.021]                 names <- names(envs)
[16:03:13.021]                 common <- intersect(names, old_names)
[16:03:13.021]                 added <- setdiff(names, old_names)
[16:03:13.021]                 removed <- setdiff(old_names, names)
[16:03:13.021]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.021]                   envs[common]]
[16:03:13.021]                 NAMES <- toupper(changed)
[16:03:13.021]                 args <- list()
[16:03:13.021]                 for (kk in seq_along(NAMES)) {
[16:03:13.021]                   name <- changed[[kk]]
[16:03:13.021]                   NAME <- NAMES[[kk]]
[16:03:13.021]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.021]                     next
[16:03:13.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.021]                 }
[16:03:13.021]                 NAMES <- toupper(added)
[16:03:13.021]                 for (kk in seq_along(NAMES)) {
[16:03:13.021]                   name <- added[[kk]]
[16:03:13.021]                   NAME <- NAMES[[kk]]
[16:03:13.021]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.021]                     next
[16:03:13.021]                   args[[name]] <- ""
[16:03:13.021]                 }
[16:03:13.021]                 NAMES <- toupper(removed)
[16:03:13.021]                 for (kk in seq_along(NAMES)) {
[16:03:13.021]                   name <- removed[[kk]]
[16:03:13.021]                   NAME <- NAMES[[kk]]
[16:03:13.021]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.021]                     next
[16:03:13.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.021]                 }
[16:03:13.021]                 if (length(args) > 0) 
[16:03:13.021]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.021]             }
[16:03:13.021]             else {
[16:03:13.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.021]             }
[16:03:13.021]             {
[16:03:13.021]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.021]                   0L) {
[16:03:13.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.021]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.021]                   base::options(opts)
[16:03:13.021]                 }
[16:03:13.021]                 {
[16:03:13.021]                   {
[16:03:13.021]                     NULL
[16:03:13.021]                     RNGkind("Mersenne-Twister")
[16:03:13.021]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:13.021]                       inherits = FALSE)
[16:03:13.021]                   }
[16:03:13.021]                   options(future.plan = NULL)
[16:03:13.021]                   if (is.na(NA_character_)) 
[16:03:13.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.021]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:13.021]                   {
[16:03:13.021]                     future <- SequentialFuture(..., envir = envir)
[16:03:13.021]                     if (!future$lazy) 
[16:03:13.021]                       future <- run(future)
[16:03:13.021]                     invisible(future)
[16:03:13.021]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.021]                 }
[16:03:13.021]             }
[16:03:13.021]         }
[16:03:13.021]     })
[16:03:13.021]     if (TRUE) {
[16:03:13.021]         base::sink(type = "output", split = FALSE)
[16:03:13.021]         if (TRUE) {
[16:03:13.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.021]         }
[16:03:13.021]         else {
[16:03:13.021]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.021]         }
[16:03:13.021]         base::close(...future.stdout)
[16:03:13.021]         ...future.stdout <- NULL
[16:03:13.021]     }
[16:03:13.021]     ...future.result$conditions <- ...future.conditions
[16:03:13.021]     ...future.result$finished <- base::Sys.time()
[16:03:13.021]     ...future.result
[16:03:13.021] }
[16:03:13.022] assign_globals() ...
[16:03:13.022] List of 11
[16:03:13.022]  $ ...future.FUN            :function (x, ...)  
[16:03:13.022]  $ x_FUN                    :function (x, y)  
[16:03:13.022]  $ times                    : int 15
[16:03:13.022]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.022]  $ stop_if_not              :function (...)  
[16:03:13.022]  $ dim                      : int [1:2] 3 5
[16:03:13.022]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:13.022]  $ future.call.arguments    :List of 1
[16:03:13.022]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:13.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.022]  $ ...future.elements_ii    :List of 4
[16:03:13.022]   ..$ A: num 50
[16:03:13.022]   ..$ B: num 60
[16:03:13.022]   ..$ C: num 70
[16:03:13.022]   ..$ D: num 80
[16:03:13.022]  $ ...future.seeds_ii       : NULL
[16:03:13.022]  $ ...future.globals.maxSize: NULL
[16:03:13.022]  - attr(*, "where")=List of 11
[16:03:13.022]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.022]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.022]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.022]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.022]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.022]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.022]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.022]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.022]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.022]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.022]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.022]  - attr(*, "resolved")= logi FALSE
[16:03:13.022]  - attr(*, "total_size")= num 98600
[16:03:13.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.022]  - attr(*, "already-done")= logi TRUE
[16:03:13.031] - copied ‘...future.FUN’ to environment
[16:03:13.031] - reassign environment for ‘x_FUN’
[16:03:13.031] - copied ‘x_FUN’ to environment
[16:03:13.031] - copied ‘times’ to environment
[16:03:13.031] - copied ‘stopf’ to environment
[16:03:13.031] - copied ‘stop_if_not’ to environment
[16:03:13.031] - copied ‘dim’ to environment
[16:03:13.031] - copied ‘valid_types’ to environment
[16:03:13.032] - copied ‘future.call.arguments’ to environment
[16:03:13.032] - copied ‘...future.elements_ii’ to environment
[16:03:13.032] - copied ‘...future.seeds_ii’ to environment
[16:03:13.032] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.032] assign_globals() ... done
[16:03:13.032] plan(): Setting new future strategy stack:
[16:03:13.032] List of future strategies:
[16:03:13.032] 1. sequential:
[16:03:13.032]    - args: function (..., envir = parent.frame())
[16:03:13.032]    - tweaked: FALSE
[16:03:13.032]    - call: NULL
[16:03:13.033] plan(): nbrOfWorkers() = 1
[16:03:13.033] plan(): Setting new future strategy stack:
[16:03:13.034] List of future strategies:
[16:03:13.034] 1. sequential:
[16:03:13.034]    - args: function (..., envir = parent.frame())
[16:03:13.034]    - tweaked: FALSE
[16:03:13.034]    - call: plan(strategy)
[16:03:13.034] plan(): nbrOfWorkers() = 1
[16:03:13.034] SequentialFuture started (and completed)
[16:03:13.034] - Launch lazy future ... done
[16:03:13.036] run() for ‘SequentialFuture’ ... done
[16:03:13.036] Created future:
[16:03:13.036] SequentialFuture:
[16:03:13.036] Label: ‘future_vapply-1’
[16:03:13.036] Expression:
[16:03:13.036] {
[16:03:13.036]     do.call(function(...) {
[16:03:13.036]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.036]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.036]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.036]             on.exit(options(oopts), add = TRUE)
[16:03:13.036]         }
[16:03:13.036]         {
[16:03:13.036]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.036]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.036]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.036]             })
[16:03:13.036]         }
[16:03:13.036]     }, args = future.call.arguments)
[16:03:13.036] }
[16:03:13.036] Lazy evaluation: FALSE
[16:03:13.036] Asynchronous evaluation: FALSE
[16:03:13.036] Local evaluation: TRUE
[16:03:13.036] Environment: R_GlobalEnv
[16:03:13.036] Capture standard output: TRUE
[16:03:13.036] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.036] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.036] Packages: 1 packages (‘future.apply’)
[16:03:13.036] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.036] Resolved: TRUE
[16:03:13.036] Value: 1.34 KiB of class ‘list’
[16:03:13.036] Early signaling: FALSE
[16:03:13.036] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.036] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:13.037] Chunk #1 of 1 ... DONE
[16:03:13.037] Launching 1 futures (chunks) ... DONE
[16:03:13.037] Resolving 1 futures (chunks) ...
[16:03:13.037] resolve() on list ...
[16:03:13.037]  recursive: 0
[16:03:13.037]  length: 1
[16:03:13.038] 
[16:03:13.038] resolved() for ‘SequentialFuture’ ...
[16:03:13.038] - state: ‘finished’
[16:03:13.038] - run: TRUE
[16:03:13.038] - result: ‘FutureResult’
[16:03:13.038] resolved() for ‘SequentialFuture’ ... done
[16:03:13.038] Future #1
[16:03:13.038] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:13.038] - nx: 1
[16:03:13.038] - relay: TRUE
[16:03:13.038] - stdout: TRUE
[16:03:13.039] - signal: TRUE
[16:03:13.039] - resignal: FALSE
[16:03:13.039] - force: TRUE
[16:03:13.039] - relayed: [n=1] FALSE
[16:03:13.039] - queued futures: [n=1] FALSE
[16:03:13.039]  - until=1
[16:03:13.039]  - relaying element #1
[16:03:13.039] - relayed: [n=1] TRUE
[16:03:13.039] - queued futures: [n=1] TRUE
[16:03:13.039] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:13.040]  length: 0 (resolved future 1)
[16:03:13.040] Relaying remaining futures
[16:03:13.040] signalConditionsASAP(NULL, pos=0) ...
[16:03:13.040] - nx: 1
[16:03:13.040] - relay: TRUE
[16:03:13.040] - stdout: TRUE
[16:03:13.040] - signal: TRUE
[16:03:13.040] - resignal: FALSE
[16:03:13.040] - force: TRUE
[16:03:13.040] - relayed: [n=1] TRUE
[16:03:13.040] - queued futures: [n=1] TRUE
 - flush all
[16:03:13.041] - relayed: [n=1] TRUE
[16:03:13.041] - queued futures: [n=1] TRUE
[16:03:13.041] signalConditionsASAP(NULL, pos=0) ... done
[16:03:13.041] resolve() on list ... DONE
[16:03:13.041]  - Number of value chunks collected: 1
[16:03:13.041] Resolving 1 futures (chunks) ... DONE
[16:03:13.041] Reducing values from 1 chunks ...
[16:03:13.041]  - Number of values collected after concatenation: 4
[16:03:13.041]  - Number of values expected: 4
[16:03:13.041] Reducing values from 1 chunks ... DONE
[16:03:13.041] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[16:03:13.043] future_lapply() ...
[16:03:13.045] Number of chunks: 1
[16:03:13.045] getGlobalsAndPackagesXApply() ...
[16:03:13.045]  - future.globals: TRUE
[16:03:13.045] getGlobalsAndPackages() ...
[16:03:13.045] Searching for globals...
[16:03:13.048] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:13.048] Searching for globals ... DONE
[16:03:13.048] Resolving globals: FALSE
[16:03:13.049] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[16:03:13.049] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:13.050] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.050] - packages: [1] ‘future.apply’
[16:03:13.050] getGlobalsAndPackages() ... DONE
[16:03:13.050]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.050]  - needed namespaces: [n=1] ‘future.apply’
[16:03:13.050] Finding globals ... DONE
[16:03:13.050]  - use_args: TRUE
[16:03:13.050]  - Getting '...' globals ...
[16:03:13.051] resolve() on list ...
[16:03:13.051]  recursive: 0
[16:03:13.051]  length: 1
[16:03:13.051]  elements: ‘...’
[16:03:13.051]  length: 0 (resolved future 1)
[16:03:13.051] resolve() on list ... DONE
[16:03:13.051]    - '...' content: [n=0] 
[16:03:13.051] List of 1
[16:03:13.051]  $ ...: list()
[16:03:13.051]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.051]  - attr(*, "where")=List of 1
[16:03:13.051]   ..$ ...:<environment: 0x564e41524d18> 
[16:03:13.051]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.051]  - attr(*, "resolved")= logi TRUE
[16:03:13.051]  - attr(*, "total_size")= num NA
[16:03:13.054]  - Getting '...' globals ... DONE
[16:03:13.054] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:13.054] List of 8
[16:03:13.054]  $ ...future.FUN:function (x, ...)  
[16:03:13.054]  $ x_FUN        :function (x)  
[16:03:13.054]  $ times        : int 1
[16:03:13.054]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.054]  $ stop_if_not  :function (...)  
[16:03:13.054]  $ dim          : NULL
[16:03:13.054]  $ valid_types  : chr "logical"
[16:03:13.054]  $ ...          : list()
[16:03:13.054]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.054]  - attr(*, "where")=List of 8
[16:03:13.054]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:13.054]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:13.054]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:13.054]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:13.054]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:13.054]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:13.054]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:13.054]   ..$ ...          :<environment: 0x564e41524d18> 
[16:03:13.054]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.054]  - attr(*, "resolved")= logi FALSE
[16:03:13.054]  - attr(*, "total_size")= num 94200
[16:03:13.060] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:13.060] getGlobalsAndPackagesXApply() ... DONE
[16:03:13.061] Number of futures (= number of chunks): 1
[16:03:13.061] Launching 1 futures (chunks) ...
[16:03:13.061] Chunk #1 of 1 ...
[16:03:13.061]  - Finding globals in 'X' for chunk #1 ...
[16:03:13.061] getGlobalsAndPackages() ...
[16:03:13.061] Searching for globals...
[16:03:13.061] 
[16:03:13.061] Searching for globals ... DONE
[16:03:13.062] - globals: [0] <none>
[16:03:13.062] getGlobalsAndPackages() ... DONE
[16:03:13.062]    + additional globals found: [n=0] 
[16:03:13.062]    + additional namespaces needed: [n=0] 
[16:03:13.062]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:13.062]  - seeds: <none>
[16:03:13.062]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.062] getGlobalsAndPackages() ...
[16:03:13.062] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.062] Resolving globals: FALSE
[16:03:13.062] Tweak future expression to call with '...' arguments ...
[16:03:13.063] {
[16:03:13.063]     do.call(function(...) {
[16:03:13.063]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.063]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.063]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.063]             on.exit(options(oopts), add = TRUE)
[16:03:13.063]         }
[16:03:13.063]         {
[16:03:13.063]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.063]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.063]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.063]             })
[16:03:13.063]         }
[16:03:13.063]     }, args = future.call.arguments)
[16:03:13.063] }
[16:03:13.063] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.063] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.063] - packages: [1] ‘future.apply’
[16:03:13.064] getGlobalsAndPackages() ... DONE
[16:03:13.064] run() for ‘Future’ ...
[16:03:13.064] - state: ‘created’
[16:03:13.064] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:13.064] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:13.064] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:13.064]   - Field: ‘label’
[16:03:13.065]   - Field: ‘local’
[16:03:13.065]   - Field: ‘owner’
[16:03:13.065]   - Field: ‘envir’
[16:03:13.065]   - Field: ‘packages’
[16:03:13.065]   - Field: ‘gc’
[16:03:13.065]   - Field: ‘conditions’
[16:03:13.065]   - Field: ‘expr’
[16:03:13.065]   - Field: ‘uuid’
[16:03:13.065]   - Field: ‘seed’
[16:03:13.065]   - Field: ‘version’
[16:03:13.065]   - Field: ‘result’
[16:03:13.066]   - Field: ‘asynchronous’
[16:03:13.066]   - Field: ‘calls’
[16:03:13.066]   - Field: ‘globals’
[16:03:13.066]   - Field: ‘stdout’
[16:03:13.066]   - Field: ‘earlySignal’
[16:03:13.066]   - Field: ‘lazy’
[16:03:13.066]   - Field: ‘state’
[16:03:13.066] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:13.066] - Launch lazy future ...
[16:03:13.066] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.067] Packages needed by future strategies (n = 0): <none>
[16:03:13.067] {
[16:03:13.067]     {
[16:03:13.067]         {
[16:03:13.067]             ...future.startTime <- base::Sys.time()
[16:03:13.067]             {
[16:03:13.067]                 {
[16:03:13.067]                   {
[16:03:13.067]                     {
[16:03:13.067]                       base::local({
[16:03:13.067]                         has_future <- base::requireNamespace("future", 
[16:03:13.067]                           quietly = TRUE)
[16:03:13.067]                         if (has_future) {
[16:03:13.067]                           ns <- base::getNamespace("future")
[16:03:13.067]                           version <- ns[[".package"]][["version"]]
[16:03:13.067]                           if (is.null(version)) 
[16:03:13.067]                             version <- utils::packageVersion("future")
[16:03:13.067]                         }
[16:03:13.067]                         else {
[16:03:13.067]                           version <- NULL
[16:03:13.067]                         }
[16:03:13.067]                         if (!has_future || version < "1.8.0") {
[16:03:13.067]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.067]                             "", base::R.version$version.string), 
[16:03:13.067]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:13.067]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:13.067]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.067]                               "release", "version")], collapse = " "), 
[16:03:13.067]                             hostname = base::Sys.info()[["nodename"]])
[16:03:13.067]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.067]                             info)
[16:03:13.067]                           info <- base::paste(info, collapse = "; ")
[16:03:13.067]                           if (!has_future) {
[16:03:13.067]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.067]                               info)
[16:03:13.067]                           }
[16:03:13.067]                           else {
[16:03:13.067]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.067]                               info, version)
[16:03:13.067]                           }
[16:03:13.067]                           base::stop(msg)
[16:03:13.067]                         }
[16:03:13.067]                       })
[16:03:13.067]                     }
[16:03:13.067]                     base::local({
[16:03:13.067]                       for (pkg in "future.apply") {
[16:03:13.067]                         base::loadNamespace(pkg)
[16:03:13.067]                         base::library(pkg, character.only = TRUE)
[16:03:13.067]                       }
[16:03:13.067]                     })
[16:03:13.067]                   }
[16:03:13.067]                   options(future.plan = NULL)
[16:03:13.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.067]                 }
[16:03:13.067]                 ...future.workdir <- getwd()
[16:03:13.067]             }
[16:03:13.067]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.067]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.067]         }
[16:03:13.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:13.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.067]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.067]             base::names(...future.oldOptions))
[16:03:13.067]     }
[16:03:13.067]     if (FALSE) {
[16:03:13.067]     }
[16:03:13.067]     else {
[16:03:13.067]         if (TRUE) {
[16:03:13.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.067]                 open = "w")
[16:03:13.067]         }
[16:03:13.067]         else {
[16:03:13.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.067]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.067]         }
[16:03:13.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.067]             base::sink(type = "output", split = FALSE)
[16:03:13.067]             base::close(...future.stdout)
[16:03:13.067]         }, add = TRUE)
[16:03:13.067]     }
[16:03:13.067]     ...future.frame <- base::sys.nframe()
[16:03:13.067]     ...future.conditions <- base::list()
[16:03:13.067]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.067]     if (FALSE) {
[16:03:13.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.067]     }
[16:03:13.067]     ...future.result <- base::tryCatch({
[16:03:13.067]         base::withCallingHandlers({
[16:03:13.067]             ...future.value <- base::withVisible(base::local({
[16:03:13.067]                 do.call(function(...) {
[16:03:13.067]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.067]                   if (!identical(...future.globals.maxSize.org, 
[16:03:13.067]                     ...future.globals.maxSize)) {
[16:03:13.067]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.067]                     on.exit(options(oopts), add = TRUE)
[16:03:13.067]                   }
[16:03:13.067]                   {
[16:03:13.067]                     lapply(seq_along(...future.elements_ii), 
[16:03:13.067]                       FUN = function(jj) {
[16:03:13.067]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.067]                         ...future.FUN(...future.X_jj, ...)
[16:03:13.067]                       })
[16:03:13.067]                   }
[16:03:13.067]                 }, args = future.call.arguments)
[16:03:13.067]             }))
[16:03:13.067]             future::FutureResult(value = ...future.value$value, 
[16:03:13.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.067]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.067]                     ...future.globalenv.names))
[16:03:13.067]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.067]         }, condition = base::local({
[16:03:13.067]             c <- base::c
[16:03:13.067]             inherits <- base::inherits
[16:03:13.067]             invokeRestart <- base::invokeRestart
[16:03:13.067]             length <- base::length
[16:03:13.067]             list <- base::list
[16:03:13.067]             seq.int <- base::seq.int
[16:03:13.067]             signalCondition <- base::signalCondition
[16:03:13.067]             sys.calls <- base::sys.calls
[16:03:13.067]             `[[` <- base::`[[`
[16:03:13.067]             `+` <- base::`+`
[16:03:13.067]             `<<-` <- base::`<<-`
[16:03:13.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.067]                   3L)]
[16:03:13.067]             }
[16:03:13.067]             function(cond) {
[16:03:13.067]                 is_error <- inherits(cond, "error")
[16:03:13.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.067]                   NULL)
[16:03:13.067]                 if (is_error) {
[16:03:13.067]                   sessionInformation <- function() {
[16:03:13.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.067]                       search = base::search(), system = base::Sys.info())
[16:03:13.067]                   }
[16:03:13.067]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.067]                     cond$call), session = sessionInformation(), 
[16:03:13.067]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.067]                   signalCondition(cond)
[16:03:13.067]                 }
[16:03:13.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.067]                 "immediateCondition"))) {
[16:03:13.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.067]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.067]                   if (TRUE && !signal) {
[16:03:13.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.067]                     {
[16:03:13.067]                       inherits <- base::inherits
[16:03:13.067]                       invokeRestart <- base::invokeRestart
[16:03:13.067]                       is.null <- base::is.null
[16:03:13.067]                       muffled <- FALSE
[16:03:13.067]                       if (inherits(cond, "message")) {
[16:03:13.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.067]                         if (muffled) 
[16:03:13.067]                           invokeRestart("muffleMessage")
[16:03:13.067]                       }
[16:03:13.067]                       else if (inherits(cond, "warning")) {
[16:03:13.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.067]                         if (muffled) 
[16:03:13.067]                           invokeRestart("muffleWarning")
[16:03:13.067]                       }
[16:03:13.067]                       else if (inherits(cond, "condition")) {
[16:03:13.067]                         if (!is.null(pattern)) {
[16:03:13.067]                           computeRestarts <- base::computeRestarts
[16:03:13.067]                           grepl <- base::grepl
[16:03:13.067]                           restarts <- computeRestarts(cond)
[16:03:13.067]                           for (restart in restarts) {
[16:03:13.067]                             name <- restart$name
[16:03:13.067]                             if (is.null(name)) 
[16:03:13.067]                               next
[16:03:13.067]                             if (!grepl(pattern, name)) 
[16:03:13.067]                               next
[16:03:13.067]                             invokeRestart(restart)
[16:03:13.067]                             muffled <- TRUE
[16:03:13.067]                             break
[16:03:13.067]                           }
[16:03:13.067]                         }
[16:03:13.067]                       }
[16:03:13.067]                       invisible(muffled)
[16:03:13.067]                     }
[16:03:13.067]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.067]                   }
[16:03:13.067]                 }
[16:03:13.067]                 else {
[16:03:13.067]                   if (TRUE) {
[16:03:13.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.067]                     {
[16:03:13.067]                       inherits <- base::inherits
[16:03:13.067]                       invokeRestart <- base::invokeRestart
[16:03:13.067]                       is.null <- base::is.null
[16:03:13.067]                       muffled <- FALSE
[16:03:13.067]                       if (inherits(cond, "message")) {
[16:03:13.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.067]                         if (muffled) 
[16:03:13.067]                           invokeRestart("muffleMessage")
[16:03:13.067]                       }
[16:03:13.067]                       else if (inherits(cond, "warning")) {
[16:03:13.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.067]                         if (muffled) 
[16:03:13.067]                           invokeRestart("muffleWarning")
[16:03:13.067]                       }
[16:03:13.067]                       else if (inherits(cond, "condition")) {
[16:03:13.067]                         if (!is.null(pattern)) {
[16:03:13.067]                           computeRestarts <- base::computeRestarts
[16:03:13.067]                           grepl <- base::grepl
[16:03:13.067]                           restarts <- computeRestarts(cond)
[16:03:13.067]                           for (restart in restarts) {
[16:03:13.067]                             name <- restart$name
[16:03:13.067]                             if (is.null(name)) 
[16:03:13.067]                               next
[16:03:13.067]                             if (!grepl(pattern, name)) 
[16:03:13.067]                               next
[16:03:13.067]                             invokeRestart(restart)
[16:03:13.067]                             muffled <- TRUE
[16:03:13.067]                             break
[16:03:13.067]                           }
[16:03:13.067]                         }
[16:03:13.067]                       }
[16:03:13.067]                       invisible(muffled)
[16:03:13.067]                     }
[16:03:13.067]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.067]                   }
[16:03:13.067]                 }
[16:03:13.067]             }
[16:03:13.067]         }))
[16:03:13.067]     }, error = function(ex) {
[16:03:13.067]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.067]                 ...future.rng), started = ...future.startTime, 
[16:03:13.067]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.067]             version = "1.8"), class = "FutureResult")
[16:03:13.067]     }, finally = {
[16:03:13.067]         if (!identical(...future.workdir, getwd())) 
[16:03:13.067]             setwd(...future.workdir)
[16:03:13.067]         {
[16:03:13.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.067]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.067]             }
[16:03:13.067]             base::options(...future.oldOptions)
[16:03:13.067]             if (.Platform$OS.type == "windows") {
[16:03:13.067]                 old_names <- names(...future.oldEnvVars)
[16:03:13.067]                 envs <- base::Sys.getenv()
[16:03:13.067]                 names <- names(envs)
[16:03:13.067]                 common <- intersect(names, old_names)
[16:03:13.067]                 added <- setdiff(names, old_names)
[16:03:13.067]                 removed <- setdiff(old_names, names)
[16:03:13.067]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.067]                   envs[common]]
[16:03:13.067]                 NAMES <- toupper(changed)
[16:03:13.067]                 args <- list()
[16:03:13.067]                 for (kk in seq_along(NAMES)) {
[16:03:13.067]                   name <- changed[[kk]]
[16:03:13.067]                   NAME <- NAMES[[kk]]
[16:03:13.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.067]                     next
[16:03:13.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.067]                 }
[16:03:13.067]                 NAMES <- toupper(added)
[16:03:13.067]                 for (kk in seq_along(NAMES)) {
[16:03:13.067]                   name <- added[[kk]]
[16:03:13.067]                   NAME <- NAMES[[kk]]
[16:03:13.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.067]                     next
[16:03:13.067]                   args[[name]] <- ""
[16:03:13.067]                 }
[16:03:13.067]                 NAMES <- toupper(removed)
[16:03:13.067]                 for (kk in seq_along(NAMES)) {
[16:03:13.067]                   name <- removed[[kk]]
[16:03:13.067]                   NAME <- NAMES[[kk]]
[16:03:13.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.067]                     next
[16:03:13.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.067]                 }
[16:03:13.067]                 if (length(args) > 0) 
[16:03:13.067]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.067]             }
[16:03:13.067]             else {
[16:03:13.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.067]             }
[16:03:13.067]             {
[16:03:13.067]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.067]                   0L) {
[16:03:13.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.067]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.067]                   base::options(opts)
[16:03:13.067]                 }
[16:03:13.067]                 {
[16:03:13.067]                   {
[16:03:13.067]                     NULL
[16:03:13.067]                     RNGkind("Mersenne-Twister")
[16:03:13.067]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:13.067]                       inherits = FALSE)
[16:03:13.067]                   }
[16:03:13.067]                   options(future.plan = NULL)
[16:03:13.067]                   if (is.na(NA_character_)) 
[16:03:13.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.067]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:13.067]                   {
[16:03:13.067]                     future <- SequentialFuture(..., envir = envir)
[16:03:13.067]                     if (!future$lazy) 
[16:03:13.067]                       future <- run(future)
[16:03:13.067]                     invisible(future)
[16:03:13.067]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.067]                 }
[16:03:13.067]             }
[16:03:13.067]         }
[16:03:13.067]     })
[16:03:13.067]     if (TRUE) {
[16:03:13.067]         base::sink(type = "output", split = FALSE)
[16:03:13.067]         if (TRUE) {
[16:03:13.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.067]         }
[16:03:13.067]         else {
[16:03:13.067]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.067]         }
[16:03:13.067]         base::close(...future.stdout)
[16:03:13.067]         ...future.stdout <- NULL
[16:03:13.067]     }
[16:03:13.067]     ...future.result$conditions <- ...future.conditions
[16:03:13.067]     ...future.result$finished <- base::Sys.time()
[16:03:13.067]     ...future.result
[16:03:13.067] }
[16:03:13.069] assign_globals() ...
[16:03:13.069] List of 11
[16:03:13.069]  $ ...future.FUN            :function (x, ...)  
[16:03:13.069]  $ x_FUN                    :function (x)  
[16:03:13.069]  $ times                    : int 1
[16:03:13.069]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.069]  $ stop_if_not              :function (...)  
[16:03:13.069]  $ dim                      : NULL
[16:03:13.069]  $ valid_types              : chr "logical"
[16:03:13.069]  $ future.call.arguments    : list()
[16:03:13.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.069]  $ ...future.elements_ii    :List of 11
[16:03:13.069]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[16:03:13.069]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[16:03:13.069]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[16:03:13.069]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[16:03:13.069]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[16:03:13.069]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[16:03:13.069]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[16:03:13.069]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[16:03:13.069]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[16:03:13.069]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[16:03:13.069]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[16:03:13.069]  $ ...future.seeds_ii       : NULL
[16:03:13.069]  $ ...future.globals.maxSize: NULL
[16:03:13.069]  - attr(*, "where")=List of 11
[16:03:13.069]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.069]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.069]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.069]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.069]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.069]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.069]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.069]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.069]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.069]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.069]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.069]  - attr(*, "resolved")= logi FALSE
[16:03:13.069]  - attr(*, "total_size")= num 94200
[16:03:13.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.069]  - attr(*, "already-done")= logi TRUE
[16:03:13.080] - copied ‘...future.FUN’ to environment
[16:03:13.080] - copied ‘x_FUN’ to environment
[16:03:13.080] - copied ‘times’ to environment
[16:03:13.080] - copied ‘stopf’ to environment
[16:03:13.081] - copied ‘stop_if_not’ to environment
[16:03:13.081] - copied ‘dim’ to environment
[16:03:13.081] - copied ‘valid_types’ to environment
[16:03:13.081] - copied ‘future.call.arguments’ to environment
[16:03:13.081] - copied ‘...future.elements_ii’ to environment
[16:03:13.081] - copied ‘...future.seeds_ii’ to environment
[16:03:13.081] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.081] assign_globals() ... done
[16:03:13.082] plan(): Setting new future strategy stack:
[16:03:13.082] List of future strategies:
[16:03:13.082] 1. sequential:
[16:03:13.082]    - args: function (..., envir = parent.frame())
[16:03:13.082]    - tweaked: FALSE
[16:03:13.082]    - call: NULL
[16:03:13.082] plan(): nbrOfWorkers() = 1
[16:03:13.083] plan(): Setting new future strategy stack:
[16:03:13.083] List of future strategies:
[16:03:13.083] 1. sequential:
[16:03:13.083]    - args: function (..., envir = parent.frame())
[16:03:13.083]    - tweaked: FALSE
[16:03:13.083]    - call: plan(strategy)
[16:03:13.083] plan(): nbrOfWorkers() = 1
[16:03:13.083] SequentialFuture started (and completed)
[16:03:13.084] - Launch lazy future ... done
[16:03:13.084] run() for ‘SequentialFuture’ ... done
[16:03:13.084] Created future:
[16:03:13.084] SequentialFuture:
[16:03:13.084] Label: ‘future_vapply-1’
[16:03:13.084] Expression:
[16:03:13.084] {
[16:03:13.084]     do.call(function(...) {
[16:03:13.084]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.084]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.084]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.084]             on.exit(options(oopts), add = TRUE)
[16:03:13.084]         }
[16:03:13.084]         {
[16:03:13.084]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.084]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.084]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.084]             })
[16:03:13.084]         }
[16:03:13.084]     }, args = future.call.arguments)
[16:03:13.084] }
[16:03:13.084] Lazy evaluation: FALSE
[16:03:13.084] Asynchronous evaluation: FALSE
[16:03:13.084] Local evaluation: TRUE
[16:03:13.084] Environment: R_GlobalEnv
[16:03:13.084] Capture standard output: TRUE
[16:03:13.084] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.084] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.084] Packages: 1 packages (‘future.apply’)
[16:03:13.084] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.084] Resolved: TRUE
[16:03:13.084] Value: 616 bytes of class ‘list’
[16:03:13.084] Early signaling: FALSE
[16:03:13.084] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.084] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:13.085] Chunk #1 of 1 ... DONE
[16:03:13.085] Launching 1 futures (chunks) ... DONE
[16:03:13.085] Resolving 1 futures (chunks) ...
[16:03:13.085] resolve() on list ...
[16:03:13.085]  recursive: 0
[16:03:13.086]  length: 1
[16:03:13.086] 
[16:03:13.086] resolved() for ‘SequentialFuture’ ...
[16:03:13.086] - state: ‘finished’
[16:03:13.086] - run: TRUE
[16:03:13.086] - result: ‘FutureResult’
[16:03:13.086] resolved() for ‘SequentialFuture’ ... done
[16:03:13.086] Future #1
[16:03:13.086] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:13.086] - nx: 1
[16:03:13.087] - relay: TRUE
[16:03:13.087] - stdout: TRUE
[16:03:13.087] - signal: TRUE
[16:03:13.087] - resignal: FALSE
[16:03:13.087] - force: TRUE
[16:03:13.087] - relayed: [n=1] FALSE
[16:03:13.087] - queued futures: [n=1] FALSE
[16:03:13.087]  - until=1
[16:03:13.087]  - relaying element #1
[16:03:13.087] - relayed: [n=1] TRUE
[16:03:13.088] - queued futures: [n=1] TRUE
[16:03:13.088] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:13.088]  length: 0 (resolved future 1)
[16:03:13.088] Relaying remaining futures
[16:03:13.088] signalConditionsASAP(NULL, pos=0) ...
[16:03:13.088] - nx: 1
[16:03:13.088] - relay: TRUE
[16:03:13.088] - stdout: TRUE
[16:03:13.088] - signal: TRUE
[16:03:13.088] - resignal: FALSE
[16:03:13.088] - force: TRUE
[16:03:13.088] - relayed: [n=1] TRUE
[16:03:13.089] - queued futures: [n=1] TRUE
 - flush all
[16:03:13.089] - relayed: [n=1] TRUE
[16:03:13.089] - queued futures: [n=1] TRUE
[16:03:13.089] signalConditionsASAP(NULL, pos=0) ... done
[16:03:13.089] resolve() on list ... DONE
[16:03:13.089]  - Number of value chunks collected: 1
[16:03:13.089] Resolving 1 futures (chunks) ... DONE
[16:03:13.089] Reducing values from 1 chunks ...
[16:03:13.089]  - Number of values collected after concatenation: 11
[16:03:13.089]  - Number of values expected: 11
[16:03:13.090] Reducing values from 1 chunks ... DONE
[16:03:13.090] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[16:03:13.090] future_lapply() ...
[16:03:13.092] Number of chunks: 1
[16:03:13.092] getGlobalsAndPackagesXApply() ...
[16:03:13.092]  - future.globals: TRUE
[16:03:13.092] getGlobalsAndPackages() ...
[16:03:13.093] Searching for globals...
[16:03:13.095] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:13.096] Searching for globals ... DONE
[16:03:13.096] Resolving globals: FALSE
[16:03:13.098] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[16:03:13.098] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:13.099] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.099] - packages: [1] ‘future.apply’
[16:03:13.099] getGlobalsAndPackages() ... DONE
[16:03:13.099]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.099]  - needed namespaces: [n=1] ‘future.apply’
[16:03:13.099] Finding globals ... DONE
[16:03:13.099]  - use_args: TRUE
[16:03:13.099]  - Getting '...' globals ...
[16:03:13.100] resolve() on list ...
[16:03:13.100]  recursive: 0
[16:03:13.100]  length: 1
[16:03:13.100]  elements: ‘...’
[16:03:13.100]  length: 0 (resolved future 1)
[16:03:13.100] resolve() on list ... DONE
[16:03:13.100]    - '...' content: [n=0] 
[16:03:13.100] List of 1
[16:03:13.100]  $ ...: list()
[16:03:13.100]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.100]  - attr(*, "where")=List of 1
[16:03:13.100]   ..$ ...:<environment: 0x564e42ad18d0> 
[16:03:13.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.100]  - attr(*, "resolved")= logi TRUE
[16:03:13.100]  - attr(*, "total_size")= num NA
[16:03:13.103]  - Getting '...' globals ... DONE
[16:03:13.103] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:13.103] List of 8
[16:03:13.103]  $ ...future.FUN:function (x, ...)  
[16:03:13.103]  $ x_FUN        :function (x)  
[16:03:13.103]  $ times        : int 1
[16:03:13.103]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.103]  $ stop_if_not  :function (...)  
[16:03:13.103]  $ dim          : NULL
[16:03:13.103]  $ valid_types  : chr [1:2] "logical" "integer"
[16:03:13.103]  $ ...          : list()
[16:03:13.103]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.103]  - attr(*, "where")=List of 8
[16:03:13.103]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:13.103]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:13.103]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:13.103]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:13.103]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:13.103]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:13.103]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:13.103]   ..$ ...          :<environment: 0x564e42ad18d0> 
[16:03:13.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.103]  - attr(*, "resolved")= logi FALSE
[16:03:13.103]  - attr(*, "total_size")= num 94264
[16:03:13.108] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:13.108] getGlobalsAndPackagesXApply() ... DONE
[16:03:13.109] Number of futures (= number of chunks): 1
[16:03:13.109] Launching 1 futures (chunks) ...
[16:03:13.109] Chunk #1 of 1 ...
[16:03:13.109]  - Finding globals in 'X' for chunk #1 ...
[16:03:13.109] getGlobalsAndPackages() ...
[16:03:13.109] Searching for globals...
[16:03:13.109] 
[16:03:13.109] Searching for globals ... DONE
[16:03:13.109] - globals: [0] <none>
[16:03:13.110] getGlobalsAndPackages() ... DONE
[16:03:13.110]    + additional globals found: [n=0] 
[16:03:13.110]    + additional namespaces needed: [n=0] 
[16:03:13.110]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:13.110]  - seeds: <none>
[16:03:13.110]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.110] getGlobalsAndPackages() ...
[16:03:13.110] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.110] Resolving globals: FALSE
[16:03:13.110] Tweak future expression to call with '...' arguments ...
[16:03:13.110] {
[16:03:13.110]     do.call(function(...) {
[16:03:13.110]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.110]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.110]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.110]             on.exit(options(oopts), add = TRUE)
[16:03:13.110]         }
[16:03:13.110]         {
[16:03:13.110]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.110]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.110]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.110]             })
[16:03:13.110]         }
[16:03:13.110]     }, args = future.call.arguments)
[16:03:13.110] }
[16:03:13.111] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.111] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.111] - packages: [1] ‘future.apply’
[16:03:13.111] getGlobalsAndPackages() ... DONE
[16:03:13.112] run() for ‘Future’ ...
[16:03:13.112] - state: ‘created’
[16:03:13.112] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:13.112] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:13.112] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:13.112]   - Field: ‘label’
[16:03:13.113]   - Field: ‘local’
[16:03:13.113]   - Field: ‘owner’
[16:03:13.113]   - Field: ‘envir’
[16:03:13.113]   - Field: ‘packages’
[16:03:13.113]   - Field: ‘gc’
[16:03:13.113]   - Field: ‘conditions’
[16:03:13.113]   - Field: ‘expr’
[16:03:13.113]   - Field: ‘uuid’
[16:03:13.113]   - Field: ‘seed’
[16:03:13.113]   - Field: ‘version’
[16:03:13.113]   - Field: ‘result’
[16:03:13.114]   - Field: ‘asynchronous’
[16:03:13.114]   - Field: ‘calls’
[16:03:13.114]   - Field: ‘globals’
[16:03:13.114]   - Field: ‘stdout’
[16:03:13.114]   - Field: ‘earlySignal’
[16:03:13.114]   - Field: ‘lazy’
[16:03:13.114]   - Field: ‘state’
[16:03:13.114] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:13.114] - Launch lazy future ...
[16:03:13.114] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.115] Packages needed by future strategies (n = 0): <none>
[16:03:13.115] {
[16:03:13.115]     {
[16:03:13.115]         {
[16:03:13.115]             ...future.startTime <- base::Sys.time()
[16:03:13.115]             {
[16:03:13.115]                 {
[16:03:13.115]                   {
[16:03:13.115]                     {
[16:03:13.115]                       base::local({
[16:03:13.115]                         has_future <- base::requireNamespace("future", 
[16:03:13.115]                           quietly = TRUE)
[16:03:13.115]                         if (has_future) {
[16:03:13.115]                           ns <- base::getNamespace("future")
[16:03:13.115]                           version <- ns[[".package"]][["version"]]
[16:03:13.115]                           if (is.null(version)) 
[16:03:13.115]                             version <- utils::packageVersion("future")
[16:03:13.115]                         }
[16:03:13.115]                         else {
[16:03:13.115]                           version <- NULL
[16:03:13.115]                         }
[16:03:13.115]                         if (!has_future || version < "1.8.0") {
[16:03:13.115]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.115]                             "", base::R.version$version.string), 
[16:03:13.115]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:13.115]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:13.115]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.115]                               "release", "version")], collapse = " "), 
[16:03:13.115]                             hostname = base::Sys.info()[["nodename"]])
[16:03:13.115]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.115]                             info)
[16:03:13.115]                           info <- base::paste(info, collapse = "; ")
[16:03:13.115]                           if (!has_future) {
[16:03:13.115]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.115]                               info)
[16:03:13.115]                           }
[16:03:13.115]                           else {
[16:03:13.115]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.115]                               info, version)
[16:03:13.115]                           }
[16:03:13.115]                           base::stop(msg)
[16:03:13.115]                         }
[16:03:13.115]                       })
[16:03:13.115]                     }
[16:03:13.115]                     base::local({
[16:03:13.115]                       for (pkg in "future.apply") {
[16:03:13.115]                         base::loadNamespace(pkg)
[16:03:13.115]                         base::library(pkg, character.only = TRUE)
[16:03:13.115]                       }
[16:03:13.115]                     })
[16:03:13.115]                   }
[16:03:13.115]                   options(future.plan = NULL)
[16:03:13.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.115]                 }
[16:03:13.115]                 ...future.workdir <- getwd()
[16:03:13.115]             }
[16:03:13.115]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.115]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.115]         }
[16:03:13.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.115]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:13.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.115]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.115]             base::names(...future.oldOptions))
[16:03:13.115]     }
[16:03:13.115]     if (FALSE) {
[16:03:13.115]     }
[16:03:13.115]     else {
[16:03:13.115]         if (TRUE) {
[16:03:13.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.115]                 open = "w")
[16:03:13.115]         }
[16:03:13.115]         else {
[16:03:13.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.115]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.115]         }
[16:03:13.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.115]             base::sink(type = "output", split = FALSE)
[16:03:13.115]             base::close(...future.stdout)
[16:03:13.115]         }, add = TRUE)
[16:03:13.115]     }
[16:03:13.115]     ...future.frame <- base::sys.nframe()
[16:03:13.115]     ...future.conditions <- base::list()
[16:03:13.115]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.115]     if (FALSE) {
[16:03:13.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.115]     }
[16:03:13.115]     ...future.result <- base::tryCatch({
[16:03:13.115]         base::withCallingHandlers({
[16:03:13.115]             ...future.value <- base::withVisible(base::local({
[16:03:13.115]                 do.call(function(...) {
[16:03:13.115]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.115]                   if (!identical(...future.globals.maxSize.org, 
[16:03:13.115]                     ...future.globals.maxSize)) {
[16:03:13.115]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.115]                     on.exit(options(oopts), add = TRUE)
[16:03:13.115]                   }
[16:03:13.115]                   {
[16:03:13.115]                     lapply(seq_along(...future.elements_ii), 
[16:03:13.115]                       FUN = function(jj) {
[16:03:13.115]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.115]                         ...future.FUN(...future.X_jj, ...)
[16:03:13.115]                       })
[16:03:13.115]                   }
[16:03:13.115]                 }, args = future.call.arguments)
[16:03:13.115]             }))
[16:03:13.115]             future::FutureResult(value = ...future.value$value, 
[16:03:13.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.115]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.115]                     ...future.globalenv.names))
[16:03:13.115]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.115]         }, condition = base::local({
[16:03:13.115]             c <- base::c
[16:03:13.115]             inherits <- base::inherits
[16:03:13.115]             invokeRestart <- base::invokeRestart
[16:03:13.115]             length <- base::length
[16:03:13.115]             list <- base::list
[16:03:13.115]             seq.int <- base::seq.int
[16:03:13.115]             signalCondition <- base::signalCondition
[16:03:13.115]             sys.calls <- base::sys.calls
[16:03:13.115]             `[[` <- base::`[[`
[16:03:13.115]             `+` <- base::`+`
[16:03:13.115]             `<<-` <- base::`<<-`
[16:03:13.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.115]                   3L)]
[16:03:13.115]             }
[16:03:13.115]             function(cond) {
[16:03:13.115]                 is_error <- inherits(cond, "error")
[16:03:13.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.115]                   NULL)
[16:03:13.115]                 if (is_error) {
[16:03:13.115]                   sessionInformation <- function() {
[16:03:13.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.115]                       search = base::search(), system = base::Sys.info())
[16:03:13.115]                   }
[16:03:13.115]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.115]                     cond$call), session = sessionInformation(), 
[16:03:13.115]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.115]                   signalCondition(cond)
[16:03:13.115]                 }
[16:03:13.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.115]                 "immediateCondition"))) {
[16:03:13.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.115]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.115]                   if (TRUE && !signal) {
[16:03:13.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.115]                     {
[16:03:13.115]                       inherits <- base::inherits
[16:03:13.115]                       invokeRestart <- base::invokeRestart
[16:03:13.115]                       is.null <- base::is.null
[16:03:13.115]                       muffled <- FALSE
[16:03:13.115]                       if (inherits(cond, "message")) {
[16:03:13.115]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.115]                         if (muffled) 
[16:03:13.115]                           invokeRestart("muffleMessage")
[16:03:13.115]                       }
[16:03:13.115]                       else if (inherits(cond, "warning")) {
[16:03:13.115]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.115]                         if (muffled) 
[16:03:13.115]                           invokeRestart("muffleWarning")
[16:03:13.115]                       }
[16:03:13.115]                       else if (inherits(cond, "condition")) {
[16:03:13.115]                         if (!is.null(pattern)) {
[16:03:13.115]                           computeRestarts <- base::computeRestarts
[16:03:13.115]                           grepl <- base::grepl
[16:03:13.115]                           restarts <- computeRestarts(cond)
[16:03:13.115]                           for (restart in restarts) {
[16:03:13.115]                             name <- restart$name
[16:03:13.115]                             if (is.null(name)) 
[16:03:13.115]                               next
[16:03:13.115]                             if (!grepl(pattern, name)) 
[16:03:13.115]                               next
[16:03:13.115]                             invokeRestart(restart)
[16:03:13.115]                             muffled <- TRUE
[16:03:13.115]                             break
[16:03:13.115]                           }
[16:03:13.115]                         }
[16:03:13.115]                       }
[16:03:13.115]                       invisible(muffled)
[16:03:13.115]                     }
[16:03:13.115]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.115]                   }
[16:03:13.115]                 }
[16:03:13.115]                 else {
[16:03:13.115]                   if (TRUE) {
[16:03:13.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.115]                     {
[16:03:13.115]                       inherits <- base::inherits
[16:03:13.115]                       invokeRestart <- base::invokeRestart
[16:03:13.115]                       is.null <- base::is.null
[16:03:13.115]                       muffled <- FALSE
[16:03:13.115]                       if (inherits(cond, "message")) {
[16:03:13.115]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.115]                         if (muffled) 
[16:03:13.115]                           invokeRestart("muffleMessage")
[16:03:13.115]                       }
[16:03:13.115]                       else if (inherits(cond, "warning")) {
[16:03:13.115]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.115]                         if (muffled) 
[16:03:13.115]                           invokeRestart("muffleWarning")
[16:03:13.115]                       }
[16:03:13.115]                       else if (inherits(cond, "condition")) {
[16:03:13.115]                         if (!is.null(pattern)) {
[16:03:13.115]                           computeRestarts <- base::computeRestarts
[16:03:13.115]                           grepl <- base::grepl
[16:03:13.115]                           restarts <- computeRestarts(cond)
[16:03:13.115]                           for (restart in restarts) {
[16:03:13.115]                             name <- restart$name
[16:03:13.115]                             if (is.null(name)) 
[16:03:13.115]                               next
[16:03:13.115]                             if (!grepl(pattern, name)) 
[16:03:13.115]                               next
[16:03:13.115]                             invokeRestart(restart)
[16:03:13.115]                             muffled <- TRUE
[16:03:13.115]                             break
[16:03:13.115]                           }
[16:03:13.115]                         }
[16:03:13.115]                       }
[16:03:13.115]                       invisible(muffled)
[16:03:13.115]                     }
[16:03:13.115]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.115]                   }
[16:03:13.115]                 }
[16:03:13.115]             }
[16:03:13.115]         }))
[16:03:13.115]     }, error = function(ex) {
[16:03:13.115]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.115]                 ...future.rng), started = ...future.startTime, 
[16:03:13.115]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.115]             version = "1.8"), class = "FutureResult")
[16:03:13.115]     }, finally = {
[16:03:13.115]         if (!identical(...future.workdir, getwd())) 
[16:03:13.115]             setwd(...future.workdir)
[16:03:13.115]         {
[16:03:13.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.115]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.115]             }
[16:03:13.115]             base::options(...future.oldOptions)
[16:03:13.115]             if (.Platform$OS.type == "windows") {
[16:03:13.115]                 old_names <- names(...future.oldEnvVars)
[16:03:13.115]                 envs <- base::Sys.getenv()
[16:03:13.115]                 names <- names(envs)
[16:03:13.115]                 common <- intersect(names, old_names)
[16:03:13.115]                 added <- setdiff(names, old_names)
[16:03:13.115]                 removed <- setdiff(old_names, names)
[16:03:13.115]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.115]                   envs[common]]
[16:03:13.115]                 NAMES <- toupper(changed)
[16:03:13.115]                 args <- list()
[16:03:13.115]                 for (kk in seq_along(NAMES)) {
[16:03:13.115]                   name <- changed[[kk]]
[16:03:13.115]                   NAME <- NAMES[[kk]]
[16:03:13.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.115]                     next
[16:03:13.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.115]                 }
[16:03:13.115]                 NAMES <- toupper(added)
[16:03:13.115]                 for (kk in seq_along(NAMES)) {
[16:03:13.115]                   name <- added[[kk]]
[16:03:13.115]                   NAME <- NAMES[[kk]]
[16:03:13.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.115]                     next
[16:03:13.115]                   args[[name]] <- ""
[16:03:13.115]                 }
[16:03:13.115]                 NAMES <- toupper(removed)
[16:03:13.115]                 for (kk in seq_along(NAMES)) {
[16:03:13.115]                   name <- removed[[kk]]
[16:03:13.115]                   NAME <- NAMES[[kk]]
[16:03:13.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.115]                     next
[16:03:13.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.115]                 }
[16:03:13.115]                 if (length(args) > 0) 
[16:03:13.115]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.115]             }
[16:03:13.115]             else {
[16:03:13.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.115]             }
[16:03:13.115]             {
[16:03:13.115]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.115]                   0L) {
[16:03:13.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.115]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.115]                   base::options(opts)
[16:03:13.115]                 }
[16:03:13.115]                 {
[16:03:13.115]                   {
[16:03:13.115]                     NULL
[16:03:13.115]                     RNGkind("Mersenne-Twister")
[16:03:13.115]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:13.115]                       inherits = FALSE)
[16:03:13.115]                   }
[16:03:13.115]                   options(future.plan = NULL)
[16:03:13.115]                   if (is.na(NA_character_)) 
[16:03:13.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.115]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:13.115]                   {
[16:03:13.115]                     future <- SequentialFuture(..., envir = envir)
[16:03:13.115]                     if (!future$lazy) 
[16:03:13.115]                       future <- run(future)
[16:03:13.115]                     invisible(future)
[16:03:13.115]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.115]                 }
[16:03:13.115]             }
[16:03:13.115]         }
[16:03:13.115]     })
[16:03:13.115]     if (TRUE) {
[16:03:13.115]         base::sink(type = "output", split = FALSE)
[16:03:13.115]         if (TRUE) {
[16:03:13.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.115]         }
[16:03:13.115]         else {
[16:03:13.115]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.115]         }
[16:03:13.115]         base::close(...future.stdout)
[16:03:13.115]         ...future.stdout <- NULL
[16:03:13.115]     }
[16:03:13.115]     ...future.result$conditions <- ...future.conditions
[16:03:13.115]     ...future.result$finished <- base::Sys.time()
[16:03:13.115]     ...future.result
[16:03:13.115] }
[16:03:13.117] assign_globals() ...
[16:03:13.117] List of 11
[16:03:13.117]  $ ...future.FUN            :function (x, ...)  
[16:03:13.117]  $ x_FUN                    :function (x)  
[16:03:13.117]  $ times                    : int 1
[16:03:13.117]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.117]  $ stop_if_not              :function (...)  
[16:03:13.117]  $ dim                      : NULL
[16:03:13.117]  $ valid_types              : chr [1:2] "logical" "integer"
[16:03:13.117]  $ future.call.arguments    : list()
[16:03:13.117]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.117]  $ ...future.elements_ii    :List of 3
[16:03:13.117]   ..$ a: num 1
[16:03:13.117]   ..$ b: num 2
[16:03:13.117]   ..$ c: num 3
[16:03:13.117]  $ ...future.seeds_ii       : NULL
[16:03:13.117]  $ ...future.globals.maxSize: NULL
[16:03:13.117]  - attr(*, "where")=List of 11
[16:03:13.117]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.117]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.117]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.117]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.117]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.117]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.117]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.117]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.117]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.117]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.117]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.117]  - attr(*, "resolved")= logi FALSE
[16:03:13.117]  - attr(*, "total_size")= num 94264
[16:03:13.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.117]  - attr(*, "already-done")= logi TRUE
[16:03:13.126] - copied ‘...future.FUN’ to environment
[16:03:13.126] - copied ‘x_FUN’ to environment
[16:03:13.126] - copied ‘times’ to environment
[16:03:13.126] - copied ‘stopf’ to environment
[16:03:13.127] - copied ‘stop_if_not’ to environment
[16:03:13.127] - copied ‘dim’ to environment
[16:03:13.127] - copied ‘valid_types’ to environment
[16:03:13.127] - copied ‘future.call.arguments’ to environment
[16:03:13.127] - copied ‘...future.elements_ii’ to environment
[16:03:13.127] - copied ‘...future.seeds_ii’ to environment
[16:03:13.127] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.127] assign_globals() ... done
[16:03:13.128] plan(): Setting new future strategy stack:
[16:03:13.128] List of future strategies:
[16:03:13.128] 1. sequential:
[16:03:13.128]    - args: function (..., envir = parent.frame())
[16:03:13.128]    - tweaked: FALSE
[16:03:13.128]    - call: NULL
[16:03:13.128] plan(): nbrOfWorkers() = 1
[16:03:13.129] plan(): Setting new future strategy stack:
[16:03:13.129] List of future strategies:
[16:03:13.129] 1. sequential:
[16:03:13.129]    - args: function (..., envir = parent.frame())
[16:03:13.129]    - tweaked: FALSE
[16:03:13.129]    - call: plan(strategy)
[16:03:13.129] plan(): nbrOfWorkers() = 1
[16:03:13.129] SequentialFuture started (and completed)
[16:03:13.129] - Launch lazy future ... done
[16:03:13.129] run() for ‘SequentialFuture’ ... done
[16:03:13.130] Created future:
[16:03:13.130] SequentialFuture:
[16:03:13.130] Label: ‘future_vapply-1’
[16:03:13.130] Expression:
[16:03:13.130] {
[16:03:13.130]     do.call(function(...) {
[16:03:13.130]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.130]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.130]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.130]             on.exit(options(oopts), add = TRUE)
[16:03:13.130]         }
[16:03:13.130]         {
[16:03:13.130]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.130]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.130]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.130]             })
[16:03:13.130]         }
[16:03:13.130]     }, args = future.call.arguments)
[16:03:13.130] }
[16:03:13.130] Lazy evaluation: FALSE
[16:03:13.130] Asynchronous evaluation: FALSE
[16:03:13.130] Local evaluation: TRUE
[16:03:13.130] Environment: R_GlobalEnv
[16:03:13.130] Capture standard output: TRUE
[16:03:13.130] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.130] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.130] Packages: 1 packages (‘future.apply’)
[16:03:13.130] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.130] Resolved: TRUE
[16:03:13.130] Value: 168 bytes of class ‘list’
[16:03:13.130] Early signaling: FALSE
[16:03:13.130] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.130] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:13.131] Chunk #1 of 1 ... DONE
[16:03:13.131] Launching 1 futures (chunks) ... DONE
[16:03:13.131] Resolving 1 futures (chunks) ...
[16:03:13.131] resolve() on list ...
[16:03:13.131]  recursive: 0
[16:03:13.131]  length: 1
[16:03:13.131] 
[16:03:13.131] resolved() for ‘SequentialFuture’ ...
[16:03:13.131] - state: ‘finished’
[16:03:13.132] - run: TRUE
[16:03:13.132] - result: ‘FutureResult’
[16:03:13.132] resolved() for ‘SequentialFuture’ ... done
[16:03:13.132] Future #1
[16:03:13.132] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:13.132] - nx: 1
[16:03:13.132] - relay: TRUE
[16:03:13.132] - stdout: TRUE
[16:03:13.132] - signal: TRUE
[16:03:13.132] - resignal: FALSE
[16:03:13.132] - force: TRUE
[16:03:13.133] - relayed: [n=1] FALSE
[16:03:13.133] - queued futures: [n=1] FALSE
[16:03:13.133]  - until=1
[16:03:13.133]  - relaying element #1
[16:03:13.133] - relayed: [n=1] TRUE
[16:03:13.133] - queued futures: [n=1] TRUE
[16:03:13.133] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:13.133]  length: 0 (resolved future 1)
[16:03:13.133] Relaying remaining futures
[16:03:13.133] signalConditionsASAP(NULL, pos=0) ...
[16:03:13.134] - nx: 1
[16:03:13.134] - relay: TRUE
[16:03:13.134] - stdout: TRUE
[16:03:13.134] - signal: TRUE
[16:03:13.134] - resignal: FALSE
[16:03:13.134] - force: TRUE
[16:03:13.134] - relayed: [n=1] TRUE
[16:03:13.134] - queued futures: [n=1] TRUE
 - flush all
[16:03:13.134] - relayed: [n=1] TRUE
[16:03:13.134] - queued futures: [n=1] TRUE
[16:03:13.134] signalConditionsASAP(NULL, pos=0) ... done
[16:03:13.134] resolve() on list ... DONE
[16:03:13.135]  - Number of value chunks collected: 1
[16:03:13.135] Resolving 1 futures (chunks) ... DONE
[16:03:13.135] Reducing values from 1 chunks ...
[16:03:13.135]  - Number of values collected after concatenation: 3
[16:03:13.135]  - Number of values expected: 3
[16:03:13.135] Reducing values from 1 chunks ... DONE
[16:03:13.135] future_lapply() ... DONE
- exceptions ...
[16:03:13.135] future_lapply() ...
[16:03:13.137] Number of chunks: 1
[16:03:13.137] getGlobalsAndPackagesXApply() ...
[16:03:13.137]  - future.globals: TRUE
[16:03:13.137] getGlobalsAndPackages() ...
[16:03:13.137] Searching for globals...
[16:03:13.142] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:13.142] Searching for globals ... DONE
[16:03:13.142] Resolving globals: FALSE
[16:03:13.143] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[16:03:13.143] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:13.143] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.144] - packages: [1] ‘future.apply’
[16:03:13.144] getGlobalsAndPackages() ... DONE
[16:03:13.144]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.144]  - needed namespaces: [n=1] ‘future.apply’
[16:03:13.144] Finding globals ... DONE
[16:03:13.144]  - use_args: TRUE
[16:03:13.144]  - Getting '...' globals ...
[16:03:13.144] resolve() on list ...
[16:03:13.145]  recursive: 0
[16:03:13.145]  length: 1
[16:03:13.145]  elements: ‘...’
[16:03:13.145]  length: 0 (resolved future 1)
[16:03:13.145] resolve() on list ... DONE
[16:03:13.145]    - '...' content: [n=0] 
[16:03:13.145] List of 1
[16:03:13.145]  $ ...: list()
[16:03:13.145]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.145]  - attr(*, "where")=List of 1
[16:03:13.145]   ..$ ...:<environment: 0x564e42d96760> 
[16:03:13.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.145]  - attr(*, "resolved")= logi TRUE
[16:03:13.145]  - attr(*, "total_size")= num NA
[16:03:13.147]  - Getting '...' globals ... DONE
[16:03:13.148] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:13.148] List of 8
[16:03:13.148]  $ ...future.FUN:function (x, ...)  
[16:03:13.148]  $ x_FUN        :function (x)  
[16:03:13.148]  $ times        : int 2
[16:03:13.148]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.148]  $ stop_if_not  :function (...)  
[16:03:13.148]  $ dim          : NULL
[16:03:13.148]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:13.148]  $ ...          : list()
[16:03:13.148]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.148]  - attr(*, "where")=List of 8
[16:03:13.148]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:13.148]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:13.148]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:13.148]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:13.148]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:13.148]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:13.148]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:13.148]   ..$ ...          :<environment: 0x564e42d96760> 
[16:03:13.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.148]  - attr(*, "resolved")= logi FALSE
[16:03:13.148]  - attr(*, "total_size")= num 95128
[16:03:13.153] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:13.153] getGlobalsAndPackagesXApply() ... DONE
[16:03:13.153] Number of futures (= number of chunks): 1
[16:03:13.153] Launching 1 futures (chunks) ...
[16:03:13.153] Chunk #1 of 1 ...
[16:03:13.153]  - Finding globals in 'X' for chunk #1 ...
[16:03:13.153] getGlobalsAndPackages() ...
[16:03:13.154] Searching for globals...
[16:03:13.154] 
[16:03:13.154] Searching for globals ... DONE
[16:03:13.154] - globals: [0] <none>
[16:03:13.154] getGlobalsAndPackages() ... DONE
[16:03:13.154]    + additional globals found: [n=0] 
[16:03:13.154]    + additional namespaces needed: [n=0] 
[16:03:13.154]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:13.154]  - seeds: <none>
[16:03:13.154]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.155] getGlobalsAndPackages() ...
[16:03:13.155] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.155] Resolving globals: FALSE
[16:03:13.155] Tweak future expression to call with '...' arguments ...
[16:03:13.155] {
[16:03:13.155]     do.call(function(...) {
[16:03:13.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.155]             on.exit(options(oopts), add = TRUE)
[16:03:13.155]         }
[16:03:13.155]         {
[16:03:13.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.155]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.155]             })
[16:03:13.155]         }
[16:03:13.155]     }, args = future.call.arguments)
[16:03:13.155] }
[16:03:13.155] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.156] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.156] - packages: [1] ‘future.apply’
[16:03:13.156] getGlobalsAndPackages() ... DONE
[16:03:13.156] run() for ‘Future’ ...
[16:03:13.156] - state: ‘created’
[16:03:13.156] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:13.158] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:13.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:13.158]   - Field: ‘label’
[16:03:13.158]   - Field: ‘local’
[16:03:13.158]   - Field: ‘owner’
[16:03:13.158]   - Field: ‘envir’
[16:03:13.158]   - Field: ‘packages’
[16:03:13.158]   - Field: ‘gc’
[16:03:13.159]   - Field: ‘conditions’
[16:03:13.159]   - Field: ‘expr’
[16:03:13.159]   - Field: ‘uuid’
[16:03:13.159]   - Field: ‘seed’
[16:03:13.159]   - Field: ‘version’
[16:03:13.159]   - Field: ‘result’
[16:03:13.159]   - Field: ‘asynchronous’
[16:03:13.159]   - Field: ‘calls’
[16:03:13.159]   - Field: ‘globals’
[16:03:13.159]   - Field: ‘stdout’
[16:03:13.160]   - Field: ‘earlySignal’
[16:03:13.160]   - Field: ‘lazy’
[16:03:13.160]   - Field: ‘state’
[16:03:13.160] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:13.160] - Launch lazy future ...
[16:03:13.160] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.160] Packages needed by future strategies (n = 0): <none>
[16:03:13.161] {
[16:03:13.161]     {
[16:03:13.161]         {
[16:03:13.161]             ...future.startTime <- base::Sys.time()
[16:03:13.161]             {
[16:03:13.161]                 {
[16:03:13.161]                   {
[16:03:13.161]                     {
[16:03:13.161]                       base::local({
[16:03:13.161]                         has_future <- base::requireNamespace("future", 
[16:03:13.161]                           quietly = TRUE)
[16:03:13.161]                         if (has_future) {
[16:03:13.161]                           ns <- base::getNamespace("future")
[16:03:13.161]                           version <- ns[[".package"]][["version"]]
[16:03:13.161]                           if (is.null(version)) 
[16:03:13.161]                             version <- utils::packageVersion("future")
[16:03:13.161]                         }
[16:03:13.161]                         else {
[16:03:13.161]                           version <- NULL
[16:03:13.161]                         }
[16:03:13.161]                         if (!has_future || version < "1.8.0") {
[16:03:13.161]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.161]                             "", base::R.version$version.string), 
[16:03:13.161]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:13.161]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:13.161]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.161]                               "release", "version")], collapse = " "), 
[16:03:13.161]                             hostname = base::Sys.info()[["nodename"]])
[16:03:13.161]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.161]                             info)
[16:03:13.161]                           info <- base::paste(info, collapse = "; ")
[16:03:13.161]                           if (!has_future) {
[16:03:13.161]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.161]                               info)
[16:03:13.161]                           }
[16:03:13.161]                           else {
[16:03:13.161]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.161]                               info, version)
[16:03:13.161]                           }
[16:03:13.161]                           base::stop(msg)
[16:03:13.161]                         }
[16:03:13.161]                       })
[16:03:13.161]                     }
[16:03:13.161]                     base::local({
[16:03:13.161]                       for (pkg in "future.apply") {
[16:03:13.161]                         base::loadNamespace(pkg)
[16:03:13.161]                         base::library(pkg, character.only = TRUE)
[16:03:13.161]                       }
[16:03:13.161]                     })
[16:03:13.161]                   }
[16:03:13.161]                   options(future.plan = NULL)
[16:03:13.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.161]                 }
[16:03:13.161]                 ...future.workdir <- getwd()
[16:03:13.161]             }
[16:03:13.161]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.161]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.161]         }
[16:03:13.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.161]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:13.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.161]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.161]             base::names(...future.oldOptions))
[16:03:13.161]     }
[16:03:13.161]     if (FALSE) {
[16:03:13.161]     }
[16:03:13.161]     else {
[16:03:13.161]         if (TRUE) {
[16:03:13.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.161]                 open = "w")
[16:03:13.161]         }
[16:03:13.161]         else {
[16:03:13.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.161]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.161]         }
[16:03:13.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.161]             base::sink(type = "output", split = FALSE)
[16:03:13.161]             base::close(...future.stdout)
[16:03:13.161]         }, add = TRUE)
[16:03:13.161]     }
[16:03:13.161]     ...future.frame <- base::sys.nframe()
[16:03:13.161]     ...future.conditions <- base::list()
[16:03:13.161]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.161]     if (FALSE) {
[16:03:13.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.161]     }
[16:03:13.161]     ...future.result <- base::tryCatch({
[16:03:13.161]         base::withCallingHandlers({
[16:03:13.161]             ...future.value <- base::withVisible(base::local({
[16:03:13.161]                 do.call(function(...) {
[16:03:13.161]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.161]                   if (!identical(...future.globals.maxSize.org, 
[16:03:13.161]                     ...future.globals.maxSize)) {
[16:03:13.161]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.161]                     on.exit(options(oopts), add = TRUE)
[16:03:13.161]                   }
[16:03:13.161]                   {
[16:03:13.161]                     lapply(seq_along(...future.elements_ii), 
[16:03:13.161]                       FUN = function(jj) {
[16:03:13.161]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.161]                         ...future.FUN(...future.X_jj, ...)
[16:03:13.161]                       })
[16:03:13.161]                   }
[16:03:13.161]                 }, args = future.call.arguments)
[16:03:13.161]             }))
[16:03:13.161]             future::FutureResult(value = ...future.value$value, 
[16:03:13.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.161]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.161]                     ...future.globalenv.names))
[16:03:13.161]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.161]         }, condition = base::local({
[16:03:13.161]             c <- base::c
[16:03:13.161]             inherits <- base::inherits
[16:03:13.161]             invokeRestart <- base::invokeRestart
[16:03:13.161]             length <- base::length
[16:03:13.161]             list <- base::list
[16:03:13.161]             seq.int <- base::seq.int
[16:03:13.161]             signalCondition <- base::signalCondition
[16:03:13.161]             sys.calls <- base::sys.calls
[16:03:13.161]             `[[` <- base::`[[`
[16:03:13.161]             `+` <- base::`+`
[16:03:13.161]             `<<-` <- base::`<<-`
[16:03:13.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.161]                   3L)]
[16:03:13.161]             }
[16:03:13.161]             function(cond) {
[16:03:13.161]                 is_error <- inherits(cond, "error")
[16:03:13.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.161]                   NULL)
[16:03:13.161]                 if (is_error) {
[16:03:13.161]                   sessionInformation <- function() {
[16:03:13.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.161]                       search = base::search(), system = base::Sys.info())
[16:03:13.161]                   }
[16:03:13.161]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.161]                     cond$call), session = sessionInformation(), 
[16:03:13.161]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.161]                   signalCondition(cond)
[16:03:13.161]                 }
[16:03:13.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.161]                 "immediateCondition"))) {
[16:03:13.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.161]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.161]                   if (TRUE && !signal) {
[16:03:13.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.161]                     {
[16:03:13.161]                       inherits <- base::inherits
[16:03:13.161]                       invokeRestart <- base::invokeRestart
[16:03:13.161]                       is.null <- base::is.null
[16:03:13.161]                       muffled <- FALSE
[16:03:13.161]                       if (inherits(cond, "message")) {
[16:03:13.161]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.161]                         if (muffled) 
[16:03:13.161]                           invokeRestart("muffleMessage")
[16:03:13.161]                       }
[16:03:13.161]                       else if (inherits(cond, "warning")) {
[16:03:13.161]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.161]                         if (muffled) 
[16:03:13.161]                           invokeRestart("muffleWarning")
[16:03:13.161]                       }
[16:03:13.161]                       else if (inherits(cond, "condition")) {
[16:03:13.161]                         if (!is.null(pattern)) {
[16:03:13.161]                           computeRestarts <- base::computeRestarts
[16:03:13.161]                           grepl <- base::grepl
[16:03:13.161]                           restarts <- computeRestarts(cond)
[16:03:13.161]                           for (restart in restarts) {
[16:03:13.161]                             name <- restart$name
[16:03:13.161]                             if (is.null(name)) 
[16:03:13.161]                               next
[16:03:13.161]                             if (!grepl(pattern, name)) 
[16:03:13.161]                               next
[16:03:13.161]                             invokeRestart(restart)
[16:03:13.161]                             muffled <- TRUE
[16:03:13.161]                             break
[16:03:13.161]                           }
[16:03:13.161]                         }
[16:03:13.161]                       }
[16:03:13.161]                       invisible(muffled)
[16:03:13.161]                     }
[16:03:13.161]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.161]                   }
[16:03:13.161]                 }
[16:03:13.161]                 else {
[16:03:13.161]                   if (TRUE) {
[16:03:13.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.161]                     {
[16:03:13.161]                       inherits <- base::inherits
[16:03:13.161]                       invokeRestart <- base::invokeRestart
[16:03:13.161]                       is.null <- base::is.null
[16:03:13.161]                       muffled <- FALSE
[16:03:13.161]                       if (inherits(cond, "message")) {
[16:03:13.161]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.161]                         if (muffled) 
[16:03:13.161]                           invokeRestart("muffleMessage")
[16:03:13.161]                       }
[16:03:13.161]                       else if (inherits(cond, "warning")) {
[16:03:13.161]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.161]                         if (muffled) 
[16:03:13.161]                           invokeRestart("muffleWarning")
[16:03:13.161]                       }
[16:03:13.161]                       else if (inherits(cond, "condition")) {
[16:03:13.161]                         if (!is.null(pattern)) {
[16:03:13.161]                           computeRestarts <- base::computeRestarts
[16:03:13.161]                           grepl <- base::grepl
[16:03:13.161]                           restarts <- computeRestarts(cond)
[16:03:13.161]                           for (restart in restarts) {
[16:03:13.161]                             name <- restart$name
[16:03:13.161]                             if (is.null(name)) 
[16:03:13.161]                               next
[16:03:13.161]                             if (!grepl(pattern, name)) 
[16:03:13.161]                               next
[16:03:13.161]                             invokeRestart(restart)
[16:03:13.161]                             muffled <- TRUE
[16:03:13.161]                             break
[16:03:13.161]                           }
[16:03:13.161]                         }
[16:03:13.161]                       }
[16:03:13.161]                       invisible(muffled)
[16:03:13.161]                     }
[16:03:13.161]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.161]                   }
[16:03:13.161]                 }
[16:03:13.161]             }
[16:03:13.161]         }))
[16:03:13.161]     }, error = function(ex) {
[16:03:13.161]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.161]                 ...future.rng), started = ...future.startTime, 
[16:03:13.161]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.161]             version = "1.8"), class = "FutureResult")
[16:03:13.161]     }, finally = {
[16:03:13.161]         if (!identical(...future.workdir, getwd())) 
[16:03:13.161]             setwd(...future.workdir)
[16:03:13.161]         {
[16:03:13.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.161]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.161]             }
[16:03:13.161]             base::options(...future.oldOptions)
[16:03:13.161]             if (.Platform$OS.type == "windows") {
[16:03:13.161]                 old_names <- names(...future.oldEnvVars)
[16:03:13.161]                 envs <- base::Sys.getenv()
[16:03:13.161]                 names <- names(envs)
[16:03:13.161]                 common <- intersect(names, old_names)
[16:03:13.161]                 added <- setdiff(names, old_names)
[16:03:13.161]                 removed <- setdiff(old_names, names)
[16:03:13.161]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.161]                   envs[common]]
[16:03:13.161]                 NAMES <- toupper(changed)
[16:03:13.161]                 args <- list()
[16:03:13.161]                 for (kk in seq_along(NAMES)) {
[16:03:13.161]                   name <- changed[[kk]]
[16:03:13.161]                   NAME <- NAMES[[kk]]
[16:03:13.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.161]                     next
[16:03:13.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.161]                 }
[16:03:13.161]                 NAMES <- toupper(added)
[16:03:13.161]                 for (kk in seq_along(NAMES)) {
[16:03:13.161]                   name <- added[[kk]]
[16:03:13.161]                   NAME <- NAMES[[kk]]
[16:03:13.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.161]                     next
[16:03:13.161]                   args[[name]] <- ""
[16:03:13.161]                 }
[16:03:13.161]                 NAMES <- toupper(removed)
[16:03:13.161]                 for (kk in seq_along(NAMES)) {
[16:03:13.161]                   name <- removed[[kk]]
[16:03:13.161]                   NAME <- NAMES[[kk]]
[16:03:13.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.161]                     next
[16:03:13.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.161]                 }
[16:03:13.161]                 if (length(args) > 0) 
[16:03:13.161]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.161]             }
[16:03:13.161]             else {
[16:03:13.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.161]             }
[16:03:13.161]             {
[16:03:13.161]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.161]                   0L) {
[16:03:13.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.161]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.161]                   base::options(opts)
[16:03:13.161]                 }
[16:03:13.161]                 {
[16:03:13.161]                   {
[16:03:13.161]                     NULL
[16:03:13.161]                     RNGkind("Mersenne-Twister")
[16:03:13.161]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:13.161]                       inherits = FALSE)
[16:03:13.161]                   }
[16:03:13.161]                   options(future.plan = NULL)
[16:03:13.161]                   if (is.na(NA_character_)) 
[16:03:13.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.161]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:13.161]                   {
[16:03:13.161]                     future <- SequentialFuture(..., envir = envir)
[16:03:13.161]                     if (!future$lazy) 
[16:03:13.161]                       future <- run(future)
[16:03:13.161]                     invisible(future)
[16:03:13.161]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.161]                 }
[16:03:13.161]             }
[16:03:13.161]         }
[16:03:13.161]     })
[16:03:13.161]     if (TRUE) {
[16:03:13.161]         base::sink(type = "output", split = FALSE)
[16:03:13.161]         if (TRUE) {
[16:03:13.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.161]         }
[16:03:13.161]         else {
[16:03:13.161]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.161]         }
[16:03:13.161]         base::close(...future.stdout)
[16:03:13.161]         ...future.stdout <- NULL
[16:03:13.161]     }
[16:03:13.161]     ...future.result$conditions <- ...future.conditions
[16:03:13.161]     ...future.result$finished <- base::Sys.time()
[16:03:13.161]     ...future.result
[16:03:13.161] }
[16:03:13.162] assign_globals() ...
[16:03:13.162] List of 11
[16:03:13.162]  $ ...future.FUN            :function (x, ...)  
[16:03:13.162]  $ x_FUN                    :function (x)  
[16:03:13.162]  $ times                    : int 2
[16:03:13.162]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.162]  $ stop_if_not              :function (...)  
[16:03:13.162]  $ dim                      : NULL
[16:03:13.162]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:13.162]  $ future.call.arguments    : list()
[16:03:13.162]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.162]  $ ...future.elements_ii    :List of 3
[16:03:13.162]   ..$ : int 1
[16:03:13.162]   ..$ : int 2
[16:03:13.162]   ..$ : int 3
[16:03:13.162]  $ ...future.seeds_ii       : NULL
[16:03:13.162]  $ ...future.globals.maxSize: NULL
[16:03:13.162]  - attr(*, "where")=List of 11
[16:03:13.162]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.162]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.162]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.162]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.162]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.162]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.162]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.162]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.162]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.162]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.162]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.162]  - attr(*, "resolved")= logi FALSE
[16:03:13.162]  - attr(*, "total_size")= num 95128
[16:03:13.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.162]  - attr(*, "already-done")= logi TRUE
[16:03:13.170] - copied ‘...future.FUN’ to environment
[16:03:13.170] - copied ‘x_FUN’ to environment
[16:03:13.170] - copied ‘times’ to environment
[16:03:13.170] - copied ‘stopf’ to environment
[16:03:13.170] - copied ‘stop_if_not’ to environment
[16:03:13.170] - copied ‘dim’ to environment
[16:03:13.171] - copied ‘valid_types’ to environment
[16:03:13.171] - copied ‘future.call.arguments’ to environment
[16:03:13.171] - copied ‘...future.elements_ii’ to environment
[16:03:13.171] - copied ‘...future.seeds_ii’ to environment
[16:03:13.171] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.171] assign_globals() ... done
[16:03:13.171] plan(): Setting new future strategy stack:
[16:03:13.171] List of future strategies:
[16:03:13.171] 1. sequential:
[16:03:13.171]    - args: function (..., envir = parent.frame())
[16:03:13.171]    - tweaked: FALSE
[16:03:13.171]    - call: NULL
[16:03:13.172] plan(): nbrOfWorkers() = 1
[16:03:13.173] plan(): Setting new future strategy stack:
[16:03:13.173] List of future strategies:
[16:03:13.173] 1. sequential:
[16:03:13.173]    - args: function (..., envir = parent.frame())
[16:03:13.173]    - tweaked: FALSE
[16:03:13.173]    - call: plan(strategy)
[16:03:13.173] plan(): nbrOfWorkers() = 1
[16:03:13.173] SequentialFuture started (and completed)
[16:03:13.173] signalConditions() ...
[16:03:13.173]  - include = ‘immediateCondition’
[16:03:13.174]  - exclude = 
[16:03:13.174]  - resignal = FALSE
[16:03:13.174]  - Number of conditions: 1
[16:03:13.174] signalConditions() ... done
[16:03:13.174] - Launch lazy future ... done
[16:03:13.174] run() for ‘SequentialFuture’ ... done
[16:03:13.174] Created future:
[16:03:13.174] SequentialFuture:
[16:03:13.174] Label: ‘future_vapply-1’
[16:03:13.174] Expression:
[16:03:13.174] {
[16:03:13.174]     do.call(function(...) {
[16:03:13.174]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.174]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.174]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.174]             on.exit(options(oopts), add = TRUE)
[16:03:13.174]         }
[16:03:13.174]         {
[16:03:13.174]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.174]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.174]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.174]             })
[16:03:13.174]         }
[16:03:13.174]     }, args = future.call.arguments)
[16:03:13.174] }
[16:03:13.174] Lazy evaluation: FALSE
[16:03:13.174] Asynchronous evaluation: FALSE
[16:03:13.174] Local evaluation: TRUE
[16:03:13.174] Environment: R_GlobalEnv
[16:03:13.174] Capture standard output: TRUE
[16:03:13.174] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.174] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.174] Packages: 1 packages (‘future.apply’)
[16:03:13.174] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.174] Resolved: TRUE
[16:03:13.174] Value: 0 bytes of class ‘NULL’
[16:03:13.174] Conditions captured: [n=1] ‘simpleError’
[16:03:13.174] Early signaling: FALSE
[16:03:13.174] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.174] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:13.175] Chunk #1 of 1 ... DONE
[16:03:13.175] Launching 1 futures (chunks) ... DONE
[16:03:13.175] Resolving 1 futures (chunks) ...
[16:03:13.176] resolve() on list ...
[16:03:13.176]  recursive: 0
[16:03:13.176]  length: 1
[16:03:13.176] 
[16:03:13.176] resolved() for ‘SequentialFuture’ ...
[16:03:13.176] - state: ‘finished’
[16:03:13.176] - run: TRUE
[16:03:13.176] - result: ‘FutureResult’
[16:03:13.176] resolved() for ‘SequentialFuture’ ... done
[16:03:13.176] Future #1
[16:03:13.176] signalConditions() ...
[16:03:13.177]  - include = ‘immediateCondition’
[16:03:13.177]  - exclude = 
[16:03:13.177]  - resignal = FALSE
[16:03:13.177]  - Number of conditions: 1
[16:03:13.177] signalConditions() ... done
[16:03:13.177] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:13.177] - nx: 1
[16:03:13.177] - relay: TRUE
[16:03:13.177] - stdout: TRUE
[16:03:13.178] - signal: TRUE
[16:03:13.179] - resignal: FALSE
[16:03:13.179] - force: TRUE
[16:03:13.179] - relayed: [n=1] FALSE
[16:03:13.179] - queued futures: [n=1] FALSE
[16:03:13.179]  - until=1
[16:03:13.179]  - relaying element #1
[16:03:13.179] signalConditions() ...
[16:03:13.179]  - include = ‘immediateCondition’
[16:03:13.179]  - exclude = 
[16:03:13.179]  - resignal = FALSE
[16:03:13.179]  - Number of conditions: 1
[16:03:13.180] signalConditions() ... done
[16:03:13.180] signalConditions() ...
[16:03:13.180]  - include = ‘immediateCondition’
[16:03:13.180]  - exclude = 
[16:03:13.180]  - resignal = FALSE
[16:03:13.180]  - Number of conditions: 1
[16:03:13.180] signalConditions() ... done
[16:03:13.180] signalConditions() ...
[16:03:13.180]  - include = ‘condition’
[16:03:13.180]  - exclude = ‘immediateCondition’
[16:03:13.181]  - resignal = TRUE
[16:03:13.181]  - Number of conditions: 1
[16:03:13.181]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:03:13.181] signalConditions() ... done
[16:03:13.181] - relayed: [n=1] FALSE
[16:03:13.181] - queued futures: [n=1] TRUE
[16:03:13.181] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:13.181] plan(): Setting new future strategy stack:
[16:03:13.181] List of future strategies:
[16:03:13.181] 1. sequential:
[16:03:13.181]    - args: function (..., envir = parent.frame())
[16:03:13.181]    - tweaked: FALSE
[16:03:13.181]    - call: plan(sequential)
[16:03:13.182] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:03:13.182] plan(): Setting new future strategy stack:
[16:03:13.182] List of future strategies:
[16:03:13.182] 1. multicore:
[16:03:13.182]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.182]    - tweaked: FALSE
[16:03:13.182]    - call: plan(strategy)
[16:03:13.186] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[16:03:13.188] future_lapply() ...
[16:03:13.194] Number of chunks: 2
[16:03:13.194] getGlobalsAndPackagesXApply() ...
[16:03:13.194]  - future.globals: TRUE
[16:03:13.194] getGlobalsAndPackages() ...
[16:03:13.194] Searching for globals...
[16:03:13.197] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:13.197] Searching for globals ... DONE
[16:03:13.197] Resolving globals: FALSE
[16:03:13.198] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[16:03:13.198] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:13.198] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.199] - packages: [1] ‘future.apply’
[16:03:13.199] getGlobalsAndPackages() ... DONE
[16:03:13.199]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.199]  - needed namespaces: [n=1] ‘future.apply’
[16:03:13.199] Finding globals ... DONE
[16:03:13.199]  - use_args: TRUE
[16:03:13.199]  - Getting '...' globals ...
[16:03:13.200] resolve() on list ...
[16:03:13.200]  recursive: 0
[16:03:13.200]  length: 1
[16:03:13.200]  elements: ‘...’
[16:03:13.200]  length: 0 (resolved future 1)
[16:03:13.200] resolve() on list ... DONE
[16:03:13.200]    - '...' content: [n=0] 
[16:03:13.200] List of 1
[16:03:13.200]  $ ...: list()
[16:03:13.200]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.200]  - attr(*, "where")=List of 1
[16:03:13.200]   ..$ ...:<environment: 0x564e409a26a0> 
[16:03:13.200]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.200]  - attr(*, "resolved")= logi TRUE
[16:03:13.200]  - attr(*, "total_size")= num NA
[16:03:13.205]  - Getting '...' globals ... DONE
[16:03:13.205] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:13.205] List of 8
[16:03:13.205]  $ ...future.FUN:function (x, ...)  
[16:03:13.205]  $ x_FUN        :function (x)  
[16:03:13.205]  $ times        : int 1
[16:03:13.205]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.205]  $ stop_if_not  :function (...)  
[16:03:13.205]  $ dim          : NULL
[16:03:13.205]  $ valid_types  : chr "character"
[16:03:13.205]  $ ...          : list()
[16:03:13.205]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.205]  - attr(*, "where")=List of 8
[16:03:13.205]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:13.205]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:13.205]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:13.205]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:13.205]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:13.205]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:13.205]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:13.205]   ..$ ...          :<environment: 0x564e409a26a0> 
[16:03:13.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.205]  - attr(*, "resolved")= logi FALSE
[16:03:13.205]  - attr(*, "total_size")= num 94208
[16:03:13.211] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:13.211] getGlobalsAndPackagesXApply() ... DONE
[16:03:13.211] Number of futures (= number of chunks): 2
[16:03:13.211] Launching 2 futures (chunks) ...
[16:03:13.211] Chunk #1 of 2 ...
[16:03:13.211]  - Finding globals in 'X' for chunk #1 ...
[16:03:13.211] getGlobalsAndPackages() ...
[16:03:13.212] Searching for globals...
[16:03:13.212] 
[16:03:13.212] Searching for globals ... DONE
[16:03:13.212] - globals: [0] <none>
[16:03:13.212] getGlobalsAndPackages() ... DONE
[16:03:13.212]    + additional globals found: [n=0] 
[16:03:13.212]    + additional namespaces needed: [n=0] 
[16:03:13.212]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:13.212]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.212]  - seeds: <none>
[16:03:13.213]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.213] getGlobalsAndPackages() ...
[16:03:13.213] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.213] Resolving globals: FALSE
[16:03:13.213] Tweak future expression to call with '...' arguments ...
[16:03:13.213] {
[16:03:13.213]     do.call(function(...) {
[16:03:13.213]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.213]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.213]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.213]             on.exit(options(oopts), add = TRUE)
[16:03:13.213]         }
[16:03:13.213]         {
[16:03:13.213]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.213]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.213]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.213]             })
[16:03:13.213]         }
[16:03:13.213]     }, args = future.call.arguments)
[16:03:13.213] }
[16:03:13.213] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.214] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.214] - packages: [1] ‘future.apply’
[16:03:13.214] getGlobalsAndPackages() ... DONE
[16:03:13.214] run() for ‘Future’ ...
[16:03:13.214] - state: ‘created’
[16:03:13.215] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.218] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.219] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.219]   - Field: ‘label’
[16:03:13.219]   - Field: ‘local’
[16:03:13.219]   - Field: ‘owner’
[16:03:13.219]   - Field: ‘envir’
[16:03:13.219]   - Field: ‘workers’
[16:03:13.219]   - Field: ‘packages’
[16:03:13.219]   - Field: ‘gc’
[16:03:13.220]   - Field: ‘job’
[16:03:13.220]   - Field: ‘conditions’
[16:03:13.220]   - Field: ‘expr’
[16:03:13.220]   - Field: ‘uuid’
[16:03:13.220]   - Field: ‘seed’
[16:03:13.220]   - Field: ‘version’
[16:03:13.220]   - Field: ‘result’
[16:03:13.220]   - Field: ‘asynchronous’
[16:03:13.220]   - Field: ‘calls’
[16:03:13.220]   - Field: ‘globals’
[16:03:13.220]   - Field: ‘stdout’
[16:03:13.221]   - Field: ‘earlySignal’
[16:03:13.221]   - Field: ‘lazy’
[16:03:13.221]   - Field: ‘state’
[16:03:13.221] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.221] - Launch lazy future ...
[16:03:13.222] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.222] Packages needed by future strategies (n = 0): <none>
[16:03:13.223] {
[16:03:13.223]     {
[16:03:13.223]         {
[16:03:13.223]             ...future.startTime <- base::Sys.time()
[16:03:13.223]             {
[16:03:13.223]                 {
[16:03:13.223]                   {
[16:03:13.223]                     {
[16:03:13.223]                       {
[16:03:13.223]                         base::local({
[16:03:13.223]                           has_future <- base::requireNamespace("future", 
[16:03:13.223]                             quietly = TRUE)
[16:03:13.223]                           if (has_future) {
[16:03:13.223]                             ns <- base::getNamespace("future")
[16:03:13.223]                             version <- ns[[".package"]][["version"]]
[16:03:13.223]                             if (is.null(version)) 
[16:03:13.223]                               version <- utils::packageVersion("future")
[16:03:13.223]                           }
[16:03:13.223]                           else {
[16:03:13.223]                             version <- NULL
[16:03:13.223]                           }
[16:03:13.223]                           if (!has_future || version < "1.8.0") {
[16:03:13.223]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.223]                               "", base::R.version$version.string), 
[16:03:13.223]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.223]                                 base::R.version$platform, 8 * 
[16:03:13.223]                                   base::.Machine$sizeof.pointer), 
[16:03:13.223]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.223]                                 "release", "version")], collapse = " "), 
[16:03:13.223]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.223]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.223]                               info)
[16:03:13.223]                             info <- base::paste(info, collapse = "; ")
[16:03:13.223]                             if (!has_future) {
[16:03:13.223]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.223]                                 info)
[16:03:13.223]                             }
[16:03:13.223]                             else {
[16:03:13.223]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.223]                                 info, version)
[16:03:13.223]                             }
[16:03:13.223]                             base::stop(msg)
[16:03:13.223]                           }
[16:03:13.223]                         })
[16:03:13.223]                       }
[16:03:13.223]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.223]                       base::options(mc.cores = 1L)
[16:03:13.223]                     }
[16:03:13.223]                     base::local({
[16:03:13.223]                       for (pkg in "future.apply") {
[16:03:13.223]                         base::loadNamespace(pkg)
[16:03:13.223]                         base::library(pkg, character.only = TRUE)
[16:03:13.223]                       }
[16:03:13.223]                     })
[16:03:13.223]                   }
[16:03:13.223]                   options(future.plan = NULL)
[16:03:13.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.223]                 }
[16:03:13.223]                 ...future.workdir <- getwd()
[16:03:13.223]             }
[16:03:13.223]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.223]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.223]         }
[16:03:13.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.223]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.223]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.223]             base::names(...future.oldOptions))
[16:03:13.223]     }
[16:03:13.223]     if (FALSE) {
[16:03:13.223]     }
[16:03:13.223]     else {
[16:03:13.223]         if (TRUE) {
[16:03:13.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.223]                 open = "w")
[16:03:13.223]         }
[16:03:13.223]         else {
[16:03:13.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.223]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.223]         }
[16:03:13.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.223]             base::sink(type = "output", split = FALSE)
[16:03:13.223]             base::close(...future.stdout)
[16:03:13.223]         }, add = TRUE)
[16:03:13.223]     }
[16:03:13.223]     ...future.frame <- base::sys.nframe()
[16:03:13.223]     ...future.conditions <- base::list()
[16:03:13.223]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.223]     if (FALSE) {
[16:03:13.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.223]     }
[16:03:13.223]     ...future.result <- base::tryCatch({
[16:03:13.223]         base::withCallingHandlers({
[16:03:13.223]             ...future.value <- base::withVisible(base::local({
[16:03:13.223]                 withCallingHandlers({
[16:03:13.223]                   {
[16:03:13.223]                     do.call(function(...) {
[16:03:13.223]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.223]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.223]                         ...future.globals.maxSize)) {
[16:03:13.223]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.223]                         on.exit(options(oopts), add = TRUE)
[16:03:13.223]                       }
[16:03:13.223]                       {
[16:03:13.223]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.223]                           FUN = function(jj) {
[16:03:13.223]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.223]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.223]                           })
[16:03:13.223]                       }
[16:03:13.223]                     }, args = future.call.arguments)
[16:03:13.223]                   }
[16:03:13.223]                 }, immediateCondition = function(cond) {
[16:03:13.223]                   save_rds <- function (object, pathname, ...) 
[16:03:13.223]                   {
[16:03:13.223]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.223]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.223]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.223]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.223]                         fi_tmp[["mtime"]])
[16:03:13.223]                     }
[16:03:13.223]                     tryCatch({
[16:03:13.223]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.223]                     }, error = function(ex) {
[16:03:13.223]                       msg <- conditionMessage(ex)
[16:03:13.223]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.223]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.223]                         fi_tmp[["mtime"]], msg)
[16:03:13.223]                       ex$message <- msg
[16:03:13.223]                       stop(ex)
[16:03:13.223]                     })
[16:03:13.223]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.223]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.223]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.223]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.223]                       fi <- file.info(pathname)
[16:03:13.223]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.223]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.223]                         fi[["size"]], fi[["mtime"]])
[16:03:13.223]                       stop(msg)
[16:03:13.223]                     }
[16:03:13.223]                     invisible(pathname)
[16:03:13.223]                   }
[16:03:13.223]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.223]                     rootPath = tempdir()) 
[16:03:13.223]                   {
[16:03:13.223]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.223]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.223]                       tmpdir = path, fileext = ".rds")
[16:03:13.223]                     save_rds(obj, file)
[16:03:13.223]                   }
[16:03:13.223]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.223]                   {
[16:03:13.223]                     inherits <- base::inherits
[16:03:13.223]                     invokeRestart <- base::invokeRestart
[16:03:13.223]                     is.null <- base::is.null
[16:03:13.223]                     muffled <- FALSE
[16:03:13.223]                     if (inherits(cond, "message")) {
[16:03:13.223]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.223]                       if (muffled) 
[16:03:13.223]                         invokeRestart("muffleMessage")
[16:03:13.223]                     }
[16:03:13.223]                     else if (inherits(cond, "warning")) {
[16:03:13.223]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.223]                       if (muffled) 
[16:03:13.223]                         invokeRestart("muffleWarning")
[16:03:13.223]                     }
[16:03:13.223]                     else if (inherits(cond, "condition")) {
[16:03:13.223]                       if (!is.null(pattern)) {
[16:03:13.223]                         computeRestarts <- base::computeRestarts
[16:03:13.223]                         grepl <- base::grepl
[16:03:13.223]                         restarts <- computeRestarts(cond)
[16:03:13.223]                         for (restart in restarts) {
[16:03:13.223]                           name <- restart$name
[16:03:13.223]                           if (is.null(name)) 
[16:03:13.223]                             next
[16:03:13.223]                           if (!grepl(pattern, name)) 
[16:03:13.223]                             next
[16:03:13.223]                           invokeRestart(restart)
[16:03:13.223]                           muffled <- TRUE
[16:03:13.223]                           break
[16:03:13.223]                         }
[16:03:13.223]                       }
[16:03:13.223]                     }
[16:03:13.223]                     invisible(muffled)
[16:03:13.223]                   }
[16:03:13.223]                   muffleCondition(cond)
[16:03:13.223]                 })
[16:03:13.223]             }))
[16:03:13.223]             future::FutureResult(value = ...future.value$value, 
[16:03:13.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.223]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.223]                     ...future.globalenv.names))
[16:03:13.223]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.223]         }, condition = base::local({
[16:03:13.223]             c <- base::c
[16:03:13.223]             inherits <- base::inherits
[16:03:13.223]             invokeRestart <- base::invokeRestart
[16:03:13.223]             length <- base::length
[16:03:13.223]             list <- base::list
[16:03:13.223]             seq.int <- base::seq.int
[16:03:13.223]             signalCondition <- base::signalCondition
[16:03:13.223]             sys.calls <- base::sys.calls
[16:03:13.223]             `[[` <- base::`[[`
[16:03:13.223]             `+` <- base::`+`
[16:03:13.223]             `<<-` <- base::`<<-`
[16:03:13.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.223]                   3L)]
[16:03:13.223]             }
[16:03:13.223]             function(cond) {
[16:03:13.223]                 is_error <- inherits(cond, "error")
[16:03:13.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.223]                   NULL)
[16:03:13.223]                 if (is_error) {
[16:03:13.223]                   sessionInformation <- function() {
[16:03:13.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.223]                       search = base::search(), system = base::Sys.info())
[16:03:13.223]                   }
[16:03:13.223]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.223]                     cond$call), session = sessionInformation(), 
[16:03:13.223]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.223]                   signalCondition(cond)
[16:03:13.223]                 }
[16:03:13.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.223]                 "immediateCondition"))) {
[16:03:13.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.223]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.223]                   if (TRUE && !signal) {
[16:03:13.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.223]                     {
[16:03:13.223]                       inherits <- base::inherits
[16:03:13.223]                       invokeRestart <- base::invokeRestart
[16:03:13.223]                       is.null <- base::is.null
[16:03:13.223]                       muffled <- FALSE
[16:03:13.223]                       if (inherits(cond, "message")) {
[16:03:13.223]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.223]                         if (muffled) 
[16:03:13.223]                           invokeRestart("muffleMessage")
[16:03:13.223]                       }
[16:03:13.223]                       else if (inherits(cond, "warning")) {
[16:03:13.223]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.223]                         if (muffled) 
[16:03:13.223]                           invokeRestart("muffleWarning")
[16:03:13.223]                       }
[16:03:13.223]                       else if (inherits(cond, "condition")) {
[16:03:13.223]                         if (!is.null(pattern)) {
[16:03:13.223]                           computeRestarts <- base::computeRestarts
[16:03:13.223]                           grepl <- base::grepl
[16:03:13.223]                           restarts <- computeRestarts(cond)
[16:03:13.223]                           for (restart in restarts) {
[16:03:13.223]                             name <- restart$name
[16:03:13.223]                             if (is.null(name)) 
[16:03:13.223]                               next
[16:03:13.223]                             if (!grepl(pattern, name)) 
[16:03:13.223]                               next
[16:03:13.223]                             invokeRestart(restart)
[16:03:13.223]                             muffled <- TRUE
[16:03:13.223]                             break
[16:03:13.223]                           }
[16:03:13.223]                         }
[16:03:13.223]                       }
[16:03:13.223]                       invisible(muffled)
[16:03:13.223]                     }
[16:03:13.223]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.223]                   }
[16:03:13.223]                 }
[16:03:13.223]                 else {
[16:03:13.223]                   if (TRUE) {
[16:03:13.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.223]                     {
[16:03:13.223]                       inherits <- base::inherits
[16:03:13.223]                       invokeRestart <- base::invokeRestart
[16:03:13.223]                       is.null <- base::is.null
[16:03:13.223]                       muffled <- FALSE
[16:03:13.223]                       if (inherits(cond, "message")) {
[16:03:13.223]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.223]                         if (muffled) 
[16:03:13.223]                           invokeRestart("muffleMessage")
[16:03:13.223]                       }
[16:03:13.223]                       else if (inherits(cond, "warning")) {
[16:03:13.223]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.223]                         if (muffled) 
[16:03:13.223]                           invokeRestart("muffleWarning")
[16:03:13.223]                       }
[16:03:13.223]                       else if (inherits(cond, "condition")) {
[16:03:13.223]                         if (!is.null(pattern)) {
[16:03:13.223]                           computeRestarts <- base::computeRestarts
[16:03:13.223]                           grepl <- base::grepl
[16:03:13.223]                           restarts <- computeRestarts(cond)
[16:03:13.223]                           for (restart in restarts) {
[16:03:13.223]                             name <- restart$name
[16:03:13.223]                             if (is.null(name)) 
[16:03:13.223]                               next
[16:03:13.223]                             if (!grepl(pattern, name)) 
[16:03:13.223]                               next
[16:03:13.223]                             invokeRestart(restart)
[16:03:13.223]                             muffled <- TRUE
[16:03:13.223]                             break
[16:03:13.223]                           }
[16:03:13.223]                         }
[16:03:13.223]                       }
[16:03:13.223]                       invisible(muffled)
[16:03:13.223]                     }
[16:03:13.223]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.223]                   }
[16:03:13.223]                 }
[16:03:13.223]             }
[16:03:13.223]         }))
[16:03:13.223]     }, error = function(ex) {
[16:03:13.223]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.223]                 ...future.rng), started = ...future.startTime, 
[16:03:13.223]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.223]             version = "1.8"), class = "FutureResult")
[16:03:13.223]     }, finally = {
[16:03:13.223]         if (!identical(...future.workdir, getwd())) 
[16:03:13.223]             setwd(...future.workdir)
[16:03:13.223]         {
[16:03:13.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.223]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.223]             }
[16:03:13.223]             base::options(...future.oldOptions)
[16:03:13.223]             if (.Platform$OS.type == "windows") {
[16:03:13.223]                 old_names <- names(...future.oldEnvVars)
[16:03:13.223]                 envs <- base::Sys.getenv()
[16:03:13.223]                 names <- names(envs)
[16:03:13.223]                 common <- intersect(names, old_names)
[16:03:13.223]                 added <- setdiff(names, old_names)
[16:03:13.223]                 removed <- setdiff(old_names, names)
[16:03:13.223]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.223]                   envs[common]]
[16:03:13.223]                 NAMES <- toupper(changed)
[16:03:13.223]                 args <- list()
[16:03:13.223]                 for (kk in seq_along(NAMES)) {
[16:03:13.223]                   name <- changed[[kk]]
[16:03:13.223]                   NAME <- NAMES[[kk]]
[16:03:13.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.223]                     next
[16:03:13.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.223]                 }
[16:03:13.223]                 NAMES <- toupper(added)
[16:03:13.223]                 for (kk in seq_along(NAMES)) {
[16:03:13.223]                   name <- added[[kk]]
[16:03:13.223]                   NAME <- NAMES[[kk]]
[16:03:13.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.223]                     next
[16:03:13.223]                   args[[name]] <- ""
[16:03:13.223]                 }
[16:03:13.223]                 NAMES <- toupper(removed)
[16:03:13.223]                 for (kk in seq_along(NAMES)) {
[16:03:13.223]                   name <- removed[[kk]]
[16:03:13.223]                   NAME <- NAMES[[kk]]
[16:03:13.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.223]                     next
[16:03:13.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.223]                 }
[16:03:13.223]                 if (length(args) > 0) 
[16:03:13.223]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.223]             }
[16:03:13.223]             else {
[16:03:13.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.223]             }
[16:03:13.223]             {
[16:03:13.223]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.223]                   0L) {
[16:03:13.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.223]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.223]                   base::options(opts)
[16:03:13.223]                 }
[16:03:13.223]                 {
[16:03:13.223]                   {
[16:03:13.223]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.223]                     NULL
[16:03:13.223]                   }
[16:03:13.223]                   options(future.plan = NULL)
[16:03:13.223]                   if (is.na(NA_character_)) 
[16:03:13.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.223]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.223]                     envir = parent.frame()) 
[16:03:13.223]                   {
[16:03:13.223]                     default_workers <- missing(workers)
[16:03:13.223]                     if (is.function(workers)) 
[16:03:13.223]                       workers <- workers()
[16:03:13.223]                     workers <- structure(as.integer(workers), 
[16:03:13.223]                       class = class(workers))
[16:03:13.223]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.223]                       1L)
[16:03:13.223]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.223]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.223]                       if (default_workers) 
[16:03:13.223]                         supportsMulticore(warn = TRUE)
[16:03:13.223]                       return(sequential(..., envir = envir))
[16:03:13.223]                     }
[16:03:13.223]                     oopts <- options(mc.cores = workers)
[16:03:13.223]                     on.exit(options(oopts))
[16:03:13.223]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.223]                       envir = envir)
[16:03:13.223]                     if (!future$lazy) 
[16:03:13.223]                       future <- run(future)
[16:03:13.223]                     invisible(future)
[16:03:13.223]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.223]                 }
[16:03:13.223]             }
[16:03:13.223]         }
[16:03:13.223]     })
[16:03:13.223]     if (TRUE) {
[16:03:13.223]         base::sink(type = "output", split = FALSE)
[16:03:13.223]         if (TRUE) {
[16:03:13.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.223]         }
[16:03:13.223]         else {
[16:03:13.223]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.223]         }
[16:03:13.223]         base::close(...future.stdout)
[16:03:13.223]         ...future.stdout <- NULL
[16:03:13.223]     }
[16:03:13.223]     ...future.result$conditions <- ...future.conditions
[16:03:13.223]     ...future.result$finished <- base::Sys.time()
[16:03:13.223]     ...future.result
[16:03:13.223] }
[16:03:13.225] assign_globals() ...
[16:03:13.225] List of 11
[16:03:13.225]  $ ...future.FUN            :function (x, ...)  
[16:03:13.225]  $ x_FUN                    :function (x)  
[16:03:13.225]  $ times                    : int 1
[16:03:13.225]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.225]  $ stop_if_not              :function (...)  
[16:03:13.225]  $ dim                      : NULL
[16:03:13.225]  $ valid_types              : chr "character"
[16:03:13.225]  $ future.call.arguments    : list()
[16:03:13.225]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.225]  $ ...future.elements_ii    :List of 1
[16:03:13.225]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:03:13.225]  $ ...future.seeds_ii       : NULL
[16:03:13.225]  $ ...future.globals.maxSize: NULL
[16:03:13.225]  - attr(*, "where")=List of 11
[16:03:13.225]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.225]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.225]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.225]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.225]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.225]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.225]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.225]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.225]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.225]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.225]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.225]  - attr(*, "resolved")= logi FALSE
[16:03:13.225]  - attr(*, "total_size")= num 94208
[16:03:13.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.225]  - attr(*, "already-done")= logi TRUE
[16:03:13.234] - copied ‘...future.FUN’ to environment
[16:03:13.234] - copied ‘x_FUN’ to environment
[16:03:13.234] - copied ‘times’ to environment
[16:03:13.234] - copied ‘stopf’ to environment
[16:03:13.234] - copied ‘stop_if_not’ to environment
[16:03:13.234] - copied ‘dim’ to environment
[16:03:13.234] - copied ‘valid_types’ to environment
[16:03:13.234] - copied ‘future.call.arguments’ to environment
[16:03:13.235] - copied ‘...future.elements_ii’ to environment
[16:03:13.235] - copied ‘...future.seeds_ii’ to environment
[16:03:13.235] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.235] assign_globals() ... done
[16:03:13.235] requestCore(): workers = 2
[16:03:13.238] MulticoreFuture started
[16:03:13.239] - Launch lazy future ... done
[16:03:13.239] run() for ‘MulticoreFuture’ ... done
[16:03:13.240] plan(): Setting new future strategy stack:
[16:03:13.240] Created future:
[16:03:13.240] List of future strategies:
[16:03:13.240] 1. sequential:
[16:03:13.240]    - args: function (..., envir = parent.frame())
[16:03:13.240]    - tweaked: FALSE
[16:03:13.240]    - call: NULL
[16:03:13.241] plan(): nbrOfWorkers() = 1
[16:03:13.243] plan(): Setting new future strategy stack:
[16:03:13.244] List of future strategies:
[16:03:13.244] 1. multicore:
[16:03:13.244]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.244]    - tweaked: FALSE
[16:03:13.244]    - call: plan(strategy)
[16:03:13.249] plan(): nbrOfWorkers() = 2
[16:03:13.240] MulticoreFuture:
[16:03:13.240] Label: ‘future_vapply-1’
[16:03:13.240] Expression:
[16:03:13.240] {
[16:03:13.240]     do.call(function(...) {
[16:03:13.240]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.240]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.240]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.240]             on.exit(options(oopts), add = TRUE)
[16:03:13.240]         }
[16:03:13.240]         {
[16:03:13.240]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.240]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.240]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.240]             })
[16:03:13.240]         }
[16:03:13.240]     }, args = future.call.arguments)
[16:03:13.240] }
[16:03:13.240] Lazy evaluation: FALSE
[16:03:13.240] Asynchronous evaluation: TRUE
[16:03:13.240] Local evaluation: TRUE
[16:03:13.240] Environment: R_GlobalEnv
[16:03:13.240] Capture standard output: TRUE
[16:03:13.240] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.240] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.240] Packages: 1 packages (‘future.apply’)
[16:03:13.240] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.240] Resolved: TRUE
[16:03:13.240] Value: <not collected>
[16:03:13.240] Conditions captured: <none>
[16:03:13.240] Early signaling: FALSE
[16:03:13.240] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.240] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.251] Chunk #1 of 2 ... DONE
[16:03:13.251] Chunk #2 of 2 ...
[16:03:13.251]  - Finding globals in 'X' for chunk #2 ...
[16:03:13.251] getGlobalsAndPackages() ...
[16:03:13.252] Searching for globals...
[16:03:13.252] 
[16:03:13.252] Searching for globals ... DONE
[16:03:13.252] - globals: [0] <none>
[16:03:13.253] getGlobalsAndPackages() ... DONE
[16:03:13.253]    + additional globals found: [n=0] 
[16:03:13.253]    + additional namespaces needed: [n=0] 
[16:03:13.253]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:13.254]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.254]  - seeds: <none>
[16:03:13.254]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.254] getGlobalsAndPackages() ...
[16:03:13.254] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.255] Resolving globals: FALSE
[16:03:13.255] Tweak future expression to call with '...' arguments ...
[16:03:13.255] {
[16:03:13.255]     do.call(function(...) {
[16:03:13.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.255]             on.exit(options(oopts), add = TRUE)
[16:03:13.255]         }
[16:03:13.255]         {
[16:03:13.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.255]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.255]             })
[16:03:13.255]         }
[16:03:13.255]     }, args = future.call.arguments)
[16:03:13.255] }
[16:03:13.256] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.257] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.257] - packages: [1] ‘future.apply’
[16:03:13.257] getGlobalsAndPackages() ... DONE
[16:03:13.258] run() for ‘Future’ ...
[16:03:13.258] - state: ‘created’
[16:03:13.258] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.263] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.263] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.263]   - Field: ‘label’
[16:03:13.264]   - Field: ‘local’
[16:03:13.264]   - Field: ‘owner’
[16:03:13.264]   - Field: ‘envir’
[16:03:13.264]   - Field: ‘workers’
[16:03:13.264]   - Field: ‘packages’
[16:03:13.264]   - Field: ‘gc’
[16:03:13.264]   - Field: ‘job’
[16:03:13.265]   - Field: ‘conditions’
[16:03:13.265]   - Field: ‘expr’
[16:03:13.265]   - Field: ‘uuid’
[16:03:13.265]   - Field: ‘seed’
[16:03:13.265]   - Field: ‘version’
[16:03:13.265]   - Field: ‘result’
[16:03:13.265]   - Field: ‘asynchronous’
[16:03:13.265]   - Field: ‘calls’
[16:03:13.266]   - Field: ‘globals’
[16:03:13.266]   - Field: ‘stdout’
[16:03:13.266]   - Field: ‘earlySignal’
[16:03:13.266]   - Field: ‘lazy’
[16:03:13.266]   - Field: ‘state’
[16:03:13.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.266] - Launch lazy future ...
[16:03:13.267] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.267] Packages needed by future strategies (n = 0): <none>
[16:03:13.268] {
[16:03:13.268]     {
[16:03:13.268]         {
[16:03:13.268]             ...future.startTime <- base::Sys.time()
[16:03:13.268]             {
[16:03:13.268]                 {
[16:03:13.268]                   {
[16:03:13.268]                     {
[16:03:13.268]                       {
[16:03:13.268]                         base::local({
[16:03:13.268]                           has_future <- base::requireNamespace("future", 
[16:03:13.268]                             quietly = TRUE)
[16:03:13.268]                           if (has_future) {
[16:03:13.268]                             ns <- base::getNamespace("future")
[16:03:13.268]                             version <- ns[[".package"]][["version"]]
[16:03:13.268]                             if (is.null(version)) 
[16:03:13.268]                               version <- utils::packageVersion("future")
[16:03:13.268]                           }
[16:03:13.268]                           else {
[16:03:13.268]                             version <- NULL
[16:03:13.268]                           }
[16:03:13.268]                           if (!has_future || version < "1.8.0") {
[16:03:13.268]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.268]                               "", base::R.version$version.string), 
[16:03:13.268]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.268]                                 base::R.version$platform, 8 * 
[16:03:13.268]                                   base::.Machine$sizeof.pointer), 
[16:03:13.268]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.268]                                 "release", "version")], collapse = " "), 
[16:03:13.268]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.268]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.268]                               info)
[16:03:13.268]                             info <- base::paste(info, collapse = "; ")
[16:03:13.268]                             if (!has_future) {
[16:03:13.268]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.268]                                 info)
[16:03:13.268]                             }
[16:03:13.268]                             else {
[16:03:13.268]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.268]                                 info, version)
[16:03:13.268]                             }
[16:03:13.268]                             base::stop(msg)
[16:03:13.268]                           }
[16:03:13.268]                         })
[16:03:13.268]                       }
[16:03:13.268]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.268]                       base::options(mc.cores = 1L)
[16:03:13.268]                     }
[16:03:13.268]                     base::local({
[16:03:13.268]                       for (pkg in "future.apply") {
[16:03:13.268]                         base::loadNamespace(pkg)
[16:03:13.268]                         base::library(pkg, character.only = TRUE)
[16:03:13.268]                       }
[16:03:13.268]                     })
[16:03:13.268]                   }
[16:03:13.268]                   options(future.plan = NULL)
[16:03:13.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.268]                 }
[16:03:13.268]                 ...future.workdir <- getwd()
[16:03:13.268]             }
[16:03:13.268]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.268]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.268]         }
[16:03:13.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.268]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.268]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.268]             base::names(...future.oldOptions))
[16:03:13.268]     }
[16:03:13.268]     if (FALSE) {
[16:03:13.268]     }
[16:03:13.268]     else {
[16:03:13.268]         if (TRUE) {
[16:03:13.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.268]                 open = "w")
[16:03:13.268]         }
[16:03:13.268]         else {
[16:03:13.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.268]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.268]         }
[16:03:13.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.268]             base::sink(type = "output", split = FALSE)
[16:03:13.268]             base::close(...future.stdout)
[16:03:13.268]         }, add = TRUE)
[16:03:13.268]     }
[16:03:13.268]     ...future.frame <- base::sys.nframe()
[16:03:13.268]     ...future.conditions <- base::list()
[16:03:13.268]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.268]     if (FALSE) {
[16:03:13.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.268]     }
[16:03:13.268]     ...future.result <- base::tryCatch({
[16:03:13.268]         base::withCallingHandlers({
[16:03:13.268]             ...future.value <- base::withVisible(base::local({
[16:03:13.268]                 withCallingHandlers({
[16:03:13.268]                   {
[16:03:13.268]                     do.call(function(...) {
[16:03:13.268]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.268]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.268]                         ...future.globals.maxSize)) {
[16:03:13.268]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.268]                         on.exit(options(oopts), add = TRUE)
[16:03:13.268]                       }
[16:03:13.268]                       {
[16:03:13.268]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.268]                           FUN = function(jj) {
[16:03:13.268]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.268]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.268]                           })
[16:03:13.268]                       }
[16:03:13.268]                     }, args = future.call.arguments)
[16:03:13.268]                   }
[16:03:13.268]                 }, immediateCondition = function(cond) {
[16:03:13.268]                   save_rds <- function (object, pathname, ...) 
[16:03:13.268]                   {
[16:03:13.268]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.268]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.268]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.268]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.268]                         fi_tmp[["mtime"]])
[16:03:13.268]                     }
[16:03:13.268]                     tryCatch({
[16:03:13.268]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.268]                     }, error = function(ex) {
[16:03:13.268]                       msg <- conditionMessage(ex)
[16:03:13.268]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.268]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.268]                         fi_tmp[["mtime"]], msg)
[16:03:13.268]                       ex$message <- msg
[16:03:13.268]                       stop(ex)
[16:03:13.268]                     })
[16:03:13.268]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.268]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.268]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.268]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.268]                       fi <- file.info(pathname)
[16:03:13.268]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.268]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.268]                         fi[["size"]], fi[["mtime"]])
[16:03:13.268]                       stop(msg)
[16:03:13.268]                     }
[16:03:13.268]                     invisible(pathname)
[16:03:13.268]                   }
[16:03:13.268]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.268]                     rootPath = tempdir()) 
[16:03:13.268]                   {
[16:03:13.268]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.268]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.268]                       tmpdir = path, fileext = ".rds")
[16:03:13.268]                     save_rds(obj, file)
[16:03:13.268]                   }
[16:03:13.268]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.268]                   {
[16:03:13.268]                     inherits <- base::inherits
[16:03:13.268]                     invokeRestart <- base::invokeRestart
[16:03:13.268]                     is.null <- base::is.null
[16:03:13.268]                     muffled <- FALSE
[16:03:13.268]                     if (inherits(cond, "message")) {
[16:03:13.268]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.268]                       if (muffled) 
[16:03:13.268]                         invokeRestart("muffleMessage")
[16:03:13.268]                     }
[16:03:13.268]                     else if (inherits(cond, "warning")) {
[16:03:13.268]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.268]                       if (muffled) 
[16:03:13.268]                         invokeRestart("muffleWarning")
[16:03:13.268]                     }
[16:03:13.268]                     else if (inherits(cond, "condition")) {
[16:03:13.268]                       if (!is.null(pattern)) {
[16:03:13.268]                         computeRestarts <- base::computeRestarts
[16:03:13.268]                         grepl <- base::grepl
[16:03:13.268]                         restarts <- computeRestarts(cond)
[16:03:13.268]                         for (restart in restarts) {
[16:03:13.268]                           name <- restart$name
[16:03:13.268]                           if (is.null(name)) 
[16:03:13.268]                             next
[16:03:13.268]                           if (!grepl(pattern, name)) 
[16:03:13.268]                             next
[16:03:13.268]                           invokeRestart(restart)
[16:03:13.268]                           muffled <- TRUE
[16:03:13.268]                           break
[16:03:13.268]                         }
[16:03:13.268]                       }
[16:03:13.268]                     }
[16:03:13.268]                     invisible(muffled)
[16:03:13.268]                   }
[16:03:13.268]                   muffleCondition(cond)
[16:03:13.268]                 })
[16:03:13.268]             }))
[16:03:13.268]             future::FutureResult(value = ...future.value$value, 
[16:03:13.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.268]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.268]                     ...future.globalenv.names))
[16:03:13.268]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.268]         }, condition = base::local({
[16:03:13.268]             c <- base::c
[16:03:13.268]             inherits <- base::inherits
[16:03:13.268]             invokeRestart <- base::invokeRestart
[16:03:13.268]             length <- base::length
[16:03:13.268]             list <- base::list
[16:03:13.268]             seq.int <- base::seq.int
[16:03:13.268]             signalCondition <- base::signalCondition
[16:03:13.268]             sys.calls <- base::sys.calls
[16:03:13.268]             `[[` <- base::`[[`
[16:03:13.268]             `+` <- base::`+`
[16:03:13.268]             `<<-` <- base::`<<-`
[16:03:13.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.268]                   3L)]
[16:03:13.268]             }
[16:03:13.268]             function(cond) {
[16:03:13.268]                 is_error <- inherits(cond, "error")
[16:03:13.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.268]                   NULL)
[16:03:13.268]                 if (is_error) {
[16:03:13.268]                   sessionInformation <- function() {
[16:03:13.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.268]                       search = base::search(), system = base::Sys.info())
[16:03:13.268]                   }
[16:03:13.268]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.268]                     cond$call), session = sessionInformation(), 
[16:03:13.268]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.268]                   signalCondition(cond)
[16:03:13.268]                 }
[16:03:13.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.268]                 "immediateCondition"))) {
[16:03:13.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.268]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.268]                   if (TRUE && !signal) {
[16:03:13.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.268]                     {
[16:03:13.268]                       inherits <- base::inherits
[16:03:13.268]                       invokeRestart <- base::invokeRestart
[16:03:13.268]                       is.null <- base::is.null
[16:03:13.268]                       muffled <- FALSE
[16:03:13.268]                       if (inherits(cond, "message")) {
[16:03:13.268]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.268]                         if (muffled) 
[16:03:13.268]                           invokeRestart("muffleMessage")
[16:03:13.268]                       }
[16:03:13.268]                       else if (inherits(cond, "warning")) {
[16:03:13.268]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.268]                         if (muffled) 
[16:03:13.268]                           invokeRestart("muffleWarning")
[16:03:13.268]                       }
[16:03:13.268]                       else if (inherits(cond, "condition")) {
[16:03:13.268]                         if (!is.null(pattern)) {
[16:03:13.268]                           computeRestarts <- base::computeRestarts
[16:03:13.268]                           grepl <- base::grepl
[16:03:13.268]                           restarts <- computeRestarts(cond)
[16:03:13.268]                           for (restart in restarts) {
[16:03:13.268]                             name <- restart$name
[16:03:13.268]                             if (is.null(name)) 
[16:03:13.268]                               next
[16:03:13.268]                             if (!grepl(pattern, name)) 
[16:03:13.268]                               next
[16:03:13.268]                             invokeRestart(restart)
[16:03:13.268]                             muffled <- TRUE
[16:03:13.268]                             break
[16:03:13.268]                           }
[16:03:13.268]                         }
[16:03:13.268]                       }
[16:03:13.268]                       invisible(muffled)
[16:03:13.268]                     }
[16:03:13.268]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.268]                   }
[16:03:13.268]                 }
[16:03:13.268]                 else {
[16:03:13.268]                   if (TRUE) {
[16:03:13.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.268]                     {
[16:03:13.268]                       inherits <- base::inherits
[16:03:13.268]                       invokeRestart <- base::invokeRestart
[16:03:13.268]                       is.null <- base::is.null
[16:03:13.268]                       muffled <- FALSE
[16:03:13.268]                       if (inherits(cond, "message")) {
[16:03:13.268]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.268]                         if (muffled) 
[16:03:13.268]                           invokeRestart("muffleMessage")
[16:03:13.268]                       }
[16:03:13.268]                       else if (inherits(cond, "warning")) {
[16:03:13.268]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.268]                         if (muffled) 
[16:03:13.268]                           invokeRestart("muffleWarning")
[16:03:13.268]                       }
[16:03:13.268]                       else if (inherits(cond, "condition")) {
[16:03:13.268]                         if (!is.null(pattern)) {
[16:03:13.268]                           computeRestarts <- base::computeRestarts
[16:03:13.268]                           grepl <- base::grepl
[16:03:13.268]                           restarts <- computeRestarts(cond)
[16:03:13.268]                           for (restart in restarts) {
[16:03:13.268]                             name <- restart$name
[16:03:13.268]                             if (is.null(name)) 
[16:03:13.268]                               next
[16:03:13.268]                             if (!grepl(pattern, name)) 
[16:03:13.268]                               next
[16:03:13.268]                             invokeRestart(restart)
[16:03:13.268]                             muffled <- TRUE
[16:03:13.268]                             break
[16:03:13.268]                           }
[16:03:13.268]                         }
[16:03:13.268]                       }
[16:03:13.268]                       invisible(muffled)
[16:03:13.268]                     }
[16:03:13.268]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.268]                   }
[16:03:13.268]                 }
[16:03:13.268]             }
[16:03:13.268]         }))
[16:03:13.268]     }, error = function(ex) {
[16:03:13.268]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.268]                 ...future.rng), started = ...future.startTime, 
[16:03:13.268]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.268]             version = "1.8"), class = "FutureResult")
[16:03:13.268]     }, finally = {
[16:03:13.268]         if (!identical(...future.workdir, getwd())) 
[16:03:13.268]             setwd(...future.workdir)
[16:03:13.268]         {
[16:03:13.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.268]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.268]             }
[16:03:13.268]             base::options(...future.oldOptions)
[16:03:13.268]             if (.Platform$OS.type == "windows") {
[16:03:13.268]                 old_names <- names(...future.oldEnvVars)
[16:03:13.268]                 envs <- base::Sys.getenv()
[16:03:13.268]                 names <- names(envs)
[16:03:13.268]                 common <- intersect(names, old_names)
[16:03:13.268]                 added <- setdiff(names, old_names)
[16:03:13.268]                 removed <- setdiff(old_names, names)
[16:03:13.268]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.268]                   envs[common]]
[16:03:13.268]                 NAMES <- toupper(changed)
[16:03:13.268]                 args <- list()
[16:03:13.268]                 for (kk in seq_along(NAMES)) {
[16:03:13.268]                   name <- changed[[kk]]
[16:03:13.268]                   NAME <- NAMES[[kk]]
[16:03:13.268]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.268]                     next
[16:03:13.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.268]                 }
[16:03:13.268]                 NAMES <- toupper(added)
[16:03:13.268]                 for (kk in seq_along(NAMES)) {
[16:03:13.268]                   name <- added[[kk]]
[16:03:13.268]                   NAME <- NAMES[[kk]]
[16:03:13.268]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.268]                     next
[16:03:13.268]                   args[[name]] <- ""
[16:03:13.268]                 }
[16:03:13.268]                 NAMES <- toupper(removed)
[16:03:13.268]                 for (kk in seq_along(NAMES)) {
[16:03:13.268]                   name <- removed[[kk]]
[16:03:13.268]                   NAME <- NAMES[[kk]]
[16:03:13.268]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.268]                     next
[16:03:13.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.268]                 }
[16:03:13.268]                 if (length(args) > 0) 
[16:03:13.268]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.268]             }
[16:03:13.268]             else {
[16:03:13.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.268]             }
[16:03:13.268]             {
[16:03:13.268]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.268]                   0L) {
[16:03:13.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.268]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.268]                   base::options(opts)
[16:03:13.268]                 }
[16:03:13.268]                 {
[16:03:13.268]                   {
[16:03:13.268]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.268]                     NULL
[16:03:13.268]                   }
[16:03:13.268]                   options(future.plan = NULL)
[16:03:13.268]                   if (is.na(NA_character_)) 
[16:03:13.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.268]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.268]                     envir = parent.frame()) 
[16:03:13.268]                   {
[16:03:13.268]                     default_workers <- missing(workers)
[16:03:13.268]                     if (is.function(workers)) 
[16:03:13.268]                       workers <- workers()
[16:03:13.268]                     workers <- structure(as.integer(workers), 
[16:03:13.268]                       class = class(workers))
[16:03:13.268]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.268]                       1L)
[16:03:13.268]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.268]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.268]                       if (default_workers) 
[16:03:13.268]                         supportsMulticore(warn = TRUE)
[16:03:13.268]                       return(sequential(..., envir = envir))
[16:03:13.268]                     }
[16:03:13.268]                     oopts <- options(mc.cores = workers)
[16:03:13.268]                     on.exit(options(oopts))
[16:03:13.268]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.268]                       envir = envir)
[16:03:13.268]                     if (!future$lazy) 
[16:03:13.268]                       future <- run(future)
[16:03:13.268]                     invisible(future)
[16:03:13.268]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.268]                 }
[16:03:13.268]             }
[16:03:13.268]         }
[16:03:13.268]     })
[16:03:13.268]     if (TRUE) {
[16:03:13.268]         base::sink(type = "output", split = FALSE)
[16:03:13.268]         if (TRUE) {
[16:03:13.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.268]         }
[16:03:13.268]         else {
[16:03:13.268]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.268]         }
[16:03:13.268]         base::close(...future.stdout)
[16:03:13.268]         ...future.stdout <- NULL
[16:03:13.268]     }
[16:03:13.268]     ...future.result$conditions <- ...future.conditions
[16:03:13.268]     ...future.result$finished <- base::Sys.time()
[16:03:13.268]     ...future.result
[16:03:13.268] }
[16:03:13.271] assign_globals() ...
[16:03:13.271] List of 11
[16:03:13.271]  $ ...future.FUN            :function (x, ...)  
[16:03:13.271]  $ x_FUN                    :function (x)  
[16:03:13.271]  $ times                    : int 1
[16:03:13.271]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.271]  $ stop_if_not              :function (...)  
[16:03:13.271]  $ dim                      : NULL
[16:03:13.271]  $ valid_types              : chr "character"
[16:03:13.271]  $ future.call.arguments    : list()
[16:03:13.271]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.271]  $ ...future.elements_ii    :List of 1
[16:03:13.271]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[16:03:13.271]  $ ...future.seeds_ii       : NULL
[16:03:13.271]  $ ...future.globals.maxSize: NULL
[16:03:13.271]  - attr(*, "where")=List of 11
[16:03:13.271]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.271]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.271]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.271]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.271]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.271]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.271]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.271]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.271]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.271]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.271]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.271]  - attr(*, "resolved")= logi FALSE
[16:03:13.271]  - attr(*, "total_size")= num 94208
[16:03:13.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.271]  - attr(*, "already-done")= logi TRUE
[16:03:13.286] - copied ‘...future.FUN’ to environment
[16:03:13.286] - copied ‘x_FUN’ to environment
[16:03:13.286] - copied ‘times’ to environment
[16:03:13.286] - copied ‘stopf’ to environment
[16:03:13.286] - copied ‘stop_if_not’ to environment
[16:03:13.287] - copied ‘dim’ to environment
[16:03:13.287] - copied ‘valid_types’ to environment
[16:03:13.287] - copied ‘future.call.arguments’ to environment
[16:03:13.287] - copied ‘...future.elements_ii’ to environment
[16:03:13.287] - copied ‘...future.seeds_ii’ to environment
[16:03:13.287] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.287] assign_globals() ... done
[16:03:13.288] requestCore(): workers = 2
[16:03:13.292] MulticoreFuture started
[16:03:13.293] - Launch lazy future ... done
[16:03:13.293] run() for ‘MulticoreFuture’ ... done
[16:03:13.294] Created future:
[16:03:13.294] plan(): Setting new future strategy stack:
[16:03:13.294] List of future strategies:
[16:03:13.294] 1. sequential:
[16:03:13.294]    - args: function (..., envir = parent.frame())
[16:03:13.294]    - tweaked: FALSE
[16:03:13.294]    - call: NULL
[16:03:13.295] plan(): nbrOfWorkers() = 1
[16:03:13.297] plan(): Setting new future strategy stack:
[16:03:13.297] List of future strategies:
[16:03:13.297] 1. multicore:
[16:03:13.297]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.297]    - tweaked: FALSE
[16:03:13.297]    - call: plan(strategy)
[16:03:13.303] plan(): nbrOfWorkers() = 2
[16:03:13.294] MulticoreFuture:
[16:03:13.294] Label: ‘future_vapply-2’
[16:03:13.294] Expression:
[16:03:13.294] {
[16:03:13.294]     do.call(function(...) {
[16:03:13.294]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.294]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.294]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.294]             on.exit(options(oopts), add = TRUE)
[16:03:13.294]         }
[16:03:13.294]         {
[16:03:13.294]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.294]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.294]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.294]             })
[16:03:13.294]         }
[16:03:13.294]     }, args = future.call.arguments)
[16:03:13.294] }
[16:03:13.294] Lazy evaluation: FALSE
[16:03:13.294] Asynchronous evaluation: TRUE
[16:03:13.294] Local evaluation: TRUE
[16:03:13.294] Environment: R_GlobalEnv
[16:03:13.294] Capture standard output: TRUE
[16:03:13.294] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.294] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.294] Packages: 1 packages (‘future.apply’)
[16:03:13.294] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.294] Resolved: TRUE
[16:03:13.294] Value: <not collected>
[16:03:13.294] Conditions captured: <none>
[16:03:13.294] Early signaling: FALSE
[16:03:13.294] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.294] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.304] Chunk #2 of 2 ... DONE
[16:03:13.304] Launching 2 futures (chunks) ... DONE
[16:03:13.304] Resolving 2 futures (chunks) ...
[16:03:13.305] resolve() on list ...
[16:03:13.305]  recursive: 0
[16:03:13.305]  length: 2
[16:03:13.305] 
[16:03:13.305] Future #1
[16:03:13.306] result() for MulticoreFuture ...
[16:03:13.308] result() for MulticoreFuture ...
[16:03:13.308] result() for MulticoreFuture ... done
[16:03:13.308] result() for MulticoreFuture ... done
[16:03:13.308] result() for MulticoreFuture ...
[16:03:13.309] result() for MulticoreFuture ... done
[16:03:13.309] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:13.309] - nx: 2
[16:03:13.309] - relay: TRUE
[16:03:13.309] - stdout: TRUE
[16:03:13.309] - signal: TRUE
[16:03:13.310] - resignal: FALSE
[16:03:13.310] - force: TRUE
[16:03:13.310] - relayed: [n=2] FALSE, FALSE
[16:03:13.310] - queued futures: [n=2] FALSE, FALSE
[16:03:13.310]  - until=1
[16:03:13.310]  - relaying element #1
[16:03:13.310] result() for MulticoreFuture ...
[16:03:13.311] result() for MulticoreFuture ... done
[16:03:13.311] result() for MulticoreFuture ...
[16:03:13.311] result() for MulticoreFuture ... done
[16:03:13.311] result() for MulticoreFuture ...
[16:03:13.311] result() for MulticoreFuture ... done
[16:03:13.312] result() for MulticoreFuture ...
[16:03:13.312] result() for MulticoreFuture ... done
[16:03:13.312] - relayed: [n=2] TRUE, FALSE
[16:03:13.312] - queued futures: [n=2] TRUE, FALSE
[16:03:13.312] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:13.312]  length: 1 (resolved future 1)
[16:03:13.313] Future #2
[16:03:13.313] result() for MulticoreFuture ...
[16:03:13.313] result() for MulticoreFuture ...
[16:03:13.314] result() for MulticoreFuture ... done
[16:03:13.314] result() for MulticoreFuture ... done
[16:03:13.314] result() for MulticoreFuture ...
[16:03:13.314] result() for MulticoreFuture ... done
[16:03:13.314] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:13.314] - nx: 2
[16:03:13.314] - relay: TRUE
[16:03:13.315] - stdout: TRUE
[16:03:13.315] - signal: TRUE
[16:03:13.315] - resignal: FALSE
[16:03:13.315] - force: TRUE
[16:03:13.315] - relayed: [n=2] TRUE, FALSE
[16:03:13.315] - queued futures: [n=2] TRUE, FALSE
[16:03:13.315]  - until=2
[16:03:13.315]  - relaying element #2
[16:03:13.316] result() for MulticoreFuture ...
[16:03:13.316] result() for MulticoreFuture ... done
[16:03:13.316] result() for MulticoreFuture ...
[16:03:13.316] result() for MulticoreFuture ... done
[16:03:13.316] result() for MulticoreFuture ...
[16:03:13.316] result() for MulticoreFuture ... done
[16:03:13.316] result() for MulticoreFuture ...
[16:03:13.316] result() for MulticoreFuture ... done
[16:03:13.316] - relayed: [n=2] TRUE, TRUE
[16:03:13.317] - queued futures: [n=2] TRUE, TRUE
[16:03:13.317] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:13.317]  length: 0 (resolved future 2)
[16:03:13.317] Relaying remaining futures
[16:03:13.317] signalConditionsASAP(NULL, pos=0) ...
[16:03:13.317] - nx: 2
[16:03:13.317] - relay: TRUE
[16:03:13.317] - stdout: TRUE
[16:03:13.317] - signal: TRUE
[16:03:13.318] - resignal: FALSE
[16:03:13.318] - force: TRUE
[16:03:13.318] - relayed: [n=2] TRUE, TRUE
[16:03:13.318] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:13.318] - relayed: [n=2] TRUE, TRUE
[16:03:13.318] - queued futures: [n=2] TRUE, TRUE
[16:03:13.318] signalConditionsASAP(NULL, pos=0) ... done
[16:03:13.318] resolve() on list ... DONE
[16:03:13.318] result() for MulticoreFuture ...
[16:03:13.319] result() for MulticoreFuture ... done
[16:03:13.319] result() for MulticoreFuture ...
[16:03:13.319] result() for MulticoreFuture ... done
[16:03:13.319] result() for MulticoreFuture ...
[16:03:13.319] result() for MulticoreFuture ... done
[16:03:13.319] result() for MulticoreFuture ...
[16:03:13.319] result() for MulticoreFuture ... done
[16:03:13.319]  - Number of value chunks collected: 2
[16:03:13.320] Resolving 2 futures (chunks) ... DONE
[16:03:13.320] Reducing values from 2 chunks ...
[16:03:13.320]  - Number of values collected after concatenation: 2
[16:03:13.320]  - Number of values expected: 2
[16:03:13.320] Reducing values from 2 chunks ... DONE
[16:03:13.320] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[16:03:13.321] future_lapply() ...
[16:03:13.330] Number of chunks: 2
[16:03:13.330] getGlobalsAndPackagesXApply() ...
[16:03:13.331]  - future.globals: TRUE
[16:03:13.331] getGlobalsAndPackages() ...
[16:03:13.331] Searching for globals...
[16:03:13.335] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[16:03:13.335] Searching for globals ... DONE
[16:03:13.335] Resolving globals: FALSE
[16:03:13.336] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[16:03:13.337] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:13.337] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.337] - packages: [1] ‘future.apply’
[16:03:13.337] getGlobalsAndPackages() ... DONE
[16:03:13.337]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.337]  - needed namespaces: [n=1] ‘future.apply’
[16:03:13.338] Finding globals ... DONE
[16:03:13.338]  - use_args: TRUE
[16:03:13.338]  - Getting '...' globals ...
[16:03:13.338] resolve() on list ...
[16:03:13.338]  recursive: 0
[16:03:13.338]  length: 1
[16:03:13.338]  elements: ‘...’
[16:03:13.338]  length: 0 (resolved future 1)
[16:03:13.339] resolve() on list ... DONE
[16:03:13.339]    - '...' content: [n=0] 
[16:03:13.339] List of 1
[16:03:13.339]  $ ...: list()
[16:03:13.339]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.339]  - attr(*, "where")=List of 1
[16:03:13.339]   ..$ ...:<environment: 0x564e42ea4868> 
[16:03:13.339]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.339]  - attr(*, "resolved")= logi TRUE
[16:03:13.339]  - attr(*, "total_size")= num NA
[16:03:13.341]  - Getting '...' globals ... DONE
[16:03:13.342] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:13.342] List of 8
[16:03:13.342]  $ ...future.FUN:function (x, ...)  
[16:03:13.342]  $ x_FUN        :function (x)  
[16:03:13.342]  $ times        : int 0
[16:03:13.342]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.342]  $ stop_if_not  :function (...)  
[16:03:13.342]  $ dim          : NULL
[16:03:13.342]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:13.342]  $ ...          : list()
[16:03:13.342]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.342]  - attr(*, "where")=List of 8
[16:03:13.342]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:13.342]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:13.342]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:13.342]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:13.342]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:13.342]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:13.342]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:13.342]   ..$ ...          :<environment: 0x564e42ea4868> 
[16:03:13.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.342]  - attr(*, "resolved")= logi FALSE
[16:03:13.342]  - attr(*, "total_size")= num 95472
[16:03:13.347] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:13.347] getGlobalsAndPackagesXApply() ... DONE
[16:03:13.349] Number of futures (= number of chunks): 2
[16:03:13.349] Launching 2 futures (chunks) ...
[16:03:13.349] Chunk #1 of 2 ...
[16:03:13.350]  - Finding globals in 'X' for chunk #1 ...
[16:03:13.350] getGlobalsAndPackages() ...
[16:03:13.350] Searching for globals...
[16:03:13.350] 
[16:03:13.350] Searching for globals ... DONE
[16:03:13.350] - globals: [0] <none>
[16:03:13.350] getGlobalsAndPackages() ... DONE
[16:03:13.350]    + additional globals found: [n=0] 
[16:03:13.351]    + additional namespaces needed: [n=0] 
[16:03:13.351]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:13.351]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.351]  - seeds: <none>
[16:03:13.351]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.351] getGlobalsAndPackages() ...
[16:03:13.351] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.351] Resolving globals: FALSE
[16:03:13.352] Tweak future expression to call with '...' arguments ...
[16:03:13.352] {
[16:03:13.352]     do.call(function(...) {
[16:03:13.352]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.352]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.352]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.352]             on.exit(options(oopts), add = TRUE)
[16:03:13.352]         }
[16:03:13.352]         {
[16:03:13.352]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.352]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.352]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.352]             })
[16:03:13.352]         }
[16:03:13.352]     }, args = future.call.arguments)
[16:03:13.352] }
[16:03:13.352] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.353] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.353] - packages: [1] ‘future.apply’
[16:03:13.353] getGlobalsAndPackages() ... DONE
[16:03:13.353] run() for ‘Future’ ...
[16:03:13.353] - state: ‘created’
[16:03:13.353] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.358] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.358] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.358]   - Field: ‘label’
[16:03:13.358]   - Field: ‘local’
[16:03:13.358]   - Field: ‘owner’
[16:03:13.358]   - Field: ‘envir’
[16:03:13.358]   - Field: ‘workers’
[16:03:13.358]   - Field: ‘packages’
[16:03:13.359]   - Field: ‘gc’
[16:03:13.359]   - Field: ‘job’
[16:03:13.359]   - Field: ‘conditions’
[16:03:13.359]   - Field: ‘expr’
[16:03:13.359]   - Field: ‘uuid’
[16:03:13.359]   - Field: ‘seed’
[16:03:13.359]   - Field: ‘version’
[16:03:13.359]   - Field: ‘result’
[16:03:13.359]   - Field: ‘asynchronous’
[16:03:13.360]   - Field: ‘calls’
[16:03:13.360]   - Field: ‘globals’
[16:03:13.360]   - Field: ‘stdout’
[16:03:13.360]   - Field: ‘earlySignal’
[16:03:13.360]   - Field: ‘lazy’
[16:03:13.360]   - Field: ‘state’
[16:03:13.360] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.360] - Launch lazy future ...
[16:03:13.361] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.361] Packages needed by future strategies (n = 0): <none>
[16:03:13.361] {
[16:03:13.361]     {
[16:03:13.361]         {
[16:03:13.361]             ...future.startTime <- base::Sys.time()
[16:03:13.361]             {
[16:03:13.361]                 {
[16:03:13.361]                   {
[16:03:13.361]                     {
[16:03:13.361]                       {
[16:03:13.361]                         base::local({
[16:03:13.361]                           has_future <- base::requireNamespace("future", 
[16:03:13.361]                             quietly = TRUE)
[16:03:13.361]                           if (has_future) {
[16:03:13.361]                             ns <- base::getNamespace("future")
[16:03:13.361]                             version <- ns[[".package"]][["version"]]
[16:03:13.361]                             if (is.null(version)) 
[16:03:13.361]                               version <- utils::packageVersion("future")
[16:03:13.361]                           }
[16:03:13.361]                           else {
[16:03:13.361]                             version <- NULL
[16:03:13.361]                           }
[16:03:13.361]                           if (!has_future || version < "1.8.0") {
[16:03:13.361]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.361]                               "", base::R.version$version.string), 
[16:03:13.361]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.361]                                 base::R.version$platform, 8 * 
[16:03:13.361]                                   base::.Machine$sizeof.pointer), 
[16:03:13.361]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.361]                                 "release", "version")], collapse = " "), 
[16:03:13.361]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.361]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.361]                               info)
[16:03:13.361]                             info <- base::paste(info, collapse = "; ")
[16:03:13.361]                             if (!has_future) {
[16:03:13.361]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.361]                                 info)
[16:03:13.361]                             }
[16:03:13.361]                             else {
[16:03:13.361]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.361]                                 info, version)
[16:03:13.361]                             }
[16:03:13.361]                             base::stop(msg)
[16:03:13.361]                           }
[16:03:13.361]                         })
[16:03:13.361]                       }
[16:03:13.361]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.361]                       base::options(mc.cores = 1L)
[16:03:13.361]                     }
[16:03:13.361]                     base::local({
[16:03:13.361]                       for (pkg in "future.apply") {
[16:03:13.361]                         base::loadNamespace(pkg)
[16:03:13.361]                         base::library(pkg, character.only = TRUE)
[16:03:13.361]                       }
[16:03:13.361]                     })
[16:03:13.361]                   }
[16:03:13.361]                   options(future.plan = NULL)
[16:03:13.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.361]                 }
[16:03:13.361]                 ...future.workdir <- getwd()
[16:03:13.361]             }
[16:03:13.361]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.361]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.361]         }
[16:03:13.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.361]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.361]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.361]             base::names(...future.oldOptions))
[16:03:13.361]     }
[16:03:13.361]     if (FALSE) {
[16:03:13.361]     }
[16:03:13.361]     else {
[16:03:13.361]         if (TRUE) {
[16:03:13.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.361]                 open = "w")
[16:03:13.361]         }
[16:03:13.361]         else {
[16:03:13.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.361]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.361]         }
[16:03:13.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.361]             base::sink(type = "output", split = FALSE)
[16:03:13.361]             base::close(...future.stdout)
[16:03:13.361]         }, add = TRUE)
[16:03:13.361]     }
[16:03:13.361]     ...future.frame <- base::sys.nframe()
[16:03:13.361]     ...future.conditions <- base::list()
[16:03:13.361]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.361]     if (FALSE) {
[16:03:13.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.361]     }
[16:03:13.361]     ...future.result <- base::tryCatch({
[16:03:13.361]         base::withCallingHandlers({
[16:03:13.361]             ...future.value <- base::withVisible(base::local({
[16:03:13.361]                 withCallingHandlers({
[16:03:13.361]                   {
[16:03:13.361]                     do.call(function(...) {
[16:03:13.361]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.361]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.361]                         ...future.globals.maxSize)) {
[16:03:13.361]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.361]                         on.exit(options(oopts), add = TRUE)
[16:03:13.361]                       }
[16:03:13.361]                       {
[16:03:13.361]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.361]                           FUN = function(jj) {
[16:03:13.361]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.361]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.361]                           })
[16:03:13.361]                       }
[16:03:13.361]                     }, args = future.call.arguments)
[16:03:13.361]                   }
[16:03:13.361]                 }, immediateCondition = function(cond) {
[16:03:13.361]                   save_rds <- function (object, pathname, ...) 
[16:03:13.361]                   {
[16:03:13.361]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.361]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.361]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.361]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.361]                         fi_tmp[["mtime"]])
[16:03:13.361]                     }
[16:03:13.361]                     tryCatch({
[16:03:13.361]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.361]                     }, error = function(ex) {
[16:03:13.361]                       msg <- conditionMessage(ex)
[16:03:13.361]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.361]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.361]                         fi_tmp[["mtime"]], msg)
[16:03:13.361]                       ex$message <- msg
[16:03:13.361]                       stop(ex)
[16:03:13.361]                     })
[16:03:13.361]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.361]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.361]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.361]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.361]                       fi <- file.info(pathname)
[16:03:13.361]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.361]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.361]                         fi[["size"]], fi[["mtime"]])
[16:03:13.361]                       stop(msg)
[16:03:13.361]                     }
[16:03:13.361]                     invisible(pathname)
[16:03:13.361]                   }
[16:03:13.361]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.361]                     rootPath = tempdir()) 
[16:03:13.361]                   {
[16:03:13.361]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.361]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.361]                       tmpdir = path, fileext = ".rds")
[16:03:13.361]                     save_rds(obj, file)
[16:03:13.361]                   }
[16:03:13.361]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.361]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.361]                   {
[16:03:13.361]                     inherits <- base::inherits
[16:03:13.361]                     invokeRestart <- base::invokeRestart
[16:03:13.361]                     is.null <- base::is.null
[16:03:13.361]                     muffled <- FALSE
[16:03:13.361]                     if (inherits(cond, "message")) {
[16:03:13.361]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.361]                       if (muffled) 
[16:03:13.361]                         invokeRestart("muffleMessage")
[16:03:13.361]                     }
[16:03:13.361]                     else if (inherits(cond, "warning")) {
[16:03:13.361]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.361]                       if (muffled) 
[16:03:13.361]                         invokeRestart("muffleWarning")
[16:03:13.361]                     }
[16:03:13.361]                     else if (inherits(cond, "condition")) {
[16:03:13.361]                       if (!is.null(pattern)) {
[16:03:13.361]                         computeRestarts <- base::computeRestarts
[16:03:13.361]                         grepl <- base::grepl
[16:03:13.361]                         restarts <- computeRestarts(cond)
[16:03:13.361]                         for (restart in restarts) {
[16:03:13.361]                           name <- restart$name
[16:03:13.361]                           if (is.null(name)) 
[16:03:13.361]                             next
[16:03:13.361]                           if (!grepl(pattern, name)) 
[16:03:13.361]                             next
[16:03:13.361]                           invokeRestart(restart)
[16:03:13.361]                           muffled <- TRUE
[16:03:13.361]                           break
[16:03:13.361]                         }
[16:03:13.361]                       }
[16:03:13.361]                     }
[16:03:13.361]                     invisible(muffled)
[16:03:13.361]                   }
[16:03:13.361]                   muffleCondition(cond)
[16:03:13.361]                 })
[16:03:13.361]             }))
[16:03:13.361]             future::FutureResult(value = ...future.value$value, 
[16:03:13.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.361]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.361]                     ...future.globalenv.names))
[16:03:13.361]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.361]         }, condition = base::local({
[16:03:13.361]             c <- base::c
[16:03:13.361]             inherits <- base::inherits
[16:03:13.361]             invokeRestart <- base::invokeRestart
[16:03:13.361]             length <- base::length
[16:03:13.361]             list <- base::list
[16:03:13.361]             seq.int <- base::seq.int
[16:03:13.361]             signalCondition <- base::signalCondition
[16:03:13.361]             sys.calls <- base::sys.calls
[16:03:13.361]             `[[` <- base::`[[`
[16:03:13.361]             `+` <- base::`+`
[16:03:13.361]             `<<-` <- base::`<<-`
[16:03:13.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.361]                   3L)]
[16:03:13.361]             }
[16:03:13.361]             function(cond) {
[16:03:13.361]                 is_error <- inherits(cond, "error")
[16:03:13.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.361]                   NULL)
[16:03:13.361]                 if (is_error) {
[16:03:13.361]                   sessionInformation <- function() {
[16:03:13.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.361]                       search = base::search(), system = base::Sys.info())
[16:03:13.361]                   }
[16:03:13.361]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.361]                     cond$call), session = sessionInformation(), 
[16:03:13.361]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.361]                   signalCondition(cond)
[16:03:13.361]                 }
[16:03:13.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.361]                 "immediateCondition"))) {
[16:03:13.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.361]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.361]                   if (TRUE && !signal) {
[16:03:13.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.361]                     {
[16:03:13.361]                       inherits <- base::inherits
[16:03:13.361]                       invokeRestart <- base::invokeRestart
[16:03:13.361]                       is.null <- base::is.null
[16:03:13.361]                       muffled <- FALSE
[16:03:13.361]                       if (inherits(cond, "message")) {
[16:03:13.361]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.361]                         if (muffled) 
[16:03:13.361]                           invokeRestart("muffleMessage")
[16:03:13.361]                       }
[16:03:13.361]                       else if (inherits(cond, "warning")) {
[16:03:13.361]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.361]                         if (muffled) 
[16:03:13.361]                           invokeRestart("muffleWarning")
[16:03:13.361]                       }
[16:03:13.361]                       else if (inherits(cond, "condition")) {
[16:03:13.361]                         if (!is.null(pattern)) {
[16:03:13.361]                           computeRestarts <- base::computeRestarts
[16:03:13.361]                           grepl <- base::grepl
[16:03:13.361]                           restarts <- computeRestarts(cond)
[16:03:13.361]                           for (restart in restarts) {
[16:03:13.361]                             name <- restart$name
[16:03:13.361]                             if (is.null(name)) 
[16:03:13.361]                               next
[16:03:13.361]                             if (!grepl(pattern, name)) 
[16:03:13.361]                               next
[16:03:13.361]                             invokeRestart(restart)
[16:03:13.361]                             muffled <- TRUE
[16:03:13.361]                             break
[16:03:13.361]                           }
[16:03:13.361]                         }
[16:03:13.361]                       }
[16:03:13.361]                       invisible(muffled)
[16:03:13.361]                     }
[16:03:13.361]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.361]                   }
[16:03:13.361]                 }
[16:03:13.361]                 else {
[16:03:13.361]                   if (TRUE) {
[16:03:13.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.361]                     {
[16:03:13.361]                       inherits <- base::inherits
[16:03:13.361]                       invokeRestart <- base::invokeRestart
[16:03:13.361]                       is.null <- base::is.null
[16:03:13.361]                       muffled <- FALSE
[16:03:13.361]                       if (inherits(cond, "message")) {
[16:03:13.361]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.361]                         if (muffled) 
[16:03:13.361]                           invokeRestart("muffleMessage")
[16:03:13.361]                       }
[16:03:13.361]                       else if (inherits(cond, "warning")) {
[16:03:13.361]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.361]                         if (muffled) 
[16:03:13.361]                           invokeRestart("muffleWarning")
[16:03:13.361]                       }
[16:03:13.361]                       else if (inherits(cond, "condition")) {
[16:03:13.361]                         if (!is.null(pattern)) {
[16:03:13.361]                           computeRestarts <- base::computeRestarts
[16:03:13.361]                           grepl <- base::grepl
[16:03:13.361]                           restarts <- computeRestarts(cond)
[16:03:13.361]                           for (restart in restarts) {
[16:03:13.361]                             name <- restart$name
[16:03:13.361]                             if (is.null(name)) 
[16:03:13.361]                               next
[16:03:13.361]                             if (!grepl(pattern, name)) 
[16:03:13.361]                               next
[16:03:13.361]                             invokeRestart(restart)
[16:03:13.361]                             muffled <- TRUE
[16:03:13.361]                             break
[16:03:13.361]                           }
[16:03:13.361]                         }
[16:03:13.361]                       }
[16:03:13.361]                       invisible(muffled)
[16:03:13.361]                     }
[16:03:13.361]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.361]                   }
[16:03:13.361]                 }
[16:03:13.361]             }
[16:03:13.361]         }))
[16:03:13.361]     }, error = function(ex) {
[16:03:13.361]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.361]                 ...future.rng), started = ...future.startTime, 
[16:03:13.361]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.361]             version = "1.8"), class = "FutureResult")
[16:03:13.361]     }, finally = {
[16:03:13.361]         if (!identical(...future.workdir, getwd())) 
[16:03:13.361]             setwd(...future.workdir)
[16:03:13.361]         {
[16:03:13.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.361]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.361]             }
[16:03:13.361]             base::options(...future.oldOptions)
[16:03:13.361]             if (.Platform$OS.type == "windows") {
[16:03:13.361]                 old_names <- names(...future.oldEnvVars)
[16:03:13.361]                 envs <- base::Sys.getenv()
[16:03:13.361]                 names <- names(envs)
[16:03:13.361]                 common <- intersect(names, old_names)
[16:03:13.361]                 added <- setdiff(names, old_names)
[16:03:13.361]                 removed <- setdiff(old_names, names)
[16:03:13.361]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.361]                   envs[common]]
[16:03:13.361]                 NAMES <- toupper(changed)
[16:03:13.361]                 args <- list()
[16:03:13.361]                 for (kk in seq_along(NAMES)) {
[16:03:13.361]                   name <- changed[[kk]]
[16:03:13.361]                   NAME <- NAMES[[kk]]
[16:03:13.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.361]                     next
[16:03:13.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.361]                 }
[16:03:13.361]                 NAMES <- toupper(added)
[16:03:13.361]                 for (kk in seq_along(NAMES)) {
[16:03:13.361]                   name <- added[[kk]]
[16:03:13.361]                   NAME <- NAMES[[kk]]
[16:03:13.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.361]                     next
[16:03:13.361]                   args[[name]] <- ""
[16:03:13.361]                 }
[16:03:13.361]                 NAMES <- toupper(removed)
[16:03:13.361]                 for (kk in seq_along(NAMES)) {
[16:03:13.361]                   name <- removed[[kk]]
[16:03:13.361]                   NAME <- NAMES[[kk]]
[16:03:13.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.361]                     next
[16:03:13.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.361]                 }
[16:03:13.361]                 if (length(args) > 0) 
[16:03:13.361]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.361]             }
[16:03:13.361]             else {
[16:03:13.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.361]             }
[16:03:13.361]             {
[16:03:13.361]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.361]                   0L) {
[16:03:13.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.361]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.361]                   base::options(opts)
[16:03:13.361]                 }
[16:03:13.361]                 {
[16:03:13.361]                   {
[16:03:13.361]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.361]                     NULL
[16:03:13.361]                   }
[16:03:13.361]                   options(future.plan = NULL)
[16:03:13.361]                   if (is.na(NA_character_)) 
[16:03:13.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.361]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.361]                     envir = parent.frame()) 
[16:03:13.361]                   {
[16:03:13.361]                     default_workers <- missing(workers)
[16:03:13.361]                     if (is.function(workers)) 
[16:03:13.361]                       workers <- workers()
[16:03:13.361]                     workers <- structure(as.integer(workers), 
[16:03:13.361]                       class = class(workers))
[16:03:13.361]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.361]                       1L)
[16:03:13.361]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.361]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.361]                       if (default_workers) 
[16:03:13.361]                         supportsMulticore(warn = TRUE)
[16:03:13.361]                       return(sequential(..., envir = envir))
[16:03:13.361]                     }
[16:03:13.361]                     oopts <- options(mc.cores = workers)
[16:03:13.361]                     on.exit(options(oopts))
[16:03:13.361]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.361]                       envir = envir)
[16:03:13.361]                     if (!future$lazy) 
[16:03:13.361]                       future <- run(future)
[16:03:13.361]                     invisible(future)
[16:03:13.361]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.361]                 }
[16:03:13.361]             }
[16:03:13.361]         }
[16:03:13.361]     })
[16:03:13.361]     if (TRUE) {
[16:03:13.361]         base::sink(type = "output", split = FALSE)
[16:03:13.361]         if (TRUE) {
[16:03:13.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.361]         }
[16:03:13.361]         else {
[16:03:13.361]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.361]         }
[16:03:13.361]         base::close(...future.stdout)
[16:03:13.361]         ...future.stdout <- NULL
[16:03:13.361]     }
[16:03:13.361]     ...future.result$conditions <- ...future.conditions
[16:03:13.361]     ...future.result$finished <- base::Sys.time()
[16:03:13.361]     ...future.result
[16:03:13.361] }
[16:03:13.364] assign_globals() ...
[16:03:13.364] List of 11
[16:03:13.364]  $ ...future.FUN            :function (x, ...)  
[16:03:13.364]  $ x_FUN                    :function (x)  
[16:03:13.364]  $ times                    : int 0
[16:03:13.364]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.364]  $ stop_if_not              :function (...)  
[16:03:13.364]  $ dim                      : NULL
[16:03:13.364]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:13.364]  $ future.call.arguments    : list()
[16:03:13.364]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.364]  $ ...future.elements_ii    :List of 5
[16:03:13.364]   ..$ : int 1
[16:03:13.364]   ..$ : int 2
[16:03:13.364]   ..$ : int 3
[16:03:13.364]   ..$ : int 4
[16:03:13.364]   ..$ : int 5
[16:03:13.364]  $ ...future.seeds_ii       : NULL
[16:03:13.364]  $ ...future.globals.maxSize: NULL
[16:03:13.364]  - attr(*, "where")=List of 11
[16:03:13.364]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.364]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.364]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.364]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.364]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.364]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.364]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.364]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.364]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.364]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.364]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.364]  - attr(*, "resolved")= logi FALSE
[16:03:13.364]  - attr(*, "total_size")= num 95472
[16:03:13.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.364]  - attr(*, "already-done")= logi TRUE
[16:03:13.372] - copied ‘...future.FUN’ to environment
[16:03:13.373] - reassign environment for ‘x_FUN’
[16:03:13.373] - copied ‘x_FUN’ to environment
[16:03:13.373] - copied ‘times’ to environment
[16:03:13.373] - copied ‘stopf’ to environment
[16:03:13.373] - copied ‘stop_if_not’ to environment
[16:03:13.373] - copied ‘dim’ to environment
[16:03:13.373] - copied ‘valid_types’ to environment
[16:03:13.373] - copied ‘future.call.arguments’ to environment
[16:03:13.373] - copied ‘...future.elements_ii’ to environment
[16:03:13.373] - copied ‘...future.seeds_ii’ to environment
[16:03:13.374] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.374] assign_globals() ... done
[16:03:13.374] requestCore(): workers = 2
[16:03:13.380] MulticoreFuture started
[16:03:13.380] - Launch lazy future ... done
[16:03:13.381] run() for ‘MulticoreFuture’ ... done
[16:03:13.381] Created future:
[16:03:13.381] plan(): Setting new future strategy stack:
[16:03:13.382] List of future strategies:
[16:03:13.382] 1. sequential:
[16:03:13.382]    - args: function (..., envir = parent.frame())
[16:03:13.382]    - tweaked: FALSE
[16:03:13.382]    - call: NULL
[16:03:13.383] plan(): nbrOfWorkers() = 1
[16:03:13.386] plan(): Setting new future strategy stack:
[16:03:13.386] List of future strategies:
[16:03:13.386] 1. multicore:
[16:03:13.386]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.386]    - tweaked: FALSE
[16:03:13.386]    - call: plan(strategy)
[16:03:13.392] plan(): nbrOfWorkers() = 2
[16:03:13.382] MulticoreFuture:
[16:03:13.382] Label: ‘future_vapply-1’
[16:03:13.382] Expression:
[16:03:13.382] {
[16:03:13.382]     do.call(function(...) {
[16:03:13.382]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.382]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.382]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.382]             on.exit(options(oopts), add = TRUE)
[16:03:13.382]         }
[16:03:13.382]         {
[16:03:13.382]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.382]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.382]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.382]             })
[16:03:13.382]         }
[16:03:13.382]     }, args = future.call.arguments)
[16:03:13.382] }
[16:03:13.382] Lazy evaluation: FALSE
[16:03:13.382] Asynchronous evaluation: TRUE
[16:03:13.382] Local evaluation: TRUE
[16:03:13.382] Environment: R_GlobalEnv
[16:03:13.382] Capture standard output: TRUE
[16:03:13.382] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.382] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.382] Packages: 1 packages (‘future.apply’)
[16:03:13.382] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.382] Resolved: TRUE
[16:03:13.382] Value: <not collected>
[16:03:13.382] Conditions captured: <none>
[16:03:13.382] Early signaling: FALSE
[16:03:13.382] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.382] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.394] Chunk #1 of 2 ... DONE
[16:03:13.394] Chunk #2 of 2 ...
[16:03:13.394]  - Finding globals in 'X' for chunk #2 ...
[16:03:13.394] getGlobalsAndPackages() ...
[16:03:13.395] Searching for globals...
[16:03:13.395] 
[16:03:13.395] Searching for globals ... DONE
[16:03:13.396] - globals: [0] <none>
[16:03:13.396] getGlobalsAndPackages() ... DONE
[16:03:13.396]    + additional globals found: [n=0] 
[16:03:13.396]    + additional namespaces needed: [n=0] 
[16:03:13.396]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:13.396]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.397]  - seeds: <none>
[16:03:13.397]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.397] getGlobalsAndPackages() ...
[16:03:13.397] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.398] Resolving globals: FALSE
[16:03:13.398] Tweak future expression to call with '...' arguments ...
[16:03:13.398] {
[16:03:13.398]     do.call(function(...) {
[16:03:13.398]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.398]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.398]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.398]             on.exit(options(oopts), add = TRUE)
[16:03:13.398]         }
[16:03:13.398]         {
[16:03:13.398]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.398]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.398]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.398]             })
[16:03:13.398]         }
[16:03:13.398]     }, args = future.call.arguments)
[16:03:13.398] }
[16:03:13.399] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.399] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.400] - packages: [1] ‘future.apply’
[16:03:13.400] getGlobalsAndPackages() ... DONE
[16:03:13.400] run() for ‘Future’ ...
[16:03:13.400] - state: ‘created’
[16:03:13.401] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.405] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.406]   - Field: ‘label’
[16:03:13.406]   - Field: ‘local’
[16:03:13.406]   - Field: ‘owner’
[16:03:13.406]   - Field: ‘envir’
[16:03:13.406]   - Field: ‘workers’
[16:03:13.407]   - Field: ‘packages’
[16:03:13.407]   - Field: ‘gc’
[16:03:13.407]   - Field: ‘job’
[16:03:13.407]   - Field: ‘conditions’
[16:03:13.407]   - Field: ‘expr’
[16:03:13.407]   - Field: ‘uuid’
[16:03:13.407]   - Field: ‘seed’
[16:03:13.408]   - Field: ‘version’
[16:03:13.408]   - Field: ‘result’
[16:03:13.408]   - Field: ‘asynchronous’
[16:03:13.408]   - Field: ‘calls’
[16:03:13.408]   - Field: ‘globals’
[16:03:13.408]   - Field: ‘stdout’
[16:03:13.408]   - Field: ‘earlySignal’
[16:03:13.408]   - Field: ‘lazy’
[16:03:13.409]   - Field: ‘state’
[16:03:13.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.409] - Launch lazy future ...
[16:03:13.409] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.409] Packages needed by future strategies (n = 0): <none>
[16:03:13.410] {
[16:03:13.410]     {
[16:03:13.410]         {
[16:03:13.410]             ...future.startTime <- base::Sys.time()
[16:03:13.410]             {
[16:03:13.410]                 {
[16:03:13.410]                   {
[16:03:13.410]                     {
[16:03:13.410]                       {
[16:03:13.410]                         base::local({
[16:03:13.410]                           has_future <- base::requireNamespace("future", 
[16:03:13.410]                             quietly = TRUE)
[16:03:13.410]                           if (has_future) {
[16:03:13.410]                             ns <- base::getNamespace("future")
[16:03:13.410]                             version <- ns[[".package"]][["version"]]
[16:03:13.410]                             if (is.null(version)) 
[16:03:13.410]                               version <- utils::packageVersion("future")
[16:03:13.410]                           }
[16:03:13.410]                           else {
[16:03:13.410]                             version <- NULL
[16:03:13.410]                           }
[16:03:13.410]                           if (!has_future || version < "1.8.0") {
[16:03:13.410]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.410]                               "", base::R.version$version.string), 
[16:03:13.410]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.410]                                 base::R.version$platform, 8 * 
[16:03:13.410]                                   base::.Machine$sizeof.pointer), 
[16:03:13.410]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.410]                                 "release", "version")], collapse = " "), 
[16:03:13.410]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.410]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.410]                               info)
[16:03:13.410]                             info <- base::paste(info, collapse = "; ")
[16:03:13.410]                             if (!has_future) {
[16:03:13.410]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.410]                                 info)
[16:03:13.410]                             }
[16:03:13.410]                             else {
[16:03:13.410]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.410]                                 info, version)
[16:03:13.410]                             }
[16:03:13.410]                             base::stop(msg)
[16:03:13.410]                           }
[16:03:13.410]                         })
[16:03:13.410]                       }
[16:03:13.410]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.410]                       base::options(mc.cores = 1L)
[16:03:13.410]                     }
[16:03:13.410]                     base::local({
[16:03:13.410]                       for (pkg in "future.apply") {
[16:03:13.410]                         base::loadNamespace(pkg)
[16:03:13.410]                         base::library(pkg, character.only = TRUE)
[16:03:13.410]                       }
[16:03:13.410]                     })
[16:03:13.410]                   }
[16:03:13.410]                   options(future.plan = NULL)
[16:03:13.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.410]                 }
[16:03:13.410]                 ...future.workdir <- getwd()
[16:03:13.410]             }
[16:03:13.410]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.410]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.410]         }
[16:03:13.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.410]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.410]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.410]             base::names(...future.oldOptions))
[16:03:13.410]     }
[16:03:13.410]     if (FALSE) {
[16:03:13.410]     }
[16:03:13.410]     else {
[16:03:13.410]         if (TRUE) {
[16:03:13.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.410]                 open = "w")
[16:03:13.410]         }
[16:03:13.410]         else {
[16:03:13.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.410]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.410]         }
[16:03:13.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.410]             base::sink(type = "output", split = FALSE)
[16:03:13.410]             base::close(...future.stdout)
[16:03:13.410]         }, add = TRUE)
[16:03:13.410]     }
[16:03:13.410]     ...future.frame <- base::sys.nframe()
[16:03:13.410]     ...future.conditions <- base::list()
[16:03:13.410]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.410]     if (FALSE) {
[16:03:13.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.410]     }
[16:03:13.410]     ...future.result <- base::tryCatch({
[16:03:13.410]         base::withCallingHandlers({
[16:03:13.410]             ...future.value <- base::withVisible(base::local({
[16:03:13.410]                 withCallingHandlers({
[16:03:13.410]                   {
[16:03:13.410]                     do.call(function(...) {
[16:03:13.410]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.410]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.410]                         ...future.globals.maxSize)) {
[16:03:13.410]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.410]                         on.exit(options(oopts), add = TRUE)
[16:03:13.410]                       }
[16:03:13.410]                       {
[16:03:13.410]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.410]                           FUN = function(jj) {
[16:03:13.410]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.410]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.410]                           })
[16:03:13.410]                       }
[16:03:13.410]                     }, args = future.call.arguments)
[16:03:13.410]                   }
[16:03:13.410]                 }, immediateCondition = function(cond) {
[16:03:13.410]                   save_rds <- function (object, pathname, ...) 
[16:03:13.410]                   {
[16:03:13.410]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.410]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.410]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.410]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.410]                         fi_tmp[["mtime"]])
[16:03:13.410]                     }
[16:03:13.410]                     tryCatch({
[16:03:13.410]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.410]                     }, error = function(ex) {
[16:03:13.410]                       msg <- conditionMessage(ex)
[16:03:13.410]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.410]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.410]                         fi_tmp[["mtime"]], msg)
[16:03:13.410]                       ex$message <- msg
[16:03:13.410]                       stop(ex)
[16:03:13.410]                     })
[16:03:13.410]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.410]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.410]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.410]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.410]                       fi <- file.info(pathname)
[16:03:13.410]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.410]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.410]                         fi[["size"]], fi[["mtime"]])
[16:03:13.410]                       stop(msg)
[16:03:13.410]                     }
[16:03:13.410]                     invisible(pathname)
[16:03:13.410]                   }
[16:03:13.410]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.410]                     rootPath = tempdir()) 
[16:03:13.410]                   {
[16:03:13.410]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.410]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.410]                       tmpdir = path, fileext = ".rds")
[16:03:13.410]                     save_rds(obj, file)
[16:03:13.410]                   }
[16:03:13.410]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.410]                   {
[16:03:13.410]                     inherits <- base::inherits
[16:03:13.410]                     invokeRestart <- base::invokeRestart
[16:03:13.410]                     is.null <- base::is.null
[16:03:13.410]                     muffled <- FALSE
[16:03:13.410]                     if (inherits(cond, "message")) {
[16:03:13.410]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.410]                       if (muffled) 
[16:03:13.410]                         invokeRestart("muffleMessage")
[16:03:13.410]                     }
[16:03:13.410]                     else if (inherits(cond, "warning")) {
[16:03:13.410]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.410]                       if (muffled) 
[16:03:13.410]                         invokeRestart("muffleWarning")
[16:03:13.410]                     }
[16:03:13.410]                     else if (inherits(cond, "condition")) {
[16:03:13.410]                       if (!is.null(pattern)) {
[16:03:13.410]                         computeRestarts <- base::computeRestarts
[16:03:13.410]                         grepl <- base::grepl
[16:03:13.410]                         restarts <- computeRestarts(cond)
[16:03:13.410]                         for (restart in restarts) {
[16:03:13.410]                           name <- restart$name
[16:03:13.410]                           if (is.null(name)) 
[16:03:13.410]                             next
[16:03:13.410]                           if (!grepl(pattern, name)) 
[16:03:13.410]                             next
[16:03:13.410]                           invokeRestart(restart)
[16:03:13.410]                           muffled <- TRUE
[16:03:13.410]                           break
[16:03:13.410]                         }
[16:03:13.410]                       }
[16:03:13.410]                     }
[16:03:13.410]                     invisible(muffled)
[16:03:13.410]                   }
[16:03:13.410]                   muffleCondition(cond)
[16:03:13.410]                 })
[16:03:13.410]             }))
[16:03:13.410]             future::FutureResult(value = ...future.value$value, 
[16:03:13.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.410]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.410]                     ...future.globalenv.names))
[16:03:13.410]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.410]         }, condition = base::local({
[16:03:13.410]             c <- base::c
[16:03:13.410]             inherits <- base::inherits
[16:03:13.410]             invokeRestart <- base::invokeRestart
[16:03:13.410]             length <- base::length
[16:03:13.410]             list <- base::list
[16:03:13.410]             seq.int <- base::seq.int
[16:03:13.410]             signalCondition <- base::signalCondition
[16:03:13.410]             sys.calls <- base::sys.calls
[16:03:13.410]             `[[` <- base::`[[`
[16:03:13.410]             `+` <- base::`+`
[16:03:13.410]             `<<-` <- base::`<<-`
[16:03:13.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.410]                   3L)]
[16:03:13.410]             }
[16:03:13.410]             function(cond) {
[16:03:13.410]                 is_error <- inherits(cond, "error")
[16:03:13.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.410]                   NULL)
[16:03:13.410]                 if (is_error) {
[16:03:13.410]                   sessionInformation <- function() {
[16:03:13.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.410]                       search = base::search(), system = base::Sys.info())
[16:03:13.410]                   }
[16:03:13.410]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.410]                     cond$call), session = sessionInformation(), 
[16:03:13.410]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.410]                   signalCondition(cond)
[16:03:13.410]                 }
[16:03:13.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.410]                 "immediateCondition"))) {
[16:03:13.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.410]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.410]                   if (TRUE && !signal) {
[16:03:13.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.410]                     {
[16:03:13.410]                       inherits <- base::inherits
[16:03:13.410]                       invokeRestart <- base::invokeRestart
[16:03:13.410]                       is.null <- base::is.null
[16:03:13.410]                       muffled <- FALSE
[16:03:13.410]                       if (inherits(cond, "message")) {
[16:03:13.410]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.410]                         if (muffled) 
[16:03:13.410]                           invokeRestart("muffleMessage")
[16:03:13.410]                       }
[16:03:13.410]                       else if (inherits(cond, "warning")) {
[16:03:13.410]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.410]                         if (muffled) 
[16:03:13.410]                           invokeRestart("muffleWarning")
[16:03:13.410]                       }
[16:03:13.410]                       else if (inherits(cond, "condition")) {
[16:03:13.410]                         if (!is.null(pattern)) {
[16:03:13.410]                           computeRestarts <- base::computeRestarts
[16:03:13.410]                           grepl <- base::grepl
[16:03:13.410]                           restarts <- computeRestarts(cond)
[16:03:13.410]                           for (restart in restarts) {
[16:03:13.410]                             name <- restart$name
[16:03:13.410]                             if (is.null(name)) 
[16:03:13.410]                               next
[16:03:13.410]                             if (!grepl(pattern, name)) 
[16:03:13.410]                               next
[16:03:13.410]                             invokeRestart(restart)
[16:03:13.410]                             muffled <- TRUE
[16:03:13.410]                             break
[16:03:13.410]                           }
[16:03:13.410]                         }
[16:03:13.410]                       }
[16:03:13.410]                       invisible(muffled)
[16:03:13.410]                     }
[16:03:13.410]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.410]                   }
[16:03:13.410]                 }
[16:03:13.410]                 else {
[16:03:13.410]                   if (TRUE) {
[16:03:13.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.410]                     {
[16:03:13.410]                       inherits <- base::inherits
[16:03:13.410]                       invokeRestart <- base::invokeRestart
[16:03:13.410]                       is.null <- base::is.null
[16:03:13.410]                       muffled <- FALSE
[16:03:13.410]                       if (inherits(cond, "message")) {
[16:03:13.410]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.410]                         if (muffled) 
[16:03:13.410]                           invokeRestart("muffleMessage")
[16:03:13.410]                       }
[16:03:13.410]                       else if (inherits(cond, "warning")) {
[16:03:13.410]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.410]                         if (muffled) 
[16:03:13.410]                           invokeRestart("muffleWarning")
[16:03:13.410]                       }
[16:03:13.410]                       else if (inherits(cond, "condition")) {
[16:03:13.410]                         if (!is.null(pattern)) {
[16:03:13.410]                           computeRestarts <- base::computeRestarts
[16:03:13.410]                           grepl <- base::grepl
[16:03:13.410]                           restarts <- computeRestarts(cond)
[16:03:13.410]                           for (restart in restarts) {
[16:03:13.410]                             name <- restart$name
[16:03:13.410]                             if (is.null(name)) 
[16:03:13.410]                               next
[16:03:13.410]                             if (!grepl(pattern, name)) 
[16:03:13.410]                               next
[16:03:13.410]                             invokeRestart(restart)
[16:03:13.410]                             muffled <- TRUE
[16:03:13.410]                             break
[16:03:13.410]                           }
[16:03:13.410]                         }
[16:03:13.410]                       }
[16:03:13.410]                       invisible(muffled)
[16:03:13.410]                     }
[16:03:13.410]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.410]                   }
[16:03:13.410]                 }
[16:03:13.410]             }
[16:03:13.410]         }))
[16:03:13.410]     }, error = function(ex) {
[16:03:13.410]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.410]                 ...future.rng), started = ...future.startTime, 
[16:03:13.410]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.410]             version = "1.8"), class = "FutureResult")
[16:03:13.410]     }, finally = {
[16:03:13.410]         if (!identical(...future.workdir, getwd())) 
[16:03:13.410]             setwd(...future.workdir)
[16:03:13.410]         {
[16:03:13.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.410]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.410]             }
[16:03:13.410]             base::options(...future.oldOptions)
[16:03:13.410]             if (.Platform$OS.type == "windows") {
[16:03:13.410]                 old_names <- names(...future.oldEnvVars)
[16:03:13.410]                 envs <- base::Sys.getenv()
[16:03:13.410]                 names <- names(envs)
[16:03:13.410]                 common <- intersect(names, old_names)
[16:03:13.410]                 added <- setdiff(names, old_names)
[16:03:13.410]                 removed <- setdiff(old_names, names)
[16:03:13.410]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.410]                   envs[common]]
[16:03:13.410]                 NAMES <- toupper(changed)
[16:03:13.410]                 args <- list()
[16:03:13.410]                 for (kk in seq_along(NAMES)) {
[16:03:13.410]                   name <- changed[[kk]]
[16:03:13.410]                   NAME <- NAMES[[kk]]
[16:03:13.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.410]                     next
[16:03:13.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.410]                 }
[16:03:13.410]                 NAMES <- toupper(added)
[16:03:13.410]                 for (kk in seq_along(NAMES)) {
[16:03:13.410]                   name <- added[[kk]]
[16:03:13.410]                   NAME <- NAMES[[kk]]
[16:03:13.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.410]                     next
[16:03:13.410]                   args[[name]] <- ""
[16:03:13.410]                 }
[16:03:13.410]                 NAMES <- toupper(removed)
[16:03:13.410]                 for (kk in seq_along(NAMES)) {
[16:03:13.410]                   name <- removed[[kk]]
[16:03:13.410]                   NAME <- NAMES[[kk]]
[16:03:13.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.410]                     next
[16:03:13.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.410]                 }
[16:03:13.410]                 if (length(args) > 0) 
[16:03:13.410]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.410]             }
[16:03:13.410]             else {
[16:03:13.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.410]             }
[16:03:13.410]             {
[16:03:13.410]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.410]                   0L) {
[16:03:13.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.410]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.410]                   base::options(opts)
[16:03:13.410]                 }
[16:03:13.410]                 {
[16:03:13.410]                   {
[16:03:13.410]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.410]                     NULL
[16:03:13.410]                   }
[16:03:13.410]                   options(future.plan = NULL)
[16:03:13.410]                   if (is.na(NA_character_)) 
[16:03:13.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.410]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.410]                     envir = parent.frame()) 
[16:03:13.410]                   {
[16:03:13.410]                     default_workers <- missing(workers)
[16:03:13.410]                     if (is.function(workers)) 
[16:03:13.410]                       workers <- workers()
[16:03:13.410]                     workers <- structure(as.integer(workers), 
[16:03:13.410]                       class = class(workers))
[16:03:13.410]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.410]                       1L)
[16:03:13.410]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.410]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.410]                       if (default_workers) 
[16:03:13.410]                         supportsMulticore(warn = TRUE)
[16:03:13.410]                       return(sequential(..., envir = envir))
[16:03:13.410]                     }
[16:03:13.410]                     oopts <- options(mc.cores = workers)
[16:03:13.410]                     on.exit(options(oopts))
[16:03:13.410]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.410]                       envir = envir)
[16:03:13.410]                     if (!future$lazy) 
[16:03:13.410]                       future <- run(future)
[16:03:13.410]                     invisible(future)
[16:03:13.410]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.410]                 }
[16:03:13.410]             }
[16:03:13.410]         }
[16:03:13.410]     })
[16:03:13.410]     if (TRUE) {
[16:03:13.410]         base::sink(type = "output", split = FALSE)
[16:03:13.410]         if (TRUE) {
[16:03:13.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.410]         }
[16:03:13.410]         else {
[16:03:13.410]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.410]         }
[16:03:13.410]         base::close(...future.stdout)
[16:03:13.410]         ...future.stdout <- NULL
[16:03:13.410]     }
[16:03:13.410]     ...future.result$conditions <- ...future.conditions
[16:03:13.410]     ...future.result$finished <- base::Sys.time()
[16:03:13.410]     ...future.result
[16:03:13.410] }
[16:03:13.413] assign_globals() ...
[16:03:13.413] List of 11
[16:03:13.413]  $ ...future.FUN            :function (x, ...)  
[16:03:13.413]  $ x_FUN                    :function (x)  
[16:03:13.413]  $ times                    : int 0
[16:03:13.413]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.413]  $ stop_if_not              :function (...)  
[16:03:13.413]  $ dim                      : NULL
[16:03:13.413]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:13.413]  $ future.call.arguments    : list()
[16:03:13.413]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.413]  $ ...future.elements_ii    :List of 5
[16:03:13.413]   ..$ : int 6
[16:03:13.413]   ..$ : int 7
[16:03:13.413]   ..$ : int 8
[16:03:13.413]   ..$ : int 9
[16:03:13.413]   ..$ : int 10
[16:03:13.413]  $ ...future.seeds_ii       : NULL
[16:03:13.413]  $ ...future.globals.maxSize: NULL
[16:03:13.413]  - attr(*, "where")=List of 11
[16:03:13.413]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.413]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.413]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.413]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.413]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.413]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.413]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.413]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.413]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.413]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.413]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.413]  - attr(*, "resolved")= logi FALSE
[16:03:13.413]  - attr(*, "total_size")= num 95472
[16:03:13.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.413]  - attr(*, "already-done")= logi TRUE
[16:03:13.423] - copied ‘...future.FUN’ to environment
[16:03:13.424] - reassign environment for ‘x_FUN’
[16:03:13.425] - copied ‘x_FUN’ to environment
[16:03:13.426] - copied ‘times’ to environment
[16:03:13.426] - copied ‘stopf’ to environment
[16:03:13.426] - copied ‘stop_if_not’ to environment
[16:03:13.426] - copied ‘dim’ to environment
[16:03:13.426] - copied ‘valid_types’ to environment
[16:03:13.426] - copied ‘future.call.arguments’ to environment
[16:03:13.426] - copied ‘...future.elements_ii’ to environment
[16:03:13.426] - copied ‘...future.seeds_ii’ to environment
[16:03:13.426] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.427] assign_globals() ... done
[16:03:13.427] requestCore(): workers = 2
[16:03:13.429] MulticoreFuture started
[16:03:13.430] - Launch lazy future ... done
[16:03:13.431] run() for ‘MulticoreFuture’ ... done
[16:03:13.432] Created future:
[16:03:13.432] plan(): Setting new future strategy stack:
[16:03:13.432] List of future strategies:
[16:03:13.432] 1. sequential:
[16:03:13.432]    - args: function (..., envir = parent.frame())
[16:03:13.432]    - tweaked: FALSE
[16:03:13.432]    - call: NULL
[16:03:13.433] plan(): nbrOfWorkers() = 1
[16:03:13.436] plan(): Setting new future strategy stack:
[16:03:13.436] List of future strategies:
[16:03:13.436] 1. multicore:
[16:03:13.436]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.436]    - tweaked: FALSE
[16:03:13.436]    - call: plan(strategy)
[16:03:13.442] plan(): nbrOfWorkers() = 2
[16:03:13.432] MulticoreFuture:
[16:03:13.432] Label: ‘future_vapply-2’
[16:03:13.432] Expression:
[16:03:13.432] {
[16:03:13.432]     do.call(function(...) {
[16:03:13.432]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.432]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.432]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.432]             on.exit(options(oopts), add = TRUE)
[16:03:13.432]         }
[16:03:13.432]         {
[16:03:13.432]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.432]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.432]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.432]             })
[16:03:13.432]         }
[16:03:13.432]     }, args = future.call.arguments)
[16:03:13.432] }
[16:03:13.432] Lazy evaluation: FALSE
[16:03:13.432] Asynchronous evaluation: TRUE
[16:03:13.432] Local evaluation: TRUE
[16:03:13.432] Environment: R_GlobalEnv
[16:03:13.432] Capture standard output: TRUE
[16:03:13.432] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.432] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.432] Packages: 1 packages (‘future.apply’)
[16:03:13.432] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.432] Resolved: TRUE
[16:03:13.432] Value: <not collected>
[16:03:13.432] Conditions captured: <none>
[16:03:13.432] Early signaling: FALSE
[16:03:13.432] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.432] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.444] Chunk #2 of 2 ... DONE
[16:03:13.444] Launching 2 futures (chunks) ... DONE
[16:03:13.444] Resolving 2 futures (chunks) ...
[16:03:13.444] resolve() on list ...
[16:03:13.445]  recursive: 0
[16:03:13.445]  length: 2
[16:03:13.445] 
[16:03:13.445] Future #1
[16:03:13.446] result() for MulticoreFuture ...
[16:03:13.446] result() for MulticoreFuture ...
[16:03:13.447] result() for MulticoreFuture ... done
[16:03:13.447] result() for MulticoreFuture ... done
[16:03:13.447] result() for MulticoreFuture ...
[16:03:13.447] result() for MulticoreFuture ... done
[16:03:13.447] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:13.448] - nx: 2
[16:03:13.448] - relay: TRUE
[16:03:13.448] - stdout: TRUE
[16:03:13.448] - signal: TRUE
[16:03:13.448] - resignal: FALSE
[16:03:13.448] - force: TRUE
[16:03:13.449] - relayed: [n=2] FALSE, FALSE
[16:03:13.449] - queued futures: [n=2] FALSE, FALSE
[16:03:13.449]  - until=1
[16:03:13.449]  - relaying element #1
[16:03:13.449] result() for MulticoreFuture ...
[16:03:13.450] result() for MulticoreFuture ... done
[16:03:13.450] result() for MulticoreFuture ...
[16:03:13.450] result() for MulticoreFuture ... done
[16:03:13.450] result() for MulticoreFuture ...
[16:03:13.450] result() for MulticoreFuture ... done
[16:03:13.451] result() for MulticoreFuture ...
[16:03:13.451] result() for MulticoreFuture ... done
[16:03:13.451] - relayed: [n=2] TRUE, FALSE
[16:03:13.451] - queued futures: [n=2] TRUE, FALSE
[16:03:13.451] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:13.451]  length: 1 (resolved future 1)
[16:03:13.452] Future #2
[16:03:13.452] result() for MulticoreFuture ...
[16:03:13.452] result() for MulticoreFuture ...
[16:03:13.453] result() for MulticoreFuture ... done
[16:03:13.453] result() for MulticoreFuture ... done
[16:03:13.453] result() for MulticoreFuture ...
[16:03:13.453] result() for MulticoreFuture ... done
[16:03:13.453] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:13.453] - nx: 2
[16:03:13.453] - relay: TRUE
[16:03:13.454] - stdout: TRUE
[16:03:13.454] - signal: TRUE
[16:03:13.454] - resignal: FALSE
[16:03:13.454] - force: TRUE
[16:03:13.454] - relayed: [n=2] TRUE, FALSE
[16:03:13.454] - queued futures: [n=2] TRUE, FALSE
[16:03:13.454]  - until=2
[16:03:13.454]  - relaying element #2
[16:03:13.454] result() for MulticoreFuture ...
[16:03:13.455] result() for MulticoreFuture ... done
[16:03:13.455] result() for MulticoreFuture ...
[16:03:13.455] result() for MulticoreFuture ... done
[16:03:13.455] result() for MulticoreFuture ...
[16:03:13.455] result() for MulticoreFuture ... done
[16:03:13.455] result() for MulticoreFuture ...
[16:03:13.455] result() for MulticoreFuture ... done
[16:03:13.455] - relayed: [n=2] TRUE, TRUE
[16:03:13.456] - queued futures: [n=2] TRUE, TRUE
[16:03:13.456] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:13.456]  length: 0 (resolved future 2)
[16:03:13.456] Relaying remaining futures
[16:03:13.456] signalConditionsASAP(NULL, pos=0) ...
[16:03:13.456] - nx: 2
[16:03:13.456] - relay: TRUE
[16:03:13.456] - stdout: TRUE
[16:03:13.456] - signal: TRUE
[16:03:13.457] - resignal: FALSE
[16:03:13.457] - force: TRUE
[16:03:13.457] - relayed: [n=2] TRUE, TRUE
[16:03:13.457] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:13.457] - relayed: [n=2] TRUE, TRUE
[16:03:13.457] - queued futures: [n=2] TRUE, TRUE
[16:03:13.457] signalConditionsASAP(NULL, pos=0) ... done
[16:03:13.457] resolve() on list ... DONE
[16:03:13.457] result() for MulticoreFuture ...
[16:03:13.458] result() for MulticoreFuture ... done
[16:03:13.458] result() for MulticoreFuture ...
[16:03:13.458] result() for MulticoreFuture ... done
[16:03:13.458] result() for MulticoreFuture ...
[16:03:13.458] result() for MulticoreFuture ... done
[16:03:13.458] result() for MulticoreFuture ...
[16:03:13.458] result() for MulticoreFuture ... done
[16:03:13.458]  - Number of value chunks collected: 2
[16:03:13.458] Resolving 2 futures (chunks) ... DONE
[16:03:13.459] Reducing values from 2 chunks ...
[16:03:13.459]  - Number of values collected after concatenation: 10
[16:03:13.459]  - Number of values expected: 10
[16:03:13.459] Reducing values from 2 chunks ... DONE
[16:03:13.459] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[16:03:13.460] future_lapply() ...
[16:03:13.466] Number of chunks: 2
[16:03:13.466] getGlobalsAndPackagesXApply() ...
[16:03:13.466]  - future.globals: TRUE
[16:03:13.467] getGlobalsAndPackages() ...
[16:03:13.467] Searching for globals...
[16:03:13.473] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[16:03:13.473] Searching for globals ... DONE
[16:03:13.473] Resolving globals: FALSE
[16:03:13.474] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[16:03:13.475] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:13.475] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.475] - packages: [1] ‘future.apply’
[16:03:13.475] getGlobalsAndPackages() ... DONE
[16:03:13.475]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.475]  - needed namespaces: [n=1] ‘future.apply’
[16:03:13.475] Finding globals ... DONE
[16:03:13.476]  - use_args: TRUE
[16:03:13.476]  - Getting '...' globals ...
[16:03:13.476] resolve() on list ...
[16:03:13.476]  recursive: 0
[16:03:13.476]  length: 1
[16:03:13.476]  elements: ‘...’
[16:03:13.476]  length: 0 (resolved future 1)
[16:03:13.476] resolve() on list ... DONE
[16:03:13.477]    - '...' content: [n=0] 
[16:03:13.477] List of 1
[16:03:13.477]  $ ...: list()
[16:03:13.477]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.477]  - attr(*, "where")=List of 1
[16:03:13.477]   ..$ ...:<environment: 0x564e429c1400> 
[16:03:13.477]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.477]  - attr(*, "resolved")= logi TRUE
[16:03:13.477]  - attr(*, "total_size")= num NA
[16:03:13.479]  - Getting '...' globals ... DONE
[16:03:13.479] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:13.480] List of 8
[16:03:13.480]  $ ...future.FUN:function (x, ...)  
[16:03:13.480]  $ x_FUN        :function (x)  
[16:03:13.480]  $ times        : int 0
[16:03:13.480]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.480]  $ stop_if_not  :function (...)  
[16:03:13.480]  $ dim          : NULL
[16:03:13.480]  $ valid_types  : chr [1:2] "logical" "integer"
[16:03:13.480]  $ ...          : list()
[16:03:13.480]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.480]  - attr(*, "where")=List of 8
[16:03:13.480]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:13.480]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:13.480]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:13.480]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:13.480]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:13.480]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:13.480]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:13.480]   ..$ ...          :<environment: 0x564e429c1400> 
[16:03:13.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.480]  - attr(*, "resolved")= logi FALSE
[16:03:13.480]  - attr(*, "total_size")= num 95400
[16:03:13.485] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:13.485] getGlobalsAndPackagesXApply() ... DONE
[16:03:13.485] Number of futures (= number of chunks): 2
[16:03:13.485] Launching 2 futures (chunks) ...
[16:03:13.485] Chunk #1 of 2 ...
[16:03:13.486]  - Finding globals in 'X' for chunk #1 ...
[16:03:13.486] getGlobalsAndPackages() ...
[16:03:13.486] Searching for globals...
[16:03:13.486] 
[16:03:13.486] Searching for globals ... DONE
[16:03:13.486] - globals: [0] <none>
[16:03:13.486] getGlobalsAndPackages() ... DONE
[16:03:13.486]    + additional globals found: [n=0] 
[16:03:13.486]    + additional namespaces needed: [n=0] 
[16:03:13.487]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:13.487]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.487]  - seeds: <none>
[16:03:13.487]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.487] getGlobalsAndPackages() ...
[16:03:13.487] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.487] Resolving globals: FALSE
[16:03:13.487] Tweak future expression to call with '...' arguments ...
[16:03:13.487] {
[16:03:13.487]     do.call(function(...) {
[16:03:13.487]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.487]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.487]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.487]             on.exit(options(oopts), add = TRUE)
[16:03:13.487]         }
[16:03:13.487]         {
[16:03:13.487]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.487]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.487]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.487]             })
[16:03:13.487]         }
[16:03:13.487]     }, args = future.call.arguments)
[16:03:13.487] }
[16:03:13.488] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.488] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.488] - packages: [1] ‘future.apply’
[16:03:13.488] getGlobalsAndPackages() ... DONE
[16:03:13.489] run() for ‘Future’ ...
[16:03:13.489] - state: ‘created’
[16:03:13.489] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.493] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.493] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.493]   - Field: ‘label’
[16:03:13.494]   - Field: ‘local’
[16:03:13.494]   - Field: ‘owner’
[16:03:13.495]   - Field: ‘envir’
[16:03:13.495]   - Field: ‘workers’
[16:03:13.495]   - Field: ‘packages’
[16:03:13.495]   - Field: ‘gc’
[16:03:13.495]   - Field: ‘job’
[16:03:13.495]   - Field: ‘conditions’
[16:03:13.495]   - Field: ‘expr’
[16:03:13.495]   - Field: ‘uuid’
[16:03:13.495]   - Field: ‘seed’
[16:03:13.496]   - Field: ‘version’
[16:03:13.496]   - Field: ‘result’
[16:03:13.496]   - Field: ‘asynchronous’
[16:03:13.496]   - Field: ‘calls’
[16:03:13.496]   - Field: ‘globals’
[16:03:13.496]   - Field: ‘stdout’
[16:03:13.496]   - Field: ‘earlySignal’
[16:03:13.496]   - Field: ‘lazy’
[16:03:13.496]   - Field: ‘state’
[16:03:13.496] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.497] - Launch lazy future ...
[16:03:13.497] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.497] Packages needed by future strategies (n = 0): <none>
[16:03:13.498] {
[16:03:13.498]     {
[16:03:13.498]         {
[16:03:13.498]             ...future.startTime <- base::Sys.time()
[16:03:13.498]             {
[16:03:13.498]                 {
[16:03:13.498]                   {
[16:03:13.498]                     {
[16:03:13.498]                       {
[16:03:13.498]                         base::local({
[16:03:13.498]                           has_future <- base::requireNamespace("future", 
[16:03:13.498]                             quietly = TRUE)
[16:03:13.498]                           if (has_future) {
[16:03:13.498]                             ns <- base::getNamespace("future")
[16:03:13.498]                             version <- ns[[".package"]][["version"]]
[16:03:13.498]                             if (is.null(version)) 
[16:03:13.498]                               version <- utils::packageVersion("future")
[16:03:13.498]                           }
[16:03:13.498]                           else {
[16:03:13.498]                             version <- NULL
[16:03:13.498]                           }
[16:03:13.498]                           if (!has_future || version < "1.8.0") {
[16:03:13.498]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.498]                               "", base::R.version$version.string), 
[16:03:13.498]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.498]                                 base::R.version$platform, 8 * 
[16:03:13.498]                                   base::.Machine$sizeof.pointer), 
[16:03:13.498]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.498]                                 "release", "version")], collapse = " "), 
[16:03:13.498]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.498]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.498]                               info)
[16:03:13.498]                             info <- base::paste(info, collapse = "; ")
[16:03:13.498]                             if (!has_future) {
[16:03:13.498]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.498]                                 info)
[16:03:13.498]                             }
[16:03:13.498]                             else {
[16:03:13.498]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.498]                                 info, version)
[16:03:13.498]                             }
[16:03:13.498]                             base::stop(msg)
[16:03:13.498]                           }
[16:03:13.498]                         })
[16:03:13.498]                       }
[16:03:13.498]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.498]                       base::options(mc.cores = 1L)
[16:03:13.498]                     }
[16:03:13.498]                     base::local({
[16:03:13.498]                       for (pkg in "future.apply") {
[16:03:13.498]                         base::loadNamespace(pkg)
[16:03:13.498]                         base::library(pkg, character.only = TRUE)
[16:03:13.498]                       }
[16:03:13.498]                     })
[16:03:13.498]                   }
[16:03:13.498]                   options(future.plan = NULL)
[16:03:13.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.498]                 }
[16:03:13.498]                 ...future.workdir <- getwd()
[16:03:13.498]             }
[16:03:13.498]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.498]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.498]         }
[16:03:13.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.498]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.498]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.498]             base::names(...future.oldOptions))
[16:03:13.498]     }
[16:03:13.498]     if (FALSE) {
[16:03:13.498]     }
[16:03:13.498]     else {
[16:03:13.498]         if (TRUE) {
[16:03:13.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.498]                 open = "w")
[16:03:13.498]         }
[16:03:13.498]         else {
[16:03:13.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.498]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.498]         }
[16:03:13.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.498]             base::sink(type = "output", split = FALSE)
[16:03:13.498]             base::close(...future.stdout)
[16:03:13.498]         }, add = TRUE)
[16:03:13.498]     }
[16:03:13.498]     ...future.frame <- base::sys.nframe()
[16:03:13.498]     ...future.conditions <- base::list()
[16:03:13.498]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.498]     if (FALSE) {
[16:03:13.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.498]     }
[16:03:13.498]     ...future.result <- base::tryCatch({
[16:03:13.498]         base::withCallingHandlers({
[16:03:13.498]             ...future.value <- base::withVisible(base::local({
[16:03:13.498]                 withCallingHandlers({
[16:03:13.498]                   {
[16:03:13.498]                     do.call(function(...) {
[16:03:13.498]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.498]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.498]                         ...future.globals.maxSize)) {
[16:03:13.498]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.498]                         on.exit(options(oopts), add = TRUE)
[16:03:13.498]                       }
[16:03:13.498]                       {
[16:03:13.498]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.498]                           FUN = function(jj) {
[16:03:13.498]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.498]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.498]                           })
[16:03:13.498]                       }
[16:03:13.498]                     }, args = future.call.arguments)
[16:03:13.498]                   }
[16:03:13.498]                 }, immediateCondition = function(cond) {
[16:03:13.498]                   save_rds <- function (object, pathname, ...) 
[16:03:13.498]                   {
[16:03:13.498]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.498]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.498]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.498]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.498]                         fi_tmp[["mtime"]])
[16:03:13.498]                     }
[16:03:13.498]                     tryCatch({
[16:03:13.498]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.498]                     }, error = function(ex) {
[16:03:13.498]                       msg <- conditionMessage(ex)
[16:03:13.498]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.498]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.498]                         fi_tmp[["mtime"]], msg)
[16:03:13.498]                       ex$message <- msg
[16:03:13.498]                       stop(ex)
[16:03:13.498]                     })
[16:03:13.498]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.498]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.498]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.498]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.498]                       fi <- file.info(pathname)
[16:03:13.498]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.498]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.498]                         fi[["size"]], fi[["mtime"]])
[16:03:13.498]                       stop(msg)
[16:03:13.498]                     }
[16:03:13.498]                     invisible(pathname)
[16:03:13.498]                   }
[16:03:13.498]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.498]                     rootPath = tempdir()) 
[16:03:13.498]                   {
[16:03:13.498]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.498]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.498]                       tmpdir = path, fileext = ".rds")
[16:03:13.498]                     save_rds(obj, file)
[16:03:13.498]                   }
[16:03:13.498]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.498]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.498]                   {
[16:03:13.498]                     inherits <- base::inherits
[16:03:13.498]                     invokeRestart <- base::invokeRestart
[16:03:13.498]                     is.null <- base::is.null
[16:03:13.498]                     muffled <- FALSE
[16:03:13.498]                     if (inherits(cond, "message")) {
[16:03:13.498]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.498]                       if (muffled) 
[16:03:13.498]                         invokeRestart("muffleMessage")
[16:03:13.498]                     }
[16:03:13.498]                     else if (inherits(cond, "warning")) {
[16:03:13.498]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.498]                       if (muffled) 
[16:03:13.498]                         invokeRestart("muffleWarning")
[16:03:13.498]                     }
[16:03:13.498]                     else if (inherits(cond, "condition")) {
[16:03:13.498]                       if (!is.null(pattern)) {
[16:03:13.498]                         computeRestarts <- base::computeRestarts
[16:03:13.498]                         grepl <- base::grepl
[16:03:13.498]                         restarts <- computeRestarts(cond)
[16:03:13.498]                         for (restart in restarts) {
[16:03:13.498]                           name <- restart$name
[16:03:13.498]                           if (is.null(name)) 
[16:03:13.498]                             next
[16:03:13.498]                           if (!grepl(pattern, name)) 
[16:03:13.498]                             next
[16:03:13.498]                           invokeRestart(restart)
[16:03:13.498]                           muffled <- TRUE
[16:03:13.498]                           break
[16:03:13.498]                         }
[16:03:13.498]                       }
[16:03:13.498]                     }
[16:03:13.498]                     invisible(muffled)
[16:03:13.498]                   }
[16:03:13.498]                   muffleCondition(cond)
[16:03:13.498]                 })
[16:03:13.498]             }))
[16:03:13.498]             future::FutureResult(value = ...future.value$value, 
[16:03:13.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.498]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.498]                     ...future.globalenv.names))
[16:03:13.498]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.498]         }, condition = base::local({
[16:03:13.498]             c <- base::c
[16:03:13.498]             inherits <- base::inherits
[16:03:13.498]             invokeRestart <- base::invokeRestart
[16:03:13.498]             length <- base::length
[16:03:13.498]             list <- base::list
[16:03:13.498]             seq.int <- base::seq.int
[16:03:13.498]             signalCondition <- base::signalCondition
[16:03:13.498]             sys.calls <- base::sys.calls
[16:03:13.498]             `[[` <- base::`[[`
[16:03:13.498]             `+` <- base::`+`
[16:03:13.498]             `<<-` <- base::`<<-`
[16:03:13.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.498]                   3L)]
[16:03:13.498]             }
[16:03:13.498]             function(cond) {
[16:03:13.498]                 is_error <- inherits(cond, "error")
[16:03:13.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.498]                   NULL)
[16:03:13.498]                 if (is_error) {
[16:03:13.498]                   sessionInformation <- function() {
[16:03:13.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.498]                       search = base::search(), system = base::Sys.info())
[16:03:13.498]                   }
[16:03:13.498]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.498]                     cond$call), session = sessionInformation(), 
[16:03:13.498]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.498]                   signalCondition(cond)
[16:03:13.498]                 }
[16:03:13.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.498]                 "immediateCondition"))) {
[16:03:13.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.498]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.498]                   if (TRUE && !signal) {
[16:03:13.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.498]                     {
[16:03:13.498]                       inherits <- base::inherits
[16:03:13.498]                       invokeRestart <- base::invokeRestart
[16:03:13.498]                       is.null <- base::is.null
[16:03:13.498]                       muffled <- FALSE
[16:03:13.498]                       if (inherits(cond, "message")) {
[16:03:13.498]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.498]                         if (muffled) 
[16:03:13.498]                           invokeRestart("muffleMessage")
[16:03:13.498]                       }
[16:03:13.498]                       else if (inherits(cond, "warning")) {
[16:03:13.498]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.498]                         if (muffled) 
[16:03:13.498]                           invokeRestart("muffleWarning")
[16:03:13.498]                       }
[16:03:13.498]                       else if (inherits(cond, "condition")) {
[16:03:13.498]                         if (!is.null(pattern)) {
[16:03:13.498]                           computeRestarts <- base::computeRestarts
[16:03:13.498]                           grepl <- base::grepl
[16:03:13.498]                           restarts <- computeRestarts(cond)
[16:03:13.498]                           for (restart in restarts) {
[16:03:13.498]                             name <- restart$name
[16:03:13.498]                             if (is.null(name)) 
[16:03:13.498]                               next
[16:03:13.498]                             if (!grepl(pattern, name)) 
[16:03:13.498]                               next
[16:03:13.498]                             invokeRestart(restart)
[16:03:13.498]                             muffled <- TRUE
[16:03:13.498]                             break
[16:03:13.498]                           }
[16:03:13.498]                         }
[16:03:13.498]                       }
[16:03:13.498]                       invisible(muffled)
[16:03:13.498]                     }
[16:03:13.498]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.498]                   }
[16:03:13.498]                 }
[16:03:13.498]                 else {
[16:03:13.498]                   if (TRUE) {
[16:03:13.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.498]                     {
[16:03:13.498]                       inherits <- base::inherits
[16:03:13.498]                       invokeRestart <- base::invokeRestart
[16:03:13.498]                       is.null <- base::is.null
[16:03:13.498]                       muffled <- FALSE
[16:03:13.498]                       if (inherits(cond, "message")) {
[16:03:13.498]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.498]                         if (muffled) 
[16:03:13.498]                           invokeRestart("muffleMessage")
[16:03:13.498]                       }
[16:03:13.498]                       else if (inherits(cond, "warning")) {
[16:03:13.498]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.498]                         if (muffled) 
[16:03:13.498]                           invokeRestart("muffleWarning")
[16:03:13.498]                       }
[16:03:13.498]                       else if (inherits(cond, "condition")) {
[16:03:13.498]                         if (!is.null(pattern)) {
[16:03:13.498]                           computeRestarts <- base::computeRestarts
[16:03:13.498]                           grepl <- base::grepl
[16:03:13.498]                           restarts <- computeRestarts(cond)
[16:03:13.498]                           for (restart in restarts) {
[16:03:13.498]                             name <- restart$name
[16:03:13.498]                             if (is.null(name)) 
[16:03:13.498]                               next
[16:03:13.498]                             if (!grepl(pattern, name)) 
[16:03:13.498]                               next
[16:03:13.498]                             invokeRestart(restart)
[16:03:13.498]                             muffled <- TRUE
[16:03:13.498]                             break
[16:03:13.498]                           }
[16:03:13.498]                         }
[16:03:13.498]                       }
[16:03:13.498]                       invisible(muffled)
[16:03:13.498]                     }
[16:03:13.498]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.498]                   }
[16:03:13.498]                 }
[16:03:13.498]             }
[16:03:13.498]         }))
[16:03:13.498]     }, error = function(ex) {
[16:03:13.498]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.498]                 ...future.rng), started = ...future.startTime, 
[16:03:13.498]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.498]             version = "1.8"), class = "FutureResult")
[16:03:13.498]     }, finally = {
[16:03:13.498]         if (!identical(...future.workdir, getwd())) 
[16:03:13.498]             setwd(...future.workdir)
[16:03:13.498]         {
[16:03:13.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.498]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.498]             }
[16:03:13.498]             base::options(...future.oldOptions)
[16:03:13.498]             if (.Platform$OS.type == "windows") {
[16:03:13.498]                 old_names <- names(...future.oldEnvVars)
[16:03:13.498]                 envs <- base::Sys.getenv()
[16:03:13.498]                 names <- names(envs)
[16:03:13.498]                 common <- intersect(names, old_names)
[16:03:13.498]                 added <- setdiff(names, old_names)
[16:03:13.498]                 removed <- setdiff(old_names, names)
[16:03:13.498]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.498]                   envs[common]]
[16:03:13.498]                 NAMES <- toupper(changed)
[16:03:13.498]                 args <- list()
[16:03:13.498]                 for (kk in seq_along(NAMES)) {
[16:03:13.498]                   name <- changed[[kk]]
[16:03:13.498]                   NAME <- NAMES[[kk]]
[16:03:13.498]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.498]                     next
[16:03:13.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.498]                 }
[16:03:13.498]                 NAMES <- toupper(added)
[16:03:13.498]                 for (kk in seq_along(NAMES)) {
[16:03:13.498]                   name <- added[[kk]]
[16:03:13.498]                   NAME <- NAMES[[kk]]
[16:03:13.498]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.498]                     next
[16:03:13.498]                   args[[name]] <- ""
[16:03:13.498]                 }
[16:03:13.498]                 NAMES <- toupper(removed)
[16:03:13.498]                 for (kk in seq_along(NAMES)) {
[16:03:13.498]                   name <- removed[[kk]]
[16:03:13.498]                   NAME <- NAMES[[kk]]
[16:03:13.498]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.498]                     next
[16:03:13.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.498]                 }
[16:03:13.498]                 if (length(args) > 0) 
[16:03:13.498]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.498]             }
[16:03:13.498]             else {
[16:03:13.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.498]             }
[16:03:13.498]             {
[16:03:13.498]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.498]                   0L) {
[16:03:13.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.498]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.498]                   base::options(opts)
[16:03:13.498]                 }
[16:03:13.498]                 {
[16:03:13.498]                   {
[16:03:13.498]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.498]                     NULL
[16:03:13.498]                   }
[16:03:13.498]                   options(future.plan = NULL)
[16:03:13.498]                   if (is.na(NA_character_)) 
[16:03:13.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.498]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.498]                     envir = parent.frame()) 
[16:03:13.498]                   {
[16:03:13.498]                     default_workers <- missing(workers)
[16:03:13.498]                     if (is.function(workers)) 
[16:03:13.498]                       workers <- workers()
[16:03:13.498]                     workers <- structure(as.integer(workers), 
[16:03:13.498]                       class = class(workers))
[16:03:13.498]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.498]                       1L)
[16:03:13.498]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.498]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.498]                       if (default_workers) 
[16:03:13.498]                         supportsMulticore(warn = TRUE)
[16:03:13.498]                       return(sequential(..., envir = envir))
[16:03:13.498]                     }
[16:03:13.498]                     oopts <- options(mc.cores = workers)
[16:03:13.498]                     on.exit(options(oopts))
[16:03:13.498]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.498]                       envir = envir)
[16:03:13.498]                     if (!future$lazy) 
[16:03:13.498]                       future <- run(future)
[16:03:13.498]                     invisible(future)
[16:03:13.498]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.498]                 }
[16:03:13.498]             }
[16:03:13.498]         }
[16:03:13.498]     })
[16:03:13.498]     if (TRUE) {
[16:03:13.498]         base::sink(type = "output", split = FALSE)
[16:03:13.498]         if (TRUE) {
[16:03:13.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.498]         }
[16:03:13.498]         else {
[16:03:13.498]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.498]         }
[16:03:13.498]         base::close(...future.stdout)
[16:03:13.498]         ...future.stdout <- NULL
[16:03:13.498]     }
[16:03:13.498]     ...future.result$conditions <- ...future.conditions
[16:03:13.498]     ...future.result$finished <- base::Sys.time()
[16:03:13.498]     ...future.result
[16:03:13.498] }
[16:03:13.500] assign_globals() ...
[16:03:13.500] List of 11
[16:03:13.500]  $ ...future.FUN            :function (x, ...)  
[16:03:13.500]  $ x_FUN                    :function (x)  
[16:03:13.500]  $ times                    : int 0
[16:03:13.500]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.500]  $ stop_if_not              :function (...)  
[16:03:13.500]  $ dim                      : NULL
[16:03:13.500]  $ valid_types              : chr [1:2] "logical" "integer"
[16:03:13.500]  $ future.call.arguments    : list()
[16:03:13.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.500]  $ ...future.elements_ii    :List of 5
[16:03:13.500]   ..$ : int 1
[16:03:13.500]   ..$ : int 2
[16:03:13.500]   ..$ : int 3
[16:03:13.500]   ..$ : int 4
[16:03:13.500]   ..$ : int 5
[16:03:13.500]  $ ...future.seeds_ii       : NULL
[16:03:13.500]  $ ...future.globals.maxSize: NULL
[16:03:13.500]  - attr(*, "where")=List of 11
[16:03:13.500]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.500]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.500]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.500]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.500]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.500]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.500]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.500]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.500]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.500]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.500]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.500]  - attr(*, "resolved")= logi FALSE
[16:03:13.500]  - attr(*, "total_size")= num 95400
[16:03:13.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.500]  - attr(*, "already-done")= logi TRUE
[16:03:13.509] - copied ‘...future.FUN’ to environment
[16:03:13.509] - reassign environment for ‘x_FUN’
[16:03:13.509] - copied ‘x_FUN’ to environment
[16:03:13.509] - copied ‘times’ to environment
[16:03:13.509] - copied ‘stopf’ to environment
[16:03:13.509] - copied ‘stop_if_not’ to environment
[16:03:13.509] - copied ‘dim’ to environment
[16:03:13.510] - copied ‘valid_types’ to environment
[16:03:13.510] - copied ‘future.call.arguments’ to environment
[16:03:13.510] - copied ‘...future.elements_ii’ to environment
[16:03:13.510] - copied ‘...future.seeds_ii’ to environment
[16:03:13.510] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.510] assign_globals() ... done
[16:03:13.510] requestCore(): workers = 2
[16:03:13.512] MulticoreFuture started
[16:03:13.513] - Launch lazy future ... done
[16:03:13.513] run() for ‘MulticoreFuture’ ... done
[16:03:13.513] Created future:
[16:03:13.514] plan(): Setting new future strategy stack:
[16:03:13.514] List of future strategies:
[16:03:13.514] 1. sequential:
[16:03:13.514]    - args: function (..., envir = parent.frame())
[16:03:13.514]    - tweaked: FALSE
[16:03:13.514]    - call: NULL
[16:03:13.515] plan(): nbrOfWorkers() = 1
[16:03:13.517] plan(): Setting new future strategy stack:
[16:03:13.517] List of future strategies:
[16:03:13.517] 1. multicore:
[16:03:13.517]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.517]    - tweaked: FALSE
[16:03:13.517]    - call: plan(strategy)
[16:03:13.523] plan(): nbrOfWorkers() = 2
[16:03:13.513] MulticoreFuture:
[16:03:13.513] Label: ‘future_vapply-1’
[16:03:13.513] Expression:
[16:03:13.513] {
[16:03:13.513]     do.call(function(...) {
[16:03:13.513]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.513]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.513]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.513]             on.exit(options(oopts), add = TRUE)
[16:03:13.513]         }
[16:03:13.513]         {
[16:03:13.513]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.513]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.513]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.513]             })
[16:03:13.513]         }
[16:03:13.513]     }, args = future.call.arguments)
[16:03:13.513] }
[16:03:13.513] Lazy evaluation: FALSE
[16:03:13.513] Asynchronous evaluation: TRUE
[16:03:13.513] Local evaluation: TRUE
[16:03:13.513] Environment: R_GlobalEnv
[16:03:13.513] Capture standard output: TRUE
[16:03:13.513] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.513] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.513] Packages: 1 packages (‘future.apply’)
[16:03:13.513] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.513] Resolved: TRUE
[16:03:13.513] Value: <not collected>
[16:03:13.513] Conditions captured: <none>
[16:03:13.513] Early signaling: FALSE
[16:03:13.513] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.513] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.524] Chunk #1 of 2 ... DONE
[16:03:13.524] Chunk #2 of 2 ...
[16:03:13.524]  - Finding globals in 'X' for chunk #2 ...
[16:03:13.524] getGlobalsAndPackages() ...
[16:03:13.524] Searching for globals...
[16:03:13.525] 
[16:03:13.525] Searching for globals ... DONE
[16:03:13.525] - globals: [0] <none>
[16:03:13.525] getGlobalsAndPackages() ... DONE
[16:03:13.525]    + additional globals found: [n=0] 
[16:03:13.525]    + additional namespaces needed: [n=0] 
[16:03:13.526]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:13.526]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.526]  - seeds: <none>
[16:03:13.526]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.526] getGlobalsAndPackages() ...
[16:03:13.526] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.527] Resolving globals: FALSE
[16:03:13.527] Tweak future expression to call with '...' arguments ...
[16:03:13.527] {
[16:03:13.527]     do.call(function(...) {
[16:03:13.527]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.527]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.527]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.527]             on.exit(options(oopts), add = TRUE)
[16:03:13.527]         }
[16:03:13.527]         {
[16:03:13.527]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.527]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.527]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.527]             })
[16:03:13.527]         }
[16:03:13.527]     }, args = future.call.arguments)
[16:03:13.527] }
[16:03:13.527] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.528] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.528] - packages: [1] ‘future.apply’
[16:03:13.529] getGlobalsAndPackages() ... DONE
[16:03:13.532] run() for ‘Future’ ...
[16:03:13.533] - state: ‘created’
[16:03:13.533] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.540] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.540] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.541]   - Field: ‘label’
[16:03:13.541]   - Field: ‘local’
[16:03:13.541]   - Field: ‘owner’
[16:03:13.542]   - Field: ‘envir’
[16:03:13.542]   - Field: ‘workers’
[16:03:13.542]   - Field: ‘packages’
[16:03:13.542]   - Field: ‘gc’
[16:03:13.542]   - Field: ‘job’
[16:03:13.543]   - Field: ‘conditions’
[16:03:13.543]   - Field: ‘expr’
[16:03:13.543]   - Field: ‘uuid’
[16:03:13.543]   - Field: ‘seed’
[16:03:13.544]   - Field: ‘version’
[16:03:13.544]   - Field: ‘result’
[16:03:13.544]   - Field: ‘asynchronous’
[16:03:13.544]   - Field: ‘calls’
[16:03:13.544]   - Field: ‘globals’
[16:03:13.545]   - Field: ‘stdout’
[16:03:13.545]   - Field: ‘earlySignal’
[16:03:13.545]   - Field: ‘lazy’
[16:03:13.545]   - Field: ‘state’
[16:03:13.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.545] - Launch lazy future ...
[16:03:13.546] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.546] Packages needed by future strategies (n = 0): <none>
[16:03:13.547] {
[16:03:13.547]     {
[16:03:13.547]         {
[16:03:13.547]             ...future.startTime <- base::Sys.time()
[16:03:13.547]             {
[16:03:13.547]                 {
[16:03:13.547]                   {
[16:03:13.547]                     {
[16:03:13.547]                       {
[16:03:13.547]                         base::local({
[16:03:13.547]                           has_future <- base::requireNamespace("future", 
[16:03:13.547]                             quietly = TRUE)
[16:03:13.547]                           if (has_future) {
[16:03:13.547]                             ns <- base::getNamespace("future")
[16:03:13.547]                             version <- ns[[".package"]][["version"]]
[16:03:13.547]                             if (is.null(version)) 
[16:03:13.547]                               version <- utils::packageVersion("future")
[16:03:13.547]                           }
[16:03:13.547]                           else {
[16:03:13.547]                             version <- NULL
[16:03:13.547]                           }
[16:03:13.547]                           if (!has_future || version < "1.8.0") {
[16:03:13.547]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.547]                               "", base::R.version$version.string), 
[16:03:13.547]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.547]                                 base::R.version$platform, 8 * 
[16:03:13.547]                                   base::.Machine$sizeof.pointer), 
[16:03:13.547]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.547]                                 "release", "version")], collapse = " "), 
[16:03:13.547]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.547]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.547]                               info)
[16:03:13.547]                             info <- base::paste(info, collapse = "; ")
[16:03:13.547]                             if (!has_future) {
[16:03:13.547]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.547]                                 info)
[16:03:13.547]                             }
[16:03:13.547]                             else {
[16:03:13.547]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.547]                                 info, version)
[16:03:13.547]                             }
[16:03:13.547]                             base::stop(msg)
[16:03:13.547]                           }
[16:03:13.547]                         })
[16:03:13.547]                       }
[16:03:13.547]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.547]                       base::options(mc.cores = 1L)
[16:03:13.547]                     }
[16:03:13.547]                     base::local({
[16:03:13.547]                       for (pkg in "future.apply") {
[16:03:13.547]                         base::loadNamespace(pkg)
[16:03:13.547]                         base::library(pkg, character.only = TRUE)
[16:03:13.547]                       }
[16:03:13.547]                     })
[16:03:13.547]                   }
[16:03:13.547]                   options(future.plan = NULL)
[16:03:13.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.547]                 }
[16:03:13.547]                 ...future.workdir <- getwd()
[16:03:13.547]             }
[16:03:13.547]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.547]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.547]         }
[16:03:13.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.547]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.547]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.547]             base::names(...future.oldOptions))
[16:03:13.547]     }
[16:03:13.547]     if (FALSE) {
[16:03:13.547]     }
[16:03:13.547]     else {
[16:03:13.547]         if (TRUE) {
[16:03:13.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.547]                 open = "w")
[16:03:13.547]         }
[16:03:13.547]         else {
[16:03:13.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.547]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.547]         }
[16:03:13.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.547]             base::sink(type = "output", split = FALSE)
[16:03:13.547]             base::close(...future.stdout)
[16:03:13.547]         }, add = TRUE)
[16:03:13.547]     }
[16:03:13.547]     ...future.frame <- base::sys.nframe()
[16:03:13.547]     ...future.conditions <- base::list()
[16:03:13.547]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.547]     if (FALSE) {
[16:03:13.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.547]     }
[16:03:13.547]     ...future.result <- base::tryCatch({
[16:03:13.547]         base::withCallingHandlers({
[16:03:13.547]             ...future.value <- base::withVisible(base::local({
[16:03:13.547]                 withCallingHandlers({
[16:03:13.547]                   {
[16:03:13.547]                     do.call(function(...) {
[16:03:13.547]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.547]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.547]                         ...future.globals.maxSize)) {
[16:03:13.547]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.547]                         on.exit(options(oopts), add = TRUE)
[16:03:13.547]                       }
[16:03:13.547]                       {
[16:03:13.547]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.547]                           FUN = function(jj) {
[16:03:13.547]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.547]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.547]                           })
[16:03:13.547]                       }
[16:03:13.547]                     }, args = future.call.arguments)
[16:03:13.547]                   }
[16:03:13.547]                 }, immediateCondition = function(cond) {
[16:03:13.547]                   save_rds <- function (object, pathname, ...) 
[16:03:13.547]                   {
[16:03:13.547]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.547]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.547]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.547]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.547]                         fi_tmp[["mtime"]])
[16:03:13.547]                     }
[16:03:13.547]                     tryCatch({
[16:03:13.547]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.547]                     }, error = function(ex) {
[16:03:13.547]                       msg <- conditionMessage(ex)
[16:03:13.547]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.547]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.547]                         fi_tmp[["mtime"]], msg)
[16:03:13.547]                       ex$message <- msg
[16:03:13.547]                       stop(ex)
[16:03:13.547]                     })
[16:03:13.547]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.547]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.547]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.547]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.547]                       fi <- file.info(pathname)
[16:03:13.547]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.547]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.547]                         fi[["size"]], fi[["mtime"]])
[16:03:13.547]                       stop(msg)
[16:03:13.547]                     }
[16:03:13.547]                     invisible(pathname)
[16:03:13.547]                   }
[16:03:13.547]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.547]                     rootPath = tempdir()) 
[16:03:13.547]                   {
[16:03:13.547]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.547]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.547]                       tmpdir = path, fileext = ".rds")
[16:03:13.547]                     save_rds(obj, file)
[16:03:13.547]                   }
[16:03:13.547]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.547]                   {
[16:03:13.547]                     inherits <- base::inherits
[16:03:13.547]                     invokeRestart <- base::invokeRestart
[16:03:13.547]                     is.null <- base::is.null
[16:03:13.547]                     muffled <- FALSE
[16:03:13.547]                     if (inherits(cond, "message")) {
[16:03:13.547]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.547]                       if (muffled) 
[16:03:13.547]                         invokeRestart("muffleMessage")
[16:03:13.547]                     }
[16:03:13.547]                     else if (inherits(cond, "warning")) {
[16:03:13.547]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.547]                       if (muffled) 
[16:03:13.547]                         invokeRestart("muffleWarning")
[16:03:13.547]                     }
[16:03:13.547]                     else if (inherits(cond, "condition")) {
[16:03:13.547]                       if (!is.null(pattern)) {
[16:03:13.547]                         computeRestarts <- base::computeRestarts
[16:03:13.547]                         grepl <- base::grepl
[16:03:13.547]                         restarts <- computeRestarts(cond)
[16:03:13.547]                         for (restart in restarts) {
[16:03:13.547]                           name <- restart$name
[16:03:13.547]                           if (is.null(name)) 
[16:03:13.547]                             next
[16:03:13.547]                           if (!grepl(pattern, name)) 
[16:03:13.547]                             next
[16:03:13.547]                           invokeRestart(restart)
[16:03:13.547]                           muffled <- TRUE
[16:03:13.547]                           break
[16:03:13.547]                         }
[16:03:13.547]                       }
[16:03:13.547]                     }
[16:03:13.547]                     invisible(muffled)
[16:03:13.547]                   }
[16:03:13.547]                   muffleCondition(cond)
[16:03:13.547]                 })
[16:03:13.547]             }))
[16:03:13.547]             future::FutureResult(value = ...future.value$value, 
[16:03:13.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.547]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.547]                     ...future.globalenv.names))
[16:03:13.547]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.547]         }, condition = base::local({
[16:03:13.547]             c <- base::c
[16:03:13.547]             inherits <- base::inherits
[16:03:13.547]             invokeRestart <- base::invokeRestart
[16:03:13.547]             length <- base::length
[16:03:13.547]             list <- base::list
[16:03:13.547]             seq.int <- base::seq.int
[16:03:13.547]             signalCondition <- base::signalCondition
[16:03:13.547]             sys.calls <- base::sys.calls
[16:03:13.547]             `[[` <- base::`[[`
[16:03:13.547]             `+` <- base::`+`
[16:03:13.547]             `<<-` <- base::`<<-`
[16:03:13.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.547]                   3L)]
[16:03:13.547]             }
[16:03:13.547]             function(cond) {
[16:03:13.547]                 is_error <- inherits(cond, "error")
[16:03:13.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.547]                   NULL)
[16:03:13.547]                 if (is_error) {
[16:03:13.547]                   sessionInformation <- function() {
[16:03:13.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.547]                       search = base::search(), system = base::Sys.info())
[16:03:13.547]                   }
[16:03:13.547]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.547]                     cond$call), session = sessionInformation(), 
[16:03:13.547]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.547]                   signalCondition(cond)
[16:03:13.547]                 }
[16:03:13.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.547]                 "immediateCondition"))) {
[16:03:13.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.547]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.547]                   if (TRUE && !signal) {
[16:03:13.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.547]                     {
[16:03:13.547]                       inherits <- base::inherits
[16:03:13.547]                       invokeRestart <- base::invokeRestart
[16:03:13.547]                       is.null <- base::is.null
[16:03:13.547]                       muffled <- FALSE
[16:03:13.547]                       if (inherits(cond, "message")) {
[16:03:13.547]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.547]                         if (muffled) 
[16:03:13.547]                           invokeRestart("muffleMessage")
[16:03:13.547]                       }
[16:03:13.547]                       else if (inherits(cond, "warning")) {
[16:03:13.547]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.547]                         if (muffled) 
[16:03:13.547]                           invokeRestart("muffleWarning")
[16:03:13.547]                       }
[16:03:13.547]                       else if (inherits(cond, "condition")) {
[16:03:13.547]                         if (!is.null(pattern)) {
[16:03:13.547]                           computeRestarts <- base::computeRestarts
[16:03:13.547]                           grepl <- base::grepl
[16:03:13.547]                           restarts <- computeRestarts(cond)
[16:03:13.547]                           for (restart in restarts) {
[16:03:13.547]                             name <- restart$name
[16:03:13.547]                             if (is.null(name)) 
[16:03:13.547]                               next
[16:03:13.547]                             if (!grepl(pattern, name)) 
[16:03:13.547]                               next
[16:03:13.547]                             invokeRestart(restart)
[16:03:13.547]                             muffled <- TRUE
[16:03:13.547]                             break
[16:03:13.547]                           }
[16:03:13.547]                         }
[16:03:13.547]                       }
[16:03:13.547]                       invisible(muffled)
[16:03:13.547]                     }
[16:03:13.547]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.547]                   }
[16:03:13.547]                 }
[16:03:13.547]                 else {
[16:03:13.547]                   if (TRUE) {
[16:03:13.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.547]                     {
[16:03:13.547]                       inherits <- base::inherits
[16:03:13.547]                       invokeRestart <- base::invokeRestart
[16:03:13.547]                       is.null <- base::is.null
[16:03:13.547]                       muffled <- FALSE
[16:03:13.547]                       if (inherits(cond, "message")) {
[16:03:13.547]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.547]                         if (muffled) 
[16:03:13.547]                           invokeRestart("muffleMessage")
[16:03:13.547]                       }
[16:03:13.547]                       else if (inherits(cond, "warning")) {
[16:03:13.547]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.547]                         if (muffled) 
[16:03:13.547]                           invokeRestart("muffleWarning")
[16:03:13.547]                       }
[16:03:13.547]                       else if (inherits(cond, "condition")) {
[16:03:13.547]                         if (!is.null(pattern)) {
[16:03:13.547]                           computeRestarts <- base::computeRestarts
[16:03:13.547]                           grepl <- base::grepl
[16:03:13.547]                           restarts <- computeRestarts(cond)
[16:03:13.547]                           for (restart in restarts) {
[16:03:13.547]                             name <- restart$name
[16:03:13.547]                             if (is.null(name)) 
[16:03:13.547]                               next
[16:03:13.547]                             if (!grepl(pattern, name)) 
[16:03:13.547]                               next
[16:03:13.547]                             invokeRestart(restart)
[16:03:13.547]                             muffled <- TRUE
[16:03:13.547]                             break
[16:03:13.547]                           }
[16:03:13.547]                         }
[16:03:13.547]                       }
[16:03:13.547]                       invisible(muffled)
[16:03:13.547]                     }
[16:03:13.547]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.547]                   }
[16:03:13.547]                 }
[16:03:13.547]             }
[16:03:13.547]         }))
[16:03:13.547]     }, error = function(ex) {
[16:03:13.547]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.547]                 ...future.rng), started = ...future.startTime, 
[16:03:13.547]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.547]             version = "1.8"), class = "FutureResult")
[16:03:13.547]     }, finally = {
[16:03:13.547]         if (!identical(...future.workdir, getwd())) 
[16:03:13.547]             setwd(...future.workdir)
[16:03:13.547]         {
[16:03:13.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.547]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.547]             }
[16:03:13.547]             base::options(...future.oldOptions)
[16:03:13.547]             if (.Platform$OS.type == "windows") {
[16:03:13.547]                 old_names <- names(...future.oldEnvVars)
[16:03:13.547]                 envs <- base::Sys.getenv()
[16:03:13.547]                 names <- names(envs)
[16:03:13.547]                 common <- intersect(names, old_names)
[16:03:13.547]                 added <- setdiff(names, old_names)
[16:03:13.547]                 removed <- setdiff(old_names, names)
[16:03:13.547]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.547]                   envs[common]]
[16:03:13.547]                 NAMES <- toupper(changed)
[16:03:13.547]                 args <- list()
[16:03:13.547]                 for (kk in seq_along(NAMES)) {
[16:03:13.547]                   name <- changed[[kk]]
[16:03:13.547]                   NAME <- NAMES[[kk]]
[16:03:13.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.547]                     next
[16:03:13.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.547]                 }
[16:03:13.547]                 NAMES <- toupper(added)
[16:03:13.547]                 for (kk in seq_along(NAMES)) {
[16:03:13.547]                   name <- added[[kk]]
[16:03:13.547]                   NAME <- NAMES[[kk]]
[16:03:13.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.547]                     next
[16:03:13.547]                   args[[name]] <- ""
[16:03:13.547]                 }
[16:03:13.547]                 NAMES <- toupper(removed)
[16:03:13.547]                 for (kk in seq_along(NAMES)) {
[16:03:13.547]                   name <- removed[[kk]]
[16:03:13.547]                   NAME <- NAMES[[kk]]
[16:03:13.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.547]                     next
[16:03:13.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.547]                 }
[16:03:13.547]                 if (length(args) > 0) 
[16:03:13.547]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.547]             }
[16:03:13.547]             else {
[16:03:13.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.547]             }
[16:03:13.547]             {
[16:03:13.547]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.547]                   0L) {
[16:03:13.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.547]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.547]                   base::options(opts)
[16:03:13.547]                 }
[16:03:13.547]                 {
[16:03:13.547]                   {
[16:03:13.547]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.547]                     NULL
[16:03:13.547]                   }
[16:03:13.547]                   options(future.plan = NULL)
[16:03:13.547]                   if (is.na(NA_character_)) 
[16:03:13.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.547]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.547]                     envir = parent.frame()) 
[16:03:13.547]                   {
[16:03:13.547]                     default_workers <- missing(workers)
[16:03:13.547]                     if (is.function(workers)) 
[16:03:13.547]                       workers <- workers()
[16:03:13.547]                     workers <- structure(as.integer(workers), 
[16:03:13.547]                       class = class(workers))
[16:03:13.547]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.547]                       1L)
[16:03:13.547]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.547]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.547]                       if (default_workers) 
[16:03:13.547]                         supportsMulticore(warn = TRUE)
[16:03:13.547]                       return(sequential(..., envir = envir))
[16:03:13.547]                     }
[16:03:13.547]                     oopts <- options(mc.cores = workers)
[16:03:13.547]                     on.exit(options(oopts))
[16:03:13.547]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.547]                       envir = envir)
[16:03:13.547]                     if (!future$lazy) 
[16:03:13.547]                       future <- run(future)
[16:03:13.547]                     invisible(future)
[16:03:13.547]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.547]                 }
[16:03:13.547]             }
[16:03:13.547]         }
[16:03:13.547]     })
[16:03:13.547]     if (TRUE) {
[16:03:13.547]         base::sink(type = "output", split = FALSE)
[16:03:13.547]         if (TRUE) {
[16:03:13.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.547]         }
[16:03:13.547]         else {
[16:03:13.547]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.547]         }
[16:03:13.547]         base::close(...future.stdout)
[16:03:13.547]         ...future.stdout <- NULL
[16:03:13.547]     }
[16:03:13.547]     ...future.result$conditions <- ...future.conditions
[16:03:13.547]     ...future.result$finished <- base::Sys.time()
[16:03:13.547]     ...future.result
[16:03:13.547] }
[16:03:13.550] assign_globals() ...
[16:03:13.550] List of 11
[16:03:13.550]  $ ...future.FUN            :function (x, ...)  
[16:03:13.550]  $ x_FUN                    :function (x)  
[16:03:13.550]  $ times                    : int 0
[16:03:13.550]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.550]  $ stop_if_not              :function (...)  
[16:03:13.550]  $ dim                      : NULL
[16:03:13.550]  $ valid_types              : chr [1:2] "logical" "integer"
[16:03:13.550]  $ future.call.arguments    : list()
[16:03:13.550]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.550]  $ ...future.elements_ii    :List of 5
[16:03:13.550]   ..$ : int 6
[16:03:13.550]   ..$ : int 7
[16:03:13.550]   ..$ : int 8
[16:03:13.550]   ..$ : int 9
[16:03:13.550]   ..$ : int 10
[16:03:13.550]  $ ...future.seeds_ii       : NULL
[16:03:13.550]  $ ...future.globals.maxSize: NULL
[16:03:13.550]  - attr(*, "where")=List of 11
[16:03:13.550]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.550]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.550]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.550]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.550]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.550]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.550]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.550]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.550]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.550]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.550]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.550]  - attr(*, "resolved")= logi FALSE
[16:03:13.550]  - attr(*, "total_size")= num 95400
[16:03:13.550]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.550]  - attr(*, "already-done")= logi TRUE
[16:03:13.561] - copied ‘...future.FUN’ to environment
[16:03:13.561] - reassign environment for ‘x_FUN’
[16:03:13.561] - copied ‘x_FUN’ to environment
[16:03:13.561] - copied ‘times’ to environment
[16:03:13.561] - copied ‘stopf’ to environment
[16:03:13.562] - copied ‘stop_if_not’ to environment
[16:03:13.562] - copied ‘dim’ to environment
[16:03:13.562] - copied ‘valid_types’ to environment
[16:03:13.562] - copied ‘future.call.arguments’ to environment
[16:03:13.562] - copied ‘...future.elements_ii’ to environment
[16:03:13.562] - copied ‘...future.seeds_ii’ to environment
[16:03:13.562] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.562] assign_globals() ... done
[16:03:13.562] requestCore(): workers = 2
[16:03:13.565] MulticoreFuture started
[16:03:13.565] - Launch lazy future ... done
[16:03:13.565] run() for ‘MulticoreFuture’ ... done
[16:03:13.565] Created future:
[16:03:13.566] plan(): Setting new future strategy stack:
[16:03:13.566] List of future strategies:
[16:03:13.566] 1. sequential:
[16:03:13.566]    - args: function (..., envir = parent.frame())
[16:03:13.566]    - tweaked: FALSE
[16:03:13.566]    - call: NULL
[16:03:13.567] plan(): nbrOfWorkers() = 1
[16:03:13.569] plan(): Setting new future strategy stack:
[16:03:13.569] List of future strategies:
[16:03:13.569] 1. multicore:
[16:03:13.569]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.569]    - tweaked: FALSE
[16:03:13.569]    - call: plan(strategy)
[16:03:13.578] plan(): nbrOfWorkers() = 2
[16:03:13.566] MulticoreFuture:
[16:03:13.566] Label: ‘future_vapply-2’
[16:03:13.566] Expression:
[16:03:13.566] {
[16:03:13.566]     do.call(function(...) {
[16:03:13.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.566]             on.exit(options(oopts), add = TRUE)
[16:03:13.566]         }
[16:03:13.566]         {
[16:03:13.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.566]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.566]             })
[16:03:13.566]         }
[16:03:13.566]     }, args = future.call.arguments)
[16:03:13.566] }
[16:03:13.566] Lazy evaluation: FALSE
[16:03:13.566] Asynchronous evaluation: TRUE
[16:03:13.566] Local evaluation: TRUE
[16:03:13.566] Environment: R_GlobalEnv
[16:03:13.566] Capture standard output: TRUE
[16:03:13.566] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.566] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.566] Packages: 1 packages (‘future.apply’)
[16:03:13.566] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.566] Resolved: FALSE
[16:03:13.566] Value: <not collected>
[16:03:13.566] Conditions captured: <none>
[16:03:13.566] Early signaling: FALSE
[16:03:13.566] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.566] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.579] Chunk #2 of 2 ... DONE
[16:03:13.579] Launching 2 futures (chunks) ... DONE
[16:03:13.579] Resolving 2 futures (chunks) ...
[16:03:13.579] resolve() on list ...
[16:03:13.580]  recursive: 0
[16:03:13.580]  length: 2
[16:03:13.580] 
[16:03:13.580] Future #1
[16:03:13.580] result() for MulticoreFuture ...
[16:03:13.583] result() for MulticoreFuture ...
[16:03:13.584] result() for MulticoreFuture ... done
[16:03:13.584] result() for MulticoreFuture ... done
[16:03:13.584] result() for MulticoreFuture ...
[16:03:13.585] result() for MulticoreFuture ... done
[16:03:13.585] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:13.586] - nx: 2
[16:03:13.586] - relay: TRUE
[16:03:13.586] - stdout: TRUE
[16:03:13.587] - signal: TRUE
[16:03:13.587] - resignal: FALSE
[16:03:13.587] - force: TRUE
[16:03:13.587] - relayed: [n=2] FALSE, FALSE
[16:03:13.588] - queued futures: [n=2] FALSE, FALSE
[16:03:13.588]  - until=1
[16:03:13.588]  - relaying element #1
[16:03:13.588] result() for MulticoreFuture ...
[16:03:13.589] result() for MulticoreFuture ... done
[16:03:13.589] result() for MulticoreFuture ...
[16:03:13.589] result() for MulticoreFuture ... done
[16:03:13.590] result() for MulticoreFuture ...
[16:03:13.590] result() for MulticoreFuture ... done
[16:03:13.590] result() for MulticoreFuture ...
[16:03:13.590] result() for MulticoreFuture ... done
[16:03:13.590] - relayed: [n=2] TRUE, FALSE
[16:03:13.591] - queued futures: [n=2] TRUE, FALSE
[16:03:13.591] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:13.591]  length: 1 (resolved future 1)
[16:03:13.592] Future #2
[16:03:13.592] result() for MulticoreFuture ...
[16:03:13.593] result() for MulticoreFuture ...
[16:03:13.593] result() for MulticoreFuture ... done
[16:03:13.593] result() for MulticoreFuture ... done
[16:03:13.593] result() for MulticoreFuture ...
[16:03:13.594] result() for MulticoreFuture ... done
[16:03:13.594] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:13.594] - nx: 2
[16:03:13.594] - relay: TRUE
[16:03:13.594] - stdout: TRUE
[16:03:13.594] - signal: TRUE
[16:03:13.594] - resignal: FALSE
[16:03:13.594] - force: TRUE
[16:03:13.594] - relayed: [n=2] TRUE, FALSE
[16:03:13.595] - queued futures: [n=2] TRUE, FALSE
[16:03:13.595]  - until=2
[16:03:13.595]  - relaying element #2
[16:03:13.595] result() for MulticoreFuture ...
[16:03:13.595] result() for MulticoreFuture ... done
[16:03:13.595] result() for MulticoreFuture ...
[16:03:13.595] result() for MulticoreFuture ... done
[16:03:13.596] result() for MulticoreFuture ...
[16:03:13.596] result() for MulticoreFuture ... done
[16:03:13.596] result() for MulticoreFuture ...
[16:03:13.596] result() for MulticoreFuture ... done
[16:03:13.596] - relayed: [n=2] TRUE, TRUE
[16:03:13.596] - queued futures: [n=2] TRUE, TRUE
[16:03:13.596] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:13.596]  length: 0 (resolved future 2)
[16:03:13.597] Relaying remaining futures
[16:03:13.597] signalConditionsASAP(NULL, pos=0) ...
[16:03:13.597] - nx: 2
[16:03:13.597] - relay: TRUE
[16:03:13.597] - stdout: TRUE
[16:03:13.597] - signal: TRUE
[16:03:13.597] - resignal: FALSE
[16:03:13.597] - force: TRUE
[16:03:13.597] - relayed: [n=2] TRUE, TRUE
[16:03:13.597] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:13.598] - relayed: [n=2] TRUE, TRUE
[16:03:13.598] - queued futures: [n=2] TRUE, TRUE
[16:03:13.598] signalConditionsASAP(NULL, pos=0) ... done
[16:03:13.598] resolve() on list ... DONE
[16:03:13.598] result() for MulticoreFuture ...
[16:03:13.598] result() for MulticoreFuture ... done
[16:03:13.598] result() for MulticoreFuture ...
[16:03:13.598] result() for MulticoreFuture ... done
[16:03:13.598] result() for MulticoreFuture ...
[16:03:13.599] result() for MulticoreFuture ... done
[16:03:13.599] result() for MulticoreFuture ...
[16:03:13.599] result() for MulticoreFuture ... done
[16:03:13.599]  - Number of value chunks collected: 2
[16:03:13.599] Resolving 2 futures (chunks) ... DONE
[16:03:13.599] Reducing values from 2 chunks ...
[16:03:13.599]  - Number of values collected after concatenation: 10
[16:03:13.599]  - Number of values expected: 10
[16:03:13.599] Reducing values from 2 chunks ... DONE
[16:03:13.600] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[16:03:13.601] future_lapply() ...
[16:03:13.607] Number of chunks: 2
[16:03:13.607] getGlobalsAndPackagesXApply() ...
[16:03:13.607]  - future.globals: TRUE
[16:03:13.607] getGlobalsAndPackages() ...
[16:03:13.607] Searching for globals...
[16:03:13.610] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:13.611] Searching for globals ... DONE
[16:03:13.611] Resolving globals: FALSE
[16:03:13.612] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[16:03:13.612] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:13.612] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.612] - packages: [1] ‘future.apply’
[16:03:13.613] getGlobalsAndPackages() ... DONE
[16:03:13.613]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.613]  - needed namespaces: [n=1] ‘future.apply’
[16:03:13.613] Finding globals ... DONE
[16:03:13.613]  - use_args: TRUE
[16:03:13.613]  - Getting '...' globals ...
[16:03:13.613] resolve() on list ...
[16:03:13.615]  recursive: 0
[16:03:13.615]  length: 1
[16:03:13.615]  elements: ‘...’
[16:03:13.615]  length: 0 (resolved future 1)
[16:03:13.615] resolve() on list ... DONE
[16:03:13.616]    - '...' content: [n=0] 
[16:03:13.616] List of 1
[16:03:13.616]  $ ...: list()
[16:03:13.616]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.616]  - attr(*, "where")=List of 1
[16:03:13.616]   ..$ ...:<environment: 0x564e413bd960> 
[16:03:13.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.616]  - attr(*, "resolved")= logi TRUE
[16:03:13.616]  - attr(*, "total_size")= num NA
[16:03:13.619]  - Getting '...' globals ... DONE
[16:03:13.619] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:13.619] List of 8
[16:03:13.619]  $ ...future.FUN:function (x, ...)  
[16:03:13.619]  $ x_FUN        :function (x)  
[16:03:13.619]  $ times        : int 1
[16:03:13.619]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.619]  $ stop_if_not  :function (...)  
[16:03:13.619]  $ dim          : NULL
[16:03:13.619]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:13.619]  $ ...          : list()
[16:03:13.619]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.619]  - attr(*, "where")=List of 8
[16:03:13.619]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:13.619]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:13.619]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:13.619]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:13.619]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:13.619]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:13.619]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:13.619]   ..$ ...          :<environment: 0x564e413bd960> 
[16:03:13.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.619]  - attr(*, "resolved")= logi FALSE
[16:03:13.619]  - attr(*, "total_size")= num 94336
[16:03:13.624] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:13.624] getGlobalsAndPackagesXApply() ... DONE
[16:03:13.625] Number of futures (= number of chunks): 2
[16:03:13.625] Launching 2 futures (chunks) ...
[16:03:13.625] Chunk #1 of 2 ...
[16:03:13.625]  - Finding globals in 'X' for chunk #1 ...
[16:03:13.625] getGlobalsAndPackages() ...
[16:03:13.625] Searching for globals...
[16:03:13.625] 
[16:03:13.625] Searching for globals ... DONE
[16:03:13.625] - globals: [0] <none>
[16:03:13.626] getGlobalsAndPackages() ... DONE
[16:03:13.626]    + additional globals found: [n=0] 
[16:03:13.626]    + additional namespaces needed: [n=0] 
[16:03:13.626]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:13.626]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.626]  - seeds: <none>
[16:03:13.626]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.626] getGlobalsAndPackages() ...
[16:03:13.626] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.626] Resolving globals: FALSE
[16:03:13.627] Tweak future expression to call with '...' arguments ...
[16:03:13.627] {
[16:03:13.627]     do.call(function(...) {
[16:03:13.627]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.627]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.627]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.627]             on.exit(options(oopts), add = TRUE)
[16:03:13.627]         }
[16:03:13.627]         {
[16:03:13.627]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.627]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.627]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.627]             })
[16:03:13.627]         }
[16:03:13.627]     }, args = future.call.arguments)
[16:03:13.627] }
[16:03:13.627] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.627] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.628] - packages: [1] ‘future.apply’
[16:03:13.628] getGlobalsAndPackages() ... DONE
[16:03:13.628] run() for ‘Future’ ...
[16:03:13.628] - state: ‘created’
[16:03:13.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.632] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.632] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.632]   - Field: ‘label’
[16:03:13.632]   - Field: ‘local’
[16:03:13.632]   - Field: ‘owner’
[16:03:13.632]   - Field: ‘envir’
[16:03:13.632]   - Field: ‘workers’
[16:03:13.633]   - Field: ‘packages’
[16:03:13.633]   - Field: ‘gc’
[16:03:13.633]   - Field: ‘job’
[16:03:13.633]   - Field: ‘conditions’
[16:03:13.633]   - Field: ‘expr’
[16:03:13.633]   - Field: ‘uuid’
[16:03:13.633]   - Field: ‘seed’
[16:03:13.633]   - Field: ‘version’
[16:03:13.633]   - Field: ‘result’
[16:03:13.633]   - Field: ‘asynchronous’
[16:03:13.633]   - Field: ‘calls’
[16:03:13.634]   - Field: ‘globals’
[16:03:13.634]   - Field: ‘stdout’
[16:03:13.634]   - Field: ‘earlySignal’
[16:03:13.634]   - Field: ‘lazy’
[16:03:13.634]   - Field: ‘state’
[16:03:13.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.634] - Launch lazy future ...
[16:03:13.634] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.635] Packages needed by future strategies (n = 0): <none>
[16:03:13.635] {
[16:03:13.635]     {
[16:03:13.635]         {
[16:03:13.635]             ...future.startTime <- base::Sys.time()
[16:03:13.635]             {
[16:03:13.635]                 {
[16:03:13.635]                   {
[16:03:13.635]                     {
[16:03:13.635]                       {
[16:03:13.635]                         base::local({
[16:03:13.635]                           has_future <- base::requireNamespace("future", 
[16:03:13.635]                             quietly = TRUE)
[16:03:13.635]                           if (has_future) {
[16:03:13.635]                             ns <- base::getNamespace("future")
[16:03:13.635]                             version <- ns[[".package"]][["version"]]
[16:03:13.635]                             if (is.null(version)) 
[16:03:13.635]                               version <- utils::packageVersion("future")
[16:03:13.635]                           }
[16:03:13.635]                           else {
[16:03:13.635]                             version <- NULL
[16:03:13.635]                           }
[16:03:13.635]                           if (!has_future || version < "1.8.0") {
[16:03:13.635]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.635]                               "", base::R.version$version.string), 
[16:03:13.635]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.635]                                 base::R.version$platform, 8 * 
[16:03:13.635]                                   base::.Machine$sizeof.pointer), 
[16:03:13.635]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.635]                                 "release", "version")], collapse = " "), 
[16:03:13.635]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.635]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.635]                               info)
[16:03:13.635]                             info <- base::paste(info, collapse = "; ")
[16:03:13.635]                             if (!has_future) {
[16:03:13.635]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.635]                                 info)
[16:03:13.635]                             }
[16:03:13.635]                             else {
[16:03:13.635]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.635]                                 info, version)
[16:03:13.635]                             }
[16:03:13.635]                             base::stop(msg)
[16:03:13.635]                           }
[16:03:13.635]                         })
[16:03:13.635]                       }
[16:03:13.635]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.635]                       base::options(mc.cores = 1L)
[16:03:13.635]                     }
[16:03:13.635]                     base::local({
[16:03:13.635]                       for (pkg in "future.apply") {
[16:03:13.635]                         base::loadNamespace(pkg)
[16:03:13.635]                         base::library(pkg, character.only = TRUE)
[16:03:13.635]                       }
[16:03:13.635]                     })
[16:03:13.635]                   }
[16:03:13.635]                   options(future.plan = NULL)
[16:03:13.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.635]                 }
[16:03:13.635]                 ...future.workdir <- getwd()
[16:03:13.635]             }
[16:03:13.635]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.635]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.635]         }
[16:03:13.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.635]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.635]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.635]             base::names(...future.oldOptions))
[16:03:13.635]     }
[16:03:13.635]     if (FALSE) {
[16:03:13.635]     }
[16:03:13.635]     else {
[16:03:13.635]         if (TRUE) {
[16:03:13.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.635]                 open = "w")
[16:03:13.635]         }
[16:03:13.635]         else {
[16:03:13.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.635]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.635]         }
[16:03:13.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.635]             base::sink(type = "output", split = FALSE)
[16:03:13.635]             base::close(...future.stdout)
[16:03:13.635]         }, add = TRUE)
[16:03:13.635]     }
[16:03:13.635]     ...future.frame <- base::sys.nframe()
[16:03:13.635]     ...future.conditions <- base::list()
[16:03:13.635]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.635]     if (FALSE) {
[16:03:13.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.635]     }
[16:03:13.635]     ...future.result <- base::tryCatch({
[16:03:13.635]         base::withCallingHandlers({
[16:03:13.635]             ...future.value <- base::withVisible(base::local({
[16:03:13.635]                 withCallingHandlers({
[16:03:13.635]                   {
[16:03:13.635]                     do.call(function(...) {
[16:03:13.635]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.635]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.635]                         ...future.globals.maxSize)) {
[16:03:13.635]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.635]                         on.exit(options(oopts), add = TRUE)
[16:03:13.635]                       }
[16:03:13.635]                       {
[16:03:13.635]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.635]                           FUN = function(jj) {
[16:03:13.635]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.635]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.635]                           })
[16:03:13.635]                       }
[16:03:13.635]                     }, args = future.call.arguments)
[16:03:13.635]                   }
[16:03:13.635]                 }, immediateCondition = function(cond) {
[16:03:13.635]                   save_rds <- function (object, pathname, ...) 
[16:03:13.635]                   {
[16:03:13.635]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.635]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.635]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.635]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.635]                         fi_tmp[["mtime"]])
[16:03:13.635]                     }
[16:03:13.635]                     tryCatch({
[16:03:13.635]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.635]                     }, error = function(ex) {
[16:03:13.635]                       msg <- conditionMessage(ex)
[16:03:13.635]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.635]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.635]                         fi_tmp[["mtime"]], msg)
[16:03:13.635]                       ex$message <- msg
[16:03:13.635]                       stop(ex)
[16:03:13.635]                     })
[16:03:13.635]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.635]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.635]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.635]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.635]                       fi <- file.info(pathname)
[16:03:13.635]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.635]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.635]                         fi[["size"]], fi[["mtime"]])
[16:03:13.635]                       stop(msg)
[16:03:13.635]                     }
[16:03:13.635]                     invisible(pathname)
[16:03:13.635]                   }
[16:03:13.635]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.635]                     rootPath = tempdir()) 
[16:03:13.635]                   {
[16:03:13.635]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.635]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.635]                       tmpdir = path, fileext = ".rds")
[16:03:13.635]                     save_rds(obj, file)
[16:03:13.635]                   }
[16:03:13.635]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.635]                   {
[16:03:13.635]                     inherits <- base::inherits
[16:03:13.635]                     invokeRestart <- base::invokeRestart
[16:03:13.635]                     is.null <- base::is.null
[16:03:13.635]                     muffled <- FALSE
[16:03:13.635]                     if (inherits(cond, "message")) {
[16:03:13.635]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.635]                       if (muffled) 
[16:03:13.635]                         invokeRestart("muffleMessage")
[16:03:13.635]                     }
[16:03:13.635]                     else if (inherits(cond, "warning")) {
[16:03:13.635]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.635]                       if (muffled) 
[16:03:13.635]                         invokeRestart("muffleWarning")
[16:03:13.635]                     }
[16:03:13.635]                     else if (inherits(cond, "condition")) {
[16:03:13.635]                       if (!is.null(pattern)) {
[16:03:13.635]                         computeRestarts <- base::computeRestarts
[16:03:13.635]                         grepl <- base::grepl
[16:03:13.635]                         restarts <- computeRestarts(cond)
[16:03:13.635]                         for (restart in restarts) {
[16:03:13.635]                           name <- restart$name
[16:03:13.635]                           if (is.null(name)) 
[16:03:13.635]                             next
[16:03:13.635]                           if (!grepl(pattern, name)) 
[16:03:13.635]                             next
[16:03:13.635]                           invokeRestart(restart)
[16:03:13.635]                           muffled <- TRUE
[16:03:13.635]                           break
[16:03:13.635]                         }
[16:03:13.635]                       }
[16:03:13.635]                     }
[16:03:13.635]                     invisible(muffled)
[16:03:13.635]                   }
[16:03:13.635]                   muffleCondition(cond)
[16:03:13.635]                 })
[16:03:13.635]             }))
[16:03:13.635]             future::FutureResult(value = ...future.value$value, 
[16:03:13.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.635]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.635]                     ...future.globalenv.names))
[16:03:13.635]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.635]         }, condition = base::local({
[16:03:13.635]             c <- base::c
[16:03:13.635]             inherits <- base::inherits
[16:03:13.635]             invokeRestart <- base::invokeRestart
[16:03:13.635]             length <- base::length
[16:03:13.635]             list <- base::list
[16:03:13.635]             seq.int <- base::seq.int
[16:03:13.635]             signalCondition <- base::signalCondition
[16:03:13.635]             sys.calls <- base::sys.calls
[16:03:13.635]             `[[` <- base::`[[`
[16:03:13.635]             `+` <- base::`+`
[16:03:13.635]             `<<-` <- base::`<<-`
[16:03:13.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.635]                   3L)]
[16:03:13.635]             }
[16:03:13.635]             function(cond) {
[16:03:13.635]                 is_error <- inherits(cond, "error")
[16:03:13.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.635]                   NULL)
[16:03:13.635]                 if (is_error) {
[16:03:13.635]                   sessionInformation <- function() {
[16:03:13.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.635]                       search = base::search(), system = base::Sys.info())
[16:03:13.635]                   }
[16:03:13.635]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.635]                     cond$call), session = sessionInformation(), 
[16:03:13.635]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.635]                   signalCondition(cond)
[16:03:13.635]                 }
[16:03:13.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.635]                 "immediateCondition"))) {
[16:03:13.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.635]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.635]                   if (TRUE && !signal) {
[16:03:13.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.635]                     {
[16:03:13.635]                       inherits <- base::inherits
[16:03:13.635]                       invokeRestart <- base::invokeRestart
[16:03:13.635]                       is.null <- base::is.null
[16:03:13.635]                       muffled <- FALSE
[16:03:13.635]                       if (inherits(cond, "message")) {
[16:03:13.635]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.635]                         if (muffled) 
[16:03:13.635]                           invokeRestart("muffleMessage")
[16:03:13.635]                       }
[16:03:13.635]                       else if (inherits(cond, "warning")) {
[16:03:13.635]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.635]                         if (muffled) 
[16:03:13.635]                           invokeRestart("muffleWarning")
[16:03:13.635]                       }
[16:03:13.635]                       else if (inherits(cond, "condition")) {
[16:03:13.635]                         if (!is.null(pattern)) {
[16:03:13.635]                           computeRestarts <- base::computeRestarts
[16:03:13.635]                           grepl <- base::grepl
[16:03:13.635]                           restarts <- computeRestarts(cond)
[16:03:13.635]                           for (restart in restarts) {
[16:03:13.635]                             name <- restart$name
[16:03:13.635]                             if (is.null(name)) 
[16:03:13.635]                               next
[16:03:13.635]                             if (!grepl(pattern, name)) 
[16:03:13.635]                               next
[16:03:13.635]                             invokeRestart(restart)
[16:03:13.635]                             muffled <- TRUE
[16:03:13.635]                             break
[16:03:13.635]                           }
[16:03:13.635]                         }
[16:03:13.635]                       }
[16:03:13.635]                       invisible(muffled)
[16:03:13.635]                     }
[16:03:13.635]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.635]                   }
[16:03:13.635]                 }
[16:03:13.635]                 else {
[16:03:13.635]                   if (TRUE) {
[16:03:13.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.635]                     {
[16:03:13.635]                       inherits <- base::inherits
[16:03:13.635]                       invokeRestart <- base::invokeRestart
[16:03:13.635]                       is.null <- base::is.null
[16:03:13.635]                       muffled <- FALSE
[16:03:13.635]                       if (inherits(cond, "message")) {
[16:03:13.635]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.635]                         if (muffled) 
[16:03:13.635]                           invokeRestart("muffleMessage")
[16:03:13.635]                       }
[16:03:13.635]                       else if (inherits(cond, "warning")) {
[16:03:13.635]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.635]                         if (muffled) 
[16:03:13.635]                           invokeRestart("muffleWarning")
[16:03:13.635]                       }
[16:03:13.635]                       else if (inherits(cond, "condition")) {
[16:03:13.635]                         if (!is.null(pattern)) {
[16:03:13.635]                           computeRestarts <- base::computeRestarts
[16:03:13.635]                           grepl <- base::grepl
[16:03:13.635]                           restarts <- computeRestarts(cond)
[16:03:13.635]                           for (restart in restarts) {
[16:03:13.635]                             name <- restart$name
[16:03:13.635]                             if (is.null(name)) 
[16:03:13.635]                               next
[16:03:13.635]                             if (!grepl(pattern, name)) 
[16:03:13.635]                               next
[16:03:13.635]                             invokeRestart(restart)
[16:03:13.635]                             muffled <- TRUE
[16:03:13.635]                             break
[16:03:13.635]                           }
[16:03:13.635]                         }
[16:03:13.635]                       }
[16:03:13.635]                       invisible(muffled)
[16:03:13.635]                     }
[16:03:13.635]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.635]                   }
[16:03:13.635]                 }
[16:03:13.635]             }
[16:03:13.635]         }))
[16:03:13.635]     }, error = function(ex) {
[16:03:13.635]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.635]                 ...future.rng), started = ...future.startTime, 
[16:03:13.635]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.635]             version = "1.8"), class = "FutureResult")
[16:03:13.635]     }, finally = {
[16:03:13.635]         if (!identical(...future.workdir, getwd())) 
[16:03:13.635]             setwd(...future.workdir)
[16:03:13.635]         {
[16:03:13.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.635]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.635]             }
[16:03:13.635]             base::options(...future.oldOptions)
[16:03:13.635]             if (.Platform$OS.type == "windows") {
[16:03:13.635]                 old_names <- names(...future.oldEnvVars)
[16:03:13.635]                 envs <- base::Sys.getenv()
[16:03:13.635]                 names <- names(envs)
[16:03:13.635]                 common <- intersect(names, old_names)
[16:03:13.635]                 added <- setdiff(names, old_names)
[16:03:13.635]                 removed <- setdiff(old_names, names)
[16:03:13.635]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.635]                   envs[common]]
[16:03:13.635]                 NAMES <- toupper(changed)
[16:03:13.635]                 args <- list()
[16:03:13.635]                 for (kk in seq_along(NAMES)) {
[16:03:13.635]                   name <- changed[[kk]]
[16:03:13.635]                   NAME <- NAMES[[kk]]
[16:03:13.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.635]                     next
[16:03:13.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.635]                 }
[16:03:13.635]                 NAMES <- toupper(added)
[16:03:13.635]                 for (kk in seq_along(NAMES)) {
[16:03:13.635]                   name <- added[[kk]]
[16:03:13.635]                   NAME <- NAMES[[kk]]
[16:03:13.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.635]                     next
[16:03:13.635]                   args[[name]] <- ""
[16:03:13.635]                 }
[16:03:13.635]                 NAMES <- toupper(removed)
[16:03:13.635]                 for (kk in seq_along(NAMES)) {
[16:03:13.635]                   name <- removed[[kk]]
[16:03:13.635]                   NAME <- NAMES[[kk]]
[16:03:13.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.635]                     next
[16:03:13.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.635]                 }
[16:03:13.635]                 if (length(args) > 0) 
[16:03:13.635]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.635]             }
[16:03:13.635]             else {
[16:03:13.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.635]             }
[16:03:13.635]             {
[16:03:13.635]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.635]                   0L) {
[16:03:13.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.635]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.635]                   base::options(opts)
[16:03:13.635]                 }
[16:03:13.635]                 {
[16:03:13.635]                   {
[16:03:13.635]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.635]                     NULL
[16:03:13.635]                   }
[16:03:13.635]                   options(future.plan = NULL)
[16:03:13.635]                   if (is.na(NA_character_)) 
[16:03:13.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.635]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.635]                     envir = parent.frame()) 
[16:03:13.635]                   {
[16:03:13.635]                     default_workers <- missing(workers)
[16:03:13.635]                     if (is.function(workers)) 
[16:03:13.635]                       workers <- workers()
[16:03:13.635]                     workers <- structure(as.integer(workers), 
[16:03:13.635]                       class = class(workers))
[16:03:13.635]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.635]                       1L)
[16:03:13.635]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.635]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.635]                       if (default_workers) 
[16:03:13.635]                         supportsMulticore(warn = TRUE)
[16:03:13.635]                       return(sequential(..., envir = envir))
[16:03:13.635]                     }
[16:03:13.635]                     oopts <- options(mc.cores = workers)
[16:03:13.635]                     on.exit(options(oopts))
[16:03:13.635]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.635]                       envir = envir)
[16:03:13.635]                     if (!future$lazy) 
[16:03:13.635]                       future <- run(future)
[16:03:13.635]                     invisible(future)
[16:03:13.635]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.635]                 }
[16:03:13.635]             }
[16:03:13.635]         }
[16:03:13.635]     })
[16:03:13.635]     if (TRUE) {
[16:03:13.635]         base::sink(type = "output", split = FALSE)
[16:03:13.635]         if (TRUE) {
[16:03:13.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.635]         }
[16:03:13.635]         else {
[16:03:13.635]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.635]         }
[16:03:13.635]         base::close(...future.stdout)
[16:03:13.635]         ...future.stdout <- NULL
[16:03:13.635]     }
[16:03:13.635]     ...future.result$conditions <- ...future.conditions
[16:03:13.635]     ...future.result$finished <- base::Sys.time()
[16:03:13.635]     ...future.result
[16:03:13.635] }
[16:03:13.638] assign_globals() ...
[16:03:13.638] List of 11
[16:03:13.638]  $ ...future.FUN            :function (x, ...)  
[16:03:13.638]  $ x_FUN                    :function (x)  
[16:03:13.638]  $ times                    : int 1
[16:03:13.638]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.638]  $ stop_if_not              :function (...)  
[16:03:13.638]  $ dim                      : NULL
[16:03:13.638]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:13.638]  $ future.call.arguments    : list()
[16:03:13.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.638]  $ ...future.elements_ii    :List of 5
[16:03:13.638]   ..$ : int 1
[16:03:13.638]   ..$ : int 2
[16:03:13.638]   ..$ : int 3
[16:03:13.638]   ..$ : int 4
[16:03:13.638]   ..$ : int 5
[16:03:13.638]  $ ...future.seeds_ii       : NULL
[16:03:13.638]  $ ...future.globals.maxSize: NULL
[16:03:13.638]  - attr(*, "where")=List of 11
[16:03:13.638]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.638]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.638]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.638]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.638]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.638]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.638]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.638]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.638]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.638]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.638]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.638]  - attr(*, "resolved")= logi FALSE
[16:03:13.638]  - attr(*, "total_size")= num 94336
[16:03:13.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.638]  - attr(*, "already-done")= logi TRUE
[16:03:13.648] - copied ‘...future.FUN’ to environment
[16:03:13.648] - copied ‘x_FUN’ to environment
[16:03:13.648] - copied ‘times’ to environment
[16:03:13.648] - copied ‘stopf’ to environment
[16:03:13.648] - copied ‘stop_if_not’ to environment
[16:03:13.648] - copied ‘dim’ to environment
[16:03:13.648] - copied ‘valid_types’ to environment
[16:03:13.648] - copied ‘future.call.arguments’ to environment
[16:03:13.648] - copied ‘...future.elements_ii’ to environment
[16:03:13.648] - copied ‘...future.seeds_ii’ to environment
[16:03:13.649] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.649] assign_globals() ... done
[16:03:13.649] requestCore(): workers = 2
[16:03:13.651] MulticoreFuture started
[16:03:13.651] - Launch lazy future ... done
[16:03:13.652] run() for ‘MulticoreFuture’ ... done
[16:03:13.652] Created future:
[16:03:13.653] plan(): Setting new future strategy stack:
[16:03:13.653] List of future strategies:
[16:03:13.653] 1. sequential:
[16:03:13.653]    - args: function (..., envir = parent.frame())
[16:03:13.653]    - tweaked: FALSE
[16:03:13.653]    - call: NULL
[16:03:13.654] plan(): nbrOfWorkers() = 1
[16:03:13.656] plan(): Setting new future strategy stack:
[16:03:13.656] List of future strategies:
[16:03:13.656] 1. multicore:
[16:03:13.656]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.656]    - tweaked: FALSE
[16:03:13.656]    - call: plan(strategy)
[16:03:13.661] plan(): nbrOfWorkers() = 2
[16:03:13.652] MulticoreFuture:
[16:03:13.652] Label: ‘future_vapply-1’
[16:03:13.652] Expression:
[16:03:13.652] {
[16:03:13.652]     do.call(function(...) {
[16:03:13.652]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.652]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.652]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.652]             on.exit(options(oopts), add = TRUE)
[16:03:13.652]         }
[16:03:13.652]         {
[16:03:13.652]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.652]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.652]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.652]             })
[16:03:13.652]         }
[16:03:13.652]     }, args = future.call.arguments)
[16:03:13.652] }
[16:03:13.652] Lazy evaluation: FALSE
[16:03:13.652] Asynchronous evaluation: TRUE
[16:03:13.652] Local evaluation: TRUE
[16:03:13.652] Environment: R_GlobalEnv
[16:03:13.652] Capture standard output: TRUE
[16:03:13.652] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.652] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.652] Packages: 1 packages (‘future.apply’)
[16:03:13.652] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.652] Resolved: TRUE
[16:03:13.652] Value: <not collected>
[16:03:13.652] Conditions captured: <none>
[16:03:13.652] Early signaling: FALSE
[16:03:13.652] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.652] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.662] Chunk #1 of 2 ... DONE
[16:03:13.662] Chunk #2 of 2 ...
[16:03:13.663]  - Finding globals in 'X' for chunk #2 ...
[16:03:13.663] getGlobalsAndPackages() ...
[16:03:13.663] Searching for globals...
[16:03:13.663] 
[16:03:13.663] Searching for globals ... DONE
[16:03:13.664] - globals: [0] <none>
[16:03:13.664] getGlobalsAndPackages() ... DONE
[16:03:13.664]    + additional globals found: [n=0] 
[16:03:13.664]    + additional namespaces needed: [n=0] 
[16:03:13.664]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:13.664]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.664]  - seeds: <none>
[16:03:13.665]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.665] getGlobalsAndPackages() ...
[16:03:13.665] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.665] Resolving globals: FALSE
[16:03:13.665] Tweak future expression to call with '...' arguments ...
[16:03:13.665] {
[16:03:13.665]     do.call(function(...) {
[16:03:13.665]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.665]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.665]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.665]             on.exit(options(oopts), add = TRUE)
[16:03:13.665]         }
[16:03:13.665]         {
[16:03:13.665]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.665]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.665]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.665]             })
[16:03:13.665]         }
[16:03:13.665]     }, args = future.call.arguments)
[16:03:13.665] }
[16:03:13.666] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.667] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.667] - packages: [1] ‘future.apply’
[16:03:13.667] getGlobalsAndPackages() ... DONE
[16:03:13.668] run() for ‘Future’ ...
[16:03:13.668] - state: ‘created’
[16:03:13.668] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.673] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.673]   - Field: ‘label’
[16:03:13.673]   - Field: ‘local’
[16:03:13.673]   - Field: ‘owner’
[16:03:13.673]   - Field: ‘envir’
[16:03:13.674]   - Field: ‘workers’
[16:03:13.674]   - Field: ‘packages’
[16:03:13.674]   - Field: ‘gc’
[16:03:13.674]   - Field: ‘job’
[16:03:13.674]   - Field: ‘conditions’
[16:03:13.674]   - Field: ‘expr’
[16:03:13.674]   - Field: ‘uuid’
[16:03:13.675]   - Field: ‘seed’
[16:03:13.675]   - Field: ‘version’
[16:03:13.675]   - Field: ‘result’
[16:03:13.675]   - Field: ‘asynchronous’
[16:03:13.675]   - Field: ‘calls’
[16:03:13.675]   - Field: ‘globals’
[16:03:13.677]   - Field: ‘stdout’
[16:03:13.678]   - Field: ‘earlySignal’
[16:03:13.678]   - Field: ‘lazy’
[16:03:13.678]   - Field: ‘state’
[16:03:13.679] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.679] - Launch lazy future ...
[16:03:13.680] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.680] Packages needed by future strategies (n = 0): <none>
[16:03:13.682] {
[16:03:13.682]     {
[16:03:13.682]         {
[16:03:13.682]             ...future.startTime <- base::Sys.time()
[16:03:13.682]             {
[16:03:13.682]                 {
[16:03:13.682]                   {
[16:03:13.682]                     {
[16:03:13.682]                       {
[16:03:13.682]                         base::local({
[16:03:13.682]                           has_future <- base::requireNamespace("future", 
[16:03:13.682]                             quietly = TRUE)
[16:03:13.682]                           if (has_future) {
[16:03:13.682]                             ns <- base::getNamespace("future")
[16:03:13.682]                             version <- ns[[".package"]][["version"]]
[16:03:13.682]                             if (is.null(version)) 
[16:03:13.682]                               version <- utils::packageVersion("future")
[16:03:13.682]                           }
[16:03:13.682]                           else {
[16:03:13.682]                             version <- NULL
[16:03:13.682]                           }
[16:03:13.682]                           if (!has_future || version < "1.8.0") {
[16:03:13.682]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.682]                               "", base::R.version$version.string), 
[16:03:13.682]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.682]                                 base::R.version$platform, 8 * 
[16:03:13.682]                                   base::.Machine$sizeof.pointer), 
[16:03:13.682]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.682]                                 "release", "version")], collapse = " "), 
[16:03:13.682]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.682]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.682]                               info)
[16:03:13.682]                             info <- base::paste(info, collapse = "; ")
[16:03:13.682]                             if (!has_future) {
[16:03:13.682]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.682]                                 info)
[16:03:13.682]                             }
[16:03:13.682]                             else {
[16:03:13.682]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.682]                                 info, version)
[16:03:13.682]                             }
[16:03:13.682]                             base::stop(msg)
[16:03:13.682]                           }
[16:03:13.682]                         })
[16:03:13.682]                       }
[16:03:13.682]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.682]                       base::options(mc.cores = 1L)
[16:03:13.682]                     }
[16:03:13.682]                     base::local({
[16:03:13.682]                       for (pkg in "future.apply") {
[16:03:13.682]                         base::loadNamespace(pkg)
[16:03:13.682]                         base::library(pkg, character.only = TRUE)
[16:03:13.682]                       }
[16:03:13.682]                     })
[16:03:13.682]                   }
[16:03:13.682]                   options(future.plan = NULL)
[16:03:13.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.682]                 }
[16:03:13.682]                 ...future.workdir <- getwd()
[16:03:13.682]             }
[16:03:13.682]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.682]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.682]         }
[16:03:13.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.682]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.682]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.682]             base::names(...future.oldOptions))
[16:03:13.682]     }
[16:03:13.682]     if (FALSE) {
[16:03:13.682]     }
[16:03:13.682]     else {
[16:03:13.682]         if (TRUE) {
[16:03:13.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.682]                 open = "w")
[16:03:13.682]         }
[16:03:13.682]         else {
[16:03:13.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.682]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.682]         }
[16:03:13.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.682]             base::sink(type = "output", split = FALSE)
[16:03:13.682]             base::close(...future.stdout)
[16:03:13.682]         }, add = TRUE)
[16:03:13.682]     }
[16:03:13.682]     ...future.frame <- base::sys.nframe()
[16:03:13.682]     ...future.conditions <- base::list()
[16:03:13.682]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.682]     if (FALSE) {
[16:03:13.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.682]     }
[16:03:13.682]     ...future.result <- base::tryCatch({
[16:03:13.682]         base::withCallingHandlers({
[16:03:13.682]             ...future.value <- base::withVisible(base::local({
[16:03:13.682]                 withCallingHandlers({
[16:03:13.682]                   {
[16:03:13.682]                     do.call(function(...) {
[16:03:13.682]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.682]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.682]                         ...future.globals.maxSize)) {
[16:03:13.682]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.682]                         on.exit(options(oopts), add = TRUE)
[16:03:13.682]                       }
[16:03:13.682]                       {
[16:03:13.682]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.682]                           FUN = function(jj) {
[16:03:13.682]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.682]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.682]                           })
[16:03:13.682]                       }
[16:03:13.682]                     }, args = future.call.arguments)
[16:03:13.682]                   }
[16:03:13.682]                 }, immediateCondition = function(cond) {
[16:03:13.682]                   save_rds <- function (object, pathname, ...) 
[16:03:13.682]                   {
[16:03:13.682]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.682]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.682]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.682]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.682]                         fi_tmp[["mtime"]])
[16:03:13.682]                     }
[16:03:13.682]                     tryCatch({
[16:03:13.682]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.682]                     }, error = function(ex) {
[16:03:13.682]                       msg <- conditionMessage(ex)
[16:03:13.682]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.682]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.682]                         fi_tmp[["mtime"]], msg)
[16:03:13.682]                       ex$message <- msg
[16:03:13.682]                       stop(ex)
[16:03:13.682]                     })
[16:03:13.682]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.682]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.682]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.682]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.682]                       fi <- file.info(pathname)
[16:03:13.682]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.682]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.682]                         fi[["size"]], fi[["mtime"]])
[16:03:13.682]                       stop(msg)
[16:03:13.682]                     }
[16:03:13.682]                     invisible(pathname)
[16:03:13.682]                   }
[16:03:13.682]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.682]                     rootPath = tempdir()) 
[16:03:13.682]                   {
[16:03:13.682]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.682]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.682]                       tmpdir = path, fileext = ".rds")
[16:03:13.682]                     save_rds(obj, file)
[16:03:13.682]                   }
[16:03:13.682]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.682]                   {
[16:03:13.682]                     inherits <- base::inherits
[16:03:13.682]                     invokeRestart <- base::invokeRestart
[16:03:13.682]                     is.null <- base::is.null
[16:03:13.682]                     muffled <- FALSE
[16:03:13.682]                     if (inherits(cond, "message")) {
[16:03:13.682]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.682]                       if (muffled) 
[16:03:13.682]                         invokeRestart("muffleMessage")
[16:03:13.682]                     }
[16:03:13.682]                     else if (inherits(cond, "warning")) {
[16:03:13.682]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.682]                       if (muffled) 
[16:03:13.682]                         invokeRestart("muffleWarning")
[16:03:13.682]                     }
[16:03:13.682]                     else if (inherits(cond, "condition")) {
[16:03:13.682]                       if (!is.null(pattern)) {
[16:03:13.682]                         computeRestarts <- base::computeRestarts
[16:03:13.682]                         grepl <- base::grepl
[16:03:13.682]                         restarts <- computeRestarts(cond)
[16:03:13.682]                         for (restart in restarts) {
[16:03:13.682]                           name <- restart$name
[16:03:13.682]                           if (is.null(name)) 
[16:03:13.682]                             next
[16:03:13.682]                           if (!grepl(pattern, name)) 
[16:03:13.682]                             next
[16:03:13.682]                           invokeRestart(restart)
[16:03:13.682]                           muffled <- TRUE
[16:03:13.682]                           break
[16:03:13.682]                         }
[16:03:13.682]                       }
[16:03:13.682]                     }
[16:03:13.682]                     invisible(muffled)
[16:03:13.682]                   }
[16:03:13.682]                   muffleCondition(cond)
[16:03:13.682]                 })
[16:03:13.682]             }))
[16:03:13.682]             future::FutureResult(value = ...future.value$value, 
[16:03:13.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.682]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.682]                     ...future.globalenv.names))
[16:03:13.682]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.682]         }, condition = base::local({
[16:03:13.682]             c <- base::c
[16:03:13.682]             inherits <- base::inherits
[16:03:13.682]             invokeRestart <- base::invokeRestart
[16:03:13.682]             length <- base::length
[16:03:13.682]             list <- base::list
[16:03:13.682]             seq.int <- base::seq.int
[16:03:13.682]             signalCondition <- base::signalCondition
[16:03:13.682]             sys.calls <- base::sys.calls
[16:03:13.682]             `[[` <- base::`[[`
[16:03:13.682]             `+` <- base::`+`
[16:03:13.682]             `<<-` <- base::`<<-`
[16:03:13.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.682]                   3L)]
[16:03:13.682]             }
[16:03:13.682]             function(cond) {
[16:03:13.682]                 is_error <- inherits(cond, "error")
[16:03:13.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.682]                   NULL)
[16:03:13.682]                 if (is_error) {
[16:03:13.682]                   sessionInformation <- function() {
[16:03:13.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.682]                       search = base::search(), system = base::Sys.info())
[16:03:13.682]                   }
[16:03:13.682]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.682]                     cond$call), session = sessionInformation(), 
[16:03:13.682]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.682]                   signalCondition(cond)
[16:03:13.682]                 }
[16:03:13.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.682]                 "immediateCondition"))) {
[16:03:13.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.682]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.682]                   if (TRUE && !signal) {
[16:03:13.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.682]                     {
[16:03:13.682]                       inherits <- base::inherits
[16:03:13.682]                       invokeRestart <- base::invokeRestart
[16:03:13.682]                       is.null <- base::is.null
[16:03:13.682]                       muffled <- FALSE
[16:03:13.682]                       if (inherits(cond, "message")) {
[16:03:13.682]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.682]                         if (muffled) 
[16:03:13.682]                           invokeRestart("muffleMessage")
[16:03:13.682]                       }
[16:03:13.682]                       else if (inherits(cond, "warning")) {
[16:03:13.682]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.682]                         if (muffled) 
[16:03:13.682]                           invokeRestart("muffleWarning")
[16:03:13.682]                       }
[16:03:13.682]                       else if (inherits(cond, "condition")) {
[16:03:13.682]                         if (!is.null(pattern)) {
[16:03:13.682]                           computeRestarts <- base::computeRestarts
[16:03:13.682]                           grepl <- base::grepl
[16:03:13.682]                           restarts <- computeRestarts(cond)
[16:03:13.682]                           for (restart in restarts) {
[16:03:13.682]                             name <- restart$name
[16:03:13.682]                             if (is.null(name)) 
[16:03:13.682]                               next
[16:03:13.682]                             if (!grepl(pattern, name)) 
[16:03:13.682]                               next
[16:03:13.682]                             invokeRestart(restart)
[16:03:13.682]                             muffled <- TRUE
[16:03:13.682]                             break
[16:03:13.682]                           }
[16:03:13.682]                         }
[16:03:13.682]                       }
[16:03:13.682]                       invisible(muffled)
[16:03:13.682]                     }
[16:03:13.682]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.682]                   }
[16:03:13.682]                 }
[16:03:13.682]                 else {
[16:03:13.682]                   if (TRUE) {
[16:03:13.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.682]                     {
[16:03:13.682]                       inherits <- base::inherits
[16:03:13.682]                       invokeRestart <- base::invokeRestart
[16:03:13.682]                       is.null <- base::is.null
[16:03:13.682]                       muffled <- FALSE
[16:03:13.682]                       if (inherits(cond, "message")) {
[16:03:13.682]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.682]                         if (muffled) 
[16:03:13.682]                           invokeRestart("muffleMessage")
[16:03:13.682]                       }
[16:03:13.682]                       else if (inherits(cond, "warning")) {
[16:03:13.682]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.682]                         if (muffled) 
[16:03:13.682]                           invokeRestart("muffleWarning")
[16:03:13.682]                       }
[16:03:13.682]                       else if (inherits(cond, "condition")) {
[16:03:13.682]                         if (!is.null(pattern)) {
[16:03:13.682]                           computeRestarts <- base::computeRestarts
[16:03:13.682]                           grepl <- base::grepl
[16:03:13.682]                           restarts <- computeRestarts(cond)
[16:03:13.682]                           for (restart in restarts) {
[16:03:13.682]                             name <- restart$name
[16:03:13.682]                             if (is.null(name)) 
[16:03:13.682]                               next
[16:03:13.682]                             if (!grepl(pattern, name)) 
[16:03:13.682]                               next
[16:03:13.682]                             invokeRestart(restart)
[16:03:13.682]                             muffled <- TRUE
[16:03:13.682]                             break
[16:03:13.682]                           }
[16:03:13.682]                         }
[16:03:13.682]                       }
[16:03:13.682]                       invisible(muffled)
[16:03:13.682]                     }
[16:03:13.682]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.682]                   }
[16:03:13.682]                 }
[16:03:13.682]             }
[16:03:13.682]         }))
[16:03:13.682]     }, error = function(ex) {
[16:03:13.682]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.682]                 ...future.rng), started = ...future.startTime, 
[16:03:13.682]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.682]             version = "1.8"), class = "FutureResult")
[16:03:13.682]     }, finally = {
[16:03:13.682]         if (!identical(...future.workdir, getwd())) 
[16:03:13.682]             setwd(...future.workdir)
[16:03:13.682]         {
[16:03:13.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.682]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.682]             }
[16:03:13.682]             base::options(...future.oldOptions)
[16:03:13.682]             if (.Platform$OS.type == "windows") {
[16:03:13.682]                 old_names <- names(...future.oldEnvVars)
[16:03:13.682]                 envs <- base::Sys.getenv()
[16:03:13.682]                 names <- names(envs)
[16:03:13.682]                 common <- intersect(names, old_names)
[16:03:13.682]                 added <- setdiff(names, old_names)
[16:03:13.682]                 removed <- setdiff(old_names, names)
[16:03:13.682]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.682]                   envs[common]]
[16:03:13.682]                 NAMES <- toupper(changed)
[16:03:13.682]                 args <- list()
[16:03:13.682]                 for (kk in seq_along(NAMES)) {
[16:03:13.682]                   name <- changed[[kk]]
[16:03:13.682]                   NAME <- NAMES[[kk]]
[16:03:13.682]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.682]                     next
[16:03:13.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.682]                 }
[16:03:13.682]                 NAMES <- toupper(added)
[16:03:13.682]                 for (kk in seq_along(NAMES)) {
[16:03:13.682]                   name <- added[[kk]]
[16:03:13.682]                   NAME <- NAMES[[kk]]
[16:03:13.682]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.682]                     next
[16:03:13.682]                   args[[name]] <- ""
[16:03:13.682]                 }
[16:03:13.682]                 NAMES <- toupper(removed)
[16:03:13.682]                 for (kk in seq_along(NAMES)) {
[16:03:13.682]                   name <- removed[[kk]]
[16:03:13.682]                   NAME <- NAMES[[kk]]
[16:03:13.682]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.682]                     next
[16:03:13.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.682]                 }
[16:03:13.682]                 if (length(args) > 0) 
[16:03:13.682]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.682]             }
[16:03:13.682]             else {
[16:03:13.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.682]             }
[16:03:13.682]             {
[16:03:13.682]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.682]                   0L) {
[16:03:13.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.682]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.682]                   base::options(opts)
[16:03:13.682]                 }
[16:03:13.682]                 {
[16:03:13.682]                   {
[16:03:13.682]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.682]                     NULL
[16:03:13.682]                   }
[16:03:13.682]                   options(future.plan = NULL)
[16:03:13.682]                   if (is.na(NA_character_)) 
[16:03:13.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.682]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.682]                     envir = parent.frame()) 
[16:03:13.682]                   {
[16:03:13.682]                     default_workers <- missing(workers)
[16:03:13.682]                     if (is.function(workers)) 
[16:03:13.682]                       workers <- workers()
[16:03:13.682]                     workers <- structure(as.integer(workers), 
[16:03:13.682]                       class = class(workers))
[16:03:13.682]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.682]                       1L)
[16:03:13.682]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.682]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.682]                       if (default_workers) 
[16:03:13.682]                         supportsMulticore(warn = TRUE)
[16:03:13.682]                       return(sequential(..., envir = envir))
[16:03:13.682]                     }
[16:03:13.682]                     oopts <- options(mc.cores = workers)
[16:03:13.682]                     on.exit(options(oopts))
[16:03:13.682]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.682]                       envir = envir)
[16:03:13.682]                     if (!future$lazy) 
[16:03:13.682]                       future <- run(future)
[16:03:13.682]                     invisible(future)
[16:03:13.682]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.682]                 }
[16:03:13.682]             }
[16:03:13.682]         }
[16:03:13.682]     })
[16:03:13.682]     if (TRUE) {
[16:03:13.682]         base::sink(type = "output", split = FALSE)
[16:03:13.682]         if (TRUE) {
[16:03:13.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.682]         }
[16:03:13.682]         else {
[16:03:13.682]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.682]         }
[16:03:13.682]         base::close(...future.stdout)
[16:03:13.682]         ...future.stdout <- NULL
[16:03:13.682]     }
[16:03:13.682]     ...future.result$conditions <- ...future.conditions
[16:03:13.682]     ...future.result$finished <- base::Sys.time()
[16:03:13.682]     ...future.result
[16:03:13.682] }
[16:03:13.686] assign_globals() ...
[16:03:13.686] List of 11
[16:03:13.686]  $ ...future.FUN            :function (x, ...)  
[16:03:13.686]  $ x_FUN                    :function (x)  
[16:03:13.686]  $ times                    : int 1
[16:03:13.686]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.686]  $ stop_if_not              :function (...)  
[16:03:13.686]  $ dim                      : NULL
[16:03:13.686]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:13.686]  $ future.call.arguments    : list()
[16:03:13.686]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.686]  $ ...future.elements_ii    :List of 5
[16:03:13.686]   ..$ : int 6
[16:03:13.686]   ..$ : int 7
[16:03:13.686]   ..$ : int 8
[16:03:13.686]   ..$ : int 9
[16:03:13.686]   ..$ : int 10
[16:03:13.686]  $ ...future.seeds_ii       : NULL
[16:03:13.686]  $ ...future.globals.maxSize: NULL
[16:03:13.686]  - attr(*, "where")=List of 11
[16:03:13.686]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.686]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.686]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.686]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.686]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.686]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.686]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.686]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.686]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.686]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.686]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.686]  - attr(*, "resolved")= logi FALSE
[16:03:13.686]  - attr(*, "total_size")= num 94336
[16:03:13.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.686]  - attr(*, "already-done")= logi TRUE
[16:03:13.699] - copied ‘...future.FUN’ to environment
[16:03:13.700] - copied ‘x_FUN’ to environment
[16:03:13.700] - copied ‘times’ to environment
[16:03:13.700] - copied ‘stopf’ to environment
[16:03:13.700] - copied ‘stop_if_not’ to environment
[16:03:13.700] - copied ‘dim’ to environment
[16:03:13.700] - copied ‘valid_types’ to environment
[16:03:13.700] - copied ‘future.call.arguments’ to environment
[16:03:13.700] - copied ‘...future.elements_ii’ to environment
[16:03:13.700] - copied ‘...future.seeds_ii’ to environment
[16:03:13.700] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.701] assign_globals() ... done
[16:03:13.701] requestCore(): workers = 2
[16:03:13.703] MulticoreFuture started
[16:03:13.703] - Launch lazy future ... done
[16:03:13.703] run() for ‘MulticoreFuture’ ... done
[16:03:13.704] Created future:
[16:03:13.704] plan(): Setting new future strategy stack:
[16:03:13.705] List of future strategies:
[16:03:13.705] 1. sequential:
[16:03:13.705]    - args: function (..., envir = parent.frame())
[16:03:13.705]    - tweaked: FALSE
[16:03:13.705]    - call: NULL
[16:03:13.706] plan(): nbrOfWorkers() = 1
[16:03:13.708] plan(): Setting new future strategy stack:
[16:03:13.708] List of future strategies:
[16:03:13.708] 1. multicore:
[16:03:13.708]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.708]    - tweaked: FALSE
[16:03:13.708]    - call: plan(strategy)
[16:03:13.714] plan(): nbrOfWorkers() = 2
[16:03:13.704] MulticoreFuture:
[16:03:13.704] Label: ‘future_vapply-2’
[16:03:13.704] Expression:
[16:03:13.704] {
[16:03:13.704]     do.call(function(...) {
[16:03:13.704]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.704]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.704]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.704]             on.exit(options(oopts), add = TRUE)
[16:03:13.704]         }
[16:03:13.704]         {
[16:03:13.704]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.704]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.704]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.704]             })
[16:03:13.704]         }
[16:03:13.704]     }, args = future.call.arguments)
[16:03:13.704] }
[16:03:13.704] Lazy evaluation: FALSE
[16:03:13.704] Asynchronous evaluation: TRUE
[16:03:13.704] Local evaluation: TRUE
[16:03:13.704] Environment: R_GlobalEnv
[16:03:13.704] Capture standard output: TRUE
[16:03:13.704] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.704] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.704] Packages: 1 packages (‘future.apply’)
[16:03:13.704] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.704] Resolved: TRUE
[16:03:13.704] Value: <not collected>
[16:03:13.704] Conditions captured: <none>
[16:03:13.704] Early signaling: FALSE
[16:03:13.704] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.704] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.715] Chunk #2 of 2 ... DONE
[16:03:13.715] Launching 2 futures (chunks) ... DONE
[16:03:13.715] Resolving 2 futures (chunks) ...
[16:03:13.715] resolve() on list ...
[16:03:13.715]  recursive: 0
[16:03:13.715]  length: 2
[16:03:13.716] 
[16:03:13.716] Future #1
[16:03:13.716] result() for MulticoreFuture ...
[16:03:13.717] result() for MulticoreFuture ...
[16:03:13.717] result() for MulticoreFuture ... done
[16:03:13.717] result() for MulticoreFuture ... done
[16:03:13.717] result() for MulticoreFuture ...
[16:03:13.718] result() for MulticoreFuture ... done
[16:03:13.718] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:13.718] - nx: 2
[16:03:13.718] - relay: TRUE
[16:03:13.718] - stdout: TRUE
[16:03:13.718] - signal: TRUE
[16:03:13.718] - resignal: FALSE
[16:03:13.718] - force: TRUE
[16:03:13.719] - relayed: [n=2] FALSE, FALSE
[16:03:13.719] - queued futures: [n=2] FALSE, FALSE
[16:03:13.719]  - until=1
[16:03:13.719]  - relaying element #1
[16:03:13.719] result() for MulticoreFuture ...
[16:03:13.719] result() for MulticoreFuture ... done
[16:03:13.720] result() for MulticoreFuture ...
[16:03:13.720] result() for MulticoreFuture ... done
[16:03:13.720] result() for MulticoreFuture ...
[16:03:13.720] result() for MulticoreFuture ... done
[16:03:13.720] result() for MulticoreFuture ...
[16:03:13.720] result() for MulticoreFuture ... done
[16:03:13.720] - relayed: [n=2] TRUE, FALSE
[16:03:13.721] - queued futures: [n=2] TRUE, FALSE
[16:03:13.721] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:13.721]  length: 1 (resolved future 1)
[16:03:13.721] Future #2
[16:03:13.721] result() for MulticoreFuture ...
[16:03:13.726] result() for MulticoreFuture ...
[16:03:13.726] result() for MulticoreFuture ... done
[16:03:13.726] result() for MulticoreFuture ... done
[16:03:13.727] result() for MulticoreFuture ...
[16:03:13.727] result() for MulticoreFuture ... done
[16:03:13.727] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:13.728] - nx: 2
[16:03:13.728] - relay: TRUE
[16:03:13.728] - stdout: TRUE
[16:03:13.728] - signal: TRUE
[16:03:13.728] - resignal: FALSE
[16:03:13.728] - force: TRUE
[16:03:13.728] - relayed: [n=2] TRUE, FALSE
[16:03:13.729] - queued futures: [n=2] TRUE, FALSE
[16:03:13.729]  - until=2
[16:03:13.729]  - relaying element #2
[16:03:13.729] result() for MulticoreFuture ...
[16:03:13.729] result() for MulticoreFuture ... done
[16:03:13.729] result() for MulticoreFuture ...
[16:03:13.730] result() for MulticoreFuture ... done
[16:03:13.730] result() for MulticoreFuture ...
[16:03:13.730] result() for MulticoreFuture ... done
[16:03:13.730] result() for MulticoreFuture ...
[16:03:13.730] result() for MulticoreFuture ... done
[16:03:13.730] - relayed: [n=2] TRUE, TRUE
[16:03:13.731] - queued futures: [n=2] TRUE, TRUE
[16:03:13.731] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:13.731]  length: 0 (resolved future 2)
[16:03:13.731] Relaying remaining futures
[16:03:13.731] signalConditionsASAP(NULL, pos=0) ...
[16:03:13.731] - nx: 2
[16:03:13.731] - relay: TRUE
[16:03:13.732] - stdout: TRUE
[16:03:13.732] - signal: TRUE
[16:03:13.732] - resignal: FALSE
[16:03:13.732] - force: TRUE
[16:03:13.732] - relayed: [n=2] TRUE, TRUE
[16:03:13.732] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:13.732] - relayed: [n=2] TRUE, TRUE
[16:03:13.732] - queued futures: [n=2] TRUE, TRUE
[16:03:13.733] signalConditionsASAP(NULL, pos=0) ... done
[16:03:13.733] resolve() on list ... DONE
[16:03:13.733] result() for MulticoreFuture ...
[16:03:13.733] result() for MulticoreFuture ... done
[16:03:13.733] result() for MulticoreFuture ...
[16:03:13.733] result() for MulticoreFuture ... done
[16:03:13.733] result() for MulticoreFuture ...
[16:03:13.733] result() for MulticoreFuture ... done
[16:03:13.734] result() for MulticoreFuture ...
[16:03:13.734] result() for MulticoreFuture ... done
[16:03:13.734]  - Number of value chunks collected: 2
[16:03:13.734] Resolving 2 futures (chunks) ... DONE
[16:03:13.734] Reducing values from 2 chunks ...
[16:03:13.734]  - Number of values collected after concatenation: 10
[16:03:13.734]  - Number of values expected: 10
[16:03:13.734] Reducing values from 2 chunks ... DONE
[16:03:13.734] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[16:03:13.736] future_lapply() ...
[16:03:13.742] Number of chunks: 2
[16:03:13.742] getGlobalsAndPackagesXApply() ...
[16:03:13.742]  - future.globals: TRUE
[16:03:13.742] getGlobalsAndPackages() ...
[16:03:13.742] Searching for globals...
[16:03:13.746] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[16:03:13.746] Searching for globals ... DONE
[16:03:13.746] Resolving globals: FALSE
[16:03:13.747] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[16:03:13.748] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:13.748] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.748] - packages: [1] ‘future.apply’
[16:03:13.748] getGlobalsAndPackages() ... DONE
[16:03:13.748]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.748]  - needed namespaces: [n=1] ‘future.apply’
[16:03:13.748] Finding globals ... DONE
[16:03:13.748]  - use_args: TRUE
[16:03:13.749]  - Getting '...' globals ...
[16:03:13.749] resolve() on list ...
[16:03:13.749]  recursive: 0
[16:03:13.749]  length: 1
[16:03:13.749]  elements: ‘...’
[16:03:13.749]  length: 0 (resolved future 1)
[16:03:13.749] resolve() on list ... DONE
[16:03:13.749]    - '...' content: [n=0] 
[16:03:13.750] List of 1
[16:03:13.750]  $ ...: list()
[16:03:13.750]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.750]  - attr(*, "where")=List of 1
[16:03:13.750]   ..$ ...:<environment: 0x564e411ca9b8> 
[16:03:13.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.750]  - attr(*, "resolved")= logi TRUE
[16:03:13.750]  - attr(*, "total_size")= num NA
[16:03:13.754]  - Getting '...' globals ... DONE
[16:03:13.754] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:13.754] List of 8
[16:03:13.754]  $ ...future.FUN:function (x, ...)  
[16:03:13.754]  $ x_FUN        :function (x)  
[16:03:13.754]  $ times        : int 2
[16:03:13.754]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.754]  $ stop_if_not  :function (...)  
[16:03:13.754]  $ dim          : NULL
[16:03:13.754]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:13.754]  $ ...          : list()
[16:03:13.754]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.754]  - attr(*, "where")=List of 8
[16:03:13.754]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:13.754]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:13.754]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:13.754]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:13.754]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:13.754]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:13.754]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:13.754]   ..$ ...          :<environment: 0x564e411ca9b8> 
[16:03:13.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.754]  - attr(*, "resolved")= logi FALSE
[16:03:13.754]  - attr(*, "total_size")= num 96456
[16:03:13.760] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:13.760] getGlobalsAndPackagesXApply() ... DONE
[16:03:13.760] Number of futures (= number of chunks): 2
[16:03:13.760] Launching 2 futures (chunks) ...
[16:03:13.760] Chunk #1 of 2 ...
[16:03:13.761]  - Finding globals in 'X' for chunk #1 ...
[16:03:13.761] getGlobalsAndPackages() ...
[16:03:13.761] Searching for globals...
[16:03:13.761] 
[16:03:13.761] Searching for globals ... DONE
[16:03:13.761] - globals: [0] <none>
[16:03:13.761] getGlobalsAndPackages() ... DONE
[16:03:13.761]    + additional globals found: [n=0] 
[16:03:13.761]    + additional namespaces needed: [n=0] 
[16:03:13.762]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:13.762]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.762]  - seeds: <none>
[16:03:13.762]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.762] getGlobalsAndPackages() ...
[16:03:13.762] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.762] Resolving globals: FALSE
[16:03:13.762] Tweak future expression to call with '...' arguments ...
[16:03:13.762] {
[16:03:13.762]     do.call(function(...) {
[16:03:13.762]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.762]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.762]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.762]             on.exit(options(oopts), add = TRUE)
[16:03:13.762]         }
[16:03:13.762]         {
[16:03:13.762]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.762]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.762]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.762]             })
[16:03:13.762]         }
[16:03:13.762]     }, args = future.call.arguments)
[16:03:13.762] }
[16:03:13.763] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.763] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.763] - packages: [1] ‘future.apply’
[16:03:13.763] getGlobalsAndPackages() ... DONE
[16:03:13.764] run() for ‘Future’ ...
[16:03:13.764] - state: ‘created’
[16:03:13.764] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.768] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.768]   - Field: ‘label’
[16:03:13.768]   - Field: ‘local’
[16:03:13.768]   - Field: ‘owner’
[16:03:13.768]   - Field: ‘envir’
[16:03:13.768]   - Field: ‘workers’
[16:03:13.768]   - Field: ‘packages’
[16:03:13.769]   - Field: ‘gc’
[16:03:13.769]   - Field: ‘job’
[16:03:13.769]   - Field: ‘conditions’
[16:03:13.769]   - Field: ‘expr’
[16:03:13.769]   - Field: ‘uuid’
[16:03:13.769]   - Field: ‘seed’
[16:03:13.769]   - Field: ‘version’
[16:03:13.769]   - Field: ‘result’
[16:03:13.769]   - Field: ‘asynchronous’
[16:03:13.769]   - Field: ‘calls’
[16:03:13.769]   - Field: ‘globals’
[16:03:13.770]   - Field: ‘stdout’
[16:03:13.770]   - Field: ‘earlySignal’
[16:03:13.770]   - Field: ‘lazy’
[16:03:13.770]   - Field: ‘state’
[16:03:13.770] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.770] - Launch lazy future ...
[16:03:13.770] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.770] Packages needed by future strategies (n = 0): <none>
[16:03:13.771] {
[16:03:13.771]     {
[16:03:13.771]         {
[16:03:13.771]             ...future.startTime <- base::Sys.time()
[16:03:13.771]             {
[16:03:13.771]                 {
[16:03:13.771]                   {
[16:03:13.771]                     {
[16:03:13.771]                       {
[16:03:13.771]                         base::local({
[16:03:13.771]                           has_future <- base::requireNamespace("future", 
[16:03:13.771]                             quietly = TRUE)
[16:03:13.771]                           if (has_future) {
[16:03:13.771]                             ns <- base::getNamespace("future")
[16:03:13.771]                             version <- ns[[".package"]][["version"]]
[16:03:13.771]                             if (is.null(version)) 
[16:03:13.771]                               version <- utils::packageVersion("future")
[16:03:13.771]                           }
[16:03:13.771]                           else {
[16:03:13.771]                             version <- NULL
[16:03:13.771]                           }
[16:03:13.771]                           if (!has_future || version < "1.8.0") {
[16:03:13.771]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.771]                               "", base::R.version$version.string), 
[16:03:13.771]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.771]                                 base::R.version$platform, 8 * 
[16:03:13.771]                                   base::.Machine$sizeof.pointer), 
[16:03:13.771]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.771]                                 "release", "version")], collapse = " "), 
[16:03:13.771]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.771]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.771]                               info)
[16:03:13.771]                             info <- base::paste(info, collapse = "; ")
[16:03:13.771]                             if (!has_future) {
[16:03:13.771]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.771]                                 info)
[16:03:13.771]                             }
[16:03:13.771]                             else {
[16:03:13.771]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.771]                                 info, version)
[16:03:13.771]                             }
[16:03:13.771]                             base::stop(msg)
[16:03:13.771]                           }
[16:03:13.771]                         })
[16:03:13.771]                       }
[16:03:13.771]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.771]                       base::options(mc.cores = 1L)
[16:03:13.771]                     }
[16:03:13.771]                     base::local({
[16:03:13.771]                       for (pkg in "future.apply") {
[16:03:13.771]                         base::loadNamespace(pkg)
[16:03:13.771]                         base::library(pkg, character.only = TRUE)
[16:03:13.771]                       }
[16:03:13.771]                     })
[16:03:13.771]                   }
[16:03:13.771]                   options(future.plan = NULL)
[16:03:13.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.771]                 }
[16:03:13.771]                 ...future.workdir <- getwd()
[16:03:13.771]             }
[16:03:13.771]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.771]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.771]         }
[16:03:13.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.771]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.771]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.771]             base::names(...future.oldOptions))
[16:03:13.771]     }
[16:03:13.771]     if (FALSE) {
[16:03:13.771]     }
[16:03:13.771]     else {
[16:03:13.771]         if (TRUE) {
[16:03:13.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.771]                 open = "w")
[16:03:13.771]         }
[16:03:13.771]         else {
[16:03:13.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.771]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.771]         }
[16:03:13.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.771]             base::sink(type = "output", split = FALSE)
[16:03:13.771]             base::close(...future.stdout)
[16:03:13.771]         }, add = TRUE)
[16:03:13.771]     }
[16:03:13.771]     ...future.frame <- base::sys.nframe()
[16:03:13.771]     ...future.conditions <- base::list()
[16:03:13.771]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.771]     if (FALSE) {
[16:03:13.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.771]     }
[16:03:13.771]     ...future.result <- base::tryCatch({
[16:03:13.771]         base::withCallingHandlers({
[16:03:13.771]             ...future.value <- base::withVisible(base::local({
[16:03:13.771]                 withCallingHandlers({
[16:03:13.771]                   {
[16:03:13.771]                     do.call(function(...) {
[16:03:13.771]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.771]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.771]                         ...future.globals.maxSize)) {
[16:03:13.771]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.771]                         on.exit(options(oopts), add = TRUE)
[16:03:13.771]                       }
[16:03:13.771]                       {
[16:03:13.771]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.771]                           FUN = function(jj) {
[16:03:13.771]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.771]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.771]                           })
[16:03:13.771]                       }
[16:03:13.771]                     }, args = future.call.arguments)
[16:03:13.771]                   }
[16:03:13.771]                 }, immediateCondition = function(cond) {
[16:03:13.771]                   save_rds <- function (object, pathname, ...) 
[16:03:13.771]                   {
[16:03:13.771]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.771]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.771]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.771]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.771]                         fi_tmp[["mtime"]])
[16:03:13.771]                     }
[16:03:13.771]                     tryCatch({
[16:03:13.771]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.771]                     }, error = function(ex) {
[16:03:13.771]                       msg <- conditionMessage(ex)
[16:03:13.771]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.771]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.771]                         fi_tmp[["mtime"]], msg)
[16:03:13.771]                       ex$message <- msg
[16:03:13.771]                       stop(ex)
[16:03:13.771]                     })
[16:03:13.771]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.771]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.771]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.771]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.771]                       fi <- file.info(pathname)
[16:03:13.771]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.771]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.771]                         fi[["size"]], fi[["mtime"]])
[16:03:13.771]                       stop(msg)
[16:03:13.771]                     }
[16:03:13.771]                     invisible(pathname)
[16:03:13.771]                   }
[16:03:13.771]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.771]                     rootPath = tempdir()) 
[16:03:13.771]                   {
[16:03:13.771]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.771]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.771]                       tmpdir = path, fileext = ".rds")
[16:03:13.771]                     save_rds(obj, file)
[16:03:13.771]                   }
[16:03:13.771]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.771]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.771]                   {
[16:03:13.771]                     inherits <- base::inherits
[16:03:13.771]                     invokeRestart <- base::invokeRestart
[16:03:13.771]                     is.null <- base::is.null
[16:03:13.771]                     muffled <- FALSE
[16:03:13.771]                     if (inherits(cond, "message")) {
[16:03:13.771]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.771]                       if (muffled) 
[16:03:13.771]                         invokeRestart("muffleMessage")
[16:03:13.771]                     }
[16:03:13.771]                     else if (inherits(cond, "warning")) {
[16:03:13.771]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.771]                       if (muffled) 
[16:03:13.771]                         invokeRestart("muffleWarning")
[16:03:13.771]                     }
[16:03:13.771]                     else if (inherits(cond, "condition")) {
[16:03:13.771]                       if (!is.null(pattern)) {
[16:03:13.771]                         computeRestarts <- base::computeRestarts
[16:03:13.771]                         grepl <- base::grepl
[16:03:13.771]                         restarts <- computeRestarts(cond)
[16:03:13.771]                         for (restart in restarts) {
[16:03:13.771]                           name <- restart$name
[16:03:13.771]                           if (is.null(name)) 
[16:03:13.771]                             next
[16:03:13.771]                           if (!grepl(pattern, name)) 
[16:03:13.771]                             next
[16:03:13.771]                           invokeRestart(restart)
[16:03:13.771]                           muffled <- TRUE
[16:03:13.771]                           break
[16:03:13.771]                         }
[16:03:13.771]                       }
[16:03:13.771]                     }
[16:03:13.771]                     invisible(muffled)
[16:03:13.771]                   }
[16:03:13.771]                   muffleCondition(cond)
[16:03:13.771]                 })
[16:03:13.771]             }))
[16:03:13.771]             future::FutureResult(value = ...future.value$value, 
[16:03:13.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.771]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.771]                     ...future.globalenv.names))
[16:03:13.771]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.771]         }, condition = base::local({
[16:03:13.771]             c <- base::c
[16:03:13.771]             inherits <- base::inherits
[16:03:13.771]             invokeRestart <- base::invokeRestart
[16:03:13.771]             length <- base::length
[16:03:13.771]             list <- base::list
[16:03:13.771]             seq.int <- base::seq.int
[16:03:13.771]             signalCondition <- base::signalCondition
[16:03:13.771]             sys.calls <- base::sys.calls
[16:03:13.771]             `[[` <- base::`[[`
[16:03:13.771]             `+` <- base::`+`
[16:03:13.771]             `<<-` <- base::`<<-`
[16:03:13.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.771]                   3L)]
[16:03:13.771]             }
[16:03:13.771]             function(cond) {
[16:03:13.771]                 is_error <- inherits(cond, "error")
[16:03:13.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.771]                   NULL)
[16:03:13.771]                 if (is_error) {
[16:03:13.771]                   sessionInformation <- function() {
[16:03:13.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.771]                       search = base::search(), system = base::Sys.info())
[16:03:13.771]                   }
[16:03:13.771]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.771]                     cond$call), session = sessionInformation(), 
[16:03:13.771]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.771]                   signalCondition(cond)
[16:03:13.771]                 }
[16:03:13.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.771]                 "immediateCondition"))) {
[16:03:13.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.771]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.771]                   if (TRUE && !signal) {
[16:03:13.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.771]                     {
[16:03:13.771]                       inherits <- base::inherits
[16:03:13.771]                       invokeRestart <- base::invokeRestart
[16:03:13.771]                       is.null <- base::is.null
[16:03:13.771]                       muffled <- FALSE
[16:03:13.771]                       if (inherits(cond, "message")) {
[16:03:13.771]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.771]                         if (muffled) 
[16:03:13.771]                           invokeRestart("muffleMessage")
[16:03:13.771]                       }
[16:03:13.771]                       else if (inherits(cond, "warning")) {
[16:03:13.771]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.771]                         if (muffled) 
[16:03:13.771]                           invokeRestart("muffleWarning")
[16:03:13.771]                       }
[16:03:13.771]                       else if (inherits(cond, "condition")) {
[16:03:13.771]                         if (!is.null(pattern)) {
[16:03:13.771]                           computeRestarts <- base::computeRestarts
[16:03:13.771]                           grepl <- base::grepl
[16:03:13.771]                           restarts <- computeRestarts(cond)
[16:03:13.771]                           for (restart in restarts) {
[16:03:13.771]                             name <- restart$name
[16:03:13.771]                             if (is.null(name)) 
[16:03:13.771]                               next
[16:03:13.771]                             if (!grepl(pattern, name)) 
[16:03:13.771]                               next
[16:03:13.771]                             invokeRestart(restart)
[16:03:13.771]                             muffled <- TRUE
[16:03:13.771]                             break
[16:03:13.771]                           }
[16:03:13.771]                         }
[16:03:13.771]                       }
[16:03:13.771]                       invisible(muffled)
[16:03:13.771]                     }
[16:03:13.771]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.771]                   }
[16:03:13.771]                 }
[16:03:13.771]                 else {
[16:03:13.771]                   if (TRUE) {
[16:03:13.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.771]                     {
[16:03:13.771]                       inherits <- base::inherits
[16:03:13.771]                       invokeRestart <- base::invokeRestart
[16:03:13.771]                       is.null <- base::is.null
[16:03:13.771]                       muffled <- FALSE
[16:03:13.771]                       if (inherits(cond, "message")) {
[16:03:13.771]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.771]                         if (muffled) 
[16:03:13.771]                           invokeRestart("muffleMessage")
[16:03:13.771]                       }
[16:03:13.771]                       else if (inherits(cond, "warning")) {
[16:03:13.771]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.771]                         if (muffled) 
[16:03:13.771]                           invokeRestart("muffleWarning")
[16:03:13.771]                       }
[16:03:13.771]                       else if (inherits(cond, "condition")) {
[16:03:13.771]                         if (!is.null(pattern)) {
[16:03:13.771]                           computeRestarts <- base::computeRestarts
[16:03:13.771]                           grepl <- base::grepl
[16:03:13.771]                           restarts <- computeRestarts(cond)
[16:03:13.771]                           for (restart in restarts) {
[16:03:13.771]                             name <- restart$name
[16:03:13.771]                             if (is.null(name)) 
[16:03:13.771]                               next
[16:03:13.771]                             if (!grepl(pattern, name)) 
[16:03:13.771]                               next
[16:03:13.771]                             invokeRestart(restart)
[16:03:13.771]                             muffled <- TRUE
[16:03:13.771]                             break
[16:03:13.771]                           }
[16:03:13.771]                         }
[16:03:13.771]                       }
[16:03:13.771]                       invisible(muffled)
[16:03:13.771]                     }
[16:03:13.771]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.771]                   }
[16:03:13.771]                 }
[16:03:13.771]             }
[16:03:13.771]         }))
[16:03:13.771]     }, error = function(ex) {
[16:03:13.771]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.771]                 ...future.rng), started = ...future.startTime, 
[16:03:13.771]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.771]             version = "1.8"), class = "FutureResult")
[16:03:13.771]     }, finally = {
[16:03:13.771]         if (!identical(...future.workdir, getwd())) 
[16:03:13.771]             setwd(...future.workdir)
[16:03:13.771]         {
[16:03:13.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.771]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.771]             }
[16:03:13.771]             base::options(...future.oldOptions)
[16:03:13.771]             if (.Platform$OS.type == "windows") {
[16:03:13.771]                 old_names <- names(...future.oldEnvVars)
[16:03:13.771]                 envs <- base::Sys.getenv()
[16:03:13.771]                 names <- names(envs)
[16:03:13.771]                 common <- intersect(names, old_names)
[16:03:13.771]                 added <- setdiff(names, old_names)
[16:03:13.771]                 removed <- setdiff(old_names, names)
[16:03:13.771]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.771]                   envs[common]]
[16:03:13.771]                 NAMES <- toupper(changed)
[16:03:13.771]                 args <- list()
[16:03:13.771]                 for (kk in seq_along(NAMES)) {
[16:03:13.771]                   name <- changed[[kk]]
[16:03:13.771]                   NAME <- NAMES[[kk]]
[16:03:13.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.771]                     next
[16:03:13.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.771]                 }
[16:03:13.771]                 NAMES <- toupper(added)
[16:03:13.771]                 for (kk in seq_along(NAMES)) {
[16:03:13.771]                   name <- added[[kk]]
[16:03:13.771]                   NAME <- NAMES[[kk]]
[16:03:13.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.771]                     next
[16:03:13.771]                   args[[name]] <- ""
[16:03:13.771]                 }
[16:03:13.771]                 NAMES <- toupper(removed)
[16:03:13.771]                 for (kk in seq_along(NAMES)) {
[16:03:13.771]                   name <- removed[[kk]]
[16:03:13.771]                   NAME <- NAMES[[kk]]
[16:03:13.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.771]                     next
[16:03:13.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.771]                 }
[16:03:13.771]                 if (length(args) > 0) 
[16:03:13.771]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.771]             }
[16:03:13.771]             else {
[16:03:13.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.771]             }
[16:03:13.771]             {
[16:03:13.771]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.771]                   0L) {
[16:03:13.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.771]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.771]                   base::options(opts)
[16:03:13.771]                 }
[16:03:13.771]                 {
[16:03:13.771]                   {
[16:03:13.771]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.771]                     NULL
[16:03:13.771]                   }
[16:03:13.771]                   options(future.plan = NULL)
[16:03:13.771]                   if (is.na(NA_character_)) 
[16:03:13.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.771]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.771]                     envir = parent.frame()) 
[16:03:13.771]                   {
[16:03:13.771]                     default_workers <- missing(workers)
[16:03:13.771]                     if (is.function(workers)) 
[16:03:13.771]                       workers <- workers()
[16:03:13.771]                     workers <- structure(as.integer(workers), 
[16:03:13.771]                       class = class(workers))
[16:03:13.771]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.771]                       1L)
[16:03:13.771]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.771]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.771]                       if (default_workers) 
[16:03:13.771]                         supportsMulticore(warn = TRUE)
[16:03:13.771]                       return(sequential(..., envir = envir))
[16:03:13.771]                     }
[16:03:13.771]                     oopts <- options(mc.cores = workers)
[16:03:13.771]                     on.exit(options(oopts))
[16:03:13.771]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.771]                       envir = envir)
[16:03:13.771]                     if (!future$lazy) 
[16:03:13.771]                       future <- run(future)
[16:03:13.771]                     invisible(future)
[16:03:13.771]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.771]                 }
[16:03:13.771]             }
[16:03:13.771]         }
[16:03:13.771]     })
[16:03:13.771]     if (TRUE) {
[16:03:13.771]         base::sink(type = "output", split = FALSE)
[16:03:13.771]         if (TRUE) {
[16:03:13.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.771]         }
[16:03:13.771]         else {
[16:03:13.771]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.771]         }
[16:03:13.771]         base::close(...future.stdout)
[16:03:13.771]         ...future.stdout <- NULL
[16:03:13.771]     }
[16:03:13.771]     ...future.result$conditions <- ...future.conditions
[16:03:13.771]     ...future.result$finished <- base::Sys.time()
[16:03:13.771]     ...future.result
[16:03:13.771] }
[16:03:13.773] assign_globals() ...
[16:03:13.774] List of 11
[16:03:13.774]  $ ...future.FUN            :function (x, ...)  
[16:03:13.774]  $ x_FUN                    :function (x)  
[16:03:13.774]  $ times                    : int 2
[16:03:13.774]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.774]  $ stop_if_not              :function (...)  
[16:03:13.774]  $ dim                      : NULL
[16:03:13.774]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:13.774]  $ future.call.arguments    : list()
[16:03:13.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.774]  $ ...future.elements_ii    :List of 5
[16:03:13.774]   ..$ : int 1
[16:03:13.774]   ..$ : int 2
[16:03:13.774]   ..$ : int 3
[16:03:13.774]   ..$ : int 4
[16:03:13.774]   ..$ : int 5
[16:03:13.774]  $ ...future.seeds_ii       : NULL
[16:03:13.774]  $ ...future.globals.maxSize: NULL
[16:03:13.774]  - attr(*, "where")=List of 11
[16:03:13.774]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.774]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.774]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.774]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.774]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.774]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.774]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.774]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.774]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.774]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.774]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.774]  - attr(*, "resolved")= logi FALSE
[16:03:13.774]  - attr(*, "total_size")= num 96456
[16:03:13.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.774]  - attr(*, "already-done")= logi TRUE
[16:03:13.784] - copied ‘...future.FUN’ to environment
[16:03:13.784] - reassign environment for ‘x_FUN’
[16:03:13.784] - copied ‘x_FUN’ to environment
[16:03:13.784] - copied ‘times’ to environment
[16:03:13.784] - copied ‘stopf’ to environment
[16:03:13.784] - copied ‘stop_if_not’ to environment
[16:03:13.784] - copied ‘dim’ to environment
[16:03:13.784] - copied ‘valid_types’ to environment
[16:03:13.784] - copied ‘future.call.arguments’ to environment
[16:03:13.784] - copied ‘...future.elements_ii’ to environment
[16:03:13.785] - copied ‘...future.seeds_ii’ to environment
[16:03:13.785] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.785] assign_globals() ... done
[16:03:13.785] requestCore(): workers = 2
[16:03:13.787] MulticoreFuture started
[16:03:13.787] - Launch lazy future ... done
[16:03:13.788] run() for ‘MulticoreFuture’ ... done
[16:03:13.788] Created future:
[16:03:13.789] plan(): Setting new future strategy stack:
[16:03:13.789] List of future strategies:
[16:03:13.789] 1. sequential:
[16:03:13.789]    - args: function (..., envir = parent.frame())
[16:03:13.789]    - tweaked: FALSE
[16:03:13.789]    - call: NULL
[16:03:13.790] plan(): nbrOfWorkers() = 1
[16:03:13.792] plan(): Setting new future strategy stack:
[16:03:13.792] List of future strategies:
[16:03:13.792] 1. multicore:
[16:03:13.792]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.792]    - tweaked: FALSE
[16:03:13.792]    - call: plan(strategy)
[16:03:13.797] plan(): nbrOfWorkers() = 2
[16:03:13.788] MulticoreFuture:
[16:03:13.788] Label: ‘future_vapply-1’
[16:03:13.788] Expression:
[16:03:13.788] {
[16:03:13.788]     do.call(function(...) {
[16:03:13.788]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.788]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.788]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.788]             on.exit(options(oopts), add = TRUE)
[16:03:13.788]         }
[16:03:13.788]         {
[16:03:13.788]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.788]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.788]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.788]             })
[16:03:13.788]         }
[16:03:13.788]     }, args = future.call.arguments)
[16:03:13.788] }
[16:03:13.788] Lazy evaluation: FALSE
[16:03:13.788] Asynchronous evaluation: TRUE
[16:03:13.788] Local evaluation: TRUE
[16:03:13.788] Environment: R_GlobalEnv
[16:03:13.788] Capture standard output: TRUE
[16:03:13.788] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.788] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.788] Packages: 1 packages (‘future.apply’)
[16:03:13.788] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.788] Resolved: TRUE
[16:03:13.788] Value: <not collected>
[16:03:13.788] Conditions captured: <none>
[16:03:13.788] Early signaling: FALSE
[16:03:13.788] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.788] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.798] Chunk #1 of 2 ... DONE
[16:03:13.798] Chunk #2 of 2 ...
[16:03:13.799]  - Finding globals in 'X' for chunk #2 ...
[16:03:13.799] getGlobalsAndPackages() ...
[16:03:13.799] Searching for globals...
[16:03:13.799] 
[16:03:13.800] Searching for globals ... DONE
[16:03:13.800] - globals: [0] <none>
[16:03:13.800] getGlobalsAndPackages() ... DONE
[16:03:13.800]    + additional globals found: [n=0] 
[16:03:13.800]    + additional namespaces needed: [n=0] 
[16:03:13.800]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:13.800]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.801]  - seeds: <none>
[16:03:13.801]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.801] getGlobalsAndPackages() ...
[16:03:13.801] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.801] Resolving globals: FALSE
[16:03:13.801] Tweak future expression to call with '...' arguments ...
[16:03:13.802] {
[16:03:13.802]     do.call(function(...) {
[16:03:13.802]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.802]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.802]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.802]             on.exit(options(oopts), add = TRUE)
[16:03:13.802]         }
[16:03:13.802]         {
[16:03:13.802]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.802]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.802]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.802]             })
[16:03:13.802]         }
[16:03:13.802]     }, args = future.call.arguments)
[16:03:13.802] }
[16:03:13.802] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.803] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.803] - packages: [1] ‘future.apply’
[16:03:13.803] getGlobalsAndPackages() ... DONE
[16:03:13.804] run() for ‘Future’ ...
[16:03:13.804] - state: ‘created’
[16:03:13.804] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.809] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.809] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.809]   - Field: ‘label’
[16:03:13.809]   - Field: ‘local’
[16:03:13.809]   - Field: ‘owner’
[16:03:13.809]   - Field: ‘envir’
[16:03:13.810]   - Field: ‘workers’
[16:03:13.810]   - Field: ‘packages’
[16:03:13.810]   - Field: ‘gc’
[16:03:13.810]   - Field: ‘job’
[16:03:13.810]   - Field: ‘conditions’
[16:03:13.810]   - Field: ‘expr’
[16:03:13.810]   - Field: ‘uuid’
[16:03:13.811]   - Field: ‘seed’
[16:03:13.811]   - Field: ‘version’
[16:03:13.811]   - Field: ‘result’
[16:03:13.811]   - Field: ‘asynchronous’
[16:03:13.811]   - Field: ‘calls’
[16:03:13.811]   - Field: ‘globals’
[16:03:13.812]   - Field: ‘stdout’
[16:03:13.812]   - Field: ‘earlySignal’
[16:03:13.812]   - Field: ‘lazy’
[16:03:13.812]   - Field: ‘state’
[16:03:13.812] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.812] - Launch lazy future ...
[16:03:13.813] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.815] Packages needed by future strategies (n = 0): <none>
[16:03:13.817] {
[16:03:13.817]     {
[16:03:13.817]         {
[16:03:13.817]             ...future.startTime <- base::Sys.time()
[16:03:13.817]             {
[16:03:13.817]                 {
[16:03:13.817]                   {
[16:03:13.817]                     {
[16:03:13.817]                       {
[16:03:13.817]                         base::local({
[16:03:13.817]                           has_future <- base::requireNamespace("future", 
[16:03:13.817]                             quietly = TRUE)
[16:03:13.817]                           if (has_future) {
[16:03:13.817]                             ns <- base::getNamespace("future")
[16:03:13.817]                             version <- ns[[".package"]][["version"]]
[16:03:13.817]                             if (is.null(version)) 
[16:03:13.817]                               version <- utils::packageVersion("future")
[16:03:13.817]                           }
[16:03:13.817]                           else {
[16:03:13.817]                             version <- NULL
[16:03:13.817]                           }
[16:03:13.817]                           if (!has_future || version < "1.8.0") {
[16:03:13.817]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.817]                               "", base::R.version$version.string), 
[16:03:13.817]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.817]                                 base::R.version$platform, 8 * 
[16:03:13.817]                                   base::.Machine$sizeof.pointer), 
[16:03:13.817]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.817]                                 "release", "version")], collapse = " "), 
[16:03:13.817]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.817]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.817]                               info)
[16:03:13.817]                             info <- base::paste(info, collapse = "; ")
[16:03:13.817]                             if (!has_future) {
[16:03:13.817]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.817]                                 info)
[16:03:13.817]                             }
[16:03:13.817]                             else {
[16:03:13.817]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.817]                                 info, version)
[16:03:13.817]                             }
[16:03:13.817]                             base::stop(msg)
[16:03:13.817]                           }
[16:03:13.817]                         })
[16:03:13.817]                       }
[16:03:13.817]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.817]                       base::options(mc.cores = 1L)
[16:03:13.817]                     }
[16:03:13.817]                     base::local({
[16:03:13.817]                       for (pkg in "future.apply") {
[16:03:13.817]                         base::loadNamespace(pkg)
[16:03:13.817]                         base::library(pkg, character.only = TRUE)
[16:03:13.817]                       }
[16:03:13.817]                     })
[16:03:13.817]                   }
[16:03:13.817]                   options(future.plan = NULL)
[16:03:13.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.817]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.817]                 }
[16:03:13.817]                 ...future.workdir <- getwd()
[16:03:13.817]             }
[16:03:13.817]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.817]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.817]         }
[16:03:13.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.817]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.817]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.817]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.817]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.817]             base::names(...future.oldOptions))
[16:03:13.817]     }
[16:03:13.817]     if (FALSE) {
[16:03:13.817]     }
[16:03:13.817]     else {
[16:03:13.817]         if (TRUE) {
[16:03:13.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.817]                 open = "w")
[16:03:13.817]         }
[16:03:13.817]         else {
[16:03:13.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.817]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.817]         }
[16:03:13.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.817]             base::sink(type = "output", split = FALSE)
[16:03:13.817]             base::close(...future.stdout)
[16:03:13.817]         }, add = TRUE)
[16:03:13.817]     }
[16:03:13.817]     ...future.frame <- base::sys.nframe()
[16:03:13.817]     ...future.conditions <- base::list()
[16:03:13.817]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.817]     if (FALSE) {
[16:03:13.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.817]     }
[16:03:13.817]     ...future.result <- base::tryCatch({
[16:03:13.817]         base::withCallingHandlers({
[16:03:13.817]             ...future.value <- base::withVisible(base::local({
[16:03:13.817]                 withCallingHandlers({
[16:03:13.817]                   {
[16:03:13.817]                     do.call(function(...) {
[16:03:13.817]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.817]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.817]                         ...future.globals.maxSize)) {
[16:03:13.817]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.817]                         on.exit(options(oopts), add = TRUE)
[16:03:13.817]                       }
[16:03:13.817]                       {
[16:03:13.817]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.817]                           FUN = function(jj) {
[16:03:13.817]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.817]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.817]                           })
[16:03:13.817]                       }
[16:03:13.817]                     }, args = future.call.arguments)
[16:03:13.817]                   }
[16:03:13.817]                 }, immediateCondition = function(cond) {
[16:03:13.817]                   save_rds <- function (object, pathname, ...) 
[16:03:13.817]                   {
[16:03:13.817]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.817]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.817]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.817]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.817]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.817]                         fi_tmp[["mtime"]])
[16:03:13.817]                     }
[16:03:13.817]                     tryCatch({
[16:03:13.817]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.817]                     }, error = function(ex) {
[16:03:13.817]                       msg <- conditionMessage(ex)
[16:03:13.817]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.817]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.817]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.817]                         fi_tmp[["mtime"]], msg)
[16:03:13.817]                       ex$message <- msg
[16:03:13.817]                       stop(ex)
[16:03:13.817]                     })
[16:03:13.817]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.817]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.817]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.817]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.817]                       fi <- file.info(pathname)
[16:03:13.817]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.817]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.817]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.817]                         fi[["size"]], fi[["mtime"]])
[16:03:13.817]                       stop(msg)
[16:03:13.817]                     }
[16:03:13.817]                     invisible(pathname)
[16:03:13.817]                   }
[16:03:13.817]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.817]                     rootPath = tempdir()) 
[16:03:13.817]                   {
[16:03:13.817]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.817]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.817]                       tmpdir = path, fileext = ".rds")
[16:03:13.817]                     save_rds(obj, file)
[16:03:13.817]                   }
[16:03:13.817]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.817]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.817]                   {
[16:03:13.817]                     inherits <- base::inherits
[16:03:13.817]                     invokeRestart <- base::invokeRestart
[16:03:13.817]                     is.null <- base::is.null
[16:03:13.817]                     muffled <- FALSE
[16:03:13.817]                     if (inherits(cond, "message")) {
[16:03:13.817]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.817]                       if (muffled) 
[16:03:13.817]                         invokeRestart("muffleMessage")
[16:03:13.817]                     }
[16:03:13.817]                     else if (inherits(cond, "warning")) {
[16:03:13.817]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.817]                       if (muffled) 
[16:03:13.817]                         invokeRestart("muffleWarning")
[16:03:13.817]                     }
[16:03:13.817]                     else if (inherits(cond, "condition")) {
[16:03:13.817]                       if (!is.null(pattern)) {
[16:03:13.817]                         computeRestarts <- base::computeRestarts
[16:03:13.817]                         grepl <- base::grepl
[16:03:13.817]                         restarts <- computeRestarts(cond)
[16:03:13.817]                         for (restart in restarts) {
[16:03:13.817]                           name <- restart$name
[16:03:13.817]                           if (is.null(name)) 
[16:03:13.817]                             next
[16:03:13.817]                           if (!grepl(pattern, name)) 
[16:03:13.817]                             next
[16:03:13.817]                           invokeRestart(restart)
[16:03:13.817]                           muffled <- TRUE
[16:03:13.817]                           break
[16:03:13.817]                         }
[16:03:13.817]                       }
[16:03:13.817]                     }
[16:03:13.817]                     invisible(muffled)
[16:03:13.817]                   }
[16:03:13.817]                   muffleCondition(cond)
[16:03:13.817]                 })
[16:03:13.817]             }))
[16:03:13.817]             future::FutureResult(value = ...future.value$value, 
[16:03:13.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.817]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.817]                     ...future.globalenv.names))
[16:03:13.817]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.817]         }, condition = base::local({
[16:03:13.817]             c <- base::c
[16:03:13.817]             inherits <- base::inherits
[16:03:13.817]             invokeRestart <- base::invokeRestart
[16:03:13.817]             length <- base::length
[16:03:13.817]             list <- base::list
[16:03:13.817]             seq.int <- base::seq.int
[16:03:13.817]             signalCondition <- base::signalCondition
[16:03:13.817]             sys.calls <- base::sys.calls
[16:03:13.817]             `[[` <- base::`[[`
[16:03:13.817]             `+` <- base::`+`
[16:03:13.817]             `<<-` <- base::`<<-`
[16:03:13.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.817]                   3L)]
[16:03:13.817]             }
[16:03:13.817]             function(cond) {
[16:03:13.817]                 is_error <- inherits(cond, "error")
[16:03:13.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.817]                   NULL)
[16:03:13.817]                 if (is_error) {
[16:03:13.817]                   sessionInformation <- function() {
[16:03:13.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.817]                       search = base::search(), system = base::Sys.info())
[16:03:13.817]                   }
[16:03:13.817]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.817]                     cond$call), session = sessionInformation(), 
[16:03:13.817]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.817]                   signalCondition(cond)
[16:03:13.817]                 }
[16:03:13.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.817]                 "immediateCondition"))) {
[16:03:13.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.817]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.817]                   if (TRUE && !signal) {
[16:03:13.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.817]                     {
[16:03:13.817]                       inherits <- base::inherits
[16:03:13.817]                       invokeRestart <- base::invokeRestart
[16:03:13.817]                       is.null <- base::is.null
[16:03:13.817]                       muffled <- FALSE
[16:03:13.817]                       if (inherits(cond, "message")) {
[16:03:13.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.817]                         if (muffled) 
[16:03:13.817]                           invokeRestart("muffleMessage")
[16:03:13.817]                       }
[16:03:13.817]                       else if (inherits(cond, "warning")) {
[16:03:13.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.817]                         if (muffled) 
[16:03:13.817]                           invokeRestart("muffleWarning")
[16:03:13.817]                       }
[16:03:13.817]                       else if (inherits(cond, "condition")) {
[16:03:13.817]                         if (!is.null(pattern)) {
[16:03:13.817]                           computeRestarts <- base::computeRestarts
[16:03:13.817]                           grepl <- base::grepl
[16:03:13.817]                           restarts <- computeRestarts(cond)
[16:03:13.817]                           for (restart in restarts) {
[16:03:13.817]                             name <- restart$name
[16:03:13.817]                             if (is.null(name)) 
[16:03:13.817]                               next
[16:03:13.817]                             if (!grepl(pattern, name)) 
[16:03:13.817]                               next
[16:03:13.817]                             invokeRestart(restart)
[16:03:13.817]                             muffled <- TRUE
[16:03:13.817]                             break
[16:03:13.817]                           }
[16:03:13.817]                         }
[16:03:13.817]                       }
[16:03:13.817]                       invisible(muffled)
[16:03:13.817]                     }
[16:03:13.817]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.817]                   }
[16:03:13.817]                 }
[16:03:13.817]                 else {
[16:03:13.817]                   if (TRUE) {
[16:03:13.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.817]                     {
[16:03:13.817]                       inherits <- base::inherits
[16:03:13.817]                       invokeRestart <- base::invokeRestart
[16:03:13.817]                       is.null <- base::is.null
[16:03:13.817]                       muffled <- FALSE
[16:03:13.817]                       if (inherits(cond, "message")) {
[16:03:13.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.817]                         if (muffled) 
[16:03:13.817]                           invokeRestart("muffleMessage")
[16:03:13.817]                       }
[16:03:13.817]                       else if (inherits(cond, "warning")) {
[16:03:13.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.817]                         if (muffled) 
[16:03:13.817]                           invokeRestart("muffleWarning")
[16:03:13.817]                       }
[16:03:13.817]                       else if (inherits(cond, "condition")) {
[16:03:13.817]                         if (!is.null(pattern)) {
[16:03:13.817]                           computeRestarts <- base::computeRestarts
[16:03:13.817]                           grepl <- base::grepl
[16:03:13.817]                           restarts <- computeRestarts(cond)
[16:03:13.817]                           for (restart in restarts) {
[16:03:13.817]                             name <- restart$name
[16:03:13.817]                             if (is.null(name)) 
[16:03:13.817]                               next
[16:03:13.817]                             if (!grepl(pattern, name)) 
[16:03:13.817]                               next
[16:03:13.817]                             invokeRestart(restart)
[16:03:13.817]                             muffled <- TRUE
[16:03:13.817]                             break
[16:03:13.817]                           }
[16:03:13.817]                         }
[16:03:13.817]                       }
[16:03:13.817]                       invisible(muffled)
[16:03:13.817]                     }
[16:03:13.817]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.817]                   }
[16:03:13.817]                 }
[16:03:13.817]             }
[16:03:13.817]         }))
[16:03:13.817]     }, error = function(ex) {
[16:03:13.817]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.817]                 ...future.rng), started = ...future.startTime, 
[16:03:13.817]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.817]             version = "1.8"), class = "FutureResult")
[16:03:13.817]     }, finally = {
[16:03:13.817]         if (!identical(...future.workdir, getwd())) 
[16:03:13.817]             setwd(...future.workdir)
[16:03:13.817]         {
[16:03:13.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.817]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.817]             }
[16:03:13.817]             base::options(...future.oldOptions)
[16:03:13.817]             if (.Platform$OS.type == "windows") {
[16:03:13.817]                 old_names <- names(...future.oldEnvVars)
[16:03:13.817]                 envs <- base::Sys.getenv()
[16:03:13.817]                 names <- names(envs)
[16:03:13.817]                 common <- intersect(names, old_names)
[16:03:13.817]                 added <- setdiff(names, old_names)
[16:03:13.817]                 removed <- setdiff(old_names, names)
[16:03:13.817]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.817]                   envs[common]]
[16:03:13.817]                 NAMES <- toupper(changed)
[16:03:13.817]                 args <- list()
[16:03:13.817]                 for (kk in seq_along(NAMES)) {
[16:03:13.817]                   name <- changed[[kk]]
[16:03:13.817]                   NAME <- NAMES[[kk]]
[16:03:13.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.817]                     next
[16:03:13.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.817]                 }
[16:03:13.817]                 NAMES <- toupper(added)
[16:03:13.817]                 for (kk in seq_along(NAMES)) {
[16:03:13.817]                   name <- added[[kk]]
[16:03:13.817]                   NAME <- NAMES[[kk]]
[16:03:13.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.817]                     next
[16:03:13.817]                   args[[name]] <- ""
[16:03:13.817]                 }
[16:03:13.817]                 NAMES <- toupper(removed)
[16:03:13.817]                 for (kk in seq_along(NAMES)) {
[16:03:13.817]                   name <- removed[[kk]]
[16:03:13.817]                   NAME <- NAMES[[kk]]
[16:03:13.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.817]                     next
[16:03:13.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.817]                 }
[16:03:13.817]                 if (length(args) > 0) 
[16:03:13.817]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.817]             }
[16:03:13.817]             else {
[16:03:13.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.817]             }
[16:03:13.817]             {
[16:03:13.817]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.817]                   0L) {
[16:03:13.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.817]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.817]                   base::options(opts)
[16:03:13.817]                 }
[16:03:13.817]                 {
[16:03:13.817]                   {
[16:03:13.817]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.817]                     NULL
[16:03:13.817]                   }
[16:03:13.817]                   options(future.plan = NULL)
[16:03:13.817]                   if (is.na(NA_character_)) 
[16:03:13.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.817]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.817]                     envir = parent.frame()) 
[16:03:13.817]                   {
[16:03:13.817]                     default_workers <- missing(workers)
[16:03:13.817]                     if (is.function(workers)) 
[16:03:13.817]                       workers <- workers()
[16:03:13.817]                     workers <- structure(as.integer(workers), 
[16:03:13.817]                       class = class(workers))
[16:03:13.817]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.817]                       1L)
[16:03:13.817]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.817]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.817]                       if (default_workers) 
[16:03:13.817]                         supportsMulticore(warn = TRUE)
[16:03:13.817]                       return(sequential(..., envir = envir))
[16:03:13.817]                     }
[16:03:13.817]                     oopts <- options(mc.cores = workers)
[16:03:13.817]                     on.exit(options(oopts))
[16:03:13.817]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.817]                       envir = envir)
[16:03:13.817]                     if (!future$lazy) 
[16:03:13.817]                       future <- run(future)
[16:03:13.817]                     invisible(future)
[16:03:13.817]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.817]                 }
[16:03:13.817]             }
[16:03:13.817]         }
[16:03:13.817]     })
[16:03:13.817]     if (TRUE) {
[16:03:13.817]         base::sink(type = "output", split = FALSE)
[16:03:13.817]         if (TRUE) {
[16:03:13.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.817]         }
[16:03:13.817]         else {
[16:03:13.817]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.817]         }
[16:03:13.817]         base::close(...future.stdout)
[16:03:13.817]         ...future.stdout <- NULL
[16:03:13.817]     }
[16:03:13.817]     ...future.result$conditions <- ...future.conditions
[16:03:13.817]     ...future.result$finished <- base::Sys.time()
[16:03:13.817]     ...future.result
[16:03:13.817] }
[16:03:13.821] assign_globals() ...
[16:03:13.821] List of 11
[16:03:13.821]  $ ...future.FUN            :function (x, ...)  
[16:03:13.821]  $ x_FUN                    :function (x)  
[16:03:13.821]  $ times                    : int 2
[16:03:13.821]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.821]  $ stop_if_not              :function (...)  
[16:03:13.821]  $ dim                      : NULL
[16:03:13.821]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:13.821]  $ future.call.arguments    : list()
[16:03:13.821]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.821]  $ ...future.elements_ii    :List of 5
[16:03:13.821]   ..$ : int 6
[16:03:13.821]   ..$ : int 7
[16:03:13.821]   ..$ : int 8
[16:03:13.821]   ..$ : int 9
[16:03:13.821]   ..$ : int 10
[16:03:13.821]  $ ...future.seeds_ii       : NULL
[16:03:13.821]  $ ...future.globals.maxSize: NULL
[16:03:13.821]  - attr(*, "where")=List of 11
[16:03:13.821]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.821]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.821]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.821]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.821]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.821]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.821]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.821]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.821]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.821]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.821]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.821]  - attr(*, "resolved")= logi FALSE
[16:03:13.821]  - attr(*, "total_size")= num 96456
[16:03:13.821]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.821]  - attr(*, "already-done")= logi TRUE
[16:03:13.834] - copied ‘...future.FUN’ to environment
[16:03:13.835] - reassign environment for ‘x_FUN’
[16:03:13.835] - copied ‘x_FUN’ to environment
[16:03:13.835] - copied ‘times’ to environment
[16:03:13.835] - copied ‘stopf’ to environment
[16:03:13.835] - copied ‘stop_if_not’ to environment
[16:03:13.835] - copied ‘dim’ to environment
[16:03:13.835] - copied ‘valid_types’ to environment
[16:03:13.835] - copied ‘future.call.arguments’ to environment
[16:03:13.835] - copied ‘...future.elements_ii’ to environment
[16:03:13.835] - copied ‘...future.seeds_ii’ to environment
[16:03:13.836] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.836] assign_globals() ... done
[16:03:13.836] requestCore(): workers = 2
[16:03:13.838] MulticoreFuture started
[16:03:13.838] - Launch lazy future ... done
[16:03:13.839] run() for ‘MulticoreFuture’ ... done
[16:03:13.839] Created future:
[16:03:13.840] plan(): Setting new future strategy stack:
[16:03:13.840] List of future strategies:
[16:03:13.840] 1. sequential:
[16:03:13.840]    - args: function (..., envir = parent.frame())
[16:03:13.840]    - tweaked: FALSE
[16:03:13.840]    - call: NULL
[16:03:13.841] plan(): nbrOfWorkers() = 1
[16:03:13.843] plan(): Setting new future strategy stack:
[16:03:13.843] List of future strategies:
[16:03:13.843] 1. multicore:
[16:03:13.843]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.843]    - tweaked: FALSE
[16:03:13.843]    - call: plan(strategy)
[16:03:13.848] plan(): nbrOfWorkers() = 2
[16:03:13.839] MulticoreFuture:
[16:03:13.839] Label: ‘future_vapply-2’
[16:03:13.839] Expression:
[16:03:13.839] {
[16:03:13.839]     do.call(function(...) {
[16:03:13.839]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.839]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.839]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.839]             on.exit(options(oopts), add = TRUE)
[16:03:13.839]         }
[16:03:13.839]         {
[16:03:13.839]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.839]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.839]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.839]             })
[16:03:13.839]         }
[16:03:13.839]     }, args = future.call.arguments)
[16:03:13.839] }
[16:03:13.839] Lazy evaluation: FALSE
[16:03:13.839] Asynchronous evaluation: TRUE
[16:03:13.839] Local evaluation: TRUE
[16:03:13.839] Environment: R_GlobalEnv
[16:03:13.839] Capture standard output: TRUE
[16:03:13.839] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.839] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.839] Packages: 1 packages (‘future.apply’)
[16:03:13.839] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.839] Resolved: TRUE
[16:03:13.839] Value: <not collected>
[16:03:13.839] Conditions captured: <none>
[16:03:13.839] Early signaling: FALSE
[16:03:13.839] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.839] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.849] Chunk #2 of 2 ... DONE
[16:03:13.849] Launching 2 futures (chunks) ... DONE
[16:03:13.849] Resolving 2 futures (chunks) ...
[16:03:13.850] resolve() on list ...
[16:03:13.850]  recursive: 0
[16:03:13.850]  length: 2
[16:03:13.850] 
[16:03:13.850] Future #1
[16:03:13.850] result() for MulticoreFuture ...
[16:03:13.851] result() for MulticoreFuture ...
[16:03:13.851] result() for MulticoreFuture ... done
[16:03:13.852] result() for MulticoreFuture ... done
[16:03:13.852] result() for MulticoreFuture ...
[16:03:13.852] result() for MulticoreFuture ... done
[16:03:13.852] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:13.852] - nx: 2
[16:03:13.852] - relay: TRUE
[16:03:13.852] - stdout: TRUE
[16:03:13.853] - signal: TRUE
[16:03:13.853] - resignal: FALSE
[16:03:13.853] - force: TRUE
[16:03:13.853] - relayed: [n=2] FALSE, FALSE
[16:03:13.853] - queued futures: [n=2] FALSE, FALSE
[16:03:13.853]  - until=1
[16:03:13.853]  - relaying element #1
[16:03:13.854] result() for MulticoreFuture ...
[16:03:13.854] result() for MulticoreFuture ... done
[16:03:13.854] result() for MulticoreFuture ...
[16:03:13.854] result() for MulticoreFuture ... done
[16:03:13.854] result() for MulticoreFuture ...
[16:03:13.854] result() for MulticoreFuture ... done
[16:03:13.855] result() for MulticoreFuture ...
[16:03:13.855] result() for MulticoreFuture ... done
[16:03:13.855] - relayed: [n=2] TRUE, FALSE
[16:03:13.855] - queued futures: [n=2] TRUE, FALSE
[16:03:13.855] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:13.855]  length: 1 (resolved future 1)
[16:03:13.856] Future #2
[16:03:13.856] result() for MulticoreFuture ...
[16:03:13.860] result() for MulticoreFuture ...
[16:03:13.860] result() for MulticoreFuture ... done
[16:03:13.861] result() for MulticoreFuture ... done
[16:03:13.861] result() for MulticoreFuture ...
[16:03:13.861] result() for MulticoreFuture ... done
[16:03:13.861] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:13.862] - nx: 2
[16:03:13.862] - relay: TRUE
[16:03:13.862] - stdout: TRUE
[16:03:13.862] - signal: TRUE
[16:03:13.862] - resignal: FALSE
[16:03:13.862] - force: TRUE
[16:03:13.863] - relayed: [n=2] TRUE, FALSE
[16:03:13.863] - queued futures: [n=2] TRUE, FALSE
[16:03:13.863]  - until=2
[16:03:13.863]  - relaying element #2
[16:03:13.863] result() for MulticoreFuture ...
[16:03:13.863] result() for MulticoreFuture ... done
[16:03:13.864] result() for MulticoreFuture ...
[16:03:13.864] result() for MulticoreFuture ... done
[16:03:13.864] result() for MulticoreFuture ...
[16:03:13.864] result() for MulticoreFuture ... done
[16:03:13.864] result() for MulticoreFuture ...
[16:03:13.864] result() for MulticoreFuture ... done
[16:03:13.865] - relayed: [n=2] TRUE, TRUE
[16:03:13.865] - queued futures: [n=2] TRUE, TRUE
[16:03:13.865] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:13.865]  length: 0 (resolved future 2)
[16:03:13.865] Relaying remaining futures
[16:03:13.865] signalConditionsASAP(NULL, pos=0) ...
[16:03:13.865] - nx: 2
[16:03:13.866] - relay: TRUE
[16:03:13.866] - stdout: TRUE
[16:03:13.866] - signal: TRUE
[16:03:13.866] - resignal: FALSE
[16:03:13.866] - force: TRUE
[16:03:13.866] - relayed: [n=2] TRUE, TRUE
[16:03:13.866] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:13.866] - relayed: [n=2] TRUE, TRUE
[16:03:13.867] - queued futures: [n=2] TRUE, TRUE
[16:03:13.867] signalConditionsASAP(NULL, pos=0) ... done
[16:03:13.867] resolve() on list ... DONE
[16:03:13.867] result() for MulticoreFuture ...
[16:03:13.867] result() for MulticoreFuture ... done
[16:03:13.867] result() for MulticoreFuture ...
[16:03:13.867] result() for MulticoreFuture ... done
[16:03:13.867] result() for MulticoreFuture ...
[16:03:13.867] result() for MulticoreFuture ... done
[16:03:13.868] result() for MulticoreFuture ...
[16:03:13.868] result() for MulticoreFuture ... done
[16:03:13.868]  - Number of value chunks collected: 2
[16:03:13.868] Resolving 2 futures (chunks) ... DONE
[16:03:13.868] Reducing values from 2 chunks ...
[16:03:13.868]  - Number of values collected after concatenation: 10
[16:03:13.868]  - Number of values expected: 10
[16:03:13.868] Reducing values from 2 chunks ... DONE
[16:03:13.869] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:03:13.870] future_lapply() ...
[16:03:13.876] Number of chunks: 2
[16:03:13.877] getGlobalsAndPackagesXApply() ...
[16:03:13.877]  - future.globals: TRUE
[16:03:13.877] getGlobalsAndPackages() ...
[16:03:13.877] Searching for globals...
[16:03:13.881] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:03:13.881] Searching for globals ... DONE
[16:03:13.881] Resolving globals: FALSE
[16:03:13.882] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[16:03:13.882] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:13.882] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.882] - packages: [1] ‘future.apply’
[16:03:13.883] getGlobalsAndPackages() ... DONE
[16:03:13.883]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:13.883]  - needed namespaces: [n=1] ‘future.apply’
[16:03:13.883] Finding globals ... DONE
[16:03:13.883]  - use_args: TRUE
[16:03:13.883]  - Getting '...' globals ...
[16:03:13.883] resolve() on list ...
[16:03:13.884]  recursive: 0
[16:03:13.884]  length: 1
[16:03:13.884]  elements: ‘...’
[16:03:13.884]  length: 0 (resolved future 1)
[16:03:13.884] resolve() on list ... DONE
[16:03:13.884]    - '...' content: [n=0] 
[16:03:13.884] List of 1
[16:03:13.884]  $ ...: list()
[16:03:13.884]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.884]  - attr(*, "where")=List of 1
[16:03:13.884]   ..$ ...:<environment: 0x564e41171a70> 
[16:03:13.884]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.884]  - attr(*, "resolved")= logi TRUE
[16:03:13.884]  - attr(*, "total_size")= num NA
[16:03:13.889]  - Getting '...' globals ... DONE
[16:03:13.889] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:13.889] List of 8
[16:03:13.889]  $ ...future.FUN:function (x, ...)  
[16:03:13.889]  $ x_FUN        :function (x)  
[16:03:13.889]  $ times        : int 4
[16:03:13.889]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.889]  $ stop_if_not  :function (...)  
[16:03:13.889]  $ dim          : int [1:2] 2 2
[16:03:13.889]  $ valid_types  : chr [1:2] "logical" "integer"
[16:03:13.889]  $ ...          : list()
[16:03:13.889]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.889]  - attr(*, "where")=List of 8
[16:03:13.889]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:13.889]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:13.889]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:13.889]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:13.889]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:13.889]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:13.889]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:13.889]   ..$ ...          :<environment: 0x564e41171a70> 
[16:03:13.889]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.889]  - attr(*, "resolved")= logi FALSE
[16:03:13.889]  - attr(*, "total_size")= num 97232
[16:03:13.895] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:13.895] getGlobalsAndPackagesXApply() ... DONE
[16:03:13.895] Number of futures (= number of chunks): 2
[16:03:13.895] Launching 2 futures (chunks) ...
[16:03:13.895] Chunk #1 of 2 ...
[16:03:13.895]  - Finding globals in 'X' for chunk #1 ...
[16:03:13.895] getGlobalsAndPackages() ...
[16:03:13.896] Searching for globals...
[16:03:13.896] 
[16:03:13.896] Searching for globals ... DONE
[16:03:13.896] - globals: [0] <none>
[16:03:13.896] getGlobalsAndPackages() ... DONE
[16:03:13.896]    + additional globals found: [n=0] 
[16:03:13.896]    + additional namespaces needed: [n=0] 
[16:03:13.896]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:13.896]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.897]  - seeds: <none>
[16:03:13.897]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.897] getGlobalsAndPackages() ...
[16:03:13.897] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.897] Resolving globals: FALSE
[16:03:13.897] Tweak future expression to call with '...' arguments ...
[16:03:13.897] {
[16:03:13.897]     do.call(function(...) {
[16:03:13.897]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.897]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.897]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.897]             on.exit(options(oopts), add = TRUE)
[16:03:13.897]         }
[16:03:13.897]         {
[16:03:13.897]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.897]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.897]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.897]             })
[16:03:13.897]         }
[16:03:13.897]     }, args = future.call.arguments)
[16:03:13.897] }
[16:03:13.897] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.898] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.898] - packages: [1] ‘future.apply’
[16:03:13.898] getGlobalsAndPackages() ... DONE
[16:03:13.899] run() for ‘Future’ ...
[16:03:13.899] - state: ‘created’
[16:03:13.899] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.902] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.903]   - Field: ‘label’
[16:03:13.903]   - Field: ‘local’
[16:03:13.903]   - Field: ‘owner’
[16:03:13.903]   - Field: ‘envir’
[16:03:13.903]   - Field: ‘workers’
[16:03:13.903]   - Field: ‘packages’
[16:03:13.903]   - Field: ‘gc’
[16:03:13.903]   - Field: ‘job’
[16:03:13.904]   - Field: ‘conditions’
[16:03:13.904]   - Field: ‘expr’
[16:03:13.904]   - Field: ‘uuid’
[16:03:13.904]   - Field: ‘seed’
[16:03:13.904]   - Field: ‘version’
[16:03:13.904]   - Field: ‘result’
[16:03:13.904]   - Field: ‘asynchronous’
[16:03:13.904]   - Field: ‘calls’
[16:03:13.904]   - Field: ‘globals’
[16:03:13.904]   - Field: ‘stdout’
[16:03:13.904]   - Field: ‘earlySignal’
[16:03:13.905]   - Field: ‘lazy’
[16:03:13.905]   - Field: ‘state’
[16:03:13.905] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.905] - Launch lazy future ...
[16:03:13.905] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.905] Packages needed by future strategies (n = 0): <none>
[16:03:13.906] {
[16:03:13.906]     {
[16:03:13.906]         {
[16:03:13.906]             ...future.startTime <- base::Sys.time()
[16:03:13.906]             {
[16:03:13.906]                 {
[16:03:13.906]                   {
[16:03:13.906]                     {
[16:03:13.906]                       {
[16:03:13.906]                         base::local({
[16:03:13.906]                           has_future <- base::requireNamespace("future", 
[16:03:13.906]                             quietly = TRUE)
[16:03:13.906]                           if (has_future) {
[16:03:13.906]                             ns <- base::getNamespace("future")
[16:03:13.906]                             version <- ns[[".package"]][["version"]]
[16:03:13.906]                             if (is.null(version)) 
[16:03:13.906]                               version <- utils::packageVersion("future")
[16:03:13.906]                           }
[16:03:13.906]                           else {
[16:03:13.906]                             version <- NULL
[16:03:13.906]                           }
[16:03:13.906]                           if (!has_future || version < "1.8.0") {
[16:03:13.906]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.906]                               "", base::R.version$version.string), 
[16:03:13.906]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.906]                                 base::R.version$platform, 8 * 
[16:03:13.906]                                   base::.Machine$sizeof.pointer), 
[16:03:13.906]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.906]                                 "release", "version")], collapse = " "), 
[16:03:13.906]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.906]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.906]                               info)
[16:03:13.906]                             info <- base::paste(info, collapse = "; ")
[16:03:13.906]                             if (!has_future) {
[16:03:13.906]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.906]                                 info)
[16:03:13.906]                             }
[16:03:13.906]                             else {
[16:03:13.906]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.906]                                 info, version)
[16:03:13.906]                             }
[16:03:13.906]                             base::stop(msg)
[16:03:13.906]                           }
[16:03:13.906]                         })
[16:03:13.906]                       }
[16:03:13.906]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.906]                       base::options(mc.cores = 1L)
[16:03:13.906]                     }
[16:03:13.906]                     base::local({
[16:03:13.906]                       for (pkg in "future.apply") {
[16:03:13.906]                         base::loadNamespace(pkg)
[16:03:13.906]                         base::library(pkg, character.only = TRUE)
[16:03:13.906]                       }
[16:03:13.906]                     })
[16:03:13.906]                   }
[16:03:13.906]                   options(future.plan = NULL)
[16:03:13.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.906]                 }
[16:03:13.906]                 ...future.workdir <- getwd()
[16:03:13.906]             }
[16:03:13.906]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.906]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.906]         }
[16:03:13.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.906]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.906]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.906]             base::names(...future.oldOptions))
[16:03:13.906]     }
[16:03:13.906]     if (FALSE) {
[16:03:13.906]     }
[16:03:13.906]     else {
[16:03:13.906]         if (TRUE) {
[16:03:13.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.906]                 open = "w")
[16:03:13.906]         }
[16:03:13.906]         else {
[16:03:13.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.906]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.906]         }
[16:03:13.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.906]             base::sink(type = "output", split = FALSE)
[16:03:13.906]             base::close(...future.stdout)
[16:03:13.906]         }, add = TRUE)
[16:03:13.906]     }
[16:03:13.906]     ...future.frame <- base::sys.nframe()
[16:03:13.906]     ...future.conditions <- base::list()
[16:03:13.906]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.906]     if (FALSE) {
[16:03:13.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.906]     }
[16:03:13.906]     ...future.result <- base::tryCatch({
[16:03:13.906]         base::withCallingHandlers({
[16:03:13.906]             ...future.value <- base::withVisible(base::local({
[16:03:13.906]                 withCallingHandlers({
[16:03:13.906]                   {
[16:03:13.906]                     do.call(function(...) {
[16:03:13.906]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.906]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.906]                         ...future.globals.maxSize)) {
[16:03:13.906]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.906]                         on.exit(options(oopts), add = TRUE)
[16:03:13.906]                       }
[16:03:13.906]                       {
[16:03:13.906]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.906]                           FUN = function(jj) {
[16:03:13.906]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.906]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.906]                           })
[16:03:13.906]                       }
[16:03:13.906]                     }, args = future.call.arguments)
[16:03:13.906]                   }
[16:03:13.906]                 }, immediateCondition = function(cond) {
[16:03:13.906]                   save_rds <- function (object, pathname, ...) 
[16:03:13.906]                   {
[16:03:13.906]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.906]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.906]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.906]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.906]                         fi_tmp[["mtime"]])
[16:03:13.906]                     }
[16:03:13.906]                     tryCatch({
[16:03:13.906]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.906]                     }, error = function(ex) {
[16:03:13.906]                       msg <- conditionMessage(ex)
[16:03:13.906]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.906]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.906]                         fi_tmp[["mtime"]], msg)
[16:03:13.906]                       ex$message <- msg
[16:03:13.906]                       stop(ex)
[16:03:13.906]                     })
[16:03:13.906]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.906]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.906]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.906]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.906]                       fi <- file.info(pathname)
[16:03:13.906]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.906]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.906]                         fi[["size"]], fi[["mtime"]])
[16:03:13.906]                       stop(msg)
[16:03:13.906]                     }
[16:03:13.906]                     invisible(pathname)
[16:03:13.906]                   }
[16:03:13.906]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.906]                     rootPath = tempdir()) 
[16:03:13.906]                   {
[16:03:13.906]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.906]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.906]                       tmpdir = path, fileext = ".rds")
[16:03:13.906]                     save_rds(obj, file)
[16:03:13.906]                   }
[16:03:13.906]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.906]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.906]                   {
[16:03:13.906]                     inherits <- base::inherits
[16:03:13.906]                     invokeRestart <- base::invokeRestart
[16:03:13.906]                     is.null <- base::is.null
[16:03:13.906]                     muffled <- FALSE
[16:03:13.906]                     if (inherits(cond, "message")) {
[16:03:13.906]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.906]                       if (muffled) 
[16:03:13.906]                         invokeRestart("muffleMessage")
[16:03:13.906]                     }
[16:03:13.906]                     else if (inherits(cond, "warning")) {
[16:03:13.906]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.906]                       if (muffled) 
[16:03:13.906]                         invokeRestart("muffleWarning")
[16:03:13.906]                     }
[16:03:13.906]                     else if (inherits(cond, "condition")) {
[16:03:13.906]                       if (!is.null(pattern)) {
[16:03:13.906]                         computeRestarts <- base::computeRestarts
[16:03:13.906]                         grepl <- base::grepl
[16:03:13.906]                         restarts <- computeRestarts(cond)
[16:03:13.906]                         for (restart in restarts) {
[16:03:13.906]                           name <- restart$name
[16:03:13.906]                           if (is.null(name)) 
[16:03:13.906]                             next
[16:03:13.906]                           if (!grepl(pattern, name)) 
[16:03:13.906]                             next
[16:03:13.906]                           invokeRestart(restart)
[16:03:13.906]                           muffled <- TRUE
[16:03:13.906]                           break
[16:03:13.906]                         }
[16:03:13.906]                       }
[16:03:13.906]                     }
[16:03:13.906]                     invisible(muffled)
[16:03:13.906]                   }
[16:03:13.906]                   muffleCondition(cond)
[16:03:13.906]                 })
[16:03:13.906]             }))
[16:03:13.906]             future::FutureResult(value = ...future.value$value, 
[16:03:13.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.906]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.906]                     ...future.globalenv.names))
[16:03:13.906]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.906]         }, condition = base::local({
[16:03:13.906]             c <- base::c
[16:03:13.906]             inherits <- base::inherits
[16:03:13.906]             invokeRestart <- base::invokeRestart
[16:03:13.906]             length <- base::length
[16:03:13.906]             list <- base::list
[16:03:13.906]             seq.int <- base::seq.int
[16:03:13.906]             signalCondition <- base::signalCondition
[16:03:13.906]             sys.calls <- base::sys.calls
[16:03:13.906]             `[[` <- base::`[[`
[16:03:13.906]             `+` <- base::`+`
[16:03:13.906]             `<<-` <- base::`<<-`
[16:03:13.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.906]                   3L)]
[16:03:13.906]             }
[16:03:13.906]             function(cond) {
[16:03:13.906]                 is_error <- inherits(cond, "error")
[16:03:13.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.906]                   NULL)
[16:03:13.906]                 if (is_error) {
[16:03:13.906]                   sessionInformation <- function() {
[16:03:13.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.906]                       search = base::search(), system = base::Sys.info())
[16:03:13.906]                   }
[16:03:13.906]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.906]                     cond$call), session = sessionInformation(), 
[16:03:13.906]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.906]                   signalCondition(cond)
[16:03:13.906]                 }
[16:03:13.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.906]                 "immediateCondition"))) {
[16:03:13.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.906]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.906]                   if (TRUE && !signal) {
[16:03:13.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.906]                     {
[16:03:13.906]                       inherits <- base::inherits
[16:03:13.906]                       invokeRestart <- base::invokeRestart
[16:03:13.906]                       is.null <- base::is.null
[16:03:13.906]                       muffled <- FALSE
[16:03:13.906]                       if (inherits(cond, "message")) {
[16:03:13.906]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.906]                         if (muffled) 
[16:03:13.906]                           invokeRestart("muffleMessage")
[16:03:13.906]                       }
[16:03:13.906]                       else if (inherits(cond, "warning")) {
[16:03:13.906]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.906]                         if (muffled) 
[16:03:13.906]                           invokeRestart("muffleWarning")
[16:03:13.906]                       }
[16:03:13.906]                       else if (inherits(cond, "condition")) {
[16:03:13.906]                         if (!is.null(pattern)) {
[16:03:13.906]                           computeRestarts <- base::computeRestarts
[16:03:13.906]                           grepl <- base::grepl
[16:03:13.906]                           restarts <- computeRestarts(cond)
[16:03:13.906]                           for (restart in restarts) {
[16:03:13.906]                             name <- restart$name
[16:03:13.906]                             if (is.null(name)) 
[16:03:13.906]                               next
[16:03:13.906]                             if (!grepl(pattern, name)) 
[16:03:13.906]                               next
[16:03:13.906]                             invokeRestart(restart)
[16:03:13.906]                             muffled <- TRUE
[16:03:13.906]                             break
[16:03:13.906]                           }
[16:03:13.906]                         }
[16:03:13.906]                       }
[16:03:13.906]                       invisible(muffled)
[16:03:13.906]                     }
[16:03:13.906]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.906]                   }
[16:03:13.906]                 }
[16:03:13.906]                 else {
[16:03:13.906]                   if (TRUE) {
[16:03:13.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.906]                     {
[16:03:13.906]                       inherits <- base::inherits
[16:03:13.906]                       invokeRestart <- base::invokeRestart
[16:03:13.906]                       is.null <- base::is.null
[16:03:13.906]                       muffled <- FALSE
[16:03:13.906]                       if (inherits(cond, "message")) {
[16:03:13.906]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.906]                         if (muffled) 
[16:03:13.906]                           invokeRestart("muffleMessage")
[16:03:13.906]                       }
[16:03:13.906]                       else if (inherits(cond, "warning")) {
[16:03:13.906]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.906]                         if (muffled) 
[16:03:13.906]                           invokeRestart("muffleWarning")
[16:03:13.906]                       }
[16:03:13.906]                       else if (inherits(cond, "condition")) {
[16:03:13.906]                         if (!is.null(pattern)) {
[16:03:13.906]                           computeRestarts <- base::computeRestarts
[16:03:13.906]                           grepl <- base::grepl
[16:03:13.906]                           restarts <- computeRestarts(cond)
[16:03:13.906]                           for (restart in restarts) {
[16:03:13.906]                             name <- restart$name
[16:03:13.906]                             if (is.null(name)) 
[16:03:13.906]                               next
[16:03:13.906]                             if (!grepl(pattern, name)) 
[16:03:13.906]                               next
[16:03:13.906]                             invokeRestart(restart)
[16:03:13.906]                             muffled <- TRUE
[16:03:13.906]                             break
[16:03:13.906]                           }
[16:03:13.906]                         }
[16:03:13.906]                       }
[16:03:13.906]                       invisible(muffled)
[16:03:13.906]                     }
[16:03:13.906]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.906]                   }
[16:03:13.906]                 }
[16:03:13.906]             }
[16:03:13.906]         }))
[16:03:13.906]     }, error = function(ex) {
[16:03:13.906]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.906]                 ...future.rng), started = ...future.startTime, 
[16:03:13.906]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.906]             version = "1.8"), class = "FutureResult")
[16:03:13.906]     }, finally = {
[16:03:13.906]         if (!identical(...future.workdir, getwd())) 
[16:03:13.906]             setwd(...future.workdir)
[16:03:13.906]         {
[16:03:13.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.906]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.906]             }
[16:03:13.906]             base::options(...future.oldOptions)
[16:03:13.906]             if (.Platform$OS.type == "windows") {
[16:03:13.906]                 old_names <- names(...future.oldEnvVars)
[16:03:13.906]                 envs <- base::Sys.getenv()
[16:03:13.906]                 names <- names(envs)
[16:03:13.906]                 common <- intersect(names, old_names)
[16:03:13.906]                 added <- setdiff(names, old_names)
[16:03:13.906]                 removed <- setdiff(old_names, names)
[16:03:13.906]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.906]                   envs[common]]
[16:03:13.906]                 NAMES <- toupper(changed)
[16:03:13.906]                 args <- list()
[16:03:13.906]                 for (kk in seq_along(NAMES)) {
[16:03:13.906]                   name <- changed[[kk]]
[16:03:13.906]                   NAME <- NAMES[[kk]]
[16:03:13.906]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.906]                     next
[16:03:13.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.906]                 }
[16:03:13.906]                 NAMES <- toupper(added)
[16:03:13.906]                 for (kk in seq_along(NAMES)) {
[16:03:13.906]                   name <- added[[kk]]
[16:03:13.906]                   NAME <- NAMES[[kk]]
[16:03:13.906]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.906]                     next
[16:03:13.906]                   args[[name]] <- ""
[16:03:13.906]                 }
[16:03:13.906]                 NAMES <- toupper(removed)
[16:03:13.906]                 for (kk in seq_along(NAMES)) {
[16:03:13.906]                   name <- removed[[kk]]
[16:03:13.906]                   NAME <- NAMES[[kk]]
[16:03:13.906]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.906]                     next
[16:03:13.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.906]                 }
[16:03:13.906]                 if (length(args) > 0) 
[16:03:13.906]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.906]             }
[16:03:13.906]             else {
[16:03:13.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.906]             }
[16:03:13.906]             {
[16:03:13.906]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.906]                   0L) {
[16:03:13.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.906]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.906]                   base::options(opts)
[16:03:13.906]                 }
[16:03:13.906]                 {
[16:03:13.906]                   {
[16:03:13.906]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.906]                     NULL
[16:03:13.906]                   }
[16:03:13.906]                   options(future.plan = NULL)
[16:03:13.906]                   if (is.na(NA_character_)) 
[16:03:13.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.906]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.906]                     envir = parent.frame()) 
[16:03:13.906]                   {
[16:03:13.906]                     default_workers <- missing(workers)
[16:03:13.906]                     if (is.function(workers)) 
[16:03:13.906]                       workers <- workers()
[16:03:13.906]                     workers <- structure(as.integer(workers), 
[16:03:13.906]                       class = class(workers))
[16:03:13.906]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.906]                       1L)
[16:03:13.906]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.906]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.906]                       if (default_workers) 
[16:03:13.906]                         supportsMulticore(warn = TRUE)
[16:03:13.906]                       return(sequential(..., envir = envir))
[16:03:13.906]                     }
[16:03:13.906]                     oopts <- options(mc.cores = workers)
[16:03:13.906]                     on.exit(options(oopts))
[16:03:13.906]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.906]                       envir = envir)
[16:03:13.906]                     if (!future$lazy) 
[16:03:13.906]                       future <- run(future)
[16:03:13.906]                     invisible(future)
[16:03:13.906]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.906]                 }
[16:03:13.906]             }
[16:03:13.906]         }
[16:03:13.906]     })
[16:03:13.906]     if (TRUE) {
[16:03:13.906]         base::sink(type = "output", split = FALSE)
[16:03:13.906]         if (TRUE) {
[16:03:13.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.906]         }
[16:03:13.906]         else {
[16:03:13.906]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.906]         }
[16:03:13.906]         base::close(...future.stdout)
[16:03:13.906]         ...future.stdout <- NULL
[16:03:13.906]     }
[16:03:13.906]     ...future.result$conditions <- ...future.conditions
[16:03:13.906]     ...future.result$finished <- base::Sys.time()
[16:03:13.906]     ...future.result
[16:03:13.906] }
[16:03:13.908] assign_globals() ...
[16:03:13.908] List of 11
[16:03:13.908]  $ ...future.FUN            :function (x, ...)  
[16:03:13.908]  $ x_FUN                    :function (x)  
[16:03:13.908]  $ times                    : int 4
[16:03:13.908]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.908]  $ stop_if_not              :function (...)  
[16:03:13.908]  $ dim                      : int [1:2] 2 2
[16:03:13.908]  $ valid_types              : chr [1:2] "logical" "integer"
[16:03:13.908]  $ future.call.arguments    : list()
[16:03:13.908]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.908]  $ ...future.elements_ii    :List of 5
[16:03:13.908]   ..$ : int 1
[16:03:13.908]   ..$ : int 2
[16:03:13.908]   ..$ : int 3
[16:03:13.908]   ..$ : int 4
[16:03:13.908]   ..$ : int 5
[16:03:13.908]  $ ...future.seeds_ii       : NULL
[16:03:13.908]  $ ...future.globals.maxSize: NULL
[16:03:13.908]  - attr(*, "where")=List of 11
[16:03:13.908]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.908]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.908]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.908]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.908]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.908]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.908]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.908]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.908]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.908]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.908]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.908]  - attr(*, "resolved")= logi FALSE
[16:03:13.908]  - attr(*, "total_size")= num 97232
[16:03:13.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.908]  - attr(*, "already-done")= logi TRUE
[16:03:13.919] - copied ‘...future.FUN’ to environment
[16:03:13.919] - reassign environment for ‘x_FUN’
[16:03:13.919] - copied ‘x_FUN’ to environment
[16:03:13.919] - copied ‘times’ to environment
[16:03:13.919] - copied ‘stopf’ to environment
[16:03:13.920] - copied ‘stop_if_not’ to environment
[16:03:13.920] - copied ‘dim’ to environment
[16:03:13.920] - copied ‘valid_types’ to environment
[16:03:13.920] - copied ‘future.call.arguments’ to environment
[16:03:13.920] - copied ‘...future.elements_ii’ to environment
[16:03:13.920] - copied ‘...future.seeds_ii’ to environment
[16:03:13.920] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.920] assign_globals() ... done
[16:03:13.920] requestCore(): workers = 2
[16:03:13.922] MulticoreFuture started
[16:03:13.923] - Launch lazy future ... done
[16:03:13.923] run() for ‘MulticoreFuture’ ... done
[16:03:13.923] Created future:
[16:03:13.924] plan(): Setting new future strategy stack:
[16:03:13.924] List of future strategies:
[16:03:13.924] 1. sequential:
[16:03:13.924]    - args: function (..., envir = parent.frame())
[16:03:13.924]    - tweaked: FALSE
[16:03:13.924]    - call: NULL
[16:03:13.925] plan(): nbrOfWorkers() = 1
[16:03:13.927] plan(): Setting new future strategy stack:
[16:03:13.927] List of future strategies:
[16:03:13.927] 1. multicore:
[16:03:13.927]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.927]    - tweaked: FALSE
[16:03:13.927]    - call: plan(strategy)
[16:03:13.932] plan(): nbrOfWorkers() = 2
[16:03:13.924] MulticoreFuture:
[16:03:13.924] Label: ‘future_vapply-1’
[16:03:13.924] Expression:
[16:03:13.924] {
[16:03:13.924]     do.call(function(...) {
[16:03:13.924]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.924]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.924]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.924]             on.exit(options(oopts), add = TRUE)
[16:03:13.924]         }
[16:03:13.924]         {
[16:03:13.924]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.924]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.924]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.924]             })
[16:03:13.924]         }
[16:03:13.924]     }, args = future.call.arguments)
[16:03:13.924] }
[16:03:13.924] Lazy evaluation: FALSE
[16:03:13.924] Asynchronous evaluation: TRUE
[16:03:13.924] Local evaluation: TRUE
[16:03:13.924] Environment: R_GlobalEnv
[16:03:13.924] Capture standard output: TRUE
[16:03:13.924] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.924] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.924] Packages: 1 packages (‘future.apply’)
[16:03:13.924] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.924] Resolved: TRUE
[16:03:13.924] Value: <not collected>
[16:03:13.924] Conditions captured: <none>
[16:03:13.924] Early signaling: FALSE
[16:03:13.924] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.924] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.934] Chunk #1 of 2 ... DONE
[16:03:13.934] Chunk #2 of 2 ...
[16:03:13.934]  - Finding globals in 'X' for chunk #2 ...
[16:03:13.934] getGlobalsAndPackages() ...
[16:03:13.934] Searching for globals...
[16:03:13.935] 
[16:03:13.935] Searching for globals ... DONE
[16:03:13.935] - globals: [0] <none>
[16:03:13.935] getGlobalsAndPackages() ... DONE
[16:03:13.935]    + additional globals found: [n=0] 
[16:03:13.936]    + additional namespaces needed: [n=0] 
[16:03:13.936]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:13.936]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:13.936]  - seeds: <none>
[16:03:13.936]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.936] getGlobalsAndPackages() ...
[16:03:13.936] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.937] Resolving globals: FALSE
[16:03:13.937] Tweak future expression to call with '...' arguments ...
[16:03:13.937] {
[16:03:13.937]     do.call(function(...) {
[16:03:13.937]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.937]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.937]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.937]             on.exit(options(oopts), add = TRUE)
[16:03:13.937]         }
[16:03:13.937]         {
[16:03:13.937]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.937]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.937]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.937]             })
[16:03:13.937]         }
[16:03:13.937]     }, args = future.call.arguments)
[16:03:13.937] }
[16:03:13.937] Tweak future expression to call with '...' arguments ... DONE
[16:03:13.938] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:13.938] - packages: [1] ‘future.apply’
[16:03:13.939] getGlobalsAndPackages() ... DONE
[16:03:13.939] run() for ‘Future’ ...
[16:03:13.939] - state: ‘created’
[16:03:13.940] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:13.944] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.944] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:13.945]   - Field: ‘label’
[16:03:13.945]   - Field: ‘local’
[16:03:13.945]   - Field: ‘owner’
[16:03:13.945]   - Field: ‘envir’
[16:03:13.945]   - Field: ‘workers’
[16:03:13.954]   - Field: ‘packages’
[16:03:13.954]   - Field: ‘gc’
[16:03:13.954]   - Field: ‘job’
[16:03:13.954]   - Field: ‘conditions’
[16:03:13.954]   - Field: ‘expr’
[16:03:13.954]   - Field: ‘uuid’
[16:03:13.954]   - Field: ‘seed’
[16:03:13.955]   - Field: ‘version’
[16:03:13.955]   - Field: ‘result’
[16:03:13.955]   - Field: ‘asynchronous’
[16:03:13.955]   - Field: ‘calls’
[16:03:13.955]   - Field: ‘globals’
[16:03:13.955]   - Field: ‘stdout’
[16:03:13.955]   - Field: ‘earlySignal’
[16:03:13.955]   - Field: ‘lazy’
[16:03:13.956]   - Field: ‘state’
[16:03:13.956] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:13.956] - Launch lazy future ...
[16:03:13.956] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:13.957] Packages needed by future strategies (n = 0): <none>
[16:03:13.958] {
[16:03:13.958]     {
[16:03:13.958]         {
[16:03:13.958]             ...future.startTime <- base::Sys.time()
[16:03:13.958]             {
[16:03:13.958]                 {
[16:03:13.958]                   {
[16:03:13.958]                     {
[16:03:13.958]                       {
[16:03:13.958]                         base::local({
[16:03:13.958]                           has_future <- base::requireNamespace("future", 
[16:03:13.958]                             quietly = TRUE)
[16:03:13.958]                           if (has_future) {
[16:03:13.958]                             ns <- base::getNamespace("future")
[16:03:13.958]                             version <- ns[[".package"]][["version"]]
[16:03:13.958]                             if (is.null(version)) 
[16:03:13.958]                               version <- utils::packageVersion("future")
[16:03:13.958]                           }
[16:03:13.958]                           else {
[16:03:13.958]                             version <- NULL
[16:03:13.958]                           }
[16:03:13.958]                           if (!has_future || version < "1.8.0") {
[16:03:13.958]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:13.958]                               "", base::R.version$version.string), 
[16:03:13.958]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:13.958]                                 base::R.version$platform, 8 * 
[16:03:13.958]                                   base::.Machine$sizeof.pointer), 
[16:03:13.958]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:13.958]                                 "release", "version")], collapse = " "), 
[16:03:13.958]                               hostname = base::Sys.info()[["nodename"]])
[16:03:13.958]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:13.958]                               info)
[16:03:13.958]                             info <- base::paste(info, collapse = "; ")
[16:03:13.958]                             if (!has_future) {
[16:03:13.958]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:13.958]                                 info)
[16:03:13.958]                             }
[16:03:13.958]                             else {
[16:03:13.958]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:13.958]                                 info, version)
[16:03:13.958]                             }
[16:03:13.958]                             base::stop(msg)
[16:03:13.958]                           }
[16:03:13.958]                         })
[16:03:13.958]                       }
[16:03:13.958]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:13.958]                       base::options(mc.cores = 1L)
[16:03:13.958]                     }
[16:03:13.958]                     base::local({
[16:03:13.958]                       for (pkg in "future.apply") {
[16:03:13.958]                         base::loadNamespace(pkg)
[16:03:13.958]                         base::library(pkg, character.only = TRUE)
[16:03:13.958]                       }
[16:03:13.958]                     })
[16:03:13.958]                   }
[16:03:13.958]                   options(future.plan = NULL)
[16:03:13.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:13.958]                 }
[16:03:13.958]                 ...future.workdir <- getwd()
[16:03:13.958]             }
[16:03:13.958]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:13.958]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:13.958]         }
[16:03:13.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:13.958]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:13.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:13.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:13.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:13.958]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:13.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:13.958]             base::names(...future.oldOptions))
[16:03:13.958]     }
[16:03:13.958]     if (FALSE) {
[16:03:13.958]     }
[16:03:13.958]     else {
[16:03:13.958]         if (TRUE) {
[16:03:13.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:13.958]                 open = "w")
[16:03:13.958]         }
[16:03:13.958]         else {
[16:03:13.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:13.958]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:13.958]         }
[16:03:13.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:13.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:13.958]             base::sink(type = "output", split = FALSE)
[16:03:13.958]             base::close(...future.stdout)
[16:03:13.958]         }, add = TRUE)
[16:03:13.958]     }
[16:03:13.958]     ...future.frame <- base::sys.nframe()
[16:03:13.958]     ...future.conditions <- base::list()
[16:03:13.958]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:13.958]     if (FALSE) {
[16:03:13.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:13.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:13.958]     }
[16:03:13.958]     ...future.result <- base::tryCatch({
[16:03:13.958]         base::withCallingHandlers({
[16:03:13.958]             ...future.value <- base::withVisible(base::local({
[16:03:13.958]                 withCallingHandlers({
[16:03:13.958]                   {
[16:03:13.958]                     do.call(function(...) {
[16:03:13.958]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.958]                       if (!identical(...future.globals.maxSize.org, 
[16:03:13.958]                         ...future.globals.maxSize)) {
[16:03:13.958]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.958]                         on.exit(options(oopts), add = TRUE)
[16:03:13.958]                       }
[16:03:13.958]                       {
[16:03:13.958]                         lapply(seq_along(...future.elements_ii), 
[16:03:13.958]                           FUN = function(jj) {
[16:03:13.958]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.958]                             ...future.FUN(...future.X_jj, ...)
[16:03:13.958]                           })
[16:03:13.958]                       }
[16:03:13.958]                     }, args = future.call.arguments)
[16:03:13.958]                   }
[16:03:13.958]                 }, immediateCondition = function(cond) {
[16:03:13.958]                   save_rds <- function (object, pathname, ...) 
[16:03:13.958]                   {
[16:03:13.958]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:13.958]                     if (file_test("-f", pathname_tmp)) {
[16:03:13.958]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.958]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:13.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.958]                         fi_tmp[["mtime"]])
[16:03:13.958]                     }
[16:03:13.958]                     tryCatch({
[16:03:13.958]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:13.958]                     }, error = function(ex) {
[16:03:13.958]                       msg <- conditionMessage(ex)
[16:03:13.958]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.958]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:13.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.958]                         fi_tmp[["mtime"]], msg)
[16:03:13.958]                       ex$message <- msg
[16:03:13.958]                       stop(ex)
[16:03:13.958]                     })
[16:03:13.958]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:13.958]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:13.958]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:13.958]                       fi_tmp <- file.info(pathname_tmp)
[16:03:13.958]                       fi <- file.info(pathname)
[16:03:13.958]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:13.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:13.958]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:13.958]                         fi[["size"]], fi[["mtime"]])
[16:03:13.958]                       stop(msg)
[16:03:13.958]                     }
[16:03:13.958]                     invisible(pathname)
[16:03:13.958]                   }
[16:03:13.958]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:13.958]                     rootPath = tempdir()) 
[16:03:13.958]                   {
[16:03:13.958]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:13.958]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:13.958]                       tmpdir = path, fileext = ".rds")
[16:03:13.958]                     save_rds(obj, file)
[16:03:13.958]                   }
[16:03:13.958]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:13.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.958]                   {
[16:03:13.958]                     inherits <- base::inherits
[16:03:13.958]                     invokeRestart <- base::invokeRestart
[16:03:13.958]                     is.null <- base::is.null
[16:03:13.958]                     muffled <- FALSE
[16:03:13.958]                     if (inherits(cond, "message")) {
[16:03:13.958]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:13.958]                       if (muffled) 
[16:03:13.958]                         invokeRestart("muffleMessage")
[16:03:13.958]                     }
[16:03:13.958]                     else if (inherits(cond, "warning")) {
[16:03:13.958]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:13.958]                       if (muffled) 
[16:03:13.958]                         invokeRestart("muffleWarning")
[16:03:13.958]                     }
[16:03:13.958]                     else if (inherits(cond, "condition")) {
[16:03:13.958]                       if (!is.null(pattern)) {
[16:03:13.958]                         computeRestarts <- base::computeRestarts
[16:03:13.958]                         grepl <- base::grepl
[16:03:13.958]                         restarts <- computeRestarts(cond)
[16:03:13.958]                         for (restart in restarts) {
[16:03:13.958]                           name <- restart$name
[16:03:13.958]                           if (is.null(name)) 
[16:03:13.958]                             next
[16:03:13.958]                           if (!grepl(pattern, name)) 
[16:03:13.958]                             next
[16:03:13.958]                           invokeRestart(restart)
[16:03:13.958]                           muffled <- TRUE
[16:03:13.958]                           break
[16:03:13.958]                         }
[16:03:13.958]                       }
[16:03:13.958]                     }
[16:03:13.958]                     invisible(muffled)
[16:03:13.958]                   }
[16:03:13.958]                   muffleCondition(cond)
[16:03:13.958]                 })
[16:03:13.958]             }))
[16:03:13.958]             future::FutureResult(value = ...future.value$value, 
[16:03:13.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.958]                   ...future.rng), globalenv = if (FALSE) 
[16:03:13.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:13.958]                     ...future.globalenv.names))
[16:03:13.958]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:13.958]         }, condition = base::local({
[16:03:13.958]             c <- base::c
[16:03:13.958]             inherits <- base::inherits
[16:03:13.958]             invokeRestart <- base::invokeRestart
[16:03:13.958]             length <- base::length
[16:03:13.958]             list <- base::list
[16:03:13.958]             seq.int <- base::seq.int
[16:03:13.958]             signalCondition <- base::signalCondition
[16:03:13.958]             sys.calls <- base::sys.calls
[16:03:13.958]             `[[` <- base::`[[`
[16:03:13.958]             `+` <- base::`+`
[16:03:13.958]             `<<-` <- base::`<<-`
[16:03:13.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:13.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:13.958]                   3L)]
[16:03:13.958]             }
[16:03:13.958]             function(cond) {
[16:03:13.958]                 is_error <- inherits(cond, "error")
[16:03:13.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:13.958]                   NULL)
[16:03:13.958]                 if (is_error) {
[16:03:13.958]                   sessionInformation <- function() {
[16:03:13.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:13.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:13.958]                       search = base::search(), system = base::Sys.info())
[16:03:13.958]                   }
[16:03:13.958]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:13.958]                     cond$call), session = sessionInformation(), 
[16:03:13.958]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:13.958]                   signalCondition(cond)
[16:03:13.958]                 }
[16:03:13.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:13.958]                 "immediateCondition"))) {
[16:03:13.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:13.958]                   ...future.conditions[[length(...future.conditions) + 
[16:03:13.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:13.958]                   if (TRUE && !signal) {
[16:03:13.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.958]                     {
[16:03:13.958]                       inherits <- base::inherits
[16:03:13.958]                       invokeRestart <- base::invokeRestart
[16:03:13.958]                       is.null <- base::is.null
[16:03:13.958]                       muffled <- FALSE
[16:03:13.958]                       if (inherits(cond, "message")) {
[16:03:13.958]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.958]                         if (muffled) 
[16:03:13.958]                           invokeRestart("muffleMessage")
[16:03:13.958]                       }
[16:03:13.958]                       else if (inherits(cond, "warning")) {
[16:03:13.958]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.958]                         if (muffled) 
[16:03:13.958]                           invokeRestart("muffleWarning")
[16:03:13.958]                       }
[16:03:13.958]                       else if (inherits(cond, "condition")) {
[16:03:13.958]                         if (!is.null(pattern)) {
[16:03:13.958]                           computeRestarts <- base::computeRestarts
[16:03:13.958]                           grepl <- base::grepl
[16:03:13.958]                           restarts <- computeRestarts(cond)
[16:03:13.958]                           for (restart in restarts) {
[16:03:13.958]                             name <- restart$name
[16:03:13.958]                             if (is.null(name)) 
[16:03:13.958]                               next
[16:03:13.958]                             if (!grepl(pattern, name)) 
[16:03:13.958]                               next
[16:03:13.958]                             invokeRestart(restart)
[16:03:13.958]                             muffled <- TRUE
[16:03:13.958]                             break
[16:03:13.958]                           }
[16:03:13.958]                         }
[16:03:13.958]                       }
[16:03:13.958]                       invisible(muffled)
[16:03:13.958]                     }
[16:03:13.958]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.958]                   }
[16:03:13.958]                 }
[16:03:13.958]                 else {
[16:03:13.958]                   if (TRUE) {
[16:03:13.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:13.958]                     {
[16:03:13.958]                       inherits <- base::inherits
[16:03:13.958]                       invokeRestart <- base::invokeRestart
[16:03:13.958]                       is.null <- base::is.null
[16:03:13.958]                       muffled <- FALSE
[16:03:13.958]                       if (inherits(cond, "message")) {
[16:03:13.958]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:13.958]                         if (muffled) 
[16:03:13.958]                           invokeRestart("muffleMessage")
[16:03:13.958]                       }
[16:03:13.958]                       else if (inherits(cond, "warning")) {
[16:03:13.958]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:13.958]                         if (muffled) 
[16:03:13.958]                           invokeRestart("muffleWarning")
[16:03:13.958]                       }
[16:03:13.958]                       else if (inherits(cond, "condition")) {
[16:03:13.958]                         if (!is.null(pattern)) {
[16:03:13.958]                           computeRestarts <- base::computeRestarts
[16:03:13.958]                           grepl <- base::grepl
[16:03:13.958]                           restarts <- computeRestarts(cond)
[16:03:13.958]                           for (restart in restarts) {
[16:03:13.958]                             name <- restart$name
[16:03:13.958]                             if (is.null(name)) 
[16:03:13.958]                               next
[16:03:13.958]                             if (!grepl(pattern, name)) 
[16:03:13.958]                               next
[16:03:13.958]                             invokeRestart(restart)
[16:03:13.958]                             muffled <- TRUE
[16:03:13.958]                             break
[16:03:13.958]                           }
[16:03:13.958]                         }
[16:03:13.958]                       }
[16:03:13.958]                       invisible(muffled)
[16:03:13.958]                     }
[16:03:13.958]                     muffleCondition(cond, pattern = "^muffle")
[16:03:13.958]                   }
[16:03:13.958]                 }
[16:03:13.958]             }
[16:03:13.958]         }))
[16:03:13.958]     }, error = function(ex) {
[16:03:13.958]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:13.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:13.958]                 ...future.rng), started = ...future.startTime, 
[16:03:13.958]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:13.958]             version = "1.8"), class = "FutureResult")
[16:03:13.958]     }, finally = {
[16:03:13.958]         if (!identical(...future.workdir, getwd())) 
[16:03:13.958]             setwd(...future.workdir)
[16:03:13.958]         {
[16:03:13.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:13.958]                 ...future.oldOptions$nwarnings <- NULL
[16:03:13.958]             }
[16:03:13.958]             base::options(...future.oldOptions)
[16:03:13.958]             if (.Platform$OS.type == "windows") {
[16:03:13.958]                 old_names <- names(...future.oldEnvVars)
[16:03:13.958]                 envs <- base::Sys.getenv()
[16:03:13.958]                 names <- names(envs)
[16:03:13.958]                 common <- intersect(names, old_names)
[16:03:13.958]                 added <- setdiff(names, old_names)
[16:03:13.958]                 removed <- setdiff(old_names, names)
[16:03:13.958]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:13.958]                   envs[common]]
[16:03:13.958]                 NAMES <- toupper(changed)
[16:03:13.958]                 args <- list()
[16:03:13.958]                 for (kk in seq_along(NAMES)) {
[16:03:13.958]                   name <- changed[[kk]]
[16:03:13.958]                   NAME <- NAMES[[kk]]
[16:03:13.958]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.958]                     next
[16:03:13.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.958]                 }
[16:03:13.958]                 NAMES <- toupper(added)
[16:03:13.958]                 for (kk in seq_along(NAMES)) {
[16:03:13.958]                   name <- added[[kk]]
[16:03:13.958]                   NAME <- NAMES[[kk]]
[16:03:13.958]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.958]                     next
[16:03:13.958]                   args[[name]] <- ""
[16:03:13.958]                 }
[16:03:13.958]                 NAMES <- toupper(removed)
[16:03:13.958]                 for (kk in seq_along(NAMES)) {
[16:03:13.958]                   name <- removed[[kk]]
[16:03:13.958]                   NAME <- NAMES[[kk]]
[16:03:13.958]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:13.958]                     next
[16:03:13.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:13.958]                 }
[16:03:13.958]                 if (length(args) > 0) 
[16:03:13.958]                   base::do.call(base::Sys.setenv, args = args)
[16:03:13.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:13.958]             }
[16:03:13.958]             else {
[16:03:13.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:13.958]             }
[16:03:13.958]             {
[16:03:13.958]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:13.958]                   0L) {
[16:03:13.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:13.958]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:13.958]                   base::options(opts)
[16:03:13.958]                 }
[16:03:13.958]                 {
[16:03:13.958]                   {
[16:03:13.958]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:13.958]                     NULL
[16:03:13.958]                   }
[16:03:13.958]                   options(future.plan = NULL)
[16:03:13.958]                   if (is.na(NA_character_)) 
[16:03:13.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:13.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:13.958]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:13.958]                     envir = parent.frame()) 
[16:03:13.958]                   {
[16:03:13.958]                     default_workers <- missing(workers)
[16:03:13.958]                     if (is.function(workers)) 
[16:03:13.958]                       workers <- workers()
[16:03:13.958]                     workers <- structure(as.integer(workers), 
[16:03:13.958]                       class = class(workers))
[16:03:13.958]                     stop_if_not(is.finite(workers), workers >= 
[16:03:13.958]                       1L)
[16:03:13.958]                     if ((workers == 1L && !inherits(workers, 
[16:03:13.958]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:13.958]                       if (default_workers) 
[16:03:13.958]                         supportsMulticore(warn = TRUE)
[16:03:13.958]                       return(sequential(..., envir = envir))
[16:03:13.958]                     }
[16:03:13.958]                     oopts <- options(mc.cores = workers)
[16:03:13.958]                     on.exit(options(oopts))
[16:03:13.958]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:13.958]                       envir = envir)
[16:03:13.958]                     if (!future$lazy) 
[16:03:13.958]                       future <- run(future)
[16:03:13.958]                     invisible(future)
[16:03:13.958]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:13.958]                 }
[16:03:13.958]             }
[16:03:13.958]         }
[16:03:13.958]     })
[16:03:13.958]     if (TRUE) {
[16:03:13.958]         base::sink(type = "output", split = FALSE)
[16:03:13.958]         if (TRUE) {
[16:03:13.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:13.958]         }
[16:03:13.958]         else {
[16:03:13.958]             ...future.result["stdout"] <- base::list(NULL)
[16:03:13.958]         }
[16:03:13.958]         base::close(...future.stdout)
[16:03:13.958]         ...future.stdout <- NULL
[16:03:13.958]     }
[16:03:13.958]     ...future.result$conditions <- ...future.conditions
[16:03:13.958]     ...future.result$finished <- base::Sys.time()
[16:03:13.958]     ...future.result
[16:03:13.958] }
[16:03:13.961] assign_globals() ...
[16:03:13.961] List of 11
[16:03:13.961]  $ ...future.FUN            :function (x, ...)  
[16:03:13.961]  $ x_FUN                    :function (x)  
[16:03:13.961]  $ times                    : int 4
[16:03:13.961]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:13.961]  $ stop_if_not              :function (...)  
[16:03:13.961]  $ dim                      : int [1:2] 2 2
[16:03:13.961]  $ valid_types              : chr [1:2] "logical" "integer"
[16:03:13.961]  $ future.call.arguments    : list()
[16:03:13.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:13.961]  $ ...future.elements_ii    :List of 5
[16:03:13.961]   ..$ : int 6
[16:03:13.961]   ..$ : int 7
[16:03:13.961]   ..$ : int 8
[16:03:13.961]   ..$ : int 9
[16:03:13.961]   ..$ : int 10
[16:03:13.961]  $ ...future.seeds_ii       : NULL
[16:03:13.961]  $ ...future.globals.maxSize: NULL
[16:03:13.961]  - attr(*, "where")=List of 11
[16:03:13.961]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:13.961]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:13.961]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:13.961]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:13.961]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:13.961]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:13.961]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:13.961]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:13.961]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:13.961]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:13.961]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:13.961]  - attr(*, "resolved")= logi FALSE
[16:03:13.961]  - attr(*, "total_size")= num 97232
[16:03:13.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:13.961]  - attr(*, "already-done")= logi TRUE
[16:03:13.974] - copied ‘...future.FUN’ to environment
[16:03:13.974] - reassign environment for ‘x_FUN’
[16:03:13.974] - copied ‘x_FUN’ to environment
[16:03:13.975] - copied ‘times’ to environment
[16:03:13.975] - copied ‘stopf’ to environment
[16:03:13.975] - copied ‘stop_if_not’ to environment
[16:03:13.975] - copied ‘dim’ to environment
[16:03:13.975] - copied ‘valid_types’ to environment
[16:03:13.975] - copied ‘future.call.arguments’ to environment
[16:03:13.975] - copied ‘...future.elements_ii’ to environment
[16:03:13.975] - copied ‘...future.seeds_ii’ to environment
[16:03:13.975] - copied ‘...future.globals.maxSize’ to environment
[16:03:13.975] assign_globals() ... done
[16:03:13.976] requestCore(): workers = 2
[16:03:13.978] MulticoreFuture started
[16:03:13.978] - Launch lazy future ... done
[16:03:13.978] run() for ‘MulticoreFuture’ ... done
[16:03:13.979] Created future:
[16:03:13.979] plan(): Setting new future strategy stack:
[16:03:13.980] List of future strategies:
[16:03:13.980] 1. sequential:
[16:03:13.980]    - args: function (..., envir = parent.frame())
[16:03:13.980]    - tweaked: FALSE
[16:03:13.980]    - call: NULL
[16:03:13.980] plan(): nbrOfWorkers() = 1
[16:03:13.982] plan(): Setting new future strategy stack:
[16:03:13.982] List of future strategies:
[16:03:13.982] 1. multicore:
[16:03:13.982]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:13.982]    - tweaked: FALSE
[16:03:13.982]    - call: plan(strategy)
[16:03:13.988] plan(): nbrOfWorkers() = 2
[16:03:13.979] MulticoreFuture:
[16:03:13.979] Label: ‘future_vapply-2’
[16:03:13.979] Expression:
[16:03:13.979] {
[16:03:13.979]     do.call(function(...) {
[16:03:13.979]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:13.979]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:13.979]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:13.979]             on.exit(options(oopts), add = TRUE)
[16:03:13.979]         }
[16:03:13.979]         {
[16:03:13.979]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:13.979]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:13.979]                 ...future.FUN(...future.X_jj, ...)
[16:03:13.979]             })
[16:03:13.979]         }
[16:03:13.979]     }, args = future.call.arguments)
[16:03:13.979] }
[16:03:13.979] Lazy evaluation: FALSE
[16:03:13.979] Asynchronous evaluation: TRUE
[16:03:13.979] Local evaluation: TRUE
[16:03:13.979] Environment: R_GlobalEnv
[16:03:13.979] Capture standard output: TRUE
[16:03:13.979] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:13.979] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:13.979] Packages: 1 packages (‘future.apply’)
[16:03:13.979] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:13.979] Resolved: TRUE
[16:03:13.979] Value: <not collected>
[16:03:13.979] Conditions captured: <none>
[16:03:13.979] Early signaling: FALSE
[16:03:13.979] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:13.979] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:13.989] Chunk #2 of 2 ... DONE
[16:03:13.989] Launching 2 futures (chunks) ... DONE
[16:03:13.989] Resolving 2 futures (chunks) ...
[16:03:13.989] resolve() on list ...
[16:03:13.990]  recursive: 0
[16:03:13.990]  length: 2
[16:03:13.990] 
[16:03:13.990] Future #1
[16:03:13.990] result() for MulticoreFuture ...
[16:03:13.991] result() for MulticoreFuture ...
[16:03:13.991] result() for MulticoreFuture ... done
[16:03:13.992] result() for MulticoreFuture ... done
[16:03:13.992] result() for MulticoreFuture ...
[16:03:13.992] result() for MulticoreFuture ... done
[16:03:13.992] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:13.992] - nx: 2
[16:03:13.992] - relay: TRUE
[16:03:13.992] - stdout: TRUE
[16:03:13.993] - signal: TRUE
[16:03:13.993] - resignal: FALSE
[16:03:13.993] - force: TRUE
[16:03:13.993] - relayed: [n=2] FALSE, FALSE
[16:03:13.993] - queued futures: [n=2] FALSE, FALSE
[16:03:13.993]  - until=1
[16:03:13.993]  - relaying element #1
[16:03:13.994] result() for MulticoreFuture ...
[16:03:13.994] result() for MulticoreFuture ... done
[16:03:13.994] result() for MulticoreFuture ...
[16:03:13.994] result() for MulticoreFuture ... done
[16:03:13.994] result() for MulticoreFuture ...
[16:03:13.995] result() for MulticoreFuture ... done
[16:03:13.995] result() for MulticoreFuture ...
[16:03:13.998] result() for MulticoreFuture ... done
[16:03:13.999] - relayed: [n=2] TRUE, FALSE
[16:03:13.999] - queued futures: [n=2] TRUE, FALSE
[16:03:13.999] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:14.000]  length: 1 (resolved future 1)
[16:03:14.001] Future #2
[16:03:14.001] result() for MulticoreFuture ...
[16:03:14.002] result() for MulticoreFuture ...
[16:03:14.002] result() for MulticoreFuture ... done
[16:03:14.002] result() for MulticoreFuture ... done
[16:03:14.003] result() for MulticoreFuture ...
[16:03:14.003] result() for MulticoreFuture ... done
[16:03:14.003] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:14.003] - nx: 2
[16:03:14.003] - relay: TRUE
[16:03:14.004] - stdout: TRUE
[16:03:14.004] - signal: TRUE
[16:03:14.004] - resignal: FALSE
[16:03:14.004] - force: TRUE
[16:03:14.004] - relayed: [n=2] TRUE, FALSE
[16:03:14.004] - queued futures: [n=2] TRUE, FALSE
[16:03:14.005]  - until=2
[16:03:14.005]  - relaying element #2
[16:03:14.005] result() for MulticoreFuture ...
[16:03:14.005] result() for MulticoreFuture ... done
[16:03:14.005] result() for MulticoreFuture ...
[16:03:14.005] result() for MulticoreFuture ... done
[16:03:14.006] result() for MulticoreFuture ...
[16:03:14.006] result() for MulticoreFuture ... done
[16:03:14.006] result() for MulticoreFuture ...
[16:03:14.006] result() for MulticoreFuture ... done
[16:03:14.006] - relayed: [n=2] TRUE, TRUE
[16:03:14.006] - queued futures: [n=2] TRUE, TRUE
[16:03:14.006] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:14.007]  length: 0 (resolved future 2)
[16:03:14.007] Relaying remaining futures
[16:03:14.007] signalConditionsASAP(NULL, pos=0) ...
[16:03:14.007] - nx: 2
[16:03:14.007] - relay: TRUE
[16:03:14.007] - stdout: TRUE
[16:03:14.007] - signal: TRUE
[16:03:14.008] - resignal: FALSE
[16:03:14.008] - force: TRUE
[16:03:14.008] - relayed: [n=2] TRUE, TRUE
[16:03:14.008] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:14.008] - relayed: [n=2] TRUE, TRUE
[16:03:14.008] - queued futures: [n=2] TRUE, TRUE
[16:03:14.008] signalConditionsASAP(NULL, pos=0) ... done
[16:03:14.009] resolve() on list ... DONE
[16:03:14.009] result() for MulticoreFuture ...
[16:03:14.009] result() for MulticoreFuture ... done
[16:03:14.009] result() for MulticoreFuture ...
[16:03:14.009] result() for MulticoreFuture ... done
[16:03:14.009] result() for MulticoreFuture ...
[16:03:14.009] result() for MulticoreFuture ... done
[16:03:14.009] result() for MulticoreFuture ...
[16:03:14.010] result() for MulticoreFuture ... done
[16:03:14.010]  - Number of value chunks collected: 2
[16:03:14.010] Resolving 2 futures (chunks) ... DONE
[16:03:14.010] Reducing values from 2 chunks ...
[16:03:14.010]  - Number of values collected after concatenation: 10
[16:03:14.010]  - Number of values expected: 10
[16:03:14.010] Reducing values from 2 chunks ... DONE
[16:03:14.010] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:03:14.012] future_lapply() ...
[16:03:14.018] Number of chunks: 2
[16:03:14.018] getGlobalsAndPackagesXApply() ...
[16:03:14.018]  - future.globals: TRUE
[16:03:14.018] getGlobalsAndPackages() ...
[16:03:14.018] Searching for globals...
[16:03:14.022] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:03:14.022] Searching for globals ... DONE
[16:03:14.022] Resolving globals: FALSE
[16:03:14.023] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[16:03:14.024] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:14.024] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.024] - packages: [1] ‘future.apply’
[16:03:14.024] getGlobalsAndPackages() ... DONE
[16:03:14.024]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.024]  - needed namespaces: [n=1] ‘future.apply’
[16:03:14.024] Finding globals ... DONE
[16:03:14.025]  - use_args: TRUE
[16:03:14.025]  - Getting '...' globals ...
[16:03:14.025] resolve() on list ...
[16:03:14.025]  recursive: 0
[16:03:14.025]  length: 1
[16:03:14.025]  elements: ‘...’
[16:03:14.025]  length: 0 (resolved future 1)
[16:03:14.025] resolve() on list ... DONE
[16:03:14.026]    - '...' content: [n=0] 
[16:03:14.026] List of 1
[16:03:14.026]  $ ...: list()
[16:03:14.026]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.026]  - attr(*, "where")=List of 1
[16:03:14.026]   ..$ ...:<environment: 0x564e413ced80> 
[16:03:14.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.026]  - attr(*, "resolved")= logi TRUE
[16:03:14.026]  - attr(*, "total_size")= num NA
[16:03:14.030]  - Getting '...' globals ... DONE
[16:03:14.030] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:14.030] List of 8
[16:03:14.030]  $ ...future.FUN:function (x, ...)  
[16:03:14.030]  $ x_FUN        :function (x)  
[16:03:14.030]  $ times        : int 4
[16:03:14.030]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.030]  $ stop_if_not  :function (...)  
[16:03:14.030]  $ dim          : int [1:2] 2 2
[16:03:14.030]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:14.030]  $ ...          : list()
[16:03:14.030]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.030]  - attr(*, "where")=List of 8
[16:03:14.030]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:14.030]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:14.030]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:14.030]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:14.030]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:14.030]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:14.030]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:14.030]   ..$ ...          :<environment: 0x564e413ced80> 
[16:03:14.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.030]  - attr(*, "resolved")= logi FALSE
[16:03:14.030]  - attr(*, "total_size")= num 97304
[16:03:14.037] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:14.037] getGlobalsAndPackagesXApply() ... DONE
[16:03:14.037] Number of futures (= number of chunks): 2
[16:03:14.037] Launching 2 futures (chunks) ...
[16:03:14.037] Chunk #1 of 2 ...
[16:03:14.037]  - Finding globals in 'X' for chunk #1 ...
[16:03:14.037] getGlobalsAndPackages() ...
[16:03:14.037] Searching for globals...
[16:03:14.038] 
[16:03:14.038] Searching for globals ... DONE
[16:03:14.038] - globals: [0] <none>
[16:03:14.038] getGlobalsAndPackages() ... DONE
[16:03:14.038]    + additional globals found: [n=0] 
[16:03:14.038]    + additional namespaces needed: [n=0] 
[16:03:14.038]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:14.038]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.038]  - seeds: <none>
[16:03:14.038]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.039] getGlobalsAndPackages() ...
[16:03:14.039] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.039] Resolving globals: FALSE
[16:03:14.039] Tweak future expression to call with '...' arguments ...
[16:03:14.039] {
[16:03:14.039]     do.call(function(...) {
[16:03:14.039]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.039]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.039]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.039]             on.exit(options(oopts), add = TRUE)
[16:03:14.039]         }
[16:03:14.039]         {
[16:03:14.039]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.039]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.039]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.039]             })
[16:03:14.039]         }
[16:03:14.039]     }, args = future.call.arguments)
[16:03:14.039] }
[16:03:14.039] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.040] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.040] - packages: [1] ‘future.apply’
[16:03:14.040] getGlobalsAndPackages() ... DONE
[16:03:14.040] run() for ‘Future’ ...
[16:03:14.040] - state: ‘created’
[16:03:14.041] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.044] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.044]   - Field: ‘label’
[16:03:14.045]   - Field: ‘local’
[16:03:14.045]   - Field: ‘owner’
[16:03:14.045]   - Field: ‘envir’
[16:03:14.045]   - Field: ‘workers’
[16:03:14.045]   - Field: ‘packages’
[16:03:14.045]   - Field: ‘gc’
[16:03:14.045]   - Field: ‘job’
[16:03:14.045]   - Field: ‘conditions’
[16:03:14.045]   - Field: ‘expr’
[16:03:14.045]   - Field: ‘uuid’
[16:03:14.046]   - Field: ‘seed’
[16:03:14.046]   - Field: ‘version’
[16:03:14.046]   - Field: ‘result’
[16:03:14.046]   - Field: ‘asynchronous’
[16:03:14.046]   - Field: ‘calls’
[16:03:14.046]   - Field: ‘globals’
[16:03:14.046]   - Field: ‘stdout’
[16:03:14.046]   - Field: ‘earlySignal’
[16:03:14.046]   - Field: ‘lazy’
[16:03:14.046]   - Field: ‘state’
[16:03:14.046] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.047] - Launch lazy future ...
[16:03:14.047] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:14.047] Packages needed by future strategies (n = 0): <none>
[16:03:14.048] {
[16:03:14.048]     {
[16:03:14.048]         {
[16:03:14.048]             ...future.startTime <- base::Sys.time()
[16:03:14.048]             {
[16:03:14.048]                 {
[16:03:14.048]                   {
[16:03:14.048]                     {
[16:03:14.048]                       {
[16:03:14.048]                         base::local({
[16:03:14.048]                           has_future <- base::requireNamespace("future", 
[16:03:14.048]                             quietly = TRUE)
[16:03:14.048]                           if (has_future) {
[16:03:14.048]                             ns <- base::getNamespace("future")
[16:03:14.048]                             version <- ns[[".package"]][["version"]]
[16:03:14.048]                             if (is.null(version)) 
[16:03:14.048]                               version <- utils::packageVersion("future")
[16:03:14.048]                           }
[16:03:14.048]                           else {
[16:03:14.048]                             version <- NULL
[16:03:14.048]                           }
[16:03:14.048]                           if (!has_future || version < "1.8.0") {
[16:03:14.048]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.048]                               "", base::R.version$version.string), 
[16:03:14.048]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.048]                                 base::R.version$platform, 8 * 
[16:03:14.048]                                   base::.Machine$sizeof.pointer), 
[16:03:14.048]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.048]                                 "release", "version")], collapse = " "), 
[16:03:14.048]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.048]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.048]                               info)
[16:03:14.048]                             info <- base::paste(info, collapse = "; ")
[16:03:14.048]                             if (!has_future) {
[16:03:14.048]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.048]                                 info)
[16:03:14.048]                             }
[16:03:14.048]                             else {
[16:03:14.048]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.048]                                 info, version)
[16:03:14.048]                             }
[16:03:14.048]                             base::stop(msg)
[16:03:14.048]                           }
[16:03:14.048]                         })
[16:03:14.048]                       }
[16:03:14.048]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.048]                       base::options(mc.cores = 1L)
[16:03:14.048]                     }
[16:03:14.048]                     base::local({
[16:03:14.048]                       for (pkg in "future.apply") {
[16:03:14.048]                         base::loadNamespace(pkg)
[16:03:14.048]                         base::library(pkg, character.only = TRUE)
[16:03:14.048]                       }
[16:03:14.048]                     })
[16:03:14.048]                   }
[16:03:14.048]                   options(future.plan = NULL)
[16:03:14.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.048]                 }
[16:03:14.048]                 ...future.workdir <- getwd()
[16:03:14.048]             }
[16:03:14.048]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.048]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.048]         }
[16:03:14.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.048]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.048]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.048]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.048]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.048]             base::names(...future.oldOptions))
[16:03:14.048]     }
[16:03:14.048]     if (FALSE) {
[16:03:14.048]     }
[16:03:14.048]     else {
[16:03:14.048]         if (TRUE) {
[16:03:14.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.048]                 open = "w")
[16:03:14.048]         }
[16:03:14.048]         else {
[16:03:14.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.048]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.048]         }
[16:03:14.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.048]             base::sink(type = "output", split = FALSE)
[16:03:14.048]             base::close(...future.stdout)
[16:03:14.048]         }, add = TRUE)
[16:03:14.048]     }
[16:03:14.048]     ...future.frame <- base::sys.nframe()
[16:03:14.048]     ...future.conditions <- base::list()
[16:03:14.048]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.048]     if (FALSE) {
[16:03:14.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.048]     }
[16:03:14.048]     ...future.result <- base::tryCatch({
[16:03:14.048]         base::withCallingHandlers({
[16:03:14.048]             ...future.value <- base::withVisible(base::local({
[16:03:14.048]                 withCallingHandlers({
[16:03:14.048]                   {
[16:03:14.048]                     do.call(function(...) {
[16:03:14.048]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.048]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.048]                         ...future.globals.maxSize)) {
[16:03:14.048]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.048]                         on.exit(options(oopts), add = TRUE)
[16:03:14.048]                       }
[16:03:14.048]                       {
[16:03:14.048]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.048]                           FUN = function(jj) {
[16:03:14.048]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.048]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.048]                           })
[16:03:14.048]                       }
[16:03:14.048]                     }, args = future.call.arguments)
[16:03:14.048]                   }
[16:03:14.048]                 }, immediateCondition = function(cond) {
[16:03:14.048]                   save_rds <- function (object, pathname, ...) 
[16:03:14.048]                   {
[16:03:14.048]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.048]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.048]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.048]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.048]                         fi_tmp[["mtime"]])
[16:03:14.048]                     }
[16:03:14.048]                     tryCatch({
[16:03:14.048]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.048]                     }, error = function(ex) {
[16:03:14.048]                       msg <- conditionMessage(ex)
[16:03:14.048]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.048]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.048]                         fi_tmp[["mtime"]], msg)
[16:03:14.048]                       ex$message <- msg
[16:03:14.048]                       stop(ex)
[16:03:14.048]                     })
[16:03:14.048]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.048]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.048]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.048]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.048]                       fi <- file.info(pathname)
[16:03:14.048]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.048]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.048]                         fi[["size"]], fi[["mtime"]])
[16:03:14.048]                       stop(msg)
[16:03:14.048]                     }
[16:03:14.048]                     invisible(pathname)
[16:03:14.048]                   }
[16:03:14.048]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.048]                     rootPath = tempdir()) 
[16:03:14.048]                   {
[16:03:14.048]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.048]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.048]                       tmpdir = path, fileext = ".rds")
[16:03:14.048]                     save_rds(obj, file)
[16:03:14.048]                   }
[16:03:14.048]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.048]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.048]                   {
[16:03:14.048]                     inherits <- base::inherits
[16:03:14.048]                     invokeRestart <- base::invokeRestart
[16:03:14.048]                     is.null <- base::is.null
[16:03:14.048]                     muffled <- FALSE
[16:03:14.048]                     if (inherits(cond, "message")) {
[16:03:14.048]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.048]                       if (muffled) 
[16:03:14.048]                         invokeRestart("muffleMessage")
[16:03:14.048]                     }
[16:03:14.048]                     else if (inherits(cond, "warning")) {
[16:03:14.048]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.048]                       if (muffled) 
[16:03:14.048]                         invokeRestart("muffleWarning")
[16:03:14.048]                     }
[16:03:14.048]                     else if (inherits(cond, "condition")) {
[16:03:14.048]                       if (!is.null(pattern)) {
[16:03:14.048]                         computeRestarts <- base::computeRestarts
[16:03:14.048]                         grepl <- base::grepl
[16:03:14.048]                         restarts <- computeRestarts(cond)
[16:03:14.048]                         for (restart in restarts) {
[16:03:14.048]                           name <- restart$name
[16:03:14.048]                           if (is.null(name)) 
[16:03:14.048]                             next
[16:03:14.048]                           if (!grepl(pattern, name)) 
[16:03:14.048]                             next
[16:03:14.048]                           invokeRestart(restart)
[16:03:14.048]                           muffled <- TRUE
[16:03:14.048]                           break
[16:03:14.048]                         }
[16:03:14.048]                       }
[16:03:14.048]                     }
[16:03:14.048]                     invisible(muffled)
[16:03:14.048]                   }
[16:03:14.048]                   muffleCondition(cond)
[16:03:14.048]                 })
[16:03:14.048]             }))
[16:03:14.048]             future::FutureResult(value = ...future.value$value, 
[16:03:14.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.048]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.048]                     ...future.globalenv.names))
[16:03:14.048]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.048]         }, condition = base::local({
[16:03:14.048]             c <- base::c
[16:03:14.048]             inherits <- base::inherits
[16:03:14.048]             invokeRestart <- base::invokeRestart
[16:03:14.048]             length <- base::length
[16:03:14.048]             list <- base::list
[16:03:14.048]             seq.int <- base::seq.int
[16:03:14.048]             signalCondition <- base::signalCondition
[16:03:14.048]             sys.calls <- base::sys.calls
[16:03:14.048]             `[[` <- base::`[[`
[16:03:14.048]             `+` <- base::`+`
[16:03:14.048]             `<<-` <- base::`<<-`
[16:03:14.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.048]                   3L)]
[16:03:14.048]             }
[16:03:14.048]             function(cond) {
[16:03:14.048]                 is_error <- inherits(cond, "error")
[16:03:14.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.048]                   NULL)
[16:03:14.048]                 if (is_error) {
[16:03:14.048]                   sessionInformation <- function() {
[16:03:14.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.048]                       search = base::search(), system = base::Sys.info())
[16:03:14.048]                   }
[16:03:14.048]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.048]                     cond$call), session = sessionInformation(), 
[16:03:14.048]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.048]                   signalCondition(cond)
[16:03:14.048]                 }
[16:03:14.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.048]                 "immediateCondition"))) {
[16:03:14.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.048]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.048]                   if (TRUE && !signal) {
[16:03:14.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.048]                     {
[16:03:14.048]                       inherits <- base::inherits
[16:03:14.048]                       invokeRestart <- base::invokeRestart
[16:03:14.048]                       is.null <- base::is.null
[16:03:14.048]                       muffled <- FALSE
[16:03:14.048]                       if (inherits(cond, "message")) {
[16:03:14.048]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.048]                         if (muffled) 
[16:03:14.048]                           invokeRestart("muffleMessage")
[16:03:14.048]                       }
[16:03:14.048]                       else if (inherits(cond, "warning")) {
[16:03:14.048]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.048]                         if (muffled) 
[16:03:14.048]                           invokeRestart("muffleWarning")
[16:03:14.048]                       }
[16:03:14.048]                       else if (inherits(cond, "condition")) {
[16:03:14.048]                         if (!is.null(pattern)) {
[16:03:14.048]                           computeRestarts <- base::computeRestarts
[16:03:14.048]                           grepl <- base::grepl
[16:03:14.048]                           restarts <- computeRestarts(cond)
[16:03:14.048]                           for (restart in restarts) {
[16:03:14.048]                             name <- restart$name
[16:03:14.048]                             if (is.null(name)) 
[16:03:14.048]                               next
[16:03:14.048]                             if (!grepl(pattern, name)) 
[16:03:14.048]                               next
[16:03:14.048]                             invokeRestart(restart)
[16:03:14.048]                             muffled <- TRUE
[16:03:14.048]                             break
[16:03:14.048]                           }
[16:03:14.048]                         }
[16:03:14.048]                       }
[16:03:14.048]                       invisible(muffled)
[16:03:14.048]                     }
[16:03:14.048]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.048]                   }
[16:03:14.048]                 }
[16:03:14.048]                 else {
[16:03:14.048]                   if (TRUE) {
[16:03:14.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.048]                     {
[16:03:14.048]                       inherits <- base::inherits
[16:03:14.048]                       invokeRestart <- base::invokeRestart
[16:03:14.048]                       is.null <- base::is.null
[16:03:14.048]                       muffled <- FALSE
[16:03:14.048]                       if (inherits(cond, "message")) {
[16:03:14.048]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.048]                         if (muffled) 
[16:03:14.048]                           invokeRestart("muffleMessage")
[16:03:14.048]                       }
[16:03:14.048]                       else if (inherits(cond, "warning")) {
[16:03:14.048]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.048]                         if (muffled) 
[16:03:14.048]                           invokeRestart("muffleWarning")
[16:03:14.048]                       }
[16:03:14.048]                       else if (inherits(cond, "condition")) {
[16:03:14.048]                         if (!is.null(pattern)) {
[16:03:14.048]                           computeRestarts <- base::computeRestarts
[16:03:14.048]                           grepl <- base::grepl
[16:03:14.048]                           restarts <- computeRestarts(cond)
[16:03:14.048]                           for (restart in restarts) {
[16:03:14.048]                             name <- restart$name
[16:03:14.048]                             if (is.null(name)) 
[16:03:14.048]                               next
[16:03:14.048]                             if (!grepl(pattern, name)) 
[16:03:14.048]                               next
[16:03:14.048]                             invokeRestart(restart)
[16:03:14.048]                             muffled <- TRUE
[16:03:14.048]                             break
[16:03:14.048]                           }
[16:03:14.048]                         }
[16:03:14.048]                       }
[16:03:14.048]                       invisible(muffled)
[16:03:14.048]                     }
[16:03:14.048]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.048]                   }
[16:03:14.048]                 }
[16:03:14.048]             }
[16:03:14.048]         }))
[16:03:14.048]     }, error = function(ex) {
[16:03:14.048]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.048]                 ...future.rng), started = ...future.startTime, 
[16:03:14.048]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.048]             version = "1.8"), class = "FutureResult")
[16:03:14.048]     }, finally = {
[16:03:14.048]         if (!identical(...future.workdir, getwd())) 
[16:03:14.048]             setwd(...future.workdir)
[16:03:14.048]         {
[16:03:14.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.048]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.048]             }
[16:03:14.048]             base::options(...future.oldOptions)
[16:03:14.048]             if (.Platform$OS.type == "windows") {
[16:03:14.048]                 old_names <- names(...future.oldEnvVars)
[16:03:14.048]                 envs <- base::Sys.getenv()
[16:03:14.048]                 names <- names(envs)
[16:03:14.048]                 common <- intersect(names, old_names)
[16:03:14.048]                 added <- setdiff(names, old_names)
[16:03:14.048]                 removed <- setdiff(old_names, names)
[16:03:14.048]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.048]                   envs[common]]
[16:03:14.048]                 NAMES <- toupper(changed)
[16:03:14.048]                 args <- list()
[16:03:14.048]                 for (kk in seq_along(NAMES)) {
[16:03:14.048]                   name <- changed[[kk]]
[16:03:14.048]                   NAME <- NAMES[[kk]]
[16:03:14.048]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.048]                     next
[16:03:14.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.048]                 }
[16:03:14.048]                 NAMES <- toupper(added)
[16:03:14.048]                 for (kk in seq_along(NAMES)) {
[16:03:14.048]                   name <- added[[kk]]
[16:03:14.048]                   NAME <- NAMES[[kk]]
[16:03:14.048]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.048]                     next
[16:03:14.048]                   args[[name]] <- ""
[16:03:14.048]                 }
[16:03:14.048]                 NAMES <- toupper(removed)
[16:03:14.048]                 for (kk in seq_along(NAMES)) {
[16:03:14.048]                   name <- removed[[kk]]
[16:03:14.048]                   NAME <- NAMES[[kk]]
[16:03:14.048]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.048]                     next
[16:03:14.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.048]                 }
[16:03:14.048]                 if (length(args) > 0) 
[16:03:14.048]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.048]             }
[16:03:14.048]             else {
[16:03:14.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.048]             }
[16:03:14.048]             {
[16:03:14.048]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.048]                   0L) {
[16:03:14.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.048]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.048]                   base::options(opts)
[16:03:14.048]                 }
[16:03:14.048]                 {
[16:03:14.048]                   {
[16:03:14.048]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.048]                     NULL
[16:03:14.048]                   }
[16:03:14.048]                   options(future.plan = NULL)
[16:03:14.048]                   if (is.na(NA_character_)) 
[16:03:14.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.048]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.048]                     envir = parent.frame()) 
[16:03:14.048]                   {
[16:03:14.048]                     default_workers <- missing(workers)
[16:03:14.048]                     if (is.function(workers)) 
[16:03:14.048]                       workers <- workers()
[16:03:14.048]                     workers <- structure(as.integer(workers), 
[16:03:14.048]                       class = class(workers))
[16:03:14.048]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.048]                       1L)
[16:03:14.048]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.048]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.048]                       if (default_workers) 
[16:03:14.048]                         supportsMulticore(warn = TRUE)
[16:03:14.048]                       return(sequential(..., envir = envir))
[16:03:14.048]                     }
[16:03:14.048]                     oopts <- options(mc.cores = workers)
[16:03:14.048]                     on.exit(options(oopts))
[16:03:14.048]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.048]                       envir = envir)
[16:03:14.048]                     if (!future$lazy) 
[16:03:14.048]                       future <- run(future)
[16:03:14.048]                     invisible(future)
[16:03:14.048]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.048]                 }
[16:03:14.048]             }
[16:03:14.048]         }
[16:03:14.048]     })
[16:03:14.048]     if (TRUE) {
[16:03:14.048]         base::sink(type = "output", split = FALSE)
[16:03:14.048]         if (TRUE) {
[16:03:14.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.048]         }
[16:03:14.048]         else {
[16:03:14.048]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.048]         }
[16:03:14.048]         base::close(...future.stdout)
[16:03:14.048]         ...future.stdout <- NULL
[16:03:14.048]     }
[16:03:14.048]     ...future.result$conditions <- ...future.conditions
[16:03:14.048]     ...future.result$finished <- base::Sys.time()
[16:03:14.048]     ...future.result
[16:03:14.048] }
[16:03:14.050] assign_globals() ...
[16:03:14.050] List of 11
[16:03:14.050]  $ ...future.FUN            :function (x, ...)  
[16:03:14.050]  $ x_FUN                    :function (x)  
[16:03:14.050]  $ times                    : int 4
[16:03:14.050]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.050]  $ stop_if_not              :function (...)  
[16:03:14.050]  $ dim                      : int [1:2] 2 2
[16:03:14.050]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:14.050]  $ future.call.arguments    : list()
[16:03:14.050]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.050]  $ ...future.elements_ii    :List of 5
[16:03:14.050]   ..$ : int 1
[16:03:14.050]   ..$ : int 2
[16:03:14.050]   ..$ : int 3
[16:03:14.050]   ..$ : int 4
[16:03:14.050]   ..$ : int 5
[16:03:14.050]  $ ...future.seeds_ii       : NULL
[16:03:14.050]  $ ...future.globals.maxSize: NULL
[16:03:14.050]  - attr(*, "where")=List of 11
[16:03:14.050]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.050]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:14.050]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:14.050]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:14.050]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:14.050]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:14.050]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:14.050]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.050]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.050]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.050]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.050]  - attr(*, "resolved")= logi FALSE
[16:03:14.050]  - attr(*, "total_size")= num 97304
[16:03:14.050]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.050]  - attr(*, "already-done")= logi TRUE
[16:03:14.061] - copied ‘...future.FUN’ to environment
[16:03:14.061] - reassign environment for ‘x_FUN’
[16:03:14.061] - copied ‘x_FUN’ to environment
[16:03:14.061] - copied ‘times’ to environment
[16:03:14.061] - copied ‘stopf’ to environment
[16:03:14.061] - copied ‘stop_if_not’ to environment
[16:03:14.061] - copied ‘dim’ to environment
[16:03:14.061] - copied ‘valid_types’ to environment
[16:03:14.061] - copied ‘future.call.arguments’ to environment
[16:03:14.062] - copied ‘...future.elements_ii’ to environment
[16:03:14.062] - copied ‘...future.seeds_ii’ to environment
[16:03:14.062] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.062] assign_globals() ... done
[16:03:14.062] requestCore(): workers = 2
[16:03:14.064] MulticoreFuture started
[16:03:14.065] - Launch lazy future ... done
[16:03:14.065] run() for ‘MulticoreFuture’ ... done
[16:03:14.065] Created future:
[16:03:14.066] plan(): Setting new future strategy stack:
[16:03:14.066] List of future strategies:
[16:03:14.066] 1. sequential:
[16:03:14.066]    - args: function (..., envir = parent.frame())
[16:03:14.066]    - tweaked: FALSE
[16:03:14.066]    - call: NULL
[16:03:14.067] plan(): nbrOfWorkers() = 1
[16:03:14.069] plan(): Setting new future strategy stack:
[16:03:14.069] List of future strategies:
[16:03:14.069] 1. multicore:
[16:03:14.069]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.069]    - tweaked: FALSE
[16:03:14.069]    - call: plan(strategy)
[16:03:14.074] plan(): nbrOfWorkers() = 2
[16:03:14.065] MulticoreFuture:
[16:03:14.065] Label: ‘future_vapply-1’
[16:03:14.065] Expression:
[16:03:14.065] {
[16:03:14.065]     do.call(function(...) {
[16:03:14.065]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.065]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.065]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.065]             on.exit(options(oopts), add = TRUE)
[16:03:14.065]         }
[16:03:14.065]         {
[16:03:14.065]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.065]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.065]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.065]             })
[16:03:14.065]         }
[16:03:14.065]     }, args = future.call.arguments)
[16:03:14.065] }
[16:03:14.065] Lazy evaluation: FALSE
[16:03:14.065] Asynchronous evaluation: TRUE
[16:03:14.065] Local evaluation: TRUE
[16:03:14.065] Environment: R_GlobalEnv
[16:03:14.065] Capture standard output: TRUE
[16:03:14.065] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.065] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:14.065] Packages: 1 packages (‘future.apply’)
[16:03:14.065] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.065] Resolved: TRUE
[16:03:14.065] Value: <not collected>
[16:03:14.065] Conditions captured: <none>
[16:03:14.065] Early signaling: FALSE
[16:03:14.065] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.065] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.076] Chunk #1 of 2 ... DONE
[16:03:14.076] Chunk #2 of 2 ...
[16:03:14.076]  - Finding globals in 'X' for chunk #2 ...
[16:03:14.076] getGlobalsAndPackages() ...
[16:03:14.076] Searching for globals...
[16:03:14.077] 
[16:03:14.077] Searching for globals ... DONE
[16:03:14.077] - globals: [0] <none>
[16:03:14.077] getGlobalsAndPackages() ... DONE
[16:03:14.077]    + additional globals found: [n=0] 
[16:03:14.077]    + additional namespaces needed: [n=0] 
[16:03:14.078]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:14.078]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.078]  - seeds: <none>
[16:03:14.078]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.078] getGlobalsAndPackages() ...
[16:03:14.078] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.079] Resolving globals: FALSE
[16:03:14.079] Tweak future expression to call with '...' arguments ...
[16:03:14.079] {
[16:03:14.079]     do.call(function(...) {
[16:03:14.079]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.079]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.079]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.079]             on.exit(options(oopts), add = TRUE)
[16:03:14.079]         }
[16:03:14.079]         {
[16:03:14.079]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.079]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.079]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.079]             })
[16:03:14.079]         }
[16:03:14.079]     }, args = future.call.arguments)
[16:03:14.079] }
[16:03:14.079] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.080] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.080] - packages: [1] ‘future.apply’
[16:03:14.081] getGlobalsAndPackages() ... DONE
[16:03:14.081] run() for ‘Future’ ...
[16:03:14.081] - state: ‘created’
[16:03:14.082] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.086] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.086] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.086]   - Field: ‘label’
[16:03:14.087]   - Field: ‘local’
[16:03:14.087]   - Field: ‘owner’
[16:03:14.087]   - Field: ‘envir’
[16:03:14.087]   - Field: ‘workers’
[16:03:14.087]   - Field: ‘packages’
[16:03:14.087]   - Field: ‘gc’
[16:03:14.087]   - Field: ‘job’
[16:03:14.088]   - Field: ‘conditions’
[16:03:14.088]   - Field: ‘expr’
[16:03:14.088]   - Field: ‘uuid’
[16:03:14.088]   - Field: ‘seed’
[16:03:14.088]   - Field: ‘version’
[16:03:14.088]   - Field: ‘result’
[16:03:14.088]   - Field: ‘asynchronous’
[16:03:14.089]   - Field: ‘calls’
[16:03:14.089]   - Field: ‘globals’
[16:03:14.089]   - Field: ‘stdout’
[16:03:14.089]   - Field: ‘earlySignal’
[16:03:14.089]   - Field: ‘lazy’
[16:03:14.089]   - Field: ‘state’
[16:03:14.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.089] - Launch lazy future ...
[16:03:14.090] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:14.090] Packages needed by future strategies (n = 0): <none>
[16:03:14.091] {
[16:03:14.091]     {
[16:03:14.091]         {
[16:03:14.091]             ...future.startTime <- base::Sys.time()
[16:03:14.091]             {
[16:03:14.091]                 {
[16:03:14.091]                   {
[16:03:14.091]                     {
[16:03:14.091]                       {
[16:03:14.091]                         base::local({
[16:03:14.091]                           has_future <- base::requireNamespace("future", 
[16:03:14.091]                             quietly = TRUE)
[16:03:14.091]                           if (has_future) {
[16:03:14.091]                             ns <- base::getNamespace("future")
[16:03:14.091]                             version <- ns[[".package"]][["version"]]
[16:03:14.091]                             if (is.null(version)) 
[16:03:14.091]                               version <- utils::packageVersion("future")
[16:03:14.091]                           }
[16:03:14.091]                           else {
[16:03:14.091]                             version <- NULL
[16:03:14.091]                           }
[16:03:14.091]                           if (!has_future || version < "1.8.0") {
[16:03:14.091]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.091]                               "", base::R.version$version.string), 
[16:03:14.091]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.091]                                 base::R.version$platform, 8 * 
[16:03:14.091]                                   base::.Machine$sizeof.pointer), 
[16:03:14.091]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.091]                                 "release", "version")], collapse = " "), 
[16:03:14.091]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.091]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.091]                               info)
[16:03:14.091]                             info <- base::paste(info, collapse = "; ")
[16:03:14.091]                             if (!has_future) {
[16:03:14.091]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.091]                                 info)
[16:03:14.091]                             }
[16:03:14.091]                             else {
[16:03:14.091]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.091]                                 info, version)
[16:03:14.091]                             }
[16:03:14.091]                             base::stop(msg)
[16:03:14.091]                           }
[16:03:14.091]                         })
[16:03:14.091]                       }
[16:03:14.091]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.091]                       base::options(mc.cores = 1L)
[16:03:14.091]                     }
[16:03:14.091]                     base::local({
[16:03:14.091]                       for (pkg in "future.apply") {
[16:03:14.091]                         base::loadNamespace(pkg)
[16:03:14.091]                         base::library(pkg, character.only = TRUE)
[16:03:14.091]                       }
[16:03:14.091]                     })
[16:03:14.091]                   }
[16:03:14.091]                   options(future.plan = NULL)
[16:03:14.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.091]                 }
[16:03:14.091]                 ...future.workdir <- getwd()
[16:03:14.091]             }
[16:03:14.091]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.091]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.091]         }
[16:03:14.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.091]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.091]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.091]             base::names(...future.oldOptions))
[16:03:14.091]     }
[16:03:14.091]     if (FALSE) {
[16:03:14.091]     }
[16:03:14.091]     else {
[16:03:14.091]         if (TRUE) {
[16:03:14.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.091]                 open = "w")
[16:03:14.091]         }
[16:03:14.091]         else {
[16:03:14.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.091]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.091]         }
[16:03:14.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.091]             base::sink(type = "output", split = FALSE)
[16:03:14.091]             base::close(...future.stdout)
[16:03:14.091]         }, add = TRUE)
[16:03:14.091]     }
[16:03:14.091]     ...future.frame <- base::sys.nframe()
[16:03:14.091]     ...future.conditions <- base::list()
[16:03:14.091]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.091]     if (FALSE) {
[16:03:14.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.091]     }
[16:03:14.091]     ...future.result <- base::tryCatch({
[16:03:14.091]         base::withCallingHandlers({
[16:03:14.091]             ...future.value <- base::withVisible(base::local({
[16:03:14.091]                 withCallingHandlers({
[16:03:14.091]                   {
[16:03:14.091]                     do.call(function(...) {
[16:03:14.091]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.091]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.091]                         ...future.globals.maxSize)) {
[16:03:14.091]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.091]                         on.exit(options(oopts), add = TRUE)
[16:03:14.091]                       }
[16:03:14.091]                       {
[16:03:14.091]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.091]                           FUN = function(jj) {
[16:03:14.091]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.091]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.091]                           })
[16:03:14.091]                       }
[16:03:14.091]                     }, args = future.call.arguments)
[16:03:14.091]                   }
[16:03:14.091]                 }, immediateCondition = function(cond) {
[16:03:14.091]                   save_rds <- function (object, pathname, ...) 
[16:03:14.091]                   {
[16:03:14.091]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.091]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.091]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.091]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.091]                         fi_tmp[["mtime"]])
[16:03:14.091]                     }
[16:03:14.091]                     tryCatch({
[16:03:14.091]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.091]                     }, error = function(ex) {
[16:03:14.091]                       msg <- conditionMessage(ex)
[16:03:14.091]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.091]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.091]                         fi_tmp[["mtime"]], msg)
[16:03:14.091]                       ex$message <- msg
[16:03:14.091]                       stop(ex)
[16:03:14.091]                     })
[16:03:14.091]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.091]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.091]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.091]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.091]                       fi <- file.info(pathname)
[16:03:14.091]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.091]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.091]                         fi[["size"]], fi[["mtime"]])
[16:03:14.091]                       stop(msg)
[16:03:14.091]                     }
[16:03:14.091]                     invisible(pathname)
[16:03:14.091]                   }
[16:03:14.091]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.091]                     rootPath = tempdir()) 
[16:03:14.091]                   {
[16:03:14.091]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.091]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.091]                       tmpdir = path, fileext = ".rds")
[16:03:14.091]                     save_rds(obj, file)
[16:03:14.091]                   }
[16:03:14.091]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.091]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.091]                   {
[16:03:14.091]                     inherits <- base::inherits
[16:03:14.091]                     invokeRestart <- base::invokeRestart
[16:03:14.091]                     is.null <- base::is.null
[16:03:14.091]                     muffled <- FALSE
[16:03:14.091]                     if (inherits(cond, "message")) {
[16:03:14.091]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.091]                       if (muffled) 
[16:03:14.091]                         invokeRestart("muffleMessage")
[16:03:14.091]                     }
[16:03:14.091]                     else if (inherits(cond, "warning")) {
[16:03:14.091]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.091]                       if (muffled) 
[16:03:14.091]                         invokeRestart("muffleWarning")
[16:03:14.091]                     }
[16:03:14.091]                     else if (inherits(cond, "condition")) {
[16:03:14.091]                       if (!is.null(pattern)) {
[16:03:14.091]                         computeRestarts <- base::computeRestarts
[16:03:14.091]                         grepl <- base::grepl
[16:03:14.091]                         restarts <- computeRestarts(cond)
[16:03:14.091]                         for (restart in restarts) {
[16:03:14.091]                           name <- restart$name
[16:03:14.091]                           if (is.null(name)) 
[16:03:14.091]                             next
[16:03:14.091]                           if (!grepl(pattern, name)) 
[16:03:14.091]                             next
[16:03:14.091]                           invokeRestart(restart)
[16:03:14.091]                           muffled <- TRUE
[16:03:14.091]                           break
[16:03:14.091]                         }
[16:03:14.091]                       }
[16:03:14.091]                     }
[16:03:14.091]                     invisible(muffled)
[16:03:14.091]                   }
[16:03:14.091]                   muffleCondition(cond)
[16:03:14.091]                 })
[16:03:14.091]             }))
[16:03:14.091]             future::FutureResult(value = ...future.value$value, 
[16:03:14.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.091]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.091]                     ...future.globalenv.names))
[16:03:14.091]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.091]         }, condition = base::local({
[16:03:14.091]             c <- base::c
[16:03:14.091]             inherits <- base::inherits
[16:03:14.091]             invokeRestart <- base::invokeRestart
[16:03:14.091]             length <- base::length
[16:03:14.091]             list <- base::list
[16:03:14.091]             seq.int <- base::seq.int
[16:03:14.091]             signalCondition <- base::signalCondition
[16:03:14.091]             sys.calls <- base::sys.calls
[16:03:14.091]             `[[` <- base::`[[`
[16:03:14.091]             `+` <- base::`+`
[16:03:14.091]             `<<-` <- base::`<<-`
[16:03:14.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.091]                   3L)]
[16:03:14.091]             }
[16:03:14.091]             function(cond) {
[16:03:14.091]                 is_error <- inherits(cond, "error")
[16:03:14.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.091]                   NULL)
[16:03:14.091]                 if (is_error) {
[16:03:14.091]                   sessionInformation <- function() {
[16:03:14.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.091]                       search = base::search(), system = base::Sys.info())
[16:03:14.091]                   }
[16:03:14.091]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.091]                     cond$call), session = sessionInformation(), 
[16:03:14.091]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.091]                   signalCondition(cond)
[16:03:14.091]                 }
[16:03:14.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.091]                 "immediateCondition"))) {
[16:03:14.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.091]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.091]                   if (TRUE && !signal) {
[16:03:14.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.091]                     {
[16:03:14.091]                       inherits <- base::inherits
[16:03:14.091]                       invokeRestart <- base::invokeRestart
[16:03:14.091]                       is.null <- base::is.null
[16:03:14.091]                       muffled <- FALSE
[16:03:14.091]                       if (inherits(cond, "message")) {
[16:03:14.091]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.091]                         if (muffled) 
[16:03:14.091]                           invokeRestart("muffleMessage")
[16:03:14.091]                       }
[16:03:14.091]                       else if (inherits(cond, "warning")) {
[16:03:14.091]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.091]                         if (muffled) 
[16:03:14.091]                           invokeRestart("muffleWarning")
[16:03:14.091]                       }
[16:03:14.091]                       else if (inherits(cond, "condition")) {
[16:03:14.091]                         if (!is.null(pattern)) {
[16:03:14.091]                           computeRestarts <- base::computeRestarts
[16:03:14.091]                           grepl <- base::grepl
[16:03:14.091]                           restarts <- computeRestarts(cond)
[16:03:14.091]                           for (restart in restarts) {
[16:03:14.091]                             name <- restart$name
[16:03:14.091]                             if (is.null(name)) 
[16:03:14.091]                               next
[16:03:14.091]                             if (!grepl(pattern, name)) 
[16:03:14.091]                               next
[16:03:14.091]                             invokeRestart(restart)
[16:03:14.091]                             muffled <- TRUE
[16:03:14.091]                             break
[16:03:14.091]                           }
[16:03:14.091]                         }
[16:03:14.091]                       }
[16:03:14.091]                       invisible(muffled)
[16:03:14.091]                     }
[16:03:14.091]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.091]                   }
[16:03:14.091]                 }
[16:03:14.091]                 else {
[16:03:14.091]                   if (TRUE) {
[16:03:14.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.091]                     {
[16:03:14.091]                       inherits <- base::inherits
[16:03:14.091]                       invokeRestart <- base::invokeRestart
[16:03:14.091]                       is.null <- base::is.null
[16:03:14.091]                       muffled <- FALSE
[16:03:14.091]                       if (inherits(cond, "message")) {
[16:03:14.091]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.091]                         if (muffled) 
[16:03:14.091]                           invokeRestart("muffleMessage")
[16:03:14.091]                       }
[16:03:14.091]                       else if (inherits(cond, "warning")) {
[16:03:14.091]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.091]                         if (muffled) 
[16:03:14.091]                           invokeRestart("muffleWarning")
[16:03:14.091]                       }
[16:03:14.091]                       else if (inherits(cond, "condition")) {
[16:03:14.091]                         if (!is.null(pattern)) {
[16:03:14.091]                           computeRestarts <- base::computeRestarts
[16:03:14.091]                           grepl <- base::grepl
[16:03:14.091]                           restarts <- computeRestarts(cond)
[16:03:14.091]                           for (restart in restarts) {
[16:03:14.091]                             name <- restart$name
[16:03:14.091]                             if (is.null(name)) 
[16:03:14.091]                               next
[16:03:14.091]                             if (!grepl(pattern, name)) 
[16:03:14.091]                               next
[16:03:14.091]                             invokeRestart(restart)
[16:03:14.091]                             muffled <- TRUE
[16:03:14.091]                             break
[16:03:14.091]                           }
[16:03:14.091]                         }
[16:03:14.091]                       }
[16:03:14.091]                       invisible(muffled)
[16:03:14.091]                     }
[16:03:14.091]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.091]                   }
[16:03:14.091]                 }
[16:03:14.091]             }
[16:03:14.091]         }))
[16:03:14.091]     }, error = function(ex) {
[16:03:14.091]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.091]                 ...future.rng), started = ...future.startTime, 
[16:03:14.091]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.091]             version = "1.8"), class = "FutureResult")
[16:03:14.091]     }, finally = {
[16:03:14.091]         if (!identical(...future.workdir, getwd())) 
[16:03:14.091]             setwd(...future.workdir)
[16:03:14.091]         {
[16:03:14.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.091]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.091]             }
[16:03:14.091]             base::options(...future.oldOptions)
[16:03:14.091]             if (.Platform$OS.type == "windows") {
[16:03:14.091]                 old_names <- names(...future.oldEnvVars)
[16:03:14.091]                 envs <- base::Sys.getenv()
[16:03:14.091]                 names <- names(envs)
[16:03:14.091]                 common <- intersect(names, old_names)
[16:03:14.091]                 added <- setdiff(names, old_names)
[16:03:14.091]                 removed <- setdiff(old_names, names)
[16:03:14.091]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.091]                   envs[common]]
[16:03:14.091]                 NAMES <- toupper(changed)
[16:03:14.091]                 args <- list()
[16:03:14.091]                 for (kk in seq_along(NAMES)) {
[16:03:14.091]                   name <- changed[[kk]]
[16:03:14.091]                   NAME <- NAMES[[kk]]
[16:03:14.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.091]                     next
[16:03:14.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.091]                 }
[16:03:14.091]                 NAMES <- toupper(added)
[16:03:14.091]                 for (kk in seq_along(NAMES)) {
[16:03:14.091]                   name <- added[[kk]]
[16:03:14.091]                   NAME <- NAMES[[kk]]
[16:03:14.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.091]                     next
[16:03:14.091]                   args[[name]] <- ""
[16:03:14.091]                 }
[16:03:14.091]                 NAMES <- toupper(removed)
[16:03:14.091]                 for (kk in seq_along(NAMES)) {
[16:03:14.091]                   name <- removed[[kk]]
[16:03:14.091]                   NAME <- NAMES[[kk]]
[16:03:14.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.091]                     next
[16:03:14.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.091]                 }
[16:03:14.091]                 if (length(args) > 0) 
[16:03:14.091]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.091]             }
[16:03:14.091]             else {
[16:03:14.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.091]             }
[16:03:14.091]             {
[16:03:14.091]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.091]                   0L) {
[16:03:14.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.091]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.091]                   base::options(opts)
[16:03:14.091]                 }
[16:03:14.091]                 {
[16:03:14.091]                   {
[16:03:14.091]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.091]                     NULL
[16:03:14.091]                   }
[16:03:14.091]                   options(future.plan = NULL)
[16:03:14.091]                   if (is.na(NA_character_)) 
[16:03:14.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.091]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.091]                     envir = parent.frame()) 
[16:03:14.091]                   {
[16:03:14.091]                     default_workers <- missing(workers)
[16:03:14.091]                     if (is.function(workers)) 
[16:03:14.091]                       workers <- workers()
[16:03:14.091]                     workers <- structure(as.integer(workers), 
[16:03:14.091]                       class = class(workers))
[16:03:14.091]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.091]                       1L)
[16:03:14.091]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.091]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.091]                       if (default_workers) 
[16:03:14.091]                         supportsMulticore(warn = TRUE)
[16:03:14.091]                       return(sequential(..., envir = envir))
[16:03:14.091]                     }
[16:03:14.091]                     oopts <- options(mc.cores = workers)
[16:03:14.091]                     on.exit(options(oopts))
[16:03:14.091]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.091]                       envir = envir)
[16:03:14.091]                     if (!future$lazy) 
[16:03:14.091]                       future <- run(future)
[16:03:14.091]                     invisible(future)
[16:03:14.091]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.091]                 }
[16:03:14.091]             }
[16:03:14.091]         }
[16:03:14.091]     })
[16:03:14.091]     if (TRUE) {
[16:03:14.091]         base::sink(type = "output", split = FALSE)
[16:03:14.091]         if (TRUE) {
[16:03:14.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.091]         }
[16:03:14.091]         else {
[16:03:14.091]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.091]         }
[16:03:14.091]         base::close(...future.stdout)
[16:03:14.091]         ...future.stdout <- NULL
[16:03:14.091]     }
[16:03:14.091]     ...future.result$conditions <- ...future.conditions
[16:03:14.091]     ...future.result$finished <- base::Sys.time()
[16:03:14.091]     ...future.result
[16:03:14.091] }
[16:03:14.095] assign_globals() ...
[16:03:14.095] List of 11
[16:03:14.095]  $ ...future.FUN            :function (x, ...)  
[16:03:14.095]  $ x_FUN                    :function (x)  
[16:03:14.095]  $ times                    : int 4
[16:03:14.095]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.095]  $ stop_if_not              :function (...)  
[16:03:14.095]  $ dim                      : int [1:2] 2 2
[16:03:14.095]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:14.095]  $ future.call.arguments    : list()
[16:03:14.095]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.095]  $ ...future.elements_ii    :List of 5
[16:03:14.095]   ..$ : int 6
[16:03:14.095]   ..$ : int 7
[16:03:14.095]   ..$ : int 8
[16:03:14.095]   ..$ : int 9
[16:03:14.095]   ..$ : int 10
[16:03:14.095]  $ ...future.seeds_ii       : NULL
[16:03:14.095]  $ ...future.globals.maxSize: NULL
[16:03:14.095]  - attr(*, "where")=List of 11
[16:03:14.095]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.095]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:14.095]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:14.095]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:14.095]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:14.095]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:14.095]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:14.095]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.095]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.095]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.095]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.095]  - attr(*, "resolved")= logi FALSE
[16:03:14.095]  - attr(*, "total_size")= num 97304
[16:03:14.095]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.095]  - attr(*, "already-done")= logi TRUE
[16:03:14.112] - copied ‘...future.FUN’ to environment
[16:03:14.113] - reassign environment for ‘x_FUN’
[16:03:14.113] - copied ‘x_FUN’ to environment
[16:03:14.113] - copied ‘times’ to environment
[16:03:14.113] - copied ‘stopf’ to environment
[16:03:14.113] - copied ‘stop_if_not’ to environment
[16:03:14.113] - copied ‘dim’ to environment
[16:03:14.113] - copied ‘valid_types’ to environment
[16:03:14.113] - copied ‘future.call.arguments’ to environment
[16:03:14.113] - copied ‘...future.elements_ii’ to environment
[16:03:14.114] - copied ‘...future.seeds_ii’ to environment
[16:03:14.114] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.114] assign_globals() ... done
[16:03:14.114] requestCore(): workers = 2
[16:03:14.116] MulticoreFuture started
[16:03:14.116] - Launch lazy future ... done
[16:03:14.117] run() for ‘MulticoreFuture’ ... done
[16:03:14.117] Created future:
[16:03:14.117] plan(): Setting new future strategy stack:
[16:03:14.118] List of future strategies:
[16:03:14.118] 1. sequential:
[16:03:14.118]    - args: function (..., envir = parent.frame())
[16:03:14.118]    - tweaked: FALSE
[16:03:14.118]    - call: NULL
[16:03:14.118] plan(): nbrOfWorkers() = 1
[16:03:14.121] plan(): Setting new future strategy stack:
[16:03:14.121] List of future strategies:
[16:03:14.121] 1. multicore:
[16:03:14.121]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.121]    - tweaked: FALSE
[16:03:14.121]    - call: plan(strategy)
[16:03:14.126] plan(): nbrOfWorkers() = 2
[16:03:14.117] MulticoreFuture:
[16:03:14.117] Label: ‘future_vapply-2’
[16:03:14.117] Expression:
[16:03:14.117] {
[16:03:14.117]     do.call(function(...) {
[16:03:14.117]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.117]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.117]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.117]             on.exit(options(oopts), add = TRUE)
[16:03:14.117]         }
[16:03:14.117]         {
[16:03:14.117]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.117]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.117]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.117]             })
[16:03:14.117]         }
[16:03:14.117]     }, args = future.call.arguments)
[16:03:14.117] }
[16:03:14.117] Lazy evaluation: FALSE
[16:03:14.117] Asynchronous evaluation: TRUE
[16:03:14.117] Local evaluation: TRUE
[16:03:14.117] Environment: R_GlobalEnv
[16:03:14.117] Capture standard output: TRUE
[16:03:14.117] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.117] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:14.117] Packages: 1 packages (‘future.apply’)
[16:03:14.117] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.117] Resolved: TRUE
[16:03:14.117] Value: <not collected>
[16:03:14.117] Conditions captured: <none>
[16:03:14.117] Early signaling: FALSE
[16:03:14.117] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.117] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.127] Chunk #2 of 2 ... DONE
[16:03:14.127] Launching 2 futures (chunks) ... DONE
[16:03:14.127] Resolving 2 futures (chunks) ...
[16:03:14.127] resolve() on list ...
[16:03:14.128]  recursive: 0
[16:03:14.128]  length: 2
[16:03:14.128] 
[16:03:14.128] Future #1
[16:03:14.128] result() for MulticoreFuture ...
[16:03:14.129] result() for MulticoreFuture ...
[16:03:14.129] result() for MulticoreFuture ... done
[16:03:14.129] result() for MulticoreFuture ... done
[16:03:14.130] result() for MulticoreFuture ...
[16:03:14.130] result() for MulticoreFuture ... done
[16:03:14.130] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:14.130] - nx: 2
[16:03:14.130] - relay: TRUE
[16:03:14.130] - stdout: TRUE
[16:03:14.131] - signal: TRUE
[16:03:14.131] - resignal: FALSE
[16:03:14.131] - force: TRUE
[16:03:14.131] - relayed: [n=2] FALSE, FALSE
[16:03:14.131] - queued futures: [n=2] FALSE, FALSE
[16:03:14.131]  - until=1
[16:03:14.131]  - relaying element #1
[16:03:14.132] result() for MulticoreFuture ...
[16:03:14.132] result() for MulticoreFuture ... done
[16:03:14.132] result() for MulticoreFuture ...
[16:03:14.132] result() for MulticoreFuture ... done
[16:03:14.132] result() for MulticoreFuture ...
[16:03:14.132] result() for MulticoreFuture ... done
[16:03:14.133] result() for MulticoreFuture ...
[16:03:14.133] result() for MulticoreFuture ... done
[16:03:14.133] - relayed: [n=2] TRUE, FALSE
[16:03:14.133] - queued futures: [n=2] TRUE, FALSE
[16:03:14.133] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:14.133]  length: 1 (resolved future 1)
[16:03:14.134] Future #2
[16:03:14.134] result() for MulticoreFuture ...
[16:03:14.135] result() for MulticoreFuture ...
[16:03:14.135] result() for MulticoreFuture ... done
[16:03:14.135] result() for MulticoreFuture ... done
[16:03:14.135] result() for MulticoreFuture ...
[16:03:14.135] result() for MulticoreFuture ... done
[16:03:14.135] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:14.135] - nx: 2
[16:03:14.136] - relay: TRUE
[16:03:14.136] - stdout: TRUE
[16:03:14.136] - signal: TRUE
[16:03:14.136] - resignal: FALSE
[16:03:14.136] - force: TRUE
[16:03:14.136] - relayed: [n=2] TRUE, FALSE
[16:03:14.136] - queued futures: [n=2] TRUE, FALSE
[16:03:14.136]  - until=2
[16:03:14.137]  - relaying element #2
[16:03:14.137] result() for MulticoreFuture ...
[16:03:14.137] result() for MulticoreFuture ... done
[16:03:14.139] result() for MulticoreFuture ...
[16:03:14.140] result() for MulticoreFuture ... done
[16:03:14.140] result() for MulticoreFuture ...
[16:03:14.140] result() for MulticoreFuture ... done
[16:03:14.140] result() for MulticoreFuture ...
[16:03:14.140] result() for MulticoreFuture ... done
[16:03:14.141] - relayed: [n=2] TRUE, TRUE
[16:03:14.141] - queued futures: [n=2] TRUE, TRUE
[16:03:14.141] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:14.141]  length: 0 (resolved future 2)
[16:03:14.141] Relaying remaining futures
[16:03:14.141] signalConditionsASAP(NULL, pos=0) ...
[16:03:14.142] - nx: 2
[16:03:14.142] - relay: TRUE
[16:03:14.142] - stdout: TRUE
[16:03:14.142] - signal: TRUE
[16:03:14.142] - resignal: FALSE
[16:03:14.142] - force: TRUE
[16:03:14.142] - relayed: [n=2] TRUE, TRUE
[16:03:14.142] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:14.143] - relayed: [n=2] TRUE, TRUE
[16:03:14.143] - queued futures: [n=2] TRUE, TRUE
[16:03:14.143] signalConditionsASAP(NULL, pos=0) ... done
[16:03:14.143] resolve() on list ... DONE
[16:03:14.143] result() for MulticoreFuture ...
[16:03:14.143] result() for MulticoreFuture ... done
[16:03:14.144] result() for MulticoreFuture ...
[16:03:14.144] result() for MulticoreFuture ... done
[16:03:14.144] result() for MulticoreFuture ...
[16:03:14.144] result() for MulticoreFuture ... done
[16:03:14.144] result() for MulticoreFuture ...
[16:03:14.144] result() for MulticoreFuture ... done
[16:03:14.145]  - Number of value chunks collected: 2
[16:03:14.145] Resolving 2 futures (chunks) ... DONE
[16:03:14.145] Reducing values from 2 chunks ...
[16:03:14.145]  - Number of values collected after concatenation: 10
[16:03:14.145]  - Number of values expected: 10
[16:03:14.145] Reducing values from 2 chunks ... DONE
[16:03:14.145] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[16:03:14.148] future_lapply() ...
[16:03:14.154] Number of chunks: 2
[16:03:14.154] getGlobalsAndPackagesXApply() ...
[16:03:14.155]  - future.globals: TRUE
[16:03:14.155] getGlobalsAndPackages() ...
[16:03:14.155] Searching for globals...
[16:03:14.159] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[16:03:14.159] Searching for globals ... DONE
[16:03:14.159] Resolving globals: FALSE
[16:03:14.160] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[16:03:14.160] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:14.161] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.161] - packages: [1] ‘future.apply’
[16:03:14.161] getGlobalsAndPackages() ... DONE
[16:03:14.161]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.161]  - needed namespaces: [n=1] ‘future.apply’
[16:03:14.161] Finding globals ... DONE
[16:03:14.161]  - use_args: TRUE
[16:03:14.161]  - Getting '...' globals ...
[16:03:14.162] resolve() on list ...
[16:03:14.162]  recursive: 0
[16:03:14.162]  length: 1
[16:03:14.162]  elements: ‘...’
[16:03:14.162]  length: 0 (resolved future 1)
[16:03:14.162] resolve() on list ... DONE
[16:03:14.162]    - '...' content: [n=0] 
[16:03:14.162] List of 1
[16:03:14.162]  $ ...: list()
[16:03:14.162]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.162]  - attr(*, "where")=List of 1
[16:03:14.162]   ..$ ...:<environment: 0x564e41f25ed8> 
[16:03:14.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.162]  - attr(*, "resolved")= logi TRUE
[16:03:14.162]  - attr(*, "total_size")= num NA
[16:03:14.167]  - Getting '...' globals ... DONE
[16:03:14.167] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:14.167] List of 8
[16:03:14.167]  $ ...future.FUN:function (x, ...)  
[16:03:14.167]  $ x_FUN        :function (x)  
[16:03:14.167]  $ times        : int 4
[16:03:14.167]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.167]  $ stop_if_not  :function (...)  
[16:03:14.167]  $ dim          : int [1:2] 2 2
[16:03:14.167]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:14.167]  $ ...          : list()
[16:03:14.167]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.167]  - attr(*, "where")=List of 8
[16:03:14.167]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:14.167]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:14.167]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:14.167]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:14.167]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:14.167]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:14.167]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:14.167]   ..$ ...          :<environment: 0x564e41f25ed8> 
[16:03:14.167]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.167]  - attr(*, "resolved")= logi FALSE
[16:03:14.167]  - attr(*, "total_size")= num 105552
[16:03:14.173] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:14.173] getGlobalsAndPackagesXApply() ... DONE
[16:03:14.173] Number of futures (= number of chunks): 2
[16:03:14.174] Launching 2 futures (chunks) ...
[16:03:14.174] Chunk #1 of 2 ...
[16:03:14.174]  - Finding globals in 'X' for chunk #1 ...
[16:03:14.174] getGlobalsAndPackages() ...
[16:03:14.174] Searching for globals...
[16:03:14.174] 
[16:03:14.174] Searching for globals ... DONE
[16:03:14.174] - globals: [0] <none>
[16:03:14.175] getGlobalsAndPackages() ... DONE
[16:03:14.175]    + additional globals found: [n=0] 
[16:03:14.175]    + additional namespaces needed: [n=0] 
[16:03:14.175]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:14.175]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.175]  - seeds: <none>
[16:03:14.175]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.175] getGlobalsAndPackages() ...
[16:03:14.175] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.175] Resolving globals: FALSE
[16:03:14.176] Tweak future expression to call with '...' arguments ...
[16:03:14.176] {
[16:03:14.176]     do.call(function(...) {
[16:03:14.176]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.176]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.176]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.176]             on.exit(options(oopts), add = TRUE)
[16:03:14.176]         }
[16:03:14.176]         {
[16:03:14.176]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.176]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.176]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.176]             })
[16:03:14.176]         }
[16:03:14.176]     }, args = future.call.arguments)
[16:03:14.176] }
[16:03:14.176] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.176] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.177] - packages: [1] ‘future.apply’
[16:03:14.177] getGlobalsAndPackages() ... DONE
[16:03:14.177] run() for ‘Future’ ...
[16:03:14.177] - state: ‘created’
[16:03:14.177] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.181] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.181] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.181]   - Field: ‘label’
[16:03:14.181]   - Field: ‘local’
[16:03:14.181]   - Field: ‘owner’
[16:03:14.181]   - Field: ‘envir’
[16:03:14.181]   - Field: ‘workers’
[16:03:14.182]   - Field: ‘packages’
[16:03:14.182]   - Field: ‘gc’
[16:03:14.182]   - Field: ‘job’
[16:03:14.182]   - Field: ‘conditions’
[16:03:14.182]   - Field: ‘expr’
[16:03:14.182]   - Field: ‘uuid’
[16:03:14.182]   - Field: ‘seed’
[16:03:14.182]   - Field: ‘version’
[16:03:14.182]   - Field: ‘result’
[16:03:14.182]   - Field: ‘asynchronous’
[16:03:14.182]   - Field: ‘calls’
[16:03:14.183]   - Field: ‘globals’
[16:03:14.183]   - Field: ‘stdout’
[16:03:14.183]   - Field: ‘earlySignal’
[16:03:14.183]   - Field: ‘lazy’
[16:03:14.183]   - Field: ‘state’
[16:03:14.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.183] - Launch lazy future ...
[16:03:14.183] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:14.184] Packages needed by future strategies (n = 0): <none>
[16:03:14.184] {
[16:03:14.184]     {
[16:03:14.184]         {
[16:03:14.184]             ...future.startTime <- base::Sys.time()
[16:03:14.184]             {
[16:03:14.184]                 {
[16:03:14.184]                   {
[16:03:14.184]                     {
[16:03:14.184]                       {
[16:03:14.184]                         base::local({
[16:03:14.184]                           has_future <- base::requireNamespace("future", 
[16:03:14.184]                             quietly = TRUE)
[16:03:14.184]                           if (has_future) {
[16:03:14.184]                             ns <- base::getNamespace("future")
[16:03:14.184]                             version <- ns[[".package"]][["version"]]
[16:03:14.184]                             if (is.null(version)) 
[16:03:14.184]                               version <- utils::packageVersion("future")
[16:03:14.184]                           }
[16:03:14.184]                           else {
[16:03:14.184]                             version <- NULL
[16:03:14.184]                           }
[16:03:14.184]                           if (!has_future || version < "1.8.0") {
[16:03:14.184]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.184]                               "", base::R.version$version.string), 
[16:03:14.184]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.184]                                 base::R.version$platform, 8 * 
[16:03:14.184]                                   base::.Machine$sizeof.pointer), 
[16:03:14.184]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.184]                                 "release", "version")], collapse = " "), 
[16:03:14.184]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.184]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.184]                               info)
[16:03:14.184]                             info <- base::paste(info, collapse = "; ")
[16:03:14.184]                             if (!has_future) {
[16:03:14.184]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.184]                                 info)
[16:03:14.184]                             }
[16:03:14.184]                             else {
[16:03:14.184]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.184]                                 info, version)
[16:03:14.184]                             }
[16:03:14.184]                             base::stop(msg)
[16:03:14.184]                           }
[16:03:14.184]                         })
[16:03:14.184]                       }
[16:03:14.184]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.184]                       base::options(mc.cores = 1L)
[16:03:14.184]                     }
[16:03:14.184]                     base::local({
[16:03:14.184]                       for (pkg in "future.apply") {
[16:03:14.184]                         base::loadNamespace(pkg)
[16:03:14.184]                         base::library(pkg, character.only = TRUE)
[16:03:14.184]                       }
[16:03:14.184]                     })
[16:03:14.184]                   }
[16:03:14.184]                   options(future.plan = NULL)
[16:03:14.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.184]                 }
[16:03:14.184]                 ...future.workdir <- getwd()
[16:03:14.184]             }
[16:03:14.184]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.184]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.184]         }
[16:03:14.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.184]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.184]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.184]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.184]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.184]             base::names(...future.oldOptions))
[16:03:14.184]     }
[16:03:14.184]     if (FALSE) {
[16:03:14.184]     }
[16:03:14.184]     else {
[16:03:14.184]         if (TRUE) {
[16:03:14.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.184]                 open = "w")
[16:03:14.184]         }
[16:03:14.184]         else {
[16:03:14.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.184]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.184]         }
[16:03:14.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.184]             base::sink(type = "output", split = FALSE)
[16:03:14.184]             base::close(...future.stdout)
[16:03:14.184]         }, add = TRUE)
[16:03:14.184]     }
[16:03:14.184]     ...future.frame <- base::sys.nframe()
[16:03:14.184]     ...future.conditions <- base::list()
[16:03:14.184]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.184]     if (FALSE) {
[16:03:14.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.184]     }
[16:03:14.184]     ...future.result <- base::tryCatch({
[16:03:14.184]         base::withCallingHandlers({
[16:03:14.184]             ...future.value <- base::withVisible(base::local({
[16:03:14.184]                 withCallingHandlers({
[16:03:14.184]                   {
[16:03:14.184]                     do.call(function(...) {
[16:03:14.184]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.184]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.184]                         ...future.globals.maxSize)) {
[16:03:14.184]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.184]                         on.exit(options(oopts), add = TRUE)
[16:03:14.184]                       }
[16:03:14.184]                       {
[16:03:14.184]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.184]                           FUN = function(jj) {
[16:03:14.184]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.184]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.184]                           })
[16:03:14.184]                       }
[16:03:14.184]                     }, args = future.call.arguments)
[16:03:14.184]                   }
[16:03:14.184]                 }, immediateCondition = function(cond) {
[16:03:14.184]                   save_rds <- function (object, pathname, ...) 
[16:03:14.184]                   {
[16:03:14.184]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.184]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.184]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.184]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.184]                         fi_tmp[["mtime"]])
[16:03:14.184]                     }
[16:03:14.184]                     tryCatch({
[16:03:14.184]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.184]                     }, error = function(ex) {
[16:03:14.184]                       msg <- conditionMessage(ex)
[16:03:14.184]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.184]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.184]                         fi_tmp[["mtime"]], msg)
[16:03:14.184]                       ex$message <- msg
[16:03:14.184]                       stop(ex)
[16:03:14.184]                     })
[16:03:14.184]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.184]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.184]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.184]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.184]                       fi <- file.info(pathname)
[16:03:14.184]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.184]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.184]                         fi[["size"]], fi[["mtime"]])
[16:03:14.184]                       stop(msg)
[16:03:14.184]                     }
[16:03:14.184]                     invisible(pathname)
[16:03:14.184]                   }
[16:03:14.184]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.184]                     rootPath = tempdir()) 
[16:03:14.184]                   {
[16:03:14.184]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.184]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.184]                       tmpdir = path, fileext = ".rds")
[16:03:14.184]                     save_rds(obj, file)
[16:03:14.184]                   }
[16:03:14.184]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.184]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.184]                   {
[16:03:14.184]                     inherits <- base::inherits
[16:03:14.184]                     invokeRestart <- base::invokeRestart
[16:03:14.184]                     is.null <- base::is.null
[16:03:14.184]                     muffled <- FALSE
[16:03:14.184]                     if (inherits(cond, "message")) {
[16:03:14.184]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.184]                       if (muffled) 
[16:03:14.184]                         invokeRestart("muffleMessage")
[16:03:14.184]                     }
[16:03:14.184]                     else if (inherits(cond, "warning")) {
[16:03:14.184]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.184]                       if (muffled) 
[16:03:14.184]                         invokeRestart("muffleWarning")
[16:03:14.184]                     }
[16:03:14.184]                     else if (inherits(cond, "condition")) {
[16:03:14.184]                       if (!is.null(pattern)) {
[16:03:14.184]                         computeRestarts <- base::computeRestarts
[16:03:14.184]                         grepl <- base::grepl
[16:03:14.184]                         restarts <- computeRestarts(cond)
[16:03:14.184]                         for (restart in restarts) {
[16:03:14.184]                           name <- restart$name
[16:03:14.184]                           if (is.null(name)) 
[16:03:14.184]                             next
[16:03:14.184]                           if (!grepl(pattern, name)) 
[16:03:14.184]                             next
[16:03:14.184]                           invokeRestart(restart)
[16:03:14.184]                           muffled <- TRUE
[16:03:14.184]                           break
[16:03:14.184]                         }
[16:03:14.184]                       }
[16:03:14.184]                     }
[16:03:14.184]                     invisible(muffled)
[16:03:14.184]                   }
[16:03:14.184]                   muffleCondition(cond)
[16:03:14.184]                 })
[16:03:14.184]             }))
[16:03:14.184]             future::FutureResult(value = ...future.value$value, 
[16:03:14.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.184]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.184]                     ...future.globalenv.names))
[16:03:14.184]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.184]         }, condition = base::local({
[16:03:14.184]             c <- base::c
[16:03:14.184]             inherits <- base::inherits
[16:03:14.184]             invokeRestart <- base::invokeRestart
[16:03:14.184]             length <- base::length
[16:03:14.184]             list <- base::list
[16:03:14.184]             seq.int <- base::seq.int
[16:03:14.184]             signalCondition <- base::signalCondition
[16:03:14.184]             sys.calls <- base::sys.calls
[16:03:14.184]             `[[` <- base::`[[`
[16:03:14.184]             `+` <- base::`+`
[16:03:14.184]             `<<-` <- base::`<<-`
[16:03:14.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.184]                   3L)]
[16:03:14.184]             }
[16:03:14.184]             function(cond) {
[16:03:14.184]                 is_error <- inherits(cond, "error")
[16:03:14.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.184]                   NULL)
[16:03:14.184]                 if (is_error) {
[16:03:14.184]                   sessionInformation <- function() {
[16:03:14.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.184]                       search = base::search(), system = base::Sys.info())
[16:03:14.184]                   }
[16:03:14.184]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.184]                     cond$call), session = sessionInformation(), 
[16:03:14.184]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.184]                   signalCondition(cond)
[16:03:14.184]                 }
[16:03:14.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.184]                 "immediateCondition"))) {
[16:03:14.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.184]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.184]                   if (TRUE && !signal) {
[16:03:14.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.184]                     {
[16:03:14.184]                       inherits <- base::inherits
[16:03:14.184]                       invokeRestart <- base::invokeRestart
[16:03:14.184]                       is.null <- base::is.null
[16:03:14.184]                       muffled <- FALSE
[16:03:14.184]                       if (inherits(cond, "message")) {
[16:03:14.184]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.184]                         if (muffled) 
[16:03:14.184]                           invokeRestart("muffleMessage")
[16:03:14.184]                       }
[16:03:14.184]                       else if (inherits(cond, "warning")) {
[16:03:14.184]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.184]                         if (muffled) 
[16:03:14.184]                           invokeRestart("muffleWarning")
[16:03:14.184]                       }
[16:03:14.184]                       else if (inherits(cond, "condition")) {
[16:03:14.184]                         if (!is.null(pattern)) {
[16:03:14.184]                           computeRestarts <- base::computeRestarts
[16:03:14.184]                           grepl <- base::grepl
[16:03:14.184]                           restarts <- computeRestarts(cond)
[16:03:14.184]                           for (restart in restarts) {
[16:03:14.184]                             name <- restart$name
[16:03:14.184]                             if (is.null(name)) 
[16:03:14.184]                               next
[16:03:14.184]                             if (!grepl(pattern, name)) 
[16:03:14.184]                               next
[16:03:14.184]                             invokeRestart(restart)
[16:03:14.184]                             muffled <- TRUE
[16:03:14.184]                             break
[16:03:14.184]                           }
[16:03:14.184]                         }
[16:03:14.184]                       }
[16:03:14.184]                       invisible(muffled)
[16:03:14.184]                     }
[16:03:14.184]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.184]                   }
[16:03:14.184]                 }
[16:03:14.184]                 else {
[16:03:14.184]                   if (TRUE) {
[16:03:14.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.184]                     {
[16:03:14.184]                       inherits <- base::inherits
[16:03:14.184]                       invokeRestart <- base::invokeRestart
[16:03:14.184]                       is.null <- base::is.null
[16:03:14.184]                       muffled <- FALSE
[16:03:14.184]                       if (inherits(cond, "message")) {
[16:03:14.184]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.184]                         if (muffled) 
[16:03:14.184]                           invokeRestart("muffleMessage")
[16:03:14.184]                       }
[16:03:14.184]                       else if (inherits(cond, "warning")) {
[16:03:14.184]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.184]                         if (muffled) 
[16:03:14.184]                           invokeRestart("muffleWarning")
[16:03:14.184]                       }
[16:03:14.184]                       else if (inherits(cond, "condition")) {
[16:03:14.184]                         if (!is.null(pattern)) {
[16:03:14.184]                           computeRestarts <- base::computeRestarts
[16:03:14.184]                           grepl <- base::grepl
[16:03:14.184]                           restarts <- computeRestarts(cond)
[16:03:14.184]                           for (restart in restarts) {
[16:03:14.184]                             name <- restart$name
[16:03:14.184]                             if (is.null(name)) 
[16:03:14.184]                               next
[16:03:14.184]                             if (!grepl(pattern, name)) 
[16:03:14.184]                               next
[16:03:14.184]                             invokeRestart(restart)
[16:03:14.184]                             muffled <- TRUE
[16:03:14.184]                             break
[16:03:14.184]                           }
[16:03:14.184]                         }
[16:03:14.184]                       }
[16:03:14.184]                       invisible(muffled)
[16:03:14.184]                     }
[16:03:14.184]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.184]                   }
[16:03:14.184]                 }
[16:03:14.184]             }
[16:03:14.184]         }))
[16:03:14.184]     }, error = function(ex) {
[16:03:14.184]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.184]                 ...future.rng), started = ...future.startTime, 
[16:03:14.184]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.184]             version = "1.8"), class = "FutureResult")
[16:03:14.184]     }, finally = {
[16:03:14.184]         if (!identical(...future.workdir, getwd())) 
[16:03:14.184]             setwd(...future.workdir)
[16:03:14.184]         {
[16:03:14.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.184]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.184]             }
[16:03:14.184]             base::options(...future.oldOptions)
[16:03:14.184]             if (.Platform$OS.type == "windows") {
[16:03:14.184]                 old_names <- names(...future.oldEnvVars)
[16:03:14.184]                 envs <- base::Sys.getenv()
[16:03:14.184]                 names <- names(envs)
[16:03:14.184]                 common <- intersect(names, old_names)
[16:03:14.184]                 added <- setdiff(names, old_names)
[16:03:14.184]                 removed <- setdiff(old_names, names)
[16:03:14.184]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.184]                   envs[common]]
[16:03:14.184]                 NAMES <- toupper(changed)
[16:03:14.184]                 args <- list()
[16:03:14.184]                 for (kk in seq_along(NAMES)) {
[16:03:14.184]                   name <- changed[[kk]]
[16:03:14.184]                   NAME <- NAMES[[kk]]
[16:03:14.184]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.184]                     next
[16:03:14.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.184]                 }
[16:03:14.184]                 NAMES <- toupper(added)
[16:03:14.184]                 for (kk in seq_along(NAMES)) {
[16:03:14.184]                   name <- added[[kk]]
[16:03:14.184]                   NAME <- NAMES[[kk]]
[16:03:14.184]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.184]                     next
[16:03:14.184]                   args[[name]] <- ""
[16:03:14.184]                 }
[16:03:14.184]                 NAMES <- toupper(removed)
[16:03:14.184]                 for (kk in seq_along(NAMES)) {
[16:03:14.184]                   name <- removed[[kk]]
[16:03:14.184]                   NAME <- NAMES[[kk]]
[16:03:14.184]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.184]                     next
[16:03:14.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.184]                 }
[16:03:14.184]                 if (length(args) > 0) 
[16:03:14.184]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.184]             }
[16:03:14.184]             else {
[16:03:14.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.184]             }
[16:03:14.184]             {
[16:03:14.184]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.184]                   0L) {
[16:03:14.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.184]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.184]                   base::options(opts)
[16:03:14.184]                 }
[16:03:14.184]                 {
[16:03:14.184]                   {
[16:03:14.184]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.184]                     NULL
[16:03:14.184]                   }
[16:03:14.184]                   options(future.plan = NULL)
[16:03:14.184]                   if (is.na(NA_character_)) 
[16:03:14.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.184]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.184]                     envir = parent.frame()) 
[16:03:14.184]                   {
[16:03:14.184]                     default_workers <- missing(workers)
[16:03:14.184]                     if (is.function(workers)) 
[16:03:14.184]                       workers <- workers()
[16:03:14.184]                     workers <- structure(as.integer(workers), 
[16:03:14.184]                       class = class(workers))
[16:03:14.184]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.184]                       1L)
[16:03:14.184]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.184]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.184]                       if (default_workers) 
[16:03:14.184]                         supportsMulticore(warn = TRUE)
[16:03:14.184]                       return(sequential(..., envir = envir))
[16:03:14.184]                     }
[16:03:14.184]                     oopts <- options(mc.cores = workers)
[16:03:14.184]                     on.exit(options(oopts))
[16:03:14.184]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.184]                       envir = envir)
[16:03:14.184]                     if (!future$lazy) 
[16:03:14.184]                       future <- run(future)
[16:03:14.184]                     invisible(future)
[16:03:14.184]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.184]                 }
[16:03:14.184]             }
[16:03:14.184]         }
[16:03:14.184]     })
[16:03:14.184]     if (TRUE) {
[16:03:14.184]         base::sink(type = "output", split = FALSE)
[16:03:14.184]         if (TRUE) {
[16:03:14.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.184]         }
[16:03:14.184]         else {
[16:03:14.184]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.184]         }
[16:03:14.184]         base::close(...future.stdout)
[16:03:14.184]         ...future.stdout <- NULL
[16:03:14.184]     }
[16:03:14.184]     ...future.result$conditions <- ...future.conditions
[16:03:14.184]     ...future.result$finished <- base::Sys.time()
[16:03:14.184]     ...future.result
[16:03:14.184] }
[16:03:14.187] assign_globals() ...
[16:03:14.187] List of 11
[16:03:14.187]  $ ...future.FUN            :function (x, ...)  
[16:03:14.187]  $ x_FUN                    :function (x)  
[16:03:14.187]  $ times                    : int 4
[16:03:14.187]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.187]  $ stop_if_not              :function (...)  
[16:03:14.187]  $ dim                      : int [1:2] 2 2
[16:03:14.187]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:14.187]  $ future.call.arguments    : list()
[16:03:14.187]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.187]  $ ...future.elements_ii    :List of 5
[16:03:14.187]   ..$ : int 1
[16:03:14.187]   ..$ : int 2
[16:03:14.187]   ..$ : int 3
[16:03:14.187]   ..$ : int 4
[16:03:14.187]   ..$ : int 5
[16:03:14.187]  $ ...future.seeds_ii       : NULL
[16:03:14.187]  $ ...future.globals.maxSize: NULL
[16:03:14.187]  - attr(*, "where")=List of 11
[16:03:14.187]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.187]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:14.187]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:14.187]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:14.187]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:14.187]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:14.187]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:14.187]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.187]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.187]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.187]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.187]  - attr(*, "resolved")= logi FALSE
[16:03:14.187]  - attr(*, "total_size")= num 105552
[16:03:14.187]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.187]  - attr(*, "already-done")= logi TRUE
[16:03:14.198] - copied ‘...future.FUN’ to environment
[16:03:14.198] - reassign environment for ‘x_FUN’
[16:03:14.198] - copied ‘x_FUN’ to environment
[16:03:14.198] - copied ‘times’ to environment
[16:03:14.198] - copied ‘stopf’ to environment
[16:03:14.198] - copied ‘stop_if_not’ to environment
[16:03:14.198] - copied ‘dim’ to environment
[16:03:14.198] - copied ‘valid_types’ to environment
[16:03:14.199] - copied ‘future.call.arguments’ to environment
[16:03:14.199] - copied ‘...future.elements_ii’ to environment
[16:03:14.199] - copied ‘...future.seeds_ii’ to environment
[16:03:14.199] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.199] assign_globals() ... done
[16:03:14.199] requestCore(): workers = 2
[16:03:14.201] MulticoreFuture started
[16:03:14.202] - Launch lazy future ... done
[16:03:14.202] run() for ‘MulticoreFuture’ ... done
[16:03:14.202] Created future:
[16:03:14.203] plan(): Setting new future strategy stack:
[16:03:14.203] List of future strategies:
[16:03:14.203] 1. sequential:
[16:03:14.203]    - args: function (..., envir = parent.frame())
[16:03:14.203]    - tweaked: FALSE
[16:03:14.203]    - call: NULL
[16:03:14.204] plan(): nbrOfWorkers() = 1
[16:03:14.206] plan(): Setting new future strategy stack:
[16:03:14.206] List of future strategies:
[16:03:14.206] 1. multicore:
[16:03:14.206]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.206]    - tweaked: FALSE
[16:03:14.206]    - call: plan(strategy)
[16:03:14.211] plan(): nbrOfWorkers() = 2
[16:03:14.202] MulticoreFuture:
[16:03:14.202] Label: ‘future_vapply-1’
[16:03:14.202] Expression:
[16:03:14.202] {
[16:03:14.202]     do.call(function(...) {
[16:03:14.202]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.202]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.202]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.202]             on.exit(options(oopts), add = TRUE)
[16:03:14.202]         }
[16:03:14.202]         {
[16:03:14.202]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.202]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.202]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.202]             })
[16:03:14.202]         }
[16:03:14.202]     }, args = future.call.arguments)
[16:03:14.202] }
[16:03:14.202] Lazy evaluation: FALSE
[16:03:14.202] Asynchronous evaluation: TRUE
[16:03:14.202] Local evaluation: TRUE
[16:03:14.202] Environment: R_GlobalEnv
[16:03:14.202] Capture standard output: TRUE
[16:03:14.202] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.202] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:14.202] Packages: 1 packages (‘future.apply’)
[16:03:14.202] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.202] Resolved: TRUE
[16:03:14.202] Value: <not collected>
[16:03:14.202] Conditions captured: <none>
[16:03:14.202] Early signaling: FALSE
[16:03:14.202] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.202] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.213] Chunk #1 of 2 ... DONE
[16:03:14.213] Chunk #2 of 2 ...
[16:03:14.213]  - Finding globals in 'X' for chunk #2 ...
[16:03:14.213] getGlobalsAndPackages() ...
[16:03:14.213] Searching for globals...
[16:03:14.214] 
[16:03:14.214] Searching for globals ... DONE
[16:03:14.214] - globals: [0] <none>
[16:03:14.214] getGlobalsAndPackages() ... DONE
[16:03:14.214]    + additional globals found: [n=0] 
[16:03:14.214]    + additional namespaces needed: [n=0] 
[16:03:14.215]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:14.215]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.215]  - seeds: <none>
[16:03:14.215]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.215] getGlobalsAndPackages() ...
[16:03:14.215] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.216] Resolving globals: FALSE
[16:03:14.216] Tweak future expression to call with '...' arguments ...
[16:03:14.216] {
[16:03:14.216]     do.call(function(...) {
[16:03:14.216]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.216]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.216]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.216]             on.exit(options(oopts), add = TRUE)
[16:03:14.216]         }
[16:03:14.216]         {
[16:03:14.216]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.216]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.216]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.216]             })
[16:03:14.216]         }
[16:03:14.216]     }, args = future.call.arguments)
[16:03:14.216] }
[16:03:14.216] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.217] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.218] - packages: [1] ‘future.apply’
[16:03:14.218] getGlobalsAndPackages() ... DONE
[16:03:14.218] run() for ‘Future’ ...
[16:03:14.218] - state: ‘created’
[16:03:14.219] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.223] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.223] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.224]   - Field: ‘label’
[16:03:14.224]   - Field: ‘local’
[16:03:14.224]   - Field: ‘owner’
[16:03:14.224]   - Field: ‘envir’
[16:03:14.224]   - Field: ‘workers’
[16:03:14.224]   - Field: ‘packages’
[16:03:14.224]   - Field: ‘gc’
[16:03:14.225]   - Field: ‘job’
[16:03:14.225]   - Field: ‘conditions’
[16:03:14.225]   - Field: ‘expr’
[16:03:14.225]   - Field: ‘uuid’
[16:03:14.225]   - Field: ‘seed’
[16:03:14.225]   - Field: ‘version’
[16:03:14.225]   - Field: ‘result’
[16:03:14.226]   - Field: ‘asynchronous’
[16:03:14.226]   - Field: ‘calls’
[16:03:14.226]   - Field: ‘globals’
[16:03:14.226]   - Field: ‘stdout’
[16:03:14.226]   - Field: ‘earlySignal’
[16:03:14.226]   - Field: ‘lazy’
[16:03:14.226]   - Field: ‘state’
[16:03:14.227] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.227] - Launch lazy future ...
[16:03:14.227] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:14.227] Packages needed by future strategies (n = 0): <none>
[16:03:14.231] {
[16:03:14.231]     {
[16:03:14.231]         {
[16:03:14.231]             ...future.startTime <- base::Sys.time()
[16:03:14.231]             {
[16:03:14.231]                 {
[16:03:14.231]                   {
[16:03:14.231]                     {
[16:03:14.231]                       {
[16:03:14.231]                         base::local({
[16:03:14.231]                           has_future <- base::requireNamespace("future", 
[16:03:14.231]                             quietly = TRUE)
[16:03:14.231]                           if (has_future) {
[16:03:14.231]                             ns <- base::getNamespace("future")
[16:03:14.231]                             version <- ns[[".package"]][["version"]]
[16:03:14.231]                             if (is.null(version)) 
[16:03:14.231]                               version <- utils::packageVersion("future")
[16:03:14.231]                           }
[16:03:14.231]                           else {
[16:03:14.231]                             version <- NULL
[16:03:14.231]                           }
[16:03:14.231]                           if (!has_future || version < "1.8.0") {
[16:03:14.231]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.231]                               "", base::R.version$version.string), 
[16:03:14.231]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.231]                                 base::R.version$platform, 8 * 
[16:03:14.231]                                   base::.Machine$sizeof.pointer), 
[16:03:14.231]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.231]                                 "release", "version")], collapse = " "), 
[16:03:14.231]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.231]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.231]                               info)
[16:03:14.231]                             info <- base::paste(info, collapse = "; ")
[16:03:14.231]                             if (!has_future) {
[16:03:14.231]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.231]                                 info)
[16:03:14.231]                             }
[16:03:14.231]                             else {
[16:03:14.231]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.231]                                 info, version)
[16:03:14.231]                             }
[16:03:14.231]                             base::stop(msg)
[16:03:14.231]                           }
[16:03:14.231]                         })
[16:03:14.231]                       }
[16:03:14.231]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.231]                       base::options(mc.cores = 1L)
[16:03:14.231]                     }
[16:03:14.231]                     base::local({
[16:03:14.231]                       for (pkg in "future.apply") {
[16:03:14.231]                         base::loadNamespace(pkg)
[16:03:14.231]                         base::library(pkg, character.only = TRUE)
[16:03:14.231]                       }
[16:03:14.231]                     })
[16:03:14.231]                   }
[16:03:14.231]                   options(future.plan = NULL)
[16:03:14.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.231]                 }
[16:03:14.231]                 ...future.workdir <- getwd()
[16:03:14.231]             }
[16:03:14.231]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.231]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.231]         }
[16:03:14.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.231]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.231]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.231]             base::names(...future.oldOptions))
[16:03:14.231]     }
[16:03:14.231]     if (FALSE) {
[16:03:14.231]     }
[16:03:14.231]     else {
[16:03:14.231]         if (TRUE) {
[16:03:14.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.231]                 open = "w")
[16:03:14.231]         }
[16:03:14.231]         else {
[16:03:14.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.231]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.231]         }
[16:03:14.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.231]             base::sink(type = "output", split = FALSE)
[16:03:14.231]             base::close(...future.stdout)
[16:03:14.231]         }, add = TRUE)
[16:03:14.231]     }
[16:03:14.231]     ...future.frame <- base::sys.nframe()
[16:03:14.231]     ...future.conditions <- base::list()
[16:03:14.231]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.231]     if (FALSE) {
[16:03:14.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.231]     }
[16:03:14.231]     ...future.result <- base::tryCatch({
[16:03:14.231]         base::withCallingHandlers({
[16:03:14.231]             ...future.value <- base::withVisible(base::local({
[16:03:14.231]                 withCallingHandlers({
[16:03:14.231]                   {
[16:03:14.231]                     do.call(function(...) {
[16:03:14.231]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.231]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.231]                         ...future.globals.maxSize)) {
[16:03:14.231]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.231]                         on.exit(options(oopts), add = TRUE)
[16:03:14.231]                       }
[16:03:14.231]                       {
[16:03:14.231]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.231]                           FUN = function(jj) {
[16:03:14.231]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.231]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.231]                           })
[16:03:14.231]                       }
[16:03:14.231]                     }, args = future.call.arguments)
[16:03:14.231]                   }
[16:03:14.231]                 }, immediateCondition = function(cond) {
[16:03:14.231]                   save_rds <- function (object, pathname, ...) 
[16:03:14.231]                   {
[16:03:14.231]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.231]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.231]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.231]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.231]                         fi_tmp[["mtime"]])
[16:03:14.231]                     }
[16:03:14.231]                     tryCatch({
[16:03:14.231]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.231]                     }, error = function(ex) {
[16:03:14.231]                       msg <- conditionMessage(ex)
[16:03:14.231]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.231]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.231]                         fi_tmp[["mtime"]], msg)
[16:03:14.231]                       ex$message <- msg
[16:03:14.231]                       stop(ex)
[16:03:14.231]                     })
[16:03:14.231]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.231]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.231]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.231]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.231]                       fi <- file.info(pathname)
[16:03:14.231]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.231]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.231]                         fi[["size"]], fi[["mtime"]])
[16:03:14.231]                       stop(msg)
[16:03:14.231]                     }
[16:03:14.231]                     invisible(pathname)
[16:03:14.231]                   }
[16:03:14.231]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.231]                     rootPath = tempdir()) 
[16:03:14.231]                   {
[16:03:14.231]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.231]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.231]                       tmpdir = path, fileext = ".rds")
[16:03:14.231]                     save_rds(obj, file)
[16:03:14.231]                   }
[16:03:14.231]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.231]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.231]                   {
[16:03:14.231]                     inherits <- base::inherits
[16:03:14.231]                     invokeRestart <- base::invokeRestart
[16:03:14.231]                     is.null <- base::is.null
[16:03:14.231]                     muffled <- FALSE
[16:03:14.231]                     if (inherits(cond, "message")) {
[16:03:14.231]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.231]                       if (muffled) 
[16:03:14.231]                         invokeRestart("muffleMessage")
[16:03:14.231]                     }
[16:03:14.231]                     else if (inherits(cond, "warning")) {
[16:03:14.231]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.231]                       if (muffled) 
[16:03:14.231]                         invokeRestart("muffleWarning")
[16:03:14.231]                     }
[16:03:14.231]                     else if (inherits(cond, "condition")) {
[16:03:14.231]                       if (!is.null(pattern)) {
[16:03:14.231]                         computeRestarts <- base::computeRestarts
[16:03:14.231]                         grepl <- base::grepl
[16:03:14.231]                         restarts <- computeRestarts(cond)
[16:03:14.231]                         for (restart in restarts) {
[16:03:14.231]                           name <- restart$name
[16:03:14.231]                           if (is.null(name)) 
[16:03:14.231]                             next
[16:03:14.231]                           if (!grepl(pattern, name)) 
[16:03:14.231]                             next
[16:03:14.231]                           invokeRestart(restart)
[16:03:14.231]                           muffled <- TRUE
[16:03:14.231]                           break
[16:03:14.231]                         }
[16:03:14.231]                       }
[16:03:14.231]                     }
[16:03:14.231]                     invisible(muffled)
[16:03:14.231]                   }
[16:03:14.231]                   muffleCondition(cond)
[16:03:14.231]                 })
[16:03:14.231]             }))
[16:03:14.231]             future::FutureResult(value = ...future.value$value, 
[16:03:14.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.231]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.231]                     ...future.globalenv.names))
[16:03:14.231]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.231]         }, condition = base::local({
[16:03:14.231]             c <- base::c
[16:03:14.231]             inherits <- base::inherits
[16:03:14.231]             invokeRestart <- base::invokeRestart
[16:03:14.231]             length <- base::length
[16:03:14.231]             list <- base::list
[16:03:14.231]             seq.int <- base::seq.int
[16:03:14.231]             signalCondition <- base::signalCondition
[16:03:14.231]             sys.calls <- base::sys.calls
[16:03:14.231]             `[[` <- base::`[[`
[16:03:14.231]             `+` <- base::`+`
[16:03:14.231]             `<<-` <- base::`<<-`
[16:03:14.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.231]                   3L)]
[16:03:14.231]             }
[16:03:14.231]             function(cond) {
[16:03:14.231]                 is_error <- inherits(cond, "error")
[16:03:14.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.231]                   NULL)
[16:03:14.231]                 if (is_error) {
[16:03:14.231]                   sessionInformation <- function() {
[16:03:14.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.231]                       search = base::search(), system = base::Sys.info())
[16:03:14.231]                   }
[16:03:14.231]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.231]                     cond$call), session = sessionInformation(), 
[16:03:14.231]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.231]                   signalCondition(cond)
[16:03:14.231]                 }
[16:03:14.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.231]                 "immediateCondition"))) {
[16:03:14.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.231]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.231]                   if (TRUE && !signal) {
[16:03:14.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.231]                     {
[16:03:14.231]                       inherits <- base::inherits
[16:03:14.231]                       invokeRestart <- base::invokeRestart
[16:03:14.231]                       is.null <- base::is.null
[16:03:14.231]                       muffled <- FALSE
[16:03:14.231]                       if (inherits(cond, "message")) {
[16:03:14.231]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.231]                         if (muffled) 
[16:03:14.231]                           invokeRestart("muffleMessage")
[16:03:14.231]                       }
[16:03:14.231]                       else if (inherits(cond, "warning")) {
[16:03:14.231]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.231]                         if (muffled) 
[16:03:14.231]                           invokeRestart("muffleWarning")
[16:03:14.231]                       }
[16:03:14.231]                       else if (inherits(cond, "condition")) {
[16:03:14.231]                         if (!is.null(pattern)) {
[16:03:14.231]                           computeRestarts <- base::computeRestarts
[16:03:14.231]                           grepl <- base::grepl
[16:03:14.231]                           restarts <- computeRestarts(cond)
[16:03:14.231]                           for (restart in restarts) {
[16:03:14.231]                             name <- restart$name
[16:03:14.231]                             if (is.null(name)) 
[16:03:14.231]                               next
[16:03:14.231]                             if (!grepl(pattern, name)) 
[16:03:14.231]                               next
[16:03:14.231]                             invokeRestart(restart)
[16:03:14.231]                             muffled <- TRUE
[16:03:14.231]                             break
[16:03:14.231]                           }
[16:03:14.231]                         }
[16:03:14.231]                       }
[16:03:14.231]                       invisible(muffled)
[16:03:14.231]                     }
[16:03:14.231]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.231]                   }
[16:03:14.231]                 }
[16:03:14.231]                 else {
[16:03:14.231]                   if (TRUE) {
[16:03:14.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.231]                     {
[16:03:14.231]                       inherits <- base::inherits
[16:03:14.231]                       invokeRestart <- base::invokeRestart
[16:03:14.231]                       is.null <- base::is.null
[16:03:14.231]                       muffled <- FALSE
[16:03:14.231]                       if (inherits(cond, "message")) {
[16:03:14.231]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.231]                         if (muffled) 
[16:03:14.231]                           invokeRestart("muffleMessage")
[16:03:14.231]                       }
[16:03:14.231]                       else if (inherits(cond, "warning")) {
[16:03:14.231]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.231]                         if (muffled) 
[16:03:14.231]                           invokeRestart("muffleWarning")
[16:03:14.231]                       }
[16:03:14.231]                       else if (inherits(cond, "condition")) {
[16:03:14.231]                         if (!is.null(pattern)) {
[16:03:14.231]                           computeRestarts <- base::computeRestarts
[16:03:14.231]                           grepl <- base::grepl
[16:03:14.231]                           restarts <- computeRestarts(cond)
[16:03:14.231]                           for (restart in restarts) {
[16:03:14.231]                             name <- restart$name
[16:03:14.231]                             if (is.null(name)) 
[16:03:14.231]                               next
[16:03:14.231]                             if (!grepl(pattern, name)) 
[16:03:14.231]                               next
[16:03:14.231]                             invokeRestart(restart)
[16:03:14.231]                             muffled <- TRUE
[16:03:14.231]                             break
[16:03:14.231]                           }
[16:03:14.231]                         }
[16:03:14.231]                       }
[16:03:14.231]                       invisible(muffled)
[16:03:14.231]                     }
[16:03:14.231]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.231]                   }
[16:03:14.231]                 }
[16:03:14.231]             }
[16:03:14.231]         }))
[16:03:14.231]     }, error = function(ex) {
[16:03:14.231]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.231]                 ...future.rng), started = ...future.startTime, 
[16:03:14.231]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.231]             version = "1.8"), class = "FutureResult")
[16:03:14.231]     }, finally = {
[16:03:14.231]         if (!identical(...future.workdir, getwd())) 
[16:03:14.231]             setwd(...future.workdir)
[16:03:14.231]         {
[16:03:14.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.231]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.231]             }
[16:03:14.231]             base::options(...future.oldOptions)
[16:03:14.231]             if (.Platform$OS.type == "windows") {
[16:03:14.231]                 old_names <- names(...future.oldEnvVars)
[16:03:14.231]                 envs <- base::Sys.getenv()
[16:03:14.231]                 names <- names(envs)
[16:03:14.231]                 common <- intersect(names, old_names)
[16:03:14.231]                 added <- setdiff(names, old_names)
[16:03:14.231]                 removed <- setdiff(old_names, names)
[16:03:14.231]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.231]                   envs[common]]
[16:03:14.231]                 NAMES <- toupper(changed)
[16:03:14.231]                 args <- list()
[16:03:14.231]                 for (kk in seq_along(NAMES)) {
[16:03:14.231]                   name <- changed[[kk]]
[16:03:14.231]                   NAME <- NAMES[[kk]]
[16:03:14.231]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.231]                     next
[16:03:14.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.231]                 }
[16:03:14.231]                 NAMES <- toupper(added)
[16:03:14.231]                 for (kk in seq_along(NAMES)) {
[16:03:14.231]                   name <- added[[kk]]
[16:03:14.231]                   NAME <- NAMES[[kk]]
[16:03:14.231]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.231]                     next
[16:03:14.231]                   args[[name]] <- ""
[16:03:14.231]                 }
[16:03:14.231]                 NAMES <- toupper(removed)
[16:03:14.231]                 for (kk in seq_along(NAMES)) {
[16:03:14.231]                   name <- removed[[kk]]
[16:03:14.231]                   NAME <- NAMES[[kk]]
[16:03:14.231]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.231]                     next
[16:03:14.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.231]                 }
[16:03:14.231]                 if (length(args) > 0) 
[16:03:14.231]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.231]             }
[16:03:14.231]             else {
[16:03:14.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.231]             }
[16:03:14.231]             {
[16:03:14.231]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.231]                   0L) {
[16:03:14.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.231]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.231]                   base::options(opts)
[16:03:14.231]                 }
[16:03:14.231]                 {
[16:03:14.231]                   {
[16:03:14.231]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.231]                     NULL
[16:03:14.231]                   }
[16:03:14.231]                   options(future.plan = NULL)
[16:03:14.231]                   if (is.na(NA_character_)) 
[16:03:14.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.231]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.231]                     envir = parent.frame()) 
[16:03:14.231]                   {
[16:03:14.231]                     default_workers <- missing(workers)
[16:03:14.231]                     if (is.function(workers)) 
[16:03:14.231]                       workers <- workers()
[16:03:14.231]                     workers <- structure(as.integer(workers), 
[16:03:14.231]                       class = class(workers))
[16:03:14.231]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.231]                       1L)
[16:03:14.231]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.231]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.231]                       if (default_workers) 
[16:03:14.231]                         supportsMulticore(warn = TRUE)
[16:03:14.231]                       return(sequential(..., envir = envir))
[16:03:14.231]                     }
[16:03:14.231]                     oopts <- options(mc.cores = workers)
[16:03:14.231]                     on.exit(options(oopts))
[16:03:14.231]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.231]                       envir = envir)
[16:03:14.231]                     if (!future$lazy) 
[16:03:14.231]                       future <- run(future)
[16:03:14.231]                     invisible(future)
[16:03:14.231]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.231]                 }
[16:03:14.231]             }
[16:03:14.231]         }
[16:03:14.231]     })
[16:03:14.231]     if (TRUE) {
[16:03:14.231]         base::sink(type = "output", split = FALSE)
[16:03:14.231]         if (TRUE) {
[16:03:14.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.231]         }
[16:03:14.231]         else {
[16:03:14.231]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.231]         }
[16:03:14.231]         base::close(...future.stdout)
[16:03:14.231]         ...future.stdout <- NULL
[16:03:14.231]     }
[16:03:14.231]     ...future.result$conditions <- ...future.conditions
[16:03:14.231]     ...future.result$finished <- base::Sys.time()
[16:03:14.231]     ...future.result
[16:03:14.231] }
[16:03:14.235] assign_globals() ...
[16:03:14.235] List of 11
[16:03:14.235]  $ ...future.FUN            :function (x, ...)  
[16:03:14.235]  $ x_FUN                    :function (x)  
[16:03:14.235]  $ times                    : int 4
[16:03:14.235]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.235]  $ stop_if_not              :function (...)  
[16:03:14.235]  $ dim                      : int [1:2] 2 2
[16:03:14.235]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:14.235]  $ future.call.arguments    : list()
[16:03:14.235]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.235]  $ ...future.elements_ii    :List of 5
[16:03:14.235]   ..$ : int 6
[16:03:14.235]   ..$ : int 7
[16:03:14.235]   ..$ : int 8
[16:03:14.235]   ..$ : int 9
[16:03:14.235]   ..$ : int 10
[16:03:14.235]  $ ...future.seeds_ii       : NULL
[16:03:14.235]  $ ...future.globals.maxSize: NULL
[16:03:14.235]  - attr(*, "where")=List of 11
[16:03:14.235]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.235]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:14.235]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:14.235]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:14.235]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:14.235]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:14.235]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:14.235]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.235]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.235]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.235]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.235]  - attr(*, "resolved")= logi FALSE
[16:03:14.235]  - attr(*, "total_size")= num 105552
[16:03:14.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.235]  - attr(*, "already-done")= logi TRUE
[16:03:14.250] - copied ‘...future.FUN’ to environment
[16:03:14.250] - reassign environment for ‘x_FUN’
[16:03:14.250] - copied ‘x_FUN’ to environment
[16:03:14.250] - copied ‘times’ to environment
[16:03:14.250] - copied ‘stopf’ to environment
[16:03:14.250] - copied ‘stop_if_not’ to environment
[16:03:14.251] - copied ‘dim’ to environment
[16:03:14.251] - copied ‘valid_types’ to environment
[16:03:14.251] - copied ‘future.call.arguments’ to environment
[16:03:14.251] - copied ‘...future.elements_ii’ to environment
[16:03:14.251] - copied ‘...future.seeds_ii’ to environment
[16:03:14.251] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.251] assign_globals() ... done
[16:03:14.251] requestCore(): workers = 2
[16:03:14.253] MulticoreFuture started
[16:03:14.254] - Launch lazy future ... done
[16:03:14.254] run() for ‘MulticoreFuture’ ... done
[16:03:14.254] Created future:
[16:03:14.255] plan(): Setting new future strategy stack:
[16:03:14.255] List of future strategies:
[16:03:14.255] 1. sequential:
[16:03:14.255]    - args: function (..., envir = parent.frame())
[16:03:14.255]    - tweaked: FALSE
[16:03:14.255]    - call: NULL
[16:03:14.256] plan(): nbrOfWorkers() = 1
[16:03:14.258] plan(): Setting new future strategy stack:
[16:03:14.258] List of future strategies:
[16:03:14.258] 1. multicore:
[16:03:14.258]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.258]    - tweaked: FALSE
[16:03:14.258]    - call: plan(strategy)
[16:03:14.263] plan(): nbrOfWorkers() = 2
[16:03:14.255] MulticoreFuture:
[16:03:14.255] Label: ‘future_vapply-2’
[16:03:14.255] Expression:
[16:03:14.255] {
[16:03:14.255]     do.call(function(...) {
[16:03:14.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.255]             on.exit(options(oopts), add = TRUE)
[16:03:14.255]         }
[16:03:14.255]         {
[16:03:14.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.255]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.255]             })
[16:03:14.255]         }
[16:03:14.255]     }, args = future.call.arguments)
[16:03:14.255] }
[16:03:14.255] Lazy evaluation: FALSE
[16:03:14.255] Asynchronous evaluation: TRUE
[16:03:14.255] Local evaluation: TRUE
[16:03:14.255] Environment: R_GlobalEnv
[16:03:14.255] Capture standard output: TRUE
[16:03:14.255] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.255] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:14.255] Packages: 1 packages (‘future.apply’)
[16:03:14.255] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.255] Resolved: TRUE
[16:03:14.255] Value: <not collected>
[16:03:14.255] Conditions captured: <none>
[16:03:14.255] Early signaling: FALSE
[16:03:14.255] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.255] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.264] Chunk #2 of 2 ... DONE
[16:03:14.264] Launching 2 futures (chunks) ... DONE
[16:03:14.264] Resolving 2 futures (chunks) ...
[16:03:14.265] resolve() on list ...
[16:03:14.265]  recursive: 0
[16:03:14.265]  length: 2
[16:03:14.265] 
[16:03:14.265] Future #1
[16:03:14.266] result() for MulticoreFuture ...
[16:03:14.267] result() for MulticoreFuture ...
[16:03:14.267] result() for MulticoreFuture ... done
[16:03:14.267] result() for MulticoreFuture ... done
[16:03:14.267] result() for MulticoreFuture ...
[16:03:14.267] result() for MulticoreFuture ... done
[16:03:14.268] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:14.268] - nx: 2
[16:03:14.268] - relay: TRUE
[16:03:14.268] - stdout: TRUE
[16:03:14.268] - signal: TRUE
[16:03:14.269] - resignal: FALSE
[16:03:14.269] - force: TRUE
[16:03:14.269] - relayed: [n=2] FALSE, FALSE
[16:03:14.269] - queued futures: [n=2] FALSE, FALSE
[16:03:14.269]  - until=1
[16:03:14.270]  - relaying element #1
[16:03:14.270] result() for MulticoreFuture ...
[16:03:14.270] result() for MulticoreFuture ... done
[16:03:14.270] result() for MulticoreFuture ...
[16:03:14.270] result() for MulticoreFuture ... done
[16:03:14.271] result() for MulticoreFuture ...
[16:03:14.271] result() for MulticoreFuture ... done
[16:03:14.271] result() for MulticoreFuture ...
[16:03:14.271] result() for MulticoreFuture ... done
[16:03:14.271] - relayed: [n=2] TRUE, FALSE
[16:03:14.271] - queued futures: [n=2] TRUE, FALSE
[16:03:14.272] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:14.272]  length: 1 (resolved future 1)
[16:03:14.272] Future #2
[16:03:14.272] result() for MulticoreFuture ...
[16:03:14.273] result() for MulticoreFuture ...
[16:03:14.273] result() for MulticoreFuture ... done
[16:03:14.273] result() for MulticoreFuture ... done
[16:03:14.277] result() for MulticoreFuture ...
[16:03:14.278] result() for MulticoreFuture ... done
[16:03:14.278] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:14.278] - nx: 2
[16:03:14.278] - relay: TRUE
[16:03:14.278] - stdout: TRUE
[16:03:14.279] - signal: TRUE
[16:03:14.279] - resignal: FALSE
[16:03:14.279] - force: TRUE
[16:03:14.279] - relayed: [n=2] TRUE, FALSE
[16:03:14.279] - queued futures: [n=2] TRUE, FALSE
[16:03:14.279]  - until=2
[16:03:14.280]  - relaying element #2
[16:03:14.280] result() for MulticoreFuture ...
[16:03:14.280] result() for MulticoreFuture ... done
[16:03:14.280] result() for MulticoreFuture ...
[16:03:14.280] result() for MulticoreFuture ... done
[16:03:14.280] result() for MulticoreFuture ...
[16:03:14.281] result() for MulticoreFuture ... done
[16:03:14.281] result() for MulticoreFuture ...
[16:03:14.281] result() for MulticoreFuture ... done
[16:03:14.281] - relayed: [n=2] TRUE, TRUE
[16:03:14.281] - queued futures: [n=2] TRUE, TRUE
[16:03:14.281] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:14.282]  length: 0 (resolved future 2)
[16:03:14.282] Relaying remaining futures
[16:03:14.282] signalConditionsASAP(NULL, pos=0) ...
[16:03:14.282] - nx: 2
[16:03:14.282] - relay: TRUE
[16:03:14.282] - stdout: TRUE
[16:03:14.282] - signal: TRUE
[16:03:14.282] - resignal: FALSE
[16:03:14.283] - force: TRUE
[16:03:14.283] - relayed: [n=2] TRUE, TRUE
[16:03:14.283] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:14.283] - relayed: [n=2] TRUE, TRUE
[16:03:14.283] - queued futures: [n=2] TRUE, TRUE
[16:03:14.284] signalConditionsASAP(NULL, pos=0) ... done
[16:03:14.284] resolve() on list ... DONE
[16:03:14.284] result() for MulticoreFuture ...
[16:03:14.284] result() for MulticoreFuture ... done
[16:03:14.284] result() for MulticoreFuture ...
[16:03:14.284] result() for MulticoreFuture ... done
[16:03:14.284] result() for MulticoreFuture ...
[16:03:14.285] result() for MulticoreFuture ... done
[16:03:14.285] result() for MulticoreFuture ...
[16:03:14.285] result() for MulticoreFuture ... done
[16:03:14.285]  - Number of value chunks collected: 2
[16:03:14.285] Resolving 2 futures (chunks) ... DONE
[16:03:14.285] Reducing values from 2 chunks ...
[16:03:14.285]  - Number of values collected after concatenation: 10
[16:03:14.286]  - Number of values expected: 10
[16:03:14.286] Reducing values from 2 chunks ... DONE
[16:03:14.286] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[16:03:14.289] future_lapply() ...
[16:03:14.295] Number of chunks: 2
[16:03:14.295] getGlobalsAndPackagesXApply() ...
[16:03:14.295]  - future.globals: TRUE
[16:03:14.295] getGlobalsAndPackages() ...
[16:03:14.295] Searching for globals...
[16:03:14.299] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[16:03:14.299] Searching for globals ... DONE
[16:03:14.299] Resolving globals: FALSE
[16:03:14.300] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[16:03:14.301] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:14.301] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.301] - packages: [2] ‘stats’, ‘future.apply’
[16:03:14.301] getGlobalsAndPackages() ... DONE
[16:03:14.301]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.301]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:03:14.301] Finding globals ... DONE
[16:03:14.301]  - use_args: TRUE
[16:03:14.302]  - Getting '...' globals ...
[16:03:14.302] resolve() on list ...
[16:03:14.302]  recursive: 0
[16:03:14.302]  length: 1
[16:03:14.302]  elements: ‘...’
[16:03:14.302]  length: 0 (resolved future 1)
[16:03:14.302] resolve() on list ... DONE
[16:03:14.302]    - '...' content: [n=0] 
[16:03:14.305] List of 1
[16:03:14.305]  $ ...: list()
[16:03:14.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.305]  - attr(*, "where")=List of 1
[16:03:14.305]   ..$ ...:<environment: 0x564e41311720> 
[16:03:14.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.305]  - attr(*, "resolved")= logi TRUE
[16:03:14.305]  - attr(*, "total_size")= num NA
[16:03:14.307]  - Getting '...' globals ... DONE
[16:03:14.308] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:14.308] List of 8
[16:03:14.308]  $ ...future.FUN:function (x, ...)  
[16:03:14.308]  $ x_FUN        :function (x, ...)  
[16:03:14.308]  $ times        : int 5
[16:03:14.308]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.308]  $ stop_if_not  :function (...)  
[16:03:14.308]  $ dim          : NULL
[16:03:14.308]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:14.308]  $ ...          : list()
[16:03:14.308]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.308]  - attr(*, "where")=List of 8
[16:03:14.308]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:14.308]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:14.308]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:14.308]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:14.308]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:14.308]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:14.308]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:14.308]   ..$ ...          :<environment: 0x564e41311720> 
[16:03:14.308]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.308]  - attr(*, "resolved")= logi FALSE
[16:03:14.308]  - attr(*, "total_size")= num 95528
[16:03:14.313] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:03:14.314] getGlobalsAndPackagesXApply() ... DONE
[16:03:14.314] Number of futures (= number of chunks): 2
[16:03:14.314] Launching 2 futures (chunks) ...
[16:03:14.314] Chunk #1 of 2 ...
[16:03:14.314]  - Finding globals in 'X' for chunk #1 ...
[16:03:14.314] getGlobalsAndPackages() ...
[16:03:14.314] Searching for globals...
[16:03:14.315] 
[16:03:14.315] Searching for globals ... DONE
[16:03:14.315] - globals: [0] <none>
[16:03:14.315] getGlobalsAndPackages() ... DONE
[16:03:14.315]    + additional globals found: [n=0] 
[16:03:14.315]    + additional namespaces needed: [n=0] 
[16:03:14.315]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:14.315]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.315]  - seeds: <none>
[16:03:14.315]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.316] getGlobalsAndPackages() ...
[16:03:14.316] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.316] Resolving globals: FALSE
[16:03:14.316] Tweak future expression to call with '...' arguments ...
[16:03:14.316] {
[16:03:14.316]     do.call(function(...) {
[16:03:14.316]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.316]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.316]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.316]             on.exit(options(oopts), add = TRUE)
[16:03:14.316]         }
[16:03:14.316]         {
[16:03:14.316]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.316]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.316]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.316]             })
[16:03:14.316]         }
[16:03:14.316]     }, args = future.call.arguments)
[16:03:14.316] }
[16:03:14.316] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.317] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.317] - packages: [2] ‘stats’, ‘future.apply’
[16:03:14.317] getGlobalsAndPackages() ... DONE
[16:03:14.317] run() for ‘Future’ ...
[16:03:14.317] - state: ‘created’
[16:03:14.318] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.321] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.321] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.321]   - Field: ‘label’
[16:03:14.321]   - Field: ‘local’
[16:03:14.322]   - Field: ‘owner’
[16:03:14.322]   - Field: ‘envir’
[16:03:14.322]   - Field: ‘workers’
[16:03:14.322]   - Field: ‘packages’
[16:03:14.322]   - Field: ‘gc’
[16:03:14.322]   - Field: ‘job’
[16:03:14.322]   - Field: ‘conditions’
[16:03:14.322]   - Field: ‘expr’
[16:03:14.322]   - Field: ‘uuid’
[16:03:14.322]   - Field: ‘seed’
[16:03:14.323]   - Field: ‘version’
[16:03:14.323]   - Field: ‘result’
[16:03:14.323]   - Field: ‘asynchronous’
[16:03:14.323]   - Field: ‘calls’
[16:03:14.323]   - Field: ‘globals’
[16:03:14.323]   - Field: ‘stdout’
[16:03:14.323]   - Field: ‘earlySignal’
[16:03:14.323]   - Field: ‘lazy’
[16:03:14.323]   - Field: ‘state’
[16:03:14.323] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.324] - Launch lazy future ...
[16:03:14.324] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:03:14.324] Packages needed by future strategies (n = 0): <none>
[16:03:14.324] {
[16:03:14.324]     {
[16:03:14.324]         {
[16:03:14.324]             ...future.startTime <- base::Sys.time()
[16:03:14.324]             {
[16:03:14.324]                 {
[16:03:14.324]                   {
[16:03:14.324]                     {
[16:03:14.324]                       {
[16:03:14.324]                         base::local({
[16:03:14.324]                           has_future <- base::requireNamespace("future", 
[16:03:14.324]                             quietly = TRUE)
[16:03:14.324]                           if (has_future) {
[16:03:14.324]                             ns <- base::getNamespace("future")
[16:03:14.324]                             version <- ns[[".package"]][["version"]]
[16:03:14.324]                             if (is.null(version)) 
[16:03:14.324]                               version <- utils::packageVersion("future")
[16:03:14.324]                           }
[16:03:14.324]                           else {
[16:03:14.324]                             version <- NULL
[16:03:14.324]                           }
[16:03:14.324]                           if (!has_future || version < "1.8.0") {
[16:03:14.324]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.324]                               "", base::R.version$version.string), 
[16:03:14.324]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.324]                                 base::R.version$platform, 8 * 
[16:03:14.324]                                   base::.Machine$sizeof.pointer), 
[16:03:14.324]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.324]                                 "release", "version")], collapse = " "), 
[16:03:14.324]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.324]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.324]                               info)
[16:03:14.324]                             info <- base::paste(info, collapse = "; ")
[16:03:14.324]                             if (!has_future) {
[16:03:14.324]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.324]                                 info)
[16:03:14.324]                             }
[16:03:14.324]                             else {
[16:03:14.324]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.324]                                 info, version)
[16:03:14.324]                             }
[16:03:14.324]                             base::stop(msg)
[16:03:14.324]                           }
[16:03:14.324]                         })
[16:03:14.324]                       }
[16:03:14.324]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.324]                       base::options(mc.cores = 1L)
[16:03:14.324]                     }
[16:03:14.324]                     base::local({
[16:03:14.324]                       for (pkg in c("stats", "future.apply")) {
[16:03:14.324]                         base::loadNamespace(pkg)
[16:03:14.324]                         base::library(pkg, character.only = TRUE)
[16:03:14.324]                       }
[16:03:14.324]                     })
[16:03:14.324]                   }
[16:03:14.324]                   options(future.plan = NULL)
[16:03:14.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.324]                 }
[16:03:14.324]                 ...future.workdir <- getwd()
[16:03:14.324]             }
[16:03:14.324]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.324]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.324]         }
[16:03:14.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.324]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.324]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.324]             base::names(...future.oldOptions))
[16:03:14.324]     }
[16:03:14.324]     if (FALSE) {
[16:03:14.324]     }
[16:03:14.324]     else {
[16:03:14.324]         if (TRUE) {
[16:03:14.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.324]                 open = "w")
[16:03:14.324]         }
[16:03:14.324]         else {
[16:03:14.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.324]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.324]         }
[16:03:14.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.324]             base::sink(type = "output", split = FALSE)
[16:03:14.324]             base::close(...future.stdout)
[16:03:14.324]         }, add = TRUE)
[16:03:14.324]     }
[16:03:14.324]     ...future.frame <- base::sys.nframe()
[16:03:14.324]     ...future.conditions <- base::list()
[16:03:14.324]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.324]     if (FALSE) {
[16:03:14.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.324]     }
[16:03:14.324]     ...future.result <- base::tryCatch({
[16:03:14.324]         base::withCallingHandlers({
[16:03:14.324]             ...future.value <- base::withVisible(base::local({
[16:03:14.324]                 withCallingHandlers({
[16:03:14.324]                   {
[16:03:14.324]                     do.call(function(...) {
[16:03:14.324]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.324]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.324]                         ...future.globals.maxSize)) {
[16:03:14.324]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.324]                         on.exit(options(oopts), add = TRUE)
[16:03:14.324]                       }
[16:03:14.324]                       {
[16:03:14.324]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.324]                           FUN = function(jj) {
[16:03:14.324]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.324]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.324]                           })
[16:03:14.324]                       }
[16:03:14.324]                     }, args = future.call.arguments)
[16:03:14.324]                   }
[16:03:14.324]                 }, immediateCondition = function(cond) {
[16:03:14.324]                   save_rds <- function (object, pathname, ...) 
[16:03:14.324]                   {
[16:03:14.324]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.324]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.324]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.324]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.324]                         fi_tmp[["mtime"]])
[16:03:14.324]                     }
[16:03:14.324]                     tryCatch({
[16:03:14.324]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.324]                     }, error = function(ex) {
[16:03:14.324]                       msg <- conditionMessage(ex)
[16:03:14.324]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.324]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.324]                         fi_tmp[["mtime"]], msg)
[16:03:14.324]                       ex$message <- msg
[16:03:14.324]                       stop(ex)
[16:03:14.324]                     })
[16:03:14.324]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.324]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.324]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.324]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.324]                       fi <- file.info(pathname)
[16:03:14.324]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.324]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.324]                         fi[["size"]], fi[["mtime"]])
[16:03:14.324]                       stop(msg)
[16:03:14.324]                     }
[16:03:14.324]                     invisible(pathname)
[16:03:14.324]                   }
[16:03:14.324]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.324]                     rootPath = tempdir()) 
[16:03:14.324]                   {
[16:03:14.324]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.324]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.324]                       tmpdir = path, fileext = ".rds")
[16:03:14.324]                     save_rds(obj, file)
[16:03:14.324]                   }
[16:03:14.324]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.324]                   {
[16:03:14.324]                     inherits <- base::inherits
[16:03:14.324]                     invokeRestart <- base::invokeRestart
[16:03:14.324]                     is.null <- base::is.null
[16:03:14.324]                     muffled <- FALSE
[16:03:14.324]                     if (inherits(cond, "message")) {
[16:03:14.324]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.324]                       if (muffled) 
[16:03:14.324]                         invokeRestart("muffleMessage")
[16:03:14.324]                     }
[16:03:14.324]                     else if (inherits(cond, "warning")) {
[16:03:14.324]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.324]                       if (muffled) 
[16:03:14.324]                         invokeRestart("muffleWarning")
[16:03:14.324]                     }
[16:03:14.324]                     else if (inherits(cond, "condition")) {
[16:03:14.324]                       if (!is.null(pattern)) {
[16:03:14.324]                         computeRestarts <- base::computeRestarts
[16:03:14.324]                         grepl <- base::grepl
[16:03:14.324]                         restarts <- computeRestarts(cond)
[16:03:14.324]                         for (restart in restarts) {
[16:03:14.324]                           name <- restart$name
[16:03:14.324]                           if (is.null(name)) 
[16:03:14.324]                             next
[16:03:14.324]                           if (!grepl(pattern, name)) 
[16:03:14.324]                             next
[16:03:14.324]                           invokeRestart(restart)
[16:03:14.324]                           muffled <- TRUE
[16:03:14.324]                           break
[16:03:14.324]                         }
[16:03:14.324]                       }
[16:03:14.324]                     }
[16:03:14.324]                     invisible(muffled)
[16:03:14.324]                   }
[16:03:14.324]                   muffleCondition(cond)
[16:03:14.324]                 })
[16:03:14.324]             }))
[16:03:14.324]             future::FutureResult(value = ...future.value$value, 
[16:03:14.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.324]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.324]                     ...future.globalenv.names))
[16:03:14.324]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.324]         }, condition = base::local({
[16:03:14.324]             c <- base::c
[16:03:14.324]             inherits <- base::inherits
[16:03:14.324]             invokeRestart <- base::invokeRestart
[16:03:14.324]             length <- base::length
[16:03:14.324]             list <- base::list
[16:03:14.324]             seq.int <- base::seq.int
[16:03:14.324]             signalCondition <- base::signalCondition
[16:03:14.324]             sys.calls <- base::sys.calls
[16:03:14.324]             `[[` <- base::`[[`
[16:03:14.324]             `+` <- base::`+`
[16:03:14.324]             `<<-` <- base::`<<-`
[16:03:14.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.324]                   3L)]
[16:03:14.324]             }
[16:03:14.324]             function(cond) {
[16:03:14.324]                 is_error <- inherits(cond, "error")
[16:03:14.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.324]                   NULL)
[16:03:14.324]                 if (is_error) {
[16:03:14.324]                   sessionInformation <- function() {
[16:03:14.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.324]                       search = base::search(), system = base::Sys.info())
[16:03:14.324]                   }
[16:03:14.324]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.324]                     cond$call), session = sessionInformation(), 
[16:03:14.324]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.324]                   signalCondition(cond)
[16:03:14.324]                 }
[16:03:14.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.324]                 "immediateCondition"))) {
[16:03:14.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.324]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.324]                   if (TRUE && !signal) {
[16:03:14.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.324]                     {
[16:03:14.324]                       inherits <- base::inherits
[16:03:14.324]                       invokeRestart <- base::invokeRestart
[16:03:14.324]                       is.null <- base::is.null
[16:03:14.324]                       muffled <- FALSE
[16:03:14.324]                       if (inherits(cond, "message")) {
[16:03:14.324]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.324]                         if (muffled) 
[16:03:14.324]                           invokeRestart("muffleMessage")
[16:03:14.324]                       }
[16:03:14.324]                       else if (inherits(cond, "warning")) {
[16:03:14.324]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.324]                         if (muffled) 
[16:03:14.324]                           invokeRestart("muffleWarning")
[16:03:14.324]                       }
[16:03:14.324]                       else if (inherits(cond, "condition")) {
[16:03:14.324]                         if (!is.null(pattern)) {
[16:03:14.324]                           computeRestarts <- base::computeRestarts
[16:03:14.324]                           grepl <- base::grepl
[16:03:14.324]                           restarts <- computeRestarts(cond)
[16:03:14.324]                           for (restart in restarts) {
[16:03:14.324]                             name <- restart$name
[16:03:14.324]                             if (is.null(name)) 
[16:03:14.324]                               next
[16:03:14.324]                             if (!grepl(pattern, name)) 
[16:03:14.324]                               next
[16:03:14.324]                             invokeRestart(restart)
[16:03:14.324]                             muffled <- TRUE
[16:03:14.324]                             break
[16:03:14.324]                           }
[16:03:14.324]                         }
[16:03:14.324]                       }
[16:03:14.324]                       invisible(muffled)
[16:03:14.324]                     }
[16:03:14.324]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.324]                   }
[16:03:14.324]                 }
[16:03:14.324]                 else {
[16:03:14.324]                   if (TRUE) {
[16:03:14.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.324]                     {
[16:03:14.324]                       inherits <- base::inherits
[16:03:14.324]                       invokeRestart <- base::invokeRestart
[16:03:14.324]                       is.null <- base::is.null
[16:03:14.324]                       muffled <- FALSE
[16:03:14.324]                       if (inherits(cond, "message")) {
[16:03:14.324]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.324]                         if (muffled) 
[16:03:14.324]                           invokeRestart("muffleMessage")
[16:03:14.324]                       }
[16:03:14.324]                       else if (inherits(cond, "warning")) {
[16:03:14.324]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.324]                         if (muffled) 
[16:03:14.324]                           invokeRestart("muffleWarning")
[16:03:14.324]                       }
[16:03:14.324]                       else if (inherits(cond, "condition")) {
[16:03:14.324]                         if (!is.null(pattern)) {
[16:03:14.324]                           computeRestarts <- base::computeRestarts
[16:03:14.324]                           grepl <- base::grepl
[16:03:14.324]                           restarts <- computeRestarts(cond)
[16:03:14.324]                           for (restart in restarts) {
[16:03:14.324]                             name <- restart$name
[16:03:14.324]                             if (is.null(name)) 
[16:03:14.324]                               next
[16:03:14.324]                             if (!grepl(pattern, name)) 
[16:03:14.324]                               next
[16:03:14.324]                             invokeRestart(restart)
[16:03:14.324]                             muffled <- TRUE
[16:03:14.324]                             break
[16:03:14.324]                           }
[16:03:14.324]                         }
[16:03:14.324]                       }
[16:03:14.324]                       invisible(muffled)
[16:03:14.324]                     }
[16:03:14.324]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.324]                   }
[16:03:14.324]                 }
[16:03:14.324]             }
[16:03:14.324]         }))
[16:03:14.324]     }, error = function(ex) {
[16:03:14.324]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.324]                 ...future.rng), started = ...future.startTime, 
[16:03:14.324]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.324]             version = "1.8"), class = "FutureResult")
[16:03:14.324]     }, finally = {
[16:03:14.324]         if (!identical(...future.workdir, getwd())) 
[16:03:14.324]             setwd(...future.workdir)
[16:03:14.324]         {
[16:03:14.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.324]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.324]             }
[16:03:14.324]             base::options(...future.oldOptions)
[16:03:14.324]             if (.Platform$OS.type == "windows") {
[16:03:14.324]                 old_names <- names(...future.oldEnvVars)
[16:03:14.324]                 envs <- base::Sys.getenv()
[16:03:14.324]                 names <- names(envs)
[16:03:14.324]                 common <- intersect(names, old_names)
[16:03:14.324]                 added <- setdiff(names, old_names)
[16:03:14.324]                 removed <- setdiff(old_names, names)
[16:03:14.324]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.324]                   envs[common]]
[16:03:14.324]                 NAMES <- toupper(changed)
[16:03:14.324]                 args <- list()
[16:03:14.324]                 for (kk in seq_along(NAMES)) {
[16:03:14.324]                   name <- changed[[kk]]
[16:03:14.324]                   NAME <- NAMES[[kk]]
[16:03:14.324]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.324]                     next
[16:03:14.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.324]                 }
[16:03:14.324]                 NAMES <- toupper(added)
[16:03:14.324]                 for (kk in seq_along(NAMES)) {
[16:03:14.324]                   name <- added[[kk]]
[16:03:14.324]                   NAME <- NAMES[[kk]]
[16:03:14.324]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.324]                     next
[16:03:14.324]                   args[[name]] <- ""
[16:03:14.324]                 }
[16:03:14.324]                 NAMES <- toupper(removed)
[16:03:14.324]                 for (kk in seq_along(NAMES)) {
[16:03:14.324]                   name <- removed[[kk]]
[16:03:14.324]                   NAME <- NAMES[[kk]]
[16:03:14.324]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.324]                     next
[16:03:14.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.324]                 }
[16:03:14.324]                 if (length(args) > 0) 
[16:03:14.324]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.324]             }
[16:03:14.324]             else {
[16:03:14.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.324]             }
[16:03:14.324]             {
[16:03:14.324]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.324]                   0L) {
[16:03:14.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.324]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.324]                   base::options(opts)
[16:03:14.324]                 }
[16:03:14.324]                 {
[16:03:14.324]                   {
[16:03:14.324]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.324]                     NULL
[16:03:14.324]                   }
[16:03:14.324]                   options(future.plan = NULL)
[16:03:14.324]                   if (is.na(NA_character_)) 
[16:03:14.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.324]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.324]                     envir = parent.frame()) 
[16:03:14.324]                   {
[16:03:14.324]                     default_workers <- missing(workers)
[16:03:14.324]                     if (is.function(workers)) 
[16:03:14.324]                       workers <- workers()
[16:03:14.324]                     workers <- structure(as.integer(workers), 
[16:03:14.324]                       class = class(workers))
[16:03:14.324]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.324]                       1L)
[16:03:14.324]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.324]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.324]                       if (default_workers) 
[16:03:14.324]                         supportsMulticore(warn = TRUE)
[16:03:14.324]                       return(sequential(..., envir = envir))
[16:03:14.324]                     }
[16:03:14.324]                     oopts <- options(mc.cores = workers)
[16:03:14.324]                     on.exit(options(oopts))
[16:03:14.324]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.324]                       envir = envir)
[16:03:14.324]                     if (!future$lazy) 
[16:03:14.324]                       future <- run(future)
[16:03:14.324]                     invisible(future)
[16:03:14.324]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.324]                 }
[16:03:14.324]             }
[16:03:14.324]         }
[16:03:14.324]     })
[16:03:14.324]     if (TRUE) {
[16:03:14.324]         base::sink(type = "output", split = FALSE)
[16:03:14.324]         if (TRUE) {
[16:03:14.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.324]         }
[16:03:14.324]         else {
[16:03:14.324]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.324]         }
[16:03:14.324]         base::close(...future.stdout)
[16:03:14.324]         ...future.stdout <- NULL
[16:03:14.324]     }
[16:03:14.324]     ...future.result$conditions <- ...future.conditions
[16:03:14.324]     ...future.result$finished <- base::Sys.time()
[16:03:14.324]     ...future.result
[16:03:14.324] }
[16:03:14.327] assign_globals() ...
[16:03:14.327] List of 11
[16:03:14.327]  $ ...future.FUN            :function (x, ...)  
[16:03:14.327]  $ x_FUN                    :function (x, ...)  
[16:03:14.327]  $ times                    : int 5
[16:03:14.327]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.327]  $ stop_if_not              :function (...)  
[16:03:14.327]  $ dim                      : NULL
[16:03:14.327]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:14.327]  $ future.call.arguments    : list()
[16:03:14.327]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.327]  $ ...future.elements_ii    :List of 1
[16:03:14.327]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:03:14.327]  $ ...future.seeds_ii       : NULL
[16:03:14.327]  $ ...future.globals.maxSize: NULL
[16:03:14.327]  - attr(*, "where")=List of 11
[16:03:14.327]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.327]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:14.327]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:14.327]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:14.327]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:14.327]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:14.327]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:14.327]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.327]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.327]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.327]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.327]  - attr(*, "resolved")= logi FALSE
[16:03:14.327]  - attr(*, "total_size")= num 95528
[16:03:14.327]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.327]  - attr(*, "already-done")= logi TRUE
[16:03:14.337] - copied ‘...future.FUN’ to environment
[16:03:14.337] - copied ‘x_FUN’ to environment
[16:03:14.337] - copied ‘times’ to environment
[16:03:14.337] - copied ‘stopf’ to environment
[16:03:14.337] - copied ‘stop_if_not’ to environment
[16:03:14.337] - copied ‘dim’ to environment
[16:03:14.337] - copied ‘valid_types’ to environment
[16:03:14.337] - copied ‘future.call.arguments’ to environment
[16:03:14.337] - copied ‘...future.elements_ii’ to environment
[16:03:14.338] - copied ‘...future.seeds_ii’ to environment
[16:03:14.338] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.338] assign_globals() ... done
[16:03:14.338] requestCore(): workers = 2
[16:03:14.340] MulticoreFuture started
[16:03:14.341] - Launch lazy future ... done
[16:03:14.341] run() for ‘MulticoreFuture’ ... done
[16:03:14.341] Created future:
[16:03:14.342] plan(): Setting new future strategy stack:
[16:03:14.342] List of future strategies:
[16:03:14.342] 1. sequential:
[16:03:14.342]    - args: function (..., envir = parent.frame())
[16:03:14.342]    - tweaked: FALSE
[16:03:14.342]    - call: NULL
[16:03:14.343] plan(): nbrOfWorkers() = 1
[16:03:14.345] plan(): Setting new future strategy stack:
[16:03:14.346] List of future strategies:
[16:03:14.346] 1. multicore:
[16:03:14.346]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.346]    - tweaked: FALSE
[16:03:14.346]    - call: plan(strategy)
[16:03:14.351] plan(): nbrOfWorkers() = 2
[16:03:14.341] MulticoreFuture:
[16:03:14.341] Label: ‘future_vapply-1’
[16:03:14.341] Expression:
[16:03:14.341] {
[16:03:14.341]     do.call(function(...) {
[16:03:14.341]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.341]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.341]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.341]             on.exit(options(oopts), add = TRUE)
[16:03:14.341]         }
[16:03:14.341]         {
[16:03:14.341]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.341]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.341]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.341]             })
[16:03:14.341]         }
[16:03:14.341]     }, args = future.call.arguments)
[16:03:14.341] }
[16:03:14.341] Lazy evaluation: FALSE
[16:03:14.341] Asynchronous evaluation: TRUE
[16:03:14.341] Local evaluation: TRUE
[16:03:14.341] Environment: R_GlobalEnv
[16:03:14.341] Capture standard output: TRUE
[16:03:14.341] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.341] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:14.341] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:03:14.341] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.341] Resolved: TRUE
[16:03:14.341] Value: <not collected>
[16:03:14.341] Conditions captured: <none>
[16:03:14.341] Early signaling: FALSE
[16:03:14.341] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.341] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.352] Chunk #1 of 2 ... DONE
[16:03:14.352] Chunk #2 of 2 ...
[16:03:14.352]  - Finding globals in 'X' for chunk #2 ...
[16:03:14.352] getGlobalsAndPackages() ...
[16:03:14.353] Searching for globals...
[16:03:14.353] 
[16:03:14.353] Searching for globals ... DONE
[16:03:14.353] - globals: [0] <none>
[16:03:14.353] getGlobalsAndPackages() ... DONE
[16:03:14.354]    + additional globals found: [n=0] 
[16:03:14.354]    + additional namespaces needed: [n=0] 
[16:03:14.354]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:14.354]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.354]  - seeds: <none>
[16:03:14.354]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.354] getGlobalsAndPackages() ...
[16:03:14.355] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.355] Resolving globals: FALSE
[16:03:14.355] Tweak future expression to call with '...' arguments ...
[16:03:14.355] {
[16:03:14.355]     do.call(function(...) {
[16:03:14.355]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.355]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.355]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.355]             on.exit(options(oopts), add = TRUE)
[16:03:14.355]         }
[16:03:14.355]         {
[16:03:14.355]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.355]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.355]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.355]             })
[16:03:14.355]         }
[16:03:14.355]     }, args = future.call.arguments)
[16:03:14.355] }
[16:03:14.356] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.357] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.357] - packages: [2] ‘stats’, ‘future.apply’
[16:03:14.357] getGlobalsAndPackages() ... DONE
[16:03:14.357] run() for ‘Future’ ...
[16:03:14.358] - state: ‘created’
[16:03:14.358] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.362] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.363]   - Field: ‘label’
[16:03:14.363]   - Field: ‘local’
[16:03:14.363]   - Field: ‘owner’
[16:03:14.363]   - Field: ‘envir’
[16:03:14.363]   - Field: ‘workers’
[16:03:14.364]   - Field: ‘packages’
[16:03:14.364]   - Field: ‘gc’
[16:03:14.364]   - Field: ‘job’
[16:03:14.364]   - Field: ‘conditions’
[16:03:14.364]   - Field: ‘expr’
[16:03:14.364]   - Field: ‘uuid’
[16:03:14.364]   - Field: ‘seed’
[16:03:14.365]   - Field: ‘version’
[16:03:14.365]   - Field: ‘result’
[16:03:14.365]   - Field: ‘asynchronous’
[16:03:14.365]   - Field: ‘calls’
[16:03:14.365]   - Field: ‘globals’
[16:03:14.365]   - Field: ‘stdout’
[16:03:14.365]   - Field: ‘earlySignal’
[16:03:14.368]   - Field: ‘lazy’
[16:03:14.368]   - Field: ‘state’
[16:03:14.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.369] - Launch lazy future ...
[16:03:14.370] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:03:14.370] Packages needed by future strategies (n = 0): <none>
[16:03:14.371] {
[16:03:14.371]     {
[16:03:14.371]         {
[16:03:14.371]             ...future.startTime <- base::Sys.time()
[16:03:14.371]             {
[16:03:14.371]                 {
[16:03:14.371]                   {
[16:03:14.371]                     {
[16:03:14.371]                       {
[16:03:14.371]                         base::local({
[16:03:14.371]                           has_future <- base::requireNamespace("future", 
[16:03:14.371]                             quietly = TRUE)
[16:03:14.371]                           if (has_future) {
[16:03:14.371]                             ns <- base::getNamespace("future")
[16:03:14.371]                             version <- ns[[".package"]][["version"]]
[16:03:14.371]                             if (is.null(version)) 
[16:03:14.371]                               version <- utils::packageVersion("future")
[16:03:14.371]                           }
[16:03:14.371]                           else {
[16:03:14.371]                             version <- NULL
[16:03:14.371]                           }
[16:03:14.371]                           if (!has_future || version < "1.8.0") {
[16:03:14.371]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.371]                               "", base::R.version$version.string), 
[16:03:14.371]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.371]                                 base::R.version$platform, 8 * 
[16:03:14.371]                                   base::.Machine$sizeof.pointer), 
[16:03:14.371]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.371]                                 "release", "version")], collapse = " "), 
[16:03:14.371]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.371]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.371]                               info)
[16:03:14.371]                             info <- base::paste(info, collapse = "; ")
[16:03:14.371]                             if (!has_future) {
[16:03:14.371]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.371]                                 info)
[16:03:14.371]                             }
[16:03:14.371]                             else {
[16:03:14.371]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.371]                                 info, version)
[16:03:14.371]                             }
[16:03:14.371]                             base::stop(msg)
[16:03:14.371]                           }
[16:03:14.371]                         })
[16:03:14.371]                       }
[16:03:14.371]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.371]                       base::options(mc.cores = 1L)
[16:03:14.371]                     }
[16:03:14.371]                     base::local({
[16:03:14.371]                       for (pkg in c("stats", "future.apply")) {
[16:03:14.371]                         base::loadNamespace(pkg)
[16:03:14.371]                         base::library(pkg, character.only = TRUE)
[16:03:14.371]                       }
[16:03:14.371]                     })
[16:03:14.371]                   }
[16:03:14.371]                   options(future.plan = NULL)
[16:03:14.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.371]                 }
[16:03:14.371]                 ...future.workdir <- getwd()
[16:03:14.371]             }
[16:03:14.371]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.371]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.371]         }
[16:03:14.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.371]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.371]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.371]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.371]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.371]             base::names(...future.oldOptions))
[16:03:14.371]     }
[16:03:14.371]     if (FALSE) {
[16:03:14.371]     }
[16:03:14.371]     else {
[16:03:14.371]         if (TRUE) {
[16:03:14.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.371]                 open = "w")
[16:03:14.371]         }
[16:03:14.371]         else {
[16:03:14.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.371]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.371]         }
[16:03:14.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.371]             base::sink(type = "output", split = FALSE)
[16:03:14.371]             base::close(...future.stdout)
[16:03:14.371]         }, add = TRUE)
[16:03:14.371]     }
[16:03:14.371]     ...future.frame <- base::sys.nframe()
[16:03:14.371]     ...future.conditions <- base::list()
[16:03:14.371]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.371]     if (FALSE) {
[16:03:14.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.371]     }
[16:03:14.371]     ...future.result <- base::tryCatch({
[16:03:14.371]         base::withCallingHandlers({
[16:03:14.371]             ...future.value <- base::withVisible(base::local({
[16:03:14.371]                 withCallingHandlers({
[16:03:14.371]                   {
[16:03:14.371]                     do.call(function(...) {
[16:03:14.371]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.371]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.371]                         ...future.globals.maxSize)) {
[16:03:14.371]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.371]                         on.exit(options(oopts), add = TRUE)
[16:03:14.371]                       }
[16:03:14.371]                       {
[16:03:14.371]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.371]                           FUN = function(jj) {
[16:03:14.371]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.371]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.371]                           })
[16:03:14.371]                       }
[16:03:14.371]                     }, args = future.call.arguments)
[16:03:14.371]                   }
[16:03:14.371]                 }, immediateCondition = function(cond) {
[16:03:14.371]                   save_rds <- function (object, pathname, ...) 
[16:03:14.371]                   {
[16:03:14.371]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.371]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.371]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.371]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.371]                         fi_tmp[["mtime"]])
[16:03:14.371]                     }
[16:03:14.371]                     tryCatch({
[16:03:14.371]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.371]                     }, error = function(ex) {
[16:03:14.371]                       msg <- conditionMessage(ex)
[16:03:14.371]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.371]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.371]                         fi_tmp[["mtime"]], msg)
[16:03:14.371]                       ex$message <- msg
[16:03:14.371]                       stop(ex)
[16:03:14.371]                     })
[16:03:14.371]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.371]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.371]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.371]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.371]                       fi <- file.info(pathname)
[16:03:14.371]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.371]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.371]                         fi[["size"]], fi[["mtime"]])
[16:03:14.371]                       stop(msg)
[16:03:14.371]                     }
[16:03:14.371]                     invisible(pathname)
[16:03:14.371]                   }
[16:03:14.371]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.371]                     rootPath = tempdir()) 
[16:03:14.371]                   {
[16:03:14.371]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.371]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.371]                       tmpdir = path, fileext = ".rds")
[16:03:14.371]                     save_rds(obj, file)
[16:03:14.371]                   }
[16:03:14.371]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.371]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.371]                   {
[16:03:14.371]                     inherits <- base::inherits
[16:03:14.371]                     invokeRestart <- base::invokeRestart
[16:03:14.371]                     is.null <- base::is.null
[16:03:14.371]                     muffled <- FALSE
[16:03:14.371]                     if (inherits(cond, "message")) {
[16:03:14.371]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.371]                       if (muffled) 
[16:03:14.371]                         invokeRestart("muffleMessage")
[16:03:14.371]                     }
[16:03:14.371]                     else if (inherits(cond, "warning")) {
[16:03:14.371]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.371]                       if (muffled) 
[16:03:14.371]                         invokeRestart("muffleWarning")
[16:03:14.371]                     }
[16:03:14.371]                     else if (inherits(cond, "condition")) {
[16:03:14.371]                       if (!is.null(pattern)) {
[16:03:14.371]                         computeRestarts <- base::computeRestarts
[16:03:14.371]                         grepl <- base::grepl
[16:03:14.371]                         restarts <- computeRestarts(cond)
[16:03:14.371]                         for (restart in restarts) {
[16:03:14.371]                           name <- restart$name
[16:03:14.371]                           if (is.null(name)) 
[16:03:14.371]                             next
[16:03:14.371]                           if (!grepl(pattern, name)) 
[16:03:14.371]                             next
[16:03:14.371]                           invokeRestart(restart)
[16:03:14.371]                           muffled <- TRUE
[16:03:14.371]                           break
[16:03:14.371]                         }
[16:03:14.371]                       }
[16:03:14.371]                     }
[16:03:14.371]                     invisible(muffled)
[16:03:14.371]                   }
[16:03:14.371]                   muffleCondition(cond)
[16:03:14.371]                 })
[16:03:14.371]             }))
[16:03:14.371]             future::FutureResult(value = ...future.value$value, 
[16:03:14.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.371]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.371]                     ...future.globalenv.names))
[16:03:14.371]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.371]         }, condition = base::local({
[16:03:14.371]             c <- base::c
[16:03:14.371]             inherits <- base::inherits
[16:03:14.371]             invokeRestart <- base::invokeRestart
[16:03:14.371]             length <- base::length
[16:03:14.371]             list <- base::list
[16:03:14.371]             seq.int <- base::seq.int
[16:03:14.371]             signalCondition <- base::signalCondition
[16:03:14.371]             sys.calls <- base::sys.calls
[16:03:14.371]             `[[` <- base::`[[`
[16:03:14.371]             `+` <- base::`+`
[16:03:14.371]             `<<-` <- base::`<<-`
[16:03:14.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.371]                   3L)]
[16:03:14.371]             }
[16:03:14.371]             function(cond) {
[16:03:14.371]                 is_error <- inherits(cond, "error")
[16:03:14.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.371]                   NULL)
[16:03:14.371]                 if (is_error) {
[16:03:14.371]                   sessionInformation <- function() {
[16:03:14.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.371]                       search = base::search(), system = base::Sys.info())
[16:03:14.371]                   }
[16:03:14.371]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.371]                     cond$call), session = sessionInformation(), 
[16:03:14.371]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.371]                   signalCondition(cond)
[16:03:14.371]                 }
[16:03:14.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.371]                 "immediateCondition"))) {
[16:03:14.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.371]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.371]                   if (TRUE && !signal) {
[16:03:14.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.371]                     {
[16:03:14.371]                       inherits <- base::inherits
[16:03:14.371]                       invokeRestart <- base::invokeRestart
[16:03:14.371]                       is.null <- base::is.null
[16:03:14.371]                       muffled <- FALSE
[16:03:14.371]                       if (inherits(cond, "message")) {
[16:03:14.371]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.371]                         if (muffled) 
[16:03:14.371]                           invokeRestart("muffleMessage")
[16:03:14.371]                       }
[16:03:14.371]                       else if (inherits(cond, "warning")) {
[16:03:14.371]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.371]                         if (muffled) 
[16:03:14.371]                           invokeRestart("muffleWarning")
[16:03:14.371]                       }
[16:03:14.371]                       else if (inherits(cond, "condition")) {
[16:03:14.371]                         if (!is.null(pattern)) {
[16:03:14.371]                           computeRestarts <- base::computeRestarts
[16:03:14.371]                           grepl <- base::grepl
[16:03:14.371]                           restarts <- computeRestarts(cond)
[16:03:14.371]                           for (restart in restarts) {
[16:03:14.371]                             name <- restart$name
[16:03:14.371]                             if (is.null(name)) 
[16:03:14.371]                               next
[16:03:14.371]                             if (!grepl(pattern, name)) 
[16:03:14.371]                               next
[16:03:14.371]                             invokeRestart(restart)
[16:03:14.371]                             muffled <- TRUE
[16:03:14.371]                             break
[16:03:14.371]                           }
[16:03:14.371]                         }
[16:03:14.371]                       }
[16:03:14.371]                       invisible(muffled)
[16:03:14.371]                     }
[16:03:14.371]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.371]                   }
[16:03:14.371]                 }
[16:03:14.371]                 else {
[16:03:14.371]                   if (TRUE) {
[16:03:14.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.371]                     {
[16:03:14.371]                       inherits <- base::inherits
[16:03:14.371]                       invokeRestart <- base::invokeRestart
[16:03:14.371]                       is.null <- base::is.null
[16:03:14.371]                       muffled <- FALSE
[16:03:14.371]                       if (inherits(cond, "message")) {
[16:03:14.371]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.371]                         if (muffled) 
[16:03:14.371]                           invokeRestart("muffleMessage")
[16:03:14.371]                       }
[16:03:14.371]                       else if (inherits(cond, "warning")) {
[16:03:14.371]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.371]                         if (muffled) 
[16:03:14.371]                           invokeRestart("muffleWarning")
[16:03:14.371]                       }
[16:03:14.371]                       else if (inherits(cond, "condition")) {
[16:03:14.371]                         if (!is.null(pattern)) {
[16:03:14.371]                           computeRestarts <- base::computeRestarts
[16:03:14.371]                           grepl <- base::grepl
[16:03:14.371]                           restarts <- computeRestarts(cond)
[16:03:14.371]                           for (restart in restarts) {
[16:03:14.371]                             name <- restart$name
[16:03:14.371]                             if (is.null(name)) 
[16:03:14.371]                               next
[16:03:14.371]                             if (!grepl(pattern, name)) 
[16:03:14.371]                               next
[16:03:14.371]                             invokeRestart(restart)
[16:03:14.371]                             muffled <- TRUE
[16:03:14.371]                             break
[16:03:14.371]                           }
[16:03:14.371]                         }
[16:03:14.371]                       }
[16:03:14.371]                       invisible(muffled)
[16:03:14.371]                     }
[16:03:14.371]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.371]                   }
[16:03:14.371]                 }
[16:03:14.371]             }
[16:03:14.371]         }))
[16:03:14.371]     }, error = function(ex) {
[16:03:14.371]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.371]                 ...future.rng), started = ...future.startTime, 
[16:03:14.371]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.371]             version = "1.8"), class = "FutureResult")
[16:03:14.371]     }, finally = {
[16:03:14.371]         if (!identical(...future.workdir, getwd())) 
[16:03:14.371]             setwd(...future.workdir)
[16:03:14.371]         {
[16:03:14.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.371]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.371]             }
[16:03:14.371]             base::options(...future.oldOptions)
[16:03:14.371]             if (.Platform$OS.type == "windows") {
[16:03:14.371]                 old_names <- names(...future.oldEnvVars)
[16:03:14.371]                 envs <- base::Sys.getenv()
[16:03:14.371]                 names <- names(envs)
[16:03:14.371]                 common <- intersect(names, old_names)
[16:03:14.371]                 added <- setdiff(names, old_names)
[16:03:14.371]                 removed <- setdiff(old_names, names)
[16:03:14.371]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.371]                   envs[common]]
[16:03:14.371]                 NAMES <- toupper(changed)
[16:03:14.371]                 args <- list()
[16:03:14.371]                 for (kk in seq_along(NAMES)) {
[16:03:14.371]                   name <- changed[[kk]]
[16:03:14.371]                   NAME <- NAMES[[kk]]
[16:03:14.371]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.371]                     next
[16:03:14.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.371]                 }
[16:03:14.371]                 NAMES <- toupper(added)
[16:03:14.371]                 for (kk in seq_along(NAMES)) {
[16:03:14.371]                   name <- added[[kk]]
[16:03:14.371]                   NAME <- NAMES[[kk]]
[16:03:14.371]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.371]                     next
[16:03:14.371]                   args[[name]] <- ""
[16:03:14.371]                 }
[16:03:14.371]                 NAMES <- toupper(removed)
[16:03:14.371]                 for (kk in seq_along(NAMES)) {
[16:03:14.371]                   name <- removed[[kk]]
[16:03:14.371]                   NAME <- NAMES[[kk]]
[16:03:14.371]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.371]                     next
[16:03:14.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.371]                 }
[16:03:14.371]                 if (length(args) > 0) 
[16:03:14.371]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.371]             }
[16:03:14.371]             else {
[16:03:14.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.371]             }
[16:03:14.371]             {
[16:03:14.371]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.371]                   0L) {
[16:03:14.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.371]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.371]                   base::options(opts)
[16:03:14.371]                 }
[16:03:14.371]                 {
[16:03:14.371]                   {
[16:03:14.371]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.371]                     NULL
[16:03:14.371]                   }
[16:03:14.371]                   options(future.plan = NULL)
[16:03:14.371]                   if (is.na(NA_character_)) 
[16:03:14.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.371]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.371]                     envir = parent.frame()) 
[16:03:14.371]                   {
[16:03:14.371]                     default_workers <- missing(workers)
[16:03:14.371]                     if (is.function(workers)) 
[16:03:14.371]                       workers <- workers()
[16:03:14.371]                     workers <- structure(as.integer(workers), 
[16:03:14.371]                       class = class(workers))
[16:03:14.371]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.371]                       1L)
[16:03:14.371]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.371]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.371]                       if (default_workers) 
[16:03:14.371]                         supportsMulticore(warn = TRUE)
[16:03:14.371]                       return(sequential(..., envir = envir))
[16:03:14.371]                     }
[16:03:14.371]                     oopts <- options(mc.cores = workers)
[16:03:14.371]                     on.exit(options(oopts))
[16:03:14.371]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.371]                       envir = envir)
[16:03:14.371]                     if (!future$lazy) 
[16:03:14.371]                       future <- run(future)
[16:03:14.371]                     invisible(future)
[16:03:14.371]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.371]                 }
[16:03:14.371]             }
[16:03:14.371]         }
[16:03:14.371]     })
[16:03:14.371]     if (TRUE) {
[16:03:14.371]         base::sink(type = "output", split = FALSE)
[16:03:14.371]         if (TRUE) {
[16:03:14.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.371]         }
[16:03:14.371]         else {
[16:03:14.371]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.371]         }
[16:03:14.371]         base::close(...future.stdout)
[16:03:14.371]         ...future.stdout <- NULL
[16:03:14.371]     }
[16:03:14.371]     ...future.result$conditions <- ...future.conditions
[16:03:14.371]     ...future.result$finished <- base::Sys.time()
[16:03:14.371]     ...future.result
[16:03:14.371] }
[16:03:14.375] assign_globals() ...
[16:03:14.375] List of 11
[16:03:14.375]  $ ...future.FUN            :function (x, ...)  
[16:03:14.375]  $ x_FUN                    :function (x, ...)  
[16:03:14.375]  $ times                    : int 5
[16:03:14.375]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.375]  $ stop_if_not              :function (...)  
[16:03:14.375]  $ dim                      : NULL
[16:03:14.375]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:14.375]  $ future.call.arguments    : list()
[16:03:14.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.375]  $ ...future.elements_ii    :List of 2
[16:03:14.375]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:03:14.375]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:03:14.375]  $ ...future.seeds_ii       : NULL
[16:03:14.375]  $ ...future.globals.maxSize: NULL
[16:03:14.375]  - attr(*, "where")=List of 11
[16:03:14.375]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.375]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:14.375]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:14.375]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:14.375]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:14.375]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:14.375]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:14.375]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.375]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.375]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.375]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.375]  - attr(*, "resolved")= logi FALSE
[16:03:14.375]  - attr(*, "total_size")= num 95528
[16:03:14.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.375]  - attr(*, "already-done")= logi TRUE
[16:03:14.388] - copied ‘...future.FUN’ to environment
[16:03:14.388] - copied ‘x_FUN’ to environment
[16:03:14.388] - copied ‘times’ to environment
[16:03:14.388] - copied ‘stopf’ to environment
[16:03:14.388] - copied ‘stop_if_not’ to environment
[16:03:14.388] - copied ‘dim’ to environment
[16:03:14.388] - copied ‘valid_types’ to environment
[16:03:14.389] - copied ‘future.call.arguments’ to environment
[16:03:14.389] - copied ‘...future.elements_ii’ to environment
[16:03:14.389] - copied ‘...future.seeds_ii’ to environment
[16:03:14.389] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.389] assign_globals() ... done
[16:03:14.389] requestCore(): workers = 2
[16:03:14.391] MulticoreFuture started
[16:03:14.392] - Launch lazy future ... done
[16:03:14.392] run() for ‘MulticoreFuture’ ... done
[16:03:14.392] Created future:
[16:03:14.393] plan(): Setting new future strategy stack:
[16:03:14.393] List of future strategies:
[16:03:14.393] 1. sequential:
[16:03:14.393]    - args: function (..., envir = parent.frame())
[16:03:14.393]    - tweaked: FALSE
[16:03:14.393]    - call: NULL
[16:03:14.394] plan(): nbrOfWorkers() = 1
[16:03:14.397] plan(): Setting new future strategy stack:
[16:03:14.397] List of future strategies:
[16:03:14.397] 1. multicore:
[16:03:14.397]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.397]    - tweaked: FALSE
[16:03:14.397]    - call: plan(strategy)
[16:03:14.402] plan(): nbrOfWorkers() = 2
[16:03:14.392] MulticoreFuture:
[16:03:14.392] Label: ‘future_vapply-2’
[16:03:14.392] Expression:
[16:03:14.392] {
[16:03:14.392]     do.call(function(...) {
[16:03:14.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.392]             on.exit(options(oopts), add = TRUE)
[16:03:14.392]         }
[16:03:14.392]         {
[16:03:14.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.392]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.392]             })
[16:03:14.392]         }
[16:03:14.392]     }, args = future.call.arguments)
[16:03:14.392] }
[16:03:14.392] Lazy evaluation: FALSE
[16:03:14.392] Asynchronous evaluation: TRUE
[16:03:14.392] Local evaluation: TRUE
[16:03:14.392] Environment: R_GlobalEnv
[16:03:14.392] Capture standard output: TRUE
[16:03:14.392] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.392] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:14.392] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:03:14.392] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.392] Resolved: TRUE
[16:03:14.392] Value: <not collected>
[16:03:14.392] Conditions captured: <none>
[16:03:14.392] Early signaling: FALSE
[16:03:14.392] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.392] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.403] Chunk #2 of 2 ... DONE
[16:03:14.403] Launching 2 futures (chunks) ... DONE
[16:03:14.403] Resolving 2 futures (chunks) ...
[16:03:14.404] resolve() on list ...
[16:03:14.404]  recursive: 0
[16:03:14.404]  length: 2
[16:03:14.404] 
[16:03:14.404] Future #1
[16:03:14.405] result() for MulticoreFuture ...
[16:03:14.405] result() for MulticoreFuture ...
[16:03:14.406] result() for MulticoreFuture ... done
[16:03:14.406] result() for MulticoreFuture ... done
[16:03:14.406] result() for MulticoreFuture ...
[16:03:14.406] result() for MulticoreFuture ... done
[16:03:14.406] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:14.406] - nx: 2
[16:03:14.406] - relay: TRUE
[16:03:14.407] - stdout: TRUE
[16:03:14.407] - signal: TRUE
[16:03:14.407] - resignal: FALSE
[16:03:14.407] - force: TRUE
[16:03:14.407] - relayed: [n=2] FALSE, FALSE
[16:03:14.407] - queued futures: [n=2] FALSE, FALSE
[16:03:14.407]  - until=1
[16:03:14.408]  - relaying element #1
[16:03:14.408] result() for MulticoreFuture ...
[16:03:14.408] result() for MulticoreFuture ... done
[16:03:14.408] result() for MulticoreFuture ...
[16:03:14.408] result() for MulticoreFuture ... done
[16:03:14.408] result() for MulticoreFuture ...
[16:03:14.408] result() for MulticoreFuture ... done
[16:03:14.409] result() for MulticoreFuture ...
[16:03:14.409] result() for MulticoreFuture ... done
[16:03:14.409] - relayed: [n=2] TRUE, FALSE
[16:03:14.409] - queued futures: [n=2] TRUE, FALSE
[16:03:14.409] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:14.409]  length: 1 (resolved future 1)
[16:03:14.410] Future #2
[16:03:14.410] result() for MulticoreFuture ...
[16:03:14.413] result() for MulticoreFuture ...
[16:03:14.414] result() for MulticoreFuture ... done
[16:03:14.414] result() for MulticoreFuture ... done
[16:03:14.414] result() for MulticoreFuture ...
[16:03:14.414] result() for MulticoreFuture ... done
[16:03:14.414] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:14.415] - nx: 2
[16:03:14.415] - relay: TRUE
[16:03:14.415] - stdout: TRUE
[16:03:14.415] - signal: TRUE
[16:03:14.415] - resignal: FALSE
[16:03:14.415] - force: TRUE
[16:03:14.416] - relayed: [n=2] TRUE, FALSE
[16:03:14.416] - queued futures: [n=2] TRUE, FALSE
[16:03:14.416]  - until=2
[16:03:14.416]  - relaying element #2
[16:03:14.416] result() for MulticoreFuture ...
[16:03:14.416] result() for MulticoreFuture ... done
[16:03:14.416] result() for MulticoreFuture ...
[16:03:14.417] result() for MulticoreFuture ... done
[16:03:14.417] result() for MulticoreFuture ...
[16:03:14.417] result() for MulticoreFuture ... done
[16:03:14.417] result() for MulticoreFuture ...
[16:03:14.417] result() for MulticoreFuture ... done
[16:03:14.417] - relayed: [n=2] TRUE, TRUE
[16:03:14.418] - queued futures: [n=2] TRUE, TRUE
[16:03:14.418] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:14.418]  length: 0 (resolved future 2)
[16:03:14.418] Relaying remaining futures
[16:03:14.418] signalConditionsASAP(NULL, pos=0) ...
[16:03:14.418] - nx: 2
[16:03:14.418] - relay: TRUE
[16:03:14.419] - stdout: TRUE
[16:03:14.419] - signal: TRUE
[16:03:14.419] - resignal: FALSE
[16:03:14.419] - force: TRUE
[16:03:14.419] - relayed: [n=2] TRUE, TRUE
[16:03:14.419] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:14.420] - relayed: [n=2] TRUE, TRUE
[16:03:14.420] - queued futures: [n=2] TRUE, TRUE
[16:03:14.420] signalConditionsASAP(NULL, pos=0) ... done
[16:03:14.420] resolve() on list ... DONE
[16:03:14.420] result() for MulticoreFuture ...
[16:03:14.420] result() for MulticoreFuture ... done
[16:03:14.420] result() for MulticoreFuture ...
[16:03:14.421] result() for MulticoreFuture ... done
[16:03:14.421] result() for MulticoreFuture ...
[16:03:14.421] result() for MulticoreFuture ... done
[16:03:14.421] result() for MulticoreFuture ...
[16:03:14.421] result() for MulticoreFuture ... done
[16:03:14.421]  - Number of value chunks collected: 2
[16:03:14.421] Resolving 2 futures (chunks) ... DONE
[16:03:14.422] Reducing values from 2 chunks ...
[16:03:14.422]  - Number of values collected after concatenation: 3
[16:03:14.422]  - Number of values expected: 3
[16:03:14.422] Reducing values from 2 chunks ... DONE
[16:03:14.422] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[16:03:14.424] future_lapply() ...
[16:03:14.433] Number of chunks: 2
[16:03:14.433] getGlobalsAndPackagesXApply() ...
[16:03:14.433]  - future.globals: TRUE
[16:03:14.433] getGlobalsAndPackages() ...
[16:03:14.433] Searching for globals...
[16:03:14.440] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:03:14.440] Searching for globals ... DONE
[16:03:14.441] Resolving globals: FALSE
[16:03:14.441] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[16:03:14.442] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[16:03:14.442] - globals: [1] ‘FUN’
[16:03:14.442] - packages: [1] ‘stats’
[16:03:14.442] getGlobalsAndPackages() ... DONE
[16:03:14.442]  - globals found/used: [n=1] ‘FUN’
[16:03:14.442]  - needed namespaces: [n=1] ‘stats’
[16:03:14.442] Finding globals ... DONE
[16:03:14.443]  - use_args: TRUE
[16:03:14.443]  - Getting '...' globals ...
[16:03:14.443] resolve() on list ...
[16:03:14.443]  recursive: 0
[16:03:14.443]  length: 1
[16:03:14.443]  elements: ‘...’
[16:03:14.444]  length: 0 (resolved future 1)
[16:03:14.444] resolve() on list ... DONE
[16:03:14.444]    - '...' content: [n=0] 
[16:03:14.444] List of 1
[16:03:14.444]  $ ...: list()
[16:03:14.444]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.444]  - attr(*, "where")=List of 1
[16:03:14.444]   ..$ ...:<environment: 0x564e414135c8> 
[16:03:14.444]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.444]  - attr(*, "resolved")= logi TRUE
[16:03:14.444]  - attr(*, "total_size")= num NA
[16:03:14.446]  - Getting '...' globals ... DONE
[16:03:14.446] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:14.447] List of 2
[16:03:14.447]  $ ...future.FUN:function (x, na.rm = TRUE)  
[16:03:14.447]  $ ...          : list()
[16:03:14.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.447]  - attr(*, "where")=List of 2
[16:03:14.447]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:14.447]   ..$ ...          :<environment: 0x564e414135c8> 
[16:03:14.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.447]  - attr(*, "resolved")= logi FALSE
[16:03:14.447]  - attr(*, "total_size")= num 46960
[16:03:14.449] Packages to be attached in all futures: [n=1] ‘stats’
[16:03:14.449] getGlobalsAndPackagesXApply() ... DONE
[16:03:14.450] Number of futures (= number of chunks): 2
[16:03:14.450] Launching 2 futures (chunks) ...
[16:03:14.450] Chunk #1 of 2 ...
[16:03:14.450]  - Finding globals in 'X' for chunk #1 ...
[16:03:14.450] getGlobalsAndPackages() ...
[16:03:14.450] Searching for globals...
[16:03:14.450] 
[16:03:14.450] Searching for globals ... DONE
[16:03:14.451] - globals: [0] <none>
[16:03:14.451] getGlobalsAndPackages() ... DONE
[16:03:14.451]    + additional globals found: [n=0] 
[16:03:14.451]    + additional namespaces needed: [n=0] 
[16:03:14.451]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:14.451]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.451]  - seeds: <none>
[16:03:14.451]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.451] getGlobalsAndPackages() ...
[16:03:14.451] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.452] Resolving globals: FALSE
[16:03:14.452] Tweak future expression to call with '...' arguments ...
[16:03:14.452] {
[16:03:14.452]     do.call(function(...) {
[16:03:14.452]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.452]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.452]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.452]             on.exit(options(oopts), add = TRUE)
[16:03:14.452]         }
[16:03:14.452]         {
[16:03:14.452]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.452]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.452]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.452]             })
[16:03:14.452]         }
[16:03:14.452]     }, args = future.call.arguments)
[16:03:14.452] }
[16:03:14.452] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.452] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.453] - packages: [1] ‘stats’
[16:03:14.453] getGlobalsAndPackages() ... DONE
[16:03:14.453] run() for ‘Future’ ...
[16:03:14.453] - state: ‘created’
[16:03:14.453] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.457] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.457]   - Field: ‘label’
[16:03:14.457]   - Field: ‘local’
[16:03:14.457]   - Field: ‘owner’
[16:03:14.457]   - Field: ‘envir’
[16:03:14.457]   - Field: ‘workers’
[16:03:14.458]   - Field: ‘packages’
[16:03:14.458]   - Field: ‘gc’
[16:03:14.458]   - Field: ‘job’
[16:03:14.458]   - Field: ‘conditions’
[16:03:14.458]   - Field: ‘expr’
[16:03:14.458]   - Field: ‘uuid’
[16:03:14.458]   - Field: ‘seed’
[16:03:14.458]   - Field: ‘version’
[16:03:14.458]   - Field: ‘result’
[16:03:14.458]   - Field: ‘asynchronous’
[16:03:14.458]   - Field: ‘calls’
[16:03:14.459]   - Field: ‘globals’
[16:03:14.460]   - Field: ‘stdout’
[16:03:14.460]   - Field: ‘earlySignal’
[16:03:14.461]   - Field: ‘lazy’
[16:03:14.461]   - Field: ‘state’
[16:03:14.461] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.461] - Launch lazy future ...
[16:03:14.461] Packages needed by the future expression (n = 1): ‘stats’
[16:03:14.461] Packages needed by future strategies (n = 0): <none>
[16:03:14.462] {
[16:03:14.462]     {
[16:03:14.462]         {
[16:03:14.462]             ...future.startTime <- base::Sys.time()
[16:03:14.462]             {
[16:03:14.462]                 {
[16:03:14.462]                   {
[16:03:14.462]                     {
[16:03:14.462]                       {
[16:03:14.462]                         base::local({
[16:03:14.462]                           has_future <- base::requireNamespace("future", 
[16:03:14.462]                             quietly = TRUE)
[16:03:14.462]                           if (has_future) {
[16:03:14.462]                             ns <- base::getNamespace("future")
[16:03:14.462]                             version <- ns[[".package"]][["version"]]
[16:03:14.462]                             if (is.null(version)) 
[16:03:14.462]                               version <- utils::packageVersion("future")
[16:03:14.462]                           }
[16:03:14.462]                           else {
[16:03:14.462]                             version <- NULL
[16:03:14.462]                           }
[16:03:14.462]                           if (!has_future || version < "1.8.0") {
[16:03:14.462]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.462]                               "", base::R.version$version.string), 
[16:03:14.462]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.462]                                 base::R.version$platform, 8 * 
[16:03:14.462]                                   base::.Machine$sizeof.pointer), 
[16:03:14.462]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.462]                                 "release", "version")], collapse = " "), 
[16:03:14.462]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.462]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.462]                               info)
[16:03:14.462]                             info <- base::paste(info, collapse = "; ")
[16:03:14.462]                             if (!has_future) {
[16:03:14.462]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.462]                                 info)
[16:03:14.462]                             }
[16:03:14.462]                             else {
[16:03:14.462]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.462]                                 info, version)
[16:03:14.462]                             }
[16:03:14.462]                             base::stop(msg)
[16:03:14.462]                           }
[16:03:14.462]                         })
[16:03:14.462]                       }
[16:03:14.462]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.462]                       base::options(mc.cores = 1L)
[16:03:14.462]                     }
[16:03:14.462]                     base::local({
[16:03:14.462]                       for (pkg in "stats") {
[16:03:14.462]                         base::loadNamespace(pkg)
[16:03:14.462]                         base::library(pkg, character.only = TRUE)
[16:03:14.462]                       }
[16:03:14.462]                     })
[16:03:14.462]                   }
[16:03:14.462]                   options(future.plan = NULL)
[16:03:14.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.462]                 }
[16:03:14.462]                 ...future.workdir <- getwd()
[16:03:14.462]             }
[16:03:14.462]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.462]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.462]         }
[16:03:14.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.462]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.462]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.462]             base::names(...future.oldOptions))
[16:03:14.462]     }
[16:03:14.462]     if (FALSE) {
[16:03:14.462]     }
[16:03:14.462]     else {
[16:03:14.462]         if (TRUE) {
[16:03:14.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.462]                 open = "w")
[16:03:14.462]         }
[16:03:14.462]         else {
[16:03:14.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.462]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.462]         }
[16:03:14.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.462]             base::sink(type = "output", split = FALSE)
[16:03:14.462]             base::close(...future.stdout)
[16:03:14.462]         }, add = TRUE)
[16:03:14.462]     }
[16:03:14.462]     ...future.frame <- base::sys.nframe()
[16:03:14.462]     ...future.conditions <- base::list()
[16:03:14.462]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.462]     if (FALSE) {
[16:03:14.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.462]     }
[16:03:14.462]     ...future.result <- base::tryCatch({
[16:03:14.462]         base::withCallingHandlers({
[16:03:14.462]             ...future.value <- base::withVisible(base::local({
[16:03:14.462]                 withCallingHandlers({
[16:03:14.462]                   {
[16:03:14.462]                     do.call(function(...) {
[16:03:14.462]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.462]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.462]                         ...future.globals.maxSize)) {
[16:03:14.462]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.462]                         on.exit(options(oopts), add = TRUE)
[16:03:14.462]                       }
[16:03:14.462]                       {
[16:03:14.462]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.462]                           FUN = function(jj) {
[16:03:14.462]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.462]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.462]                           })
[16:03:14.462]                       }
[16:03:14.462]                     }, args = future.call.arguments)
[16:03:14.462]                   }
[16:03:14.462]                 }, immediateCondition = function(cond) {
[16:03:14.462]                   save_rds <- function (object, pathname, ...) 
[16:03:14.462]                   {
[16:03:14.462]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.462]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.462]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.462]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.462]                         fi_tmp[["mtime"]])
[16:03:14.462]                     }
[16:03:14.462]                     tryCatch({
[16:03:14.462]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.462]                     }, error = function(ex) {
[16:03:14.462]                       msg <- conditionMessage(ex)
[16:03:14.462]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.462]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.462]                         fi_tmp[["mtime"]], msg)
[16:03:14.462]                       ex$message <- msg
[16:03:14.462]                       stop(ex)
[16:03:14.462]                     })
[16:03:14.462]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.462]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.462]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.462]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.462]                       fi <- file.info(pathname)
[16:03:14.462]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.462]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.462]                         fi[["size"]], fi[["mtime"]])
[16:03:14.462]                       stop(msg)
[16:03:14.462]                     }
[16:03:14.462]                     invisible(pathname)
[16:03:14.462]                   }
[16:03:14.462]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.462]                     rootPath = tempdir()) 
[16:03:14.462]                   {
[16:03:14.462]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.462]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.462]                       tmpdir = path, fileext = ".rds")
[16:03:14.462]                     save_rds(obj, file)
[16:03:14.462]                   }
[16:03:14.462]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.462]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.462]                   {
[16:03:14.462]                     inherits <- base::inherits
[16:03:14.462]                     invokeRestart <- base::invokeRestart
[16:03:14.462]                     is.null <- base::is.null
[16:03:14.462]                     muffled <- FALSE
[16:03:14.462]                     if (inherits(cond, "message")) {
[16:03:14.462]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.462]                       if (muffled) 
[16:03:14.462]                         invokeRestart("muffleMessage")
[16:03:14.462]                     }
[16:03:14.462]                     else if (inherits(cond, "warning")) {
[16:03:14.462]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.462]                       if (muffled) 
[16:03:14.462]                         invokeRestart("muffleWarning")
[16:03:14.462]                     }
[16:03:14.462]                     else if (inherits(cond, "condition")) {
[16:03:14.462]                       if (!is.null(pattern)) {
[16:03:14.462]                         computeRestarts <- base::computeRestarts
[16:03:14.462]                         grepl <- base::grepl
[16:03:14.462]                         restarts <- computeRestarts(cond)
[16:03:14.462]                         for (restart in restarts) {
[16:03:14.462]                           name <- restart$name
[16:03:14.462]                           if (is.null(name)) 
[16:03:14.462]                             next
[16:03:14.462]                           if (!grepl(pattern, name)) 
[16:03:14.462]                             next
[16:03:14.462]                           invokeRestart(restart)
[16:03:14.462]                           muffled <- TRUE
[16:03:14.462]                           break
[16:03:14.462]                         }
[16:03:14.462]                       }
[16:03:14.462]                     }
[16:03:14.462]                     invisible(muffled)
[16:03:14.462]                   }
[16:03:14.462]                   muffleCondition(cond)
[16:03:14.462]                 })
[16:03:14.462]             }))
[16:03:14.462]             future::FutureResult(value = ...future.value$value, 
[16:03:14.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.462]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.462]                     ...future.globalenv.names))
[16:03:14.462]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.462]         }, condition = base::local({
[16:03:14.462]             c <- base::c
[16:03:14.462]             inherits <- base::inherits
[16:03:14.462]             invokeRestart <- base::invokeRestart
[16:03:14.462]             length <- base::length
[16:03:14.462]             list <- base::list
[16:03:14.462]             seq.int <- base::seq.int
[16:03:14.462]             signalCondition <- base::signalCondition
[16:03:14.462]             sys.calls <- base::sys.calls
[16:03:14.462]             `[[` <- base::`[[`
[16:03:14.462]             `+` <- base::`+`
[16:03:14.462]             `<<-` <- base::`<<-`
[16:03:14.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.462]                   3L)]
[16:03:14.462]             }
[16:03:14.462]             function(cond) {
[16:03:14.462]                 is_error <- inherits(cond, "error")
[16:03:14.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.462]                   NULL)
[16:03:14.462]                 if (is_error) {
[16:03:14.462]                   sessionInformation <- function() {
[16:03:14.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.462]                       search = base::search(), system = base::Sys.info())
[16:03:14.462]                   }
[16:03:14.462]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.462]                     cond$call), session = sessionInformation(), 
[16:03:14.462]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.462]                   signalCondition(cond)
[16:03:14.462]                 }
[16:03:14.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.462]                 "immediateCondition"))) {
[16:03:14.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.462]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.462]                   if (TRUE && !signal) {
[16:03:14.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.462]                     {
[16:03:14.462]                       inherits <- base::inherits
[16:03:14.462]                       invokeRestart <- base::invokeRestart
[16:03:14.462]                       is.null <- base::is.null
[16:03:14.462]                       muffled <- FALSE
[16:03:14.462]                       if (inherits(cond, "message")) {
[16:03:14.462]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.462]                         if (muffled) 
[16:03:14.462]                           invokeRestart("muffleMessage")
[16:03:14.462]                       }
[16:03:14.462]                       else if (inherits(cond, "warning")) {
[16:03:14.462]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.462]                         if (muffled) 
[16:03:14.462]                           invokeRestart("muffleWarning")
[16:03:14.462]                       }
[16:03:14.462]                       else if (inherits(cond, "condition")) {
[16:03:14.462]                         if (!is.null(pattern)) {
[16:03:14.462]                           computeRestarts <- base::computeRestarts
[16:03:14.462]                           grepl <- base::grepl
[16:03:14.462]                           restarts <- computeRestarts(cond)
[16:03:14.462]                           for (restart in restarts) {
[16:03:14.462]                             name <- restart$name
[16:03:14.462]                             if (is.null(name)) 
[16:03:14.462]                               next
[16:03:14.462]                             if (!grepl(pattern, name)) 
[16:03:14.462]                               next
[16:03:14.462]                             invokeRestart(restart)
[16:03:14.462]                             muffled <- TRUE
[16:03:14.462]                             break
[16:03:14.462]                           }
[16:03:14.462]                         }
[16:03:14.462]                       }
[16:03:14.462]                       invisible(muffled)
[16:03:14.462]                     }
[16:03:14.462]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.462]                   }
[16:03:14.462]                 }
[16:03:14.462]                 else {
[16:03:14.462]                   if (TRUE) {
[16:03:14.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.462]                     {
[16:03:14.462]                       inherits <- base::inherits
[16:03:14.462]                       invokeRestart <- base::invokeRestart
[16:03:14.462]                       is.null <- base::is.null
[16:03:14.462]                       muffled <- FALSE
[16:03:14.462]                       if (inherits(cond, "message")) {
[16:03:14.462]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.462]                         if (muffled) 
[16:03:14.462]                           invokeRestart("muffleMessage")
[16:03:14.462]                       }
[16:03:14.462]                       else if (inherits(cond, "warning")) {
[16:03:14.462]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.462]                         if (muffled) 
[16:03:14.462]                           invokeRestart("muffleWarning")
[16:03:14.462]                       }
[16:03:14.462]                       else if (inherits(cond, "condition")) {
[16:03:14.462]                         if (!is.null(pattern)) {
[16:03:14.462]                           computeRestarts <- base::computeRestarts
[16:03:14.462]                           grepl <- base::grepl
[16:03:14.462]                           restarts <- computeRestarts(cond)
[16:03:14.462]                           for (restart in restarts) {
[16:03:14.462]                             name <- restart$name
[16:03:14.462]                             if (is.null(name)) 
[16:03:14.462]                               next
[16:03:14.462]                             if (!grepl(pattern, name)) 
[16:03:14.462]                               next
[16:03:14.462]                             invokeRestart(restart)
[16:03:14.462]                             muffled <- TRUE
[16:03:14.462]                             break
[16:03:14.462]                           }
[16:03:14.462]                         }
[16:03:14.462]                       }
[16:03:14.462]                       invisible(muffled)
[16:03:14.462]                     }
[16:03:14.462]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.462]                   }
[16:03:14.462]                 }
[16:03:14.462]             }
[16:03:14.462]         }))
[16:03:14.462]     }, error = function(ex) {
[16:03:14.462]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.462]                 ...future.rng), started = ...future.startTime, 
[16:03:14.462]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.462]             version = "1.8"), class = "FutureResult")
[16:03:14.462]     }, finally = {
[16:03:14.462]         if (!identical(...future.workdir, getwd())) 
[16:03:14.462]             setwd(...future.workdir)
[16:03:14.462]         {
[16:03:14.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.462]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.462]             }
[16:03:14.462]             base::options(...future.oldOptions)
[16:03:14.462]             if (.Platform$OS.type == "windows") {
[16:03:14.462]                 old_names <- names(...future.oldEnvVars)
[16:03:14.462]                 envs <- base::Sys.getenv()
[16:03:14.462]                 names <- names(envs)
[16:03:14.462]                 common <- intersect(names, old_names)
[16:03:14.462]                 added <- setdiff(names, old_names)
[16:03:14.462]                 removed <- setdiff(old_names, names)
[16:03:14.462]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.462]                   envs[common]]
[16:03:14.462]                 NAMES <- toupper(changed)
[16:03:14.462]                 args <- list()
[16:03:14.462]                 for (kk in seq_along(NAMES)) {
[16:03:14.462]                   name <- changed[[kk]]
[16:03:14.462]                   NAME <- NAMES[[kk]]
[16:03:14.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.462]                     next
[16:03:14.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.462]                 }
[16:03:14.462]                 NAMES <- toupper(added)
[16:03:14.462]                 for (kk in seq_along(NAMES)) {
[16:03:14.462]                   name <- added[[kk]]
[16:03:14.462]                   NAME <- NAMES[[kk]]
[16:03:14.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.462]                     next
[16:03:14.462]                   args[[name]] <- ""
[16:03:14.462]                 }
[16:03:14.462]                 NAMES <- toupper(removed)
[16:03:14.462]                 for (kk in seq_along(NAMES)) {
[16:03:14.462]                   name <- removed[[kk]]
[16:03:14.462]                   NAME <- NAMES[[kk]]
[16:03:14.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.462]                     next
[16:03:14.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.462]                 }
[16:03:14.462]                 if (length(args) > 0) 
[16:03:14.462]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.462]             }
[16:03:14.462]             else {
[16:03:14.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.462]             }
[16:03:14.462]             {
[16:03:14.462]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.462]                   0L) {
[16:03:14.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.462]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.462]                   base::options(opts)
[16:03:14.462]                 }
[16:03:14.462]                 {
[16:03:14.462]                   {
[16:03:14.462]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.462]                     NULL
[16:03:14.462]                   }
[16:03:14.462]                   options(future.plan = NULL)
[16:03:14.462]                   if (is.na(NA_character_)) 
[16:03:14.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.462]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.462]                     envir = parent.frame()) 
[16:03:14.462]                   {
[16:03:14.462]                     default_workers <- missing(workers)
[16:03:14.462]                     if (is.function(workers)) 
[16:03:14.462]                       workers <- workers()
[16:03:14.462]                     workers <- structure(as.integer(workers), 
[16:03:14.462]                       class = class(workers))
[16:03:14.462]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.462]                       1L)
[16:03:14.462]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.462]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.462]                       if (default_workers) 
[16:03:14.462]                         supportsMulticore(warn = TRUE)
[16:03:14.462]                       return(sequential(..., envir = envir))
[16:03:14.462]                     }
[16:03:14.462]                     oopts <- options(mc.cores = workers)
[16:03:14.462]                     on.exit(options(oopts))
[16:03:14.462]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.462]                       envir = envir)
[16:03:14.462]                     if (!future$lazy) 
[16:03:14.462]                       future <- run(future)
[16:03:14.462]                     invisible(future)
[16:03:14.462]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.462]                 }
[16:03:14.462]             }
[16:03:14.462]         }
[16:03:14.462]     })
[16:03:14.462]     if (TRUE) {
[16:03:14.462]         base::sink(type = "output", split = FALSE)
[16:03:14.462]         if (TRUE) {
[16:03:14.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.462]         }
[16:03:14.462]         else {
[16:03:14.462]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.462]         }
[16:03:14.462]         base::close(...future.stdout)
[16:03:14.462]         ...future.stdout <- NULL
[16:03:14.462]     }
[16:03:14.462]     ...future.result$conditions <- ...future.conditions
[16:03:14.462]     ...future.result$finished <- base::Sys.time()
[16:03:14.462]     ...future.result
[16:03:14.462] }
[16:03:14.464] assign_globals() ...
[16:03:14.465] List of 5
[16:03:14.465]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[16:03:14.465]  $ future.call.arguments    : list()
[16:03:14.465]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.465]  $ ...future.elements_ii    :List of 4
[16:03:14.465]   ..$ : int [1:3] 1 2 3
[16:03:14.465]   ..$ : int [1:4] 1 2 3 4
[16:03:14.465]   ..$ : int [1:5] 1 2 3 4 5
[16:03:14.465]   ..$ : int [1:6] 1 2 3 4 5 6
[16:03:14.465]  $ ...future.seeds_ii       : NULL
[16:03:14.465]  $ ...future.globals.maxSize: NULL
[16:03:14.465]  - attr(*, "where")=List of 5
[16:03:14.465]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.465]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.465]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.465]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.465]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.465]  - attr(*, "resolved")= logi FALSE
[16:03:14.465]  - attr(*, "total_size")= num 46960
[16:03:14.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.465]  - attr(*, "already-done")= logi TRUE
[16:03:14.470] - copied ‘...future.FUN’ to environment
[16:03:14.471] - copied ‘future.call.arguments’ to environment
[16:03:14.471] - copied ‘...future.elements_ii’ to environment
[16:03:14.471] - copied ‘...future.seeds_ii’ to environment
[16:03:14.471] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.471] assign_globals() ... done
[16:03:14.471] requestCore(): workers = 2
[16:03:14.473] MulticoreFuture started
[16:03:14.474] - Launch lazy future ... done
[16:03:14.474] run() for ‘MulticoreFuture’ ... done
[16:03:14.474] Created future:
[16:03:14.475] plan(): Setting new future strategy stack:
[16:03:14.475] List of future strategies:
[16:03:14.475] 1. sequential:
[16:03:14.475]    - args: function (..., envir = parent.frame())
[16:03:14.475]    - tweaked: FALSE
[16:03:14.475]    - call: NULL
[16:03:14.476] plan(): nbrOfWorkers() = 1
[16:03:14.478] plan(): Setting new future strategy stack:
[16:03:14.478] List of future strategies:
[16:03:14.478] 1. multicore:
[16:03:14.478]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.478]    - tweaked: FALSE
[16:03:14.478]    - call: plan(strategy)
[16:03:14.484] plan(): nbrOfWorkers() = 2
[16:03:14.475] MulticoreFuture:
[16:03:14.475] Label: ‘future_sapply-1’
[16:03:14.475] Expression:
[16:03:14.475] {
[16:03:14.475]     do.call(function(...) {
[16:03:14.475]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.475]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.475]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.475]             on.exit(options(oopts), add = TRUE)
[16:03:14.475]         }
[16:03:14.475]         {
[16:03:14.475]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.475]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.475]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.475]             })
[16:03:14.475]         }
[16:03:14.475]     }, args = future.call.arguments)
[16:03:14.475] }
[16:03:14.475] Lazy evaluation: FALSE
[16:03:14.475] Asynchronous evaluation: TRUE
[16:03:14.475] Local evaluation: TRUE
[16:03:14.475] Environment: R_GlobalEnv
[16:03:14.475] Capture standard output: TRUE
[16:03:14.475] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.475] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:14.475] Packages: 1 packages (‘stats’)
[16:03:14.475] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.475] Resolved: TRUE
[16:03:14.475] Value: <not collected>
[16:03:14.475] Conditions captured: <none>
[16:03:14.475] Early signaling: FALSE
[16:03:14.475] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.475] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.485] Chunk #1 of 2 ... DONE
[16:03:14.485] Chunk #2 of 2 ...
[16:03:14.485]  - Finding globals in 'X' for chunk #2 ...
[16:03:14.485] getGlobalsAndPackages() ...
[16:03:14.486] Searching for globals...
[16:03:14.486] 
[16:03:14.486] Searching for globals ... DONE
[16:03:14.486] - globals: [0] <none>
[16:03:14.486] getGlobalsAndPackages() ... DONE
[16:03:14.487]    + additional globals found: [n=0] 
[16:03:14.487]    + additional namespaces needed: [n=0] 
[16:03:14.487]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:14.487]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.487]  - seeds: <none>
[16:03:14.487]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.488] getGlobalsAndPackages() ...
[16:03:14.488] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.488] Resolving globals: FALSE
[16:03:14.488] Tweak future expression to call with '...' arguments ...
[16:03:14.488] {
[16:03:14.488]     do.call(function(...) {
[16:03:14.488]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.488]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.488]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.488]             on.exit(options(oopts), add = TRUE)
[16:03:14.488]         }
[16:03:14.488]         {
[16:03:14.488]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.488]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.488]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.488]             })
[16:03:14.488]         }
[16:03:14.488]     }, args = future.call.arguments)
[16:03:14.488] }
[16:03:14.489] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.489] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.490] - packages: [1] ‘stats’
[16:03:14.490] getGlobalsAndPackages() ... DONE
[16:03:14.490] run() for ‘Future’ ...
[16:03:14.490] - state: ‘created’
[16:03:14.491] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.495] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.495] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.495]   - Field: ‘label’
[16:03:14.496]   - Field: ‘local’
[16:03:14.496]   - Field: ‘owner’
[16:03:14.496]   - Field: ‘envir’
[16:03:14.496]   - Field: ‘workers’
[16:03:14.496]   - Field: ‘packages’
[16:03:14.496]   - Field: ‘gc’
[16:03:14.496]   - Field: ‘job’
[16:03:14.497]   - Field: ‘conditions’
[16:03:14.497]   - Field: ‘expr’
[16:03:14.497]   - Field: ‘uuid’
[16:03:14.497]   - Field: ‘seed’
[16:03:14.497]   - Field: ‘version’
[16:03:14.497]   - Field: ‘result’
[16:03:14.497]   - Field: ‘asynchronous’
[16:03:14.498]   - Field: ‘calls’
[16:03:14.498]   - Field: ‘globals’
[16:03:14.498]   - Field: ‘stdout’
[16:03:14.498]   - Field: ‘earlySignal’
[16:03:14.498]   - Field: ‘lazy’
[16:03:14.498]   - Field: ‘state’
[16:03:14.498] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.499] - Launch lazy future ...
[16:03:14.499] Packages needed by the future expression (n = 1): ‘stats’
[16:03:14.499] Packages needed by future strategies (n = 0): <none>
[16:03:14.504] {
[16:03:14.504]     {
[16:03:14.504]         {
[16:03:14.504]             ...future.startTime <- base::Sys.time()
[16:03:14.504]             {
[16:03:14.504]                 {
[16:03:14.504]                   {
[16:03:14.504]                     {
[16:03:14.504]                       {
[16:03:14.504]                         base::local({
[16:03:14.504]                           has_future <- base::requireNamespace("future", 
[16:03:14.504]                             quietly = TRUE)
[16:03:14.504]                           if (has_future) {
[16:03:14.504]                             ns <- base::getNamespace("future")
[16:03:14.504]                             version <- ns[[".package"]][["version"]]
[16:03:14.504]                             if (is.null(version)) 
[16:03:14.504]                               version <- utils::packageVersion("future")
[16:03:14.504]                           }
[16:03:14.504]                           else {
[16:03:14.504]                             version <- NULL
[16:03:14.504]                           }
[16:03:14.504]                           if (!has_future || version < "1.8.0") {
[16:03:14.504]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.504]                               "", base::R.version$version.string), 
[16:03:14.504]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.504]                                 base::R.version$platform, 8 * 
[16:03:14.504]                                   base::.Machine$sizeof.pointer), 
[16:03:14.504]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.504]                                 "release", "version")], collapse = " "), 
[16:03:14.504]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.504]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.504]                               info)
[16:03:14.504]                             info <- base::paste(info, collapse = "; ")
[16:03:14.504]                             if (!has_future) {
[16:03:14.504]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.504]                                 info)
[16:03:14.504]                             }
[16:03:14.504]                             else {
[16:03:14.504]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.504]                                 info, version)
[16:03:14.504]                             }
[16:03:14.504]                             base::stop(msg)
[16:03:14.504]                           }
[16:03:14.504]                         })
[16:03:14.504]                       }
[16:03:14.504]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.504]                       base::options(mc.cores = 1L)
[16:03:14.504]                     }
[16:03:14.504]                     base::local({
[16:03:14.504]                       for (pkg in "stats") {
[16:03:14.504]                         base::loadNamespace(pkg)
[16:03:14.504]                         base::library(pkg, character.only = TRUE)
[16:03:14.504]                       }
[16:03:14.504]                     })
[16:03:14.504]                   }
[16:03:14.504]                   options(future.plan = NULL)
[16:03:14.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.504]                 }
[16:03:14.504]                 ...future.workdir <- getwd()
[16:03:14.504]             }
[16:03:14.504]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.504]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.504]         }
[16:03:14.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.504]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.504]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.504]             base::names(...future.oldOptions))
[16:03:14.504]     }
[16:03:14.504]     if (FALSE) {
[16:03:14.504]     }
[16:03:14.504]     else {
[16:03:14.504]         if (TRUE) {
[16:03:14.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.504]                 open = "w")
[16:03:14.504]         }
[16:03:14.504]         else {
[16:03:14.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.504]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.504]         }
[16:03:14.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.504]             base::sink(type = "output", split = FALSE)
[16:03:14.504]             base::close(...future.stdout)
[16:03:14.504]         }, add = TRUE)
[16:03:14.504]     }
[16:03:14.504]     ...future.frame <- base::sys.nframe()
[16:03:14.504]     ...future.conditions <- base::list()
[16:03:14.504]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.504]     if (FALSE) {
[16:03:14.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.504]     }
[16:03:14.504]     ...future.result <- base::tryCatch({
[16:03:14.504]         base::withCallingHandlers({
[16:03:14.504]             ...future.value <- base::withVisible(base::local({
[16:03:14.504]                 withCallingHandlers({
[16:03:14.504]                   {
[16:03:14.504]                     do.call(function(...) {
[16:03:14.504]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.504]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.504]                         ...future.globals.maxSize)) {
[16:03:14.504]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.504]                         on.exit(options(oopts), add = TRUE)
[16:03:14.504]                       }
[16:03:14.504]                       {
[16:03:14.504]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.504]                           FUN = function(jj) {
[16:03:14.504]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.504]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.504]                           })
[16:03:14.504]                       }
[16:03:14.504]                     }, args = future.call.arguments)
[16:03:14.504]                   }
[16:03:14.504]                 }, immediateCondition = function(cond) {
[16:03:14.504]                   save_rds <- function (object, pathname, ...) 
[16:03:14.504]                   {
[16:03:14.504]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.504]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.504]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.504]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.504]                         fi_tmp[["mtime"]])
[16:03:14.504]                     }
[16:03:14.504]                     tryCatch({
[16:03:14.504]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.504]                     }, error = function(ex) {
[16:03:14.504]                       msg <- conditionMessage(ex)
[16:03:14.504]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.504]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.504]                         fi_tmp[["mtime"]], msg)
[16:03:14.504]                       ex$message <- msg
[16:03:14.504]                       stop(ex)
[16:03:14.504]                     })
[16:03:14.504]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.504]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.504]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.504]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.504]                       fi <- file.info(pathname)
[16:03:14.504]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.504]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.504]                         fi[["size"]], fi[["mtime"]])
[16:03:14.504]                       stop(msg)
[16:03:14.504]                     }
[16:03:14.504]                     invisible(pathname)
[16:03:14.504]                   }
[16:03:14.504]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.504]                     rootPath = tempdir()) 
[16:03:14.504]                   {
[16:03:14.504]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.504]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.504]                       tmpdir = path, fileext = ".rds")
[16:03:14.504]                     save_rds(obj, file)
[16:03:14.504]                   }
[16:03:14.504]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.504]                   {
[16:03:14.504]                     inherits <- base::inherits
[16:03:14.504]                     invokeRestart <- base::invokeRestart
[16:03:14.504]                     is.null <- base::is.null
[16:03:14.504]                     muffled <- FALSE
[16:03:14.504]                     if (inherits(cond, "message")) {
[16:03:14.504]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.504]                       if (muffled) 
[16:03:14.504]                         invokeRestart("muffleMessage")
[16:03:14.504]                     }
[16:03:14.504]                     else if (inherits(cond, "warning")) {
[16:03:14.504]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.504]                       if (muffled) 
[16:03:14.504]                         invokeRestart("muffleWarning")
[16:03:14.504]                     }
[16:03:14.504]                     else if (inherits(cond, "condition")) {
[16:03:14.504]                       if (!is.null(pattern)) {
[16:03:14.504]                         computeRestarts <- base::computeRestarts
[16:03:14.504]                         grepl <- base::grepl
[16:03:14.504]                         restarts <- computeRestarts(cond)
[16:03:14.504]                         for (restart in restarts) {
[16:03:14.504]                           name <- restart$name
[16:03:14.504]                           if (is.null(name)) 
[16:03:14.504]                             next
[16:03:14.504]                           if (!grepl(pattern, name)) 
[16:03:14.504]                             next
[16:03:14.504]                           invokeRestart(restart)
[16:03:14.504]                           muffled <- TRUE
[16:03:14.504]                           break
[16:03:14.504]                         }
[16:03:14.504]                       }
[16:03:14.504]                     }
[16:03:14.504]                     invisible(muffled)
[16:03:14.504]                   }
[16:03:14.504]                   muffleCondition(cond)
[16:03:14.504]                 })
[16:03:14.504]             }))
[16:03:14.504]             future::FutureResult(value = ...future.value$value, 
[16:03:14.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.504]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.504]                     ...future.globalenv.names))
[16:03:14.504]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.504]         }, condition = base::local({
[16:03:14.504]             c <- base::c
[16:03:14.504]             inherits <- base::inherits
[16:03:14.504]             invokeRestart <- base::invokeRestart
[16:03:14.504]             length <- base::length
[16:03:14.504]             list <- base::list
[16:03:14.504]             seq.int <- base::seq.int
[16:03:14.504]             signalCondition <- base::signalCondition
[16:03:14.504]             sys.calls <- base::sys.calls
[16:03:14.504]             `[[` <- base::`[[`
[16:03:14.504]             `+` <- base::`+`
[16:03:14.504]             `<<-` <- base::`<<-`
[16:03:14.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.504]                   3L)]
[16:03:14.504]             }
[16:03:14.504]             function(cond) {
[16:03:14.504]                 is_error <- inherits(cond, "error")
[16:03:14.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.504]                   NULL)
[16:03:14.504]                 if (is_error) {
[16:03:14.504]                   sessionInformation <- function() {
[16:03:14.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.504]                       search = base::search(), system = base::Sys.info())
[16:03:14.504]                   }
[16:03:14.504]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.504]                     cond$call), session = sessionInformation(), 
[16:03:14.504]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.504]                   signalCondition(cond)
[16:03:14.504]                 }
[16:03:14.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.504]                 "immediateCondition"))) {
[16:03:14.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.504]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.504]                   if (TRUE && !signal) {
[16:03:14.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.504]                     {
[16:03:14.504]                       inherits <- base::inherits
[16:03:14.504]                       invokeRestart <- base::invokeRestart
[16:03:14.504]                       is.null <- base::is.null
[16:03:14.504]                       muffled <- FALSE
[16:03:14.504]                       if (inherits(cond, "message")) {
[16:03:14.504]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.504]                         if (muffled) 
[16:03:14.504]                           invokeRestart("muffleMessage")
[16:03:14.504]                       }
[16:03:14.504]                       else if (inherits(cond, "warning")) {
[16:03:14.504]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.504]                         if (muffled) 
[16:03:14.504]                           invokeRestart("muffleWarning")
[16:03:14.504]                       }
[16:03:14.504]                       else if (inherits(cond, "condition")) {
[16:03:14.504]                         if (!is.null(pattern)) {
[16:03:14.504]                           computeRestarts <- base::computeRestarts
[16:03:14.504]                           grepl <- base::grepl
[16:03:14.504]                           restarts <- computeRestarts(cond)
[16:03:14.504]                           for (restart in restarts) {
[16:03:14.504]                             name <- restart$name
[16:03:14.504]                             if (is.null(name)) 
[16:03:14.504]                               next
[16:03:14.504]                             if (!grepl(pattern, name)) 
[16:03:14.504]                               next
[16:03:14.504]                             invokeRestart(restart)
[16:03:14.504]                             muffled <- TRUE
[16:03:14.504]                             break
[16:03:14.504]                           }
[16:03:14.504]                         }
[16:03:14.504]                       }
[16:03:14.504]                       invisible(muffled)
[16:03:14.504]                     }
[16:03:14.504]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.504]                   }
[16:03:14.504]                 }
[16:03:14.504]                 else {
[16:03:14.504]                   if (TRUE) {
[16:03:14.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.504]                     {
[16:03:14.504]                       inherits <- base::inherits
[16:03:14.504]                       invokeRestart <- base::invokeRestart
[16:03:14.504]                       is.null <- base::is.null
[16:03:14.504]                       muffled <- FALSE
[16:03:14.504]                       if (inherits(cond, "message")) {
[16:03:14.504]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.504]                         if (muffled) 
[16:03:14.504]                           invokeRestart("muffleMessage")
[16:03:14.504]                       }
[16:03:14.504]                       else if (inherits(cond, "warning")) {
[16:03:14.504]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.504]                         if (muffled) 
[16:03:14.504]                           invokeRestart("muffleWarning")
[16:03:14.504]                       }
[16:03:14.504]                       else if (inherits(cond, "condition")) {
[16:03:14.504]                         if (!is.null(pattern)) {
[16:03:14.504]                           computeRestarts <- base::computeRestarts
[16:03:14.504]                           grepl <- base::grepl
[16:03:14.504]                           restarts <- computeRestarts(cond)
[16:03:14.504]                           for (restart in restarts) {
[16:03:14.504]                             name <- restart$name
[16:03:14.504]                             if (is.null(name)) 
[16:03:14.504]                               next
[16:03:14.504]                             if (!grepl(pattern, name)) 
[16:03:14.504]                               next
[16:03:14.504]                             invokeRestart(restart)
[16:03:14.504]                             muffled <- TRUE
[16:03:14.504]                             break
[16:03:14.504]                           }
[16:03:14.504]                         }
[16:03:14.504]                       }
[16:03:14.504]                       invisible(muffled)
[16:03:14.504]                     }
[16:03:14.504]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.504]                   }
[16:03:14.504]                 }
[16:03:14.504]             }
[16:03:14.504]         }))
[16:03:14.504]     }, error = function(ex) {
[16:03:14.504]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.504]                 ...future.rng), started = ...future.startTime, 
[16:03:14.504]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.504]             version = "1.8"), class = "FutureResult")
[16:03:14.504]     }, finally = {
[16:03:14.504]         if (!identical(...future.workdir, getwd())) 
[16:03:14.504]             setwd(...future.workdir)
[16:03:14.504]         {
[16:03:14.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.504]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.504]             }
[16:03:14.504]             base::options(...future.oldOptions)
[16:03:14.504]             if (.Platform$OS.type == "windows") {
[16:03:14.504]                 old_names <- names(...future.oldEnvVars)
[16:03:14.504]                 envs <- base::Sys.getenv()
[16:03:14.504]                 names <- names(envs)
[16:03:14.504]                 common <- intersect(names, old_names)
[16:03:14.504]                 added <- setdiff(names, old_names)
[16:03:14.504]                 removed <- setdiff(old_names, names)
[16:03:14.504]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.504]                   envs[common]]
[16:03:14.504]                 NAMES <- toupper(changed)
[16:03:14.504]                 args <- list()
[16:03:14.504]                 for (kk in seq_along(NAMES)) {
[16:03:14.504]                   name <- changed[[kk]]
[16:03:14.504]                   NAME <- NAMES[[kk]]
[16:03:14.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.504]                     next
[16:03:14.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.504]                 }
[16:03:14.504]                 NAMES <- toupper(added)
[16:03:14.504]                 for (kk in seq_along(NAMES)) {
[16:03:14.504]                   name <- added[[kk]]
[16:03:14.504]                   NAME <- NAMES[[kk]]
[16:03:14.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.504]                     next
[16:03:14.504]                   args[[name]] <- ""
[16:03:14.504]                 }
[16:03:14.504]                 NAMES <- toupper(removed)
[16:03:14.504]                 for (kk in seq_along(NAMES)) {
[16:03:14.504]                   name <- removed[[kk]]
[16:03:14.504]                   NAME <- NAMES[[kk]]
[16:03:14.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.504]                     next
[16:03:14.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.504]                 }
[16:03:14.504]                 if (length(args) > 0) 
[16:03:14.504]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.504]             }
[16:03:14.504]             else {
[16:03:14.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.504]             }
[16:03:14.504]             {
[16:03:14.504]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.504]                   0L) {
[16:03:14.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.504]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.504]                   base::options(opts)
[16:03:14.504]                 }
[16:03:14.504]                 {
[16:03:14.504]                   {
[16:03:14.504]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.504]                     NULL
[16:03:14.504]                   }
[16:03:14.504]                   options(future.plan = NULL)
[16:03:14.504]                   if (is.na(NA_character_)) 
[16:03:14.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.504]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.504]                     envir = parent.frame()) 
[16:03:14.504]                   {
[16:03:14.504]                     default_workers <- missing(workers)
[16:03:14.504]                     if (is.function(workers)) 
[16:03:14.504]                       workers <- workers()
[16:03:14.504]                     workers <- structure(as.integer(workers), 
[16:03:14.504]                       class = class(workers))
[16:03:14.504]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.504]                       1L)
[16:03:14.504]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.504]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.504]                       if (default_workers) 
[16:03:14.504]                         supportsMulticore(warn = TRUE)
[16:03:14.504]                       return(sequential(..., envir = envir))
[16:03:14.504]                     }
[16:03:14.504]                     oopts <- options(mc.cores = workers)
[16:03:14.504]                     on.exit(options(oopts))
[16:03:14.504]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.504]                       envir = envir)
[16:03:14.504]                     if (!future$lazy) 
[16:03:14.504]                       future <- run(future)
[16:03:14.504]                     invisible(future)
[16:03:14.504]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.504]                 }
[16:03:14.504]             }
[16:03:14.504]         }
[16:03:14.504]     })
[16:03:14.504]     if (TRUE) {
[16:03:14.504]         base::sink(type = "output", split = FALSE)
[16:03:14.504]         if (TRUE) {
[16:03:14.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.504]         }
[16:03:14.504]         else {
[16:03:14.504]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.504]         }
[16:03:14.504]         base::close(...future.stdout)
[16:03:14.504]         ...future.stdout <- NULL
[16:03:14.504]     }
[16:03:14.504]     ...future.result$conditions <- ...future.conditions
[16:03:14.504]     ...future.result$finished <- base::Sys.time()
[16:03:14.504]     ...future.result
[16:03:14.504] }
[16:03:14.507] assign_globals() ...
[16:03:14.507] List of 5
[16:03:14.507]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[16:03:14.507]  $ future.call.arguments    : list()
[16:03:14.507]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.507]  $ ...future.elements_ii    :List of 3
[16:03:14.507]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:03:14.507]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:03:14.507]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:03:14.507]  $ ...future.seeds_ii       : NULL
[16:03:14.507]  $ ...future.globals.maxSize: NULL
[16:03:14.507]  - attr(*, "where")=List of 5
[16:03:14.507]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.507]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.507]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.507]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.507]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.507]  - attr(*, "resolved")= logi FALSE
[16:03:14.507]  - attr(*, "total_size")= num 46960
[16:03:14.507]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.507]  - attr(*, "already-done")= logi TRUE
[16:03:14.517] - copied ‘...future.FUN’ to environment
[16:03:14.517] - copied ‘future.call.arguments’ to environment
[16:03:14.518] - copied ‘...future.elements_ii’ to environment
[16:03:14.518] - copied ‘...future.seeds_ii’ to environment
[16:03:14.518] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.518] assign_globals() ... done
[16:03:14.518] requestCore(): workers = 2
[16:03:14.521] MulticoreFuture started
[16:03:14.521] - Launch lazy future ... done
[16:03:14.521] run() for ‘MulticoreFuture’ ... done
[16:03:14.522] Created future:
[16:03:14.522] plan(): Setting new future strategy stack:
[16:03:14.522] List of future strategies:
[16:03:14.522] 1. sequential:
[16:03:14.522]    - args: function (..., envir = parent.frame())
[16:03:14.522]    - tweaked: FALSE
[16:03:14.522]    - call: NULL
[16:03:14.524] plan(): nbrOfWorkers() = 1
[16:03:14.526] plan(): Setting new future strategy stack:
[16:03:14.526] List of future strategies:
[16:03:14.526] 1. multicore:
[16:03:14.526]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.526]    - tweaked: FALSE
[16:03:14.526]    - call: plan(strategy)
[16:03:14.531] plan(): nbrOfWorkers() = 2
[16:03:14.522] MulticoreFuture:
[16:03:14.522] Label: ‘future_sapply-2’
[16:03:14.522] Expression:
[16:03:14.522] {
[16:03:14.522]     do.call(function(...) {
[16:03:14.522]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.522]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.522]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.522]             on.exit(options(oopts), add = TRUE)
[16:03:14.522]         }
[16:03:14.522]         {
[16:03:14.522]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.522]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.522]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.522]             })
[16:03:14.522]         }
[16:03:14.522]     }, args = future.call.arguments)
[16:03:14.522] }
[16:03:14.522] Lazy evaluation: FALSE
[16:03:14.522] Asynchronous evaluation: TRUE
[16:03:14.522] Local evaluation: TRUE
[16:03:14.522] Environment: R_GlobalEnv
[16:03:14.522] Capture standard output: TRUE
[16:03:14.522] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.522] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:14.522] Packages: 1 packages (‘stats’)
[16:03:14.522] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.522] Resolved: TRUE
[16:03:14.522] Value: <not collected>
[16:03:14.522] Conditions captured: <none>
[16:03:14.522] Early signaling: FALSE
[16:03:14.522] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.522] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.532] Chunk #2 of 2 ... DONE
[16:03:14.532] Launching 2 futures (chunks) ... DONE
[16:03:14.533] Resolving 2 futures (chunks) ...
[16:03:14.533] resolve() on list ...
[16:03:14.533]  recursive: 0
[16:03:14.533]  length: 2
[16:03:14.533] 
[16:03:14.534] Future #1
[16:03:14.534] result() for MulticoreFuture ...
[16:03:14.535] result() for MulticoreFuture ...
[16:03:14.535] result() for MulticoreFuture ... done
[16:03:14.535] result() for MulticoreFuture ... done
[16:03:14.535] result() for MulticoreFuture ...
[16:03:14.535] result() for MulticoreFuture ... done
[16:03:14.536] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:14.536] - nx: 2
[16:03:14.536] - relay: TRUE
[16:03:14.536] - stdout: TRUE
[16:03:14.536] - signal: TRUE
[16:03:14.536] - resignal: FALSE
[16:03:14.536] - force: TRUE
[16:03:14.537] - relayed: [n=2] FALSE, FALSE
[16:03:14.537] - queued futures: [n=2] FALSE, FALSE
[16:03:14.537]  - until=1
[16:03:14.537]  - relaying element #1
[16:03:14.537] result() for MulticoreFuture ...
[16:03:14.537] result() for MulticoreFuture ... done
[16:03:14.538] result() for MulticoreFuture ...
[16:03:14.538] result() for MulticoreFuture ... done
[16:03:14.538] result() for MulticoreFuture ...
[16:03:14.538] result() for MulticoreFuture ... done
[16:03:14.538] result() for MulticoreFuture ...
[16:03:14.538] result() for MulticoreFuture ... done
[16:03:14.539] - relayed: [n=2] TRUE, FALSE
[16:03:14.539] - queued futures: [n=2] TRUE, FALSE
[16:03:14.539] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:14.539]  length: 1 (resolved future 1)
[16:03:14.539] Future #2
[16:03:14.540] result() for MulticoreFuture ...
[16:03:14.540] result() for MulticoreFuture ...
[16:03:14.540] result() for MulticoreFuture ... done
[16:03:14.541] result() for MulticoreFuture ... done
[16:03:14.541] result() for MulticoreFuture ...
[16:03:14.541] result() for MulticoreFuture ... done
[16:03:14.541] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:14.541] - nx: 2
[16:03:14.541] - relay: TRUE
[16:03:14.541] - stdout: TRUE
[16:03:14.542] - signal: TRUE
[16:03:14.542] - resignal: FALSE
[16:03:14.542] - force: TRUE
[16:03:14.542] - relayed: [n=2] TRUE, FALSE
[16:03:14.542] - queued futures: [n=2] TRUE, FALSE
[16:03:14.542]  - until=2
[16:03:14.542]  - relaying element #2
[16:03:14.542] result() for MulticoreFuture ...
[16:03:14.543] result() for MulticoreFuture ... done
[16:03:14.543] result() for MulticoreFuture ...
[16:03:14.543] result() for MulticoreFuture ... done
[16:03:14.543] result() for MulticoreFuture ...
[16:03:14.543] result() for MulticoreFuture ... done
[16:03:14.543] result() for MulticoreFuture ...
[16:03:14.543] result() for MulticoreFuture ... done
[16:03:14.543] - relayed: [n=2] TRUE, TRUE
[16:03:14.544] - queued futures: [n=2] TRUE, TRUE
[16:03:14.544] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:14.544]  length: 0 (resolved future 2)
[16:03:14.544] Relaying remaining futures
[16:03:14.544] signalConditionsASAP(NULL, pos=0) ...
[16:03:14.544] - nx: 2
[16:03:14.544] - relay: TRUE
[16:03:14.544] - stdout: TRUE
[16:03:14.544] - signal: TRUE
[16:03:14.545] - resignal: FALSE
[16:03:14.545] - force: TRUE
[16:03:14.545] - relayed: [n=2] TRUE, TRUE
[16:03:14.545] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:14.545] - relayed: [n=2] TRUE, TRUE
[16:03:14.545] - queued futures: [n=2] TRUE, TRUE
[16:03:14.545] signalConditionsASAP(NULL, pos=0) ... done
[16:03:14.545] resolve() on list ... DONE
[16:03:14.548] result() for MulticoreFuture ...
[16:03:14.548] result() for MulticoreFuture ... done
[16:03:14.549] result() for MulticoreFuture ...
[16:03:14.549] result() for MulticoreFuture ... done
[16:03:14.549] result() for MulticoreFuture ...
[16:03:14.549] result() for MulticoreFuture ... done
[16:03:14.549] result() for MulticoreFuture ...
[16:03:14.549] result() for MulticoreFuture ... done
[16:03:14.550]  - Number of value chunks collected: 2
[16:03:14.550] Resolving 2 futures (chunks) ... DONE
[16:03:14.550] Reducing values from 2 chunks ...
[16:03:14.550]  - Number of values collected after concatenation: 7
[16:03:14.550]  - Number of values expected: 7
[16:03:14.550] Reducing values from 2 chunks ... DONE
[16:03:14.551] future_lapply() ... DONE
[16:03:14.551] future_lapply() ...
[16:03:14.558] Number of chunks: 2
[16:03:14.559] getGlobalsAndPackagesXApply() ...
[16:03:14.559]  - future.globals: TRUE
[16:03:14.559] getGlobalsAndPackages() ...
[16:03:14.559] Searching for globals...
[16:03:14.566] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:03:14.567] Searching for globals ... DONE
[16:03:14.567] Resolving globals: FALSE
[16:03:14.568] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[16:03:14.568] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[16:03:14.569] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.569] - packages: [2] ‘stats’, ‘future.apply’
[16:03:14.569] getGlobalsAndPackages() ... DONE
[16:03:14.569]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.569]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:03:14.569] Finding globals ... DONE
[16:03:14.569]  - use_args: TRUE
[16:03:14.569]  - Getting '...' globals ...
[16:03:14.571] resolve() on list ...
[16:03:14.572]  recursive: 0
[16:03:14.572]  length: 1
[16:03:14.572]  elements: ‘...’
[16:03:14.572]  length: 0 (resolved future 1)
[16:03:14.572] resolve() on list ... DONE
[16:03:14.572]    - '...' content: [n=0] 
[16:03:14.572] List of 1
[16:03:14.572]  $ ...: list()
[16:03:14.572]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.572]  - attr(*, "where")=List of 1
[16:03:14.572]   ..$ ...:<environment: 0x564e42ba76d0> 
[16:03:14.572]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.572]  - attr(*, "resolved")= logi TRUE
[16:03:14.572]  - attr(*, "total_size")= num NA
[16:03:14.575]  - Getting '...' globals ... DONE
[16:03:14.575] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:14.576] List of 8
[16:03:14.576]  $ ...future.FUN:function (x, ...)  
[16:03:14.576]  $ x_FUN        :function (x, na.rm = TRUE)  
[16:03:14.576]  $ times        : int 5
[16:03:14.576]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.576]  $ stop_if_not  :function (...)  
[16:03:14.576]  $ dim          : NULL
[16:03:14.576]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:14.576]  $ ...          : list()
[16:03:14.576]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.576]  - attr(*, "where")=List of 8
[16:03:14.576]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:14.576]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:14.576]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:14.576]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:14.576]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:14.576]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:14.576]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:14.576]   ..$ ...          :<environment: 0x564e42ba76d0> 
[16:03:14.576]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.576]  - attr(*, "resolved")= logi FALSE
[16:03:14.576]  - attr(*, "total_size")= num 141240
[16:03:14.581] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:03:14.581] getGlobalsAndPackagesXApply() ... DONE
[16:03:14.581] Number of futures (= number of chunks): 2
[16:03:14.582] Launching 2 futures (chunks) ...
[16:03:14.582] Chunk #1 of 2 ...
[16:03:14.582]  - Finding globals in 'X' for chunk #1 ...
[16:03:14.582] getGlobalsAndPackages() ...
[16:03:14.582] Searching for globals...
[16:03:14.582] 
[16:03:14.582] Searching for globals ... DONE
[16:03:14.582] - globals: [0] <none>
[16:03:14.582] getGlobalsAndPackages() ... DONE
[16:03:14.583]    + additional globals found: [n=0] 
[16:03:14.583]    + additional namespaces needed: [n=0] 
[16:03:14.583]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:14.583]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.583]  - seeds: <none>
[16:03:14.583]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.583] getGlobalsAndPackages() ...
[16:03:14.583] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.583] Resolving globals: FALSE
[16:03:14.583] Tweak future expression to call with '...' arguments ...
[16:03:14.584] {
[16:03:14.584]     do.call(function(...) {
[16:03:14.584]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.584]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.584]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.584]             on.exit(options(oopts), add = TRUE)
[16:03:14.584]         }
[16:03:14.584]         {
[16:03:14.584]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.584]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.584]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.584]             })
[16:03:14.584]         }
[16:03:14.584]     }, args = future.call.arguments)
[16:03:14.584] }
[16:03:14.584] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.584] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.584] - packages: [2] ‘stats’, ‘future.apply’
[16:03:14.585] getGlobalsAndPackages() ... DONE
[16:03:14.585] run() for ‘Future’ ...
[16:03:14.585] - state: ‘created’
[16:03:14.585] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.589] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.589]   - Field: ‘label’
[16:03:14.589]   - Field: ‘local’
[16:03:14.589]   - Field: ‘owner’
[16:03:14.589]   - Field: ‘envir’
[16:03:14.589]   - Field: ‘workers’
[16:03:14.590]   - Field: ‘packages’
[16:03:14.590]   - Field: ‘gc’
[16:03:14.590]   - Field: ‘job’
[16:03:14.590]   - Field: ‘conditions’
[16:03:14.590]   - Field: ‘expr’
[16:03:14.590]   - Field: ‘uuid’
[16:03:14.590]   - Field: ‘seed’
[16:03:14.590]   - Field: ‘version’
[16:03:14.590]   - Field: ‘result’
[16:03:14.590]   - Field: ‘asynchronous’
[16:03:14.590]   - Field: ‘calls’
[16:03:14.591]   - Field: ‘globals’
[16:03:14.591]   - Field: ‘stdout’
[16:03:14.591]   - Field: ‘earlySignal’
[16:03:14.592]   - Field: ‘lazy’
[16:03:14.593]   - Field: ‘state’
[16:03:14.593] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.593] - Launch lazy future ...
[16:03:14.593] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:03:14.593] Packages needed by future strategies (n = 0): <none>
[16:03:14.594] {
[16:03:14.594]     {
[16:03:14.594]         {
[16:03:14.594]             ...future.startTime <- base::Sys.time()
[16:03:14.594]             {
[16:03:14.594]                 {
[16:03:14.594]                   {
[16:03:14.594]                     {
[16:03:14.594]                       {
[16:03:14.594]                         base::local({
[16:03:14.594]                           has_future <- base::requireNamespace("future", 
[16:03:14.594]                             quietly = TRUE)
[16:03:14.594]                           if (has_future) {
[16:03:14.594]                             ns <- base::getNamespace("future")
[16:03:14.594]                             version <- ns[[".package"]][["version"]]
[16:03:14.594]                             if (is.null(version)) 
[16:03:14.594]                               version <- utils::packageVersion("future")
[16:03:14.594]                           }
[16:03:14.594]                           else {
[16:03:14.594]                             version <- NULL
[16:03:14.594]                           }
[16:03:14.594]                           if (!has_future || version < "1.8.0") {
[16:03:14.594]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.594]                               "", base::R.version$version.string), 
[16:03:14.594]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.594]                                 base::R.version$platform, 8 * 
[16:03:14.594]                                   base::.Machine$sizeof.pointer), 
[16:03:14.594]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.594]                                 "release", "version")], collapse = " "), 
[16:03:14.594]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.594]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.594]                               info)
[16:03:14.594]                             info <- base::paste(info, collapse = "; ")
[16:03:14.594]                             if (!has_future) {
[16:03:14.594]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.594]                                 info)
[16:03:14.594]                             }
[16:03:14.594]                             else {
[16:03:14.594]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.594]                                 info, version)
[16:03:14.594]                             }
[16:03:14.594]                             base::stop(msg)
[16:03:14.594]                           }
[16:03:14.594]                         })
[16:03:14.594]                       }
[16:03:14.594]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.594]                       base::options(mc.cores = 1L)
[16:03:14.594]                     }
[16:03:14.594]                     base::local({
[16:03:14.594]                       for (pkg in c("stats", "future.apply")) {
[16:03:14.594]                         base::loadNamespace(pkg)
[16:03:14.594]                         base::library(pkg, character.only = TRUE)
[16:03:14.594]                       }
[16:03:14.594]                     })
[16:03:14.594]                   }
[16:03:14.594]                   options(future.plan = NULL)
[16:03:14.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.594]                 }
[16:03:14.594]                 ...future.workdir <- getwd()
[16:03:14.594]             }
[16:03:14.594]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.594]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.594]         }
[16:03:14.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.594]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.594]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.594]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.594]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.594]             base::names(...future.oldOptions))
[16:03:14.594]     }
[16:03:14.594]     if (FALSE) {
[16:03:14.594]     }
[16:03:14.594]     else {
[16:03:14.594]         if (TRUE) {
[16:03:14.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.594]                 open = "w")
[16:03:14.594]         }
[16:03:14.594]         else {
[16:03:14.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.594]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.594]         }
[16:03:14.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.594]             base::sink(type = "output", split = FALSE)
[16:03:14.594]             base::close(...future.stdout)
[16:03:14.594]         }, add = TRUE)
[16:03:14.594]     }
[16:03:14.594]     ...future.frame <- base::sys.nframe()
[16:03:14.594]     ...future.conditions <- base::list()
[16:03:14.594]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.594]     if (FALSE) {
[16:03:14.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.594]     }
[16:03:14.594]     ...future.result <- base::tryCatch({
[16:03:14.594]         base::withCallingHandlers({
[16:03:14.594]             ...future.value <- base::withVisible(base::local({
[16:03:14.594]                 withCallingHandlers({
[16:03:14.594]                   {
[16:03:14.594]                     do.call(function(...) {
[16:03:14.594]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.594]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.594]                         ...future.globals.maxSize)) {
[16:03:14.594]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.594]                         on.exit(options(oopts), add = TRUE)
[16:03:14.594]                       }
[16:03:14.594]                       {
[16:03:14.594]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.594]                           FUN = function(jj) {
[16:03:14.594]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.594]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.594]                           })
[16:03:14.594]                       }
[16:03:14.594]                     }, args = future.call.arguments)
[16:03:14.594]                   }
[16:03:14.594]                 }, immediateCondition = function(cond) {
[16:03:14.594]                   save_rds <- function (object, pathname, ...) 
[16:03:14.594]                   {
[16:03:14.594]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.594]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.594]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.594]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.594]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.594]                         fi_tmp[["mtime"]])
[16:03:14.594]                     }
[16:03:14.594]                     tryCatch({
[16:03:14.594]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.594]                     }, error = function(ex) {
[16:03:14.594]                       msg <- conditionMessage(ex)
[16:03:14.594]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.594]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.594]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.594]                         fi_tmp[["mtime"]], msg)
[16:03:14.594]                       ex$message <- msg
[16:03:14.594]                       stop(ex)
[16:03:14.594]                     })
[16:03:14.594]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.594]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.594]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.594]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.594]                       fi <- file.info(pathname)
[16:03:14.594]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.594]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.594]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.594]                         fi[["size"]], fi[["mtime"]])
[16:03:14.594]                       stop(msg)
[16:03:14.594]                     }
[16:03:14.594]                     invisible(pathname)
[16:03:14.594]                   }
[16:03:14.594]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.594]                     rootPath = tempdir()) 
[16:03:14.594]                   {
[16:03:14.594]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.594]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.594]                       tmpdir = path, fileext = ".rds")
[16:03:14.594]                     save_rds(obj, file)
[16:03:14.594]                   }
[16:03:14.594]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.594]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.594]                   {
[16:03:14.594]                     inherits <- base::inherits
[16:03:14.594]                     invokeRestart <- base::invokeRestart
[16:03:14.594]                     is.null <- base::is.null
[16:03:14.594]                     muffled <- FALSE
[16:03:14.594]                     if (inherits(cond, "message")) {
[16:03:14.594]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.594]                       if (muffled) 
[16:03:14.594]                         invokeRestart("muffleMessage")
[16:03:14.594]                     }
[16:03:14.594]                     else if (inherits(cond, "warning")) {
[16:03:14.594]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.594]                       if (muffled) 
[16:03:14.594]                         invokeRestart("muffleWarning")
[16:03:14.594]                     }
[16:03:14.594]                     else if (inherits(cond, "condition")) {
[16:03:14.594]                       if (!is.null(pattern)) {
[16:03:14.594]                         computeRestarts <- base::computeRestarts
[16:03:14.594]                         grepl <- base::grepl
[16:03:14.594]                         restarts <- computeRestarts(cond)
[16:03:14.594]                         for (restart in restarts) {
[16:03:14.594]                           name <- restart$name
[16:03:14.594]                           if (is.null(name)) 
[16:03:14.594]                             next
[16:03:14.594]                           if (!grepl(pattern, name)) 
[16:03:14.594]                             next
[16:03:14.594]                           invokeRestart(restart)
[16:03:14.594]                           muffled <- TRUE
[16:03:14.594]                           break
[16:03:14.594]                         }
[16:03:14.594]                       }
[16:03:14.594]                     }
[16:03:14.594]                     invisible(muffled)
[16:03:14.594]                   }
[16:03:14.594]                   muffleCondition(cond)
[16:03:14.594]                 })
[16:03:14.594]             }))
[16:03:14.594]             future::FutureResult(value = ...future.value$value, 
[16:03:14.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.594]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.594]                     ...future.globalenv.names))
[16:03:14.594]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.594]         }, condition = base::local({
[16:03:14.594]             c <- base::c
[16:03:14.594]             inherits <- base::inherits
[16:03:14.594]             invokeRestart <- base::invokeRestart
[16:03:14.594]             length <- base::length
[16:03:14.594]             list <- base::list
[16:03:14.594]             seq.int <- base::seq.int
[16:03:14.594]             signalCondition <- base::signalCondition
[16:03:14.594]             sys.calls <- base::sys.calls
[16:03:14.594]             `[[` <- base::`[[`
[16:03:14.594]             `+` <- base::`+`
[16:03:14.594]             `<<-` <- base::`<<-`
[16:03:14.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.594]                   3L)]
[16:03:14.594]             }
[16:03:14.594]             function(cond) {
[16:03:14.594]                 is_error <- inherits(cond, "error")
[16:03:14.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.594]                   NULL)
[16:03:14.594]                 if (is_error) {
[16:03:14.594]                   sessionInformation <- function() {
[16:03:14.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.594]                       search = base::search(), system = base::Sys.info())
[16:03:14.594]                   }
[16:03:14.594]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.594]                     cond$call), session = sessionInformation(), 
[16:03:14.594]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.594]                   signalCondition(cond)
[16:03:14.594]                 }
[16:03:14.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.594]                 "immediateCondition"))) {
[16:03:14.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.594]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.594]                   if (TRUE && !signal) {
[16:03:14.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.594]                     {
[16:03:14.594]                       inherits <- base::inherits
[16:03:14.594]                       invokeRestart <- base::invokeRestart
[16:03:14.594]                       is.null <- base::is.null
[16:03:14.594]                       muffled <- FALSE
[16:03:14.594]                       if (inherits(cond, "message")) {
[16:03:14.594]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.594]                         if (muffled) 
[16:03:14.594]                           invokeRestart("muffleMessage")
[16:03:14.594]                       }
[16:03:14.594]                       else if (inherits(cond, "warning")) {
[16:03:14.594]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.594]                         if (muffled) 
[16:03:14.594]                           invokeRestart("muffleWarning")
[16:03:14.594]                       }
[16:03:14.594]                       else if (inherits(cond, "condition")) {
[16:03:14.594]                         if (!is.null(pattern)) {
[16:03:14.594]                           computeRestarts <- base::computeRestarts
[16:03:14.594]                           grepl <- base::grepl
[16:03:14.594]                           restarts <- computeRestarts(cond)
[16:03:14.594]                           for (restart in restarts) {
[16:03:14.594]                             name <- restart$name
[16:03:14.594]                             if (is.null(name)) 
[16:03:14.594]                               next
[16:03:14.594]                             if (!grepl(pattern, name)) 
[16:03:14.594]                               next
[16:03:14.594]                             invokeRestart(restart)
[16:03:14.594]                             muffled <- TRUE
[16:03:14.594]                             break
[16:03:14.594]                           }
[16:03:14.594]                         }
[16:03:14.594]                       }
[16:03:14.594]                       invisible(muffled)
[16:03:14.594]                     }
[16:03:14.594]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.594]                   }
[16:03:14.594]                 }
[16:03:14.594]                 else {
[16:03:14.594]                   if (TRUE) {
[16:03:14.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.594]                     {
[16:03:14.594]                       inherits <- base::inherits
[16:03:14.594]                       invokeRestart <- base::invokeRestart
[16:03:14.594]                       is.null <- base::is.null
[16:03:14.594]                       muffled <- FALSE
[16:03:14.594]                       if (inherits(cond, "message")) {
[16:03:14.594]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.594]                         if (muffled) 
[16:03:14.594]                           invokeRestart("muffleMessage")
[16:03:14.594]                       }
[16:03:14.594]                       else if (inherits(cond, "warning")) {
[16:03:14.594]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.594]                         if (muffled) 
[16:03:14.594]                           invokeRestart("muffleWarning")
[16:03:14.594]                       }
[16:03:14.594]                       else if (inherits(cond, "condition")) {
[16:03:14.594]                         if (!is.null(pattern)) {
[16:03:14.594]                           computeRestarts <- base::computeRestarts
[16:03:14.594]                           grepl <- base::grepl
[16:03:14.594]                           restarts <- computeRestarts(cond)
[16:03:14.594]                           for (restart in restarts) {
[16:03:14.594]                             name <- restart$name
[16:03:14.594]                             if (is.null(name)) 
[16:03:14.594]                               next
[16:03:14.594]                             if (!grepl(pattern, name)) 
[16:03:14.594]                               next
[16:03:14.594]                             invokeRestart(restart)
[16:03:14.594]                             muffled <- TRUE
[16:03:14.594]                             break
[16:03:14.594]                           }
[16:03:14.594]                         }
[16:03:14.594]                       }
[16:03:14.594]                       invisible(muffled)
[16:03:14.594]                     }
[16:03:14.594]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.594]                   }
[16:03:14.594]                 }
[16:03:14.594]             }
[16:03:14.594]         }))
[16:03:14.594]     }, error = function(ex) {
[16:03:14.594]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.594]                 ...future.rng), started = ...future.startTime, 
[16:03:14.594]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.594]             version = "1.8"), class = "FutureResult")
[16:03:14.594]     }, finally = {
[16:03:14.594]         if (!identical(...future.workdir, getwd())) 
[16:03:14.594]             setwd(...future.workdir)
[16:03:14.594]         {
[16:03:14.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.594]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.594]             }
[16:03:14.594]             base::options(...future.oldOptions)
[16:03:14.594]             if (.Platform$OS.type == "windows") {
[16:03:14.594]                 old_names <- names(...future.oldEnvVars)
[16:03:14.594]                 envs <- base::Sys.getenv()
[16:03:14.594]                 names <- names(envs)
[16:03:14.594]                 common <- intersect(names, old_names)
[16:03:14.594]                 added <- setdiff(names, old_names)
[16:03:14.594]                 removed <- setdiff(old_names, names)
[16:03:14.594]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.594]                   envs[common]]
[16:03:14.594]                 NAMES <- toupper(changed)
[16:03:14.594]                 args <- list()
[16:03:14.594]                 for (kk in seq_along(NAMES)) {
[16:03:14.594]                   name <- changed[[kk]]
[16:03:14.594]                   NAME <- NAMES[[kk]]
[16:03:14.594]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.594]                     next
[16:03:14.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.594]                 }
[16:03:14.594]                 NAMES <- toupper(added)
[16:03:14.594]                 for (kk in seq_along(NAMES)) {
[16:03:14.594]                   name <- added[[kk]]
[16:03:14.594]                   NAME <- NAMES[[kk]]
[16:03:14.594]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.594]                     next
[16:03:14.594]                   args[[name]] <- ""
[16:03:14.594]                 }
[16:03:14.594]                 NAMES <- toupper(removed)
[16:03:14.594]                 for (kk in seq_along(NAMES)) {
[16:03:14.594]                   name <- removed[[kk]]
[16:03:14.594]                   NAME <- NAMES[[kk]]
[16:03:14.594]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.594]                     next
[16:03:14.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.594]                 }
[16:03:14.594]                 if (length(args) > 0) 
[16:03:14.594]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.594]             }
[16:03:14.594]             else {
[16:03:14.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.594]             }
[16:03:14.594]             {
[16:03:14.594]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.594]                   0L) {
[16:03:14.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.594]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.594]                   base::options(opts)
[16:03:14.594]                 }
[16:03:14.594]                 {
[16:03:14.594]                   {
[16:03:14.594]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.594]                     NULL
[16:03:14.594]                   }
[16:03:14.594]                   options(future.plan = NULL)
[16:03:14.594]                   if (is.na(NA_character_)) 
[16:03:14.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.594]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.594]                     envir = parent.frame()) 
[16:03:14.594]                   {
[16:03:14.594]                     default_workers <- missing(workers)
[16:03:14.594]                     if (is.function(workers)) 
[16:03:14.594]                       workers <- workers()
[16:03:14.594]                     workers <- structure(as.integer(workers), 
[16:03:14.594]                       class = class(workers))
[16:03:14.594]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.594]                       1L)
[16:03:14.594]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.594]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.594]                       if (default_workers) 
[16:03:14.594]                         supportsMulticore(warn = TRUE)
[16:03:14.594]                       return(sequential(..., envir = envir))
[16:03:14.594]                     }
[16:03:14.594]                     oopts <- options(mc.cores = workers)
[16:03:14.594]                     on.exit(options(oopts))
[16:03:14.594]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.594]                       envir = envir)
[16:03:14.594]                     if (!future$lazy) 
[16:03:14.594]                       future <- run(future)
[16:03:14.594]                     invisible(future)
[16:03:14.594]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.594]                 }
[16:03:14.594]             }
[16:03:14.594]         }
[16:03:14.594]     })
[16:03:14.594]     if (TRUE) {
[16:03:14.594]         base::sink(type = "output", split = FALSE)
[16:03:14.594]         if (TRUE) {
[16:03:14.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.594]         }
[16:03:14.594]         else {
[16:03:14.594]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.594]         }
[16:03:14.594]         base::close(...future.stdout)
[16:03:14.594]         ...future.stdout <- NULL
[16:03:14.594]     }
[16:03:14.594]     ...future.result$conditions <- ...future.conditions
[16:03:14.594]     ...future.result$finished <- base::Sys.time()
[16:03:14.594]     ...future.result
[16:03:14.594] }
[16:03:14.596] assign_globals() ...
[16:03:14.597] List of 11
[16:03:14.597]  $ ...future.FUN            :function (x, ...)  
[16:03:14.597]  $ x_FUN                    :function (x, na.rm = TRUE)  
[16:03:14.597]  $ times                    : int 5
[16:03:14.597]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.597]  $ stop_if_not              :function (...)  
[16:03:14.597]  $ dim                      : NULL
[16:03:14.597]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:14.597]  $ future.call.arguments    : list()
[16:03:14.597]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.597]  $ ...future.elements_ii    :List of 4
[16:03:14.597]   ..$ : int [1:3] 1 2 3
[16:03:14.597]   ..$ : int [1:4] 1 2 3 4
[16:03:14.597]   ..$ : int [1:5] 1 2 3 4 5
[16:03:14.597]   ..$ : int [1:6] 1 2 3 4 5 6
[16:03:14.597]  $ ...future.seeds_ii       : NULL
[16:03:14.597]  $ ...future.globals.maxSize: NULL
[16:03:14.597]  - attr(*, "where")=List of 11
[16:03:14.597]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.597]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:14.597]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:14.597]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:14.597]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:14.597]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:14.597]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:14.597]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.597]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.597]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.597]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.597]  - attr(*, "resolved")= logi FALSE
[16:03:14.597]  - attr(*, "total_size")= num 141240
[16:03:14.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.597]  - attr(*, "already-done")= logi TRUE
[16:03:14.605] - copied ‘...future.FUN’ to environment
[16:03:14.605] - copied ‘x_FUN’ to environment
[16:03:14.605] - copied ‘times’ to environment
[16:03:14.605] - copied ‘stopf’ to environment
[16:03:14.605] - copied ‘stop_if_not’ to environment
[16:03:14.605] - copied ‘dim’ to environment
[16:03:14.606] - copied ‘valid_types’ to environment
[16:03:14.606] - copied ‘future.call.arguments’ to environment
[16:03:14.606] - copied ‘...future.elements_ii’ to environment
[16:03:14.606] - copied ‘...future.seeds_ii’ to environment
[16:03:14.606] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.606] assign_globals() ... done
[16:03:14.606] requestCore(): workers = 2
[16:03:14.608] MulticoreFuture started
[16:03:14.609] - Launch lazy future ... done
[16:03:14.609] run() for ‘MulticoreFuture’ ... done
[16:03:14.609] Created future:
[16:03:14.610] plan(): Setting new future strategy stack:
[16:03:14.610] List of future strategies:
[16:03:14.610] 1. sequential:
[16:03:14.610]    - args: function (..., envir = parent.frame())
[16:03:14.610]    - tweaked: FALSE
[16:03:14.610]    - call: NULL
[16:03:14.611] plan(): nbrOfWorkers() = 1
[16:03:14.613] plan(): Setting new future strategy stack:
[16:03:14.613] List of future strategies:
[16:03:14.613] 1. multicore:
[16:03:14.613]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.613]    - tweaked: FALSE
[16:03:14.613]    - call: plan(strategy)
[16:03:14.618] plan(): nbrOfWorkers() = 2
[16:03:14.609] MulticoreFuture:
[16:03:14.609] Label: ‘future_vapply-1’
[16:03:14.609] Expression:
[16:03:14.609] {
[16:03:14.609]     do.call(function(...) {
[16:03:14.609]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.609]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.609]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.609]             on.exit(options(oopts), add = TRUE)
[16:03:14.609]         }
[16:03:14.609]         {
[16:03:14.609]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.609]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.609]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.609]             })
[16:03:14.609]         }
[16:03:14.609]     }, args = future.call.arguments)
[16:03:14.609] }
[16:03:14.609] Lazy evaluation: FALSE
[16:03:14.609] Asynchronous evaluation: TRUE
[16:03:14.609] Local evaluation: TRUE
[16:03:14.609] Environment: R_GlobalEnv
[16:03:14.609] Capture standard output: TRUE
[16:03:14.609] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.609] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:14.609] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:03:14.609] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.609] Resolved: TRUE
[16:03:14.609] Value: <not collected>
[16:03:14.609] Conditions captured: <none>
[16:03:14.609] Early signaling: FALSE
[16:03:14.609] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.609] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.619] Chunk #1 of 2 ... DONE
[16:03:14.620] Chunk #2 of 2 ...
[16:03:14.620]  - Finding globals in 'X' for chunk #2 ...
[16:03:14.620] getGlobalsAndPackages() ...
[16:03:14.620] Searching for globals...
[16:03:14.621] 
[16:03:14.621] Searching for globals ... DONE
[16:03:14.621] - globals: [0] <none>
[16:03:14.621] getGlobalsAndPackages() ... DONE
[16:03:14.621]    + additional globals found: [n=0] 
[16:03:14.621]    + additional namespaces needed: [n=0] 
[16:03:14.621]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:14.622]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.622]  - seeds: <none>
[16:03:14.622]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.622] getGlobalsAndPackages() ...
[16:03:14.622] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.622] Resolving globals: FALSE
[16:03:14.623] Tweak future expression to call with '...' arguments ...
[16:03:14.623] {
[16:03:14.623]     do.call(function(...) {
[16:03:14.623]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.623]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.623]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.623]             on.exit(options(oopts), add = TRUE)
[16:03:14.623]         }
[16:03:14.623]         {
[16:03:14.623]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.623]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.623]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.623]             })
[16:03:14.623]         }
[16:03:14.623]     }, args = future.call.arguments)
[16:03:14.623] }
[16:03:14.623] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.624] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.624] - packages: [2] ‘stats’, ‘future.apply’
[16:03:14.624] getGlobalsAndPackages() ... DONE
[16:03:14.628] run() for ‘Future’ ...
[16:03:14.628] - state: ‘created’
[16:03:14.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.635] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.636]   - Field: ‘label’
[16:03:14.636]   - Field: ‘local’
[16:03:14.636]   - Field: ‘owner’
[16:03:14.636]   - Field: ‘envir’
[16:03:14.637]   - Field: ‘workers’
[16:03:14.637]   - Field: ‘packages’
[16:03:14.637]   - Field: ‘gc’
[16:03:14.637]   - Field: ‘job’
[16:03:14.638]   - Field: ‘conditions’
[16:03:14.638]   - Field: ‘expr’
[16:03:14.638]   - Field: ‘uuid’
[16:03:14.638]   - Field: ‘seed’
[16:03:14.638]   - Field: ‘version’
[16:03:14.639]   - Field: ‘result’
[16:03:14.639]   - Field: ‘asynchronous’
[16:03:14.639]   - Field: ‘calls’
[16:03:14.639]   - Field: ‘globals’
[16:03:14.639]   - Field: ‘stdout’
[16:03:14.640]   - Field: ‘earlySignal’
[16:03:14.640]   - Field: ‘lazy’
[16:03:14.640]   - Field: ‘state’
[16:03:14.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.640] - Launch lazy future ...
[16:03:14.641] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:03:14.641] Packages needed by future strategies (n = 0): <none>
[16:03:14.642] {
[16:03:14.642]     {
[16:03:14.642]         {
[16:03:14.642]             ...future.startTime <- base::Sys.time()
[16:03:14.642]             {
[16:03:14.642]                 {
[16:03:14.642]                   {
[16:03:14.642]                     {
[16:03:14.642]                       {
[16:03:14.642]                         base::local({
[16:03:14.642]                           has_future <- base::requireNamespace("future", 
[16:03:14.642]                             quietly = TRUE)
[16:03:14.642]                           if (has_future) {
[16:03:14.642]                             ns <- base::getNamespace("future")
[16:03:14.642]                             version <- ns[[".package"]][["version"]]
[16:03:14.642]                             if (is.null(version)) 
[16:03:14.642]                               version <- utils::packageVersion("future")
[16:03:14.642]                           }
[16:03:14.642]                           else {
[16:03:14.642]                             version <- NULL
[16:03:14.642]                           }
[16:03:14.642]                           if (!has_future || version < "1.8.0") {
[16:03:14.642]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.642]                               "", base::R.version$version.string), 
[16:03:14.642]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.642]                                 base::R.version$platform, 8 * 
[16:03:14.642]                                   base::.Machine$sizeof.pointer), 
[16:03:14.642]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.642]                                 "release", "version")], collapse = " "), 
[16:03:14.642]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.642]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.642]                               info)
[16:03:14.642]                             info <- base::paste(info, collapse = "; ")
[16:03:14.642]                             if (!has_future) {
[16:03:14.642]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.642]                                 info)
[16:03:14.642]                             }
[16:03:14.642]                             else {
[16:03:14.642]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.642]                                 info, version)
[16:03:14.642]                             }
[16:03:14.642]                             base::stop(msg)
[16:03:14.642]                           }
[16:03:14.642]                         })
[16:03:14.642]                       }
[16:03:14.642]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.642]                       base::options(mc.cores = 1L)
[16:03:14.642]                     }
[16:03:14.642]                     base::local({
[16:03:14.642]                       for (pkg in c("stats", "future.apply")) {
[16:03:14.642]                         base::loadNamespace(pkg)
[16:03:14.642]                         base::library(pkg, character.only = TRUE)
[16:03:14.642]                       }
[16:03:14.642]                     })
[16:03:14.642]                   }
[16:03:14.642]                   options(future.plan = NULL)
[16:03:14.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.642]                 }
[16:03:14.642]                 ...future.workdir <- getwd()
[16:03:14.642]             }
[16:03:14.642]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.642]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.642]         }
[16:03:14.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.642]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.642]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.642]             base::names(...future.oldOptions))
[16:03:14.642]     }
[16:03:14.642]     if (FALSE) {
[16:03:14.642]     }
[16:03:14.642]     else {
[16:03:14.642]         if (TRUE) {
[16:03:14.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.642]                 open = "w")
[16:03:14.642]         }
[16:03:14.642]         else {
[16:03:14.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.642]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.642]         }
[16:03:14.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.642]             base::sink(type = "output", split = FALSE)
[16:03:14.642]             base::close(...future.stdout)
[16:03:14.642]         }, add = TRUE)
[16:03:14.642]     }
[16:03:14.642]     ...future.frame <- base::sys.nframe()
[16:03:14.642]     ...future.conditions <- base::list()
[16:03:14.642]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.642]     if (FALSE) {
[16:03:14.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.642]     }
[16:03:14.642]     ...future.result <- base::tryCatch({
[16:03:14.642]         base::withCallingHandlers({
[16:03:14.642]             ...future.value <- base::withVisible(base::local({
[16:03:14.642]                 withCallingHandlers({
[16:03:14.642]                   {
[16:03:14.642]                     do.call(function(...) {
[16:03:14.642]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.642]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.642]                         ...future.globals.maxSize)) {
[16:03:14.642]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.642]                         on.exit(options(oopts), add = TRUE)
[16:03:14.642]                       }
[16:03:14.642]                       {
[16:03:14.642]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.642]                           FUN = function(jj) {
[16:03:14.642]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.642]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.642]                           })
[16:03:14.642]                       }
[16:03:14.642]                     }, args = future.call.arguments)
[16:03:14.642]                   }
[16:03:14.642]                 }, immediateCondition = function(cond) {
[16:03:14.642]                   save_rds <- function (object, pathname, ...) 
[16:03:14.642]                   {
[16:03:14.642]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.642]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.642]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.642]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.642]                         fi_tmp[["mtime"]])
[16:03:14.642]                     }
[16:03:14.642]                     tryCatch({
[16:03:14.642]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.642]                     }, error = function(ex) {
[16:03:14.642]                       msg <- conditionMessage(ex)
[16:03:14.642]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.642]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.642]                         fi_tmp[["mtime"]], msg)
[16:03:14.642]                       ex$message <- msg
[16:03:14.642]                       stop(ex)
[16:03:14.642]                     })
[16:03:14.642]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.642]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.642]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.642]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.642]                       fi <- file.info(pathname)
[16:03:14.642]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.642]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.642]                         fi[["size"]], fi[["mtime"]])
[16:03:14.642]                       stop(msg)
[16:03:14.642]                     }
[16:03:14.642]                     invisible(pathname)
[16:03:14.642]                   }
[16:03:14.642]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.642]                     rootPath = tempdir()) 
[16:03:14.642]                   {
[16:03:14.642]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.642]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.642]                       tmpdir = path, fileext = ".rds")
[16:03:14.642]                     save_rds(obj, file)
[16:03:14.642]                   }
[16:03:14.642]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.642]                   {
[16:03:14.642]                     inherits <- base::inherits
[16:03:14.642]                     invokeRestart <- base::invokeRestart
[16:03:14.642]                     is.null <- base::is.null
[16:03:14.642]                     muffled <- FALSE
[16:03:14.642]                     if (inherits(cond, "message")) {
[16:03:14.642]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.642]                       if (muffled) 
[16:03:14.642]                         invokeRestart("muffleMessage")
[16:03:14.642]                     }
[16:03:14.642]                     else if (inherits(cond, "warning")) {
[16:03:14.642]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.642]                       if (muffled) 
[16:03:14.642]                         invokeRestart("muffleWarning")
[16:03:14.642]                     }
[16:03:14.642]                     else if (inherits(cond, "condition")) {
[16:03:14.642]                       if (!is.null(pattern)) {
[16:03:14.642]                         computeRestarts <- base::computeRestarts
[16:03:14.642]                         grepl <- base::grepl
[16:03:14.642]                         restarts <- computeRestarts(cond)
[16:03:14.642]                         for (restart in restarts) {
[16:03:14.642]                           name <- restart$name
[16:03:14.642]                           if (is.null(name)) 
[16:03:14.642]                             next
[16:03:14.642]                           if (!grepl(pattern, name)) 
[16:03:14.642]                             next
[16:03:14.642]                           invokeRestart(restart)
[16:03:14.642]                           muffled <- TRUE
[16:03:14.642]                           break
[16:03:14.642]                         }
[16:03:14.642]                       }
[16:03:14.642]                     }
[16:03:14.642]                     invisible(muffled)
[16:03:14.642]                   }
[16:03:14.642]                   muffleCondition(cond)
[16:03:14.642]                 })
[16:03:14.642]             }))
[16:03:14.642]             future::FutureResult(value = ...future.value$value, 
[16:03:14.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.642]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.642]                     ...future.globalenv.names))
[16:03:14.642]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.642]         }, condition = base::local({
[16:03:14.642]             c <- base::c
[16:03:14.642]             inherits <- base::inherits
[16:03:14.642]             invokeRestart <- base::invokeRestart
[16:03:14.642]             length <- base::length
[16:03:14.642]             list <- base::list
[16:03:14.642]             seq.int <- base::seq.int
[16:03:14.642]             signalCondition <- base::signalCondition
[16:03:14.642]             sys.calls <- base::sys.calls
[16:03:14.642]             `[[` <- base::`[[`
[16:03:14.642]             `+` <- base::`+`
[16:03:14.642]             `<<-` <- base::`<<-`
[16:03:14.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.642]                   3L)]
[16:03:14.642]             }
[16:03:14.642]             function(cond) {
[16:03:14.642]                 is_error <- inherits(cond, "error")
[16:03:14.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.642]                   NULL)
[16:03:14.642]                 if (is_error) {
[16:03:14.642]                   sessionInformation <- function() {
[16:03:14.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.642]                       search = base::search(), system = base::Sys.info())
[16:03:14.642]                   }
[16:03:14.642]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.642]                     cond$call), session = sessionInformation(), 
[16:03:14.642]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.642]                   signalCondition(cond)
[16:03:14.642]                 }
[16:03:14.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.642]                 "immediateCondition"))) {
[16:03:14.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.642]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.642]                   if (TRUE && !signal) {
[16:03:14.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.642]                     {
[16:03:14.642]                       inherits <- base::inherits
[16:03:14.642]                       invokeRestart <- base::invokeRestart
[16:03:14.642]                       is.null <- base::is.null
[16:03:14.642]                       muffled <- FALSE
[16:03:14.642]                       if (inherits(cond, "message")) {
[16:03:14.642]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.642]                         if (muffled) 
[16:03:14.642]                           invokeRestart("muffleMessage")
[16:03:14.642]                       }
[16:03:14.642]                       else if (inherits(cond, "warning")) {
[16:03:14.642]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.642]                         if (muffled) 
[16:03:14.642]                           invokeRestart("muffleWarning")
[16:03:14.642]                       }
[16:03:14.642]                       else if (inherits(cond, "condition")) {
[16:03:14.642]                         if (!is.null(pattern)) {
[16:03:14.642]                           computeRestarts <- base::computeRestarts
[16:03:14.642]                           grepl <- base::grepl
[16:03:14.642]                           restarts <- computeRestarts(cond)
[16:03:14.642]                           for (restart in restarts) {
[16:03:14.642]                             name <- restart$name
[16:03:14.642]                             if (is.null(name)) 
[16:03:14.642]                               next
[16:03:14.642]                             if (!grepl(pattern, name)) 
[16:03:14.642]                               next
[16:03:14.642]                             invokeRestart(restart)
[16:03:14.642]                             muffled <- TRUE
[16:03:14.642]                             break
[16:03:14.642]                           }
[16:03:14.642]                         }
[16:03:14.642]                       }
[16:03:14.642]                       invisible(muffled)
[16:03:14.642]                     }
[16:03:14.642]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.642]                   }
[16:03:14.642]                 }
[16:03:14.642]                 else {
[16:03:14.642]                   if (TRUE) {
[16:03:14.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.642]                     {
[16:03:14.642]                       inherits <- base::inherits
[16:03:14.642]                       invokeRestart <- base::invokeRestart
[16:03:14.642]                       is.null <- base::is.null
[16:03:14.642]                       muffled <- FALSE
[16:03:14.642]                       if (inherits(cond, "message")) {
[16:03:14.642]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.642]                         if (muffled) 
[16:03:14.642]                           invokeRestart("muffleMessage")
[16:03:14.642]                       }
[16:03:14.642]                       else if (inherits(cond, "warning")) {
[16:03:14.642]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.642]                         if (muffled) 
[16:03:14.642]                           invokeRestart("muffleWarning")
[16:03:14.642]                       }
[16:03:14.642]                       else if (inherits(cond, "condition")) {
[16:03:14.642]                         if (!is.null(pattern)) {
[16:03:14.642]                           computeRestarts <- base::computeRestarts
[16:03:14.642]                           grepl <- base::grepl
[16:03:14.642]                           restarts <- computeRestarts(cond)
[16:03:14.642]                           for (restart in restarts) {
[16:03:14.642]                             name <- restart$name
[16:03:14.642]                             if (is.null(name)) 
[16:03:14.642]                               next
[16:03:14.642]                             if (!grepl(pattern, name)) 
[16:03:14.642]                               next
[16:03:14.642]                             invokeRestart(restart)
[16:03:14.642]                             muffled <- TRUE
[16:03:14.642]                             break
[16:03:14.642]                           }
[16:03:14.642]                         }
[16:03:14.642]                       }
[16:03:14.642]                       invisible(muffled)
[16:03:14.642]                     }
[16:03:14.642]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.642]                   }
[16:03:14.642]                 }
[16:03:14.642]             }
[16:03:14.642]         }))
[16:03:14.642]     }, error = function(ex) {
[16:03:14.642]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.642]                 ...future.rng), started = ...future.startTime, 
[16:03:14.642]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.642]             version = "1.8"), class = "FutureResult")
[16:03:14.642]     }, finally = {
[16:03:14.642]         if (!identical(...future.workdir, getwd())) 
[16:03:14.642]             setwd(...future.workdir)
[16:03:14.642]         {
[16:03:14.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.642]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.642]             }
[16:03:14.642]             base::options(...future.oldOptions)
[16:03:14.642]             if (.Platform$OS.type == "windows") {
[16:03:14.642]                 old_names <- names(...future.oldEnvVars)
[16:03:14.642]                 envs <- base::Sys.getenv()
[16:03:14.642]                 names <- names(envs)
[16:03:14.642]                 common <- intersect(names, old_names)
[16:03:14.642]                 added <- setdiff(names, old_names)
[16:03:14.642]                 removed <- setdiff(old_names, names)
[16:03:14.642]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.642]                   envs[common]]
[16:03:14.642]                 NAMES <- toupper(changed)
[16:03:14.642]                 args <- list()
[16:03:14.642]                 for (kk in seq_along(NAMES)) {
[16:03:14.642]                   name <- changed[[kk]]
[16:03:14.642]                   NAME <- NAMES[[kk]]
[16:03:14.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.642]                     next
[16:03:14.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.642]                 }
[16:03:14.642]                 NAMES <- toupper(added)
[16:03:14.642]                 for (kk in seq_along(NAMES)) {
[16:03:14.642]                   name <- added[[kk]]
[16:03:14.642]                   NAME <- NAMES[[kk]]
[16:03:14.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.642]                     next
[16:03:14.642]                   args[[name]] <- ""
[16:03:14.642]                 }
[16:03:14.642]                 NAMES <- toupper(removed)
[16:03:14.642]                 for (kk in seq_along(NAMES)) {
[16:03:14.642]                   name <- removed[[kk]]
[16:03:14.642]                   NAME <- NAMES[[kk]]
[16:03:14.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.642]                     next
[16:03:14.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.642]                 }
[16:03:14.642]                 if (length(args) > 0) 
[16:03:14.642]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.642]             }
[16:03:14.642]             else {
[16:03:14.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.642]             }
[16:03:14.642]             {
[16:03:14.642]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.642]                   0L) {
[16:03:14.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.642]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.642]                   base::options(opts)
[16:03:14.642]                 }
[16:03:14.642]                 {
[16:03:14.642]                   {
[16:03:14.642]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.642]                     NULL
[16:03:14.642]                   }
[16:03:14.642]                   options(future.plan = NULL)
[16:03:14.642]                   if (is.na(NA_character_)) 
[16:03:14.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.642]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.642]                     envir = parent.frame()) 
[16:03:14.642]                   {
[16:03:14.642]                     default_workers <- missing(workers)
[16:03:14.642]                     if (is.function(workers)) 
[16:03:14.642]                       workers <- workers()
[16:03:14.642]                     workers <- structure(as.integer(workers), 
[16:03:14.642]                       class = class(workers))
[16:03:14.642]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.642]                       1L)
[16:03:14.642]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.642]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.642]                       if (default_workers) 
[16:03:14.642]                         supportsMulticore(warn = TRUE)
[16:03:14.642]                       return(sequential(..., envir = envir))
[16:03:14.642]                     }
[16:03:14.642]                     oopts <- options(mc.cores = workers)
[16:03:14.642]                     on.exit(options(oopts))
[16:03:14.642]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.642]                       envir = envir)
[16:03:14.642]                     if (!future$lazy) 
[16:03:14.642]                       future <- run(future)
[16:03:14.642]                     invisible(future)
[16:03:14.642]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.642]                 }
[16:03:14.642]             }
[16:03:14.642]         }
[16:03:14.642]     })
[16:03:14.642]     if (TRUE) {
[16:03:14.642]         base::sink(type = "output", split = FALSE)
[16:03:14.642]         if (TRUE) {
[16:03:14.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.642]         }
[16:03:14.642]         else {
[16:03:14.642]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.642]         }
[16:03:14.642]         base::close(...future.stdout)
[16:03:14.642]         ...future.stdout <- NULL
[16:03:14.642]     }
[16:03:14.642]     ...future.result$conditions <- ...future.conditions
[16:03:14.642]     ...future.result$finished <- base::Sys.time()
[16:03:14.642]     ...future.result
[16:03:14.642] }
[16:03:14.645] assign_globals() ...
[16:03:14.645] List of 11
[16:03:14.645]  $ ...future.FUN            :function (x, ...)  
[16:03:14.645]  $ x_FUN                    :function (x, na.rm = TRUE)  
[16:03:14.645]  $ times                    : int 5
[16:03:14.645]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.645]  $ stop_if_not              :function (...)  
[16:03:14.645]  $ dim                      : NULL
[16:03:14.645]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:14.645]  $ future.call.arguments    : list()
[16:03:14.645]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.645]  $ ...future.elements_ii    :List of 3
[16:03:14.645]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:03:14.645]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:03:14.645]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:03:14.645]  $ ...future.seeds_ii       : NULL
[16:03:14.645]  $ ...future.globals.maxSize: NULL
[16:03:14.645]  - attr(*, "where")=List of 11
[16:03:14.645]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.645]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:14.645]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:14.645]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:14.645]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:14.645]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:14.645]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:14.645]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.645]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.645]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.645]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.645]  - attr(*, "resolved")= logi FALSE
[16:03:14.645]  - attr(*, "total_size")= num 141240
[16:03:14.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.645]  - attr(*, "already-done")= logi TRUE
[16:03:14.656] - copied ‘...future.FUN’ to environment
[16:03:14.656] - copied ‘x_FUN’ to environment
[16:03:14.656] - copied ‘times’ to environment
[16:03:14.656] - copied ‘stopf’ to environment
[16:03:14.656] - copied ‘stop_if_not’ to environment
[16:03:14.656] - copied ‘dim’ to environment
[16:03:14.656] - copied ‘valid_types’ to environment
[16:03:14.656] - copied ‘future.call.arguments’ to environment
[16:03:14.657] - copied ‘...future.elements_ii’ to environment
[16:03:14.657] - copied ‘...future.seeds_ii’ to environment
[16:03:14.657] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.657] assign_globals() ... done
[16:03:14.657] requestCore(): workers = 2
[16:03:14.659] MulticoreFuture started
[16:03:14.660] - Launch lazy future ... done
[16:03:14.660] run() for ‘MulticoreFuture’ ... done
[16:03:14.660] Created future:
[16:03:14.661] plan(): Setting new future strategy stack:
[16:03:14.661] List of future strategies:
[16:03:14.661] 1. sequential:
[16:03:14.661]    - args: function (..., envir = parent.frame())
[16:03:14.661]    - tweaked: FALSE
[16:03:14.661]    - call: NULL
[16:03:14.662] plan(): nbrOfWorkers() = 1
[16:03:14.671] plan(): Setting new future strategy stack:
[16:03:14.672] List of future strategies:
[16:03:14.672] 1. multicore:
[16:03:14.672]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.672]    - tweaked: FALSE
[16:03:14.672]    - call: plan(strategy)
[16:03:14.676] plan(): nbrOfWorkers() = 2
[16:03:14.660] MulticoreFuture:
[16:03:14.660] Label: ‘future_vapply-2’
[16:03:14.660] Expression:
[16:03:14.660] {
[16:03:14.660]     do.call(function(...) {
[16:03:14.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.660]             on.exit(options(oopts), add = TRUE)
[16:03:14.660]         }
[16:03:14.660]         {
[16:03:14.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.660]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.660]             })
[16:03:14.660]         }
[16:03:14.660]     }, args = future.call.arguments)
[16:03:14.660] }
[16:03:14.660] Lazy evaluation: FALSE
[16:03:14.660] Asynchronous evaluation: TRUE
[16:03:14.660] Local evaluation: TRUE
[16:03:14.660] Environment: R_GlobalEnv
[16:03:14.660] Capture standard output: TRUE
[16:03:14.660] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.660] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:14.660] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:03:14.660] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.660] Resolved: TRUE
[16:03:14.660] Value: <not collected>
[16:03:14.660] Conditions captured: <none>
[16:03:14.660] Early signaling: FALSE
[16:03:14.660] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.660] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.677] Chunk #2 of 2 ... DONE
[16:03:14.678] Launching 2 futures (chunks) ... DONE
[16:03:14.678] Resolving 2 futures (chunks) ...
[16:03:14.678] resolve() on list ...
[16:03:14.678]  recursive: 0
[16:03:14.678]  length: 2
[16:03:14.678] 
[16:03:14.678] Future #1
[16:03:14.679] result() for MulticoreFuture ...
[16:03:14.680] result() for MulticoreFuture ...
[16:03:14.680] result() for MulticoreFuture ... done
[16:03:14.680] result() for MulticoreFuture ... done
[16:03:14.680] result() for MulticoreFuture ...
[16:03:14.680] result() for MulticoreFuture ... done
[16:03:14.681] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:14.681] - nx: 2
[16:03:14.681] - relay: TRUE
[16:03:14.681] - stdout: TRUE
[16:03:14.681] - signal: TRUE
[16:03:14.682] - resignal: FALSE
[16:03:14.682] - force: TRUE
[16:03:14.682] - relayed: [n=2] FALSE, FALSE
[16:03:14.682] - queued futures: [n=2] FALSE, FALSE
[16:03:14.682]  - until=1
[16:03:14.683]  - relaying element #1
[16:03:14.683] result() for MulticoreFuture ...
[16:03:14.683] result() for MulticoreFuture ... done
[16:03:14.683] result() for MulticoreFuture ...
[16:03:14.683] result() for MulticoreFuture ... done
[16:03:14.684] result() for MulticoreFuture ...
[16:03:14.684] result() for MulticoreFuture ... done
[16:03:14.684] result() for MulticoreFuture ...
[16:03:14.684] result() for MulticoreFuture ... done
[16:03:14.684] - relayed: [n=2] TRUE, FALSE
[16:03:14.685] - queued futures: [n=2] TRUE, FALSE
[16:03:14.685] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:14.685]  length: 1 (resolved future 1)
[16:03:14.685] Future #2
[16:03:14.686] result() for MulticoreFuture ...
[16:03:14.686] result() for MulticoreFuture ...
[16:03:14.687] result() for MulticoreFuture ... done
[16:03:14.687] result() for MulticoreFuture ... done
[16:03:14.687] result() for MulticoreFuture ...
[16:03:14.687] result() for MulticoreFuture ... done
[16:03:14.688] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:14.688] - nx: 2
[16:03:14.688] - relay: TRUE
[16:03:14.688] - stdout: TRUE
[16:03:14.688] - signal: TRUE
[16:03:14.688] - resignal: FALSE
[16:03:14.688] - force: TRUE
[16:03:14.689] - relayed: [n=2] TRUE, FALSE
[16:03:14.689] - queued futures: [n=2] TRUE, FALSE
[16:03:14.689]  - until=2
[16:03:14.689]  - relaying element #2
[16:03:14.689] result() for MulticoreFuture ...
[16:03:14.689] result() for MulticoreFuture ... done
[16:03:14.689] result() for MulticoreFuture ...
[16:03:14.689] result() for MulticoreFuture ... done
[16:03:14.690] result() for MulticoreFuture ...
[16:03:14.690] result() for MulticoreFuture ... done
[16:03:14.690] result() for MulticoreFuture ...
[16:03:14.690] result() for MulticoreFuture ... done
[16:03:14.690] - relayed: [n=2] TRUE, TRUE
[16:03:14.690] - queued futures: [n=2] TRUE, TRUE
[16:03:14.690] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:14.690]  length: 0 (resolved future 2)
[16:03:14.691] Relaying remaining futures
[16:03:14.691] signalConditionsASAP(NULL, pos=0) ...
[16:03:14.691] - nx: 2
[16:03:14.691] - relay: TRUE
[16:03:14.691] - stdout: TRUE
[16:03:14.691] - signal: TRUE
[16:03:14.691] - resignal: FALSE
[16:03:14.691] - force: TRUE
[16:03:14.691] - relayed: [n=2] TRUE, TRUE
[16:03:14.691] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:14.692] - relayed: [n=2] TRUE, TRUE
[16:03:14.692] - queued futures: [n=2] TRUE, TRUE
[16:03:14.692] signalConditionsASAP(NULL, pos=0) ... done
[16:03:14.692] resolve() on list ... DONE
[16:03:14.692] result() for MulticoreFuture ...
[16:03:14.692] result() for MulticoreFuture ... done
[16:03:14.692] result() for MulticoreFuture ...
[16:03:14.692] result() for MulticoreFuture ... done
[16:03:14.693] result() for MulticoreFuture ...
[16:03:14.693] result() for MulticoreFuture ... done
[16:03:14.693] result() for MulticoreFuture ...
[16:03:14.693] result() for MulticoreFuture ... done
[16:03:14.693]  - Number of value chunks collected: 2
[16:03:14.693] Resolving 2 futures (chunks) ... DONE
[16:03:14.693] Reducing values from 2 chunks ...
[16:03:14.693]  - Number of values collected after concatenation: 7
[16:03:14.693]  - Number of values expected: 7
[16:03:14.694] Reducing values from 2 chunks ... DONE
[16:03:14.694] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[16:03:14.696] future_lapply() ...
[16:03:14.701] Number of chunks: 2
[16:03:14.701] getGlobalsAndPackagesXApply() ...
[16:03:14.701]  - future.globals: TRUE
[16:03:14.701] getGlobalsAndPackages() ...
[16:03:14.701] Searching for globals...
[16:03:14.702] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[16:03:14.702] Searching for globals ... DONE
[16:03:14.703] Resolving globals: FALSE
[16:03:14.703] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[16:03:14.703] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[16:03:14.704] - globals: [1] ‘FUN’
[16:03:14.704] 
[16:03:14.704] getGlobalsAndPackages() ... DONE
[16:03:14.704]  - globals found/used: [n=1] ‘FUN’
[16:03:14.704]  - needed namespaces: [n=0] 
[16:03:14.704] Finding globals ... DONE
[16:03:14.704]  - use_args: TRUE
[16:03:14.704]  - Getting '...' globals ...
[16:03:14.705] resolve() on list ...
[16:03:14.705]  recursive: 0
[16:03:14.705]  length: 1
[16:03:14.705]  elements: ‘...’
[16:03:14.705]  length: 0 (resolved future 1)
[16:03:14.705] resolve() on list ... DONE
[16:03:14.705]    - '...' content: [n=1] ‘y’
[16:03:14.705] List of 1
[16:03:14.705]  $ ...:List of 1
[16:03:14.705]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:14.705]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.705]  - attr(*, "where")=List of 1
[16:03:14.705]   ..$ ...:<environment: 0x564e41527290> 
[16:03:14.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.705]  - attr(*, "resolved")= logi TRUE
[16:03:14.705]  - attr(*, "total_size")= num NA
[16:03:14.711]  - Getting '...' globals ... DONE
[16:03:14.711] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:14.711] List of 2
[16:03:14.711]  $ ...future.FUN:function (x, y)  
[16:03:14.711]  $ ...          :List of 1
[16:03:14.711]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:14.711]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.711]  - attr(*, "where")=List of 2
[16:03:14.711]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:14.711]   ..$ ...          :<environment: 0x564e41527290> 
[16:03:14.711]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.711]  - attr(*, "resolved")= logi FALSE
[16:03:14.711]  - attr(*, "total_size")= num 4264
[16:03:14.714] Packages to be attached in all futures: [n=0] 
[16:03:14.715] getGlobalsAndPackagesXApply() ... DONE
[16:03:14.715] Number of futures (= number of chunks): 2
[16:03:14.715] Launching 2 futures (chunks) ...
[16:03:14.715] Chunk #1 of 2 ...
[16:03:14.715]  - Finding globals in 'X' for chunk #1 ...
[16:03:14.715] getGlobalsAndPackages() ...
[16:03:14.715] Searching for globals...
[16:03:14.716] 
[16:03:14.716] Searching for globals ... DONE
[16:03:14.716] - globals: [0] <none>
[16:03:14.716] getGlobalsAndPackages() ... DONE
[16:03:14.716]    + additional globals found: [n=0] 
[16:03:14.716]    + additional namespaces needed: [n=0] 
[16:03:14.716]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:14.716]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.716]  - seeds: <none>
[16:03:14.716]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.717] getGlobalsAndPackages() ...
[16:03:14.717] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.717] Resolving globals: FALSE
[16:03:14.717] Tweak future expression to call with '...' arguments ...
[16:03:14.717] {
[16:03:14.717]     do.call(function(...) {
[16:03:14.717]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.717]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.717]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.717]             on.exit(options(oopts), add = TRUE)
[16:03:14.717]         }
[16:03:14.717]         {
[16:03:14.717]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.717]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.717]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.717]             })
[16:03:14.717]         }
[16:03:14.717]     }, args = future.call.arguments)
[16:03:14.717] }
[16:03:14.717] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.718] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.718] 
[16:03:14.718] getGlobalsAndPackages() ... DONE
[16:03:14.718] run() for ‘Future’ ...
[16:03:14.718] - state: ‘created’
[16:03:14.718] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.722] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.723]   - Field: ‘label’
[16:03:14.723]   - Field: ‘local’
[16:03:14.723]   - Field: ‘owner’
[16:03:14.723]   - Field: ‘envir’
[16:03:14.723]   - Field: ‘workers’
[16:03:14.723]   - Field: ‘packages’
[16:03:14.723]   - Field: ‘gc’
[16:03:14.723]   - Field: ‘job’
[16:03:14.724]   - Field: ‘conditions’
[16:03:14.724]   - Field: ‘expr’
[16:03:14.724]   - Field: ‘uuid’
[16:03:14.724]   - Field: ‘seed’
[16:03:14.724]   - Field: ‘version’
[16:03:14.724]   - Field: ‘result’
[16:03:14.724]   - Field: ‘asynchronous’
[16:03:14.724]   - Field: ‘calls’
[16:03:14.724]   - Field: ‘globals’
[16:03:14.724]   - Field: ‘stdout’
[16:03:14.725]   - Field: ‘earlySignal’
[16:03:14.725]   - Field: ‘lazy’
[16:03:14.725]   - Field: ‘state’
[16:03:14.725] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.725] - Launch lazy future ...
[16:03:14.725] Packages needed by the future expression (n = 0): <none>
[16:03:14.725] Packages needed by future strategies (n = 0): <none>
[16:03:14.726] {
[16:03:14.726]     {
[16:03:14.726]         {
[16:03:14.726]             ...future.startTime <- base::Sys.time()
[16:03:14.726]             {
[16:03:14.726]                 {
[16:03:14.726]                   {
[16:03:14.726]                     {
[16:03:14.726]                       base::local({
[16:03:14.726]                         has_future <- base::requireNamespace("future", 
[16:03:14.726]                           quietly = TRUE)
[16:03:14.726]                         if (has_future) {
[16:03:14.726]                           ns <- base::getNamespace("future")
[16:03:14.726]                           version <- ns[[".package"]][["version"]]
[16:03:14.726]                           if (is.null(version)) 
[16:03:14.726]                             version <- utils::packageVersion("future")
[16:03:14.726]                         }
[16:03:14.726]                         else {
[16:03:14.726]                           version <- NULL
[16:03:14.726]                         }
[16:03:14.726]                         if (!has_future || version < "1.8.0") {
[16:03:14.726]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.726]                             "", base::R.version$version.string), 
[16:03:14.726]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:14.726]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:14.726]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.726]                               "release", "version")], collapse = " "), 
[16:03:14.726]                             hostname = base::Sys.info()[["nodename"]])
[16:03:14.726]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.726]                             info)
[16:03:14.726]                           info <- base::paste(info, collapse = "; ")
[16:03:14.726]                           if (!has_future) {
[16:03:14.726]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.726]                               info)
[16:03:14.726]                           }
[16:03:14.726]                           else {
[16:03:14.726]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.726]                               info, version)
[16:03:14.726]                           }
[16:03:14.726]                           base::stop(msg)
[16:03:14.726]                         }
[16:03:14.726]                       })
[16:03:14.726]                     }
[16:03:14.726]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.726]                     base::options(mc.cores = 1L)
[16:03:14.726]                   }
[16:03:14.726]                   options(future.plan = NULL)
[16:03:14.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.726]                 }
[16:03:14.726]                 ...future.workdir <- getwd()
[16:03:14.726]             }
[16:03:14.726]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.726]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.726]         }
[16:03:14.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.726]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.726]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.726]             base::names(...future.oldOptions))
[16:03:14.726]     }
[16:03:14.726]     if (FALSE) {
[16:03:14.726]     }
[16:03:14.726]     else {
[16:03:14.726]         if (TRUE) {
[16:03:14.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.726]                 open = "w")
[16:03:14.726]         }
[16:03:14.726]         else {
[16:03:14.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.726]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.726]         }
[16:03:14.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.726]             base::sink(type = "output", split = FALSE)
[16:03:14.726]             base::close(...future.stdout)
[16:03:14.726]         }, add = TRUE)
[16:03:14.726]     }
[16:03:14.726]     ...future.frame <- base::sys.nframe()
[16:03:14.726]     ...future.conditions <- base::list()
[16:03:14.726]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.726]     if (FALSE) {
[16:03:14.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.726]     }
[16:03:14.726]     ...future.result <- base::tryCatch({
[16:03:14.726]         base::withCallingHandlers({
[16:03:14.726]             ...future.value <- base::withVisible(base::local({
[16:03:14.726]                 withCallingHandlers({
[16:03:14.726]                   {
[16:03:14.726]                     do.call(function(...) {
[16:03:14.726]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.726]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.726]                         ...future.globals.maxSize)) {
[16:03:14.726]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.726]                         on.exit(options(oopts), add = TRUE)
[16:03:14.726]                       }
[16:03:14.726]                       {
[16:03:14.726]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.726]                           FUN = function(jj) {
[16:03:14.726]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.726]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.726]                           })
[16:03:14.726]                       }
[16:03:14.726]                     }, args = future.call.arguments)
[16:03:14.726]                   }
[16:03:14.726]                 }, immediateCondition = function(cond) {
[16:03:14.726]                   save_rds <- function (object, pathname, ...) 
[16:03:14.726]                   {
[16:03:14.726]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.726]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.726]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.726]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.726]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.726]                         fi_tmp[["mtime"]])
[16:03:14.726]                     }
[16:03:14.726]                     tryCatch({
[16:03:14.726]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.726]                     }, error = function(ex) {
[16:03:14.726]                       msg <- conditionMessage(ex)
[16:03:14.726]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.726]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.726]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.726]                         fi_tmp[["mtime"]], msg)
[16:03:14.726]                       ex$message <- msg
[16:03:14.726]                       stop(ex)
[16:03:14.726]                     })
[16:03:14.726]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.726]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.726]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.726]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.726]                       fi <- file.info(pathname)
[16:03:14.726]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.726]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.726]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.726]                         fi[["size"]], fi[["mtime"]])
[16:03:14.726]                       stop(msg)
[16:03:14.726]                     }
[16:03:14.726]                     invisible(pathname)
[16:03:14.726]                   }
[16:03:14.726]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.726]                     rootPath = tempdir()) 
[16:03:14.726]                   {
[16:03:14.726]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.726]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.726]                       tmpdir = path, fileext = ".rds")
[16:03:14.726]                     save_rds(obj, file)
[16:03:14.726]                   }
[16:03:14.726]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.726]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.726]                   {
[16:03:14.726]                     inherits <- base::inherits
[16:03:14.726]                     invokeRestart <- base::invokeRestart
[16:03:14.726]                     is.null <- base::is.null
[16:03:14.726]                     muffled <- FALSE
[16:03:14.726]                     if (inherits(cond, "message")) {
[16:03:14.726]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.726]                       if (muffled) 
[16:03:14.726]                         invokeRestart("muffleMessage")
[16:03:14.726]                     }
[16:03:14.726]                     else if (inherits(cond, "warning")) {
[16:03:14.726]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.726]                       if (muffled) 
[16:03:14.726]                         invokeRestart("muffleWarning")
[16:03:14.726]                     }
[16:03:14.726]                     else if (inherits(cond, "condition")) {
[16:03:14.726]                       if (!is.null(pattern)) {
[16:03:14.726]                         computeRestarts <- base::computeRestarts
[16:03:14.726]                         grepl <- base::grepl
[16:03:14.726]                         restarts <- computeRestarts(cond)
[16:03:14.726]                         for (restart in restarts) {
[16:03:14.726]                           name <- restart$name
[16:03:14.726]                           if (is.null(name)) 
[16:03:14.726]                             next
[16:03:14.726]                           if (!grepl(pattern, name)) 
[16:03:14.726]                             next
[16:03:14.726]                           invokeRestart(restart)
[16:03:14.726]                           muffled <- TRUE
[16:03:14.726]                           break
[16:03:14.726]                         }
[16:03:14.726]                       }
[16:03:14.726]                     }
[16:03:14.726]                     invisible(muffled)
[16:03:14.726]                   }
[16:03:14.726]                   muffleCondition(cond)
[16:03:14.726]                 })
[16:03:14.726]             }))
[16:03:14.726]             future::FutureResult(value = ...future.value$value, 
[16:03:14.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.726]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.726]                     ...future.globalenv.names))
[16:03:14.726]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.726]         }, condition = base::local({
[16:03:14.726]             c <- base::c
[16:03:14.726]             inherits <- base::inherits
[16:03:14.726]             invokeRestart <- base::invokeRestart
[16:03:14.726]             length <- base::length
[16:03:14.726]             list <- base::list
[16:03:14.726]             seq.int <- base::seq.int
[16:03:14.726]             signalCondition <- base::signalCondition
[16:03:14.726]             sys.calls <- base::sys.calls
[16:03:14.726]             `[[` <- base::`[[`
[16:03:14.726]             `+` <- base::`+`
[16:03:14.726]             `<<-` <- base::`<<-`
[16:03:14.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.726]                   3L)]
[16:03:14.726]             }
[16:03:14.726]             function(cond) {
[16:03:14.726]                 is_error <- inherits(cond, "error")
[16:03:14.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.726]                   NULL)
[16:03:14.726]                 if (is_error) {
[16:03:14.726]                   sessionInformation <- function() {
[16:03:14.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.726]                       search = base::search(), system = base::Sys.info())
[16:03:14.726]                   }
[16:03:14.726]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.726]                     cond$call), session = sessionInformation(), 
[16:03:14.726]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.726]                   signalCondition(cond)
[16:03:14.726]                 }
[16:03:14.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.726]                 "immediateCondition"))) {
[16:03:14.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.726]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.726]                   if (TRUE && !signal) {
[16:03:14.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.726]                     {
[16:03:14.726]                       inherits <- base::inherits
[16:03:14.726]                       invokeRestart <- base::invokeRestart
[16:03:14.726]                       is.null <- base::is.null
[16:03:14.726]                       muffled <- FALSE
[16:03:14.726]                       if (inherits(cond, "message")) {
[16:03:14.726]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.726]                         if (muffled) 
[16:03:14.726]                           invokeRestart("muffleMessage")
[16:03:14.726]                       }
[16:03:14.726]                       else if (inherits(cond, "warning")) {
[16:03:14.726]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.726]                         if (muffled) 
[16:03:14.726]                           invokeRestart("muffleWarning")
[16:03:14.726]                       }
[16:03:14.726]                       else if (inherits(cond, "condition")) {
[16:03:14.726]                         if (!is.null(pattern)) {
[16:03:14.726]                           computeRestarts <- base::computeRestarts
[16:03:14.726]                           grepl <- base::grepl
[16:03:14.726]                           restarts <- computeRestarts(cond)
[16:03:14.726]                           for (restart in restarts) {
[16:03:14.726]                             name <- restart$name
[16:03:14.726]                             if (is.null(name)) 
[16:03:14.726]                               next
[16:03:14.726]                             if (!grepl(pattern, name)) 
[16:03:14.726]                               next
[16:03:14.726]                             invokeRestart(restart)
[16:03:14.726]                             muffled <- TRUE
[16:03:14.726]                             break
[16:03:14.726]                           }
[16:03:14.726]                         }
[16:03:14.726]                       }
[16:03:14.726]                       invisible(muffled)
[16:03:14.726]                     }
[16:03:14.726]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.726]                   }
[16:03:14.726]                 }
[16:03:14.726]                 else {
[16:03:14.726]                   if (TRUE) {
[16:03:14.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.726]                     {
[16:03:14.726]                       inherits <- base::inherits
[16:03:14.726]                       invokeRestart <- base::invokeRestart
[16:03:14.726]                       is.null <- base::is.null
[16:03:14.726]                       muffled <- FALSE
[16:03:14.726]                       if (inherits(cond, "message")) {
[16:03:14.726]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.726]                         if (muffled) 
[16:03:14.726]                           invokeRestart("muffleMessage")
[16:03:14.726]                       }
[16:03:14.726]                       else if (inherits(cond, "warning")) {
[16:03:14.726]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.726]                         if (muffled) 
[16:03:14.726]                           invokeRestart("muffleWarning")
[16:03:14.726]                       }
[16:03:14.726]                       else if (inherits(cond, "condition")) {
[16:03:14.726]                         if (!is.null(pattern)) {
[16:03:14.726]                           computeRestarts <- base::computeRestarts
[16:03:14.726]                           grepl <- base::grepl
[16:03:14.726]                           restarts <- computeRestarts(cond)
[16:03:14.726]                           for (restart in restarts) {
[16:03:14.726]                             name <- restart$name
[16:03:14.726]                             if (is.null(name)) 
[16:03:14.726]                               next
[16:03:14.726]                             if (!grepl(pattern, name)) 
[16:03:14.726]                               next
[16:03:14.726]                             invokeRestart(restart)
[16:03:14.726]                             muffled <- TRUE
[16:03:14.726]                             break
[16:03:14.726]                           }
[16:03:14.726]                         }
[16:03:14.726]                       }
[16:03:14.726]                       invisible(muffled)
[16:03:14.726]                     }
[16:03:14.726]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.726]                   }
[16:03:14.726]                 }
[16:03:14.726]             }
[16:03:14.726]         }))
[16:03:14.726]     }, error = function(ex) {
[16:03:14.726]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.726]                 ...future.rng), started = ...future.startTime, 
[16:03:14.726]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.726]             version = "1.8"), class = "FutureResult")
[16:03:14.726]     }, finally = {
[16:03:14.726]         if (!identical(...future.workdir, getwd())) 
[16:03:14.726]             setwd(...future.workdir)
[16:03:14.726]         {
[16:03:14.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.726]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.726]             }
[16:03:14.726]             base::options(...future.oldOptions)
[16:03:14.726]             if (.Platform$OS.type == "windows") {
[16:03:14.726]                 old_names <- names(...future.oldEnvVars)
[16:03:14.726]                 envs <- base::Sys.getenv()
[16:03:14.726]                 names <- names(envs)
[16:03:14.726]                 common <- intersect(names, old_names)
[16:03:14.726]                 added <- setdiff(names, old_names)
[16:03:14.726]                 removed <- setdiff(old_names, names)
[16:03:14.726]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.726]                   envs[common]]
[16:03:14.726]                 NAMES <- toupper(changed)
[16:03:14.726]                 args <- list()
[16:03:14.726]                 for (kk in seq_along(NAMES)) {
[16:03:14.726]                   name <- changed[[kk]]
[16:03:14.726]                   NAME <- NAMES[[kk]]
[16:03:14.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.726]                     next
[16:03:14.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.726]                 }
[16:03:14.726]                 NAMES <- toupper(added)
[16:03:14.726]                 for (kk in seq_along(NAMES)) {
[16:03:14.726]                   name <- added[[kk]]
[16:03:14.726]                   NAME <- NAMES[[kk]]
[16:03:14.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.726]                     next
[16:03:14.726]                   args[[name]] <- ""
[16:03:14.726]                 }
[16:03:14.726]                 NAMES <- toupper(removed)
[16:03:14.726]                 for (kk in seq_along(NAMES)) {
[16:03:14.726]                   name <- removed[[kk]]
[16:03:14.726]                   NAME <- NAMES[[kk]]
[16:03:14.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.726]                     next
[16:03:14.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.726]                 }
[16:03:14.726]                 if (length(args) > 0) 
[16:03:14.726]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.726]             }
[16:03:14.726]             else {
[16:03:14.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.726]             }
[16:03:14.726]             {
[16:03:14.726]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.726]                   0L) {
[16:03:14.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.726]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.726]                   base::options(opts)
[16:03:14.726]                 }
[16:03:14.726]                 {
[16:03:14.726]                   {
[16:03:14.726]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.726]                     NULL
[16:03:14.726]                   }
[16:03:14.726]                   options(future.plan = NULL)
[16:03:14.726]                   if (is.na(NA_character_)) 
[16:03:14.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.726]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.726]                     envir = parent.frame()) 
[16:03:14.726]                   {
[16:03:14.726]                     default_workers <- missing(workers)
[16:03:14.726]                     if (is.function(workers)) 
[16:03:14.726]                       workers <- workers()
[16:03:14.726]                     workers <- structure(as.integer(workers), 
[16:03:14.726]                       class = class(workers))
[16:03:14.726]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.726]                       1L)
[16:03:14.726]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.726]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.726]                       if (default_workers) 
[16:03:14.726]                         supportsMulticore(warn = TRUE)
[16:03:14.726]                       return(sequential(..., envir = envir))
[16:03:14.726]                     }
[16:03:14.726]                     oopts <- options(mc.cores = workers)
[16:03:14.726]                     on.exit(options(oopts))
[16:03:14.726]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.726]                       envir = envir)
[16:03:14.726]                     if (!future$lazy) 
[16:03:14.726]                       future <- run(future)
[16:03:14.726]                     invisible(future)
[16:03:14.726]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.726]                 }
[16:03:14.726]             }
[16:03:14.726]         }
[16:03:14.726]     })
[16:03:14.726]     if (TRUE) {
[16:03:14.726]         base::sink(type = "output", split = FALSE)
[16:03:14.726]         if (TRUE) {
[16:03:14.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.726]         }
[16:03:14.726]         else {
[16:03:14.726]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.726]         }
[16:03:14.726]         base::close(...future.stdout)
[16:03:14.726]         ...future.stdout <- NULL
[16:03:14.726]     }
[16:03:14.726]     ...future.result$conditions <- ...future.conditions
[16:03:14.726]     ...future.result$finished <- base::Sys.time()
[16:03:14.726]     ...future.result
[16:03:14.726] }
[16:03:14.728] assign_globals() ...
[16:03:14.728] List of 5
[16:03:14.728]  $ ...future.FUN            :function (x, y)  
[16:03:14.728]  $ future.call.arguments    :List of 1
[16:03:14.728]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:14.728]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.728]  $ ...future.elements_ii    :List of 2
[16:03:14.728]   ..$ A: num 50
[16:03:14.728]   ..$ B: num 60
[16:03:14.728]  $ ...future.seeds_ii       : NULL
[16:03:14.728]  $ ...future.globals.maxSize: NULL
[16:03:14.728]  - attr(*, "where")=List of 5
[16:03:14.728]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.728]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.728]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.728]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.728]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.728]  - attr(*, "resolved")= logi FALSE
[16:03:14.728]  - attr(*, "total_size")= num 4264
[16:03:14.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.728]  - attr(*, "already-done")= logi TRUE
[16:03:14.736] - reassign environment for ‘...future.FUN’
[16:03:14.736] - copied ‘...future.FUN’ to environment
[16:03:14.736] - copied ‘future.call.arguments’ to environment
[16:03:14.736] - copied ‘...future.elements_ii’ to environment
[16:03:14.736] - copied ‘...future.seeds_ii’ to environment
[16:03:14.736] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.737] assign_globals() ... done
[16:03:14.737] requestCore(): workers = 2
[16:03:14.739] MulticoreFuture started
[16:03:14.740] - Launch lazy future ... done
[16:03:14.740] run() for ‘MulticoreFuture’ ... done
[16:03:14.741] plan(): Setting new future strategy stack:
[16:03:14.741] Created future:
[16:03:14.741] List of future strategies:
[16:03:14.741] 1. sequential:
[16:03:14.741]    - args: function (..., envir = parent.frame())
[16:03:14.741]    - tweaked: FALSE
[16:03:14.741]    - call: NULL
[16:03:14.742] plan(): nbrOfWorkers() = 1
[16:03:14.745] plan(): Setting new future strategy stack:
[16:03:14.745] List of future strategies:
[16:03:14.745] 1. multicore:
[16:03:14.745]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.745]    - tweaked: FALSE
[16:03:14.745]    - call: plan(strategy)
[16:03:14.752] plan(): nbrOfWorkers() = 2
[16:03:14.741] MulticoreFuture:
[16:03:14.741] Label: ‘future_sapply-1’
[16:03:14.741] Expression:
[16:03:14.741] {
[16:03:14.741]     do.call(function(...) {
[16:03:14.741]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.741]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.741]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.741]             on.exit(options(oopts), add = TRUE)
[16:03:14.741]         }
[16:03:14.741]         {
[16:03:14.741]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.741]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.741]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.741]             })
[16:03:14.741]         }
[16:03:14.741]     }, args = future.call.arguments)
[16:03:14.741] }
[16:03:14.741] Lazy evaluation: FALSE
[16:03:14.741] Asynchronous evaluation: TRUE
[16:03:14.741] Local evaluation: TRUE
[16:03:14.741] Environment: R_GlobalEnv
[16:03:14.741] Capture standard output: TRUE
[16:03:14.741] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.741] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:14.741] Packages: <none>
[16:03:14.741] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.741] Resolved: TRUE
[16:03:14.741] Value: <not collected>
[16:03:14.741] Conditions captured: <none>
[16:03:14.741] Early signaling: FALSE
[16:03:14.741] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.741] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.754] Chunk #1 of 2 ... DONE
[16:03:14.754] Chunk #2 of 2 ...
[16:03:14.754]  - Finding globals in 'X' for chunk #2 ...
[16:03:14.754] getGlobalsAndPackages() ...
[16:03:14.755] Searching for globals...
[16:03:14.755] 
[16:03:14.755] Searching for globals ... DONE
[16:03:14.756] - globals: [0] <none>
[16:03:14.756] getGlobalsAndPackages() ... DONE
[16:03:14.756]    + additional globals found: [n=0] 
[16:03:14.756]    + additional namespaces needed: [n=0] 
[16:03:14.756]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:14.757]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.757]  - seeds: <none>
[16:03:14.757]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.757] getGlobalsAndPackages() ...
[16:03:14.758] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.758] Resolving globals: FALSE
[16:03:14.758] Tweak future expression to call with '...' arguments ...
[16:03:14.758] {
[16:03:14.758]     do.call(function(...) {
[16:03:14.758]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.758]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.758]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.758]             on.exit(options(oopts), add = TRUE)
[16:03:14.758]         }
[16:03:14.758]         {
[16:03:14.758]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.758]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.758]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.758]             })
[16:03:14.758]         }
[16:03:14.758]     }, args = future.call.arguments)
[16:03:14.758] }
[16:03:14.759] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.759] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.760] 
[16:03:14.760] getGlobalsAndPackages() ... DONE
[16:03:14.760] run() for ‘Future’ ...
[16:03:14.760] - state: ‘created’
[16:03:14.761] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.766] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.766] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.766]   - Field: ‘label’
[16:03:14.766]   - Field: ‘local’
[16:03:14.766]   - Field: ‘owner’
[16:03:14.766]   - Field: ‘envir’
[16:03:14.767]   - Field: ‘workers’
[16:03:14.767]   - Field: ‘packages’
[16:03:14.767]   - Field: ‘gc’
[16:03:14.767]   - Field: ‘job’
[16:03:14.767]   - Field: ‘conditions’
[16:03:14.767]   - Field: ‘expr’
[16:03:14.767]   - Field: ‘uuid’
[16:03:14.768]   - Field: ‘seed’
[16:03:14.768]   - Field: ‘version’
[16:03:14.768]   - Field: ‘result’
[16:03:14.768]   - Field: ‘asynchronous’
[16:03:14.768]   - Field: ‘calls’
[16:03:14.768]   - Field: ‘globals’
[16:03:14.768]   - Field: ‘stdout’
[16:03:14.768]   - Field: ‘earlySignal’
[16:03:14.769]   - Field: ‘lazy’
[16:03:14.769]   - Field: ‘state’
[16:03:14.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.769] - Launch lazy future ...
[16:03:14.769] Packages needed by the future expression (n = 0): <none>
[16:03:14.770] Packages needed by future strategies (n = 0): <none>
[16:03:14.770] {
[16:03:14.770]     {
[16:03:14.770]         {
[16:03:14.770]             ...future.startTime <- base::Sys.time()
[16:03:14.770]             {
[16:03:14.770]                 {
[16:03:14.770]                   {
[16:03:14.770]                     {
[16:03:14.770]                       base::local({
[16:03:14.770]                         has_future <- base::requireNamespace("future", 
[16:03:14.770]                           quietly = TRUE)
[16:03:14.770]                         if (has_future) {
[16:03:14.770]                           ns <- base::getNamespace("future")
[16:03:14.770]                           version <- ns[[".package"]][["version"]]
[16:03:14.770]                           if (is.null(version)) 
[16:03:14.770]                             version <- utils::packageVersion("future")
[16:03:14.770]                         }
[16:03:14.770]                         else {
[16:03:14.770]                           version <- NULL
[16:03:14.770]                         }
[16:03:14.770]                         if (!has_future || version < "1.8.0") {
[16:03:14.770]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.770]                             "", base::R.version$version.string), 
[16:03:14.770]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:14.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:14.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.770]                               "release", "version")], collapse = " "), 
[16:03:14.770]                             hostname = base::Sys.info()[["nodename"]])
[16:03:14.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.770]                             info)
[16:03:14.770]                           info <- base::paste(info, collapse = "; ")
[16:03:14.770]                           if (!has_future) {
[16:03:14.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.770]                               info)
[16:03:14.770]                           }
[16:03:14.770]                           else {
[16:03:14.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.770]                               info, version)
[16:03:14.770]                           }
[16:03:14.770]                           base::stop(msg)
[16:03:14.770]                         }
[16:03:14.770]                       })
[16:03:14.770]                     }
[16:03:14.770]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.770]                     base::options(mc.cores = 1L)
[16:03:14.770]                   }
[16:03:14.770]                   options(future.plan = NULL)
[16:03:14.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.770]                 }
[16:03:14.770]                 ...future.workdir <- getwd()
[16:03:14.770]             }
[16:03:14.770]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.770]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.770]         }
[16:03:14.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.770]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.770]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.770]             base::names(...future.oldOptions))
[16:03:14.770]     }
[16:03:14.770]     if (FALSE) {
[16:03:14.770]     }
[16:03:14.770]     else {
[16:03:14.770]         if (TRUE) {
[16:03:14.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.770]                 open = "w")
[16:03:14.770]         }
[16:03:14.770]         else {
[16:03:14.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.770]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.770]         }
[16:03:14.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.770]             base::sink(type = "output", split = FALSE)
[16:03:14.770]             base::close(...future.stdout)
[16:03:14.770]         }, add = TRUE)
[16:03:14.770]     }
[16:03:14.770]     ...future.frame <- base::sys.nframe()
[16:03:14.770]     ...future.conditions <- base::list()
[16:03:14.770]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.770]     if (FALSE) {
[16:03:14.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.770]     }
[16:03:14.770]     ...future.result <- base::tryCatch({
[16:03:14.770]         base::withCallingHandlers({
[16:03:14.770]             ...future.value <- base::withVisible(base::local({
[16:03:14.770]                 withCallingHandlers({
[16:03:14.770]                   {
[16:03:14.770]                     do.call(function(...) {
[16:03:14.770]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.770]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.770]                         ...future.globals.maxSize)) {
[16:03:14.770]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.770]                         on.exit(options(oopts), add = TRUE)
[16:03:14.770]                       }
[16:03:14.770]                       {
[16:03:14.770]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.770]                           FUN = function(jj) {
[16:03:14.770]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.770]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.770]                           })
[16:03:14.770]                       }
[16:03:14.770]                     }, args = future.call.arguments)
[16:03:14.770]                   }
[16:03:14.770]                 }, immediateCondition = function(cond) {
[16:03:14.770]                   save_rds <- function (object, pathname, ...) 
[16:03:14.770]                   {
[16:03:14.770]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.770]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.770]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.770]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.770]                         fi_tmp[["mtime"]])
[16:03:14.770]                     }
[16:03:14.770]                     tryCatch({
[16:03:14.770]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.770]                     }, error = function(ex) {
[16:03:14.770]                       msg <- conditionMessage(ex)
[16:03:14.770]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.770]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.770]                         fi_tmp[["mtime"]], msg)
[16:03:14.770]                       ex$message <- msg
[16:03:14.770]                       stop(ex)
[16:03:14.770]                     })
[16:03:14.770]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.770]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.770]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.770]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.770]                       fi <- file.info(pathname)
[16:03:14.770]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.770]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.770]                         fi[["size"]], fi[["mtime"]])
[16:03:14.770]                       stop(msg)
[16:03:14.770]                     }
[16:03:14.770]                     invisible(pathname)
[16:03:14.770]                   }
[16:03:14.770]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.770]                     rootPath = tempdir()) 
[16:03:14.770]                   {
[16:03:14.770]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.770]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.770]                       tmpdir = path, fileext = ".rds")
[16:03:14.770]                     save_rds(obj, file)
[16:03:14.770]                   }
[16:03:14.770]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.770]                   {
[16:03:14.770]                     inherits <- base::inherits
[16:03:14.770]                     invokeRestart <- base::invokeRestart
[16:03:14.770]                     is.null <- base::is.null
[16:03:14.770]                     muffled <- FALSE
[16:03:14.770]                     if (inherits(cond, "message")) {
[16:03:14.770]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.770]                       if (muffled) 
[16:03:14.770]                         invokeRestart("muffleMessage")
[16:03:14.770]                     }
[16:03:14.770]                     else if (inherits(cond, "warning")) {
[16:03:14.770]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.770]                       if (muffled) 
[16:03:14.770]                         invokeRestart("muffleWarning")
[16:03:14.770]                     }
[16:03:14.770]                     else if (inherits(cond, "condition")) {
[16:03:14.770]                       if (!is.null(pattern)) {
[16:03:14.770]                         computeRestarts <- base::computeRestarts
[16:03:14.770]                         grepl <- base::grepl
[16:03:14.770]                         restarts <- computeRestarts(cond)
[16:03:14.770]                         for (restart in restarts) {
[16:03:14.770]                           name <- restart$name
[16:03:14.770]                           if (is.null(name)) 
[16:03:14.770]                             next
[16:03:14.770]                           if (!grepl(pattern, name)) 
[16:03:14.770]                             next
[16:03:14.770]                           invokeRestart(restart)
[16:03:14.770]                           muffled <- TRUE
[16:03:14.770]                           break
[16:03:14.770]                         }
[16:03:14.770]                       }
[16:03:14.770]                     }
[16:03:14.770]                     invisible(muffled)
[16:03:14.770]                   }
[16:03:14.770]                   muffleCondition(cond)
[16:03:14.770]                 })
[16:03:14.770]             }))
[16:03:14.770]             future::FutureResult(value = ...future.value$value, 
[16:03:14.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.770]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.770]                     ...future.globalenv.names))
[16:03:14.770]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.770]         }, condition = base::local({
[16:03:14.770]             c <- base::c
[16:03:14.770]             inherits <- base::inherits
[16:03:14.770]             invokeRestart <- base::invokeRestart
[16:03:14.770]             length <- base::length
[16:03:14.770]             list <- base::list
[16:03:14.770]             seq.int <- base::seq.int
[16:03:14.770]             signalCondition <- base::signalCondition
[16:03:14.770]             sys.calls <- base::sys.calls
[16:03:14.770]             `[[` <- base::`[[`
[16:03:14.770]             `+` <- base::`+`
[16:03:14.770]             `<<-` <- base::`<<-`
[16:03:14.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.770]                   3L)]
[16:03:14.770]             }
[16:03:14.770]             function(cond) {
[16:03:14.770]                 is_error <- inherits(cond, "error")
[16:03:14.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.770]                   NULL)
[16:03:14.770]                 if (is_error) {
[16:03:14.770]                   sessionInformation <- function() {
[16:03:14.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.770]                       search = base::search(), system = base::Sys.info())
[16:03:14.770]                   }
[16:03:14.770]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.770]                     cond$call), session = sessionInformation(), 
[16:03:14.770]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.770]                   signalCondition(cond)
[16:03:14.770]                 }
[16:03:14.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.770]                 "immediateCondition"))) {
[16:03:14.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.770]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.770]                   if (TRUE && !signal) {
[16:03:14.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.770]                     {
[16:03:14.770]                       inherits <- base::inherits
[16:03:14.770]                       invokeRestart <- base::invokeRestart
[16:03:14.770]                       is.null <- base::is.null
[16:03:14.770]                       muffled <- FALSE
[16:03:14.770]                       if (inherits(cond, "message")) {
[16:03:14.770]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.770]                         if (muffled) 
[16:03:14.770]                           invokeRestart("muffleMessage")
[16:03:14.770]                       }
[16:03:14.770]                       else if (inherits(cond, "warning")) {
[16:03:14.770]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.770]                         if (muffled) 
[16:03:14.770]                           invokeRestart("muffleWarning")
[16:03:14.770]                       }
[16:03:14.770]                       else if (inherits(cond, "condition")) {
[16:03:14.770]                         if (!is.null(pattern)) {
[16:03:14.770]                           computeRestarts <- base::computeRestarts
[16:03:14.770]                           grepl <- base::grepl
[16:03:14.770]                           restarts <- computeRestarts(cond)
[16:03:14.770]                           for (restart in restarts) {
[16:03:14.770]                             name <- restart$name
[16:03:14.770]                             if (is.null(name)) 
[16:03:14.770]                               next
[16:03:14.770]                             if (!grepl(pattern, name)) 
[16:03:14.770]                               next
[16:03:14.770]                             invokeRestart(restart)
[16:03:14.770]                             muffled <- TRUE
[16:03:14.770]                             break
[16:03:14.770]                           }
[16:03:14.770]                         }
[16:03:14.770]                       }
[16:03:14.770]                       invisible(muffled)
[16:03:14.770]                     }
[16:03:14.770]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.770]                   }
[16:03:14.770]                 }
[16:03:14.770]                 else {
[16:03:14.770]                   if (TRUE) {
[16:03:14.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.770]                     {
[16:03:14.770]                       inherits <- base::inherits
[16:03:14.770]                       invokeRestart <- base::invokeRestart
[16:03:14.770]                       is.null <- base::is.null
[16:03:14.770]                       muffled <- FALSE
[16:03:14.770]                       if (inherits(cond, "message")) {
[16:03:14.770]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.770]                         if (muffled) 
[16:03:14.770]                           invokeRestart("muffleMessage")
[16:03:14.770]                       }
[16:03:14.770]                       else if (inherits(cond, "warning")) {
[16:03:14.770]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.770]                         if (muffled) 
[16:03:14.770]                           invokeRestart("muffleWarning")
[16:03:14.770]                       }
[16:03:14.770]                       else if (inherits(cond, "condition")) {
[16:03:14.770]                         if (!is.null(pattern)) {
[16:03:14.770]                           computeRestarts <- base::computeRestarts
[16:03:14.770]                           grepl <- base::grepl
[16:03:14.770]                           restarts <- computeRestarts(cond)
[16:03:14.770]                           for (restart in restarts) {
[16:03:14.770]                             name <- restart$name
[16:03:14.770]                             if (is.null(name)) 
[16:03:14.770]                               next
[16:03:14.770]                             if (!grepl(pattern, name)) 
[16:03:14.770]                               next
[16:03:14.770]                             invokeRestart(restart)
[16:03:14.770]                             muffled <- TRUE
[16:03:14.770]                             break
[16:03:14.770]                           }
[16:03:14.770]                         }
[16:03:14.770]                       }
[16:03:14.770]                       invisible(muffled)
[16:03:14.770]                     }
[16:03:14.770]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.770]                   }
[16:03:14.770]                 }
[16:03:14.770]             }
[16:03:14.770]         }))
[16:03:14.770]     }, error = function(ex) {
[16:03:14.770]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.770]                 ...future.rng), started = ...future.startTime, 
[16:03:14.770]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.770]             version = "1.8"), class = "FutureResult")
[16:03:14.770]     }, finally = {
[16:03:14.770]         if (!identical(...future.workdir, getwd())) 
[16:03:14.770]             setwd(...future.workdir)
[16:03:14.770]         {
[16:03:14.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.770]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.770]             }
[16:03:14.770]             base::options(...future.oldOptions)
[16:03:14.770]             if (.Platform$OS.type == "windows") {
[16:03:14.770]                 old_names <- names(...future.oldEnvVars)
[16:03:14.770]                 envs <- base::Sys.getenv()
[16:03:14.770]                 names <- names(envs)
[16:03:14.770]                 common <- intersect(names, old_names)
[16:03:14.770]                 added <- setdiff(names, old_names)
[16:03:14.770]                 removed <- setdiff(old_names, names)
[16:03:14.770]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.770]                   envs[common]]
[16:03:14.770]                 NAMES <- toupper(changed)
[16:03:14.770]                 args <- list()
[16:03:14.770]                 for (kk in seq_along(NAMES)) {
[16:03:14.770]                   name <- changed[[kk]]
[16:03:14.770]                   NAME <- NAMES[[kk]]
[16:03:14.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.770]                     next
[16:03:14.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.770]                 }
[16:03:14.770]                 NAMES <- toupper(added)
[16:03:14.770]                 for (kk in seq_along(NAMES)) {
[16:03:14.770]                   name <- added[[kk]]
[16:03:14.770]                   NAME <- NAMES[[kk]]
[16:03:14.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.770]                     next
[16:03:14.770]                   args[[name]] <- ""
[16:03:14.770]                 }
[16:03:14.770]                 NAMES <- toupper(removed)
[16:03:14.770]                 for (kk in seq_along(NAMES)) {
[16:03:14.770]                   name <- removed[[kk]]
[16:03:14.770]                   NAME <- NAMES[[kk]]
[16:03:14.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.770]                     next
[16:03:14.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.770]                 }
[16:03:14.770]                 if (length(args) > 0) 
[16:03:14.770]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.770]             }
[16:03:14.770]             else {
[16:03:14.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.770]             }
[16:03:14.770]             {
[16:03:14.770]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.770]                   0L) {
[16:03:14.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.770]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.770]                   base::options(opts)
[16:03:14.770]                 }
[16:03:14.770]                 {
[16:03:14.770]                   {
[16:03:14.770]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.770]                     NULL
[16:03:14.770]                   }
[16:03:14.770]                   options(future.plan = NULL)
[16:03:14.770]                   if (is.na(NA_character_)) 
[16:03:14.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.770]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.770]                     envir = parent.frame()) 
[16:03:14.770]                   {
[16:03:14.770]                     default_workers <- missing(workers)
[16:03:14.770]                     if (is.function(workers)) 
[16:03:14.770]                       workers <- workers()
[16:03:14.770]                     workers <- structure(as.integer(workers), 
[16:03:14.770]                       class = class(workers))
[16:03:14.770]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.770]                       1L)
[16:03:14.770]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.770]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.770]                       if (default_workers) 
[16:03:14.770]                         supportsMulticore(warn = TRUE)
[16:03:14.770]                       return(sequential(..., envir = envir))
[16:03:14.770]                     }
[16:03:14.770]                     oopts <- options(mc.cores = workers)
[16:03:14.770]                     on.exit(options(oopts))
[16:03:14.770]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.770]                       envir = envir)
[16:03:14.770]                     if (!future$lazy) 
[16:03:14.770]                       future <- run(future)
[16:03:14.770]                     invisible(future)
[16:03:14.770]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.770]                 }
[16:03:14.770]             }
[16:03:14.770]         }
[16:03:14.770]     })
[16:03:14.770]     if (TRUE) {
[16:03:14.770]         base::sink(type = "output", split = FALSE)
[16:03:14.770]         if (TRUE) {
[16:03:14.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.770]         }
[16:03:14.770]         else {
[16:03:14.770]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.770]         }
[16:03:14.770]         base::close(...future.stdout)
[16:03:14.770]         ...future.stdout <- NULL
[16:03:14.770]     }
[16:03:14.770]     ...future.result$conditions <- ...future.conditions
[16:03:14.770]     ...future.result$finished <- base::Sys.time()
[16:03:14.770]     ...future.result
[16:03:14.770] }
[16:03:14.774] assign_globals() ...
[16:03:14.774] List of 5
[16:03:14.774]  $ ...future.FUN            :function (x, y)  
[16:03:14.774]  $ future.call.arguments    :List of 1
[16:03:14.774]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:14.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.774]  $ ...future.elements_ii    :List of 2
[16:03:14.774]   ..$ C: num 70
[16:03:14.774]   ..$ D: num 80
[16:03:14.774]  $ ...future.seeds_ii       : NULL
[16:03:14.774]  $ ...future.globals.maxSize: NULL
[16:03:14.774]  - attr(*, "where")=List of 5
[16:03:14.774]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.774]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.774]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.774]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.774]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.774]  - attr(*, "resolved")= logi FALSE
[16:03:14.774]  - attr(*, "total_size")= num 4264
[16:03:14.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.774]  - attr(*, "already-done")= logi TRUE
[16:03:14.783] - reassign environment for ‘...future.FUN’
[16:03:14.783] - copied ‘...future.FUN’ to environment
[16:03:14.784] - copied ‘future.call.arguments’ to environment
[16:03:14.784] - copied ‘...future.elements_ii’ to environment
[16:03:14.784] - copied ‘...future.seeds_ii’ to environment
[16:03:14.784] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.784] assign_globals() ... done
[16:03:14.784] requestCore(): workers = 2
[16:03:14.787] MulticoreFuture started
[16:03:14.788] - Launch lazy future ... done
[16:03:14.788] plan(): Setting new future strategy stack:
[16:03:14.788] run() for ‘MulticoreFuture’ ... done
[16:03:14.789] Created future:
[16:03:14.789] List of future strategies:
[16:03:14.789] 1. sequential:
[16:03:14.789]    - args: function (..., envir = parent.frame())
[16:03:14.789]    - tweaked: FALSE
[16:03:14.789]    - call: NULL
[16:03:14.790] plan(): nbrOfWorkers() = 1
[16:03:14.793] plan(): Setting new future strategy stack:
[16:03:14.793] List of future strategies:
[16:03:14.793] 1. multicore:
[16:03:14.793]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.793]    - tweaked: FALSE
[16:03:14.793]    - call: plan(strategy)
[16:03:14.800] plan(): nbrOfWorkers() = 2
[16:03:14.789] MulticoreFuture:
[16:03:14.789] Label: ‘future_sapply-2’
[16:03:14.789] Expression:
[16:03:14.789] {
[16:03:14.789]     do.call(function(...) {
[16:03:14.789]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.789]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.789]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.789]             on.exit(options(oopts), add = TRUE)
[16:03:14.789]         }
[16:03:14.789]         {
[16:03:14.789]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.789]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.789]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.789]             })
[16:03:14.789]         }
[16:03:14.789]     }, args = future.call.arguments)
[16:03:14.789] }
[16:03:14.789] Lazy evaluation: FALSE
[16:03:14.789] Asynchronous evaluation: TRUE
[16:03:14.789] Local evaluation: TRUE
[16:03:14.789] Environment: R_GlobalEnv
[16:03:14.789] Capture standard output: TRUE
[16:03:14.789] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.789] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:14.789] Packages: <none>
[16:03:14.789] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.789] Resolved: TRUE
[16:03:14.789] Value: <not collected>
[16:03:14.789] Conditions captured: <none>
[16:03:14.789] Early signaling: FALSE
[16:03:14.789] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.789] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.801] Chunk #2 of 2 ... DONE
[16:03:14.802] Launching 2 futures (chunks) ... DONE
[16:03:14.802] Resolving 2 futures (chunks) ...
[16:03:14.802] resolve() on list ...
[16:03:14.802]  recursive: 0
[16:03:14.803]  length: 2
[16:03:14.803] 
[16:03:14.803] Future #1
[16:03:14.803] result() for MulticoreFuture ...
[16:03:14.804] result() for MulticoreFuture ...
[16:03:14.805] result() for MulticoreFuture ... done
[16:03:14.805] result() for MulticoreFuture ... done
[16:03:14.805] result() for MulticoreFuture ...
[16:03:14.805] result() for MulticoreFuture ... done
[16:03:14.806] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:14.806] - nx: 2
[16:03:14.806] - relay: TRUE
[16:03:14.806] - stdout: TRUE
[16:03:14.806] - signal: TRUE
[16:03:14.807] - resignal: FALSE
[16:03:14.807] - force: TRUE
[16:03:14.807] - relayed: [n=2] FALSE, FALSE
[16:03:14.807] - queued futures: [n=2] FALSE, FALSE
[16:03:14.808]  - until=1
[16:03:14.808]  - relaying element #1
[16:03:14.808] result() for MulticoreFuture ...
[16:03:14.808] result() for MulticoreFuture ... done
[16:03:14.809] result() for MulticoreFuture ...
[16:03:14.809] result() for MulticoreFuture ... done
[16:03:14.809] result() for MulticoreFuture ...
[16:03:14.809] result() for MulticoreFuture ... done
[16:03:14.809] result() for MulticoreFuture ...
[16:03:14.810] result() for MulticoreFuture ... done
[16:03:14.810] - relayed: [n=2] TRUE, FALSE
[16:03:14.810] - queued futures: [n=2] TRUE, FALSE
[16:03:14.810] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:14.810]  length: 1 (resolved future 1)
[16:03:14.811] Future #2
[16:03:14.811] result() for MulticoreFuture ...
[16:03:14.811] result() for MulticoreFuture ...
[16:03:14.812] result() for MulticoreFuture ... done
[16:03:14.812] result() for MulticoreFuture ... done
[16:03:14.812] result() for MulticoreFuture ...
[16:03:14.812] result() for MulticoreFuture ... done
[16:03:14.812] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:14.813] - nx: 2
[16:03:14.813] - relay: TRUE
[16:03:14.813] - stdout: TRUE
[16:03:14.813] - signal: TRUE
[16:03:14.813] - resignal: FALSE
[16:03:14.813] - force: TRUE
[16:03:14.813] - relayed: [n=2] TRUE, FALSE
[16:03:14.813] - queued futures: [n=2] TRUE, FALSE
[16:03:14.813]  - until=2
[16:03:14.814]  - relaying element #2
[16:03:14.814] result() for MulticoreFuture ...
[16:03:14.814] result() for MulticoreFuture ... done
[16:03:14.814] result() for MulticoreFuture ...
[16:03:14.814] result() for MulticoreFuture ... done
[16:03:14.814] result() for MulticoreFuture ...
[16:03:14.814] result() for MulticoreFuture ... done
[16:03:14.814] result() for MulticoreFuture ...
[16:03:14.815] result() for MulticoreFuture ... done
[16:03:14.815] - relayed: [n=2] TRUE, TRUE
[16:03:14.815] - queued futures: [n=2] TRUE, TRUE
[16:03:14.815] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:14.815]  length: 0 (resolved future 2)
[16:03:14.815] Relaying remaining futures
[16:03:14.815] signalConditionsASAP(NULL, pos=0) ...
[16:03:14.815] - nx: 2
[16:03:14.815] - relay: TRUE
[16:03:14.816] - stdout: TRUE
[16:03:14.816] - signal: TRUE
[16:03:14.816] - resignal: FALSE
[16:03:14.816] - force: TRUE
[16:03:14.816] - relayed: [n=2] TRUE, TRUE
[16:03:14.816] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:14.816] - relayed: [n=2] TRUE, TRUE
[16:03:14.816] - queued futures: [n=2] TRUE, TRUE
[16:03:14.816] signalConditionsASAP(NULL, pos=0) ... done
[16:03:14.816] resolve() on list ... DONE
[16:03:14.817] result() for MulticoreFuture ...
[16:03:14.817] result() for MulticoreFuture ... done
[16:03:14.817] result() for MulticoreFuture ...
[16:03:14.817] result() for MulticoreFuture ... done
[16:03:14.817] result() for MulticoreFuture ...
[16:03:14.817] result() for MulticoreFuture ... done
[16:03:14.817] result() for MulticoreFuture ...
[16:03:14.817] result() for MulticoreFuture ... done
[16:03:14.817]  - Number of value chunks collected: 2
[16:03:14.818] Resolving 2 futures (chunks) ... DONE
[16:03:14.818] Reducing values from 2 chunks ...
[16:03:14.818]  - Number of values collected after concatenation: 4
[16:03:14.818]  - Number of values expected: 4
[16:03:14.818] Reducing values from 2 chunks ... DONE
[16:03:14.818] future_lapply() ... DONE
[16:03:14.819] future_lapply() ...
[16:03:14.825] Number of chunks: 2
[16:03:14.825] getGlobalsAndPackagesXApply() ...
[16:03:14.825]  - future.globals: TRUE
[16:03:14.825] getGlobalsAndPackages() ...
[16:03:14.826] Searching for globals...
[16:03:14.832] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[16:03:14.832] Searching for globals ... DONE
[16:03:14.832] Resolving globals: FALSE
[16:03:14.833] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[16:03:14.834] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:14.834] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.834] - packages: [1] ‘future.apply’
[16:03:14.834] getGlobalsAndPackages() ... DONE
[16:03:14.834]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.834]  - needed namespaces: [n=1] ‘future.apply’
[16:03:14.834] Finding globals ... DONE
[16:03:14.835]  - use_args: TRUE
[16:03:14.835]  - Getting '...' globals ...
[16:03:14.835] resolve() on list ...
[16:03:14.835]  recursive: 0
[16:03:14.835]  length: 1
[16:03:14.835]  elements: ‘...’
[16:03:14.835]  length: 0 (resolved future 1)
[16:03:14.836] resolve() on list ... DONE
[16:03:14.836]    - '...' content: [n=1] ‘y’
[16:03:14.836] List of 1
[16:03:14.836]  $ ...:List of 1
[16:03:14.836]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:14.836]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.836]  - attr(*, "where")=List of 1
[16:03:14.836]   ..$ ...:<environment: 0x564e4235b140> 
[16:03:14.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.836]  - attr(*, "resolved")= logi TRUE
[16:03:14.836]  - attr(*, "total_size")= num NA
[16:03:14.839]  - Getting '...' globals ... DONE
[16:03:14.839] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:14.839] List of 8
[16:03:14.839]  $ ...future.FUN:function (x, ...)  
[16:03:14.839]  $ x_FUN        :function (x, y)  
[16:03:14.839]  $ times        : int 15
[16:03:14.839]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.839]  $ stop_if_not  :function (...)  
[16:03:14.839]  $ dim          : int [1:2] 3 5
[16:03:14.839]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:14.839]  $ ...          :List of 1
[16:03:14.839]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:14.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.839]  - attr(*, "where")=List of 8
[16:03:14.839]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:14.839]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:14.839]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:14.839]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:14.839]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:14.839]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:14.839]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:14.839]   ..$ ...          :<environment: 0x564e4235b140> 
[16:03:14.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.839]  - attr(*, "resolved")= logi FALSE
[16:03:14.839]  - attr(*, "total_size")= num 98600
[16:03:14.845] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:14.845] getGlobalsAndPackagesXApply() ... DONE
[16:03:14.845] Number of futures (= number of chunks): 2
[16:03:14.846] Launching 2 futures (chunks) ...
[16:03:14.846] Chunk #1 of 2 ...
[16:03:14.846]  - Finding globals in 'X' for chunk #1 ...
[16:03:14.846] getGlobalsAndPackages() ...
[16:03:14.846] Searching for globals...
[16:03:14.846] 
[16:03:14.846] Searching for globals ... DONE
[16:03:14.846] - globals: [0] <none>
[16:03:14.846] getGlobalsAndPackages() ... DONE
[16:03:14.848]    + additional globals found: [n=0] 
[16:03:14.848]    + additional namespaces needed: [n=0] 
[16:03:14.848]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:14.849]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.849]  - seeds: <none>
[16:03:14.849]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.849] getGlobalsAndPackages() ...
[16:03:14.849] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.849] Resolving globals: FALSE
[16:03:14.849] Tweak future expression to call with '...' arguments ...
[16:03:14.849] {
[16:03:14.849]     do.call(function(...) {
[16:03:14.849]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.849]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.849]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.849]             on.exit(options(oopts), add = TRUE)
[16:03:14.849]         }
[16:03:14.849]         {
[16:03:14.849]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.849]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.849]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.849]             })
[16:03:14.849]         }
[16:03:14.849]     }, args = future.call.arguments)
[16:03:14.849] }
[16:03:14.850] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.850] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.850] - packages: [1] ‘future.apply’
[16:03:14.850] getGlobalsAndPackages() ... DONE
[16:03:14.851] run() for ‘Future’ ...
[16:03:14.851] - state: ‘created’
[16:03:14.851] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.855] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.855] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.855]   - Field: ‘label’
[16:03:14.855]   - Field: ‘local’
[16:03:14.855]   - Field: ‘owner’
[16:03:14.855]   - Field: ‘envir’
[16:03:14.855]   - Field: ‘workers’
[16:03:14.855]   - Field: ‘packages’
[16:03:14.856]   - Field: ‘gc’
[16:03:14.856]   - Field: ‘job’
[16:03:14.856]   - Field: ‘conditions’
[16:03:14.856]   - Field: ‘expr’
[16:03:14.856]   - Field: ‘uuid’
[16:03:14.856]   - Field: ‘seed’
[16:03:14.856]   - Field: ‘version’
[16:03:14.856]   - Field: ‘result’
[16:03:14.856]   - Field: ‘asynchronous’
[16:03:14.856]   - Field: ‘calls’
[16:03:14.856]   - Field: ‘globals’
[16:03:14.857]   - Field: ‘stdout’
[16:03:14.857]   - Field: ‘earlySignal’
[16:03:14.857]   - Field: ‘lazy’
[16:03:14.857]   - Field: ‘state’
[16:03:14.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.857] - Launch lazy future ...
[16:03:14.857] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:14.858] Packages needed by future strategies (n = 0): <none>
[16:03:14.858] {
[16:03:14.858]     {
[16:03:14.858]         {
[16:03:14.858]             ...future.startTime <- base::Sys.time()
[16:03:14.858]             {
[16:03:14.858]                 {
[16:03:14.858]                   {
[16:03:14.858]                     {
[16:03:14.858]                       {
[16:03:14.858]                         base::local({
[16:03:14.858]                           has_future <- base::requireNamespace("future", 
[16:03:14.858]                             quietly = TRUE)
[16:03:14.858]                           if (has_future) {
[16:03:14.858]                             ns <- base::getNamespace("future")
[16:03:14.858]                             version <- ns[[".package"]][["version"]]
[16:03:14.858]                             if (is.null(version)) 
[16:03:14.858]                               version <- utils::packageVersion("future")
[16:03:14.858]                           }
[16:03:14.858]                           else {
[16:03:14.858]                             version <- NULL
[16:03:14.858]                           }
[16:03:14.858]                           if (!has_future || version < "1.8.0") {
[16:03:14.858]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.858]                               "", base::R.version$version.string), 
[16:03:14.858]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.858]                                 base::R.version$platform, 8 * 
[16:03:14.858]                                   base::.Machine$sizeof.pointer), 
[16:03:14.858]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.858]                                 "release", "version")], collapse = " "), 
[16:03:14.858]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.858]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.858]                               info)
[16:03:14.858]                             info <- base::paste(info, collapse = "; ")
[16:03:14.858]                             if (!has_future) {
[16:03:14.858]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.858]                                 info)
[16:03:14.858]                             }
[16:03:14.858]                             else {
[16:03:14.858]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.858]                                 info, version)
[16:03:14.858]                             }
[16:03:14.858]                             base::stop(msg)
[16:03:14.858]                           }
[16:03:14.858]                         })
[16:03:14.858]                       }
[16:03:14.858]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.858]                       base::options(mc.cores = 1L)
[16:03:14.858]                     }
[16:03:14.858]                     base::local({
[16:03:14.858]                       for (pkg in "future.apply") {
[16:03:14.858]                         base::loadNamespace(pkg)
[16:03:14.858]                         base::library(pkg, character.only = TRUE)
[16:03:14.858]                       }
[16:03:14.858]                     })
[16:03:14.858]                   }
[16:03:14.858]                   options(future.plan = NULL)
[16:03:14.858]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.858]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.858]                 }
[16:03:14.858]                 ...future.workdir <- getwd()
[16:03:14.858]             }
[16:03:14.858]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.858]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.858]         }
[16:03:14.858]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.858]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.858]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.858]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.858]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.858]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.858]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.858]             base::names(...future.oldOptions))
[16:03:14.858]     }
[16:03:14.858]     if (FALSE) {
[16:03:14.858]     }
[16:03:14.858]     else {
[16:03:14.858]         if (TRUE) {
[16:03:14.858]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.858]                 open = "w")
[16:03:14.858]         }
[16:03:14.858]         else {
[16:03:14.858]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.858]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.858]         }
[16:03:14.858]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.858]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.858]             base::sink(type = "output", split = FALSE)
[16:03:14.858]             base::close(...future.stdout)
[16:03:14.858]         }, add = TRUE)
[16:03:14.858]     }
[16:03:14.858]     ...future.frame <- base::sys.nframe()
[16:03:14.858]     ...future.conditions <- base::list()
[16:03:14.858]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.858]     if (FALSE) {
[16:03:14.858]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.858]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.858]     }
[16:03:14.858]     ...future.result <- base::tryCatch({
[16:03:14.858]         base::withCallingHandlers({
[16:03:14.858]             ...future.value <- base::withVisible(base::local({
[16:03:14.858]                 withCallingHandlers({
[16:03:14.858]                   {
[16:03:14.858]                     do.call(function(...) {
[16:03:14.858]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.858]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.858]                         ...future.globals.maxSize)) {
[16:03:14.858]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.858]                         on.exit(options(oopts), add = TRUE)
[16:03:14.858]                       }
[16:03:14.858]                       {
[16:03:14.858]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.858]                           FUN = function(jj) {
[16:03:14.858]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.858]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.858]                           })
[16:03:14.858]                       }
[16:03:14.858]                     }, args = future.call.arguments)
[16:03:14.858]                   }
[16:03:14.858]                 }, immediateCondition = function(cond) {
[16:03:14.858]                   save_rds <- function (object, pathname, ...) 
[16:03:14.858]                   {
[16:03:14.858]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.858]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.858]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.858]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.858]                         fi_tmp[["mtime"]])
[16:03:14.858]                     }
[16:03:14.858]                     tryCatch({
[16:03:14.858]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.858]                     }, error = function(ex) {
[16:03:14.858]                       msg <- conditionMessage(ex)
[16:03:14.858]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.858]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.858]                         fi_tmp[["mtime"]], msg)
[16:03:14.858]                       ex$message <- msg
[16:03:14.858]                       stop(ex)
[16:03:14.858]                     })
[16:03:14.858]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.858]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.858]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.858]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.858]                       fi <- file.info(pathname)
[16:03:14.858]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.858]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.858]                         fi[["size"]], fi[["mtime"]])
[16:03:14.858]                       stop(msg)
[16:03:14.858]                     }
[16:03:14.858]                     invisible(pathname)
[16:03:14.858]                   }
[16:03:14.858]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.858]                     rootPath = tempdir()) 
[16:03:14.858]                   {
[16:03:14.858]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.858]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.858]                       tmpdir = path, fileext = ".rds")
[16:03:14.858]                     save_rds(obj, file)
[16:03:14.858]                   }
[16:03:14.858]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.858]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.858]                   {
[16:03:14.858]                     inherits <- base::inherits
[16:03:14.858]                     invokeRestart <- base::invokeRestart
[16:03:14.858]                     is.null <- base::is.null
[16:03:14.858]                     muffled <- FALSE
[16:03:14.858]                     if (inherits(cond, "message")) {
[16:03:14.858]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.858]                       if (muffled) 
[16:03:14.858]                         invokeRestart("muffleMessage")
[16:03:14.858]                     }
[16:03:14.858]                     else if (inherits(cond, "warning")) {
[16:03:14.858]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.858]                       if (muffled) 
[16:03:14.858]                         invokeRestart("muffleWarning")
[16:03:14.858]                     }
[16:03:14.858]                     else if (inherits(cond, "condition")) {
[16:03:14.858]                       if (!is.null(pattern)) {
[16:03:14.858]                         computeRestarts <- base::computeRestarts
[16:03:14.858]                         grepl <- base::grepl
[16:03:14.858]                         restarts <- computeRestarts(cond)
[16:03:14.858]                         for (restart in restarts) {
[16:03:14.858]                           name <- restart$name
[16:03:14.858]                           if (is.null(name)) 
[16:03:14.858]                             next
[16:03:14.858]                           if (!grepl(pattern, name)) 
[16:03:14.858]                             next
[16:03:14.858]                           invokeRestart(restart)
[16:03:14.858]                           muffled <- TRUE
[16:03:14.858]                           break
[16:03:14.858]                         }
[16:03:14.858]                       }
[16:03:14.858]                     }
[16:03:14.858]                     invisible(muffled)
[16:03:14.858]                   }
[16:03:14.858]                   muffleCondition(cond)
[16:03:14.858]                 })
[16:03:14.858]             }))
[16:03:14.858]             future::FutureResult(value = ...future.value$value, 
[16:03:14.858]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.858]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.858]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.858]                     ...future.globalenv.names))
[16:03:14.858]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.858]         }, condition = base::local({
[16:03:14.858]             c <- base::c
[16:03:14.858]             inherits <- base::inherits
[16:03:14.858]             invokeRestart <- base::invokeRestart
[16:03:14.858]             length <- base::length
[16:03:14.858]             list <- base::list
[16:03:14.858]             seq.int <- base::seq.int
[16:03:14.858]             signalCondition <- base::signalCondition
[16:03:14.858]             sys.calls <- base::sys.calls
[16:03:14.858]             `[[` <- base::`[[`
[16:03:14.858]             `+` <- base::`+`
[16:03:14.858]             `<<-` <- base::`<<-`
[16:03:14.858]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.858]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.858]                   3L)]
[16:03:14.858]             }
[16:03:14.858]             function(cond) {
[16:03:14.858]                 is_error <- inherits(cond, "error")
[16:03:14.858]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.858]                   NULL)
[16:03:14.858]                 if (is_error) {
[16:03:14.858]                   sessionInformation <- function() {
[16:03:14.858]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.858]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.858]                       search = base::search(), system = base::Sys.info())
[16:03:14.858]                   }
[16:03:14.858]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.858]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.858]                     cond$call), session = sessionInformation(), 
[16:03:14.858]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.858]                   signalCondition(cond)
[16:03:14.858]                 }
[16:03:14.858]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.858]                 "immediateCondition"))) {
[16:03:14.858]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.858]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.858]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.858]                   if (TRUE && !signal) {
[16:03:14.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.858]                     {
[16:03:14.858]                       inherits <- base::inherits
[16:03:14.858]                       invokeRestart <- base::invokeRestart
[16:03:14.858]                       is.null <- base::is.null
[16:03:14.858]                       muffled <- FALSE
[16:03:14.858]                       if (inherits(cond, "message")) {
[16:03:14.858]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.858]                         if (muffled) 
[16:03:14.858]                           invokeRestart("muffleMessage")
[16:03:14.858]                       }
[16:03:14.858]                       else if (inherits(cond, "warning")) {
[16:03:14.858]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.858]                         if (muffled) 
[16:03:14.858]                           invokeRestart("muffleWarning")
[16:03:14.858]                       }
[16:03:14.858]                       else if (inherits(cond, "condition")) {
[16:03:14.858]                         if (!is.null(pattern)) {
[16:03:14.858]                           computeRestarts <- base::computeRestarts
[16:03:14.858]                           grepl <- base::grepl
[16:03:14.858]                           restarts <- computeRestarts(cond)
[16:03:14.858]                           for (restart in restarts) {
[16:03:14.858]                             name <- restart$name
[16:03:14.858]                             if (is.null(name)) 
[16:03:14.858]                               next
[16:03:14.858]                             if (!grepl(pattern, name)) 
[16:03:14.858]                               next
[16:03:14.858]                             invokeRestart(restart)
[16:03:14.858]                             muffled <- TRUE
[16:03:14.858]                             break
[16:03:14.858]                           }
[16:03:14.858]                         }
[16:03:14.858]                       }
[16:03:14.858]                       invisible(muffled)
[16:03:14.858]                     }
[16:03:14.858]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.858]                   }
[16:03:14.858]                 }
[16:03:14.858]                 else {
[16:03:14.858]                   if (TRUE) {
[16:03:14.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.858]                     {
[16:03:14.858]                       inherits <- base::inherits
[16:03:14.858]                       invokeRestart <- base::invokeRestart
[16:03:14.858]                       is.null <- base::is.null
[16:03:14.858]                       muffled <- FALSE
[16:03:14.858]                       if (inherits(cond, "message")) {
[16:03:14.858]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.858]                         if (muffled) 
[16:03:14.858]                           invokeRestart("muffleMessage")
[16:03:14.858]                       }
[16:03:14.858]                       else if (inherits(cond, "warning")) {
[16:03:14.858]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.858]                         if (muffled) 
[16:03:14.858]                           invokeRestart("muffleWarning")
[16:03:14.858]                       }
[16:03:14.858]                       else if (inherits(cond, "condition")) {
[16:03:14.858]                         if (!is.null(pattern)) {
[16:03:14.858]                           computeRestarts <- base::computeRestarts
[16:03:14.858]                           grepl <- base::grepl
[16:03:14.858]                           restarts <- computeRestarts(cond)
[16:03:14.858]                           for (restart in restarts) {
[16:03:14.858]                             name <- restart$name
[16:03:14.858]                             if (is.null(name)) 
[16:03:14.858]                               next
[16:03:14.858]                             if (!grepl(pattern, name)) 
[16:03:14.858]                               next
[16:03:14.858]                             invokeRestart(restart)
[16:03:14.858]                             muffled <- TRUE
[16:03:14.858]                             break
[16:03:14.858]                           }
[16:03:14.858]                         }
[16:03:14.858]                       }
[16:03:14.858]                       invisible(muffled)
[16:03:14.858]                     }
[16:03:14.858]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.858]                   }
[16:03:14.858]                 }
[16:03:14.858]             }
[16:03:14.858]         }))
[16:03:14.858]     }, error = function(ex) {
[16:03:14.858]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.858]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.858]                 ...future.rng), started = ...future.startTime, 
[16:03:14.858]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.858]             version = "1.8"), class = "FutureResult")
[16:03:14.858]     }, finally = {
[16:03:14.858]         if (!identical(...future.workdir, getwd())) 
[16:03:14.858]             setwd(...future.workdir)
[16:03:14.858]         {
[16:03:14.858]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.858]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.858]             }
[16:03:14.858]             base::options(...future.oldOptions)
[16:03:14.858]             if (.Platform$OS.type == "windows") {
[16:03:14.858]                 old_names <- names(...future.oldEnvVars)
[16:03:14.858]                 envs <- base::Sys.getenv()
[16:03:14.858]                 names <- names(envs)
[16:03:14.858]                 common <- intersect(names, old_names)
[16:03:14.858]                 added <- setdiff(names, old_names)
[16:03:14.858]                 removed <- setdiff(old_names, names)
[16:03:14.858]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.858]                   envs[common]]
[16:03:14.858]                 NAMES <- toupper(changed)
[16:03:14.858]                 args <- list()
[16:03:14.858]                 for (kk in seq_along(NAMES)) {
[16:03:14.858]                   name <- changed[[kk]]
[16:03:14.858]                   NAME <- NAMES[[kk]]
[16:03:14.858]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.858]                     next
[16:03:14.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.858]                 }
[16:03:14.858]                 NAMES <- toupper(added)
[16:03:14.858]                 for (kk in seq_along(NAMES)) {
[16:03:14.858]                   name <- added[[kk]]
[16:03:14.858]                   NAME <- NAMES[[kk]]
[16:03:14.858]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.858]                     next
[16:03:14.858]                   args[[name]] <- ""
[16:03:14.858]                 }
[16:03:14.858]                 NAMES <- toupper(removed)
[16:03:14.858]                 for (kk in seq_along(NAMES)) {
[16:03:14.858]                   name <- removed[[kk]]
[16:03:14.858]                   NAME <- NAMES[[kk]]
[16:03:14.858]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.858]                     next
[16:03:14.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.858]                 }
[16:03:14.858]                 if (length(args) > 0) 
[16:03:14.858]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.858]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.858]             }
[16:03:14.858]             else {
[16:03:14.858]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.858]             }
[16:03:14.858]             {
[16:03:14.858]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.858]                   0L) {
[16:03:14.858]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.858]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.858]                   base::options(opts)
[16:03:14.858]                 }
[16:03:14.858]                 {
[16:03:14.858]                   {
[16:03:14.858]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.858]                     NULL
[16:03:14.858]                   }
[16:03:14.858]                   options(future.plan = NULL)
[16:03:14.858]                   if (is.na(NA_character_)) 
[16:03:14.858]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.858]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.858]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.858]                     envir = parent.frame()) 
[16:03:14.858]                   {
[16:03:14.858]                     default_workers <- missing(workers)
[16:03:14.858]                     if (is.function(workers)) 
[16:03:14.858]                       workers <- workers()
[16:03:14.858]                     workers <- structure(as.integer(workers), 
[16:03:14.858]                       class = class(workers))
[16:03:14.858]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.858]                       1L)
[16:03:14.858]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.858]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.858]                       if (default_workers) 
[16:03:14.858]                         supportsMulticore(warn = TRUE)
[16:03:14.858]                       return(sequential(..., envir = envir))
[16:03:14.858]                     }
[16:03:14.858]                     oopts <- options(mc.cores = workers)
[16:03:14.858]                     on.exit(options(oopts))
[16:03:14.858]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.858]                       envir = envir)
[16:03:14.858]                     if (!future$lazy) 
[16:03:14.858]                       future <- run(future)
[16:03:14.858]                     invisible(future)
[16:03:14.858]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.858]                 }
[16:03:14.858]             }
[16:03:14.858]         }
[16:03:14.858]     })
[16:03:14.858]     if (TRUE) {
[16:03:14.858]         base::sink(type = "output", split = FALSE)
[16:03:14.858]         if (TRUE) {
[16:03:14.858]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.858]         }
[16:03:14.858]         else {
[16:03:14.858]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.858]         }
[16:03:14.858]         base::close(...future.stdout)
[16:03:14.858]         ...future.stdout <- NULL
[16:03:14.858]     }
[16:03:14.858]     ...future.result$conditions <- ...future.conditions
[16:03:14.858]     ...future.result$finished <- base::Sys.time()
[16:03:14.858]     ...future.result
[16:03:14.858] }
[16:03:14.861] assign_globals() ...
[16:03:14.861] List of 11
[16:03:14.861]  $ ...future.FUN            :function (x, ...)  
[16:03:14.861]  $ x_FUN                    :function (x, y)  
[16:03:14.861]  $ times                    : int 15
[16:03:14.861]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.861]  $ stop_if_not              :function (...)  
[16:03:14.861]  $ dim                      : int [1:2] 3 5
[16:03:14.861]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:14.861]  $ future.call.arguments    :List of 1
[16:03:14.861]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:14.861]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.861]  $ ...future.elements_ii    :List of 2
[16:03:14.861]   ..$ A: num 50
[16:03:14.861]   ..$ B: num 60
[16:03:14.861]  $ ...future.seeds_ii       : NULL
[16:03:14.861]  $ ...future.globals.maxSize: NULL
[16:03:14.861]  - attr(*, "where")=List of 11
[16:03:14.861]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.861]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:14.861]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:14.861]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:14.861]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:14.861]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:14.861]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:14.861]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.861]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.861]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.861]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.861]  - attr(*, "resolved")= logi FALSE
[16:03:14.861]  - attr(*, "total_size")= num 98600
[16:03:14.861]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.861]  - attr(*, "already-done")= logi TRUE
[16:03:14.869] - copied ‘...future.FUN’ to environment
[16:03:14.869] - reassign environment for ‘x_FUN’
[16:03:14.870] - copied ‘x_FUN’ to environment
[16:03:14.870] - copied ‘times’ to environment
[16:03:14.870] - copied ‘stopf’ to environment
[16:03:14.870] - copied ‘stop_if_not’ to environment
[16:03:14.870] - copied ‘dim’ to environment
[16:03:14.870] - copied ‘valid_types’ to environment
[16:03:14.870] - copied ‘future.call.arguments’ to environment
[16:03:14.870] - copied ‘...future.elements_ii’ to environment
[16:03:14.872] - copied ‘...future.seeds_ii’ to environment
[16:03:14.873] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.873] assign_globals() ... done
[16:03:14.873] requestCore(): workers = 2
[16:03:14.875] MulticoreFuture started
[16:03:14.876] - Launch lazy future ... done
[16:03:14.877] run() for ‘MulticoreFuture’ ... done
[16:03:14.877] Created future:
[16:03:14.877] plan(): Setting new future strategy stack:
[16:03:14.878] List of future strategies:
[16:03:14.878] 1. sequential:
[16:03:14.878]    - args: function (..., envir = parent.frame())
[16:03:14.878]    - tweaked: FALSE
[16:03:14.878]    - call: NULL
[16:03:14.879] plan(): nbrOfWorkers() = 1
[16:03:14.882] plan(): Setting new future strategy stack:
[16:03:14.882] List of future strategies:
[16:03:14.882] 1. multicore:
[16:03:14.882]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.882]    - tweaked: FALSE
[16:03:14.882]    - call: plan(strategy)
[16:03:14.889] plan(): nbrOfWorkers() = 2
[16:03:14.878] MulticoreFuture:
[16:03:14.878] Label: ‘future_vapply-1’
[16:03:14.878] Expression:
[16:03:14.878] {
[16:03:14.878]     do.call(function(...) {
[16:03:14.878]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.878]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.878]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.878]             on.exit(options(oopts), add = TRUE)
[16:03:14.878]         }
[16:03:14.878]         {
[16:03:14.878]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.878]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.878]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.878]             })
[16:03:14.878]         }
[16:03:14.878]     }, args = future.call.arguments)
[16:03:14.878] }
[16:03:14.878] Lazy evaluation: FALSE
[16:03:14.878] Asynchronous evaluation: TRUE
[16:03:14.878] Local evaluation: TRUE
[16:03:14.878] Environment: R_GlobalEnv
[16:03:14.878] Capture standard output: TRUE
[16:03:14.878] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.878] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:14.878] Packages: 1 packages (‘future.apply’)
[16:03:14.878] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.878] Resolved: TRUE
[16:03:14.878] Value: <not collected>
[16:03:14.878] Conditions captured: <none>
[16:03:14.878] Early signaling: FALSE
[16:03:14.878] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.878] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.891] Chunk #1 of 2 ... DONE
[16:03:14.891] Chunk #2 of 2 ...
[16:03:14.891]  - Finding globals in 'X' for chunk #2 ...
[16:03:14.892] getGlobalsAndPackages() ...
[16:03:14.892] Searching for globals...
[16:03:14.892] 
[16:03:14.893] Searching for globals ... DONE
[16:03:14.893] - globals: [0] <none>
[16:03:14.893] getGlobalsAndPackages() ... DONE
[16:03:14.893]    + additional globals found: [n=0] 
[16:03:14.893]    + additional namespaces needed: [n=0] 
[16:03:14.893]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:14.894]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.894]  - seeds: <none>
[16:03:14.894]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.894] getGlobalsAndPackages() ...
[16:03:14.895] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.895] Resolving globals: FALSE
[16:03:14.895] Tweak future expression to call with '...' arguments ...
[16:03:14.895] {
[16:03:14.895]     do.call(function(...) {
[16:03:14.895]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.895]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.895]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.895]             on.exit(options(oopts), add = TRUE)
[16:03:14.895]         }
[16:03:14.895]         {
[16:03:14.895]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.895]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.895]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.895]             })
[16:03:14.895]         }
[16:03:14.895]     }, args = future.call.arguments)
[16:03:14.895] }
[16:03:14.896] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.897] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.897] - packages: [1] ‘future.apply’
[16:03:14.898] getGlobalsAndPackages() ... DONE
[16:03:14.898] run() for ‘Future’ ...
[16:03:14.899] - state: ‘created’
[16:03:14.899] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.904] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.904]   - Field: ‘label’
[16:03:14.904]   - Field: ‘local’
[16:03:14.904]   - Field: ‘owner’
[16:03:14.904]   - Field: ‘envir’
[16:03:14.905]   - Field: ‘workers’
[16:03:14.905]   - Field: ‘packages’
[16:03:14.905]   - Field: ‘gc’
[16:03:14.905]   - Field: ‘job’
[16:03:14.905]   - Field: ‘conditions’
[16:03:14.905]   - Field: ‘expr’
[16:03:14.906]   - Field: ‘uuid’
[16:03:14.906]   - Field: ‘seed’
[16:03:14.906]   - Field: ‘version’
[16:03:14.906]   - Field: ‘result’
[16:03:14.906]   - Field: ‘asynchronous’
[16:03:14.906]   - Field: ‘calls’
[16:03:14.906]   - Field: ‘globals’
[16:03:14.907]   - Field: ‘stdout’
[16:03:14.907]   - Field: ‘earlySignal’
[16:03:14.907]   - Field: ‘lazy’
[16:03:14.907]   - Field: ‘state’
[16:03:14.907] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.907] - Launch lazy future ...
[16:03:14.908] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:14.908] Packages needed by future strategies (n = 0): <none>
[16:03:14.909] {
[16:03:14.909]     {
[16:03:14.909]         {
[16:03:14.909]             ...future.startTime <- base::Sys.time()
[16:03:14.909]             {
[16:03:14.909]                 {
[16:03:14.909]                   {
[16:03:14.909]                     {
[16:03:14.909]                       {
[16:03:14.909]                         base::local({
[16:03:14.909]                           has_future <- base::requireNamespace("future", 
[16:03:14.909]                             quietly = TRUE)
[16:03:14.909]                           if (has_future) {
[16:03:14.909]                             ns <- base::getNamespace("future")
[16:03:14.909]                             version <- ns[[".package"]][["version"]]
[16:03:14.909]                             if (is.null(version)) 
[16:03:14.909]                               version <- utils::packageVersion("future")
[16:03:14.909]                           }
[16:03:14.909]                           else {
[16:03:14.909]                             version <- NULL
[16:03:14.909]                           }
[16:03:14.909]                           if (!has_future || version < "1.8.0") {
[16:03:14.909]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.909]                               "", base::R.version$version.string), 
[16:03:14.909]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.909]                                 base::R.version$platform, 8 * 
[16:03:14.909]                                   base::.Machine$sizeof.pointer), 
[16:03:14.909]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.909]                                 "release", "version")], collapse = " "), 
[16:03:14.909]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.909]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.909]                               info)
[16:03:14.909]                             info <- base::paste(info, collapse = "; ")
[16:03:14.909]                             if (!has_future) {
[16:03:14.909]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.909]                                 info)
[16:03:14.909]                             }
[16:03:14.909]                             else {
[16:03:14.909]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.909]                                 info, version)
[16:03:14.909]                             }
[16:03:14.909]                             base::stop(msg)
[16:03:14.909]                           }
[16:03:14.909]                         })
[16:03:14.909]                       }
[16:03:14.909]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.909]                       base::options(mc.cores = 1L)
[16:03:14.909]                     }
[16:03:14.909]                     base::local({
[16:03:14.909]                       for (pkg in "future.apply") {
[16:03:14.909]                         base::loadNamespace(pkg)
[16:03:14.909]                         base::library(pkg, character.only = TRUE)
[16:03:14.909]                       }
[16:03:14.909]                     })
[16:03:14.909]                   }
[16:03:14.909]                   options(future.plan = NULL)
[16:03:14.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.909]                 }
[16:03:14.909]                 ...future.workdir <- getwd()
[16:03:14.909]             }
[16:03:14.909]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.909]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.909]         }
[16:03:14.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.909]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.909]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.909]             base::names(...future.oldOptions))
[16:03:14.909]     }
[16:03:14.909]     if (FALSE) {
[16:03:14.909]     }
[16:03:14.909]     else {
[16:03:14.909]         if (TRUE) {
[16:03:14.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.909]                 open = "w")
[16:03:14.909]         }
[16:03:14.909]         else {
[16:03:14.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.909]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.909]         }
[16:03:14.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.909]             base::sink(type = "output", split = FALSE)
[16:03:14.909]             base::close(...future.stdout)
[16:03:14.909]         }, add = TRUE)
[16:03:14.909]     }
[16:03:14.909]     ...future.frame <- base::sys.nframe()
[16:03:14.909]     ...future.conditions <- base::list()
[16:03:14.909]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.909]     if (FALSE) {
[16:03:14.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.909]     }
[16:03:14.909]     ...future.result <- base::tryCatch({
[16:03:14.909]         base::withCallingHandlers({
[16:03:14.909]             ...future.value <- base::withVisible(base::local({
[16:03:14.909]                 withCallingHandlers({
[16:03:14.909]                   {
[16:03:14.909]                     do.call(function(...) {
[16:03:14.909]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.909]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.909]                         ...future.globals.maxSize)) {
[16:03:14.909]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.909]                         on.exit(options(oopts), add = TRUE)
[16:03:14.909]                       }
[16:03:14.909]                       {
[16:03:14.909]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.909]                           FUN = function(jj) {
[16:03:14.909]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.909]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.909]                           })
[16:03:14.909]                       }
[16:03:14.909]                     }, args = future.call.arguments)
[16:03:14.909]                   }
[16:03:14.909]                 }, immediateCondition = function(cond) {
[16:03:14.909]                   save_rds <- function (object, pathname, ...) 
[16:03:14.909]                   {
[16:03:14.909]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.909]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.909]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.909]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.909]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.909]                         fi_tmp[["mtime"]])
[16:03:14.909]                     }
[16:03:14.909]                     tryCatch({
[16:03:14.909]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.909]                     }, error = function(ex) {
[16:03:14.909]                       msg <- conditionMessage(ex)
[16:03:14.909]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.909]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.909]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.909]                         fi_tmp[["mtime"]], msg)
[16:03:14.909]                       ex$message <- msg
[16:03:14.909]                       stop(ex)
[16:03:14.909]                     })
[16:03:14.909]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.909]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.909]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.909]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.909]                       fi <- file.info(pathname)
[16:03:14.909]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.909]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.909]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.909]                         fi[["size"]], fi[["mtime"]])
[16:03:14.909]                       stop(msg)
[16:03:14.909]                     }
[16:03:14.909]                     invisible(pathname)
[16:03:14.909]                   }
[16:03:14.909]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.909]                     rootPath = tempdir()) 
[16:03:14.909]                   {
[16:03:14.909]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.909]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.909]                       tmpdir = path, fileext = ".rds")
[16:03:14.909]                     save_rds(obj, file)
[16:03:14.909]                   }
[16:03:14.909]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.909]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.909]                   {
[16:03:14.909]                     inherits <- base::inherits
[16:03:14.909]                     invokeRestart <- base::invokeRestart
[16:03:14.909]                     is.null <- base::is.null
[16:03:14.909]                     muffled <- FALSE
[16:03:14.909]                     if (inherits(cond, "message")) {
[16:03:14.909]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.909]                       if (muffled) 
[16:03:14.909]                         invokeRestart("muffleMessage")
[16:03:14.909]                     }
[16:03:14.909]                     else if (inherits(cond, "warning")) {
[16:03:14.909]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.909]                       if (muffled) 
[16:03:14.909]                         invokeRestart("muffleWarning")
[16:03:14.909]                     }
[16:03:14.909]                     else if (inherits(cond, "condition")) {
[16:03:14.909]                       if (!is.null(pattern)) {
[16:03:14.909]                         computeRestarts <- base::computeRestarts
[16:03:14.909]                         grepl <- base::grepl
[16:03:14.909]                         restarts <- computeRestarts(cond)
[16:03:14.909]                         for (restart in restarts) {
[16:03:14.909]                           name <- restart$name
[16:03:14.909]                           if (is.null(name)) 
[16:03:14.909]                             next
[16:03:14.909]                           if (!grepl(pattern, name)) 
[16:03:14.909]                             next
[16:03:14.909]                           invokeRestart(restart)
[16:03:14.909]                           muffled <- TRUE
[16:03:14.909]                           break
[16:03:14.909]                         }
[16:03:14.909]                       }
[16:03:14.909]                     }
[16:03:14.909]                     invisible(muffled)
[16:03:14.909]                   }
[16:03:14.909]                   muffleCondition(cond)
[16:03:14.909]                 })
[16:03:14.909]             }))
[16:03:14.909]             future::FutureResult(value = ...future.value$value, 
[16:03:14.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.909]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.909]                     ...future.globalenv.names))
[16:03:14.909]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.909]         }, condition = base::local({
[16:03:14.909]             c <- base::c
[16:03:14.909]             inherits <- base::inherits
[16:03:14.909]             invokeRestart <- base::invokeRestart
[16:03:14.909]             length <- base::length
[16:03:14.909]             list <- base::list
[16:03:14.909]             seq.int <- base::seq.int
[16:03:14.909]             signalCondition <- base::signalCondition
[16:03:14.909]             sys.calls <- base::sys.calls
[16:03:14.909]             `[[` <- base::`[[`
[16:03:14.909]             `+` <- base::`+`
[16:03:14.909]             `<<-` <- base::`<<-`
[16:03:14.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.909]                   3L)]
[16:03:14.909]             }
[16:03:14.909]             function(cond) {
[16:03:14.909]                 is_error <- inherits(cond, "error")
[16:03:14.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.909]                   NULL)
[16:03:14.909]                 if (is_error) {
[16:03:14.909]                   sessionInformation <- function() {
[16:03:14.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.909]                       search = base::search(), system = base::Sys.info())
[16:03:14.909]                   }
[16:03:14.909]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.909]                     cond$call), session = sessionInformation(), 
[16:03:14.909]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.909]                   signalCondition(cond)
[16:03:14.909]                 }
[16:03:14.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.909]                 "immediateCondition"))) {
[16:03:14.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.909]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.909]                   if (TRUE && !signal) {
[16:03:14.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.909]                     {
[16:03:14.909]                       inherits <- base::inherits
[16:03:14.909]                       invokeRestart <- base::invokeRestart
[16:03:14.909]                       is.null <- base::is.null
[16:03:14.909]                       muffled <- FALSE
[16:03:14.909]                       if (inherits(cond, "message")) {
[16:03:14.909]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.909]                         if (muffled) 
[16:03:14.909]                           invokeRestart("muffleMessage")
[16:03:14.909]                       }
[16:03:14.909]                       else if (inherits(cond, "warning")) {
[16:03:14.909]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.909]                         if (muffled) 
[16:03:14.909]                           invokeRestart("muffleWarning")
[16:03:14.909]                       }
[16:03:14.909]                       else if (inherits(cond, "condition")) {
[16:03:14.909]                         if (!is.null(pattern)) {
[16:03:14.909]                           computeRestarts <- base::computeRestarts
[16:03:14.909]                           grepl <- base::grepl
[16:03:14.909]                           restarts <- computeRestarts(cond)
[16:03:14.909]                           for (restart in restarts) {
[16:03:14.909]                             name <- restart$name
[16:03:14.909]                             if (is.null(name)) 
[16:03:14.909]                               next
[16:03:14.909]                             if (!grepl(pattern, name)) 
[16:03:14.909]                               next
[16:03:14.909]                             invokeRestart(restart)
[16:03:14.909]                             muffled <- TRUE
[16:03:14.909]                             break
[16:03:14.909]                           }
[16:03:14.909]                         }
[16:03:14.909]                       }
[16:03:14.909]                       invisible(muffled)
[16:03:14.909]                     }
[16:03:14.909]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.909]                   }
[16:03:14.909]                 }
[16:03:14.909]                 else {
[16:03:14.909]                   if (TRUE) {
[16:03:14.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.909]                     {
[16:03:14.909]                       inherits <- base::inherits
[16:03:14.909]                       invokeRestart <- base::invokeRestart
[16:03:14.909]                       is.null <- base::is.null
[16:03:14.909]                       muffled <- FALSE
[16:03:14.909]                       if (inherits(cond, "message")) {
[16:03:14.909]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.909]                         if (muffled) 
[16:03:14.909]                           invokeRestart("muffleMessage")
[16:03:14.909]                       }
[16:03:14.909]                       else if (inherits(cond, "warning")) {
[16:03:14.909]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.909]                         if (muffled) 
[16:03:14.909]                           invokeRestart("muffleWarning")
[16:03:14.909]                       }
[16:03:14.909]                       else if (inherits(cond, "condition")) {
[16:03:14.909]                         if (!is.null(pattern)) {
[16:03:14.909]                           computeRestarts <- base::computeRestarts
[16:03:14.909]                           grepl <- base::grepl
[16:03:14.909]                           restarts <- computeRestarts(cond)
[16:03:14.909]                           for (restart in restarts) {
[16:03:14.909]                             name <- restart$name
[16:03:14.909]                             if (is.null(name)) 
[16:03:14.909]                               next
[16:03:14.909]                             if (!grepl(pattern, name)) 
[16:03:14.909]                               next
[16:03:14.909]                             invokeRestart(restart)
[16:03:14.909]                             muffled <- TRUE
[16:03:14.909]                             break
[16:03:14.909]                           }
[16:03:14.909]                         }
[16:03:14.909]                       }
[16:03:14.909]                       invisible(muffled)
[16:03:14.909]                     }
[16:03:14.909]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.909]                   }
[16:03:14.909]                 }
[16:03:14.909]             }
[16:03:14.909]         }))
[16:03:14.909]     }, error = function(ex) {
[16:03:14.909]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.909]                 ...future.rng), started = ...future.startTime, 
[16:03:14.909]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.909]             version = "1.8"), class = "FutureResult")
[16:03:14.909]     }, finally = {
[16:03:14.909]         if (!identical(...future.workdir, getwd())) 
[16:03:14.909]             setwd(...future.workdir)
[16:03:14.909]         {
[16:03:14.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.909]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.909]             }
[16:03:14.909]             base::options(...future.oldOptions)
[16:03:14.909]             if (.Platform$OS.type == "windows") {
[16:03:14.909]                 old_names <- names(...future.oldEnvVars)
[16:03:14.909]                 envs <- base::Sys.getenv()
[16:03:14.909]                 names <- names(envs)
[16:03:14.909]                 common <- intersect(names, old_names)
[16:03:14.909]                 added <- setdiff(names, old_names)
[16:03:14.909]                 removed <- setdiff(old_names, names)
[16:03:14.909]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.909]                   envs[common]]
[16:03:14.909]                 NAMES <- toupper(changed)
[16:03:14.909]                 args <- list()
[16:03:14.909]                 for (kk in seq_along(NAMES)) {
[16:03:14.909]                   name <- changed[[kk]]
[16:03:14.909]                   NAME <- NAMES[[kk]]
[16:03:14.909]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.909]                     next
[16:03:14.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.909]                 }
[16:03:14.909]                 NAMES <- toupper(added)
[16:03:14.909]                 for (kk in seq_along(NAMES)) {
[16:03:14.909]                   name <- added[[kk]]
[16:03:14.909]                   NAME <- NAMES[[kk]]
[16:03:14.909]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.909]                     next
[16:03:14.909]                   args[[name]] <- ""
[16:03:14.909]                 }
[16:03:14.909]                 NAMES <- toupper(removed)
[16:03:14.909]                 for (kk in seq_along(NAMES)) {
[16:03:14.909]                   name <- removed[[kk]]
[16:03:14.909]                   NAME <- NAMES[[kk]]
[16:03:14.909]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.909]                     next
[16:03:14.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.909]                 }
[16:03:14.909]                 if (length(args) > 0) 
[16:03:14.909]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.909]             }
[16:03:14.909]             else {
[16:03:14.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.909]             }
[16:03:14.909]             {
[16:03:14.909]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.909]                   0L) {
[16:03:14.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.909]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.909]                   base::options(opts)
[16:03:14.909]                 }
[16:03:14.909]                 {
[16:03:14.909]                   {
[16:03:14.909]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.909]                     NULL
[16:03:14.909]                   }
[16:03:14.909]                   options(future.plan = NULL)
[16:03:14.909]                   if (is.na(NA_character_)) 
[16:03:14.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.909]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.909]                     envir = parent.frame()) 
[16:03:14.909]                   {
[16:03:14.909]                     default_workers <- missing(workers)
[16:03:14.909]                     if (is.function(workers)) 
[16:03:14.909]                       workers <- workers()
[16:03:14.909]                     workers <- structure(as.integer(workers), 
[16:03:14.909]                       class = class(workers))
[16:03:14.909]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.909]                       1L)
[16:03:14.909]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.909]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.909]                       if (default_workers) 
[16:03:14.909]                         supportsMulticore(warn = TRUE)
[16:03:14.909]                       return(sequential(..., envir = envir))
[16:03:14.909]                     }
[16:03:14.909]                     oopts <- options(mc.cores = workers)
[16:03:14.909]                     on.exit(options(oopts))
[16:03:14.909]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.909]                       envir = envir)
[16:03:14.909]                     if (!future$lazy) 
[16:03:14.909]                       future <- run(future)
[16:03:14.909]                     invisible(future)
[16:03:14.909]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.909]                 }
[16:03:14.909]             }
[16:03:14.909]         }
[16:03:14.909]     })
[16:03:14.909]     if (TRUE) {
[16:03:14.909]         base::sink(type = "output", split = FALSE)
[16:03:14.909]         if (TRUE) {
[16:03:14.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.909]         }
[16:03:14.909]         else {
[16:03:14.909]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.909]         }
[16:03:14.909]         base::close(...future.stdout)
[16:03:14.909]         ...future.stdout <- NULL
[16:03:14.909]     }
[16:03:14.909]     ...future.result$conditions <- ...future.conditions
[16:03:14.909]     ...future.result$finished <- base::Sys.time()
[16:03:14.909]     ...future.result
[16:03:14.909] }
[16:03:14.912] assign_globals() ...
[16:03:14.912] List of 11
[16:03:14.912]  $ ...future.FUN            :function (x, ...)  
[16:03:14.912]  $ x_FUN                    :function (x, y)  
[16:03:14.912]  $ times                    : int 15
[16:03:14.912]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.912]  $ stop_if_not              :function (...)  
[16:03:14.912]  $ dim                      : int [1:2] 3 5
[16:03:14.912]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:14.912]  $ future.call.arguments    :List of 1
[16:03:14.912]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:14.912]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.912]  $ ...future.elements_ii    :List of 2
[16:03:14.912]   ..$ C: num 70
[16:03:14.912]   ..$ D: num 80
[16:03:14.912]  $ ...future.seeds_ii       : NULL
[16:03:14.912]  $ ...future.globals.maxSize: NULL
[16:03:14.912]  - attr(*, "where")=List of 11
[16:03:14.912]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:14.912]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:14.912]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:14.912]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:14.912]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:14.912]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:14.912]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:14.912]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:14.912]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:14.912]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:14.912]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:14.912]  - attr(*, "resolved")= logi FALSE
[16:03:14.912]  - attr(*, "total_size")= num 98600
[16:03:14.912]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.912]  - attr(*, "already-done")= logi TRUE
[16:03:14.924] - copied ‘...future.FUN’ to environment
[16:03:14.924] - reassign environment for ‘x_FUN’
[16:03:14.924] - copied ‘x_FUN’ to environment
[16:03:14.925] - copied ‘times’ to environment
[16:03:14.925] - copied ‘stopf’ to environment
[16:03:14.925] - copied ‘stop_if_not’ to environment
[16:03:14.925] - copied ‘dim’ to environment
[16:03:14.925] - copied ‘valid_types’ to environment
[16:03:14.925] - copied ‘future.call.arguments’ to environment
[16:03:14.925] - copied ‘...future.elements_ii’ to environment
[16:03:14.925] - copied ‘...future.seeds_ii’ to environment
[16:03:14.925] - copied ‘...future.globals.maxSize’ to environment
[16:03:14.926] assign_globals() ... done
[16:03:14.926] requestCore(): workers = 2
[16:03:14.928] MulticoreFuture started
[16:03:14.929] - Launch lazy future ... done
[16:03:14.929] run() for ‘MulticoreFuture’ ... done
[16:03:14.930] Created future:
[16:03:14.930] plan(): Setting new future strategy stack:
[16:03:14.930] List of future strategies:
[16:03:14.930] 1. sequential:
[16:03:14.930]    - args: function (..., envir = parent.frame())
[16:03:14.930]    - tweaked: FALSE
[16:03:14.930]    - call: NULL
[16:03:14.932] plan(): nbrOfWorkers() = 1
[16:03:14.934] plan(): Setting new future strategy stack:
[16:03:14.934] List of future strategies:
[16:03:14.934] 1. multicore:
[16:03:14.934]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:14.934]    - tweaked: FALSE
[16:03:14.934]    - call: plan(strategy)
[16:03:14.941] plan(): nbrOfWorkers() = 2
[16:03:14.930] MulticoreFuture:
[16:03:14.930] Label: ‘future_vapply-2’
[16:03:14.930] Expression:
[16:03:14.930] {
[16:03:14.930]     do.call(function(...) {
[16:03:14.930]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.930]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.930]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.930]             on.exit(options(oopts), add = TRUE)
[16:03:14.930]         }
[16:03:14.930]         {
[16:03:14.930]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.930]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.930]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.930]             })
[16:03:14.930]         }
[16:03:14.930]     }, args = future.call.arguments)
[16:03:14.930] }
[16:03:14.930] Lazy evaluation: FALSE
[16:03:14.930] Asynchronous evaluation: TRUE
[16:03:14.930] Local evaluation: TRUE
[16:03:14.930] Environment: R_GlobalEnv
[16:03:14.930] Capture standard output: TRUE
[16:03:14.930] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:14.930] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:14.930] Packages: 1 packages (‘future.apply’)
[16:03:14.930] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:14.930] Resolved: TRUE
[16:03:14.930] Value: <not collected>
[16:03:14.930] Conditions captured: <none>
[16:03:14.930] Early signaling: FALSE
[16:03:14.930] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:14.930] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.943] Chunk #2 of 2 ... DONE
[16:03:14.943] Launching 2 futures (chunks) ... DONE
[16:03:14.943] Resolving 2 futures (chunks) ...
[16:03:14.943] resolve() on list ...
[16:03:14.943]  recursive: 0
[16:03:14.944]  length: 2
[16:03:14.944] 
[16:03:14.944] Future #1
[16:03:14.944] result() for MulticoreFuture ...
[16:03:14.945] result() for MulticoreFuture ...
[16:03:14.946] result() for MulticoreFuture ... done
[16:03:14.946] result() for MulticoreFuture ... done
[16:03:14.946] result() for MulticoreFuture ...
[16:03:14.946] result() for MulticoreFuture ... done
[16:03:14.946] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:14.946] - nx: 2
[16:03:14.947] - relay: TRUE
[16:03:14.947] - stdout: TRUE
[16:03:14.947] - signal: TRUE
[16:03:14.947] - resignal: FALSE
[16:03:14.947] - force: TRUE
[16:03:14.947] - relayed: [n=2] FALSE, FALSE
[16:03:14.947] - queued futures: [n=2] FALSE, FALSE
[16:03:14.948]  - until=1
[16:03:14.948]  - relaying element #1
[16:03:14.948] result() for MulticoreFuture ...
[16:03:14.948] result() for MulticoreFuture ... done
[16:03:14.948] result() for MulticoreFuture ...
[16:03:14.949] result() for MulticoreFuture ... done
[16:03:14.949] result() for MulticoreFuture ...
[16:03:14.949] result() for MulticoreFuture ... done
[16:03:14.949] result() for MulticoreFuture ...
[16:03:14.949] result() for MulticoreFuture ... done
[16:03:14.950] - relayed: [n=2] TRUE, FALSE
[16:03:14.950] - queued futures: [n=2] TRUE, FALSE
[16:03:14.950] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:14.950]  length: 1 (resolved future 1)
[16:03:14.950] Future #2
[16:03:14.950] result() for MulticoreFuture ...
[16:03:14.951] result() for MulticoreFuture ...
[16:03:14.951] result() for MulticoreFuture ... done
[16:03:14.951] result() for MulticoreFuture ... done
[16:03:14.952] result() for MulticoreFuture ...
[16:03:14.952] result() for MulticoreFuture ... done
[16:03:14.952] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:14.952] - nx: 2
[16:03:14.952] - relay: TRUE
[16:03:14.952] - stdout: TRUE
[16:03:14.952] - signal: TRUE
[16:03:14.953] - resignal: FALSE
[16:03:14.953] - force: TRUE
[16:03:14.953] - relayed: [n=2] TRUE, FALSE
[16:03:14.953] - queued futures: [n=2] TRUE, FALSE
[16:03:14.953]  - until=2
[16:03:14.953]  - relaying element #2
[16:03:14.953] result() for MulticoreFuture ...
[16:03:14.953] result() for MulticoreFuture ... done
[16:03:14.953] result() for MulticoreFuture ...
[16:03:14.953] result() for MulticoreFuture ... done
[16:03:14.954] result() for MulticoreFuture ...
[16:03:14.954] result() for MulticoreFuture ... done
[16:03:14.954] result() for MulticoreFuture ...
[16:03:14.954] result() for MulticoreFuture ... done
[16:03:14.954] - relayed: [n=2] TRUE, TRUE
[16:03:14.954] - queued futures: [n=2] TRUE, TRUE
[16:03:14.954] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:14.954]  length: 0 (resolved future 2)
[16:03:14.955] Relaying remaining futures
[16:03:14.955] signalConditionsASAP(NULL, pos=0) ...
[16:03:14.955] - nx: 2
[16:03:14.955] - relay: TRUE
[16:03:14.955] - stdout: TRUE
[16:03:14.955] - signal: TRUE
[16:03:14.955] - resignal: FALSE
[16:03:14.955] - force: TRUE
[16:03:14.955] - relayed: [n=2] TRUE, TRUE
[16:03:14.956] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:14.956] - relayed: [n=2] TRUE, TRUE
[16:03:14.956] - queued futures: [n=2] TRUE, TRUE
[16:03:14.956] signalConditionsASAP(NULL, pos=0) ... done
[16:03:14.956] resolve() on list ... DONE
[16:03:14.956] result() for MulticoreFuture ...
[16:03:14.956] result() for MulticoreFuture ... done
[16:03:14.956] result() for MulticoreFuture ...
[16:03:14.956] result() for MulticoreFuture ... done
[16:03:14.957] result() for MulticoreFuture ...
[16:03:14.957] result() for MulticoreFuture ... done
[16:03:14.957] result() for MulticoreFuture ...
[16:03:14.957] result() for MulticoreFuture ... done
[16:03:14.957]  - Number of value chunks collected: 2
[16:03:14.957] Resolving 2 futures (chunks) ... DONE
[16:03:14.957] Reducing values from 2 chunks ...
[16:03:14.957]  - Number of values collected after concatenation: 4
[16:03:14.957]  - Number of values expected: 4
[16:03:14.958] Reducing values from 2 chunks ... DONE
[16:03:14.958] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[16:03:14.960] future_lapply() ...
[16:03:14.968] Number of chunks: 2
[16:03:14.969] getGlobalsAndPackagesXApply() ...
[16:03:14.969]  - future.globals: TRUE
[16:03:14.969] getGlobalsAndPackages() ...
[16:03:14.969] Searching for globals...
[16:03:14.973] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:14.973] Searching for globals ... DONE
[16:03:14.973] Resolving globals: FALSE
[16:03:14.974] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[16:03:14.974] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:14.974] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.975] - packages: [1] ‘future.apply’
[16:03:14.975] getGlobalsAndPackages() ... DONE
[16:03:14.975]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:14.975]  - needed namespaces: [n=1] ‘future.apply’
[16:03:14.975] Finding globals ... DONE
[16:03:14.975]  - use_args: TRUE
[16:03:14.975]  - Getting '...' globals ...
[16:03:14.976] resolve() on list ...
[16:03:14.976]  recursive: 0
[16:03:14.976]  length: 1
[16:03:14.976]  elements: ‘...’
[16:03:14.976]  length: 0 (resolved future 1)
[16:03:14.976] resolve() on list ... DONE
[16:03:14.976]    - '...' content: [n=0] 
[16:03:14.976] List of 1
[16:03:14.976]  $ ...: list()
[16:03:14.976]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.976]  - attr(*, "where")=List of 1
[16:03:14.976]   ..$ ...:<environment: 0x564e42b45e98> 
[16:03:14.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.976]  - attr(*, "resolved")= logi TRUE
[16:03:14.976]  - attr(*, "total_size")= num NA
[16:03:14.979]  - Getting '...' globals ... DONE
[16:03:14.979] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:14.979] List of 8
[16:03:14.979]  $ ...future.FUN:function (x, ...)  
[16:03:14.979]  $ x_FUN        :function (x)  
[16:03:14.979]  $ times        : int 1
[16:03:14.979]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:14.979]  $ stop_if_not  :function (...)  
[16:03:14.979]  $ dim          : NULL
[16:03:14.979]  $ valid_types  : chr "logical"
[16:03:14.979]  $ ...          : list()
[16:03:14.979]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:14.979]  - attr(*, "where")=List of 8
[16:03:14.979]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:14.979]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:14.979]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:14.979]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:14.979]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:14.979]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:14.979]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:14.979]   ..$ ...          :<environment: 0x564e42b45e98> 
[16:03:14.979]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:14.979]  - attr(*, "resolved")= logi FALSE
[16:03:14.979]  - attr(*, "total_size")= num 94200
[16:03:14.986] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:14.987] getGlobalsAndPackagesXApply() ... DONE
[16:03:14.987] Number of futures (= number of chunks): 2
[16:03:14.987] Launching 2 futures (chunks) ...
[16:03:14.987] Chunk #1 of 2 ...
[16:03:14.987]  - Finding globals in 'X' for chunk #1 ...
[16:03:14.987] getGlobalsAndPackages() ...
[16:03:14.987] Searching for globals...
[16:03:14.988] 
[16:03:14.988] Searching for globals ... DONE
[16:03:14.988] - globals: [0] <none>
[16:03:14.988] getGlobalsAndPackages() ... DONE
[16:03:14.988]    + additional globals found: [n=0] 
[16:03:14.988]    + additional namespaces needed: [n=0] 
[16:03:14.988]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:14.988]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:14.988]  - seeds: <none>
[16:03:14.989]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.989] getGlobalsAndPackages() ...
[16:03:14.989] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.989] Resolving globals: FALSE
[16:03:14.989] Tweak future expression to call with '...' arguments ...
[16:03:14.989] {
[16:03:14.989]     do.call(function(...) {
[16:03:14.989]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.989]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:14.989]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.989]             on.exit(options(oopts), add = TRUE)
[16:03:14.989]         }
[16:03:14.989]         {
[16:03:14.989]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:14.989]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.989]                 ...future.FUN(...future.X_jj, ...)
[16:03:14.989]             })
[16:03:14.989]         }
[16:03:14.989]     }, args = future.call.arguments)
[16:03:14.989] }
[16:03:14.989] Tweak future expression to call with '...' arguments ... DONE
[16:03:14.990] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:14.990] - packages: [1] ‘future.apply’
[16:03:14.990] getGlobalsAndPackages() ... DONE
[16:03:14.991] run() for ‘Future’ ...
[16:03:14.991] - state: ‘created’
[16:03:14.991] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:14.994] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:14.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:14.995]   - Field: ‘label’
[16:03:14.995]   - Field: ‘local’
[16:03:14.995]   - Field: ‘owner’
[16:03:14.995]   - Field: ‘envir’
[16:03:14.995]   - Field: ‘workers’
[16:03:14.995]   - Field: ‘packages’
[16:03:14.995]   - Field: ‘gc’
[16:03:14.995]   - Field: ‘job’
[16:03:14.995]   - Field: ‘conditions’
[16:03:14.996]   - Field: ‘expr’
[16:03:14.996]   - Field: ‘uuid’
[16:03:14.996]   - Field: ‘seed’
[16:03:14.996]   - Field: ‘version’
[16:03:14.996]   - Field: ‘result’
[16:03:14.996]   - Field: ‘asynchronous’
[16:03:14.996]   - Field: ‘calls’
[16:03:14.996]   - Field: ‘globals’
[16:03:14.996]   - Field: ‘stdout’
[16:03:14.996]   - Field: ‘earlySignal’
[16:03:14.997]   - Field: ‘lazy’
[16:03:14.997]   - Field: ‘state’
[16:03:14.997] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:14.997] - Launch lazy future ...
[16:03:14.997] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:14.997] Packages needed by future strategies (n = 0): <none>
[16:03:14.998] {
[16:03:14.998]     {
[16:03:14.998]         {
[16:03:14.998]             ...future.startTime <- base::Sys.time()
[16:03:14.998]             {
[16:03:14.998]                 {
[16:03:14.998]                   {
[16:03:14.998]                     {
[16:03:14.998]                       {
[16:03:14.998]                         base::local({
[16:03:14.998]                           has_future <- base::requireNamespace("future", 
[16:03:14.998]                             quietly = TRUE)
[16:03:14.998]                           if (has_future) {
[16:03:14.998]                             ns <- base::getNamespace("future")
[16:03:14.998]                             version <- ns[[".package"]][["version"]]
[16:03:14.998]                             if (is.null(version)) 
[16:03:14.998]                               version <- utils::packageVersion("future")
[16:03:14.998]                           }
[16:03:14.998]                           else {
[16:03:14.998]                             version <- NULL
[16:03:14.998]                           }
[16:03:14.998]                           if (!has_future || version < "1.8.0") {
[16:03:14.998]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:14.998]                               "", base::R.version$version.string), 
[16:03:14.998]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:14.998]                                 base::R.version$platform, 8 * 
[16:03:14.998]                                   base::.Machine$sizeof.pointer), 
[16:03:14.998]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:14.998]                                 "release", "version")], collapse = " "), 
[16:03:14.998]                               hostname = base::Sys.info()[["nodename"]])
[16:03:14.998]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:14.998]                               info)
[16:03:14.998]                             info <- base::paste(info, collapse = "; ")
[16:03:14.998]                             if (!has_future) {
[16:03:14.998]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:14.998]                                 info)
[16:03:14.998]                             }
[16:03:14.998]                             else {
[16:03:14.998]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:14.998]                                 info, version)
[16:03:14.998]                             }
[16:03:14.998]                             base::stop(msg)
[16:03:14.998]                           }
[16:03:14.998]                         })
[16:03:14.998]                       }
[16:03:14.998]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:14.998]                       base::options(mc.cores = 1L)
[16:03:14.998]                     }
[16:03:14.998]                     base::local({
[16:03:14.998]                       for (pkg in "future.apply") {
[16:03:14.998]                         base::loadNamespace(pkg)
[16:03:14.998]                         base::library(pkg, character.only = TRUE)
[16:03:14.998]                       }
[16:03:14.998]                     })
[16:03:14.998]                   }
[16:03:14.998]                   options(future.plan = NULL)
[16:03:14.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:14.998]                 }
[16:03:14.998]                 ...future.workdir <- getwd()
[16:03:14.998]             }
[16:03:14.998]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:14.998]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:14.998]         }
[16:03:14.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:14.998]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:14.998]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:14.998]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:14.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:14.998]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:14.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:14.998]             base::names(...future.oldOptions))
[16:03:14.998]     }
[16:03:14.998]     if (FALSE) {
[16:03:14.998]     }
[16:03:14.998]     else {
[16:03:14.998]         if (TRUE) {
[16:03:14.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:14.998]                 open = "w")
[16:03:14.998]         }
[16:03:14.998]         else {
[16:03:14.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:14.998]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:14.998]         }
[16:03:14.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:14.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:14.998]             base::sink(type = "output", split = FALSE)
[16:03:14.998]             base::close(...future.stdout)
[16:03:14.998]         }, add = TRUE)
[16:03:14.998]     }
[16:03:14.998]     ...future.frame <- base::sys.nframe()
[16:03:14.998]     ...future.conditions <- base::list()
[16:03:14.998]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:14.998]     if (FALSE) {
[16:03:14.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:14.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:14.998]     }
[16:03:14.998]     ...future.result <- base::tryCatch({
[16:03:14.998]         base::withCallingHandlers({
[16:03:14.998]             ...future.value <- base::withVisible(base::local({
[16:03:14.998]                 withCallingHandlers({
[16:03:14.998]                   {
[16:03:14.998]                     do.call(function(...) {
[16:03:14.998]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:14.998]                       if (!identical(...future.globals.maxSize.org, 
[16:03:14.998]                         ...future.globals.maxSize)) {
[16:03:14.998]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:14.998]                         on.exit(options(oopts), add = TRUE)
[16:03:14.998]                       }
[16:03:14.998]                       {
[16:03:14.998]                         lapply(seq_along(...future.elements_ii), 
[16:03:14.998]                           FUN = function(jj) {
[16:03:14.998]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:14.998]                             ...future.FUN(...future.X_jj, ...)
[16:03:14.998]                           })
[16:03:14.998]                       }
[16:03:14.998]                     }, args = future.call.arguments)
[16:03:14.998]                   }
[16:03:14.998]                 }, immediateCondition = function(cond) {
[16:03:14.998]                   save_rds <- function (object, pathname, ...) 
[16:03:14.998]                   {
[16:03:14.998]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:14.998]                     if (file_test("-f", pathname_tmp)) {
[16:03:14.998]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.998]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:14.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.998]                         fi_tmp[["mtime"]])
[16:03:14.998]                     }
[16:03:14.998]                     tryCatch({
[16:03:14.998]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:14.998]                     }, error = function(ex) {
[16:03:14.998]                       msg <- conditionMessage(ex)
[16:03:14.998]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.998]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:14.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.998]                         fi_tmp[["mtime"]], msg)
[16:03:14.998]                       ex$message <- msg
[16:03:14.998]                       stop(ex)
[16:03:14.998]                     })
[16:03:14.998]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:14.998]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:14.998]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:14.998]                       fi_tmp <- file.info(pathname_tmp)
[16:03:14.998]                       fi <- file.info(pathname)
[16:03:14.998]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:14.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:14.998]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:14.998]                         fi[["size"]], fi[["mtime"]])
[16:03:14.998]                       stop(msg)
[16:03:14.998]                     }
[16:03:14.998]                     invisible(pathname)
[16:03:14.998]                   }
[16:03:14.998]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:14.998]                     rootPath = tempdir()) 
[16:03:14.998]                   {
[16:03:14.998]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:14.998]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:14.998]                       tmpdir = path, fileext = ".rds")
[16:03:14.998]                     save_rds(obj, file)
[16:03:14.998]                   }
[16:03:14.998]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:14.998]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.998]                   {
[16:03:14.998]                     inherits <- base::inherits
[16:03:14.998]                     invokeRestart <- base::invokeRestart
[16:03:14.998]                     is.null <- base::is.null
[16:03:14.998]                     muffled <- FALSE
[16:03:14.998]                     if (inherits(cond, "message")) {
[16:03:14.998]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:14.998]                       if (muffled) 
[16:03:14.998]                         invokeRestart("muffleMessage")
[16:03:14.998]                     }
[16:03:14.998]                     else if (inherits(cond, "warning")) {
[16:03:14.998]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:14.998]                       if (muffled) 
[16:03:14.998]                         invokeRestart("muffleWarning")
[16:03:14.998]                     }
[16:03:14.998]                     else if (inherits(cond, "condition")) {
[16:03:14.998]                       if (!is.null(pattern)) {
[16:03:14.998]                         computeRestarts <- base::computeRestarts
[16:03:14.998]                         grepl <- base::grepl
[16:03:14.998]                         restarts <- computeRestarts(cond)
[16:03:14.998]                         for (restart in restarts) {
[16:03:14.998]                           name <- restart$name
[16:03:14.998]                           if (is.null(name)) 
[16:03:14.998]                             next
[16:03:14.998]                           if (!grepl(pattern, name)) 
[16:03:14.998]                             next
[16:03:14.998]                           invokeRestart(restart)
[16:03:14.998]                           muffled <- TRUE
[16:03:14.998]                           break
[16:03:14.998]                         }
[16:03:14.998]                       }
[16:03:14.998]                     }
[16:03:14.998]                     invisible(muffled)
[16:03:14.998]                   }
[16:03:14.998]                   muffleCondition(cond)
[16:03:14.998]                 })
[16:03:14.998]             }))
[16:03:14.998]             future::FutureResult(value = ...future.value$value, 
[16:03:14.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.998]                   ...future.rng), globalenv = if (FALSE) 
[16:03:14.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:14.998]                     ...future.globalenv.names))
[16:03:14.998]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:14.998]         }, condition = base::local({
[16:03:14.998]             c <- base::c
[16:03:14.998]             inherits <- base::inherits
[16:03:14.998]             invokeRestart <- base::invokeRestart
[16:03:14.998]             length <- base::length
[16:03:14.998]             list <- base::list
[16:03:14.998]             seq.int <- base::seq.int
[16:03:14.998]             signalCondition <- base::signalCondition
[16:03:14.998]             sys.calls <- base::sys.calls
[16:03:14.998]             `[[` <- base::`[[`
[16:03:14.998]             `+` <- base::`+`
[16:03:14.998]             `<<-` <- base::`<<-`
[16:03:14.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:14.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:14.998]                   3L)]
[16:03:14.998]             }
[16:03:14.998]             function(cond) {
[16:03:14.998]                 is_error <- inherits(cond, "error")
[16:03:14.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:14.998]                   NULL)
[16:03:14.998]                 if (is_error) {
[16:03:14.998]                   sessionInformation <- function() {
[16:03:14.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:14.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:14.998]                       search = base::search(), system = base::Sys.info())
[16:03:14.998]                   }
[16:03:14.998]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:14.998]                     cond$call), session = sessionInformation(), 
[16:03:14.998]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:14.998]                   signalCondition(cond)
[16:03:14.998]                 }
[16:03:14.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:14.998]                 "immediateCondition"))) {
[16:03:14.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:14.998]                   ...future.conditions[[length(...future.conditions) + 
[16:03:14.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:14.998]                   if (TRUE && !signal) {
[16:03:14.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.998]                     {
[16:03:14.998]                       inherits <- base::inherits
[16:03:14.998]                       invokeRestart <- base::invokeRestart
[16:03:14.998]                       is.null <- base::is.null
[16:03:14.998]                       muffled <- FALSE
[16:03:14.998]                       if (inherits(cond, "message")) {
[16:03:14.998]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.998]                         if (muffled) 
[16:03:14.998]                           invokeRestart("muffleMessage")
[16:03:14.998]                       }
[16:03:14.998]                       else if (inherits(cond, "warning")) {
[16:03:14.998]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.998]                         if (muffled) 
[16:03:14.998]                           invokeRestart("muffleWarning")
[16:03:14.998]                       }
[16:03:14.998]                       else if (inherits(cond, "condition")) {
[16:03:14.998]                         if (!is.null(pattern)) {
[16:03:14.998]                           computeRestarts <- base::computeRestarts
[16:03:14.998]                           grepl <- base::grepl
[16:03:14.998]                           restarts <- computeRestarts(cond)
[16:03:14.998]                           for (restart in restarts) {
[16:03:14.998]                             name <- restart$name
[16:03:14.998]                             if (is.null(name)) 
[16:03:14.998]                               next
[16:03:14.998]                             if (!grepl(pattern, name)) 
[16:03:14.998]                               next
[16:03:14.998]                             invokeRestart(restart)
[16:03:14.998]                             muffled <- TRUE
[16:03:14.998]                             break
[16:03:14.998]                           }
[16:03:14.998]                         }
[16:03:14.998]                       }
[16:03:14.998]                       invisible(muffled)
[16:03:14.998]                     }
[16:03:14.998]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.998]                   }
[16:03:14.998]                 }
[16:03:14.998]                 else {
[16:03:14.998]                   if (TRUE) {
[16:03:14.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:14.998]                     {
[16:03:14.998]                       inherits <- base::inherits
[16:03:14.998]                       invokeRestart <- base::invokeRestart
[16:03:14.998]                       is.null <- base::is.null
[16:03:14.998]                       muffled <- FALSE
[16:03:14.998]                       if (inherits(cond, "message")) {
[16:03:14.998]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:14.998]                         if (muffled) 
[16:03:14.998]                           invokeRestart("muffleMessage")
[16:03:14.998]                       }
[16:03:14.998]                       else if (inherits(cond, "warning")) {
[16:03:14.998]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:14.998]                         if (muffled) 
[16:03:14.998]                           invokeRestart("muffleWarning")
[16:03:14.998]                       }
[16:03:14.998]                       else if (inherits(cond, "condition")) {
[16:03:14.998]                         if (!is.null(pattern)) {
[16:03:14.998]                           computeRestarts <- base::computeRestarts
[16:03:14.998]                           grepl <- base::grepl
[16:03:14.998]                           restarts <- computeRestarts(cond)
[16:03:14.998]                           for (restart in restarts) {
[16:03:14.998]                             name <- restart$name
[16:03:14.998]                             if (is.null(name)) 
[16:03:14.998]                               next
[16:03:14.998]                             if (!grepl(pattern, name)) 
[16:03:14.998]                               next
[16:03:14.998]                             invokeRestart(restart)
[16:03:14.998]                             muffled <- TRUE
[16:03:14.998]                             break
[16:03:14.998]                           }
[16:03:14.998]                         }
[16:03:14.998]                       }
[16:03:14.998]                       invisible(muffled)
[16:03:14.998]                     }
[16:03:14.998]                     muffleCondition(cond, pattern = "^muffle")
[16:03:14.998]                   }
[16:03:14.998]                 }
[16:03:14.998]             }
[16:03:14.998]         }))
[16:03:14.998]     }, error = function(ex) {
[16:03:14.998]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:14.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:14.998]                 ...future.rng), started = ...future.startTime, 
[16:03:14.998]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:14.998]             version = "1.8"), class = "FutureResult")
[16:03:14.998]     }, finally = {
[16:03:14.998]         if (!identical(...future.workdir, getwd())) 
[16:03:14.998]             setwd(...future.workdir)
[16:03:14.998]         {
[16:03:14.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:14.998]                 ...future.oldOptions$nwarnings <- NULL
[16:03:14.998]             }
[16:03:14.998]             base::options(...future.oldOptions)
[16:03:14.998]             if (.Platform$OS.type == "windows") {
[16:03:14.998]                 old_names <- names(...future.oldEnvVars)
[16:03:14.998]                 envs <- base::Sys.getenv()
[16:03:14.998]                 names <- names(envs)
[16:03:14.998]                 common <- intersect(names, old_names)
[16:03:14.998]                 added <- setdiff(names, old_names)
[16:03:14.998]                 removed <- setdiff(old_names, names)
[16:03:14.998]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:14.998]                   envs[common]]
[16:03:14.998]                 NAMES <- toupper(changed)
[16:03:14.998]                 args <- list()
[16:03:14.998]                 for (kk in seq_along(NAMES)) {
[16:03:14.998]                   name <- changed[[kk]]
[16:03:14.998]                   NAME <- NAMES[[kk]]
[16:03:14.998]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.998]                     next
[16:03:14.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.998]                 }
[16:03:14.998]                 NAMES <- toupper(added)
[16:03:14.998]                 for (kk in seq_along(NAMES)) {
[16:03:14.998]                   name <- added[[kk]]
[16:03:14.998]                   NAME <- NAMES[[kk]]
[16:03:14.998]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.998]                     next
[16:03:14.998]                   args[[name]] <- ""
[16:03:14.998]                 }
[16:03:14.998]                 NAMES <- toupper(removed)
[16:03:14.998]                 for (kk in seq_along(NAMES)) {
[16:03:14.998]                   name <- removed[[kk]]
[16:03:14.998]                   NAME <- NAMES[[kk]]
[16:03:14.998]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:14.998]                     next
[16:03:14.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:14.998]                 }
[16:03:14.998]                 if (length(args) > 0) 
[16:03:14.998]                   base::do.call(base::Sys.setenv, args = args)
[16:03:14.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:14.998]             }
[16:03:14.998]             else {
[16:03:14.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:14.998]             }
[16:03:14.998]             {
[16:03:14.998]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:14.998]                   0L) {
[16:03:14.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:14.998]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:14.998]                   base::options(opts)
[16:03:14.998]                 }
[16:03:14.998]                 {
[16:03:14.998]                   {
[16:03:14.998]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:14.998]                     NULL
[16:03:14.998]                   }
[16:03:14.998]                   options(future.plan = NULL)
[16:03:14.998]                   if (is.na(NA_character_)) 
[16:03:14.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:14.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:14.998]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:14.998]                     envir = parent.frame()) 
[16:03:14.998]                   {
[16:03:14.998]                     default_workers <- missing(workers)
[16:03:14.998]                     if (is.function(workers)) 
[16:03:14.998]                       workers <- workers()
[16:03:14.998]                     workers <- structure(as.integer(workers), 
[16:03:14.998]                       class = class(workers))
[16:03:14.998]                     stop_if_not(is.finite(workers), workers >= 
[16:03:14.998]                       1L)
[16:03:14.998]                     if ((workers == 1L && !inherits(workers, 
[16:03:14.998]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:14.998]                       if (default_workers) 
[16:03:14.998]                         supportsMulticore(warn = TRUE)
[16:03:14.998]                       return(sequential(..., envir = envir))
[16:03:14.998]                     }
[16:03:14.998]                     oopts <- options(mc.cores = workers)
[16:03:14.998]                     on.exit(options(oopts))
[16:03:14.998]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:14.998]                       envir = envir)
[16:03:14.998]                     if (!future$lazy) 
[16:03:14.998]                       future <- run(future)
[16:03:14.998]                     invisible(future)
[16:03:14.998]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:14.998]                 }
[16:03:14.998]             }
[16:03:14.998]         }
[16:03:14.998]     })
[16:03:14.998]     if (TRUE) {
[16:03:14.998]         base::sink(type = "output", split = FALSE)
[16:03:14.998]         if (TRUE) {
[16:03:14.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:14.998]         }
[16:03:14.998]         else {
[16:03:14.998]             ...future.result["stdout"] <- base::list(NULL)
[16:03:14.998]         }
[16:03:14.998]         base::close(...future.stdout)
[16:03:14.998]         ...future.stdout <- NULL
[16:03:14.998]     }
[16:03:14.998]     ...future.result$conditions <- ...future.conditions
[16:03:14.998]     ...future.result$finished <- base::Sys.time()
[16:03:14.998]     ...future.result
[16:03:14.998] }
[16:03:15.001] assign_globals() ...
[16:03:15.001] List of 11
[16:03:15.001]  $ ...future.FUN            :function (x, ...)  
[16:03:15.001]  $ x_FUN                    :function (x)  
[16:03:15.001]  $ times                    : int 1
[16:03:15.001]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:15.001]  $ stop_if_not              :function (...)  
[16:03:15.001]  $ dim                      : NULL
[16:03:15.001]  $ valid_types              : chr "logical"
[16:03:15.001]  $ future.call.arguments    : list()
[16:03:15.001]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:15.001]  $ ...future.elements_ii    :List of 6
[16:03:15.001]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[16:03:15.001]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[16:03:15.001]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[16:03:15.001]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[16:03:15.001]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[16:03:15.001]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[16:03:15.001]  $ ...future.seeds_ii       : NULL
[16:03:15.001]  $ ...future.globals.maxSize: NULL
[16:03:15.001]  - attr(*, "where")=List of 11
[16:03:15.001]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:15.001]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:15.001]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:15.001]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:15.001]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:15.001]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:15.001]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:15.001]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:15.001]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:15.001]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:15.001]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:15.001]  - attr(*, "resolved")= logi FALSE
[16:03:15.001]  - attr(*, "total_size")= num 94200
[16:03:15.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:15.001]  - attr(*, "already-done")= logi TRUE
[16:03:15.012] - copied ‘...future.FUN’ to environment
[16:03:15.012] - copied ‘x_FUN’ to environment
[16:03:15.012] - copied ‘times’ to environment
[16:03:15.012] - copied ‘stopf’ to environment
[16:03:15.012] - copied ‘stop_if_not’ to environment
[16:03:15.012] - copied ‘dim’ to environment
[16:03:15.012] - copied ‘valid_types’ to environment
[16:03:15.012] - copied ‘future.call.arguments’ to environment
[16:03:15.013] - copied ‘...future.elements_ii’ to environment
[16:03:15.013] - copied ‘...future.seeds_ii’ to environment
[16:03:15.013] - copied ‘...future.globals.maxSize’ to environment
[16:03:15.013] assign_globals() ... done
[16:03:15.013] requestCore(): workers = 2
[16:03:15.015] MulticoreFuture started
[16:03:15.016] - Launch lazy future ... done
[16:03:15.016] run() for ‘MulticoreFuture’ ... done
[16:03:15.017] Created future:
[16:03:15.017] plan(): Setting new future strategy stack:
[16:03:15.017] List of future strategies:
[16:03:15.017] 1. sequential:
[16:03:15.017]    - args: function (..., envir = parent.frame())
[16:03:15.017]    - tweaked: FALSE
[16:03:15.017]    - call: NULL
[16:03:15.019] plan(): nbrOfWorkers() = 1
[16:03:15.022] plan(): Setting new future strategy stack:
[16:03:15.022] List of future strategies:
[16:03:15.022] 1. multicore:
[16:03:15.022]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:15.022]    - tweaked: FALSE
[16:03:15.022]    - call: plan(strategy)
[16:03:15.027] plan(): nbrOfWorkers() = 2
[16:03:15.017] MulticoreFuture:
[16:03:15.017] Label: ‘future_vapply-1’
[16:03:15.017] Expression:
[16:03:15.017] {
[16:03:15.017]     do.call(function(...) {
[16:03:15.017]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.017]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:15.017]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.017]             on.exit(options(oopts), add = TRUE)
[16:03:15.017]         }
[16:03:15.017]         {
[16:03:15.017]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:15.017]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.017]                 ...future.FUN(...future.X_jj, ...)
[16:03:15.017]             })
[16:03:15.017]         }
[16:03:15.017]     }, args = future.call.arguments)
[16:03:15.017] }
[16:03:15.017] Lazy evaluation: FALSE
[16:03:15.017] Asynchronous evaluation: TRUE
[16:03:15.017] Local evaluation: TRUE
[16:03:15.017] Environment: R_GlobalEnv
[16:03:15.017] Capture standard output: TRUE
[16:03:15.017] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:15.017] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:15.017] Packages: 1 packages (‘future.apply’)
[16:03:15.017] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:15.017] Resolved: TRUE
[16:03:15.017] Value: <not collected>
[16:03:15.017] Conditions captured: <none>
[16:03:15.017] Early signaling: FALSE
[16:03:15.017] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:15.017] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:15.028] Chunk #1 of 2 ... DONE
[16:03:15.029] Chunk #2 of 2 ...
[16:03:15.029]  - Finding globals in 'X' for chunk #2 ...
[16:03:15.029] getGlobalsAndPackages() ...
[16:03:15.029] Searching for globals...
[16:03:15.030] 
[16:03:15.030] Searching for globals ... DONE
[16:03:15.030] - globals: [0] <none>
[16:03:15.030] getGlobalsAndPackages() ... DONE
[16:03:15.030]    + additional globals found: [n=0] 
[16:03:15.030]    + additional namespaces needed: [n=0] 
[16:03:15.030]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:15.031]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:15.031]  - seeds: <none>
[16:03:15.031]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.031] getGlobalsAndPackages() ...
[16:03:15.032] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.032] Resolving globals: FALSE
[16:03:15.032] Tweak future expression to call with '...' arguments ...
[16:03:15.032] {
[16:03:15.032]     do.call(function(...) {
[16:03:15.032]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.032]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:15.032]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.032]             on.exit(options(oopts), add = TRUE)
[16:03:15.032]         }
[16:03:15.032]         {
[16:03:15.032]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:15.032]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.032]                 ...future.FUN(...future.X_jj, ...)
[16:03:15.032]             })
[16:03:15.032]         }
[16:03:15.032]     }, args = future.call.arguments)
[16:03:15.032] }
[16:03:15.033] Tweak future expression to call with '...' arguments ... DONE
[16:03:15.034] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.034] - packages: [1] ‘future.apply’
[16:03:15.034] getGlobalsAndPackages() ... DONE
[16:03:15.035] run() for ‘Future’ ...
[16:03:15.035] - state: ‘created’
[16:03:15.035] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:15.039] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:15.040] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:15.040]   - Field: ‘label’
[16:03:15.040]   - Field: ‘local’
[16:03:15.040]   - Field: ‘owner’
[16:03:15.040]   - Field: ‘envir’
[16:03:15.040]   - Field: ‘workers’
[16:03:15.041]   - Field: ‘packages’
[16:03:15.041]   - Field: ‘gc’
[16:03:15.041]   - Field: ‘job’
[16:03:15.041]   - Field: ‘conditions’
[16:03:15.041]   - Field: ‘expr’
[16:03:15.041]   - Field: ‘uuid’
[16:03:15.041]   - Field: ‘seed’
[16:03:15.041]   - Field: ‘version’
[16:03:15.042]   - Field: ‘result’
[16:03:15.042]   - Field: ‘asynchronous’
[16:03:15.042]   - Field: ‘calls’
[16:03:15.042]   - Field: ‘globals’
[16:03:15.042]   - Field: ‘stdout’
[16:03:15.042]   - Field: ‘earlySignal’
[16:03:15.042]   - Field: ‘lazy’
[16:03:15.043]   - Field: ‘state’
[16:03:15.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:15.043] - Launch lazy future ...
[16:03:15.043] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:15.043] Packages needed by future strategies (n = 0): <none>
[16:03:15.044] {
[16:03:15.044]     {
[16:03:15.044]         {
[16:03:15.044]             ...future.startTime <- base::Sys.time()
[16:03:15.044]             {
[16:03:15.044]                 {
[16:03:15.044]                   {
[16:03:15.044]                     {
[16:03:15.044]                       {
[16:03:15.044]                         base::local({
[16:03:15.044]                           has_future <- base::requireNamespace("future", 
[16:03:15.044]                             quietly = TRUE)
[16:03:15.044]                           if (has_future) {
[16:03:15.044]                             ns <- base::getNamespace("future")
[16:03:15.044]                             version <- ns[[".package"]][["version"]]
[16:03:15.044]                             if (is.null(version)) 
[16:03:15.044]                               version <- utils::packageVersion("future")
[16:03:15.044]                           }
[16:03:15.044]                           else {
[16:03:15.044]                             version <- NULL
[16:03:15.044]                           }
[16:03:15.044]                           if (!has_future || version < "1.8.0") {
[16:03:15.044]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:15.044]                               "", base::R.version$version.string), 
[16:03:15.044]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:15.044]                                 base::R.version$platform, 8 * 
[16:03:15.044]                                   base::.Machine$sizeof.pointer), 
[16:03:15.044]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:15.044]                                 "release", "version")], collapse = " "), 
[16:03:15.044]                               hostname = base::Sys.info()[["nodename"]])
[16:03:15.044]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:15.044]                               info)
[16:03:15.044]                             info <- base::paste(info, collapse = "; ")
[16:03:15.044]                             if (!has_future) {
[16:03:15.044]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:15.044]                                 info)
[16:03:15.044]                             }
[16:03:15.044]                             else {
[16:03:15.044]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:15.044]                                 info, version)
[16:03:15.044]                             }
[16:03:15.044]                             base::stop(msg)
[16:03:15.044]                           }
[16:03:15.044]                         })
[16:03:15.044]                       }
[16:03:15.044]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:15.044]                       base::options(mc.cores = 1L)
[16:03:15.044]                     }
[16:03:15.044]                     base::local({
[16:03:15.044]                       for (pkg in "future.apply") {
[16:03:15.044]                         base::loadNamespace(pkg)
[16:03:15.044]                         base::library(pkg, character.only = TRUE)
[16:03:15.044]                       }
[16:03:15.044]                     })
[16:03:15.044]                   }
[16:03:15.044]                   options(future.plan = NULL)
[16:03:15.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:15.044]                 }
[16:03:15.044]                 ...future.workdir <- getwd()
[16:03:15.044]             }
[16:03:15.044]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:15.044]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:15.044]         }
[16:03:15.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:15.044]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:15.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:15.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:15.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:15.044]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:15.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:15.044]             base::names(...future.oldOptions))
[16:03:15.044]     }
[16:03:15.044]     if (FALSE) {
[16:03:15.044]     }
[16:03:15.044]     else {
[16:03:15.044]         if (TRUE) {
[16:03:15.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:15.044]                 open = "w")
[16:03:15.044]         }
[16:03:15.044]         else {
[16:03:15.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:15.044]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:15.044]         }
[16:03:15.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:15.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:15.044]             base::sink(type = "output", split = FALSE)
[16:03:15.044]             base::close(...future.stdout)
[16:03:15.044]         }, add = TRUE)
[16:03:15.044]     }
[16:03:15.044]     ...future.frame <- base::sys.nframe()
[16:03:15.044]     ...future.conditions <- base::list()
[16:03:15.044]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:15.044]     if (FALSE) {
[16:03:15.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:15.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:15.044]     }
[16:03:15.044]     ...future.result <- base::tryCatch({
[16:03:15.044]         base::withCallingHandlers({
[16:03:15.044]             ...future.value <- base::withVisible(base::local({
[16:03:15.044]                 withCallingHandlers({
[16:03:15.044]                   {
[16:03:15.044]                     do.call(function(...) {
[16:03:15.044]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.044]                       if (!identical(...future.globals.maxSize.org, 
[16:03:15.044]                         ...future.globals.maxSize)) {
[16:03:15.044]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.044]                         on.exit(options(oopts), add = TRUE)
[16:03:15.044]                       }
[16:03:15.044]                       {
[16:03:15.044]                         lapply(seq_along(...future.elements_ii), 
[16:03:15.044]                           FUN = function(jj) {
[16:03:15.044]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.044]                             ...future.FUN(...future.X_jj, ...)
[16:03:15.044]                           })
[16:03:15.044]                       }
[16:03:15.044]                     }, args = future.call.arguments)
[16:03:15.044]                   }
[16:03:15.044]                 }, immediateCondition = function(cond) {
[16:03:15.044]                   save_rds <- function (object, pathname, ...) 
[16:03:15.044]                   {
[16:03:15.044]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:15.044]                     if (file_test("-f", pathname_tmp)) {
[16:03:15.044]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.044]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:15.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.044]                         fi_tmp[["mtime"]])
[16:03:15.044]                     }
[16:03:15.044]                     tryCatch({
[16:03:15.044]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:15.044]                     }, error = function(ex) {
[16:03:15.044]                       msg <- conditionMessage(ex)
[16:03:15.044]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.044]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:15.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.044]                         fi_tmp[["mtime"]], msg)
[16:03:15.044]                       ex$message <- msg
[16:03:15.044]                       stop(ex)
[16:03:15.044]                     })
[16:03:15.044]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:15.044]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:15.044]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:15.044]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.044]                       fi <- file.info(pathname)
[16:03:15.044]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:15.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.044]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:15.044]                         fi[["size"]], fi[["mtime"]])
[16:03:15.044]                       stop(msg)
[16:03:15.044]                     }
[16:03:15.044]                     invisible(pathname)
[16:03:15.044]                   }
[16:03:15.044]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:15.044]                     rootPath = tempdir()) 
[16:03:15.044]                   {
[16:03:15.044]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:15.044]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:15.044]                       tmpdir = path, fileext = ".rds")
[16:03:15.044]                     save_rds(obj, file)
[16:03:15.044]                   }
[16:03:15.044]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:15.044]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.044]                   {
[16:03:15.044]                     inherits <- base::inherits
[16:03:15.044]                     invokeRestart <- base::invokeRestart
[16:03:15.044]                     is.null <- base::is.null
[16:03:15.044]                     muffled <- FALSE
[16:03:15.044]                     if (inherits(cond, "message")) {
[16:03:15.044]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:15.044]                       if (muffled) 
[16:03:15.044]                         invokeRestart("muffleMessage")
[16:03:15.044]                     }
[16:03:15.044]                     else if (inherits(cond, "warning")) {
[16:03:15.044]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:15.044]                       if (muffled) 
[16:03:15.044]                         invokeRestart("muffleWarning")
[16:03:15.044]                     }
[16:03:15.044]                     else if (inherits(cond, "condition")) {
[16:03:15.044]                       if (!is.null(pattern)) {
[16:03:15.044]                         computeRestarts <- base::computeRestarts
[16:03:15.044]                         grepl <- base::grepl
[16:03:15.044]                         restarts <- computeRestarts(cond)
[16:03:15.044]                         for (restart in restarts) {
[16:03:15.044]                           name <- restart$name
[16:03:15.044]                           if (is.null(name)) 
[16:03:15.044]                             next
[16:03:15.044]                           if (!grepl(pattern, name)) 
[16:03:15.044]                             next
[16:03:15.044]                           invokeRestart(restart)
[16:03:15.044]                           muffled <- TRUE
[16:03:15.044]                           break
[16:03:15.044]                         }
[16:03:15.044]                       }
[16:03:15.044]                     }
[16:03:15.044]                     invisible(muffled)
[16:03:15.044]                   }
[16:03:15.044]                   muffleCondition(cond)
[16:03:15.044]                 })
[16:03:15.044]             }))
[16:03:15.044]             future::FutureResult(value = ...future.value$value, 
[16:03:15.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.044]                   ...future.rng), globalenv = if (FALSE) 
[16:03:15.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:15.044]                     ...future.globalenv.names))
[16:03:15.044]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:15.044]         }, condition = base::local({
[16:03:15.044]             c <- base::c
[16:03:15.044]             inherits <- base::inherits
[16:03:15.044]             invokeRestart <- base::invokeRestart
[16:03:15.044]             length <- base::length
[16:03:15.044]             list <- base::list
[16:03:15.044]             seq.int <- base::seq.int
[16:03:15.044]             signalCondition <- base::signalCondition
[16:03:15.044]             sys.calls <- base::sys.calls
[16:03:15.044]             `[[` <- base::`[[`
[16:03:15.044]             `+` <- base::`+`
[16:03:15.044]             `<<-` <- base::`<<-`
[16:03:15.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:15.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:15.044]                   3L)]
[16:03:15.044]             }
[16:03:15.044]             function(cond) {
[16:03:15.044]                 is_error <- inherits(cond, "error")
[16:03:15.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:15.044]                   NULL)
[16:03:15.044]                 if (is_error) {
[16:03:15.044]                   sessionInformation <- function() {
[16:03:15.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:15.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:15.044]                       search = base::search(), system = base::Sys.info())
[16:03:15.044]                   }
[16:03:15.044]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:15.044]                     cond$call), session = sessionInformation(), 
[16:03:15.044]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:15.044]                   signalCondition(cond)
[16:03:15.044]                 }
[16:03:15.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:15.044]                 "immediateCondition"))) {
[16:03:15.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:15.044]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:15.044]                   if (TRUE && !signal) {
[16:03:15.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.044]                     {
[16:03:15.044]                       inherits <- base::inherits
[16:03:15.044]                       invokeRestart <- base::invokeRestart
[16:03:15.044]                       is.null <- base::is.null
[16:03:15.044]                       muffled <- FALSE
[16:03:15.044]                       if (inherits(cond, "message")) {
[16:03:15.044]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.044]                         if (muffled) 
[16:03:15.044]                           invokeRestart("muffleMessage")
[16:03:15.044]                       }
[16:03:15.044]                       else if (inherits(cond, "warning")) {
[16:03:15.044]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.044]                         if (muffled) 
[16:03:15.044]                           invokeRestart("muffleWarning")
[16:03:15.044]                       }
[16:03:15.044]                       else if (inherits(cond, "condition")) {
[16:03:15.044]                         if (!is.null(pattern)) {
[16:03:15.044]                           computeRestarts <- base::computeRestarts
[16:03:15.044]                           grepl <- base::grepl
[16:03:15.044]                           restarts <- computeRestarts(cond)
[16:03:15.044]                           for (restart in restarts) {
[16:03:15.044]                             name <- restart$name
[16:03:15.044]                             if (is.null(name)) 
[16:03:15.044]                               next
[16:03:15.044]                             if (!grepl(pattern, name)) 
[16:03:15.044]                               next
[16:03:15.044]                             invokeRestart(restart)
[16:03:15.044]                             muffled <- TRUE
[16:03:15.044]                             break
[16:03:15.044]                           }
[16:03:15.044]                         }
[16:03:15.044]                       }
[16:03:15.044]                       invisible(muffled)
[16:03:15.044]                     }
[16:03:15.044]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.044]                   }
[16:03:15.044]                 }
[16:03:15.044]                 else {
[16:03:15.044]                   if (TRUE) {
[16:03:15.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.044]                     {
[16:03:15.044]                       inherits <- base::inherits
[16:03:15.044]                       invokeRestart <- base::invokeRestart
[16:03:15.044]                       is.null <- base::is.null
[16:03:15.044]                       muffled <- FALSE
[16:03:15.044]                       if (inherits(cond, "message")) {
[16:03:15.044]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.044]                         if (muffled) 
[16:03:15.044]                           invokeRestart("muffleMessage")
[16:03:15.044]                       }
[16:03:15.044]                       else if (inherits(cond, "warning")) {
[16:03:15.044]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.044]                         if (muffled) 
[16:03:15.044]                           invokeRestart("muffleWarning")
[16:03:15.044]                       }
[16:03:15.044]                       else if (inherits(cond, "condition")) {
[16:03:15.044]                         if (!is.null(pattern)) {
[16:03:15.044]                           computeRestarts <- base::computeRestarts
[16:03:15.044]                           grepl <- base::grepl
[16:03:15.044]                           restarts <- computeRestarts(cond)
[16:03:15.044]                           for (restart in restarts) {
[16:03:15.044]                             name <- restart$name
[16:03:15.044]                             if (is.null(name)) 
[16:03:15.044]                               next
[16:03:15.044]                             if (!grepl(pattern, name)) 
[16:03:15.044]                               next
[16:03:15.044]                             invokeRestart(restart)
[16:03:15.044]                             muffled <- TRUE
[16:03:15.044]                             break
[16:03:15.044]                           }
[16:03:15.044]                         }
[16:03:15.044]                       }
[16:03:15.044]                       invisible(muffled)
[16:03:15.044]                     }
[16:03:15.044]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.044]                   }
[16:03:15.044]                 }
[16:03:15.044]             }
[16:03:15.044]         }))
[16:03:15.044]     }, error = function(ex) {
[16:03:15.044]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:15.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.044]                 ...future.rng), started = ...future.startTime, 
[16:03:15.044]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:15.044]             version = "1.8"), class = "FutureResult")
[16:03:15.044]     }, finally = {
[16:03:15.044]         if (!identical(...future.workdir, getwd())) 
[16:03:15.044]             setwd(...future.workdir)
[16:03:15.044]         {
[16:03:15.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:15.044]                 ...future.oldOptions$nwarnings <- NULL
[16:03:15.044]             }
[16:03:15.044]             base::options(...future.oldOptions)
[16:03:15.044]             if (.Platform$OS.type == "windows") {
[16:03:15.044]                 old_names <- names(...future.oldEnvVars)
[16:03:15.044]                 envs <- base::Sys.getenv()
[16:03:15.044]                 names <- names(envs)
[16:03:15.044]                 common <- intersect(names, old_names)
[16:03:15.044]                 added <- setdiff(names, old_names)
[16:03:15.044]                 removed <- setdiff(old_names, names)
[16:03:15.044]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:15.044]                   envs[common]]
[16:03:15.044]                 NAMES <- toupper(changed)
[16:03:15.044]                 args <- list()
[16:03:15.044]                 for (kk in seq_along(NAMES)) {
[16:03:15.044]                   name <- changed[[kk]]
[16:03:15.044]                   NAME <- NAMES[[kk]]
[16:03:15.044]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.044]                     next
[16:03:15.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.044]                 }
[16:03:15.044]                 NAMES <- toupper(added)
[16:03:15.044]                 for (kk in seq_along(NAMES)) {
[16:03:15.044]                   name <- added[[kk]]
[16:03:15.044]                   NAME <- NAMES[[kk]]
[16:03:15.044]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.044]                     next
[16:03:15.044]                   args[[name]] <- ""
[16:03:15.044]                 }
[16:03:15.044]                 NAMES <- toupper(removed)
[16:03:15.044]                 for (kk in seq_along(NAMES)) {
[16:03:15.044]                   name <- removed[[kk]]
[16:03:15.044]                   NAME <- NAMES[[kk]]
[16:03:15.044]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.044]                     next
[16:03:15.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.044]                 }
[16:03:15.044]                 if (length(args) > 0) 
[16:03:15.044]                   base::do.call(base::Sys.setenv, args = args)
[16:03:15.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:15.044]             }
[16:03:15.044]             else {
[16:03:15.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:15.044]             }
[16:03:15.044]             {
[16:03:15.044]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:15.044]                   0L) {
[16:03:15.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:15.044]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:15.044]                   base::options(opts)
[16:03:15.044]                 }
[16:03:15.044]                 {
[16:03:15.044]                   {
[16:03:15.044]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:15.044]                     NULL
[16:03:15.044]                   }
[16:03:15.044]                   options(future.plan = NULL)
[16:03:15.044]                   if (is.na(NA_character_)) 
[16:03:15.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:15.044]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:15.044]                     envir = parent.frame()) 
[16:03:15.044]                   {
[16:03:15.044]                     default_workers <- missing(workers)
[16:03:15.044]                     if (is.function(workers)) 
[16:03:15.044]                       workers <- workers()
[16:03:15.044]                     workers <- structure(as.integer(workers), 
[16:03:15.044]                       class = class(workers))
[16:03:15.044]                     stop_if_not(is.finite(workers), workers >= 
[16:03:15.044]                       1L)
[16:03:15.044]                     if ((workers == 1L && !inherits(workers, 
[16:03:15.044]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:15.044]                       if (default_workers) 
[16:03:15.044]                         supportsMulticore(warn = TRUE)
[16:03:15.044]                       return(sequential(..., envir = envir))
[16:03:15.044]                     }
[16:03:15.044]                     oopts <- options(mc.cores = workers)
[16:03:15.044]                     on.exit(options(oopts))
[16:03:15.044]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:15.044]                       envir = envir)
[16:03:15.044]                     if (!future$lazy) 
[16:03:15.044]                       future <- run(future)
[16:03:15.044]                     invisible(future)
[16:03:15.044]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:15.044]                 }
[16:03:15.044]             }
[16:03:15.044]         }
[16:03:15.044]     })
[16:03:15.044]     if (TRUE) {
[16:03:15.044]         base::sink(type = "output", split = FALSE)
[16:03:15.044]         if (TRUE) {
[16:03:15.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:15.044]         }
[16:03:15.044]         else {
[16:03:15.044]             ...future.result["stdout"] <- base::list(NULL)
[16:03:15.044]         }
[16:03:15.044]         base::close(...future.stdout)
[16:03:15.044]         ...future.stdout <- NULL
[16:03:15.044]     }
[16:03:15.044]     ...future.result$conditions <- ...future.conditions
[16:03:15.044]     ...future.result$finished <- base::Sys.time()
[16:03:15.044]     ...future.result
[16:03:15.044] }
[16:03:15.048] assign_globals() ...
[16:03:15.048] List of 11
[16:03:15.048]  $ ...future.FUN            :function (x, ...)  
[16:03:15.048]  $ x_FUN                    :function (x)  
[16:03:15.048]  $ times                    : int 1
[16:03:15.048]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:15.048]  $ stop_if_not              :function (...)  
[16:03:15.048]  $ dim                      : NULL
[16:03:15.048]  $ valid_types              : chr "logical"
[16:03:15.048]  $ future.call.arguments    : list()
[16:03:15.048]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:15.048]  $ ...future.elements_ii    :List of 5
[16:03:15.048]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[16:03:15.048]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[16:03:15.048]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[16:03:15.048]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[16:03:15.048]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[16:03:15.048]  $ ...future.seeds_ii       : NULL
[16:03:15.048]  $ ...future.globals.maxSize: NULL
[16:03:15.048]  - attr(*, "where")=List of 11
[16:03:15.048]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:15.048]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:15.048]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:15.048]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:15.048]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:15.048]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:15.048]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:15.048]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:15.048]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:15.048]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:15.048]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:15.048]  - attr(*, "resolved")= logi FALSE
[16:03:15.048]  - attr(*, "total_size")= num 94200
[16:03:15.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:15.048]  - attr(*, "already-done")= logi TRUE
[16:03:15.064] - copied ‘...future.FUN’ to environment
[16:03:15.064] - copied ‘x_FUN’ to environment
[16:03:15.064] - copied ‘times’ to environment
[16:03:15.064] - copied ‘stopf’ to environment
[16:03:15.064] - copied ‘stop_if_not’ to environment
[16:03:15.065] - copied ‘dim’ to environment
[16:03:15.065] - copied ‘valid_types’ to environment
[16:03:15.065] - copied ‘future.call.arguments’ to environment
[16:03:15.065] - copied ‘...future.elements_ii’ to environment
[16:03:15.065] - copied ‘...future.seeds_ii’ to environment
[16:03:15.065] - copied ‘...future.globals.maxSize’ to environment
[16:03:15.065] assign_globals() ... done
[16:03:15.065] requestCore(): workers = 2
[16:03:15.068] MulticoreFuture started
[16:03:15.069] - Launch lazy future ... done
[16:03:15.069] run() for ‘MulticoreFuture’ ... done
[16:03:15.069] Created future:
[16:03:15.070] plan(): Setting new future strategy stack:
[16:03:15.070] List of future strategies:
[16:03:15.070] 1. sequential:
[16:03:15.070]    - args: function (..., envir = parent.frame())
[16:03:15.070]    - tweaked: FALSE
[16:03:15.070]    - call: NULL
[16:03:15.071] plan(): nbrOfWorkers() = 1
[16:03:15.073] plan(): Setting new future strategy stack:
[16:03:15.073] List of future strategies:
[16:03:15.073] 1. multicore:
[16:03:15.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:15.073]    - tweaked: FALSE
[16:03:15.073]    - call: plan(strategy)
[16:03:15.079] plan(): nbrOfWorkers() = 2
[16:03:15.070] MulticoreFuture:
[16:03:15.070] Label: ‘future_vapply-2’
[16:03:15.070] Expression:
[16:03:15.070] {
[16:03:15.070]     do.call(function(...) {
[16:03:15.070]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.070]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:15.070]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.070]             on.exit(options(oopts), add = TRUE)
[16:03:15.070]         }
[16:03:15.070]         {
[16:03:15.070]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:15.070]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.070]                 ...future.FUN(...future.X_jj, ...)
[16:03:15.070]             })
[16:03:15.070]         }
[16:03:15.070]     }, args = future.call.arguments)
[16:03:15.070] }
[16:03:15.070] Lazy evaluation: FALSE
[16:03:15.070] Asynchronous evaluation: TRUE
[16:03:15.070] Local evaluation: TRUE
[16:03:15.070] Environment: R_GlobalEnv
[16:03:15.070] Capture standard output: TRUE
[16:03:15.070] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:15.070] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:15.070] Packages: 1 packages (‘future.apply’)
[16:03:15.070] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:15.070] Resolved: TRUE
[16:03:15.070] Value: <not collected>
[16:03:15.070] Conditions captured: <none>
[16:03:15.070] Early signaling: FALSE
[16:03:15.070] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:15.070] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:15.080] Chunk #2 of 2 ... DONE
[16:03:15.080] Launching 2 futures (chunks) ... DONE
[16:03:15.080] Resolving 2 futures (chunks) ...
[16:03:15.080] resolve() on list ...
[16:03:15.081]  recursive: 0
[16:03:15.081]  length: 2
[16:03:15.081] 
[16:03:15.081] Future #1
[16:03:15.081] result() for MulticoreFuture ...
[16:03:15.082] result() for MulticoreFuture ...
[16:03:15.082] result() for MulticoreFuture ... done
[16:03:15.083] result() for MulticoreFuture ... done
[16:03:15.083] result() for MulticoreFuture ...
[16:03:15.083] result() for MulticoreFuture ... done
[16:03:15.083] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:15.083] - nx: 2
[16:03:15.084] - relay: TRUE
[16:03:15.084] - stdout: TRUE
[16:03:15.084] - signal: TRUE
[16:03:15.084] - resignal: FALSE
[16:03:15.084] - force: TRUE
[16:03:15.084] - relayed: [n=2] FALSE, FALSE
[16:03:15.084] - queued futures: [n=2] FALSE, FALSE
[16:03:15.085]  - until=1
[16:03:15.085]  - relaying element #1
[16:03:15.085] result() for MulticoreFuture ...
[16:03:15.085] result() for MulticoreFuture ... done
[16:03:15.085] result() for MulticoreFuture ...
[16:03:15.085] result() for MulticoreFuture ... done
[16:03:15.086] result() for MulticoreFuture ...
[16:03:15.086] result() for MulticoreFuture ... done
[16:03:15.086] result() for MulticoreFuture ...
[16:03:15.086] result() for MulticoreFuture ... done
[16:03:15.086] - relayed: [n=2] TRUE, FALSE
[16:03:15.086] - queued futures: [n=2] TRUE, FALSE
[16:03:15.087] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:15.087]  length: 1 (resolved future 1)
[16:03:15.087] Future #2
[16:03:15.087] result() for MulticoreFuture ...
[16:03:15.088] result() for MulticoreFuture ...
[16:03:15.088] result() for MulticoreFuture ... done
[16:03:15.088] result() for MulticoreFuture ... done
[16:03:15.089] result() for MulticoreFuture ...
[16:03:15.089] result() for MulticoreFuture ... done
[16:03:15.089] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:15.089] - nx: 2
[16:03:15.089] - relay: TRUE
[16:03:15.089] - stdout: TRUE
[16:03:15.089] - signal: TRUE
[16:03:15.089] - resignal: FALSE
[16:03:15.090] - force: TRUE
[16:03:15.090] - relayed: [n=2] TRUE, FALSE
[16:03:15.090] - queued futures: [n=2] TRUE, FALSE
[16:03:15.090]  - until=2
[16:03:15.090]  - relaying element #2
[16:03:15.090] result() for MulticoreFuture ...
[16:03:15.095] result() for MulticoreFuture ... done
[16:03:15.095] result() for MulticoreFuture ...
[16:03:15.095] result() for MulticoreFuture ... done
[16:03:15.095] result() for MulticoreFuture ...
[16:03:15.095] result() for MulticoreFuture ... done
[16:03:15.096] result() for MulticoreFuture ...
[16:03:15.096] result() for MulticoreFuture ... done
[16:03:15.096] - relayed: [n=2] TRUE, TRUE
[16:03:15.096] - queued futures: [n=2] TRUE, TRUE
[16:03:15.096] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:15.096]  length: 0 (resolved future 2)
[16:03:15.096] Relaying remaining futures
[16:03:15.096] signalConditionsASAP(NULL, pos=0) ...
[16:03:15.097] - nx: 2
[16:03:15.097] - relay: TRUE
[16:03:15.097] - stdout: TRUE
[16:03:15.097] - signal: TRUE
[16:03:15.097] - resignal: FALSE
[16:03:15.097] - force: TRUE
[16:03:15.097] - relayed: [n=2] TRUE, TRUE
[16:03:15.097] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:15.098] - relayed: [n=2] TRUE, TRUE
[16:03:15.098] - queued futures: [n=2] TRUE, TRUE
[16:03:15.098] signalConditionsASAP(NULL, pos=0) ... done
[16:03:15.098] resolve() on list ... DONE
[16:03:15.098] result() for MulticoreFuture ...
[16:03:15.098] result() for MulticoreFuture ... done
[16:03:15.098] result() for MulticoreFuture ...
[16:03:15.098] result() for MulticoreFuture ... done
[16:03:15.099] result() for MulticoreFuture ...
[16:03:15.099] result() for MulticoreFuture ... done
[16:03:15.099] result() for MulticoreFuture ...
[16:03:15.099] result() for MulticoreFuture ... done
[16:03:15.099]  - Number of value chunks collected: 2
[16:03:15.099] Resolving 2 futures (chunks) ... DONE
[16:03:15.100] Reducing values from 2 chunks ...
[16:03:15.100]  - Number of values collected after concatenation: 11
[16:03:15.100]  - Number of values expected: 11
[16:03:15.100] Reducing values from 2 chunks ... DONE
[16:03:15.100] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[16:03:15.101] future_lapply() ...
[16:03:15.108] Number of chunks: 2
[16:03:15.108] getGlobalsAndPackagesXApply() ...
[16:03:15.109]  - future.globals: TRUE
[16:03:15.109] getGlobalsAndPackages() ...
[16:03:15.109] Searching for globals...
[16:03:15.112] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:15.112] Searching for globals ... DONE
[16:03:15.112] Resolving globals: FALSE
[16:03:15.113] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[16:03:15.114] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:15.114] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:15.114] - packages: [1] ‘future.apply’
[16:03:15.114] getGlobalsAndPackages() ... DONE
[16:03:15.114]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:15.114]  - needed namespaces: [n=1] ‘future.apply’
[16:03:15.114] Finding globals ... DONE
[16:03:15.115]  - use_args: TRUE
[16:03:15.115]  - Getting '...' globals ...
[16:03:15.115] resolve() on list ...
[16:03:15.115]  recursive: 0
[16:03:15.115]  length: 1
[16:03:15.115]  elements: ‘...’
[16:03:15.115]  length: 0 (resolved future 1)
[16:03:15.116] resolve() on list ... DONE
[16:03:15.116]    - '...' content: [n=0] 
[16:03:15.116] List of 1
[16:03:15.116]  $ ...: list()
[16:03:15.116]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:15.116]  - attr(*, "where")=List of 1
[16:03:15.116]   ..$ ...:<environment: 0x564e42fdf5d8> 
[16:03:15.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:15.116]  - attr(*, "resolved")= logi TRUE
[16:03:15.116]  - attr(*, "total_size")= num NA
[16:03:15.118]  - Getting '...' globals ... DONE
[16:03:15.118] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:15.121] List of 8
[16:03:15.121]  $ ...future.FUN:function (x, ...)  
[16:03:15.121]  $ x_FUN        :function (x)  
[16:03:15.121]  $ times        : int 1
[16:03:15.121]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:15.121]  $ stop_if_not  :function (...)  
[16:03:15.121]  $ dim          : NULL
[16:03:15.121]  $ valid_types  : chr [1:2] "logical" "integer"
[16:03:15.121]  $ ...          : list()
[16:03:15.121]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:15.121]  - attr(*, "where")=List of 8
[16:03:15.121]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:15.121]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:15.121]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:15.121]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:15.121]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:15.121]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:15.121]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:15.121]   ..$ ...          :<environment: 0x564e42fdf5d8> 
[16:03:15.121]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:15.121]  - attr(*, "resolved")= logi FALSE
[16:03:15.121]  - attr(*, "total_size")= num 94264
[16:03:15.127] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:15.127] getGlobalsAndPackagesXApply() ... DONE
[16:03:15.127] Number of futures (= number of chunks): 2
[16:03:15.127] Launching 2 futures (chunks) ...
[16:03:15.127] Chunk #1 of 2 ...
[16:03:15.128]  - Finding globals in 'X' for chunk #1 ...
[16:03:15.128] getGlobalsAndPackages() ...
[16:03:15.128] Searching for globals...
[16:03:15.128] 
[16:03:15.128] Searching for globals ... DONE
[16:03:15.128] - globals: [0] <none>
[16:03:15.128] getGlobalsAndPackages() ... DONE
[16:03:15.128]    + additional globals found: [n=0] 
[16:03:15.129]    + additional namespaces needed: [n=0] 
[16:03:15.129]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:15.129]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:15.129]  - seeds: <none>
[16:03:15.129]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.129] getGlobalsAndPackages() ...
[16:03:15.129] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.129] Resolving globals: FALSE
[16:03:15.129] Tweak future expression to call with '...' arguments ...
[16:03:15.129] {
[16:03:15.129]     do.call(function(...) {
[16:03:15.129]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.129]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:15.129]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.129]             on.exit(options(oopts), add = TRUE)
[16:03:15.129]         }
[16:03:15.129]         {
[16:03:15.129]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:15.129]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.129]                 ...future.FUN(...future.X_jj, ...)
[16:03:15.129]             })
[16:03:15.129]         }
[16:03:15.129]     }, args = future.call.arguments)
[16:03:15.129] }
[16:03:15.130] Tweak future expression to call with '...' arguments ... DONE
[16:03:15.130] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.130] - packages: [1] ‘future.apply’
[16:03:15.130] getGlobalsAndPackages() ... DONE
[16:03:15.131] run() for ‘Future’ ...
[16:03:15.131] - state: ‘created’
[16:03:15.131] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:15.135] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:15.135] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:15.135]   - Field: ‘label’
[16:03:15.135]   - Field: ‘local’
[16:03:15.135]   - Field: ‘owner’
[16:03:15.135]   - Field: ‘envir’
[16:03:15.135]   - Field: ‘workers’
[16:03:15.135]   - Field: ‘packages’
[16:03:15.136]   - Field: ‘gc’
[16:03:15.136]   - Field: ‘job’
[16:03:15.136]   - Field: ‘conditions’
[16:03:15.136]   - Field: ‘expr’
[16:03:15.136]   - Field: ‘uuid’
[16:03:15.136]   - Field: ‘seed’
[16:03:15.136]   - Field: ‘version’
[16:03:15.136]   - Field: ‘result’
[16:03:15.136]   - Field: ‘asynchronous’
[16:03:15.136]   - Field: ‘calls’
[16:03:15.136]   - Field: ‘globals’
[16:03:15.137]   - Field: ‘stdout’
[16:03:15.137]   - Field: ‘earlySignal’
[16:03:15.137]   - Field: ‘lazy’
[16:03:15.137]   - Field: ‘state’
[16:03:15.137] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:15.137] - Launch lazy future ...
[16:03:15.137] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:15.137] Packages needed by future strategies (n = 0): <none>
[16:03:15.138] {
[16:03:15.138]     {
[16:03:15.138]         {
[16:03:15.138]             ...future.startTime <- base::Sys.time()
[16:03:15.138]             {
[16:03:15.138]                 {
[16:03:15.138]                   {
[16:03:15.138]                     {
[16:03:15.138]                       {
[16:03:15.138]                         base::local({
[16:03:15.138]                           has_future <- base::requireNamespace("future", 
[16:03:15.138]                             quietly = TRUE)
[16:03:15.138]                           if (has_future) {
[16:03:15.138]                             ns <- base::getNamespace("future")
[16:03:15.138]                             version <- ns[[".package"]][["version"]]
[16:03:15.138]                             if (is.null(version)) 
[16:03:15.138]                               version <- utils::packageVersion("future")
[16:03:15.138]                           }
[16:03:15.138]                           else {
[16:03:15.138]                             version <- NULL
[16:03:15.138]                           }
[16:03:15.138]                           if (!has_future || version < "1.8.0") {
[16:03:15.138]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:15.138]                               "", base::R.version$version.string), 
[16:03:15.138]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:15.138]                                 base::R.version$platform, 8 * 
[16:03:15.138]                                   base::.Machine$sizeof.pointer), 
[16:03:15.138]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:15.138]                                 "release", "version")], collapse = " "), 
[16:03:15.138]                               hostname = base::Sys.info()[["nodename"]])
[16:03:15.138]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:15.138]                               info)
[16:03:15.138]                             info <- base::paste(info, collapse = "; ")
[16:03:15.138]                             if (!has_future) {
[16:03:15.138]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:15.138]                                 info)
[16:03:15.138]                             }
[16:03:15.138]                             else {
[16:03:15.138]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:15.138]                                 info, version)
[16:03:15.138]                             }
[16:03:15.138]                             base::stop(msg)
[16:03:15.138]                           }
[16:03:15.138]                         })
[16:03:15.138]                       }
[16:03:15.138]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:15.138]                       base::options(mc.cores = 1L)
[16:03:15.138]                     }
[16:03:15.138]                     base::local({
[16:03:15.138]                       for (pkg in "future.apply") {
[16:03:15.138]                         base::loadNamespace(pkg)
[16:03:15.138]                         base::library(pkg, character.only = TRUE)
[16:03:15.138]                       }
[16:03:15.138]                     })
[16:03:15.138]                   }
[16:03:15.138]                   options(future.plan = NULL)
[16:03:15.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:15.138]                 }
[16:03:15.138]                 ...future.workdir <- getwd()
[16:03:15.138]             }
[16:03:15.138]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:15.138]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:15.138]         }
[16:03:15.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:15.138]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:15.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:15.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:15.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:15.138]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:15.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:15.138]             base::names(...future.oldOptions))
[16:03:15.138]     }
[16:03:15.138]     if (FALSE) {
[16:03:15.138]     }
[16:03:15.138]     else {
[16:03:15.138]         if (TRUE) {
[16:03:15.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:15.138]                 open = "w")
[16:03:15.138]         }
[16:03:15.138]         else {
[16:03:15.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:15.138]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:15.138]         }
[16:03:15.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:15.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:15.138]             base::sink(type = "output", split = FALSE)
[16:03:15.138]             base::close(...future.stdout)
[16:03:15.138]         }, add = TRUE)
[16:03:15.138]     }
[16:03:15.138]     ...future.frame <- base::sys.nframe()
[16:03:15.138]     ...future.conditions <- base::list()
[16:03:15.138]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:15.138]     if (FALSE) {
[16:03:15.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:15.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:15.138]     }
[16:03:15.138]     ...future.result <- base::tryCatch({
[16:03:15.138]         base::withCallingHandlers({
[16:03:15.138]             ...future.value <- base::withVisible(base::local({
[16:03:15.138]                 withCallingHandlers({
[16:03:15.138]                   {
[16:03:15.138]                     do.call(function(...) {
[16:03:15.138]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.138]                       if (!identical(...future.globals.maxSize.org, 
[16:03:15.138]                         ...future.globals.maxSize)) {
[16:03:15.138]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.138]                         on.exit(options(oopts), add = TRUE)
[16:03:15.138]                       }
[16:03:15.138]                       {
[16:03:15.138]                         lapply(seq_along(...future.elements_ii), 
[16:03:15.138]                           FUN = function(jj) {
[16:03:15.138]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.138]                             ...future.FUN(...future.X_jj, ...)
[16:03:15.138]                           })
[16:03:15.138]                       }
[16:03:15.138]                     }, args = future.call.arguments)
[16:03:15.138]                   }
[16:03:15.138]                 }, immediateCondition = function(cond) {
[16:03:15.138]                   save_rds <- function (object, pathname, ...) 
[16:03:15.138]                   {
[16:03:15.138]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:15.138]                     if (file_test("-f", pathname_tmp)) {
[16:03:15.138]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.138]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:15.138]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.138]                         fi_tmp[["mtime"]])
[16:03:15.138]                     }
[16:03:15.138]                     tryCatch({
[16:03:15.138]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:15.138]                     }, error = function(ex) {
[16:03:15.138]                       msg <- conditionMessage(ex)
[16:03:15.138]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.138]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:15.138]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.138]                         fi_tmp[["mtime"]], msg)
[16:03:15.138]                       ex$message <- msg
[16:03:15.138]                       stop(ex)
[16:03:15.138]                     })
[16:03:15.138]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:15.138]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:15.138]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:15.138]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.138]                       fi <- file.info(pathname)
[16:03:15.138]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:15.138]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.138]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:15.138]                         fi[["size"]], fi[["mtime"]])
[16:03:15.138]                       stop(msg)
[16:03:15.138]                     }
[16:03:15.138]                     invisible(pathname)
[16:03:15.138]                   }
[16:03:15.138]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:15.138]                     rootPath = tempdir()) 
[16:03:15.138]                   {
[16:03:15.138]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:15.138]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:15.138]                       tmpdir = path, fileext = ".rds")
[16:03:15.138]                     save_rds(obj, file)
[16:03:15.138]                   }
[16:03:15.138]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:15.138]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.138]                   {
[16:03:15.138]                     inherits <- base::inherits
[16:03:15.138]                     invokeRestart <- base::invokeRestart
[16:03:15.138]                     is.null <- base::is.null
[16:03:15.138]                     muffled <- FALSE
[16:03:15.138]                     if (inherits(cond, "message")) {
[16:03:15.138]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:15.138]                       if (muffled) 
[16:03:15.138]                         invokeRestart("muffleMessage")
[16:03:15.138]                     }
[16:03:15.138]                     else if (inherits(cond, "warning")) {
[16:03:15.138]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:15.138]                       if (muffled) 
[16:03:15.138]                         invokeRestart("muffleWarning")
[16:03:15.138]                     }
[16:03:15.138]                     else if (inherits(cond, "condition")) {
[16:03:15.138]                       if (!is.null(pattern)) {
[16:03:15.138]                         computeRestarts <- base::computeRestarts
[16:03:15.138]                         grepl <- base::grepl
[16:03:15.138]                         restarts <- computeRestarts(cond)
[16:03:15.138]                         for (restart in restarts) {
[16:03:15.138]                           name <- restart$name
[16:03:15.138]                           if (is.null(name)) 
[16:03:15.138]                             next
[16:03:15.138]                           if (!grepl(pattern, name)) 
[16:03:15.138]                             next
[16:03:15.138]                           invokeRestart(restart)
[16:03:15.138]                           muffled <- TRUE
[16:03:15.138]                           break
[16:03:15.138]                         }
[16:03:15.138]                       }
[16:03:15.138]                     }
[16:03:15.138]                     invisible(muffled)
[16:03:15.138]                   }
[16:03:15.138]                   muffleCondition(cond)
[16:03:15.138]                 })
[16:03:15.138]             }))
[16:03:15.138]             future::FutureResult(value = ...future.value$value, 
[16:03:15.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.138]                   ...future.rng), globalenv = if (FALSE) 
[16:03:15.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:15.138]                     ...future.globalenv.names))
[16:03:15.138]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:15.138]         }, condition = base::local({
[16:03:15.138]             c <- base::c
[16:03:15.138]             inherits <- base::inherits
[16:03:15.138]             invokeRestart <- base::invokeRestart
[16:03:15.138]             length <- base::length
[16:03:15.138]             list <- base::list
[16:03:15.138]             seq.int <- base::seq.int
[16:03:15.138]             signalCondition <- base::signalCondition
[16:03:15.138]             sys.calls <- base::sys.calls
[16:03:15.138]             `[[` <- base::`[[`
[16:03:15.138]             `+` <- base::`+`
[16:03:15.138]             `<<-` <- base::`<<-`
[16:03:15.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:15.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:15.138]                   3L)]
[16:03:15.138]             }
[16:03:15.138]             function(cond) {
[16:03:15.138]                 is_error <- inherits(cond, "error")
[16:03:15.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:15.138]                   NULL)
[16:03:15.138]                 if (is_error) {
[16:03:15.138]                   sessionInformation <- function() {
[16:03:15.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:15.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:15.138]                       search = base::search(), system = base::Sys.info())
[16:03:15.138]                   }
[16:03:15.138]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:15.138]                     cond$call), session = sessionInformation(), 
[16:03:15.138]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:15.138]                   signalCondition(cond)
[16:03:15.138]                 }
[16:03:15.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:15.138]                 "immediateCondition"))) {
[16:03:15.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:15.138]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:15.138]                   if (TRUE && !signal) {
[16:03:15.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.138]                     {
[16:03:15.138]                       inherits <- base::inherits
[16:03:15.138]                       invokeRestart <- base::invokeRestart
[16:03:15.138]                       is.null <- base::is.null
[16:03:15.138]                       muffled <- FALSE
[16:03:15.138]                       if (inherits(cond, "message")) {
[16:03:15.138]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.138]                         if (muffled) 
[16:03:15.138]                           invokeRestart("muffleMessage")
[16:03:15.138]                       }
[16:03:15.138]                       else if (inherits(cond, "warning")) {
[16:03:15.138]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.138]                         if (muffled) 
[16:03:15.138]                           invokeRestart("muffleWarning")
[16:03:15.138]                       }
[16:03:15.138]                       else if (inherits(cond, "condition")) {
[16:03:15.138]                         if (!is.null(pattern)) {
[16:03:15.138]                           computeRestarts <- base::computeRestarts
[16:03:15.138]                           grepl <- base::grepl
[16:03:15.138]                           restarts <- computeRestarts(cond)
[16:03:15.138]                           for (restart in restarts) {
[16:03:15.138]                             name <- restart$name
[16:03:15.138]                             if (is.null(name)) 
[16:03:15.138]                               next
[16:03:15.138]                             if (!grepl(pattern, name)) 
[16:03:15.138]                               next
[16:03:15.138]                             invokeRestart(restart)
[16:03:15.138]                             muffled <- TRUE
[16:03:15.138]                             break
[16:03:15.138]                           }
[16:03:15.138]                         }
[16:03:15.138]                       }
[16:03:15.138]                       invisible(muffled)
[16:03:15.138]                     }
[16:03:15.138]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.138]                   }
[16:03:15.138]                 }
[16:03:15.138]                 else {
[16:03:15.138]                   if (TRUE) {
[16:03:15.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.138]                     {
[16:03:15.138]                       inherits <- base::inherits
[16:03:15.138]                       invokeRestart <- base::invokeRestart
[16:03:15.138]                       is.null <- base::is.null
[16:03:15.138]                       muffled <- FALSE
[16:03:15.138]                       if (inherits(cond, "message")) {
[16:03:15.138]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.138]                         if (muffled) 
[16:03:15.138]                           invokeRestart("muffleMessage")
[16:03:15.138]                       }
[16:03:15.138]                       else if (inherits(cond, "warning")) {
[16:03:15.138]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.138]                         if (muffled) 
[16:03:15.138]                           invokeRestart("muffleWarning")
[16:03:15.138]                       }
[16:03:15.138]                       else if (inherits(cond, "condition")) {
[16:03:15.138]                         if (!is.null(pattern)) {
[16:03:15.138]                           computeRestarts <- base::computeRestarts
[16:03:15.138]                           grepl <- base::grepl
[16:03:15.138]                           restarts <- computeRestarts(cond)
[16:03:15.138]                           for (restart in restarts) {
[16:03:15.138]                             name <- restart$name
[16:03:15.138]                             if (is.null(name)) 
[16:03:15.138]                               next
[16:03:15.138]                             if (!grepl(pattern, name)) 
[16:03:15.138]                               next
[16:03:15.138]                             invokeRestart(restart)
[16:03:15.138]                             muffled <- TRUE
[16:03:15.138]                             break
[16:03:15.138]                           }
[16:03:15.138]                         }
[16:03:15.138]                       }
[16:03:15.138]                       invisible(muffled)
[16:03:15.138]                     }
[16:03:15.138]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.138]                   }
[16:03:15.138]                 }
[16:03:15.138]             }
[16:03:15.138]         }))
[16:03:15.138]     }, error = function(ex) {
[16:03:15.138]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:15.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.138]                 ...future.rng), started = ...future.startTime, 
[16:03:15.138]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:15.138]             version = "1.8"), class = "FutureResult")
[16:03:15.138]     }, finally = {
[16:03:15.138]         if (!identical(...future.workdir, getwd())) 
[16:03:15.138]             setwd(...future.workdir)
[16:03:15.138]         {
[16:03:15.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:15.138]                 ...future.oldOptions$nwarnings <- NULL
[16:03:15.138]             }
[16:03:15.138]             base::options(...future.oldOptions)
[16:03:15.138]             if (.Platform$OS.type == "windows") {
[16:03:15.138]                 old_names <- names(...future.oldEnvVars)
[16:03:15.138]                 envs <- base::Sys.getenv()
[16:03:15.138]                 names <- names(envs)
[16:03:15.138]                 common <- intersect(names, old_names)
[16:03:15.138]                 added <- setdiff(names, old_names)
[16:03:15.138]                 removed <- setdiff(old_names, names)
[16:03:15.138]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:15.138]                   envs[common]]
[16:03:15.138]                 NAMES <- toupper(changed)
[16:03:15.138]                 args <- list()
[16:03:15.138]                 for (kk in seq_along(NAMES)) {
[16:03:15.138]                   name <- changed[[kk]]
[16:03:15.138]                   NAME <- NAMES[[kk]]
[16:03:15.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.138]                     next
[16:03:15.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.138]                 }
[16:03:15.138]                 NAMES <- toupper(added)
[16:03:15.138]                 for (kk in seq_along(NAMES)) {
[16:03:15.138]                   name <- added[[kk]]
[16:03:15.138]                   NAME <- NAMES[[kk]]
[16:03:15.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.138]                     next
[16:03:15.138]                   args[[name]] <- ""
[16:03:15.138]                 }
[16:03:15.138]                 NAMES <- toupper(removed)
[16:03:15.138]                 for (kk in seq_along(NAMES)) {
[16:03:15.138]                   name <- removed[[kk]]
[16:03:15.138]                   NAME <- NAMES[[kk]]
[16:03:15.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.138]                     next
[16:03:15.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.138]                 }
[16:03:15.138]                 if (length(args) > 0) 
[16:03:15.138]                   base::do.call(base::Sys.setenv, args = args)
[16:03:15.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:15.138]             }
[16:03:15.138]             else {
[16:03:15.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:15.138]             }
[16:03:15.138]             {
[16:03:15.138]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:15.138]                   0L) {
[16:03:15.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:15.138]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:15.138]                   base::options(opts)
[16:03:15.138]                 }
[16:03:15.138]                 {
[16:03:15.138]                   {
[16:03:15.138]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:15.138]                     NULL
[16:03:15.138]                   }
[16:03:15.138]                   options(future.plan = NULL)
[16:03:15.138]                   if (is.na(NA_character_)) 
[16:03:15.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:15.138]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:15.138]                     envir = parent.frame()) 
[16:03:15.138]                   {
[16:03:15.138]                     default_workers <- missing(workers)
[16:03:15.138]                     if (is.function(workers)) 
[16:03:15.138]                       workers <- workers()
[16:03:15.138]                     workers <- structure(as.integer(workers), 
[16:03:15.138]                       class = class(workers))
[16:03:15.138]                     stop_if_not(is.finite(workers), workers >= 
[16:03:15.138]                       1L)
[16:03:15.138]                     if ((workers == 1L && !inherits(workers, 
[16:03:15.138]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:15.138]                       if (default_workers) 
[16:03:15.138]                         supportsMulticore(warn = TRUE)
[16:03:15.138]                       return(sequential(..., envir = envir))
[16:03:15.138]                     }
[16:03:15.138]                     oopts <- options(mc.cores = workers)
[16:03:15.138]                     on.exit(options(oopts))
[16:03:15.138]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:15.138]                       envir = envir)
[16:03:15.138]                     if (!future$lazy) 
[16:03:15.138]                       future <- run(future)
[16:03:15.138]                     invisible(future)
[16:03:15.138]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:15.138]                 }
[16:03:15.138]             }
[16:03:15.138]         }
[16:03:15.138]     })
[16:03:15.138]     if (TRUE) {
[16:03:15.138]         base::sink(type = "output", split = FALSE)
[16:03:15.138]         if (TRUE) {
[16:03:15.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:15.138]         }
[16:03:15.138]         else {
[16:03:15.138]             ...future.result["stdout"] <- base::list(NULL)
[16:03:15.138]         }
[16:03:15.138]         base::close(...future.stdout)
[16:03:15.138]         ...future.stdout <- NULL
[16:03:15.138]     }
[16:03:15.138]     ...future.result$conditions <- ...future.conditions
[16:03:15.138]     ...future.result$finished <- base::Sys.time()
[16:03:15.138]     ...future.result
[16:03:15.138] }
[16:03:15.141] assign_globals() ...
[16:03:15.141] List of 11
[16:03:15.141]  $ ...future.FUN            :function (x, ...)  
[16:03:15.141]  $ x_FUN                    :function (x)  
[16:03:15.141]  $ times                    : int 1
[16:03:15.141]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:15.141]  $ stop_if_not              :function (...)  
[16:03:15.141]  $ dim                      : NULL
[16:03:15.141]  $ valid_types              : chr [1:2] "logical" "integer"
[16:03:15.141]  $ future.call.arguments    : list()
[16:03:15.141]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:15.141]  $ ...future.elements_ii    :List of 1
[16:03:15.141]   ..$ a: num 1
[16:03:15.141]  $ ...future.seeds_ii       : NULL
[16:03:15.141]  $ ...future.globals.maxSize: NULL
[16:03:15.141]  - attr(*, "where")=List of 11
[16:03:15.141]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:15.141]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:15.141]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:15.141]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:15.141]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:15.141]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:15.141]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:15.141]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:15.141]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:15.141]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:15.141]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:15.141]  - attr(*, "resolved")= logi FALSE
[16:03:15.141]  - attr(*, "total_size")= num 94264
[16:03:15.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:15.141]  - attr(*, "already-done")= logi TRUE
[16:03:15.152] - copied ‘...future.FUN’ to environment
[16:03:15.152] - copied ‘x_FUN’ to environment
[16:03:15.152] - copied ‘times’ to environment
[16:03:15.152] - copied ‘stopf’ to environment
[16:03:15.152] - copied ‘stop_if_not’ to environment
[16:03:15.152] - copied ‘dim’ to environment
[16:03:15.152] - copied ‘valid_types’ to environment
[16:03:15.152] - copied ‘future.call.arguments’ to environment
[16:03:15.153] - copied ‘...future.elements_ii’ to environment
[16:03:15.153] - copied ‘...future.seeds_ii’ to environment
[16:03:15.153] - copied ‘...future.globals.maxSize’ to environment
[16:03:15.153] assign_globals() ... done
[16:03:15.153] requestCore(): workers = 2
[16:03:15.156] MulticoreFuture started
[16:03:15.156] - Launch lazy future ... done
[16:03:15.157] run() for ‘MulticoreFuture’ ... done
[16:03:15.157] Created future:
[16:03:15.158] plan(): Setting new future strategy stack:
[16:03:15.158] List of future strategies:
[16:03:15.158] 1. sequential:
[16:03:15.158]    - args: function (..., envir = parent.frame())
[16:03:15.158]    - tweaked: FALSE
[16:03:15.158]    - call: NULL
[16:03:15.159] plan(): nbrOfWorkers() = 1
[16:03:15.161] plan(): Setting new future strategy stack:
[16:03:15.161] List of future strategies:
[16:03:15.161] 1. multicore:
[16:03:15.161]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:15.161]    - tweaked: FALSE
[16:03:15.161]    - call: plan(strategy)
[16:03:15.167] plan(): nbrOfWorkers() = 2
[16:03:15.158] MulticoreFuture:
[16:03:15.158] Label: ‘future_vapply-1’
[16:03:15.158] Expression:
[16:03:15.158] {
[16:03:15.158]     do.call(function(...) {
[16:03:15.158]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.158]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:15.158]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.158]             on.exit(options(oopts), add = TRUE)
[16:03:15.158]         }
[16:03:15.158]         {
[16:03:15.158]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:15.158]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.158]                 ...future.FUN(...future.X_jj, ...)
[16:03:15.158]             })
[16:03:15.158]         }
[16:03:15.158]     }, args = future.call.arguments)
[16:03:15.158] }
[16:03:15.158] Lazy evaluation: FALSE
[16:03:15.158] Asynchronous evaluation: TRUE
[16:03:15.158] Local evaluation: TRUE
[16:03:15.158] Environment: R_GlobalEnv
[16:03:15.158] Capture standard output: TRUE
[16:03:15.158] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:15.158] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:15.158] Packages: 1 packages (‘future.apply’)
[16:03:15.158] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:15.158] Resolved: TRUE
[16:03:15.158] Value: <not collected>
[16:03:15.158] Conditions captured: <none>
[16:03:15.158] Early signaling: FALSE
[16:03:15.158] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:15.158] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:15.168] Chunk #1 of 2 ... DONE
[16:03:15.169] Chunk #2 of 2 ...
[16:03:15.169]  - Finding globals in 'X' for chunk #2 ...
[16:03:15.169] getGlobalsAndPackages() ...
[16:03:15.169] Searching for globals...
[16:03:15.170] 
[16:03:15.170] Searching for globals ... DONE
[16:03:15.170] - globals: [0] <none>
[16:03:15.170] getGlobalsAndPackages() ... DONE
[16:03:15.170]    + additional globals found: [n=0] 
[16:03:15.170]    + additional namespaces needed: [n=0] 
[16:03:15.171]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:15.171]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:15.171]  - seeds: <none>
[16:03:15.171]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.171] getGlobalsAndPackages() ...
[16:03:15.172] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.172] Resolving globals: FALSE
[16:03:15.172] Tweak future expression to call with '...' arguments ...
[16:03:15.172] {
[16:03:15.172]     do.call(function(...) {
[16:03:15.172]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.172]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:15.172]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.172]             on.exit(options(oopts), add = TRUE)
[16:03:15.172]         }
[16:03:15.172]         {
[16:03:15.172]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:15.172]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.172]                 ...future.FUN(...future.X_jj, ...)
[16:03:15.172]             })
[16:03:15.172]         }
[16:03:15.172]     }, args = future.call.arguments)
[16:03:15.172] }
[16:03:15.173] Tweak future expression to call with '...' arguments ... DONE
[16:03:15.174] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.174] - packages: [1] ‘future.apply’
[16:03:15.174] getGlobalsAndPackages() ... DONE
[16:03:15.174] run() for ‘Future’ ...
[16:03:15.175] - state: ‘created’
[16:03:15.175] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:15.180] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:15.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:15.180]   - Field: ‘label’
[16:03:15.180]   - Field: ‘local’
[16:03:15.180]   - Field: ‘owner’
[16:03:15.180]   - Field: ‘envir’
[16:03:15.181]   - Field: ‘workers’
[16:03:15.181]   - Field: ‘packages’
[16:03:15.181]   - Field: ‘gc’
[16:03:15.181]   - Field: ‘job’
[16:03:15.181]   - Field: ‘conditions’
[16:03:15.181]   - Field: ‘expr’
[16:03:15.181]   - Field: ‘uuid’
[16:03:15.182]   - Field: ‘seed’
[16:03:15.182]   - Field: ‘version’
[16:03:15.182]   - Field: ‘result’
[16:03:15.182]   - Field: ‘asynchronous’
[16:03:15.182]   - Field: ‘calls’
[16:03:15.182]   - Field: ‘globals’
[16:03:15.182]   - Field: ‘stdout’
[16:03:15.183]   - Field: ‘earlySignal’
[16:03:15.183]   - Field: ‘lazy’
[16:03:15.183]   - Field: ‘state’
[16:03:15.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:15.183] - Launch lazy future ...
[16:03:15.184] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:15.184] Packages needed by future strategies (n = 0): <none>
[16:03:15.185] {
[16:03:15.185]     {
[16:03:15.185]         {
[16:03:15.185]             ...future.startTime <- base::Sys.time()
[16:03:15.185]             {
[16:03:15.185]                 {
[16:03:15.185]                   {
[16:03:15.185]                     {
[16:03:15.185]                       {
[16:03:15.185]                         base::local({
[16:03:15.185]                           has_future <- base::requireNamespace("future", 
[16:03:15.185]                             quietly = TRUE)
[16:03:15.185]                           if (has_future) {
[16:03:15.185]                             ns <- base::getNamespace("future")
[16:03:15.185]                             version <- ns[[".package"]][["version"]]
[16:03:15.185]                             if (is.null(version)) 
[16:03:15.185]                               version <- utils::packageVersion("future")
[16:03:15.185]                           }
[16:03:15.185]                           else {
[16:03:15.185]                             version <- NULL
[16:03:15.185]                           }
[16:03:15.185]                           if (!has_future || version < "1.8.0") {
[16:03:15.185]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:15.185]                               "", base::R.version$version.string), 
[16:03:15.185]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:15.185]                                 base::R.version$platform, 8 * 
[16:03:15.185]                                   base::.Machine$sizeof.pointer), 
[16:03:15.185]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:15.185]                                 "release", "version")], collapse = " "), 
[16:03:15.185]                               hostname = base::Sys.info()[["nodename"]])
[16:03:15.185]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:15.185]                               info)
[16:03:15.185]                             info <- base::paste(info, collapse = "; ")
[16:03:15.185]                             if (!has_future) {
[16:03:15.185]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:15.185]                                 info)
[16:03:15.185]                             }
[16:03:15.185]                             else {
[16:03:15.185]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:15.185]                                 info, version)
[16:03:15.185]                             }
[16:03:15.185]                             base::stop(msg)
[16:03:15.185]                           }
[16:03:15.185]                         })
[16:03:15.185]                       }
[16:03:15.185]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:15.185]                       base::options(mc.cores = 1L)
[16:03:15.185]                     }
[16:03:15.185]                     base::local({
[16:03:15.185]                       for (pkg in "future.apply") {
[16:03:15.185]                         base::loadNamespace(pkg)
[16:03:15.185]                         base::library(pkg, character.only = TRUE)
[16:03:15.185]                       }
[16:03:15.185]                     })
[16:03:15.185]                   }
[16:03:15.185]                   options(future.plan = NULL)
[16:03:15.185]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.185]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:15.185]                 }
[16:03:15.185]                 ...future.workdir <- getwd()
[16:03:15.185]             }
[16:03:15.185]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:15.185]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:15.185]         }
[16:03:15.185]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:15.185]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:15.185]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:15.185]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:15.185]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:15.185]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:15.185]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:15.185]             base::names(...future.oldOptions))
[16:03:15.185]     }
[16:03:15.185]     if (FALSE) {
[16:03:15.185]     }
[16:03:15.185]     else {
[16:03:15.185]         if (TRUE) {
[16:03:15.185]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:15.185]                 open = "w")
[16:03:15.185]         }
[16:03:15.185]         else {
[16:03:15.185]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:15.185]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:15.185]         }
[16:03:15.185]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:15.185]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:15.185]             base::sink(type = "output", split = FALSE)
[16:03:15.185]             base::close(...future.stdout)
[16:03:15.185]         }, add = TRUE)
[16:03:15.185]     }
[16:03:15.185]     ...future.frame <- base::sys.nframe()
[16:03:15.185]     ...future.conditions <- base::list()
[16:03:15.185]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:15.185]     if (FALSE) {
[16:03:15.185]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:15.185]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:15.185]     }
[16:03:15.185]     ...future.result <- base::tryCatch({
[16:03:15.185]         base::withCallingHandlers({
[16:03:15.185]             ...future.value <- base::withVisible(base::local({
[16:03:15.185]                 withCallingHandlers({
[16:03:15.185]                   {
[16:03:15.185]                     do.call(function(...) {
[16:03:15.185]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.185]                       if (!identical(...future.globals.maxSize.org, 
[16:03:15.185]                         ...future.globals.maxSize)) {
[16:03:15.185]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.185]                         on.exit(options(oopts), add = TRUE)
[16:03:15.185]                       }
[16:03:15.185]                       {
[16:03:15.185]                         lapply(seq_along(...future.elements_ii), 
[16:03:15.185]                           FUN = function(jj) {
[16:03:15.185]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.185]                             ...future.FUN(...future.X_jj, ...)
[16:03:15.185]                           })
[16:03:15.185]                       }
[16:03:15.185]                     }, args = future.call.arguments)
[16:03:15.185]                   }
[16:03:15.185]                 }, immediateCondition = function(cond) {
[16:03:15.185]                   save_rds <- function (object, pathname, ...) 
[16:03:15.185]                   {
[16:03:15.185]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:15.185]                     if (file_test("-f", pathname_tmp)) {
[16:03:15.185]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.185]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:15.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.185]                         fi_tmp[["mtime"]])
[16:03:15.185]                     }
[16:03:15.185]                     tryCatch({
[16:03:15.185]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:15.185]                     }, error = function(ex) {
[16:03:15.185]                       msg <- conditionMessage(ex)
[16:03:15.185]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.185]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:15.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.185]                         fi_tmp[["mtime"]], msg)
[16:03:15.185]                       ex$message <- msg
[16:03:15.185]                       stop(ex)
[16:03:15.185]                     })
[16:03:15.185]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:15.185]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:15.185]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:15.185]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.185]                       fi <- file.info(pathname)
[16:03:15.185]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:15.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.185]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:15.185]                         fi[["size"]], fi[["mtime"]])
[16:03:15.185]                       stop(msg)
[16:03:15.185]                     }
[16:03:15.185]                     invisible(pathname)
[16:03:15.185]                   }
[16:03:15.185]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:15.185]                     rootPath = tempdir()) 
[16:03:15.185]                   {
[16:03:15.185]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:15.185]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:15.185]                       tmpdir = path, fileext = ".rds")
[16:03:15.185]                     save_rds(obj, file)
[16:03:15.185]                   }
[16:03:15.185]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:15.185]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.185]                   {
[16:03:15.185]                     inherits <- base::inherits
[16:03:15.185]                     invokeRestart <- base::invokeRestart
[16:03:15.185]                     is.null <- base::is.null
[16:03:15.185]                     muffled <- FALSE
[16:03:15.185]                     if (inherits(cond, "message")) {
[16:03:15.185]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:15.185]                       if (muffled) 
[16:03:15.185]                         invokeRestart("muffleMessage")
[16:03:15.185]                     }
[16:03:15.185]                     else if (inherits(cond, "warning")) {
[16:03:15.185]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:15.185]                       if (muffled) 
[16:03:15.185]                         invokeRestart("muffleWarning")
[16:03:15.185]                     }
[16:03:15.185]                     else if (inherits(cond, "condition")) {
[16:03:15.185]                       if (!is.null(pattern)) {
[16:03:15.185]                         computeRestarts <- base::computeRestarts
[16:03:15.185]                         grepl <- base::grepl
[16:03:15.185]                         restarts <- computeRestarts(cond)
[16:03:15.185]                         for (restart in restarts) {
[16:03:15.185]                           name <- restart$name
[16:03:15.185]                           if (is.null(name)) 
[16:03:15.185]                             next
[16:03:15.185]                           if (!grepl(pattern, name)) 
[16:03:15.185]                             next
[16:03:15.185]                           invokeRestart(restart)
[16:03:15.185]                           muffled <- TRUE
[16:03:15.185]                           break
[16:03:15.185]                         }
[16:03:15.185]                       }
[16:03:15.185]                     }
[16:03:15.185]                     invisible(muffled)
[16:03:15.185]                   }
[16:03:15.185]                   muffleCondition(cond)
[16:03:15.185]                 })
[16:03:15.185]             }))
[16:03:15.185]             future::FutureResult(value = ...future.value$value, 
[16:03:15.185]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.185]                   ...future.rng), globalenv = if (FALSE) 
[16:03:15.185]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:15.185]                     ...future.globalenv.names))
[16:03:15.185]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:15.185]         }, condition = base::local({
[16:03:15.185]             c <- base::c
[16:03:15.185]             inherits <- base::inherits
[16:03:15.185]             invokeRestart <- base::invokeRestart
[16:03:15.185]             length <- base::length
[16:03:15.185]             list <- base::list
[16:03:15.185]             seq.int <- base::seq.int
[16:03:15.185]             signalCondition <- base::signalCondition
[16:03:15.185]             sys.calls <- base::sys.calls
[16:03:15.185]             `[[` <- base::`[[`
[16:03:15.185]             `+` <- base::`+`
[16:03:15.185]             `<<-` <- base::`<<-`
[16:03:15.185]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:15.185]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:15.185]                   3L)]
[16:03:15.185]             }
[16:03:15.185]             function(cond) {
[16:03:15.185]                 is_error <- inherits(cond, "error")
[16:03:15.185]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:15.185]                   NULL)
[16:03:15.185]                 if (is_error) {
[16:03:15.185]                   sessionInformation <- function() {
[16:03:15.185]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:15.185]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:15.185]                       search = base::search(), system = base::Sys.info())
[16:03:15.185]                   }
[16:03:15.185]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.185]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:15.185]                     cond$call), session = sessionInformation(), 
[16:03:15.185]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:15.185]                   signalCondition(cond)
[16:03:15.185]                 }
[16:03:15.185]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:15.185]                 "immediateCondition"))) {
[16:03:15.185]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:15.185]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.185]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:15.185]                   if (TRUE && !signal) {
[16:03:15.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.185]                     {
[16:03:15.185]                       inherits <- base::inherits
[16:03:15.185]                       invokeRestart <- base::invokeRestart
[16:03:15.185]                       is.null <- base::is.null
[16:03:15.185]                       muffled <- FALSE
[16:03:15.185]                       if (inherits(cond, "message")) {
[16:03:15.185]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.185]                         if (muffled) 
[16:03:15.185]                           invokeRestart("muffleMessage")
[16:03:15.185]                       }
[16:03:15.185]                       else if (inherits(cond, "warning")) {
[16:03:15.185]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.185]                         if (muffled) 
[16:03:15.185]                           invokeRestart("muffleWarning")
[16:03:15.185]                       }
[16:03:15.185]                       else if (inherits(cond, "condition")) {
[16:03:15.185]                         if (!is.null(pattern)) {
[16:03:15.185]                           computeRestarts <- base::computeRestarts
[16:03:15.185]                           grepl <- base::grepl
[16:03:15.185]                           restarts <- computeRestarts(cond)
[16:03:15.185]                           for (restart in restarts) {
[16:03:15.185]                             name <- restart$name
[16:03:15.185]                             if (is.null(name)) 
[16:03:15.185]                               next
[16:03:15.185]                             if (!grepl(pattern, name)) 
[16:03:15.185]                               next
[16:03:15.185]                             invokeRestart(restart)
[16:03:15.185]                             muffled <- TRUE
[16:03:15.185]                             break
[16:03:15.185]                           }
[16:03:15.185]                         }
[16:03:15.185]                       }
[16:03:15.185]                       invisible(muffled)
[16:03:15.185]                     }
[16:03:15.185]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.185]                   }
[16:03:15.185]                 }
[16:03:15.185]                 else {
[16:03:15.185]                   if (TRUE) {
[16:03:15.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.185]                     {
[16:03:15.185]                       inherits <- base::inherits
[16:03:15.185]                       invokeRestart <- base::invokeRestart
[16:03:15.185]                       is.null <- base::is.null
[16:03:15.185]                       muffled <- FALSE
[16:03:15.185]                       if (inherits(cond, "message")) {
[16:03:15.185]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.185]                         if (muffled) 
[16:03:15.185]                           invokeRestart("muffleMessage")
[16:03:15.185]                       }
[16:03:15.185]                       else if (inherits(cond, "warning")) {
[16:03:15.185]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.185]                         if (muffled) 
[16:03:15.185]                           invokeRestart("muffleWarning")
[16:03:15.185]                       }
[16:03:15.185]                       else if (inherits(cond, "condition")) {
[16:03:15.185]                         if (!is.null(pattern)) {
[16:03:15.185]                           computeRestarts <- base::computeRestarts
[16:03:15.185]                           grepl <- base::grepl
[16:03:15.185]                           restarts <- computeRestarts(cond)
[16:03:15.185]                           for (restart in restarts) {
[16:03:15.185]                             name <- restart$name
[16:03:15.185]                             if (is.null(name)) 
[16:03:15.185]                               next
[16:03:15.185]                             if (!grepl(pattern, name)) 
[16:03:15.185]                               next
[16:03:15.185]                             invokeRestart(restart)
[16:03:15.185]                             muffled <- TRUE
[16:03:15.185]                             break
[16:03:15.185]                           }
[16:03:15.185]                         }
[16:03:15.185]                       }
[16:03:15.185]                       invisible(muffled)
[16:03:15.185]                     }
[16:03:15.185]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.185]                   }
[16:03:15.185]                 }
[16:03:15.185]             }
[16:03:15.185]         }))
[16:03:15.185]     }, error = function(ex) {
[16:03:15.185]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:15.185]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.185]                 ...future.rng), started = ...future.startTime, 
[16:03:15.185]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:15.185]             version = "1.8"), class = "FutureResult")
[16:03:15.185]     }, finally = {
[16:03:15.185]         if (!identical(...future.workdir, getwd())) 
[16:03:15.185]             setwd(...future.workdir)
[16:03:15.185]         {
[16:03:15.185]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:15.185]                 ...future.oldOptions$nwarnings <- NULL
[16:03:15.185]             }
[16:03:15.185]             base::options(...future.oldOptions)
[16:03:15.185]             if (.Platform$OS.type == "windows") {
[16:03:15.185]                 old_names <- names(...future.oldEnvVars)
[16:03:15.185]                 envs <- base::Sys.getenv()
[16:03:15.185]                 names <- names(envs)
[16:03:15.185]                 common <- intersect(names, old_names)
[16:03:15.185]                 added <- setdiff(names, old_names)
[16:03:15.185]                 removed <- setdiff(old_names, names)
[16:03:15.185]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:15.185]                   envs[common]]
[16:03:15.185]                 NAMES <- toupper(changed)
[16:03:15.185]                 args <- list()
[16:03:15.185]                 for (kk in seq_along(NAMES)) {
[16:03:15.185]                   name <- changed[[kk]]
[16:03:15.185]                   NAME <- NAMES[[kk]]
[16:03:15.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.185]                     next
[16:03:15.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.185]                 }
[16:03:15.185]                 NAMES <- toupper(added)
[16:03:15.185]                 for (kk in seq_along(NAMES)) {
[16:03:15.185]                   name <- added[[kk]]
[16:03:15.185]                   NAME <- NAMES[[kk]]
[16:03:15.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.185]                     next
[16:03:15.185]                   args[[name]] <- ""
[16:03:15.185]                 }
[16:03:15.185]                 NAMES <- toupper(removed)
[16:03:15.185]                 for (kk in seq_along(NAMES)) {
[16:03:15.185]                   name <- removed[[kk]]
[16:03:15.185]                   NAME <- NAMES[[kk]]
[16:03:15.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.185]                     next
[16:03:15.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.185]                 }
[16:03:15.185]                 if (length(args) > 0) 
[16:03:15.185]                   base::do.call(base::Sys.setenv, args = args)
[16:03:15.185]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:15.185]             }
[16:03:15.185]             else {
[16:03:15.185]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:15.185]             }
[16:03:15.185]             {
[16:03:15.185]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:15.185]                   0L) {
[16:03:15.185]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:15.185]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:15.185]                   base::options(opts)
[16:03:15.185]                 }
[16:03:15.185]                 {
[16:03:15.185]                   {
[16:03:15.185]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:15.185]                     NULL
[16:03:15.185]                   }
[16:03:15.185]                   options(future.plan = NULL)
[16:03:15.185]                   if (is.na(NA_character_)) 
[16:03:15.185]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.185]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:15.185]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:15.185]                     envir = parent.frame()) 
[16:03:15.185]                   {
[16:03:15.185]                     default_workers <- missing(workers)
[16:03:15.185]                     if (is.function(workers)) 
[16:03:15.185]                       workers <- workers()
[16:03:15.185]                     workers <- structure(as.integer(workers), 
[16:03:15.185]                       class = class(workers))
[16:03:15.185]                     stop_if_not(is.finite(workers), workers >= 
[16:03:15.185]                       1L)
[16:03:15.185]                     if ((workers == 1L && !inherits(workers, 
[16:03:15.185]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:15.185]                       if (default_workers) 
[16:03:15.185]                         supportsMulticore(warn = TRUE)
[16:03:15.185]                       return(sequential(..., envir = envir))
[16:03:15.185]                     }
[16:03:15.185]                     oopts <- options(mc.cores = workers)
[16:03:15.185]                     on.exit(options(oopts))
[16:03:15.185]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:15.185]                       envir = envir)
[16:03:15.185]                     if (!future$lazy) 
[16:03:15.185]                       future <- run(future)
[16:03:15.185]                     invisible(future)
[16:03:15.185]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:15.185]                 }
[16:03:15.185]             }
[16:03:15.185]         }
[16:03:15.185]     })
[16:03:15.185]     if (TRUE) {
[16:03:15.185]         base::sink(type = "output", split = FALSE)
[16:03:15.185]         if (TRUE) {
[16:03:15.185]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:15.185]         }
[16:03:15.185]         else {
[16:03:15.185]             ...future.result["stdout"] <- base::list(NULL)
[16:03:15.185]         }
[16:03:15.185]         base::close(...future.stdout)
[16:03:15.185]         ...future.stdout <- NULL
[16:03:15.185]     }
[16:03:15.185]     ...future.result$conditions <- ...future.conditions
[16:03:15.185]     ...future.result$finished <- base::Sys.time()
[16:03:15.185]     ...future.result
[16:03:15.185] }
[16:03:15.188] assign_globals() ...
[16:03:15.188] List of 11
[16:03:15.188]  $ ...future.FUN            :function (x, ...)  
[16:03:15.188]  $ x_FUN                    :function (x)  
[16:03:15.188]  $ times                    : int 1
[16:03:15.188]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:15.188]  $ stop_if_not              :function (...)  
[16:03:15.188]  $ dim                      : NULL
[16:03:15.188]  $ valid_types              : chr [1:2] "logical" "integer"
[16:03:15.188]  $ future.call.arguments    : list()
[16:03:15.188]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:15.188]  $ ...future.elements_ii    :List of 2
[16:03:15.188]   ..$ b: num 2
[16:03:15.188]   ..$ c: num 3
[16:03:15.188]  $ ...future.seeds_ii       : NULL
[16:03:15.188]  $ ...future.globals.maxSize: NULL
[16:03:15.188]  - attr(*, "where")=List of 11
[16:03:15.188]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:15.188]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:15.188]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:15.188]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:15.188]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:15.188]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:15.188]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:15.188]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:15.188]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:15.188]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:15.188]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:15.188]  - attr(*, "resolved")= logi FALSE
[16:03:15.188]  - attr(*, "total_size")= num 94264
[16:03:15.188]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:15.188]  - attr(*, "already-done")= logi TRUE
[16:03:15.204] - copied ‘...future.FUN’ to environment
[16:03:15.204] - copied ‘x_FUN’ to environment
[16:03:15.204] - copied ‘times’ to environment
[16:03:15.204] - copied ‘stopf’ to environment
[16:03:15.204] - copied ‘stop_if_not’ to environment
[16:03:15.204] - copied ‘dim’ to environment
[16:03:15.204] - copied ‘valid_types’ to environment
[16:03:15.204] - copied ‘future.call.arguments’ to environment
[16:03:15.204] - copied ‘...future.elements_ii’ to environment
[16:03:15.205] - copied ‘...future.seeds_ii’ to environment
[16:03:15.205] - copied ‘...future.globals.maxSize’ to environment
[16:03:15.205] assign_globals() ... done
[16:03:15.205] requestCore(): workers = 2
[16:03:15.207] MulticoreFuture started
[16:03:15.208] - Launch lazy future ... done
[16:03:15.208] run() for ‘MulticoreFuture’ ... done
[16:03:15.208] Created future:
[16:03:15.209] plan(): Setting new future strategy stack:
[16:03:15.209] List of future strategies:
[16:03:15.209] 1. sequential:
[16:03:15.209]    - args: function (..., envir = parent.frame())
[16:03:15.209]    - tweaked: FALSE
[16:03:15.209]    - call: NULL
[16:03:15.210] plan(): nbrOfWorkers() = 1
[16:03:15.212] plan(): Setting new future strategy stack:
[16:03:15.212] List of future strategies:
[16:03:15.212] 1. multicore:
[16:03:15.212]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:15.212]    - tweaked: FALSE
[16:03:15.212]    - call: plan(strategy)
[16:03:15.218] plan(): nbrOfWorkers() = 2
[16:03:15.208] MulticoreFuture:
[16:03:15.208] Label: ‘future_vapply-2’
[16:03:15.208] Expression:
[16:03:15.208] {
[16:03:15.208]     do.call(function(...) {
[16:03:15.208]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.208]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:15.208]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.208]             on.exit(options(oopts), add = TRUE)
[16:03:15.208]         }
[16:03:15.208]         {
[16:03:15.208]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:15.208]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.208]                 ...future.FUN(...future.X_jj, ...)
[16:03:15.208]             })
[16:03:15.208]         }
[16:03:15.208]     }, args = future.call.arguments)
[16:03:15.208] }
[16:03:15.208] Lazy evaluation: FALSE
[16:03:15.208] Asynchronous evaluation: TRUE
[16:03:15.208] Local evaluation: TRUE
[16:03:15.208] Environment: R_GlobalEnv
[16:03:15.208] Capture standard output: TRUE
[16:03:15.208] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:15.208] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:15.208] Packages: 1 packages (‘future.apply’)
[16:03:15.208] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:15.208] Resolved: TRUE
[16:03:15.208] Value: <not collected>
[16:03:15.208] Conditions captured: <none>
[16:03:15.208] Early signaling: FALSE
[16:03:15.208] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:15.208] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:15.219] Chunk #2 of 2 ... DONE
[16:03:15.219] Launching 2 futures (chunks) ... DONE
[16:03:15.219] Resolving 2 futures (chunks) ...
[16:03:15.219] resolve() on list ...
[16:03:15.219]  recursive: 0
[16:03:15.220]  length: 2
[16:03:15.220] 
[16:03:15.220] Future #1
[16:03:15.220] result() for MulticoreFuture ...
[16:03:15.221] result() for MulticoreFuture ...
[16:03:15.221] result() for MulticoreFuture ... done
[16:03:15.221] result() for MulticoreFuture ... done
[16:03:15.222] result() for MulticoreFuture ...
[16:03:15.222] result() for MulticoreFuture ... done
[16:03:15.222] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:15.222] - nx: 2
[16:03:15.222] - relay: TRUE
[16:03:15.222] - stdout: TRUE
[16:03:15.223] - signal: TRUE
[16:03:15.223] - resignal: FALSE
[16:03:15.223] - force: TRUE
[16:03:15.223] - relayed: [n=2] FALSE, FALSE
[16:03:15.223] - queued futures: [n=2] FALSE, FALSE
[16:03:15.224]  - until=1
[16:03:15.224]  - relaying element #1
[16:03:15.224] result() for MulticoreFuture ...
[16:03:15.224] result() for MulticoreFuture ... done
[16:03:15.224] result() for MulticoreFuture ...
[16:03:15.224] result() for MulticoreFuture ... done
[16:03:15.225] result() for MulticoreFuture ...
[16:03:15.225] result() for MulticoreFuture ... done
[16:03:15.225] result() for MulticoreFuture ...
[16:03:15.225] result() for MulticoreFuture ... done
[16:03:15.225] - relayed: [n=2] TRUE, FALSE
[16:03:15.225] - queued futures: [n=2] TRUE, FALSE
[16:03:15.225] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:15.226]  length: 1 (resolved future 1)
[16:03:15.226] Future #2
[16:03:15.226] result() for MulticoreFuture ...
[16:03:15.227] result() for MulticoreFuture ...
[16:03:15.227] result() for MulticoreFuture ... done
[16:03:15.227] result() for MulticoreFuture ... done
[16:03:15.228] result() for MulticoreFuture ...
[16:03:15.228] result() for MulticoreFuture ... done
[16:03:15.228] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:15.228] - nx: 2
[16:03:15.228] - relay: TRUE
[16:03:15.229] - stdout: TRUE
[16:03:15.229] - signal: TRUE
[16:03:15.229] - resignal: FALSE
[16:03:15.229] - force: TRUE
[16:03:15.229] - relayed: [n=2] TRUE, FALSE
[16:03:15.229] - queued futures: [n=2] TRUE, FALSE
[16:03:15.230]  - until=2
[16:03:15.230]  - relaying element #2
[16:03:15.230] result() for MulticoreFuture ...
[16:03:15.230] result() for MulticoreFuture ... done
[16:03:15.230] result() for MulticoreFuture ...
[16:03:15.230] result() for MulticoreFuture ... done
[16:03:15.233] result() for MulticoreFuture ...
[16:03:15.233] result() for MulticoreFuture ... done
[16:03:15.233] result() for MulticoreFuture ...
[16:03:15.233] result() for MulticoreFuture ... done
[16:03:15.233] - relayed: [n=2] TRUE, TRUE
[16:03:15.234] - queued futures: [n=2] TRUE, TRUE
[16:03:15.234] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:03:15.234]  length: 0 (resolved future 2)
[16:03:15.234] Relaying remaining futures
[16:03:15.234] signalConditionsASAP(NULL, pos=0) ...
[16:03:15.234] - nx: 2
[16:03:15.235] - relay: TRUE
[16:03:15.235] - stdout: TRUE
[16:03:15.235] - signal: TRUE
[16:03:15.235] - resignal: FALSE
[16:03:15.235] - force: TRUE
[16:03:15.235] - relayed: [n=2] TRUE, TRUE
[16:03:15.236] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:15.236] - relayed: [n=2] TRUE, TRUE
[16:03:15.236] - queued futures: [n=2] TRUE, TRUE
[16:03:15.236] signalConditionsASAP(NULL, pos=0) ... done
[16:03:15.236] resolve() on list ... DONE
[16:03:15.236] result() for MulticoreFuture ...
[16:03:15.237] result() for MulticoreFuture ... done
[16:03:15.237] result() for MulticoreFuture ...
[16:03:15.237] result() for MulticoreFuture ... done
[16:03:15.237] result() for MulticoreFuture ...
[16:03:15.237] result() for MulticoreFuture ... done
[16:03:15.237] result() for MulticoreFuture ...
[16:03:15.238] result() for MulticoreFuture ... done
[16:03:15.238]  - Number of value chunks collected: 2
[16:03:15.238] Resolving 2 futures (chunks) ... DONE
[16:03:15.238] Reducing values from 2 chunks ...
[16:03:15.238]  - Number of values collected after concatenation: 3
[16:03:15.238]  - Number of values expected: 3
[16:03:15.239] Reducing values from 2 chunks ... DONE
[16:03:15.239] future_lapply() ... DONE
- exceptions ...
[16:03:15.239] future_lapply() ...
[16:03:15.246] Number of chunks: 2
[16:03:15.246] getGlobalsAndPackagesXApply() ...
[16:03:15.247]  - future.globals: TRUE
[16:03:15.247] getGlobalsAndPackages() ...
[16:03:15.247] Searching for globals...
[16:03:15.251] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:15.251] Searching for globals ... DONE
[16:03:15.251] Resolving globals: FALSE
[16:03:15.252] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[16:03:15.252] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:15.253] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:15.253] - packages: [1] ‘future.apply’
[16:03:15.253] getGlobalsAndPackages() ... DONE
[16:03:15.253]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:15.253]  - needed namespaces: [n=1] ‘future.apply’
[16:03:15.253] Finding globals ... DONE
[16:03:15.253]  - use_args: TRUE
[16:03:15.253]  - Getting '...' globals ...
[16:03:15.254] resolve() on list ...
[16:03:15.254]  recursive: 0
[16:03:15.254]  length: 1
[16:03:15.254]  elements: ‘...’
[16:03:15.254]  length: 0 (resolved future 1)
[16:03:15.254] resolve() on list ... DONE
[16:03:15.254]    - '...' content: [n=0] 
[16:03:15.254] List of 1
[16:03:15.254]  $ ...: list()
[16:03:15.254]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:15.254]  - attr(*, "where")=List of 1
[16:03:15.254]   ..$ ...:<environment: 0x564e42e51308> 
[16:03:15.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:15.254]  - attr(*, "resolved")= logi TRUE
[16:03:15.254]  - attr(*, "total_size")= num NA
[16:03:15.257]  - Getting '...' globals ... DONE
[16:03:15.259] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:15.260] List of 8
[16:03:15.260]  $ ...future.FUN:function (x, ...)  
[16:03:15.260]  $ x_FUN        :function (x)  
[16:03:15.260]  $ times        : int 2
[16:03:15.260]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:15.260]  $ stop_if_not  :function (...)  
[16:03:15.260]  $ dim          : NULL
[16:03:15.260]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:15.260]  $ ...          : list()
[16:03:15.260]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:15.260]  - attr(*, "where")=List of 8
[16:03:15.260]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:15.260]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:15.260]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:15.260]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:15.260]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:15.260]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:15.260]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:15.260]   ..$ ...          :<environment: 0x564e42e51308> 
[16:03:15.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:15.260]  - attr(*, "resolved")= logi FALSE
[16:03:15.260]  - attr(*, "total_size")= num 95128
[16:03:15.266] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:15.266] getGlobalsAndPackagesXApply() ... DONE
[16:03:15.266] Number of futures (= number of chunks): 2
[16:03:15.266] Launching 2 futures (chunks) ...
[16:03:15.267] Chunk #1 of 2 ...
[16:03:15.267]  - Finding globals in 'X' for chunk #1 ...
[16:03:15.267] getGlobalsAndPackages() ...
[16:03:15.267] Searching for globals...
[16:03:15.267] 
[16:03:15.267] Searching for globals ... DONE
[16:03:15.267] - globals: [0] <none>
[16:03:15.267] getGlobalsAndPackages() ... DONE
[16:03:15.268]    + additional globals found: [n=0] 
[16:03:15.268]    + additional namespaces needed: [n=0] 
[16:03:15.268]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:15.268]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:15.268]  - seeds: <none>
[16:03:15.268]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.268] getGlobalsAndPackages() ...
[16:03:15.268] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.268] Resolving globals: FALSE
[16:03:15.268] Tweak future expression to call with '...' arguments ...
[16:03:15.269] {
[16:03:15.269]     do.call(function(...) {
[16:03:15.269]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.269]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:15.269]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.269]             on.exit(options(oopts), add = TRUE)
[16:03:15.269]         }
[16:03:15.269]         {
[16:03:15.269]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:15.269]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.269]                 ...future.FUN(...future.X_jj, ...)
[16:03:15.269]             })
[16:03:15.269]         }
[16:03:15.269]     }, args = future.call.arguments)
[16:03:15.269] }
[16:03:15.269] Tweak future expression to call with '...' arguments ... DONE
[16:03:15.269] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.269] - packages: [1] ‘future.apply’
[16:03:15.270] getGlobalsAndPackages() ... DONE
[16:03:15.270] run() for ‘Future’ ...
[16:03:15.270] - state: ‘created’
[16:03:15.270] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:15.274] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:15.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:15.274]   - Field: ‘label’
[16:03:15.274]   - Field: ‘local’
[16:03:15.274]   - Field: ‘owner’
[16:03:15.274]   - Field: ‘envir’
[16:03:15.274]   - Field: ‘workers’
[16:03:15.275]   - Field: ‘packages’
[16:03:15.275]   - Field: ‘gc’
[16:03:15.275]   - Field: ‘job’
[16:03:15.275]   - Field: ‘conditions’
[16:03:15.275]   - Field: ‘expr’
[16:03:15.275]   - Field: ‘uuid’
[16:03:15.275]   - Field: ‘seed’
[16:03:15.275]   - Field: ‘version’
[16:03:15.275]   - Field: ‘result’
[16:03:15.275]   - Field: ‘asynchronous’
[16:03:15.276]   - Field: ‘calls’
[16:03:15.276]   - Field: ‘globals’
[16:03:15.276]   - Field: ‘stdout’
[16:03:15.276]   - Field: ‘earlySignal’
[16:03:15.276]   - Field: ‘lazy’
[16:03:15.276]   - Field: ‘state’
[16:03:15.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:15.276] - Launch lazy future ...
[16:03:15.276] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:15.277] Packages needed by future strategies (n = 0): <none>
[16:03:15.277] {
[16:03:15.277]     {
[16:03:15.277]         {
[16:03:15.277]             ...future.startTime <- base::Sys.time()
[16:03:15.277]             {
[16:03:15.277]                 {
[16:03:15.277]                   {
[16:03:15.277]                     {
[16:03:15.277]                       {
[16:03:15.277]                         base::local({
[16:03:15.277]                           has_future <- base::requireNamespace("future", 
[16:03:15.277]                             quietly = TRUE)
[16:03:15.277]                           if (has_future) {
[16:03:15.277]                             ns <- base::getNamespace("future")
[16:03:15.277]                             version <- ns[[".package"]][["version"]]
[16:03:15.277]                             if (is.null(version)) 
[16:03:15.277]                               version <- utils::packageVersion("future")
[16:03:15.277]                           }
[16:03:15.277]                           else {
[16:03:15.277]                             version <- NULL
[16:03:15.277]                           }
[16:03:15.277]                           if (!has_future || version < "1.8.0") {
[16:03:15.277]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:15.277]                               "", base::R.version$version.string), 
[16:03:15.277]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:15.277]                                 base::R.version$platform, 8 * 
[16:03:15.277]                                   base::.Machine$sizeof.pointer), 
[16:03:15.277]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:15.277]                                 "release", "version")], collapse = " "), 
[16:03:15.277]                               hostname = base::Sys.info()[["nodename"]])
[16:03:15.277]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:15.277]                               info)
[16:03:15.277]                             info <- base::paste(info, collapse = "; ")
[16:03:15.277]                             if (!has_future) {
[16:03:15.277]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:15.277]                                 info)
[16:03:15.277]                             }
[16:03:15.277]                             else {
[16:03:15.277]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:15.277]                                 info, version)
[16:03:15.277]                             }
[16:03:15.277]                             base::stop(msg)
[16:03:15.277]                           }
[16:03:15.277]                         })
[16:03:15.277]                       }
[16:03:15.277]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:15.277]                       base::options(mc.cores = 1L)
[16:03:15.277]                     }
[16:03:15.277]                     base::local({
[16:03:15.277]                       for (pkg in "future.apply") {
[16:03:15.277]                         base::loadNamespace(pkg)
[16:03:15.277]                         base::library(pkg, character.only = TRUE)
[16:03:15.277]                       }
[16:03:15.277]                     })
[16:03:15.277]                   }
[16:03:15.277]                   options(future.plan = NULL)
[16:03:15.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:15.277]                 }
[16:03:15.277]                 ...future.workdir <- getwd()
[16:03:15.277]             }
[16:03:15.277]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:15.277]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:15.277]         }
[16:03:15.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:15.277]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:15.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:15.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:15.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:15.277]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:15.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:15.277]             base::names(...future.oldOptions))
[16:03:15.277]     }
[16:03:15.277]     if (FALSE) {
[16:03:15.277]     }
[16:03:15.277]     else {
[16:03:15.277]         if (TRUE) {
[16:03:15.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:15.277]                 open = "w")
[16:03:15.277]         }
[16:03:15.277]         else {
[16:03:15.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:15.277]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:15.277]         }
[16:03:15.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:15.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:15.277]             base::sink(type = "output", split = FALSE)
[16:03:15.277]             base::close(...future.stdout)
[16:03:15.277]         }, add = TRUE)
[16:03:15.277]     }
[16:03:15.277]     ...future.frame <- base::sys.nframe()
[16:03:15.277]     ...future.conditions <- base::list()
[16:03:15.277]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:15.277]     if (FALSE) {
[16:03:15.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:15.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:15.277]     }
[16:03:15.277]     ...future.result <- base::tryCatch({
[16:03:15.277]         base::withCallingHandlers({
[16:03:15.277]             ...future.value <- base::withVisible(base::local({
[16:03:15.277]                 withCallingHandlers({
[16:03:15.277]                   {
[16:03:15.277]                     do.call(function(...) {
[16:03:15.277]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.277]                       if (!identical(...future.globals.maxSize.org, 
[16:03:15.277]                         ...future.globals.maxSize)) {
[16:03:15.277]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.277]                         on.exit(options(oopts), add = TRUE)
[16:03:15.277]                       }
[16:03:15.277]                       {
[16:03:15.277]                         lapply(seq_along(...future.elements_ii), 
[16:03:15.277]                           FUN = function(jj) {
[16:03:15.277]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.277]                             ...future.FUN(...future.X_jj, ...)
[16:03:15.277]                           })
[16:03:15.277]                       }
[16:03:15.277]                     }, args = future.call.arguments)
[16:03:15.277]                   }
[16:03:15.277]                 }, immediateCondition = function(cond) {
[16:03:15.277]                   save_rds <- function (object, pathname, ...) 
[16:03:15.277]                   {
[16:03:15.277]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:15.277]                     if (file_test("-f", pathname_tmp)) {
[16:03:15.277]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.277]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:15.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.277]                         fi_tmp[["mtime"]])
[16:03:15.277]                     }
[16:03:15.277]                     tryCatch({
[16:03:15.277]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:15.277]                     }, error = function(ex) {
[16:03:15.277]                       msg <- conditionMessage(ex)
[16:03:15.277]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.277]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:15.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.277]                         fi_tmp[["mtime"]], msg)
[16:03:15.277]                       ex$message <- msg
[16:03:15.277]                       stop(ex)
[16:03:15.277]                     })
[16:03:15.277]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:15.277]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:15.277]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:15.277]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.277]                       fi <- file.info(pathname)
[16:03:15.277]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:15.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.277]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:15.277]                         fi[["size"]], fi[["mtime"]])
[16:03:15.277]                       stop(msg)
[16:03:15.277]                     }
[16:03:15.277]                     invisible(pathname)
[16:03:15.277]                   }
[16:03:15.277]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:15.277]                     rootPath = tempdir()) 
[16:03:15.277]                   {
[16:03:15.277]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:15.277]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:15.277]                       tmpdir = path, fileext = ".rds")
[16:03:15.277]                     save_rds(obj, file)
[16:03:15.277]                   }
[16:03:15.277]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:15.277]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.277]                   {
[16:03:15.277]                     inherits <- base::inherits
[16:03:15.277]                     invokeRestart <- base::invokeRestart
[16:03:15.277]                     is.null <- base::is.null
[16:03:15.277]                     muffled <- FALSE
[16:03:15.277]                     if (inherits(cond, "message")) {
[16:03:15.277]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:15.277]                       if (muffled) 
[16:03:15.277]                         invokeRestart("muffleMessage")
[16:03:15.277]                     }
[16:03:15.277]                     else if (inherits(cond, "warning")) {
[16:03:15.277]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:15.277]                       if (muffled) 
[16:03:15.277]                         invokeRestart("muffleWarning")
[16:03:15.277]                     }
[16:03:15.277]                     else if (inherits(cond, "condition")) {
[16:03:15.277]                       if (!is.null(pattern)) {
[16:03:15.277]                         computeRestarts <- base::computeRestarts
[16:03:15.277]                         grepl <- base::grepl
[16:03:15.277]                         restarts <- computeRestarts(cond)
[16:03:15.277]                         for (restart in restarts) {
[16:03:15.277]                           name <- restart$name
[16:03:15.277]                           if (is.null(name)) 
[16:03:15.277]                             next
[16:03:15.277]                           if (!grepl(pattern, name)) 
[16:03:15.277]                             next
[16:03:15.277]                           invokeRestart(restart)
[16:03:15.277]                           muffled <- TRUE
[16:03:15.277]                           break
[16:03:15.277]                         }
[16:03:15.277]                       }
[16:03:15.277]                     }
[16:03:15.277]                     invisible(muffled)
[16:03:15.277]                   }
[16:03:15.277]                   muffleCondition(cond)
[16:03:15.277]                 })
[16:03:15.277]             }))
[16:03:15.277]             future::FutureResult(value = ...future.value$value, 
[16:03:15.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.277]                   ...future.rng), globalenv = if (FALSE) 
[16:03:15.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:15.277]                     ...future.globalenv.names))
[16:03:15.277]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:15.277]         }, condition = base::local({
[16:03:15.277]             c <- base::c
[16:03:15.277]             inherits <- base::inherits
[16:03:15.277]             invokeRestart <- base::invokeRestart
[16:03:15.277]             length <- base::length
[16:03:15.277]             list <- base::list
[16:03:15.277]             seq.int <- base::seq.int
[16:03:15.277]             signalCondition <- base::signalCondition
[16:03:15.277]             sys.calls <- base::sys.calls
[16:03:15.277]             `[[` <- base::`[[`
[16:03:15.277]             `+` <- base::`+`
[16:03:15.277]             `<<-` <- base::`<<-`
[16:03:15.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:15.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:15.277]                   3L)]
[16:03:15.277]             }
[16:03:15.277]             function(cond) {
[16:03:15.277]                 is_error <- inherits(cond, "error")
[16:03:15.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:15.277]                   NULL)
[16:03:15.277]                 if (is_error) {
[16:03:15.277]                   sessionInformation <- function() {
[16:03:15.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:15.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:15.277]                       search = base::search(), system = base::Sys.info())
[16:03:15.277]                   }
[16:03:15.277]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:15.277]                     cond$call), session = sessionInformation(), 
[16:03:15.277]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:15.277]                   signalCondition(cond)
[16:03:15.277]                 }
[16:03:15.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:15.277]                 "immediateCondition"))) {
[16:03:15.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:15.277]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:15.277]                   if (TRUE && !signal) {
[16:03:15.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.277]                     {
[16:03:15.277]                       inherits <- base::inherits
[16:03:15.277]                       invokeRestart <- base::invokeRestart
[16:03:15.277]                       is.null <- base::is.null
[16:03:15.277]                       muffled <- FALSE
[16:03:15.277]                       if (inherits(cond, "message")) {
[16:03:15.277]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.277]                         if (muffled) 
[16:03:15.277]                           invokeRestart("muffleMessage")
[16:03:15.277]                       }
[16:03:15.277]                       else if (inherits(cond, "warning")) {
[16:03:15.277]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.277]                         if (muffled) 
[16:03:15.277]                           invokeRestart("muffleWarning")
[16:03:15.277]                       }
[16:03:15.277]                       else if (inherits(cond, "condition")) {
[16:03:15.277]                         if (!is.null(pattern)) {
[16:03:15.277]                           computeRestarts <- base::computeRestarts
[16:03:15.277]                           grepl <- base::grepl
[16:03:15.277]                           restarts <- computeRestarts(cond)
[16:03:15.277]                           for (restart in restarts) {
[16:03:15.277]                             name <- restart$name
[16:03:15.277]                             if (is.null(name)) 
[16:03:15.277]                               next
[16:03:15.277]                             if (!grepl(pattern, name)) 
[16:03:15.277]                               next
[16:03:15.277]                             invokeRestart(restart)
[16:03:15.277]                             muffled <- TRUE
[16:03:15.277]                             break
[16:03:15.277]                           }
[16:03:15.277]                         }
[16:03:15.277]                       }
[16:03:15.277]                       invisible(muffled)
[16:03:15.277]                     }
[16:03:15.277]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.277]                   }
[16:03:15.277]                 }
[16:03:15.277]                 else {
[16:03:15.277]                   if (TRUE) {
[16:03:15.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.277]                     {
[16:03:15.277]                       inherits <- base::inherits
[16:03:15.277]                       invokeRestart <- base::invokeRestart
[16:03:15.277]                       is.null <- base::is.null
[16:03:15.277]                       muffled <- FALSE
[16:03:15.277]                       if (inherits(cond, "message")) {
[16:03:15.277]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.277]                         if (muffled) 
[16:03:15.277]                           invokeRestart("muffleMessage")
[16:03:15.277]                       }
[16:03:15.277]                       else if (inherits(cond, "warning")) {
[16:03:15.277]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.277]                         if (muffled) 
[16:03:15.277]                           invokeRestart("muffleWarning")
[16:03:15.277]                       }
[16:03:15.277]                       else if (inherits(cond, "condition")) {
[16:03:15.277]                         if (!is.null(pattern)) {
[16:03:15.277]                           computeRestarts <- base::computeRestarts
[16:03:15.277]                           grepl <- base::grepl
[16:03:15.277]                           restarts <- computeRestarts(cond)
[16:03:15.277]                           for (restart in restarts) {
[16:03:15.277]                             name <- restart$name
[16:03:15.277]                             if (is.null(name)) 
[16:03:15.277]                               next
[16:03:15.277]                             if (!grepl(pattern, name)) 
[16:03:15.277]                               next
[16:03:15.277]                             invokeRestart(restart)
[16:03:15.277]                             muffled <- TRUE
[16:03:15.277]                             break
[16:03:15.277]                           }
[16:03:15.277]                         }
[16:03:15.277]                       }
[16:03:15.277]                       invisible(muffled)
[16:03:15.277]                     }
[16:03:15.277]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.277]                   }
[16:03:15.277]                 }
[16:03:15.277]             }
[16:03:15.277]         }))
[16:03:15.277]     }, error = function(ex) {
[16:03:15.277]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:15.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.277]                 ...future.rng), started = ...future.startTime, 
[16:03:15.277]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:15.277]             version = "1.8"), class = "FutureResult")
[16:03:15.277]     }, finally = {
[16:03:15.277]         if (!identical(...future.workdir, getwd())) 
[16:03:15.277]             setwd(...future.workdir)
[16:03:15.277]         {
[16:03:15.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:15.277]                 ...future.oldOptions$nwarnings <- NULL
[16:03:15.277]             }
[16:03:15.277]             base::options(...future.oldOptions)
[16:03:15.277]             if (.Platform$OS.type == "windows") {
[16:03:15.277]                 old_names <- names(...future.oldEnvVars)
[16:03:15.277]                 envs <- base::Sys.getenv()
[16:03:15.277]                 names <- names(envs)
[16:03:15.277]                 common <- intersect(names, old_names)
[16:03:15.277]                 added <- setdiff(names, old_names)
[16:03:15.277]                 removed <- setdiff(old_names, names)
[16:03:15.277]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:15.277]                   envs[common]]
[16:03:15.277]                 NAMES <- toupper(changed)
[16:03:15.277]                 args <- list()
[16:03:15.277]                 for (kk in seq_along(NAMES)) {
[16:03:15.277]                   name <- changed[[kk]]
[16:03:15.277]                   NAME <- NAMES[[kk]]
[16:03:15.277]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.277]                     next
[16:03:15.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.277]                 }
[16:03:15.277]                 NAMES <- toupper(added)
[16:03:15.277]                 for (kk in seq_along(NAMES)) {
[16:03:15.277]                   name <- added[[kk]]
[16:03:15.277]                   NAME <- NAMES[[kk]]
[16:03:15.277]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.277]                     next
[16:03:15.277]                   args[[name]] <- ""
[16:03:15.277]                 }
[16:03:15.277]                 NAMES <- toupper(removed)
[16:03:15.277]                 for (kk in seq_along(NAMES)) {
[16:03:15.277]                   name <- removed[[kk]]
[16:03:15.277]                   NAME <- NAMES[[kk]]
[16:03:15.277]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.277]                     next
[16:03:15.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.277]                 }
[16:03:15.277]                 if (length(args) > 0) 
[16:03:15.277]                   base::do.call(base::Sys.setenv, args = args)
[16:03:15.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:15.277]             }
[16:03:15.277]             else {
[16:03:15.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:15.277]             }
[16:03:15.277]             {
[16:03:15.277]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:15.277]                   0L) {
[16:03:15.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:15.277]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:15.277]                   base::options(opts)
[16:03:15.277]                 }
[16:03:15.277]                 {
[16:03:15.277]                   {
[16:03:15.277]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:15.277]                     NULL
[16:03:15.277]                   }
[16:03:15.277]                   options(future.plan = NULL)
[16:03:15.277]                   if (is.na(NA_character_)) 
[16:03:15.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:15.277]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:15.277]                     envir = parent.frame()) 
[16:03:15.277]                   {
[16:03:15.277]                     default_workers <- missing(workers)
[16:03:15.277]                     if (is.function(workers)) 
[16:03:15.277]                       workers <- workers()
[16:03:15.277]                     workers <- structure(as.integer(workers), 
[16:03:15.277]                       class = class(workers))
[16:03:15.277]                     stop_if_not(is.finite(workers), workers >= 
[16:03:15.277]                       1L)
[16:03:15.277]                     if ((workers == 1L && !inherits(workers, 
[16:03:15.277]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:15.277]                       if (default_workers) 
[16:03:15.277]                         supportsMulticore(warn = TRUE)
[16:03:15.277]                       return(sequential(..., envir = envir))
[16:03:15.277]                     }
[16:03:15.277]                     oopts <- options(mc.cores = workers)
[16:03:15.277]                     on.exit(options(oopts))
[16:03:15.277]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:15.277]                       envir = envir)
[16:03:15.277]                     if (!future$lazy) 
[16:03:15.277]                       future <- run(future)
[16:03:15.277]                     invisible(future)
[16:03:15.277]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:15.277]                 }
[16:03:15.277]             }
[16:03:15.277]         }
[16:03:15.277]     })
[16:03:15.277]     if (TRUE) {
[16:03:15.277]         base::sink(type = "output", split = FALSE)
[16:03:15.277]         if (TRUE) {
[16:03:15.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:15.277]         }
[16:03:15.277]         else {
[16:03:15.277]             ...future.result["stdout"] <- base::list(NULL)
[16:03:15.277]         }
[16:03:15.277]         base::close(...future.stdout)
[16:03:15.277]         ...future.stdout <- NULL
[16:03:15.277]     }
[16:03:15.277]     ...future.result$conditions <- ...future.conditions
[16:03:15.277]     ...future.result$finished <- base::Sys.time()
[16:03:15.277]     ...future.result
[16:03:15.277] }
[16:03:15.280] assign_globals() ...
[16:03:15.280] List of 11
[16:03:15.280]  $ ...future.FUN            :function (x, ...)  
[16:03:15.280]  $ x_FUN                    :function (x)  
[16:03:15.280]  $ times                    : int 2
[16:03:15.280]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:15.280]  $ stop_if_not              :function (...)  
[16:03:15.280]  $ dim                      : NULL
[16:03:15.280]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:15.280]  $ future.call.arguments    : list()
[16:03:15.280]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:15.280]  $ ...future.elements_ii    :List of 1
[16:03:15.280]   ..$ : int 1
[16:03:15.280]  $ ...future.seeds_ii       : NULL
[16:03:15.280]  $ ...future.globals.maxSize: NULL
[16:03:15.280]  - attr(*, "where")=List of 11
[16:03:15.280]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:15.280]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:15.280]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:15.280]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:15.280]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:15.280]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:15.280]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:15.280]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:15.280]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:15.280]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:15.280]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:15.280]  - attr(*, "resolved")= logi FALSE
[16:03:15.280]  - attr(*, "total_size")= num 95128
[16:03:15.280]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:15.280]  - attr(*, "already-done")= logi TRUE
[16:03:15.290] - copied ‘...future.FUN’ to environment
[16:03:15.290] - copied ‘x_FUN’ to environment
[16:03:15.290] - copied ‘times’ to environment
[16:03:15.290] - copied ‘stopf’ to environment
[16:03:15.290] - copied ‘stop_if_not’ to environment
[16:03:15.291] - copied ‘dim’ to environment
[16:03:15.291] - copied ‘valid_types’ to environment
[16:03:15.291] - copied ‘future.call.arguments’ to environment
[16:03:15.291] - copied ‘...future.elements_ii’ to environment
[16:03:15.291] - copied ‘...future.seeds_ii’ to environment
[16:03:15.291] - copied ‘...future.globals.maxSize’ to environment
[16:03:15.291] assign_globals() ... done
[16:03:15.291] requestCore(): workers = 2
[16:03:15.294] MulticoreFuture started
[16:03:15.294] - Launch lazy future ... done
[16:03:15.295] run() for ‘MulticoreFuture’ ... done
[16:03:15.295] plan(): Setting new future strategy stack:
[16:03:15.296] Created future:
[16:03:15.296] List of future strategies:
[16:03:15.296] 1. sequential:
[16:03:15.296]    - args: function (..., envir = parent.frame())
[16:03:15.296]    - tweaked: FALSE
[16:03:15.296]    - call: NULL
[16:03:15.297] plan(): nbrOfWorkers() = 1
[16:03:15.299] plan(): Setting new future strategy stack:
[16:03:15.299] List of future strategies:
[16:03:15.299] 1. multicore:
[16:03:15.299]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:15.299]    - tweaked: FALSE
[16:03:15.299]    - call: plan(strategy)
[16:03:15.305] plan(): nbrOfWorkers() = 2
[16:03:15.296] MulticoreFuture:
[16:03:15.296] Label: ‘future_vapply-1’
[16:03:15.296] Expression:
[16:03:15.296] {
[16:03:15.296]     do.call(function(...) {
[16:03:15.296]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.296]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:15.296]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.296]             on.exit(options(oopts), add = TRUE)
[16:03:15.296]         }
[16:03:15.296]         {
[16:03:15.296]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:15.296]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.296]                 ...future.FUN(...future.X_jj, ...)
[16:03:15.296]             })
[16:03:15.296]         }
[16:03:15.296]     }, args = future.call.arguments)
[16:03:15.296] }
[16:03:15.296] Lazy evaluation: FALSE
[16:03:15.296] Asynchronous evaluation: TRUE
[16:03:15.296] Local evaluation: TRUE
[16:03:15.296] Environment: R_GlobalEnv
[16:03:15.296] Capture standard output: TRUE
[16:03:15.296] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:15.296] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:15.296] Packages: 1 packages (‘future.apply’)
[16:03:15.296] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:15.296] Resolved: FALSE
[16:03:15.296] Value: <not collected>
[16:03:15.296] Conditions captured: <none>
[16:03:15.296] Early signaling: FALSE
[16:03:15.296] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:15.296] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:15.310] Chunk #1 of 2 ... DONE
[16:03:15.310] Chunk #2 of 2 ...
[16:03:15.310]  - Finding globals in 'X' for chunk #2 ...
[16:03:15.310] getGlobalsAndPackages() ...
[16:03:15.310] Searching for globals...
[16:03:15.311] 
[16:03:15.311] Searching for globals ... DONE
[16:03:15.311] - globals: [0] <none>
[16:03:15.312] getGlobalsAndPackages() ... DONE
[16:03:15.312]    + additional globals found: [n=0] 
[16:03:15.312]    + additional namespaces needed: [n=0] 
[16:03:15.312]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:15.312]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:15.312]  - seeds: <none>
[16:03:15.312]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.313] getGlobalsAndPackages() ...
[16:03:15.313] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.313] Resolving globals: FALSE
[16:03:15.313] Tweak future expression to call with '...' arguments ...
[16:03:15.313] {
[16:03:15.313]     do.call(function(...) {
[16:03:15.313]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.313]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:15.313]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.313]             on.exit(options(oopts), add = TRUE)
[16:03:15.313]         }
[16:03:15.313]         {
[16:03:15.313]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:15.313]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.313]                 ...future.FUN(...future.X_jj, ...)
[16:03:15.313]             })
[16:03:15.313]         }
[16:03:15.313]     }, args = future.call.arguments)
[16:03:15.313] }
[16:03:15.314] Tweak future expression to call with '...' arguments ... DONE
[16:03:15.314] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:15.315] - packages: [1] ‘future.apply’
[16:03:15.315] getGlobalsAndPackages() ... DONE
[16:03:15.315] run() for ‘Future’ ...
[16:03:15.315] - state: ‘created’
[16:03:15.316] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:15.320] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:15.320] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:15.321]   - Field: ‘label’
[16:03:15.321]   - Field: ‘local’
[16:03:15.321]   - Field: ‘owner’
[16:03:15.321]   - Field: ‘envir’
[16:03:15.321]   - Field: ‘workers’
[16:03:15.321]   - Field: ‘packages’
[16:03:15.321]   - Field: ‘gc’
[16:03:15.322]   - Field: ‘job’
[16:03:15.322]   - Field: ‘conditions’
[16:03:15.322]   - Field: ‘expr’
[16:03:15.322]   - Field: ‘uuid’
[16:03:15.322]   - Field: ‘seed’
[16:03:15.322]   - Field: ‘version’
[16:03:15.323]   - Field: ‘result’
[16:03:15.323]   - Field: ‘asynchronous’
[16:03:15.323]   - Field: ‘calls’
[16:03:15.323]   - Field: ‘globals’
[16:03:15.323]   - Field: ‘stdout’
[16:03:15.323]   - Field: ‘earlySignal’
[16:03:15.323]   - Field: ‘lazy’
[16:03:15.324]   - Field: ‘state’
[16:03:15.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:15.324] - Launch lazy future ...
[16:03:15.324] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:15.325] Packages needed by future strategies (n = 0): <none>
[16:03:15.328] {
[16:03:15.328]     {
[16:03:15.328]         {
[16:03:15.328]             ...future.startTime <- base::Sys.time()
[16:03:15.328]             {
[16:03:15.328]                 {
[16:03:15.328]                   {
[16:03:15.328]                     {
[16:03:15.328]                       {
[16:03:15.328]                         base::local({
[16:03:15.328]                           has_future <- base::requireNamespace("future", 
[16:03:15.328]                             quietly = TRUE)
[16:03:15.328]                           if (has_future) {
[16:03:15.328]                             ns <- base::getNamespace("future")
[16:03:15.328]                             version <- ns[[".package"]][["version"]]
[16:03:15.328]                             if (is.null(version)) 
[16:03:15.328]                               version <- utils::packageVersion("future")
[16:03:15.328]                           }
[16:03:15.328]                           else {
[16:03:15.328]                             version <- NULL
[16:03:15.328]                           }
[16:03:15.328]                           if (!has_future || version < "1.8.0") {
[16:03:15.328]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:15.328]                               "", base::R.version$version.string), 
[16:03:15.328]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:15.328]                                 base::R.version$platform, 8 * 
[16:03:15.328]                                   base::.Machine$sizeof.pointer), 
[16:03:15.328]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:15.328]                                 "release", "version")], collapse = " "), 
[16:03:15.328]                               hostname = base::Sys.info()[["nodename"]])
[16:03:15.328]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:15.328]                               info)
[16:03:15.328]                             info <- base::paste(info, collapse = "; ")
[16:03:15.328]                             if (!has_future) {
[16:03:15.328]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:15.328]                                 info)
[16:03:15.328]                             }
[16:03:15.328]                             else {
[16:03:15.328]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:15.328]                                 info, version)
[16:03:15.328]                             }
[16:03:15.328]                             base::stop(msg)
[16:03:15.328]                           }
[16:03:15.328]                         })
[16:03:15.328]                       }
[16:03:15.328]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:15.328]                       base::options(mc.cores = 1L)
[16:03:15.328]                     }
[16:03:15.328]                     base::local({
[16:03:15.328]                       for (pkg in "future.apply") {
[16:03:15.328]                         base::loadNamespace(pkg)
[16:03:15.328]                         base::library(pkg, character.only = TRUE)
[16:03:15.328]                       }
[16:03:15.328]                     })
[16:03:15.328]                   }
[16:03:15.328]                   options(future.plan = NULL)
[16:03:15.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:15.328]                 }
[16:03:15.328]                 ...future.workdir <- getwd()
[16:03:15.328]             }
[16:03:15.328]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:15.328]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:15.328]         }
[16:03:15.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:15.328]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:15.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:15.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:15.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:15.328]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:15.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:15.328]             base::names(...future.oldOptions))
[16:03:15.328]     }
[16:03:15.328]     if (FALSE) {
[16:03:15.328]     }
[16:03:15.328]     else {
[16:03:15.328]         if (TRUE) {
[16:03:15.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:15.328]                 open = "w")
[16:03:15.328]         }
[16:03:15.328]         else {
[16:03:15.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:15.328]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:15.328]         }
[16:03:15.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:15.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:15.328]             base::sink(type = "output", split = FALSE)
[16:03:15.328]             base::close(...future.stdout)
[16:03:15.328]         }, add = TRUE)
[16:03:15.328]     }
[16:03:15.328]     ...future.frame <- base::sys.nframe()
[16:03:15.328]     ...future.conditions <- base::list()
[16:03:15.328]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:15.328]     if (FALSE) {
[16:03:15.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:15.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:15.328]     }
[16:03:15.328]     ...future.result <- base::tryCatch({
[16:03:15.328]         base::withCallingHandlers({
[16:03:15.328]             ...future.value <- base::withVisible(base::local({
[16:03:15.328]                 withCallingHandlers({
[16:03:15.328]                   {
[16:03:15.328]                     do.call(function(...) {
[16:03:15.328]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.328]                       if (!identical(...future.globals.maxSize.org, 
[16:03:15.328]                         ...future.globals.maxSize)) {
[16:03:15.328]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.328]                         on.exit(options(oopts), add = TRUE)
[16:03:15.328]                       }
[16:03:15.328]                       {
[16:03:15.328]                         lapply(seq_along(...future.elements_ii), 
[16:03:15.328]                           FUN = function(jj) {
[16:03:15.328]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.328]                             ...future.FUN(...future.X_jj, ...)
[16:03:15.328]                           })
[16:03:15.328]                       }
[16:03:15.328]                     }, args = future.call.arguments)
[16:03:15.328]                   }
[16:03:15.328]                 }, immediateCondition = function(cond) {
[16:03:15.328]                   save_rds <- function (object, pathname, ...) 
[16:03:15.328]                   {
[16:03:15.328]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:15.328]                     if (file_test("-f", pathname_tmp)) {
[16:03:15.328]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.328]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:15.328]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.328]                         fi_tmp[["mtime"]])
[16:03:15.328]                     }
[16:03:15.328]                     tryCatch({
[16:03:15.328]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:15.328]                     }, error = function(ex) {
[16:03:15.328]                       msg <- conditionMessage(ex)
[16:03:15.328]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.328]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:15.328]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.328]                         fi_tmp[["mtime"]], msg)
[16:03:15.328]                       ex$message <- msg
[16:03:15.328]                       stop(ex)
[16:03:15.328]                     })
[16:03:15.328]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:15.328]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:15.328]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:15.328]                       fi_tmp <- file.info(pathname_tmp)
[16:03:15.328]                       fi <- file.info(pathname)
[16:03:15.328]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:15.328]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:15.328]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:15.328]                         fi[["size"]], fi[["mtime"]])
[16:03:15.328]                       stop(msg)
[16:03:15.328]                     }
[16:03:15.328]                     invisible(pathname)
[16:03:15.328]                   }
[16:03:15.328]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:15.328]                     rootPath = tempdir()) 
[16:03:15.328]                   {
[16:03:15.328]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:15.328]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:15.328]                       tmpdir = path, fileext = ".rds")
[16:03:15.328]                     save_rds(obj, file)
[16:03:15.328]                   }
[16:03:15.328]                   saveImmediateCondition(cond, path = "/tmp/RtmpAVhhkv/.future/immediateConditions")
[16:03:15.328]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.328]                   {
[16:03:15.328]                     inherits <- base::inherits
[16:03:15.328]                     invokeRestart <- base::invokeRestart
[16:03:15.328]                     is.null <- base::is.null
[16:03:15.328]                     muffled <- FALSE
[16:03:15.328]                     if (inherits(cond, "message")) {
[16:03:15.328]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:15.328]                       if (muffled) 
[16:03:15.328]                         invokeRestart("muffleMessage")
[16:03:15.328]                     }
[16:03:15.328]                     else if (inherits(cond, "warning")) {
[16:03:15.328]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:15.328]                       if (muffled) 
[16:03:15.328]                         invokeRestart("muffleWarning")
[16:03:15.328]                     }
[16:03:15.328]                     else if (inherits(cond, "condition")) {
[16:03:15.328]                       if (!is.null(pattern)) {
[16:03:15.328]                         computeRestarts <- base::computeRestarts
[16:03:15.328]                         grepl <- base::grepl
[16:03:15.328]                         restarts <- computeRestarts(cond)
[16:03:15.328]                         for (restart in restarts) {
[16:03:15.328]                           name <- restart$name
[16:03:15.328]                           if (is.null(name)) 
[16:03:15.328]                             next
[16:03:15.328]                           if (!grepl(pattern, name)) 
[16:03:15.328]                             next
[16:03:15.328]                           invokeRestart(restart)
[16:03:15.328]                           muffled <- TRUE
[16:03:15.328]                           break
[16:03:15.328]                         }
[16:03:15.328]                       }
[16:03:15.328]                     }
[16:03:15.328]                     invisible(muffled)
[16:03:15.328]                   }
[16:03:15.328]                   muffleCondition(cond)
[16:03:15.328]                 })
[16:03:15.328]             }))
[16:03:15.328]             future::FutureResult(value = ...future.value$value, 
[16:03:15.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.328]                   ...future.rng), globalenv = if (FALSE) 
[16:03:15.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:15.328]                     ...future.globalenv.names))
[16:03:15.328]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:15.328]         }, condition = base::local({
[16:03:15.328]             c <- base::c
[16:03:15.328]             inherits <- base::inherits
[16:03:15.328]             invokeRestart <- base::invokeRestart
[16:03:15.328]             length <- base::length
[16:03:15.328]             list <- base::list
[16:03:15.328]             seq.int <- base::seq.int
[16:03:15.328]             signalCondition <- base::signalCondition
[16:03:15.328]             sys.calls <- base::sys.calls
[16:03:15.328]             `[[` <- base::`[[`
[16:03:15.328]             `+` <- base::`+`
[16:03:15.328]             `<<-` <- base::`<<-`
[16:03:15.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:15.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:15.328]                   3L)]
[16:03:15.328]             }
[16:03:15.328]             function(cond) {
[16:03:15.328]                 is_error <- inherits(cond, "error")
[16:03:15.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:15.328]                   NULL)
[16:03:15.328]                 if (is_error) {
[16:03:15.328]                   sessionInformation <- function() {
[16:03:15.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:15.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:15.328]                       search = base::search(), system = base::Sys.info())
[16:03:15.328]                   }
[16:03:15.328]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:15.328]                     cond$call), session = sessionInformation(), 
[16:03:15.328]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:15.328]                   signalCondition(cond)
[16:03:15.328]                 }
[16:03:15.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:15.328]                 "immediateCondition"))) {
[16:03:15.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:15.328]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:15.328]                   if (TRUE && !signal) {
[16:03:15.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.328]                     {
[16:03:15.328]                       inherits <- base::inherits
[16:03:15.328]                       invokeRestart <- base::invokeRestart
[16:03:15.328]                       is.null <- base::is.null
[16:03:15.328]                       muffled <- FALSE
[16:03:15.328]                       if (inherits(cond, "message")) {
[16:03:15.328]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.328]                         if (muffled) 
[16:03:15.328]                           invokeRestart("muffleMessage")
[16:03:15.328]                       }
[16:03:15.328]                       else if (inherits(cond, "warning")) {
[16:03:15.328]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.328]                         if (muffled) 
[16:03:15.328]                           invokeRestart("muffleWarning")
[16:03:15.328]                       }
[16:03:15.328]                       else if (inherits(cond, "condition")) {
[16:03:15.328]                         if (!is.null(pattern)) {
[16:03:15.328]                           computeRestarts <- base::computeRestarts
[16:03:15.328]                           grepl <- base::grepl
[16:03:15.328]                           restarts <- computeRestarts(cond)
[16:03:15.328]                           for (restart in restarts) {
[16:03:15.328]                             name <- restart$name
[16:03:15.328]                             if (is.null(name)) 
[16:03:15.328]                               next
[16:03:15.328]                             if (!grepl(pattern, name)) 
[16:03:15.328]                               next
[16:03:15.328]                             invokeRestart(restart)
[16:03:15.328]                             muffled <- TRUE
[16:03:15.328]                             break
[16:03:15.328]                           }
[16:03:15.328]                         }
[16:03:15.328]                       }
[16:03:15.328]                       invisible(muffled)
[16:03:15.328]                     }
[16:03:15.328]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.328]                   }
[16:03:15.328]                 }
[16:03:15.328]                 else {
[16:03:15.328]                   if (TRUE) {
[16:03:15.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.328]                     {
[16:03:15.328]                       inherits <- base::inherits
[16:03:15.328]                       invokeRestart <- base::invokeRestart
[16:03:15.328]                       is.null <- base::is.null
[16:03:15.328]                       muffled <- FALSE
[16:03:15.328]                       if (inherits(cond, "message")) {
[16:03:15.328]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.328]                         if (muffled) 
[16:03:15.328]                           invokeRestart("muffleMessage")
[16:03:15.328]                       }
[16:03:15.328]                       else if (inherits(cond, "warning")) {
[16:03:15.328]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.328]                         if (muffled) 
[16:03:15.328]                           invokeRestart("muffleWarning")
[16:03:15.328]                       }
[16:03:15.328]                       else if (inherits(cond, "condition")) {
[16:03:15.328]                         if (!is.null(pattern)) {
[16:03:15.328]                           computeRestarts <- base::computeRestarts
[16:03:15.328]                           grepl <- base::grepl
[16:03:15.328]                           restarts <- computeRestarts(cond)
[16:03:15.328]                           for (restart in restarts) {
[16:03:15.328]                             name <- restart$name
[16:03:15.328]                             if (is.null(name)) 
[16:03:15.328]                               next
[16:03:15.328]                             if (!grepl(pattern, name)) 
[16:03:15.328]                               next
[16:03:15.328]                             invokeRestart(restart)
[16:03:15.328]                             muffled <- TRUE
[16:03:15.328]                             break
[16:03:15.328]                           }
[16:03:15.328]                         }
[16:03:15.328]                       }
[16:03:15.328]                       invisible(muffled)
[16:03:15.328]                     }
[16:03:15.328]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.328]                   }
[16:03:15.328]                 }
[16:03:15.328]             }
[16:03:15.328]         }))
[16:03:15.328]     }, error = function(ex) {
[16:03:15.328]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:15.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.328]                 ...future.rng), started = ...future.startTime, 
[16:03:15.328]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:15.328]             version = "1.8"), class = "FutureResult")
[16:03:15.328]     }, finally = {
[16:03:15.328]         if (!identical(...future.workdir, getwd())) 
[16:03:15.328]             setwd(...future.workdir)
[16:03:15.328]         {
[16:03:15.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:15.328]                 ...future.oldOptions$nwarnings <- NULL
[16:03:15.328]             }
[16:03:15.328]             base::options(...future.oldOptions)
[16:03:15.328]             if (.Platform$OS.type == "windows") {
[16:03:15.328]                 old_names <- names(...future.oldEnvVars)
[16:03:15.328]                 envs <- base::Sys.getenv()
[16:03:15.328]                 names <- names(envs)
[16:03:15.328]                 common <- intersect(names, old_names)
[16:03:15.328]                 added <- setdiff(names, old_names)
[16:03:15.328]                 removed <- setdiff(old_names, names)
[16:03:15.328]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:15.328]                   envs[common]]
[16:03:15.328]                 NAMES <- toupper(changed)
[16:03:15.328]                 args <- list()
[16:03:15.328]                 for (kk in seq_along(NAMES)) {
[16:03:15.328]                   name <- changed[[kk]]
[16:03:15.328]                   NAME <- NAMES[[kk]]
[16:03:15.328]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.328]                     next
[16:03:15.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.328]                 }
[16:03:15.328]                 NAMES <- toupper(added)
[16:03:15.328]                 for (kk in seq_along(NAMES)) {
[16:03:15.328]                   name <- added[[kk]]
[16:03:15.328]                   NAME <- NAMES[[kk]]
[16:03:15.328]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.328]                     next
[16:03:15.328]                   args[[name]] <- ""
[16:03:15.328]                 }
[16:03:15.328]                 NAMES <- toupper(removed)
[16:03:15.328]                 for (kk in seq_along(NAMES)) {
[16:03:15.328]                   name <- removed[[kk]]
[16:03:15.328]                   NAME <- NAMES[[kk]]
[16:03:15.328]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.328]                     next
[16:03:15.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.328]                 }
[16:03:15.328]                 if (length(args) > 0) 
[16:03:15.328]                   base::do.call(base::Sys.setenv, args = args)
[16:03:15.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:15.328]             }
[16:03:15.328]             else {
[16:03:15.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:15.328]             }
[16:03:15.328]             {
[16:03:15.328]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:15.328]                   0L) {
[16:03:15.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:15.328]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:15.328]                   base::options(opts)
[16:03:15.328]                 }
[16:03:15.328]                 {
[16:03:15.328]                   {
[16:03:15.328]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:15.328]                     NULL
[16:03:15.328]                   }
[16:03:15.328]                   options(future.plan = NULL)
[16:03:15.328]                   if (is.na(NA_character_)) 
[16:03:15.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:15.328]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:15.328]                     envir = parent.frame()) 
[16:03:15.328]                   {
[16:03:15.328]                     default_workers <- missing(workers)
[16:03:15.328]                     if (is.function(workers)) 
[16:03:15.328]                       workers <- workers()
[16:03:15.328]                     workers <- structure(as.integer(workers), 
[16:03:15.328]                       class = class(workers))
[16:03:15.328]                     stop_if_not(is.finite(workers), workers >= 
[16:03:15.328]                       1L)
[16:03:15.328]                     if ((workers == 1L && !inherits(workers, 
[16:03:15.328]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:15.328]                       if (default_workers) 
[16:03:15.328]                         supportsMulticore(warn = TRUE)
[16:03:15.328]                       return(sequential(..., envir = envir))
[16:03:15.328]                     }
[16:03:15.328]                     oopts <- options(mc.cores = workers)
[16:03:15.328]                     on.exit(options(oopts))
[16:03:15.328]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:15.328]                       envir = envir)
[16:03:15.328]                     if (!future$lazy) 
[16:03:15.328]                       future <- run(future)
[16:03:15.328]                     invisible(future)
[16:03:15.328]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:15.328]                 }
[16:03:15.328]             }
[16:03:15.328]         }
[16:03:15.328]     })
[16:03:15.328]     if (TRUE) {
[16:03:15.328]         base::sink(type = "output", split = FALSE)
[16:03:15.328]         if (TRUE) {
[16:03:15.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:15.328]         }
[16:03:15.328]         else {
[16:03:15.328]             ...future.result["stdout"] <- base::list(NULL)
[16:03:15.328]         }
[16:03:15.328]         base::close(...future.stdout)
[16:03:15.328]         ...future.stdout <- NULL
[16:03:15.328]     }
[16:03:15.328]     ...future.result$conditions <- ...future.conditions
[16:03:15.328]     ...future.result$finished <- base::Sys.time()
[16:03:15.328]     ...future.result
[16:03:15.328] }
[16:03:15.332] assign_globals() ...
[16:03:15.332] List of 11
[16:03:15.332]  $ ...future.FUN            :function (x, ...)  
[16:03:15.332]  $ x_FUN                    :function (x)  
[16:03:15.332]  $ times                    : int 2
[16:03:15.332]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:15.332]  $ stop_if_not              :function (...)  
[16:03:15.332]  $ dim                      : NULL
[16:03:15.332]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:03:15.332]  $ future.call.arguments    : list()
[16:03:15.332]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:15.332]  $ ...future.elements_ii    :List of 2
[16:03:15.332]   ..$ : int 2
[16:03:15.332]   ..$ : int 3
[16:03:15.332]  $ ...future.seeds_ii       : NULL
[16:03:15.332]  $ ...future.globals.maxSize: NULL
[16:03:15.332]  - attr(*, "where")=List of 11
[16:03:15.332]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:15.332]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:03:15.332]   ..$ times                    :<environment: R_EmptyEnv> 
[16:03:15.332]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:03:15.332]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:03:15.332]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:03:15.332]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:03:15.332]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:15.332]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:15.332]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:15.332]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:15.332]  - attr(*, "resolved")= logi FALSE
[16:03:15.332]  - attr(*, "total_size")= num 95128
[16:03:15.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:15.332]  - attr(*, "already-done")= logi TRUE
[16:03:15.345] - copied ‘...future.FUN’ to environment
[16:03:15.345] - copied ‘x_FUN’ to environment
[16:03:15.345] - copied ‘times’ to environment
[16:03:15.345] - copied ‘stopf’ to environment
[16:03:15.345] - copied ‘stop_if_not’ to environment
[16:03:15.345] - copied ‘dim’ to environment
[16:03:15.345] - copied ‘valid_types’ to environment
[16:03:15.346] - copied ‘future.call.arguments’ to environment
[16:03:15.346] - copied ‘...future.elements_ii’ to environment
[16:03:15.346] - copied ‘...future.seeds_ii’ to environment
[16:03:15.346] - copied ‘...future.globals.maxSize’ to environment
[16:03:15.346] assign_globals() ... done
[16:03:15.346] requestCore(): workers = 2
[16:03:15.348] MulticoreFuture started
[16:03:15.349] - Launch lazy future ... done
[16:03:15.349] run() for ‘MulticoreFuture’ ... done
[16:03:15.349] Created future:
[16:03:15.350] plan(): Setting new future strategy stack:
[16:03:15.350] List of future strategies:
[16:03:15.350] 1. sequential:
[16:03:15.350]    - args: function (..., envir = parent.frame())
[16:03:15.350]    - tweaked: FALSE
[16:03:15.350]    - call: NULL
[16:03:15.351] plan(): nbrOfWorkers() = 1
[16:03:15.353] plan(): Setting new future strategy stack:
[16:03:15.353] List of future strategies:
[16:03:15.353] 1. multicore:
[16:03:15.353]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:15.353]    - tweaked: FALSE
[16:03:15.353]    - call: plan(strategy)
[16:03:15.359] plan(): nbrOfWorkers() = 2
[16:03:15.350] MulticoreFuture:
[16:03:15.350] Label: ‘future_vapply-2’
[16:03:15.350] Expression:
[16:03:15.350] {
[16:03:15.350]     do.call(function(...) {
[16:03:15.350]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:15.350]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:15.350]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:15.350]             on.exit(options(oopts), add = TRUE)
[16:03:15.350]         }
[16:03:15.350]         {
[16:03:15.350]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:15.350]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:15.350]                 ...future.FUN(...future.X_jj, ...)
[16:03:15.350]             })
[16:03:15.350]         }
[16:03:15.350]     }, args = future.call.arguments)
[16:03:15.350] }
[16:03:15.350] Lazy evaluation: FALSE
[16:03:15.350] Asynchronous evaluation: TRUE
[16:03:15.350] Local evaluation: TRUE
[16:03:15.350] Environment: R_GlobalEnv
[16:03:15.350] Capture standard output: TRUE
[16:03:15.350] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:15.350] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:15.350] Packages: 1 packages (‘future.apply’)
[16:03:15.350] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:15.350] Resolved: FALSE
[16:03:15.350] Value: <not collected>
[16:03:15.350] Conditions captured: <none>
[16:03:15.350] Early signaling: FALSE
[16:03:15.350] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:15.350] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:15.363] Chunk #2 of 2 ... DONE
[16:03:15.363] Launching 2 futures (chunks) ... DONE
[16:03:15.363] Resolving 2 futures (chunks) ...
[16:03:15.363] resolve() on list ...
[16:03:15.364]  recursive: 0
[16:03:15.364]  length: 2
[16:03:15.364] 
[16:03:15.364] Future #1
[16:03:15.364] result() for MulticoreFuture ...
[16:03:15.378] result() for MulticoreFuture ...
[16:03:15.378] result() for MulticoreFuture ... done
[16:03:15.378] signalConditions() ...
[16:03:15.378]  - include = ‘immediateCondition’
[16:03:15.378]  - exclude = 
[16:03:15.379]  - resignal = FALSE
[16:03:15.379]  - Number of conditions: 1
[16:03:15.379] signalConditions() ... done
[16:03:15.379] result() for MulticoreFuture ... done
[16:03:15.379] result() for MulticoreFuture ...
[16:03:15.380] result() for MulticoreFuture ... done
[16:03:15.380] signalConditions() ...
[16:03:15.380]  - include = ‘immediateCondition’
[16:03:15.380]  - exclude = 
[16:03:15.380]  - resignal = FALSE
[16:03:15.380]  - Number of conditions: 1
[16:03:15.381] signalConditions() ... done
[16:03:15.381] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:15.381] - nx: 2
[16:03:15.381] - relay: TRUE
[16:03:15.381] - stdout: TRUE
[16:03:15.382] - signal: TRUE
[16:03:15.382] - resignal: FALSE
[16:03:15.382] - force: TRUE
[16:03:15.382] - relayed: [n=2] FALSE, FALSE
[16:03:15.382] - queued futures: [n=2] FALSE, FALSE
[16:03:15.382]  - until=1
[16:03:15.382]  - relaying element #1
[16:03:15.383] result() for MulticoreFuture ...
[16:03:15.383] result() for MulticoreFuture ... done
[16:03:15.383] result() for MulticoreFuture ...
[16:03:15.383] result() for MulticoreFuture ... done
[16:03:15.383] signalConditions() ...
[16:03:15.383]  - include = ‘immediateCondition’
[16:03:15.384]  - exclude = 
[16:03:15.384]  - resignal = FALSE
[16:03:15.384]  - Number of conditions: 1
[16:03:15.384] signalConditions() ... done
[16:03:15.384] result() for MulticoreFuture ...
[16:03:15.385] result() for MulticoreFuture ... done
[16:03:15.385] signalConditions() ...
[16:03:15.385]  - include = ‘immediateCondition’
[16:03:15.385]  - exclude = 
[16:03:15.385]  - resignal = FALSE
[16:03:15.385]  - Number of conditions: 1
[16:03:15.386] signalConditions() ... done
[16:03:15.386] result() for MulticoreFuture ...
[16:03:15.386] result() for MulticoreFuture ... done
[16:03:15.386] signalConditions() ...
[16:03:15.386]  - include = ‘condition’
[16:03:15.386]  - exclude = ‘immediateCondition’
[16:03:15.387]  - resignal = TRUE
[16:03:15.387]  - Number of conditions: 1
[16:03:15.387]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:03:15.387] signalConditions() ... done
[16:03:15.387] - relayed: [n=2] FALSE, FALSE
[16:03:15.388] - queued futures: [n=2] TRUE, FALSE
[16:03:15.388] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:15.388] plan(): Setting new future strategy stack:
[16:03:15.388] List of future strategies:
[16:03:15.388] 1. sequential:
[16:03:15.388]    - args: function (..., envir = parent.frame())
[16:03:15.388]    - tweaked: FALSE
[16:03:15.388]    - call: plan(sequential)
[16:03:15.389] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:03:15.390] plan(): Setting new future strategy stack:
[16:03:15.390] List of future strategies:
[16:03:15.390] 1. multisession:
[16:03:15.390]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:15.390]    - tweaked: FALSE
[16:03:15.390]    - call: plan(strategy)
[16:03:15.390] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:03:15.390] multisession:
[16:03:15.390] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:15.390] - tweaked: FALSE
[16:03:15.390] - call: plan(strategy)
[16:03:15.397] getGlobalsAndPackages() ...
[16:03:15.398] Not searching for globals
[16:03:15.398] - globals: [0] <none>
[16:03:15.398] getGlobalsAndPackages() ... DONE
[16:03:15.398] [local output] makeClusterPSOCK() ...
[16:03:15.476] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:03:15.477] [local output] Base port: 11402
[16:03:15.477] [local output] Getting setup options for 2 cluster nodes ...
[16:03:15.478] [local output]  - Node 1 of 2 ...
[16:03:15.478] [local output] localMachine=TRUE => revtunnel=FALSE

[16:03:15.479] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpAVhhkv/worker.rank=1.parallelly.parent=77625.12f393a7947ee.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpAVhhkv/worker.rank=1.parallelly.parent=77625.12f393a7947ee.pid")'’
[16:03:15.665] - Possible to infer worker's PID: TRUE
[16:03:15.666] [local output] Rscript port: 11402

[16:03:15.666] [local output]  - Node 2 of 2 ...
[16:03:15.666] [local output] localMachine=TRUE => revtunnel=FALSE

[16:03:15.667] [local output] Rscript port: 11402

[16:03:15.667] [local output] Getting setup options for 2 cluster nodes ... done
[16:03:15.667] [local output]  - Parallel setup requested for some PSOCK nodes
[16:03:15.668] [local output] Setting up PSOCK nodes in parallel
[16:03:15.668] List of 36
[16:03:15.668]  $ worker          : chr "localhost"
[16:03:15.668]   ..- attr(*, "localhost")= logi TRUE
[16:03:15.668]  $ master          : chr "localhost"
[16:03:15.668]  $ port            : int 11402
[16:03:15.668]  $ connectTimeout  : num 120
[16:03:15.668]  $ timeout         : num 2592000
[16:03:15.668]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:03:15.668]  $ homogeneous     : logi TRUE
[16:03:15.668]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:03:15.668]  $ rscript_envs    : NULL
[16:03:15.668]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:03:15.668]  $ rscript_startup : NULL
[16:03:15.668]  $ rscript_sh      : chr "sh"
[16:03:15.668]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:03:15.668]  $ methods         : logi TRUE
[16:03:15.668]  $ socketOptions   : chr "no-delay"
[16:03:15.668]  $ useXDR          : logi FALSE
[16:03:15.668]  $ outfile         : chr "/dev/null"
[16:03:15.668]  $ renice          : int NA
[16:03:15.668]  $ rshcmd          : NULL
[16:03:15.668]  $ user            : chr(0) 
[16:03:15.668]  $ revtunnel       : logi FALSE
[16:03:15.668]  $ rshlogfile      : NULL
[16:03:15.668]  $ rshopts         : chr(0) 
[16:03:15.668]  $ rank            : int 1
[16:03:15.668]  $ manual          : logi FALSE
[16:03:15.668]  $ dryrun          : logi FALSE
[16:03:15.668]  $ quiet           : logi FALSE
[16:03:15.668]  $ setup_strategy  : chr "parallel"
[16:03:15.668]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:03:15.668]  $ pidfile         : chr "/tmp/RtmpAVhhkv/worker.rank=1.parallelly.parent=77625.12f393a7947ee.pid"
[16:03:15.668]  $ rshcmd_label    : NULL
[16:03:15.668]  $ rsh_call        : NULL
[16:03:15.668]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:03:15.668]  $ localMachine    : logi TRUE
[16:03:15.668]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:03:15.668]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:03:15.668]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:03:15.668]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:03:15.668]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:03:15.668]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:03:15.668]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:03:15.668]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:03:15.668]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:03:15.668]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:03:15.668]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:03:15.668]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:03:15.668]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:03:15.668]  $ arguments       :List of 28
[16:03:15.668]   ..$ worker          : chr "localhost"
[16:03:15.668]   ..$ master          : NULL
[16:03:15.668]   ..$ port            : int 11402
[16:03:15.668]   ..$ connectTimeout  : num 120
[16:03:15.668]   ..$ timeout         : num 2592000
[16:03:15.668]   ..$ rscript         : NULL
[16:03:15.668]   ..$ homogeneous     : NULL
[16:03:15.668]   ..$ rscript_args    : NULL
[16:03:15.668]   ..$ rscript_envs    : NULL
[16:03:15.668]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:03:15.668]   ..$ rscript_startup : NULL
[16:03:15.668]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:03:15.668]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:03:15.668]   ..$ methods         : logi TRUE
[16:03:15.668]   ..$ socketOptions   : chr "no-delay"
[16:03:15.668]   ..$ useXDR          : logi FALSE
[16:03:15.668]   ..$ outfile         : chr "/dev/null"
[16:03:15.668]   ..$ renice          : int NA
[16:03:15.668]   ..$ rshcmd          : NULL
[16:03:15.668]   ..$ user            : NULL
[16:03:15.668]   ..$ revtunnel       : logi NA
[16:03:15.668]   ..$ rshlogfile      : NULL
[16:03:15.668]   ..$ rshopts         : NULL
[16:03:15.668]   ..$ rank            : int 1
[16:03:15.668]   ..$ manual          : logi FALSE
[16:03:15.668]   ..$ dryrun          : logi FALSE
[16:03:15.668]   ..$ quiet           : logi FALSE
[16:03:15.668]   ..$ setup_strategy  : chr "parallel"
[16:03:15.668]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:03:15.686] [local output] System call to launch all workers:
[16:03:15.687] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpAVhhkv/worker.rank=1.parallelly.parent=77625.12f393a7947ee.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11402 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:03:15.687] [local output] Starting PSOCK main server
[16:03:15.692] [local output] Workers launched
[16:03:15.692] [local output] Waiting for workers to connect back
[16:03:15.693]  - [local output] 0 workers out of 2 ready
[16:03:15.934]  - [local output] 0 workers out of 2 ready
[16:03:15.934]  - [local output] 1 workers out of 2 ready
[16:03:15.939]  - [local output] 1 workers out of 2 ready
[16:03:15.939]  - [local output] 2 workers out of 2 ready
[16:03:15.939] [local output] Launching of workers completed
[16:03:15.939] [local output] Collecting session information from workers
[16:03:15.940] [local output]  - Worker #1 of 2
[16:03:15.941] [local output]  - Worker #2 of 2
[16:03:15.941] [local output] makeClusterPSOCK() ... done
[16:03:15.952] Packages needed by the future expression (n = 0): <none>
[16:03:15.952] Packages needed by future strategies (n = 0): <none>
[16:03:15.952] {
[16:03:15.952]     {
[16:03:15.952]         {
[16:03:15.952]             ...future.startTime <- base::Sys.time()
[16:03:15.952]             {
[16:03:15.952]                 {
[16:03:15.952]                   {
[16:03:15.952]                     {
[16:03:15.952]                       base::local({
[16:03:15.952]                         has_future <- base::requireNamespace("future", 
[16:03:15.952]                           quietly = TRUE)
[16:03:15.952]                         if (has_future) {
[16:03:15.952]                           ns <- base::getNamespace("future")
[16:03:15.952]                           version <- ns[[".package"]][["version"]]
[16:03:15.952]                           if (is.null(version)) 
[16:03:15.952]                             version <- utils::packageVersion("future")
[16:03:15.952]                         }
[16:03:15.952]                         else {
[16:03:15.952]                           version <- NULL
[16:03:15.952]                         }
[16:03:15.952]                         if (!has_future || version < "1.8.0") {
[16:03:15.952]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:15.952]                             "", base::R.version$version.string), 
[16:03:15.952]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:15.952]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:15.952]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:15.952]                               "release", "version")], collapse = " "), 
[16:03:15.952]                             hostname = base::Sys.info()[["nodename"]])
[16:03:15.952]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:15.952]                             info)
[16:03:15.952]                           info <- base::paste(info, collapse = "; ")
[16:03:15.952]                           if (!has_future) {
[16:03:15.952]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:15.952]                               info)
[16:03:15.952]                           }
[16:03:15.952]                           else {
[16:03:15.952]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:15.952]                               info, version)
[16:03:15.952]                           }
[16:03:15.952]                           base::stop(msg)
[16:03:15.952]                         }
[16:03:15.952]                       })
[16:03:15.952]                     }
[16:03:15.952]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:15.952]                     base::options(mc.cores = 1L)
[16:03:15.952]                   }
[16:03:15.952]                   options(future.plan = NULL)
[16:03:15.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:15.952]                 }
[16:03:15.952]                 ...future.workdir <- getwd()
[16:03:15.952]             }
[16:03:15.952]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:15.952]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:15.952]         }
[16:03:15.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:15.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:15.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:15.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:15.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:15.952]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:15.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:15.952]             base::names(...future.oldOptions))
[16:03:15.952]     }
[16:03:15.952]     if (FALSE) {
[16:03:15.952]     }
[16:03:15.952]     else {
[16:03:15.952]         if (TRUE) {
[16:03:15.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:15.952]                 open = "w")
[16:03:15.952]         }
[16:03:15.952]         else {
[16:03:15.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:15.952]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:15.952]         }
[16:03:15.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:15.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:15.952]             base::sink(type = "output", split = FALSE)
[16:03:15.952]             base::close(...future.stdout)
[16:03:15.952]         }, add = TRUE)
[16:03:15.952]     }
[16:03:15.952]     ...future.frame <- base::sys.nframe()
[16:03:15.952]     ...future.conditions <- base::list()
[16:03:15.952]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:15.952]     if (FALSE) {
[16:03:15.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:15.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:15.952]     }
[16:03:15.952]     ...future.result <- base::tryCatch({
[16:03:15.952]         base::withCallingHandlers({
[16:03:15.952]             ...future.value <- base::withVisible(base::local({
[16:03:15.952]                 ...future.makeSendCondition <- base::local({
[16:03:15.952]                   sendCondition <- NULL
[16:03:15.952]                   function(frame = 1L) {
[16:03:15.952]                     if (is.function(sendCondition)) 
[16:03:15.952]                       return(sendCondition)
[16:03:15.952]                     ns <- getNamespace("parallel")
[16:03:15.952]                     if (exists("sendData", mode = "function", 
[16:03:15.952]                       envir = ns)) {
[16:03:15.952]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:15.952]                         envir = ns)
[16:03:15.952]                       envir <- sys.frame(frame)
[16:03:15.952]                       master <- NULL
[16:03:15.952]                       while (!identical(envir, .GlobalEnv) && 
[16:03:15.952]                         !identical(envir, emptyenv())) {
[16:03:15.952]                         if (exists("master", mode = "list", envir = envir, 
[16:03:15.952]                           inherits = FALSE)) {
[16:03:15.952]                           master <- get("master", mode = "list", 
[16:03:15.952]                             envir = envir, inherits = FALSE)
[16:03:15.952]                           if (inherits(master, c("SOCKnode", 
[16:03:15.952]                             "SOCK0node"))) {
[16:03:15.952]                             sendCondition <<- function(cond) {
[16:03:15.952]                               data <- list(type = "VALUE", value = cond, 
[16:03:15.952]                                 success = TRUE)
[16:03:15.952]                               parallel_sendData(master, data)
[16:03:15.952]                             }
[16:03:15.952]                             return(sendCondition)
[16:03:15.952]                           }
[16:03:15.952]                         }
[16:03:15.952]                         frame <- frame + 1L
[16:03:15.952]                         envir <- sys.frame(frame)
[16:03:15.952]                       }
[16:03:15.952]                     }
[16:03:15.952]                     sendCondition <<- function(cond) NULL
[16:03:15.952]                   }
[16:03:15.952]                 })
[16:03:15.952]                 withCallingHandlers({
[16:03:15.952]                   NA
[16:03:15.952]                 }, immediateCondition = function(cond) {
[16:03:15.952]                   sendCondition <- ...future.makeSendCondition()
[16:03:15.952]                   sendCondition(cond)
[16:03:15.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.952]                   {
[16:03:15.952]                     inherits <- base::inherits
[16:03:15.952]                     invokeRestart <- base::invokeRestart
[16:03:15.952]                     is.null <- base::is.null
[16:03:15.952]                     muffled <- FALSE
[16:03:15.952]                     if (inherits(cond, "message")) {
[16:03:15.952]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:15.952]                       if (muffled) 
[16:03:15.952]                         invokeRestart("muffleMessage")
[16:03:15.952]                     }
[16:03:15.952]                     else if (inherits(cond, "warning")) {
[16:03:15.952]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:15.952]                       if (muffled) 
[16:03:15.952]                         invokeRestart("muffleWarning")
[16:03:15.952]                     }
[16:03:15.952]                     else if (inherits(cond, "condition")) {
[16:03:15.952]                       if (!is.null(pattern)) {
[16:03:15.952]                         computeRestarts <- base::computeRestarts
[16:03:15.952]                         grepl <- base::grepl
[16:03:15.952]                         restarts <- computeRestarts(cond)
[16:03:15.952]                         for (restart in restarts) {
[16:03:15.952]                           name <- restart$name
[16:03:15.952]                           if (is.null(name)) 
[16:03:15.952]                             next
[16:03:15.952]                           if (!grepl(pattern, name)) 
[16:03:15.952]                             next
[16:03:15.952]                           invokeRestart(restart)
[16:03:15.952]                           muffled <- TRUE
[16:03:15.952]                           break
[16:03:15.952]                         }
[16:03:15.952]                       }
[16:03:15.952]                     }
[16:03:15.952]                     invisible(muffled)
[16:03:15.952]                   }
[16:03:15.952]                   muffleCondition(cond)
[16:03:15.952]                 })
[16:03:15.952]             }))
[16:03:15.952]             future::FutureResult(value = ...future.value$value, 
[16:03:15.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.952]                   ...future.rng), globalenv = if (FALSE) 
[16:03:15.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:15.952]                     ...future.globalenv.names))
[16:03:15.952]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:15.952]         }, condition = base::local({
[16:03:15.952]             c <- base::c
[16:03:15.952]             inherits <- base::inherits
[16:03:15.952]             invokeRestart <- base::invokeRestart
[16:03:15.952]             length <- base::length
[16:03:15.952]             list <- base::list
[16:03:15.952]             seq.int <- base::seq.int
[16:03:15.952]             signalCondition <- base::signalCondition
[16:03:15.952]             sys.calls <- base::sys.calls
[16:03:15.952]             `[[` <- base::`[[`
[16:03:15.952]             `+` <- base::`+`
[16:03:15.952]             `<<-` <- base::`<<-`
[16:03:15.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:15.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:15.952]                   3L)]
[16:03:15.952]             }
[16:03:15.952]             function(cond) {
[16:03:15.952]                 is_error <- inherits(cond, "error")
[16:03:15.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:15.952]                   NULL)
[16:03:15.952]                 if (is_error) {
[16:03:15.952]                   sessionInformation <- function() {
[16:03:15.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:15.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:15.952]                       search = base::search(), system = base::Sys.info())
[16:03:15.952]                   }
[16:03:15.952]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:15.952]                     cond$call), session = sessionInformation(), 
[16:03:15.952]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:15.952]                   signalCondition(cond)
[16:03:15.952]                 }
[16:03:15.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:15.952]                 "immediateCondition"))) {
[16:03:15.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:15.952]                   ...future.conditions[[length(...future.conditions) + 
[16:03:15.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:15.952]                   if (TRUE && !signal) {
[16:03:15.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.952]                     {
[16:03:15.952]                       inherits <- base::inherits
[16:03:15.952]                       invokeRestart <- base::invokeRestart
[16:03:15.952]                       is.null <- base::is.null
[16:03:15.952]                       muffled <- FALSE
[16:03:15.952]                       if (inherits(cond, "message")) {
[16:03:15.952]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.952]                         if (muffled) 
[16:03:15.952]                           invokeRestart("muffleMessage")
[16:03:15.952]                       }
[16:03:15.952]                       else if (inherits(cond, "warning")) {
[16:03:15.952]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.952]                         if (muffled) 
[16:03:15.952]                           invokeRestart("muffleWarning")
[16:03:15.952]                       }
[16:03:15.952]                       else if (inherits(cond, "condition")) {
[16:03:15.952]                         if (!is.null(pattern)) {
[16:03:15.952]                           computeRestarts <- base::computeRestarts
[16:03:15.952]                           grepl <- base::grepl
[16:03:15.952]                           restarts <- computeRestarts(cond)
[16:03:15.952]                           for (restart in restarts) {
[16:03:15.952]                             name <- restart$name
[16:03:15.952]                             if (is.null(name)) 
[16:03:15.952]                               next
[16:03:15.952]                             if (!grepl(pattern, name)) 
[16:03:15.952]                               next
[16:03:15.952]                             invokeRestart(restart)
[16:03:15.952]                             muffled <- TRUE
[16:03:15.952]                             break
[16:03:15.952]                           }
[16:03:15.952]                         }
[16:03:15.952]                       }
[16:03:15.952]                       invisible(muffled)
[16:03:15.952]                     }
[16:03:15.952]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.952]                   }
[16:03:15.952]                 }
[16:03:15.952]                 else {
[16:03:15.952]                   if (TRUE) {
[16:03:15.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:15.952]                     {
[16:03:15.952]                       inherits <- base::inherits
[16:03:15.952]                       invokeRestart <- base::invokeRestart
[16:03:15.952]                       is.null <- base::is.null
[16:03:15.952]                       muffled <- FALSE
[16:03:15.952]                       if (inherits(cond, "message")) {
[16:03:15.952]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:15.952]                         if (muffled) 
[16:03:15.952]                           invokeRestart("muffleMessage")
[16:03:15.952]                       }
[16:03:15.952]                       else if (inherits(cond, "warning")) {
[16:03:15.952]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:15.952]                         if (muffled) 
[16:03:15.952]                           invokeRestart("muffleWarning")
[16:03:15.952]                       }
[16:03:15.952]                       else if (inherits(cond, "condition")) {
[16:03:15.952]                         if (!is.null(pattern)) {
[16:03:15.952]                           computeRestarts <- base::computeRestarts
[16:03:15.952]                           grepl <- base::grepl
[16:03:15.952]                           restarts <- computeRestarts(cond)
[16:03:15.952]                           for (restart in restarts) {
[16:03:15.952]                             name <- restart$name
[16:03:15.952]                             if (is.null(name)) 
[16:03:15.952]                               next
[16:03:15.952]                             if (!grepl(pattern, name)) 
[16:03:15.952]                               next
[16:03:15.952]                             invokeRestart(restart)
[16:03:15.952]                             muffled <- TRUE
[16:03:15.952]                             break
[16:03:15.952]                           }
[16:03:15.952]                         }
[16:03:15.952]                       }
[16:03:15.952]                       invisible(muffled)
[16:03:15.952]                     }
[16:03:15.952]                     muffleCondition(cond, pattern = "^muffle")
[16:03:15.952]                   }
[16:03:15.952]                 }
[16:03:15.952]             }
[16:03:15.952]         }))
[16:03:15.952]     }, error = function(ex) {
[16:03:15.952]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:15.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:15.952]                 ...future.rng), started = ...future.startTime, 
[16:03:15.952]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:15.952]             version = "1.8"), class = "FutureResult")
[16:03:15.952]     }, finally = {
[16:03:15.952]         if (!identical(...future.workdir, getwd())) 
[16:03:15.952]             setwd(...future.workdir)
[16:03:15.952]         {
[16:03:15.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:15.952]                 ...future.oldOptions$nwarnings <- NULL
[16:03:15.952]             }
[16:03:15.952]             base::options(...future.oldOptions)
[16:03:15.952]             if (.Platform$OS.type == "windows") {
[16:03:15.952]                 old_names <- names(...future.oldEnvVars)
[16:03:15.952]                 envs <- base::Sys.getenv()
[16:03:15.952]                 names <- names(envs)
[16:03:15.952]                 common <- intersect(names, old_names)
[16:03:15.952]                 added <- setdiff(names, old_names)
[16:03:15.952]                 removed <- setdiff(old_names, names)
[16:03:15.952]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:15.952]                   envs[common]]
[16:03:15.952]                 NAMES <- toupper(changed)
[16:03:15.952]                 args <- list()
[16:03:15.952]                 for (kk in seq_along(NAMES)) {
[16:03:15.952]                   name <- changed[[kk]]
[16:03:15.952]                   NAME <- NAMES[[kk]]
[16:03:15.952]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.952]                     next
[16:03:15.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.952]                 }
[16:03:15.952]                 NAMES <- toupper(added)
[16:03:15.952]                 for (kk in seq_along(NAMES)) {
[16:03:15.952]                   name <- added[[kk]]
[16:03:15.952]                   NAME <- NAMES[[kk]]
[16:03:15.952]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.952]                     next
[16:03:15.952]                   args[[name]] <- ""
[16:03:15.952]                 }
[16:03:15.952]                 NAMES <- toupper(removed)
[16:03:15.952]                 for (kk in seq_along(NAMES)) {
[16:03:15.952]                   name <- removed[[kk]]
[16:03:15.952]                   NAME <- NAMES[[kk]]
[16:03:15.952]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:15.952]                     next
[16:03:15.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:15.952]                 }
[16:03:15.952]                 if (length(args) > 0) 
[16:03:15.952]                   base::do.call(base::Sys.setenv, args = args)
[16:03:15.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:15.952]             }
[16:03:15.952]             else {
[16:03:15.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:15.952]             }
[16:03:15.952]             {
[16:03:15.952]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:15.952]                   0L) {
[16:03:15.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:15.952]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:15.952]                   base::options(opts)
[16:03:15.952]                 }
[16:03:15.952]                 {
[16:03:15.952]                   {
[16:03:15.952]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:15.952]                     NULL
[16:03:15.952]                   }
[16:03:15.952]                   options(future.plan = NULL)
[16:03:15.952]                   if (is.na(NA_character_)) 
[16:03:15.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:15.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:15.952]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:15.952]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:15.952]                     envir = parent.frame()) 
[16:03:15.952]                   {
[16:03:15.952]                     if (is.function(workers)) 
[16:03:15.952]                       workers <- workers()
[16:03:15.952]                     workers <- structure(as.integer(workers), 
[16:03:15.952]                       class = class(workers))
[16:03:15.952]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:15.952]                       workers >= 1)
[16:03:15.952]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:15.952]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:15.952]                     }
[16:03:15.952]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:15.952]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:15.952]                       envir = envir)
[16:03:15.952]                     if (!future$lazy) 
[16:03:15.952]                       future <- run(future)
[16:03:15.952]                     invisible(future)
[16:03:15.952]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:15.952]                 }
[16:03:15.952]             }
[16:03:15.952]         }
[16:03:15.952]     })
[16:03:15.952]     if (TRUE) {
[16:03:15.952]         base::sink(type = "output", split = FALSE)
[16:03:15.952]         if (TRUE) {
[16:03:15.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:15.952]         }
[16:03:15.952]         else {
[16:03:15.952]             ...future.result["stdout"] <- base::list(NULL)
[16:03:15.952]         }
[16:03:15.952]         base::close(...future.stdout)
[16:03:15.952]         ...future.stdout <- NULL
[16:03:15.952]     }
[16:03:15.952]     ...future.result$conditions <- ...future.conditions
[16:03:15.952]     ...future.result$finished <- base::Sys.time()
[16:03:15.952]     ...future.result
[16:03:15.952] }
[16:03:16.005] MultisessionFuture started
[16:03:16.006] result() for ClusterFuture ...
[16:03:16.007] receiveMessageFromWorker() for ClusterFuture ...
[16:03:16.007] - Validating connection of MultisessionFuture
[16:03:16.050] - received message: FutureResult
[16:03:16.050] - Received FutureResult
[16:03:16.050] - Erased future from FutureRegistry
[16:03:16.050] result() for ClusterFuture ...
[16:03:16.051] - result already collected: FutureResult
[16:03:16.051] result() for ClusterFuture ... done
[16:03:16.051] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:16.051] result() for ClusterFuture ... done
[16:03:16.051] result() for ClusterFuture ...
[16:03:16.051] - result already collected: FutureResult
[16:03:16.051] result() for ClusterFuture ... done
[16:03:16.051] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:03:16.055] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[16:03:16.058] future_lapply() ...
[16:03:16.064] Number of chunks: 2
[16:03:16.064] getGlobalsAndPackagesXApply() ...
[16:03:16.064]  - future.globals: TRUE
[16:03:16.065] getGlobalsAndPackages() ...
[16:03:16.065] Searching for globals...
[16:03:16.069] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:16.069] Searching for globals ... DONE
[16:03:16.069] Resolving globals: FALSE
[16:03:16.070] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[16:03:16.070] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:16.071] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:16.071] - packages: [1] ‘future.apply’
[16:03:16.071] getGlobalsAndPackages() ... DONE
[16:03:16.071]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:16.071]  - needed namespaces: [n=1] ‘future.apply’
[16:03:16.071] Finding globals ... DONE
[16:03:16.071]  - use_args: TRUE
[16:03:16.072]  - Getting '...' globals ...
[16:03:16.072] resolve() on list ...
[16:03:16.072]  recursive: 0
[16:03:16.072]  length: 1
[16:03:16.072]  elements: ‘...’
[16:03:16.072]  length: 0 (resolved future 1)
[16:03:16.073] resolve() on list ... DONE
[16:03:16.073]    - '...' content: [n=0] 
[16:03:16.073] List of 1
[16:03:16.073]  $ ...: list()
[16:03:16.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:16.073]  - attr(*, "where")=List of 1
[16:03:16.073]   ..$ ...:<environment: 0x564e4403a828> 
[16:03:16.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:16.073]  - attr(*, "resolved")= logi TRUE
[16:03:16.073]  - attr(*, "total_size")= num NA
[16:03:16.076]  - Getting '...' globals ... DONE
[16:03:16.076] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:16.076] List of 8
[16:03:16.076]  $ ...future.FUN:function (x, ...)  
[16:03:16.076]  $ x_FUN        :function (x)  
[16:03:16.076]  $ times        : int 1
[16:03:16.076]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:16.076]  $ stop_if_not  :function (...)  
[16:03:16.076]  $ dim          : NULL
[16:03:16.076]  $ valid_types  : chr "character"
[16:03:16.076]  $ ...          : list()
[16:03:16.076]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:16.076]  - attr(*, "where")=List of 8
[16:03:16.076]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:16.076]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:16.076]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:16.076]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:16.076]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:16.076]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:16.076]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:16.076]   ..$ ...          :<environment: 0x564e4403a828> 
[16:03:16.076]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:16.076]  - attr(*, "resolved")= logi FALSE
[16:03:16.076]  - attr(*, "total_size")= num 94208
[16:03:16.083] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:16.083] getGlobalsAndPackagesXApply() ... DONE
[16:03:16.083] Number of futures (= number of chunks): 2
[16:03:16.083] Launching 2 futures (chunks) ...
[16:03:16.084] Chunk #1 of 2 ...
[16:03:16.084]  - Finding globals in 'X' for chunk #1 ...
[16:03:16.084] getGlobalsAndPackages() ...
[16:03:16.084] Searching for globals...
[16:03:16.084] 
[16:03:16.084] Searching for globals ... DONE
[16:03:16.084] - globals: [0] <none>
[16:03:16.085] getGlobalsAndPackages() ... DONE
[16:03:16.085]    + additional globals found: [n=0] 
[16:03:16.085]    + additional namespaces needed: [n=0] 
[16:03:16.085]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:16.085]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:16.085]  - seeds: <none>
[16:03:16.085]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.085] getGlobalsAndPackages() ...
[16:03:16.085] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.086] Resolving globals: FALSE
[16:03:16.086] Tweak future expression to call with '...' arguments ...
[16:03:16.086] {
[16:03:16.086]     do.call(function(...) {
[16:03:16.086]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.086]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:16.086]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.086]             on.exit(options(oopts), add = TRUE)
[16:03:16.086]         }
[16:03:16.086]         {
[16:03:16.086]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:16.086]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.086]                 ...future.FUN(...future.X_jj, ...)
[16:03:16.086]             })
[16:03:16.086]         }
[16:03:16.086]     }, args = future.call.arguments)
[16:03:16.086] }
[16:03:16.086] Tweak future expression to call with '...' arguments ... DONE
[16:03:16.087] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.087] - packages: [1] ‘future.apply’
[16:03:16.087] getGlobalsAndPackages() ... DONE
[16:03:16.087] run() for ‘Future’ ...
[16:03:16.088] - state: ‘created’
[16:03:16.088] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:16.102] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:16.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:16.102]   - Field: ‘node’
[16:03:16.102]   - Field: ‘label’
[16:03:16.102]   - Field: ‘local’
[16:03:16.103]   - Field: ‘owner’
[16:03:16.103]   - Field: ‘envir’
[16:03:16.103]   - Field: ‘workers’
[16:03:16.103]   - Field: ‘packages’
[16:03:16.103]   - Field: ‘gc’
[16:03:16.103]   - Field: ‘conditions’
[16:03:16.103]   - Field: ‘persistent’
[16:03:16.103]   - Field: ‘expr’
[16:03:16.103]   - Field: ‘uuid’
[16:03:16.104]   - Field: ‘seed’
[16:03:16.104]   - Field: ‘version’
[16:03:16.104]   - Field: ‘result’
[16:03:16.104]   - Field: ‘asynchronous’
[16:03:16.104]   - Field: ‘calls’
[16:03:16.104]   - Field: ‘globals’
[16:03:16.104]   - Field: ‘stdout’
[16:03:16.104]   - Field: ‘earlySignal’
[16:03:16.105]   - Field: ‘lazy’
[16:03:16.105]   - Field: ‘state’
[16:03:16.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:16.105] - Launch lazy future ...
[16:03:16.105] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:16.105] Packages needed by future strategies (n = 0): <none>
[16:03:16.106] {
[16:03:16.106]     {
[16:03:16.106]         {
[16:03:16.106]             ...future.startTime <- base::Sys.time()
[16:03:16.106]             {
[16:03:16.106]                 {
[16:03:16.106]                   {
[16:03:16.106]                     {
[16:03:16.106]                       {
[16:03:16.106]                         base::local({
[16:03:16.106]                           has_future <- base::requireNamespace("future", 
[16:03:16.106]                             quietly = TRUE)
[16:03:16.106]                           if (has_future) {
[16:03:16.106]                             ns <- base::getNamespace("future")
[16:03:16.106]                             version <- ns[[".package"]][["version"]]
[16:03:16.106]                             if (is.null(version)) 
[16:03:16.106]                               version <- utils::packageVersion("future")
[16:03:16.106]                           }
[16:03:16.106]                           else {
[16:03:16.106]                             version <- NULL
[16:03:16.106]                           }
[16:03:16.106]                           if (!has_future || version < "1.8.0") {
[16:03:16.106]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:16.106]                               "", base::R.version$version.string), 
[16:03:16.106]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:16.106]                                 base::R.version$platform, 8 * 
[16:03:16.106]                                   base::.Machine$sizeof.pointer), 
[16:03:16.106]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:16.106]                                 "release", "version")], collapse = " "), 
[16:03:16.106]                               hostname = base::Sys.info()[["nodename"]])
[16:03:16.106]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:16.106]                               info)
[16:03:16.106]                             info <- base::paste(info, collapse = "; ")
[16:03:16.106]                             if (!has_future) {
[16:03:16.106]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:16.106]                                 info)
[16:03:16.106]                             }
[16:03:16.106]                             else {
[16:03:16.106]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:16.106]                                 info, version)
[16:03:16.106]                             }
[16:03:16.106]                             base::stop(msg)
[16:03:16.106]                           }
[16:03:16.106]                         })
[16:03:16.106]                       }
[16:03:16.106]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:16.106]                       base::options(mc.cores = 1L)
[16:03:16.106]                     }
[16:03:16.106]                     base::local({
[16:03:16.106]                       for (pkg in "future.apply") {
[16:03:16.106]                         base::loadNamespace(pkg)
[16:03:16.106]                         base::library(pkg, character.only = TRUE)
[16:03:16.106]                       }
[16:03:16.106]                     })
[16:03:16.106]                   }
[16:03:16.106]                   options(future.plan = NULL)
[16:03:16.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:16.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:16.106]                 }
[16:03:16.106]                 ...future.workdir <- getwd()
[16:03:16.106]             }
[16:03:16.106]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:16.106]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:16.106]         }
[16:03:16.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:16.106]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:16.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:16.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:16.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:16.106]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:16.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:16.106]             base::names(...future.oldOptions))
[16:03:16.106]     }
[16:03:16.106]     if (FALSE) {
[16:03:16.106]     }
[16:03:16.106]     else {
[16:03:16.106]         if (TRUE) {
[16:03:16.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:16.106]                 open = "w")
[16:03:16.106]         }
[16:03:16.106]         else {
[16:03:16.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:16.106]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:16.106]         }
[16:03:16.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:16.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:16.106]             base::sink(type = "output", split = FALSE)
[16:03:16.106]             base::close(...future.stdout)
[16:03:16.106]         }, add = TRUE)
[16:03:16.106]     }
[16:03:16.106]     ...future.frame <- base::sys.nframe()
[16:03:16.106]     ...future.conditions <- base::list()
[16:03:16.106]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:16.106]     if (FALSE) {
[16:03:16.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:16.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:16.106]     }
[16:03:16.106]     ...future.result <- base::tryCatch({
[16:03:16.106]         base::withCallingHandlers({
[16:03:16.106]             ...future.value <- base::withVisible(base::local({
[16:03:16.106]                 ...future.makeSendCondition <- base::local({
[16:03:16.106]                   sendCondition <- NULL
[16:03:16.106]                   function(frame = 1L) {
[16:03:16.106]                     if (is.function(sendCondition)) 
[16:03:16.106]                       return(sendCondition)
[16:03:16.106]                     ns <- getNamespace("parallel")
[16:03:16.106]                     if (exists("sendData", mode = "function", 
[16:03:16.106]                       envir = ns)) {
[16:03:16.106]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:16.106]                         envir = ns)
[16:03:16.106]                       envir <- sys.frame(frame)
[16:03:16.106]                       master <- NULL
[16:03:16.106]                       while (!identical(envir, .GlobalEnv) && 
[16:03:16.106]                         !identical(envir, emptyenv())) {
[16:03:16.106]                         if (exists("master", mode = "list", envir = envir, 
[16:03:16.106]                           inherits = FALSE)) {
[16:03:16.106]                           master <- get("master", mode = "list", 
[16:03:16.106]                             envir = envir, inherits = FALSE)
[16:03:16.106]                           if (inherits(master, c("SOCKnode", 
[16:03:16.106]                             "SOCK0node"))) {
[16:03:16.106]                             sendCondition <<- function(cond) {
[16:03:16.106]                               data <- list(type = "VALUE", value = cond, 
[16:03:16.106]                                 success = TRUE)
[16:03:16.106]                               parallel_sendData(master, data)
[16:03:16.106]                             }
[16:03:16.106]                             return(sendCondition)
[16:03:16.106]                           }
[16:03:16.106]                         }
[16:03:16.106]                         frame <- frame + 1L
[16:03:16.106]                         envir <- sys.frame(frame)
[16:03:16.106]                       }
[16:03:16.106]                     }
[16:03:16.106]                     sendCondition <<- function(cond) NULL
[16:03:16.106]                   }
[16:03:16.106]                 })
[16:03:16.106]                 withCallingHandlers({
[16:03:16.106]                   {
[16:03:16.106]                     do.call(function(...) {
[16:03:16.106]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.106]                       if (!identical(...future.globals.maxSize.org, 
[16:03:16.106]                         ...future.globals.maxSize)) {
[16:03:16.106]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.106]                         on.exit(options(oopts), add = TRUE)
[16:03:16.106]                       }
[16:03:16.106]                       {
[16:03:16.106]                         lapply(seq_along(...future.elements_ii), 
[16:03:16.106]                           FUN = function(jj) {
[16:03:16.106]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.106]                             ...future.FUN(...future.X_jj, ...)
[16:03:16.106]                           })
[16:03:16.106]                       }
[16:03:16.106]                     }, args = future.call.arguments)
[16:03:16.106]                   }
[16:03:16.106]                 }, immediateCondition = function(cond) {
[16:03:16.106]                   sendCondition <- ...future.makeSendCondition()
[16:03:16.106]                   sendCondition(cond)
[16:03:16.106]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.106]                   {
[16:03:16.106]                     inherits <- base::inherits
[16:03:16.106]                     invokeRestart <- base::invokeRestart
[16:03:16.106]                     is.null <- base::is.null
[16:03:16.106]                     muffled <- FALSE
[16:03:16.106]                     if (inherits(cond, "message")) {
[16:03:16.106]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:16.106]                       if (muffled) 
[16:03:16.106]                         invokeRestart("muffleMessage")
[16:03:16.106]                     }
[16:03:16.106]                     else if (inherits(cond, "warning")) {
[16:03:16.106]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:16.106]                       if (muffled) 
[16:03:16.106]                         invokeRestart("muffleWarning")
[16:03:16.106]                     }
[16:03:16.106]                     else if (inherits(cond, "condition")) {
[16:03:16.106]                       if (!is.null(pattern)) {
[16:03:16.106]                         computeRestarts <- base::computeRestarts
[16:03:16.106]                         grepl <- base::grepl
[16:03:16.106]                         restarts <- computeRestarts(cond)
[16:03:16.106]                         for (restart in restarts) {
[16:03:16.106]                           name <- restart$name
[16:03:16.106]                           if (is.null(name)) 
[16:03:16.106]                             next
[16:03:16.106]                           if (!grepl(pattern, name)) 
[16:03:16.106]                             next
[16:03:16.106]                           invokeRestart(restart)
[16:03:16.106]                           muffled <- TRUE
[16:03:16.106]                           break
[16:03:16.106]                         }
[16:03:16.106]                       }
[16:03:16.106]                     }
[16:03:16.106]                     invisible(muffled)
[16:03:16.106]                   }
[16:03:16.106]                   muffleCondition(cond)
[16:03:16.106]                 })
[16:03:16.106]             }))
[16:03:16.106]             future::FutureResult(value = ...future.value$value, 
[16:03:16.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:16.106]                   ...future.rng), globalenv = if (FALSE) 
[16:03:16.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:16.106]                     ...future.globalenv.names))
[16:03:16.106]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:16.106]         }, condition = base::local({
[16:03:16.106]             c <- base::c
[16:03:16.106]             inherits <- base::inherits
[16:03:16.106]             invokeRestart <- base::invokeRestart
[16:03:16.106]             length <- base::length
[16:03:16.106]             list <- base::list
[16:03:16.106]             seq.int <- base::seq.int
[16:03:16.106]             signalCondition <- base::signalCondition
[16:03:16.106]             sys.calls <- base::sys.calls
[16:03:16.106]             `[[` <- base::`[[`
[16:03:16.106]             `+` <- base::`+`
[16:03:16.106]             `<<-` <- base::`<<-`
[16:03:16.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:16.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:16.106]                   3L)]
[16:03:16.106]             }
[16:03:16.106]             function(cond) {
[16:03:16.106]                 is_error <- inherits(cond, "error")
[16:03:16.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:16.106]                   NULL)
[16:03:16.106]                 if (is_error) {
[16:03:16.106]                   sessionInformation <- function() {
[16:03:16.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:16.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:16.106]                       search = base::search(), system = base::Sys.info())
[16:03:16.106]                   }
[16:03:16.106]                   ...future.conditions[[length(...future.conditions) + 
[16:03:16.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:16.106]                     cond$call), session = sessionInformation(), 
[16:03:16.106]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:16.106]                   signalCondition(cond)
[16:03:16.106]                 }
[16:03:16.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:16.106]                 "immediateCondition"))) {
[16:03:16.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:16.106]                   ...future.conditions[[length(...future.conditions) + 
[16:03:16.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:16.106]                   if (TRUE && !signal) {
[16:03:16.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.106]                     {
[16:03:16.106]                       inherits <- base::inherits
[16:03:16.106]                       invokeRestart <- base::invokeRestart
[16:03:16.106]                       is.null <- base::is.null
[16:03:16.106]                       muffled <- FALSE
[16:03:16.106]                       if (inherits(cond, "message")) {
[16:03:16.106]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:16.106]                         if (muffled) 
[16:03:16.106]                           invokeRestart("muffleMessage")
[16:03:16.106]                       }
[16:03:16.106]                       else if (inherits(cond, "warning")) {
[16:03:16.106]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:16.106]                         if (muffled) 
[16:03:16.106]                           invokeRestart("muffleWarning")
[16:03:16.106]                       }
[16:03:16.106]                       else if (inherits(cond, "condition")) {
[16:03:16.106]                         if (!is.null(pattern)) {
[16:03:16.106]                           computeRestarts <- base::computeRestarts
[16:03:16.106]                           grepl <- base::grepl
[16:03:16.106]                           restarts <- computeRestarts(cond)
[16:03:16.106]                           for (restart in restarts) {
[16:03:16.106]                             name <- restart$name
[16:03:16.106]                             if (is.null(name)) 
[16:03:16.106]                               next
[16:03:16.106]                             if (!grepl(pattern, name)) 
[16:03:16.106]                               next
[16:03:16.106]                             invokeRestart(restart)
[16:03:16.106]                             muffled <- TRUE
[16:03:16.106]                             break
[16:03:16.106]                           }
[16:03:16.106]                         }
[16:03:16.106]                       }
[16:03:16.106]                       invisible(muffled)
[16:03:16.106]                     }
[16:03:16.106]                     muffleCondition(cond, pattern = "^muffle")
[16:03:16.106]                   }
[16:03:16.106]                 }
[16:03:16.106]                 else {
[16:03:16.106]                   if (TRUE) {
[16:03:16.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.106]                     {
[16:03:16.106]                       inherits <- base::inherits
[16:03:16.106]                       invokeRestart <- base::invokeRestart
[16:03:16.106]                       is.null <- base::is.null
[16:03:16.106]                       muffled <- FALSE
[16:03:16.106]                       if (inherits(cond, "message")) {
[16:03:16.106]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:16.106]                         if (muffled) 
[16:03:16.106]                           invokeRestart("muffleMessage")
[16:03:16.106]                       }
[16:03:16.106]                       else if (inherits(cond, "warning")) {
[16:03:16.106]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:16.106]                         if (muffled) 
[16:03:16.106]                           invokeRestart("muffleWarning")
[16:03:16.106]                       }
[16:03:16.106]                       else if (inherits(cond, "condition")) {
[16:03:16.106]                         if (!is.null(pattern)) {
[16:03:16.106]                           computeRestarts <- base::computeRestarts
[16:03:16.106]                           grepl <- base::grepl
[16:03:16.106]                           restarts <- computeRestarts(cond)
[16:03:16.106]                           for (restart in restarts) {
[16:03:16.106]                             name <- restart$name
[16:03:16.106]                             if (is.null(name)) 
[16:03:16.106]                               next
[16:03:16.106]                             if (!grepl(pattern, name)) 
[16:03:16.106]                               next
[16:03:16.106]                             invokeRestart(restart)
[16:03:16.106]                             muffled <- TRUE
[16:03:16.106]                             break
[16:03:16.106]                           }
[16:03:16.106]                         }
[16:03:16.106]                       }
[16:03:16.106]                       invisible(muffled)
[16:03:16.106]                     }
[16:03:16.106]                     muffleCondition(cond, pattern = "^muffle")
[16:03:16.106]                   }
[16:03:16.106]                 }
[16:03:16.106]             }
[16:03:16.106]         }))
[16:03:16.106]     }, error = function(ex) {
[16:03:16.106]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:16.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:16.106]                 ...future.rng), started = ...future.startTime, 
[16:03:16.106]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:16.106]             version = "1.8"), class = "FutureResult")
[16:03:16.106]     }, finally = {
[16:03:16.106]         if (!identical(...future.workdir, getwd())) 
[16:03:16.106]             setwd(...future.workdir)
[16:03:16.106]         {
[16:03:16.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:16.106]                 ...future.oldOptions$nwarnings <- NULL
[16:03:16.106]             }
[16:03:16.106]             base::options(...future.oldOptions)
[16:03:16.106]             if (.Platform$OS.type == "windows") {
[16:03:16.106]                 old_names <- names(...future.oldEnvVars)
[16:03:16.106]                 envs <- base::Sys.getenv()
[16:03:16.106]                 names <- names(envs)
[16:03:16.106]                 common <- intersect(names, old_names)
[16:03:16.106]                 added <- setdiff(names, old_names)
[16:03:16.106]                 removed <- setdiff(old_names, names)
[16:03:16.106]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:16.106]                   envs[common]]
[16:03:16.106]                 NAMES <- toupper(changed)
[16:03:16.106]                 args <- list()
[16:03:16.106]                 for (kk in seq_along(NAMES)) {
[16:03:16.106]                   name <- changed[[kk]]
[16:03:16.106]                   NAME <- NAMES[[kk]]
[16:03:16.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.106]                     next
[16:03:16.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:16.106]                 }
[16:03:16.106]                 NAMES <- toupper(added)
[16:03:16.106]                 for (kk in seq_along(NAMES)) {
[16:03:16.106]                   name <- added[[kk]]
[16:03:16.106]                   NAME <- NAMES[[kk]]
[16:03:16.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.106]                     next
[16:03:16.106]                   args[[name]] <- ""
[16:03:16.106]                 }
[16:03:16.106]                 NAMES <- toupper(removed)
[16:03:16.106]                 for (kk in seq_along(NAMES)) {
[16:03:16.106]                   name <- removed[[kk]]
[16:03:16.106]                   NAME <- NAMES[[kk]]
[16:03:16.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.106]                     next
[16:03:16.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:16.106]                 }
[16:03:16.106]                 if (length(args) > 0) 
[16:03:16.106]                   base::do.call(base::Sys.setenv, args = args)
[16:03:16.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:16.106]             }
[16:03:16.106]             else {
[16:03:16.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:16.106]             }
[16:03:16.106]             {
[16:03:16.106]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:16.106]                   0L) {
[16:03:16.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:16.106]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:16.106]                   base::options(opts)
[16:03:16.106]                 }
[16:03:16.106]                 {
[16:03:16.106]                   {
[16:03:16.106]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:16.106]                     NULL
[16:03:16.106]                   }
[16:03:16.106]                   options(future.plan = NULL)
[16:03:16.106]                   if (is.na(NA_character_)) 
[16:03:16.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:16.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:16.106]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:16.106]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:16.106]                     envir = parent.frame()) 
[16:03:16.106]                   {
[16:03:16.106]                     if (is.function(workers)) 
[16:03:16.106]                       workers <- workers()
[16:03:16.106]                     workers <- structure(as.integer(workers), 
[16:03:16.106]                       class = class(workers))
[16:03:16.106]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:16.106]                       workers >= 1)
[16:03:16.106]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:16.106]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:16.106]                     }
[16:03:16.106]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:16.106]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:16.106]                       envir = envir)
[16:03:16.106]                     if (!future$lazy) 
[16:03:16.106]                       future <- run(future)
[16:03:16.106]                     invisible(future)
[16:03:16.106]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:16.106]                 }
[16:03:16.106]             }
[16:03:16.106]         }
[16:03:16.106]     })
[16:03:16.106]     if (TRUE) {
[16:03:16.106]         base::sink(type = "output", split = FALSE)
[16:03:16.106]         if (TRUE) {
[16:03:16.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:16.106]         }
[16:03:16.106]         else {
[16:03:16.106]             ...future.result["stdout"] <- base::list(NULL)
[16:03:16.106]         }
[16:03:16.106]         base::close(...future.stdout)
[16:03:16.106]         ...future.stdout <- NULL
[16:03:16.106]     }
[16:03:16.106]     ...future.result$conditions <- ...future.conditions
[16:03:16.106]     ...future.result$finished <- base::Sys.time()
[16:03:16.106]     ...future.result
[16:03:16.106] }
[16:03:16.109] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[16:03:16.109] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:16.151] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:16.151] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:03:16.152] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:03:16.152] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:16.153] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:16.153] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:16.195] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:16.195] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:16.239] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:16.239] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:03:16.240] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:03:16.240] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[16:03:16.240] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[16:03:16.241] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:16.241] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:16.241] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[16:03:16.242] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[16:03:16.242] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:16.242] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:16.242] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:16.243] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:16.243] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[16:03:16.244] MultisessionFuture started
[16:03:16.244] - Launch lazy future ... done
[16:03:16.244] run() for ‘MultisessionFuture’ ... done
[16:03:16.244] Created future:
[16:03:16.244] MultisessionFuture:
[16:03:16.244] Label: ‘future_vapply-1’
[16:03:16.244] Expression:
[16:03:16.244] {
[16:03:16.244]     do.call(function(...) {
[16:03:16.244]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.244]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:16.244]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.244]             on.exit(options(oopts), add = TRUE)
[16:03:16.244]         }
[16:03:16.244]         {
[16:03:16.244]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:16.244]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.244]                 ...future.FUN(...future.X_jj, ...)
[16:03:16.244]             })
[16:03:16.244]         }
[16:03:16.244]     }, args = future.call.arguments)
[16:03:16.244] }
[16:03:16.244] Lazy evaluation: FALSE
[16:03:16.244] Asynchronous evaluation: TRUE
[16:03:16.244] Local evaluation: TRUE
[16:03:16.244] Environment: R_GlobalEnv
[16:03:16.244] Capture standard output: TRUE
[16:03:16.244] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:16.244] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:16.244] Packages: 1 packages (‘future.apply’)
[16:03:16.244] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:16.244] Resolved: FALSE
[16:03:16.244] Value: <not collected>
[16:03:16.244] Conditions captured: <none>
[16:03:16.244] Early signaling: FALSE
[16:03:16.244] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:16.244] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:16.257] Chunk #1 of 2 ... DONE
[16:03:16.257] Chunk #2 of 2 ...
[16:03:16.257]  - Finding globals in 'X' for chunk #2 ...
[16:03:16.257] getGlobalsAndPackages() ...
[16:03:16.257] Searching for globals...
[16:03:16.258] 
[16:03:16.258] Searching for globals ... DONE
[16:03:16.258] - globals: [0] <none>
[16:03:16.258] getGlobalsAndPackages() ... DONE
[16:03:16.258]    + additional globals found: [n=0] 
[16:03:16.258]    + additional namespaces needed: [n=0] 
[16:03:16.258]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:16.259]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:16.259]  - seeds: <none>
[16:03:16.259]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.259] getGlobalsAndPackages() ...
[16:03:16.259] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.259] Resolving globals: FALSE
[16:03:16.259] Tweak future expression to call with '...' arguments ...
[16:03:16.260] {
[16:03:16.260]     do.call(function(...) {
[16:03:16.260]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.260]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:16.260]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.260]             on.exit(options(oopts), add = TRUE)
[16:03:16.260]         }
[16:03:16.260]         {
[16:03:16.260]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:16.260]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.260]                 ...future.FUN(...future.X_jj, ...)
[16:03:16.260]             })
[16:03:16.260]         }
[16:03:16.260]     }, args = future.call.arguments)
[16:03:16.260] }
[16:03:16.260] Tweak future expression to call with '...' arguments ... DONE
[16:03:16.261] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.261] - packages: [1] ‘future.apply’
[16:03:16.261] getGlobalsAndPackages() ... DONE
[16:03:16.261] run() for ‘Future’ ...
[16:03:16.261] - state: ‘created’
[16:03:16.261] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:16.276] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:16.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:16.277]   - Field: ‘node’
[16:03:16.277]   - Field: ‘label’
[16:03:16.277]   - Field: ‘local’
[16:03:16.277]   - Field: ‘owner’
[16:03:16.277]   - Field: ‘envir’
[16:03:16.277]   - Field: ‘workers’
[16:03:16.277]   - Field: ‘packages’
[16:03:16.277]   - Field: ‘gc’
[16:03:16.277]   - Field: ‘conditions’
[16:03:16.278]   - Field: ‘persistent’
[16:03:16.278]   - Field: ‘expr’
[16:03:16.278]   - Field: ‘uuid’
[16:03:16.278]   - Field: ‘seed’
[16:03:16.278]   - Field: ‘version’
[16:03:16.278]   - Field: ‘result’
[16:03:16.278]   - Field: ‘asynchronous’
[16:03:16.278]   - Field: ‘calls’
[16:03:16.278]   - Field: ‘globals’
[16:03:16.279]   - Field: ‘stdout’
[16:03:16.279]   - Field: ‘earlySignal’
[16:03:16.279]   - Field: ‘lazy’
[16:03:16.279]   - Field: ‘state’
[16:03:16.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:16.279] - Launch lazy future ...
[16:03:16.280] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:16.280] Packages needed by future strategies (n = 0): <none>
[16:03:16.280] {
[16:03:16.280]     {
[16:03:16.280]         {
[16:03:16.280]             ...future.startTime <- base::Sys.time()
[16:03:16.280]             {
[16:03:16.280]                 {
[16:03:16.280]                   {
[16:03:16.280]                     {
[16:03:16.280]                       {
[16:03:16.280]                         base::local({
[16:03:16.280]                           has_future <- base::requireNamespace("future", 
[16:03:16.280]                             quietly = TRUE)
[16:03:16.280]                           if (has_future) {
[16:03:16.280]                             ns <- base::getNamespace("future")
[16:03:16.280]                             version <- ns[[".package"]][["version"]]
[16:03:16.280]                             if (is.null(version)) 
[16:03:16.280]                               version <- utils::packageVersion("future")
[16:03:16.280]                           }
[16:03:16.280]                           else {
[16:03:16.280]                             version <- NULL
[16:03:16.280]                           }
[16:03:16.280]                           if (!has_future || version < "1.8.0") {
[16:03:16.280]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:16.280]                               "", base::R.version$version.string), 
[16:03:16.280]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:16.280]                                 base::R.version$platform, 8 * 
[16:03:16.280]                                   base::.Machine$sizeof.pointer), 
[16:03:16.280]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:16.280]                                 "release", "version")], collapse = " "), 
[16:03:16.280]                               hostname = base::Sys.info()[["nodename"]])
[16:03:16.280]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:16.280]                               info)
[16:03:16.280]                             info <- base::paste(info, collapse = "; ")
[16:03:16.280]                             if (!has_future) {
[16:03:16.280]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:16.280]                                 info)
[16:03:16.280]                             }
[16:03:16.280]                             else {
[16:03:16.280]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:16.280]                                 info, version)
[16:03:16.280]                             }
[16:03:16.280]                             base::stop(msg)
[16:03:16.280]                           }
[16:03:16.280]                         })
[16:03:16.280]                       }
[16:03:16.280]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:16.280]                       base::options(mc.cores = 1L)
[16:03:16.280]                     }
[16:03:16.280]                     base::local({
[16:03:16.280]                       for (pkg in "future.apply") {
[16:03:16.280]                         base::loadNamespace(pkg)
[16:03:16.280]                         base::library(pkg, character.only = TRUE)
[16:03:16.280]                       }
[16:03:16.280]                     })
[16:03:16.280]                   }
[16:03:16.280]                   options(future.plan = NULL)
[16:03:16.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:16.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:16.280]                 }
[16:03:16.280]                 ...future.workdir <- getwd()
[16:03:16.280]             }
[16:03:16.280]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:16.280]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:16.280]         }
[16:03:16.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:16.280]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:16.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:16.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:16.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:16.280]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:16.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:16.280]             base::names(...future.oldOptions))
[16:03:16.280]     }
[16:03:16.280]     if (FALSE) {
[16:03:16.280]     }
[16:03:16.280]     else {
[16:03:16.280]         if (TRUE) {
[16:03:16.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:16.280]                 open = "w")
[16:03:16.280]         }
[16:03:16.280]         else {
[16:03:16.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:16.280]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:16.280]         }
[16:03:16.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:16.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:16.280]             base::sink(type = "output", split = FALSE)
[16:03:16.280]             base::close(...future.stdout)
[16:03:16.280]         }, add = TRUE)
[16:03:16.280]     }
[16:03:16.280]     ...future.frame <- base::sys.nframe()
[16:03:16.280]     ...future.conditions <- base::list()
[16:03:16.280]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:16.280]     if (FALSE) {
[16:03:16.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:16.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:16.280]     }
[16:03:16.280]     ...future.result <- base::tryCatch({
[16:03:16.280]         base::withCallingHandlers({
[16:03:16.280]             ...future.value <- base::withVisible(base::local({
[16:03:16.280]                 ...future.makeSendCondition <- base::local({
[16:03:16.280]                   sendCondition <- NULL
[16:03:16.280]                   function(frame = 1L) {
[16:03:16.280]                     if (is.function(sendCondition)) 
[16:03:16.280]                       return(sendCondition)
[16:03:16.280]                     ns <- getNamespace("parallel")
[16:03:16.280]                     if (exists("sendData", mode = "function", 
[16:03:16.280]                       envir = ns)) {
[16:03:16.280]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:16.280]                         envir = ns)
[16:03:16.280]                       envir <- sys.frame(frame)
[16:03:16.280]                       master <- NULL
[16:03:16.280]                       while (!identical(envir, .GlobalEnv) && 
[16:03:16.280]                         !identical(envir, emptyenv())) {
[16:03:16.280]                         if (exists("master", mode = "list", envir = envir, 
[16:03:16.280]                           inherits = FALSE)) {
[16:03:16.280]                           master <- get("master", mode = "list", 
[16:03:16.280]                             envir = envir, inherits = FALSE)
[16:03:16.280]                           if (inherits(master, c("SOCKnode", 
[16:03:16.280]                             "SOCK0node"))) {
[16:03:16.280]                             sendCondition <<- function(cond) {
[16:03:16.280]                               data <- list(type = "VALUE", value = cond, 
[16:03:16.280]                                 success = TRUE)
[16:03:16.280]                               parallel_sendData(master, data)
[16:03:16.280]                             }
[16:03:16.280]                             return(sendCondition)
[16:03:16.280]                           }
[16:03:16.280]                         }
[16:03:16.280]                         frame <- frame + 1L
[16:03:16.280]                         envir <- sys.frame(frame)
[16:03:16.280]                       }
[16:03:16.280]                     }
[16:03:16.280]                     sendCondition <<- function(cond) NULL
[16:03:16.280]                   }
[16:03:16.280]                 })
[16:03:16.280]                 withCallingHandlers({
[16:03:16.280]                   {
[16:03:16.280]                     do.call(function(...) {
[16:03:16.280]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.280]                       if (!identical(...future.globals.maxSize.org, 
[16:03:16.280]                         ...future.globals.maxSize)) {
[16:03:16.280]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.280]                         on.exit(options(oopts), add = TRUE)
[16:03:16.280]                       }
[16:03:16.280]                       {
[16:03:16.280]                         lapply(seq_along(...future.elements_ii), 
[16:03:16.280]                           FUN = function(jj) {
[16:03:16.280]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.280]                             ...future.FUN(...future.X_jj, ...)
[16:03:16.280]                           })
[16:03:16.280]                       }
[16:03:16.280]                     }, args = future.call.arguments)
[16:03:16.280]                   }
[16:03:16.280]                 }, immediateCondition = function(cond) {
[16:03:16.280]                   sendCondition <- ...future.makeSendCondition()
[16:03:16.280]                   sendCondition(cond)
[16:03:16.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.280]                   {
[16:03:16.280]                     inherits <- base::inherits
[16:03:16.280]                     invokeRestart <- base::invokeRestart
[16:03:16.280]                     is.null <- base::is.null
[16:03:16.280]                     muffled <- FALSE
[16:03:16.280]                     if (inherits(cond, "message")) {
[16:03:16.280]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:16.280]                       if (muffled) 
[16:03:16.280]                         invokeRestart("muffleMessage")
[16:03:16.280]                     }
[16:03:16.280]                     else if (inherits(cond, "warning")) {
[16:03:16.280]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:16.280]                       if (muffled) 
[16:03:16.280]                         invokeRestart("muffleWarning")
[16:03:16.280]                     }
[16:03:16.280]                     else if (inherits(cond, "condition")) {
[16:03:16.280]                       if (!is.null(pattern)) {
[16:03:16.280]                         computeRestarts <- base::computeRestarts
[16:03:16.280]                         grepl <- base::grepl
[16:03:16.280]                         restarts <- computeRestarts(cond)
[16:03:16.280]                         for (restart in restarts) {
[16:03:16.280]                           name <- restart$name
[16:03:16.280]                           if (is.null(name)) 
[16:03:16.280]                             next
[16:03:16.280]                           if (!grepl(pattern, name)) 
[16:03:16.280]                             next
[16:03:16.280]                           invokeRestart(restart)
[16:03:16.280]                           muffled <- TRUE
[16:03:16.280]                           break
[16:03:16.280]                         }
[16:03:16.280]                       }
[16:03:16.280]                     }
[16:03:16.280]                     invisible(muffled)
[16:03:16.280]                   }
[16:03:16.280]                   muffleCondition(cond)
[16:03:16.280]                 })
[16:03:16.280]             }))
[16:03:16.280]             future::FutureResult(value = ...future.value$value, 
[16:03:16.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:16.280]                   ...future.rng), globalenv = if (FALSE) 
[16:03:16.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:16.280]                     ...future.globalenv.names))
[16:03:16.280]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:16.280]         }, condition = base::local({
[16:03:16.280]             c <- base::c
[16:03:16.280]             inherits <- base::inherits
[16:03:16.280]             invokeRestart <- base::invokeRestart
[16:03:16.280]             length <- base::length
[16:03:16.280]             list <- base::list
[16:03:16.280]             seq.int <- base::seq.int
[16:03:16.280]             signalCondition <- base::signalCondition
[16:03:16.280]             sys.calls <- base::sys.calls
[16:03:16.280]             `[[` <- base::`[[`
[16:03:16.280]             `+` <- base::`+`
[16:03:16.280]             `<<-` <- base::`<<-`
[16:03:16.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:16.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:16.280]                   3L)]
[16:03:16.280]             }
[16:03:16.280]             function(cond) {
[16:03:16.280]                 is_error <- inherits(cond, "error")
[16:03:16.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:16.280]                   NULL)
[16:03:16.280]                 if (is_error) {
[16:03:16.280]                   sessionInformation <- function() {
[16:03:16.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:16.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:16.280]                       search = base::search(), system = base::Sys.info())
[16:03:16.280]                   }
[16:03:16.280]                   ...future.conditions[[length(...future.conditions) + 
[16:03:16.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:16.280]                     cond$call), session = sessionInformation(), 
[16:03:16.280]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:16.280]                   signalCondition(cond)
[16:03:16.280]                 }
[16:03:16.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:16.280]                 "immediateCondition"))) {
[16:03:16.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:16.280]                   ...future.conditions[[length(...future.conditions) + 
[16:03:16.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:16.280]                   if (TRUE && !signal) {
[16:03:16.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.280]                     {
[16:03:16.280]                       inherits <- base::inherits
[16:03:16.280]                       invokeRestart <- base::invokeRestart
[16:03:16.280]                       is.null <- base::is.null
[16:03:16.280]                       muffled <- FALSE
[16:03:16.280]                       if (inherits(cond, "message")) {
[16:03:16.280]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:16.280]                         if (muffled) 
[16:03:16.280]                           invokeRestart("muffleMessage")
[16:03:16.280]                       }
[16:03:16.280]                       else if (inherits(cond, "warning")) {
[16:03:16.280]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:16.280]                         if (muffled) 
[16:03:16.280]                           invokeRestart("muffleWarning")
[16:03:16.280]                       }
[16:03:16.280]                       else if (inherits(cond, "condition")) {
[16:03:16.280]                         if (!is.null(pattern)) {
[16:03:16.280]                           computeRestarts <- base::computeRestarts
[16:03:16.280]                           grepl <- base::grepl
[16:03:16.280]                           restarts <- computeRestarts(cond)
[16:03:16.280]                           for (restart in restarts) {
[16:03:16.280]                             name <- restart$name
[16:03:16.280]                             if (is.null(name)) 
[16:03:16.280]                               next
[16:03:16.280]                             if (!grepl(pattern, name)) 
[16:03:16.280]                               next
[16:03:16.280]                             invokeRestart(restart)
[16:03:16.280]                             muffled <- TRUE
[16:03:16.280]                             break
[16:03:16.280]                           }
[16:03:16.280]                         }
[16:03:16.280]                       }
[16:03:16.280]                       invisible(muffled)
[16:03:16.280]                     }
[16:03:16.280]                     muffleCondition(cond, pattern = "^muffle")
[16:03:16.280]                   }
[16:03:16.280]                 }
[16:03:16.280]                 else {
[16:03:16.280]                   if (TRUE) {
[16:03:16.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.280]                     {
[16:03:16.280]                       inherits <- base::inherits
[16:03:16.280]                       invokeRestart <- base::invokeRestart
[16:03:16.280]                       is.null <- base::is.null
[16:03:16.280]                       muffled <- FALSE
[16:03:16.280]                       if (inherits(cond, "message")) {
[16:03:16.280]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:16.280]                         if (muffled) 
[16:03:16.280]                           invokeRestart("muffleMessage")
[16:03:16.280]                       }
[16:03:16.280]                       else if (inherits(cond, "warning")) {
[16:03:16.280]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:16.280]                         if (muffled) 
[16:03:16.280]                           invokeRestart("muffleWarning")
[16:03:16.280]                       }
[16:03:16.280]                       else if (inherits(cond, "condition")) {
[16:03:16.280]                         if (!is.null(pattern)) {
[16:03:16.280]                           computeRestarts <- base::computeRestarts
[16:03:16.280]                           grepl <- base::grepl
[16:03:16.280]                           restarts <- computeRestarts(cond)
[16:03:16.280]                           for (restart in restarts) {
[16:03:16.280]                             name <- restart$name
[16:03:16.280]                             if (is.null(name)) 
[16:03:16.280]                               next
[16:03:16.280]                             if (!grepl(pattern, name)) 
[16:03:16.280]                               next
[16:03:16.280]                             invokeRestart(restart)
[16:03:16.280]                             muffled <- TRUE
[16:03:16.280]                             break
[16:03:16.280]                           }
[16:03:16.280]                         }
[16:03:16.280]                       }
[16:03:16.280]                       invisible(muffled)
[16:03:16.280]                     }
[16:03:16.280]                     muffleCondition(cond, pattern = "^muffle")
[16:03:16.280]                   }
[16:03:16.280]                 }
[16:03:16.280]             }
[16:03:16.280]         }))
[16:03:16.280]     }, error = function(ex) {
[16:03:16.280]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:16.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:16.280]                 ...future.rng), started = ...future.startTime, 
[16:03:16.280]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:16.280]             version = "1.8"), class = "FutureResult")
[16:03:16.280]     }, finally = {
[16:03:16.280]         if (!identical(...future.workdir, getwd())) 
[16:03:16.280]             setwd(...future.workdir)
[16:03:16.280]         {
[16:03:16.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:16.280]                 ...future.oldOptions$nwarnings <- NULL
[16:03:16.280]             }
[16:03:16.280]             base::options(...future.oldOptions)
[16:03:16.280]             if (.Platform$OS.type == "windows") {
[16:03:16.280]                 old_names <- names(...future.oldEnvVars)
[16:03:16.280]                 envs <- base::Sys.getenv()
[16:03:16.280]                 names <- names(envs)
[16:03:16.280]                 common <- intersect(names, old_names)
[16:03:16.280]                 added <- setdiff(names, old_names)
[16:03:16.280]                 removed <- setdiff(old_names, names)
[16:03:16.280]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:16.280]                   envs[common]]
[16:03:16.280]                 NAMES <- toupper(changed)
[16:03:16.280]                 args <- list()
[16:03:16.280]                 for (kk in seq_along(NAMES)) {
[16:03:16.280]                   name <- changed[[kk]]
[16:03:16.280]                   NAME <- NAMES[[kk]]
[16:03:16.280]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.280]                     next
[16:03:16.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:16.280]                 }
[16:03:16.280]                 NAMES <- toupper(added)
[16:03:16.280]                 for (kk in seq_along(NAMES)) {
[16:03:16.280]                   name <- added[[kk]]
[16:03:16.280]                   NAME <- NAMES[[kk]]
[16:03:16.280]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.280]                     next
[16:03:16.280]                   args[[name]] <- ""
[16:03:16.280]                 }
[16:03:16.280]                 NAMES <- toupper(removed)
[16:03:16.280]                 for (kk in seq_along(NAMES)) {
[16:03:16.280]                   name <- removed[[kk]]
[16:03:16.280]                   NAME <- NAMES[[kk]]
[16:03:16.280]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.280]                     next
[16:03:16.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:16.280]                 }
[16:03:16.280]                 if (length(args) > 0) 
[16:03:16.280]                   base::do.call(base::Sys.setenv, args = args)
[16:03:16.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:16.280]             }
[16:03:16.280]             else {
[16:03:16.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:16.280]             }
[16:03:16.280]             {
[16:03:16.280]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:16.280]                   0L) {
[16:03:16.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:16.280]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:16.280]                   base::options(opts)
[16:03:16.280]                 }
[16:03:16.280]                 {
[16:03:16.280]                   {
[16:03:16.280]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:16.280]                     NULL
[16:03:16.280]                   }
[16:03:16.280]                   options(future.plan = NULL)
[16:03:16.280]                   if (is.na(NA_character_)) 
[16:03:16.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:16.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:16.280]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:16.280]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:16.280]                     envir = parent.frame()) 
[16:03:16.280]                   {
[16:03:16.280]                     if (is.function(workers)) 
[16:03:16.280]                       workers <- workers()
[16:03:16.280]                     workers <- structure(as.integer(workers), 
[16:03:16.280]                       class = class(workers))
[16:03:16.280]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:16.280]                       workers >= 1)
[16:03:16.280]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:16.280]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:16.280]                     }
[16:03:16.280]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:16.280]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:16.280]                       envir = envir)
[16:03:16.280]                     if (!future$lazy) 
[16:03:16.280]                       future <- run(future)
[16:03:16.280]                     invisible(future)
[16:03:16.280]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:16.280]                 }
[16:03:16.280]             }
[16:03:16.280]         }
[16:03:16.280]     })
[16:03:16.280]     if (TRUE) {
[16:03:16.280]         base::sink(type = "output", split = FALSE)
[16:03:16.280]         if (TRUE) {
[16:03:16.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:16.280]         }
[16:03:16.280]         else {
[16:03:16.280]             ...future.result["stdout"] <- base::list(NULL)
[16:03:16.280]         }
[16:03:16.280]         base::close(...future.stdout)
[16:03:16.280]         ...future.stdout <- NULL
[16:03:16.280]     }
[16:03:16.280]     ...future.result$conditions <- ...future.conditions
[16:03:16.280]     ...future.result$finished <- base::Sys.time()
[16:03:16.280]     ...future.result
[16:03:16.280] }
[16:03:16.334] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[16:03:16.334] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:16.339] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:16.339] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[16:03:16.339] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[16:03:16.340] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:16.340] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:16.340] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:16.383] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:16.383] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:16.427] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:16.427] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:03:16.428] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:03:16.428] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[16:03:16.428] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[16:03:16.429] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:16.429] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:16.429] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[16:03:16.429] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[16:03:16.430] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:16.430] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:16.433] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:16.433] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:16.433] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[16:03:16.434] MultisessionFuture started
[16:03:16.434] - Launch lazy future ... done
[16:03:16.434] run() for ‘MultisessionFuture’ ... done
[16:03:16.434] Created future:
[16:03:16.434] MultisessionFuture:
[16:03:16.434] Label: ‘future_vapply-2’
[16:03:16.434] Expression:
[16:03:16.434] {
[16:03:16.434]     do.call(function(...) {
[16:03:16.434]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.434]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:16.434]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.434]             on.exit(options(oopts), add = TRUE)
[16:03:16.434]         }
[16:03:16.434]         {
[16:03:16.434]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:16.434]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.434]                 ...future.FUN(...future.X_jj, ...)
[16:03:16.434]             })
[16:03:16.434]         }
[16:03:16.434]     }, args = future.call.arguments)
[16:03:16.434] }
[16:03:16.434] Lazy evaluation: FALSE
[16:03:16.434] Asynchronous evaluation: TRUE
[16:03:16.434] Local evaluation: TRUE
[16:03:16.434] Environment: R_GlobalEnv
[16:03:16.434] Capture standard output: TRUE
[16:03:16.434] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:16.434] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:16.434] Packages: 1 packages (‘future.apply’)
[16:03:16.434] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:16.434] Resolved: FALSE
[16:03:16.434] Value: <not collected>
[16:03:16.434] Conditions captured: <none>
[16:03:16.434] Early signaling: FALSE
[16:03:16.434] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:16.434] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:16.446] Chunk #2 of 2 ... DONE
[16:03:16.446] Launching 2 futures (chunks) ... DONE
[16:03:16.446] Resolving 2 futures (chunks) ...
[16:03:16.446] resolve() on list ...
[16:03:16.446]  recursive: 0
[16:03:16.447]  length: 2
[16:03:16.447] 
[16:03:16.447] receiveMessageFromWorker() for ClusterFuture ...
[16:03:16.447] - Validating connection of MultisessionFuture
[16:03:16.447] - received message: FutureResult
[16:03:16.448] - Received FutureResult
[16:03:16.448] - Erased future from FutureRegistry
[16:03:16.448] result() for ClusterFuture ...
[16:03:16.448] - result already collected: FutureResult
[16:03:16.448] result() for ClusterFuture ... done
[16:03:16.448] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:16.448] Future #1
[16:03:16.448] result() for ClusterFuture ...
[16:03:16.448] - result already collected: FutureResult
[16:03:16.448] result() for ClusterFuture ... done
[16:03:16.448] result() for ClusterFuture ...
[16:03:16.449] - result already collected: FutureResult
[16:03:16.449] result() for ClusterFuture ... done
[16:03:16.449] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:16.449] - nx: 2
[16:03:16.449] - relay: TRUE
[16:03:16.449] - stdout: TRUE
[16:03:16.449] - signal: TRUE
[16:03:16.449] - resignal: FALSE
[16:03:16.449] - force: TRUE
[16:03:16.449] - relayed: [n=2] FALSE, FALSE
[16:03:16.449] - queued futures: [n=2] FALSE, FALSE
[16:03:16.450]  - until=1
[16:03:16.450]  - relaying element #1
[16:03:16.450] result() for ClusterFuture ...
[16:03:16.450] - result already collected: FutureResult
[16:03:16.450] result() for ClusterFuture ... done
[16:03:16.450] result() for ClusterFuture ...
[16:03:16.450] - result already collected: FutureResult
[16:03:16.450] result() for ClusterFuture ... done
[16:03:16.450] result() for ClusterFuture ...
[16:03:16.450] - result already collected: FutureResult
[16:03:16.450] result() for ClusterFuture ... done
[16:03:16.450] result() for ClusterFuture ...
[16:03:16.451] - result already collected: FutureResult
[16:03:16.451] result() for ClusterFuture ... done
[16:03:16.451] - relayed: [n=2] TRUE, FALSE
[16:03:16.451] - queued futures: [n=2] TRUE, FALSE
[16:03:16.451] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:16.451]  length: 1 (resolved future 1)
[16:03:16.534] receiveMessageFromWorker() for ClusterFuture ...
[16:03:16.534] - Validating connection of MultisessionFuture
[16:03:16.534] - received message: FutureResult
[16:03:16.535] - Received FutureResult
[16:03:16.535] - Erased future from FutureRegistry
[16:03:16.535] result() for ClusterFuture ...
[16:03:16.535] - result already collected: FutureResult
[16:03:16.535] result() for ClusterFuture ... done
[16:03:16.535] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:16.535] Future #2
[16:03:16.535] result() for ClusterFuture ...
[16:03:16.535] - result already collected: FutureResult
[16:03:16.535] result() for ClusterFuture ... done
[16:03:16.536] result() for ClusterFuture ...
[16:03:16.536] - result already collected: FutureResult
[16:03:16.536] result() for ClusterFuture ... done
[16:03:16.536] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:16.536] - nx: 2
[16:03:16.536] - relay: TRUE
[16:03:16.536] - stdout: TRUE
[16:03:16.536] - signal: TRUE
[16:03:16.536] - resignal: FALSE
[16:03:16.536] - force: TRUE
[16:03:16.536] - relayed: [n=2] TRUE, FALSE
[16:03:16.537] - queued futures: [n=2] TRUE, FALSE
[16:03:16.537]  - until=2
[16:03:16.537]  - relaying element #2
[16:03:16.537] result() for ClusterFuture ...
[16:03:16.537] - result already collected: FutureResult
[16:03:16.537] result() for ClusterFuture ... done
[16:03:16.537] result() for ClusterFuture ...
[16:03:16.537] - result already collected: FutureResult
[16:03:16.537] result() for ClusterFuture ... done
[16:03:16.537] result() for ClusterFuture ...
[16:03:16.538] - result already collected: FutureResult
[16:03:16.538] result() for ClusterFuture ... done
[16:03:16.538] result() for ClusterFuture ...
[16:03:16.538] - result already collected: FutureResult
[16:03:16.538] result() for ClusterFuture ... done
[16:03:16.538] - relayed: [n=2] TRUE, TRUE
[16:03:16.538] - queued futures: [n=2] TRUE, TRUE
[16:03:16.538] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:16.538]  length: 0 (resolved future 2)
[16:03:16.538] Relaying remaining futures
[16:03:16.539] signalConditionsASAP(NULL, pos=0) ...
[16:03:16.539] - nx: 2
[16:03:16.539] - relay: TRUE
[16:03:16.539] - stdout: TRUE
[16:03:16.539] - signal: TRUE
[16:03:16.539] - resignal: FALSE
[16:03:16.539] - force: TRUE
[16:03:16.539] - relayed: [n=2] TRUE, TRUE
[16:03:16.539] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:16.539] - relayed: [n=2] TRUE, TRUE
[16:03:16.540] - queued futures: [n=2] TRUE, TRUE
[16:03:16.540] signalConditionsASAP(NULL, pos=0) ... done
[16:03:16.540] resolve() on list ... DONE
[16:03:16.540] result() for ClusterFuture ...
[16:03:16.540] - result already collected: FutureResult
[16:03:16.540] result() for ClusterFuture ... done
[16:03:16.540] result() for ClusterFuture ...
[16:03:16.540] - result already collected: FutureResult
[16:03:16.540] result() for ClusterFuture ... done
[16:03:16.540] result() for ClusterFuture ...
[16:03:16.540] - result already collected: FutureResult
[16:03:16.541] result() for ClusterFuture ... done
[16:03:16.541] result() for ClusterFuture ...
[16:03:16.541] - result already collected: FutureResult
[16:03:16.541] result() for ClusterFuture ... done
[16:03:16.541]  - Number of value chunks collected: 2
[16:03:16.541] Resolving 2 futures (chunks) ... DONE
[16:03:16.541] Reducing values from 2 chunks ...
[16:03:16.541]  - Number of values collected after concatenation: 2
[16:03:16.541]  - Number of values expected: 2
[16:03:16.541] Reducing values from 2 chunks ... DONE
[16:03:16.542] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[16:03:16.543] future_lapply() ...
[16:03:16.548] Number of chunks: 2
[16:03:16.548] getGlobalsAndPackagesXApply() ...
[16:03:16.548]  - future.globals: TRUE
[16:03:16.548] getGlobalsAndPackages() ...
[16:03:16.548] Searching for globals...
[16:03:16.552] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[16:03:16.552] Searching for globals ... DONE
[16:03:16.552] Resolving globals: FALSE
[16:03:16.553] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[16:03:16.553] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:16.553] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:16.554] - packages: [1] ‘future.apply’
[16:03:16.554] getGlobalsAndPackages() ... DONE
[16:03:16.554]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:16.554]  - needed namespaces: [n=1] ‘future.apply’
[16:03:16.554] Finding globals ... DONE
[16:03:16.554]  - use_args: TRUE
[16:03:16.554]  - Getting '...' globals ...
[16:03:16.555] resolve() on list ...
[16:03:16.555]  recursive: 0
[16:03:16.555]  length: 1
[16:03:16.555]  elements: ‘...’
[16:03:16.555]  length: 0 (resolved future 1)
[16:03:16.555] resolve() on list ... DONE
[16:03:16.555]    - '...' content: [n=0] 
[16:03:16.555] List of 1
[16:03:16.555]  $ ...: list()
[16:03:16.555]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:16.555]  - attr(*, "where")=List of 1
[16:03:16.555]   ..$ ...:<environment: 0x564e41ce0bd8> 
[16:03:16.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:16.555]  - attr(*, "resolved")= logi TRUE
[16:03:16.555]  - attr(*, "total_size")= num NA
[16:03:16.558]  - Getting '...' globals ... DONE
[16:03:16.558] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:16.558] List of 8
[16:03:16.558]  $ ...future.FUN:function (x, ...)  
[16:03:16.558]  $ x_FUN        :function (x)  
[16:03:16.558]  $ times        : int 0
[16:03:16.558]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:16.558]  $ stop_if_not  :function (...)  
[16:03:16.558]  $ dim          : NULL
[16:03:16.558]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:16.558]  $ ...          : list()
[16:03:16.558]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:16.558]  - attr(*, "where")=List of 8
[16:03:16.558]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:16.558]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:16.558]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:16.558]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:16.558]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:16.558]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:16.558]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:16.558]   ..$ ...          :<environment: 0x564e41ce0bd8> 
[16:03:16.558]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:16.558]  - attr(*, "resolved")= logi FALSE
[16:03:16.558]  - attr(*, "total_size")= num 95472
[16:03:16.563] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:16.563] getGlobalsAndPackagesXApply() ... DONE
[16:03:16.564] Number of futures (= number of chunks): 2
[16:03:16.564] Launching 2 futures (chunks) ...
[16:03:16.564] Chunk #1 of 2 ...
[16:03:16.564]  - Finding globals in 'X' for chunk #1 ...
[16:03:16.564] getGlobalsAndPackages() ...
[16:03:16.564] Searching for globals...
[16:03:16.564] 
[16:03:16.564] Searching for globals ... DONE
[16:03:16.564] - globals: [0] <none>
[16:03:16.565] getGlobalsAndPackages() ... DONE
[16:03:16.565]    + additional globals found: [n=0] 
[16:03:16.565]    + additional namespaces needed: [n=0] 
[16:03:16.565]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:16.565]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:16.565]  - seeds: <none>
[16:03:16.565]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.565] getGlobalsAndPackages() ...
[16:03:16.565] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.565] Resolving globals: FALSE
[16:03:16.566] Tweak future expression to call with '...' arguments ...
[16:03:16.566] {
[16:03:16.566]     do.call(function(...) {
[16:03:16.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:16.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.566]             on.exit(options(oopts), add = TRUE)
[16:03:16.566]         }
[16:03:16.566]         {
[16:03:16.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:16.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.566]                 ...future.FUN(...future.X_jj, ...)
[16:03:16.566]             })
[16:03:16.566]         }
[16:03:16.566]     }, args = future.call.arguments)
[16:03:16.566] }
[16:03:16.566] Tweak future expression to call with '...' arguments ... DONE
[16:03:16.566] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.566] - packages: [1] ‘future.apply’
[16:03:16.567] getGlobalsAndPackages() ... DONE
[16:03:16.567] run() for ‘Future’ ...
[16:03:16.567] - state: ‘created’
[16:03:16.567] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:16.581] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:16.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:16.581]   - Field: ‘node’
[16:03:16.581]   - Field: ‘label’
[16:03:16.581]   - Field: ‘local’
[16:03:16.581]   - Field: ‘owner’
[16:03:16.581]   - Field: ‘envir’
[16:03:16.582]   - Field: ‘workers’
[16:03:16.582]   - Field: ‘packages’
[16:03:16.582]   - Field: ‘gc’
[16:03:16.582]   - Field: ‘conditions’
[16:03:16.582]   - Field: ‘persistent’
[16:03:16.582]   - Field: ‘expr’
[16:03:16.582]   - Field: ‘uuid’
[16:03:16.582]   - Field: ‘seed’
[16:03:16.582]   - Field: ‘version’
[16:03:16.582]   - Field: ‘result’
[16:03:16.582]   - Field: ‘asynchronous’
[16:03:16.583]   - Field: ‘calls’
[16:03:16.583]   - Field: ‘globals’
[16:03:16.583]   - Field: ‘stdout’
[16:03:16.583]   - Field: ‘earlySignal’
[16:03:16.583]   - Field: ‘lazy’
[16:03:16.583]   - Field: ‘state’
[16:03:16.583] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:16.583] - Launch lazy future ...
[16:03:16.584] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:16.584] Packages needed by future strategies (n = 0): <none>
[16:03:16.584] {
[16:03:16.584]     {
[16:03:16.584]         {
[16:03:16.584]             ...future.startTime <- base::Sys.time()
[16:03:16.584]             {
[16:03:16.584]                 {
[16:03:16.584]                   {
[16:03:16.584]                     {
[16:03:16.584]                       {
[16:03:16.584]                         base::local({
[16:03:16.584]                           has_future <- base::requireNamespace("future", 
[16:03:16.584]                             quietly = TRUE)
[16:03:16.584]                           if (has_future) {
[16:03:16.584]                             ns <- base::getNamespace("future")
[16:03:16.584]                             version <- ns[[".package"]][["version"]]
[16:03:16.584]                             if (is.null(version)) 
[16:03:16.584]                               version <- utils::packageVersion("future")
[16:03:16.584]                           }
[16:03:16.584]                           else {
[16:03:16.584]                             version <- NULL
[16:03:16.584]                           }
[16:03:16.584]                           if (!has_future || version < "1.8.0") {
[16:03:16.584]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:16.584]                               "", base::R.version$version.string), 
[16:03:16.584]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:16.584]                                 base::R.version$platform, 8 * 
[16:03:16.584]                                   base::.Machine$sizeof.pointer), 
[16:03:16.584]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:16.584]                                 "release", "version")], collapse = " "), 
[16:03:16.584]                               hostname = base::Sys.info()[["nodename"]])
[16:03:16.584]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:16.584]                               info)
[16:03:16.584]                             info <- base::paste(info, collapse = "; ")
[16:03:16.584]                             if (!has_future) {
[16:03:16.584]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:16.584]                                 info)
[16:03:16.584]                             }
[16:03:16.584]                             else {
[16:03:16.584]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:16.584]                                 info, version)
[16:03:16.584]                             }
[16:03:16.584]                             base::stop(msg)
[16:03:16.584]                           }
[16:03:16.584]                         })
[16:03:16.584]                       }
[16:03:16.584]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:16.584]                       base::options(mc.cores = 1L)
[16:03:16.584]                     }
[16:03:16.584]                     base::local({
[16:03:16.584]                       for (pkg in "future.apply") {
[16:03:16.584]                         base::loadNamespace(pkg)
[16:03:16.584]                         base::library(pkg, character.only = TRUE)
[16:03:16.584]                       }
[16:03:16.584]                     })
[16:03:16.584]                   }
[16:03:16.584]                   options(future.plan = NULL)
[16:03:16.584]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:16.584]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:16.584]                 }
[16:03:16.584]                 ...future.workdir <- getwd()
[16:03:16.584]             }
[16:03:16.584]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:16.584]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:16.584]         }
[16:03:16.584]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:16.584]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:16.584]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:16.584]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:16.584]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:16.584]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:16.584]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:16.584]             base::names(...future.oldOptions))
[16:03:16.584]     }
[16:03:16.584]     if (FALSE) {
[16:03:16.584]     }
[16:03:16.584]     else {
[16:03:16.584]         if (TRUE) {
[16:03:16.584]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:16.584]                 open = "w")
[16:03:16.584]         }
[16:03:16.584]         else {
[16:03:16.584]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:16.584]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:16.584]         }
[16:03:16.584]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:16.584]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:16.584]             base::sink(type = "output", split = FALSE)
[16:03:16.584]             base::close(...future.stdout)
[16:03:16.584]         }, add = TRUE)
[16:03:16.584]     }
[16:03:16.584]     ...future.frame <- base::sys.nframe()
[16:03:16.584]     ...future.conditions <- base::list()
[16:03:16.584]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:16.584]     if (FALSE) {
[16:03:16.584]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:16.584]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:16.584]     }
[16:03:16.584]     ...future.result <- base::tryCatch({
[16:03:16.584]         base::withCallingHandlers({
[16:03:16.584]             ...future.value <- base::withVisible(base::local({
[16:03:16.584]                 ...future.makeSendCondition <- base::local({
[16:03:16.584]                   sendCondition <- NULL
[16:03:16.584]                   function(frame = 1L) {
[16:03:16.584]                     if (is.function(sendCondition)) 
[16:03:16.584]                       return(sendCondition)
[16:03:16.584]                     ns <- getNamespace("parallel")
[16:03:16.584]                     if (exists("sendData", mode = "function", 
[16:03:16.584]                       envir = ns)) {
[16:03:16.584]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:16.584]                         envir = ns)
[16:03:16.584]                       envir <- sys.frame(frame)
[16:03:16.584]                       master <- NULL
[16:03:16.584]                       while (!identical(envir, .GlobalEnv) && 
[16:03:16.584]                         !identical(envir, emptyenv())) {
[16:03:16.584]                         if (exists("master", mode = "list", envir = envir, 
[16:03:16.584]                           inherits = FALSE)) {
[16:03:16.584]                           master <- get("master", mode = "list", 
[16:03:16.584]                             envir = envir, inherits = FALSE)
[16:03:16.584]                           if (inherits(master, c("SOCKnode", 
[16:03:16.584]                             "SOCK0node"))) {
[16:03:16.584]                             sendCondition <<- function(cond) {
[16:03:16.584]                               data <- list(type = "VALUE", value = cond, 
[16:03:16.584]                                 success = TRUE)
[16:03:16.584]                               parallel_sendData(master, data)
[16:03:16.584]                             }
[16:03:16.584]                             return(sendCondition)
[16:03:16.584]                           }
[16:03:16.584]                         }
[16:03:16.584]                         frame <- frame + 1L
[16:03:16.584]                         envir <- sys.frame(frame)
[16:03:16.584]                       }
[16:03:16.584]                     }
[16:03:16.584]                     sendCondition <<- function(cond) NULL
[16:03:16.584]                   }
[16:03:16.584]                 })
[16:03:16.584]                 withCallingHandlers({
[16:03:16.584]                   {
[16:03:16.584]                     do.call(function(...) {
[16:03:16.584]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.584]                       if (!identical(...future.globals.maxSize.org, 
[16:03:16.584]                         ...future.globals.maxSize)) {
[16:03:16.584]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.584]                         on.exit(options(oopts), add = TRUE)
[16:03:16.584]                       }
[16:03:16.584]                       {
[16:03:16.584]                         lapply(seq_along(...future.elements_ii), 
[16:03:16.584]                           FUN = function(jj) {
[16:03:16.584]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.584]                             ...future.FUN(...future.X_jj, ...)
[16:03:16.584]                           })
[16:03:16.584]                       }
[16:03:16.584]                     }, args = future.call.arguments)
[16:03:16.584]                   }
[16:03:16.584]                 }, immediateCondition = function(cond) {
[16:03:16.584]                   sendCondition <- ...future.makeSendCondition()
[16:03:16.584]                   sendCondition(cond)
[16:03:16.584]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.584]                   {
[16:03:16.584]                     inherits <- base::inherits
[16:03:16.584]                     invokeRestart <- base::invokeRestart
[16:03:16.584]                     is.null <- base::is.null
[16:03:16.584]                     muffled <- FALSE
[16:03:16.584]                     if (inherits(cond, "message")) {
[16:03:16.584]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:16.584]                       if (muffled) 
[16:03:16.584]                         invokeRestart("muffleMessage")
[16:03:16.584]                     }
[16:03:16.584]                     else if (inherits(cond, "warning")) {
[16:03:16.584]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:16.584]                       if (muffled) 
[16:03:16.584]                         invokeRestart("muffleWarning")
[16:03:16.584]                     }
[16:03:16.584]                     else if (inherits(cond, "condition")) {
[16:03:16.584]                       if (!is.null(pattern)) {
[16:03:16.584]                         computeRestarts <- base::computeRestarts
[16:03:16.584]                         grepl <- base::grepl
[16:03:16.584]                         restarts <- computeRestarts(cond)
[16:03:16.584]                         for (restart in restarts) {
[16:03:16.584]                           name <- restart$name
[16:03:16.584]                           if (is.null(name)) 
[16:03:16.584]                             next
[16:03:16.584]                           if (!grepl(pattern, name)) 
[16:03:16.584]                             next
[16:03:16.584]                           invokeRestart(restart)
[16:03:16.584]                           muffled <- TRUE
[16:03:16.584]                           break
[16:03:16.584]                         }
[16:03:16.584]                       }
[16:03:16.584]                     }
[16:03:16.584]                     invisible(muffled)
[16:03:16.584]                   }
[16:03:16.584]                   muffleCondition(cond)
[16:03:16.584]                 })
[16:03:16.584]             }))
[16:03:16.584]             future::FutureResult(value = ...future.value$value, 
[16:03:16.584]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:16.584]                   ...future.rng), globalenv = if (FALSE) 
[16:03:16.584]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:16.584]                     ...future.globalenv.names))
[16:03:16.584]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:16.584]         }, condition = base::local({
[16:03:16.584]             c <- base::c
[16:03:16.584]             inherits <- base::inherits
[16:03:16.584]             invokeRestart <- base::invokeRestart
[16:03:16.584]             length <- base::length
[16:03:16.584]             list <- base::list
[16:03:16.584]             seq.int <- base::seq.int
[16:03:16.584]             signalCondition <- base::signalCondition
[16:03:16.584]             sys.calls <- base::sys.calls
[16:03:16.584]             `[[` <- base::`[[`
[16:03:16.584]             `+` <- base::`+`
[16:03:16.584]             `<<-` <- base::`<<-`
[16:03:16.584]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:16.584]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:16.584]                   3L)]
[16:03:16.584]             }
[16:03:16.584]             function(cond) {
[16:03:16.584]                 is_error <- inherits(cond, "error")
[16:03:16.584]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:16.584]                   NULL)
[16:03:16.584]                 if (is_error) {
[16:03:16.584]                   sessionInformation <- function() {
[16:03:16.584]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:16.584]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:16.584]                       search = base::search(), system = base::Sys.info())
[16:03:16.584]                   }
[16:03:16.584]                   ...future.conditions[[length(...future.conditions) + 
[16:03:16.584]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:16.584]                     cond$call), session = sessionInformation(), 
[16:03:16.584]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:16.584]                   signalCondition(cond)
[16:03:16.584]                 }
[16:03:16.584]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:16.584]                 "immediateCondition"))) {
[16:03:16.584]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:16.584]                   ...future.conditions[[length(...future.conditions) + 
[16:03:16.584]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:16.584]                   if (TRUE && !signal) {
[16:03:16.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.584]                     {
[16:03:16.584]                       inherits <- base::inherits
[16:03:16.584]                       invokeRestart <- base::invokeRestart
[16:03:16.584]                       is.null <- base::is.null
[16:03:16.584]                       muffled <- FALSE
[16:03:16.584]                       if (inherits(cond, "message")) {
[16:03:16.584]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:16.584]                         if (muffled) 
[16:03:16.584]                           invokeRestart("muffleMessage")
[16:03:16.584]                       }
[16:03:16.584]                       else if (inherits(cond, "warning")) {
[16:03:16.584]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:16.584]                         if (muffled) 
[16:03:16.584]                           invokeRestart("muffleWarning")
[16:03:16.584]                       }
[16:03:16.584]                       else if (inherits(cond, "condition")) {
[16:03:16.584]                         if (!is.null(pattern)) {
[16:03:16.584]                           computeRestarts <- base::computeRestarts
[16:03:16.584]                           grepl <- base::grepl
[16:03:16.584]                           restarts <- computeRestarts(cond)
[16:03:16.584]                           for (restart in restarts) {
[16:03:16.584]                             name <- restart$name
[16:03:16.584]                             if (is.null(name)) 
[16:03:16.584]                               next
[16:03:16.584]                             if (!grepl(pattern, name)) 
[16:03:16.584]                               next
[16:03:16.584]                             invokeRestart(restart)
[16:03:16.584]                             muffled <- TRUE
[16:03:16.584]                             break
[16:03:16.584]                           }
[16:03:16.584]                         }
[16:03:16.584]                       }
[16:03:16.584]                       invisible(muffled)
[16:03:16.584]                     }
[16:03:16.584]                     muffleCondition(cond, pattern = "^muffle")
[16:03:16.584]                   }
[16:03:16.584]                 }
[16:03:16.584]                 else {
[16:03:16.584]                   if (TRUE) {
[16:03:16.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.584]                     {
[16:03:16.584]                       inherits <- base::inherits
[16:03:16.584]                       invokeRestart <- base::invokeRestart
[16:03:16.584]                       is.null <- base::is.null
[16:03:16.584]                       muffled <- FALSE
[16:03:16.584]                       if (inherits(cond, "message")) {
[16:03:16.584]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:16.584]                         if (muffled) 
[16:03:16.584]                           invokeRestart("muffleMessage")
[16:03:16.584]                       }
[16:03:16.584]                       else if (inherits(cond, "warning")) {
[16:03:16.584]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:16.584]                         if (muffled) 
[16:03:16.584]                           invokeRestart("muffleWarning")
[16:03:16.584]                       }
[16:03:16.584]                       else if (inherits(cond, "condition")) {
[16:03:16.584]                         if (!is.null(pattern)) {
[16:03:16.584]                           computeRestarts <- base::computeRestarts
[16:03:16.584]                           grepl <- base::grepl
[16:03:16.584]                           restarts <- computeRestarts(cond)
[16:03:16.584]                           for (restart in restarts) {
[16:03:16.584]                             name <- restart$name
[16:03:16.584]                             if (is.null(name)) 
[16:03:16.584]                               next
[16:03:16.584]                             if (!grepl(pattern, name)) 
[16:03:16.584]                               next
[16:03:16.584]                             invokeRestart(restart)
[16:03:16.584]                             muffled <- TRUE
[16:03:16.584]                             break
[16:03:16.584]                           }
[16:03:16.584]                         }
[16:03:16.584]                       }
[16:03:16.584]                       invisible(muffled)
[16:03:16.584]                     }
[16:03:16.584]                     muffleCondition(cond, pattern = "^muffle")
[16:03:16.584]                   }
[16:03:16.584]                 }
[16:03:16.584]             }
[16:03:16.584]         }))
[16:03:16.584]     }, error = function(ex) {
[16:03:16.584]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:16.584]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:16.584]                 ...future.rng), started = ...future.startTime, 
[16:03:16.584]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:16.584]             version = "1.8"), class = "FutureResult")
[16:03:16.584]     }, finally = {
[16:03:16.584]         if (!identical(...future.workdir, getwd())) 
[16:03:16.584]             setwd(...future.workdir)
[16:03:16.584]         {
[16:03:16.584]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:16.584]                 ...future.oldOptions$nwarnings <- NULL
[16:03:16.584]             }
[16:03:16.584]             base::options(...future.oldOptions)
[16:03:16.584]             if (.Platform$OS.type == "windows") {
[16:03:16.584]                 old_names <- names(...future.oldEnvVars)
[16:03:16.584]                 envs <- base::Sys.getenv()
[16:03:16.584]                 names <- names(envs)
[16:03:16.584]                 common <- intersect(names, old_names)
[16:03:16.584]                 added <- setdiff(names, old_names)
[16:03:16.584]                 removed <- setdiff(old_names, names)
[16:03:16.584]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:16.584]                   envs[common]]
[16:03:16.584]                 NAMES <- toupper(changed)
[16:03:16.584]                 args <- list()
[16:03:16.584]                 for (kk in seq_along(NAMES)) {
[16:03:16.584]                   name <- changed[[kk]]
[16:03:16.584]                   NAME <- NAMES[[kk]]
[16:03:16.584]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.584]                     next
[16:03:16.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:16.584]                 }
[16:03:16.584]                 NAMES <- toupper(added)
[16:03:16.584]                 for (kk in seq_along(NAMES)) {
[16:03:16.584]                   name <- added[[kk]]
[16:03:16.584]                   NAME <- NAMES[[kk]]
[16:03:16.584]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.584]                     next
[16:03:16.584]                   args[[name]] <- ""
[16:03:16.584]                 }
[16:03:16.584]                 NAMES <- toupper(removed)
[16:03:16.584]                 for (kk in seq_along(NAMES)) {
[16:03:16.584]                   name <- removed[[kk]]
[16:03:16.584]                   NAME <- NAMES[[kk]]
[16:03:16.584]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.584]                     next
[16:03:16.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:16.584]                 }
[16:03:16.584]                 if (length(args) > 0) 
[16:03:16.584]                   base::do.call(base::Sys.setenv, args = args)
[16:03:16.584]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:16.584]             }
[16:03:16.584]             else {
[16:03:16.584]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:16.584]             }
[16:03:16.584]             {
[16:03:16.584]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:16.584]                   0L) {
[16:03:16.584]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:16.584]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:16.584]                   base::options(opts)
[16:03:16.584]                 }
[16:03:16.584]                 {
[16:03:16.584]                   {
[16:03:16.584]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:16.584]                     NULL
[16:03:16.584]                   }
[16:03:16.584]                   options(future.plan = NULL)
[16:03:16.584]                   if (is.na(NA_character_)) 
[16:03:16.584]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:16.584]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:16.584]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:16.584]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:16.584]                     envir = parent.frame()) 
[16:03:16.584]                   {
[16:03:16.584]                     if (is.function(workers)) 
[16:03:16.584]                       workers <- workers()
[16:03:16.584]                     workers <- structure(as.integer(workers), 
[16:03:16.584]                       class = class(workers))
[16:03:16.584]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:16.584]                       workers >= 1)
[16:03:16.584]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:16.584]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:16.584]                     }
[16:03:16.584]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:16.584]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:16.584]                       envir = envir)
[16:03:16.584]                     if (!future$lazy) 
[16:03:16.584]                       future <- run(future)
[16:03:16.584]                     invisible(future)
[16:03:16.584]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:16.584]                 }
[16:03:16.584]             }
[16:03:16.584]         }
[16:03:16.584]     })
[16:03:16.584]     if (TRUE) {
[16:03:16.584]         base::sink(type = "output", split = FALSE)
[16:03:16.584]         if (TRUE) {
[16:03:16.584]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:16.584]         }
[16:03:16.584]         else {
[16:03:16.584]             ...future.result["stdout"] <- base::list(NULL)
[16:03:16.584]         }
[16:03:16.584]         base::close(...future.stdout)
[16:03:16.584]         ...future.stdout <- NULL
[16:03:16.584]     }
[16:03:16.584]     ...future.result$conditions <- ...future.conditions
[16:03:16.584]     ...future.result$finished <- base::Sys.time()
[16:03:16.584]     ...future.result
[16:03:16.584] }
[16:03:16.587] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[16:03:16.587] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:16.631] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:16.631] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[16:03:16.632] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[16:03:16.632] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:16.632] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:16.632] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:16.675] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:16.675] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:16.719] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:16.719] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:03:16.720] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:03:16.720] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:03:16.720] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:03:16.720] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:16.721] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:16.721] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:03:16.721] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:03:16.721] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:16.722] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:16.722] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:16.722] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:16.722] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[16:03:16.723] MultisessionFuture started
[16:03:16.723] - Launch lazy future ... done
[16:03:16.724] run() for ‘MultisessionFuture’ ... done
[16:03:16.724] Created future:
[16:03:16.724] MultisessionFuture:
[16:03:16.724] Label: ‘future_vapply-1’
[16:03:16.724] Expression:
[16:03:16.724] {
[16:03:16.724]     do.call(function(...) {
[16:03:16.724]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.724]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:16.724]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.724]             on.exit(options(oopts), add = TRUE)
[16:03:16.724]         }
[16:03:16.724]         {
[16:03:16.724]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:16.724]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.724]                 ...future.FUN(...future.X_jj, ...)
[16:03:16.724]             })
[16:03:16.724]         }
[16:03:16.724]     }, args = future.call.arguments)
[16:03:16.724] }
[16:03:16.724] Lazy evaluation: FALSE
[16:03:16.724] Asynchronous evaluation: TRUE
[16:03:16.724] Local evaluation: TRUE
[16:03:16.724] Environment: R_GlobalEnv
[16:03:16.724] Capture standard output: TRUE
[16:03:16.724] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:16.724] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:16.724] Packages: 1 packages (‘future.apply’)
[16:03:16.724] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:16.724] Resolved: FALSE
[16:03:16.724] Value: <not collected>
[16:03:16.724] Conditions captured: <none>
[16:03:16.724] Early signaling: FALSE
[16:03:16.724] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:16.724] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:16.736] Chunk #1 of 2 ... DONE
[16:03:16.736] Chunk #2 of 2 ...
[16:03:16.736]  - Finding globals in 'X' for chunk #2 ...
[16:03:16.736] getGlobalsAndPackages() ...
[16:03:16.736] Searching for globals...
[16:03:16.736] 
[16:03:16.736] Searching for globals ... DONE
[16:03:16.737] - globals: [0] <none>
[16:03:16.737] getGlobalsAndPackages() ... DONE
[16:03:16.737]    + additional globals found: [n=0] 
[16:03:16.737]    + additional namespaces needed: [n=0] 
[16:03:16.737]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:16.737]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:16.737]  - seeds: <none>
[16:03:16.737]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.737] getGlobalsAndPackages() ...
[16:03:16.737] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.737] Resolving globals: FALSE
[16:03:16.738] Tweak future expression to call with '...' arguments ...
[16:03:16.738] {
[16:03:16.738]     do.call(function(...) {
[16:03:16.738]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.738]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:16.738]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.738]             on.exit(options(oopts), add = TRUE)
[16:03:16.738]         }
[16:03:16.738]         {
[16:03:16.738]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:16.738]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.738]                 ...future.FUN(...future.X_jj, ...)
[16:03:16.738]             })
[16:03:16.738]         }
[16:03:16.738]     }, args = future.call.arguments)
[16:03:16.738] }
[16:03:16.738] Tweak future expression to call with '...' arguments ... DONE
[16:03:16.739] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.739] - packages: [1] ‘future.apply’
[16:03:16.739] getGlobalsAndPackages() ... DONE
[16:03:16.739] run() for ‘Future’ ...
[16:03:16.739] - state: ‘created’
[16:03:16.739] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:16.753] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:16.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:16.753]   - Field: ‘node’
[16:03:16.753]   - Field: ‘label’
[16:03:16.753]   - Field: ‘local’
[16:03:16.754]   - Field: ‘owner’
[16:03:16.754]   - Field: ‘envir’
[16:03:16.754]   - Field: ‘workers’
[16:03:16.754]   - Field: ‘packages’
[16:03:16.754]   - Field: ‘gc’
[16:03:16.754]   - Field: ‘conditions’
[16:03:16.754]   - Field: ‘persistent’
[16:03:16.754]   - Field: ‘expr’
[16:03:16.754]   - Field: ‘uuid’
[16:03:16.754]   - Field: ‘seed’
[16:03:16.754]   - Field: ‘version’
[16:03:16.755]   - Field: ‘result’
[16:03:16.755]   - Field: ‘asynchronous’
[16:03:16.755]   - Field: ‘calls’
[16:03:16.755]   - Field: ‘globals’
[16:03:16.755]   - Field: ‘stdout’
[16:03:16.755]   - Field: ‘earlySignal’
[16:03:16.755]   - Field: ‘lazy’
[16:03:16.755]   - Field: ‘state’
[16:03:16.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:16.755] - Launch lazy future ...
[16:03:16.756] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:16.756] Packages needed by future strategies (n = 0): <none>
[16:03:16.756] {
[16:03:16.756]     {
[16:03:16.756]         {
[16:03:16.756]             ...future.startTime <- base::Sys.time()
[16:03:16.756]             {
[16:03:16.756]                 {
[16:03:16.756]                   {
[16:03:16.756]                     {
[16:03:16.756]                       {
[16:03:16.756]                         base::local({
[16:03:16.756]                           has_future <- base::requireNamespace("future", 
[16:03:16.756]                             quietly = TRUE)
[16:03:16.756]                           if (has_future) {
[16:03:16.756]                             ns <- base::getNamespace("future")
[16:03:16.756]                             version <- ns[[".package"]][["version"]]
[16:03:16.756]                             if (is.null(version)) 
[16:03:16.756]                               version <- utils::packageVersion("future")
[16:03:16.756]                           }
[16:03:16.756]                           else {
[16:03:16.756]                             version <- NULL
[16:03:16.756]                           }
[16:03:16.756]                           if (!has_future || version < "1.8.0") {
[16:03:16.756]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:16.756]                               "", base::R.version$version.string), 
[16:03:16.756]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:16.756]                                 base::R.version$platform, 8 * 
[16:03:16.756]                                   base::.Machine$sizeof.pointer), 
[16:03:16.756]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:16.756]                                 "release", "version")], collapse = " "), 
[16:03:16.756]                               hostname = base::Sys.info()[["nodename"]])
[16:03:16.756]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:16.756]                               info)
[16:03:16.756]                             info <- base::paste(info, collapse = "; ")
[16:03:16.756]                             if (!has_future) {
[16:03:16.756]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:16.756]                                 info)
[16:03:16.756]                             }
[16:03:16.756]                             else {
[16:03:16.756]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:16.756]                                 info, version)
[16:03:16.756]                             }
[16:03:16.756]                             base::stop(msg)
[16:03:16.756]                           }
[16:03:16.756]                         })
[16:03:16.756]                       }
[16:03:16.756]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:16.756]                       base::options(mc.cores = 1L)
[16:03:16.756]                     }
[16:03:16.756]                     base::local({
[16:03:16.756]                       for (pkg in "future.apply") {
[16:03:16.756]                         base::loadNamespace(pkg)
[16:03:16.756]                         base::library(pkg, character.only = TRUE)
[16:03:16.756]                       }
[16:03:16.756]                     })
[16:03:16.756]                   }
[16:03:16.756]                   options(future.plan = NULL)
[16:03:16.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:16.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:16.756]                 }
[16:03:16.756]                 ...future.workdir <- getwd()
[16:03:16.756]             }
[16:03:16.756]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:16.756]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:16.756]         }
[16:03:16.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:16.756]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:16.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:16.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:16.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:16.756]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:16.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:16.756]             base::names(...future.oldOptions))
[16:03:16.756]     }
[16:03:16.756]     if (FALSE) {
[16:03:16.756]     }
[16:03:16.756]     else {
[16:03:16.756]         if (TRUE) {
[16:03:16.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:16.756]                 open = "w")
[16:03:16.756]         }
[16:03:16.756]         else {
[16:03:16.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:16.756]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:16.756]         }
[16:03:16.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:16.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:16.756]             base::sink(type = "output", split = FALSE)
[16:03:16.756]             base::close(...future.stdout)
[16:03:16.756]         }, add = TRUE)
[16:03:16.756]     }
[16:03:16.756]     ...future.frame <- base::sys.nframe()
[16:03:16.756]     ...future.conditions <- base::list()
[16:03:16.756]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:16.756]     if (FALSE) {
[16:03:16.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:16.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:16.756]     }
[16:03:16.756]     ...future.result <- base::tryCatch({
[16:03:16.756]         base::withCallingHandlers({
[16:03:16.756]             ...future.value <- base::withVisible(base::local({
[16:03:16.756]                 ...future.makeSendCondition <- base::local({
[16:03:16.756]                   sendCondition <- NULL
[16:03:16.756]                   function(frame = 1L) {
[16:03:16.756]                     if (is.function(sendCondition)) 
[16:03:16.756]                       return(sendCondition)
[16:03:16.756]                     ns <- getNamespace("parallel")
[16:03:16.756]                     if (exists("sendData", mode = "function", 
[16:03:16.756]                       envir = ns)) {
[16:03:16.756]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:16.756]                         envir = ns)
[16:03:16.756]                       envir <- sys.frame(frame)
[16:03:16.756]                       master <- NULL
[16:03:16.756]                       while (!identical(envir, .GlobalEnv) && 
[16:03:16.756]                         !identical(envir, emptyenv())) {
[16:03:16.756]                         if (exists("master", mode = "list", envir = envir, 
[16:03:16.756]                           inherits = FALSE)) {
[16:03:16.756]                           master <- get("master", mode = "list", 
[16:03:16.756]                             envir = envir, inherits = FALSE)
[16:03:16.756]                           if (inherits(master, c("SOCKnode", 
[16:03:16.756]                             "SOCK0node"))) {
[16:03:16.756]                             sendCondition <<- function(cond) {
[16:03:16.756]                               data <- list(type = "VALUE", value = cond, 
[16:03:16.756]                                 success = TRUE)
[16:03:16.756]                               parallel_sendData(master, data)
[16:03:16.756]                             }
[16:03:16.756]                             return(sendCondition)
[16:03:16.756]                           }
[16:03:16.756]                         }
[16:03:16.756]                         frame <- frame + 1L
[16:03:16.756]                         envir <- sys.frame(frame)
[16:03:16.756]                       }
[16:03:16.756]                     }
[16:03:16.756]                     sendCondition <<- function(cond) NULL
[16:03:16.756]                   }
[16:03:16.756]                 })
[16:03:16.756]                 withCallingHandlers({
[16:03:16.756]                   {
[16:03:16.756]                     do.call(function(...) {
[16:03:16.756]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.756]                       if (!identical(...future.globals.maxSize.org, 
[16:03:16.756]                         ...future.globals.maxSize)) {
[16:03:16.756]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.756]                         on.exit(options(oopts), add = TRUE)
[16:03:16.756]                       }
[16:03:16.756]                       {
[16:03:16.756]                         lapply(seq_along(...future.elements_ii), 
[16:03:16.756]                           FUN = function(jj) {
[16:03:16.756]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.756]                             ...future.FUN(...future.X_jj, ...)
[16:03:16.756]                           })
[16:03:16.756]                       }
[16:03:16.756]                     }, args = future.call.arguments)
[16:03:16.756]                   }
[16:03:16.756]                 }, immediateCondition = function(cond) {
[16:03:16.756]                   sendCondition <- ...future.makeSendCondition()
[16:03:16.756]                   sendCondition(cond)
[16:03:16.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.756]                   {
[16:03:16.756]                     inherits <- base::inherits
[16:03:16.756]                     invokeRestart <- base::invokeRestart
[16:03:16.756]                     is.null <- base::is.null
[16:03:16.756]                     muffled <- FALSE
[16:03:16.756]                     if (inherits(cond, "message")) {
[16:03:16.756]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:16.756]                       if (muffled) 
[16:03:16.756]                         invokeRestart("muffleMessage")
[16:03:16.756]                     }
[16:03:16.756]                     else if (inherits(cond, "warning")) {
[16:03:16.756]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:16.756]                       if (muffled) 
[16:03:16.756]                         invokeRestart("muffleWarning")
[16:03:16.756]                     }
[16:03:16.756]                     else if (inherits(cond, "condition")) {
[16:03:16.756]                       if (!is.null(pattern)) {
[16:03:16.756]                         computeRestarts <- base::computeRestarts
[16:03:16.756]                         grepl <- base::grepl
[16:03:16.756]                         restarts <- computeRestarts(cond)
[16:03:16.756]                         for (restart in restarts) {
[16:03:16.756]                           name <- restart$name
[16:03:16.756]                           if (is.null(name)) 
[16:03:16.756]                             next
[16:03:16.756]                           if (!grepl(pattern, name)) 
[16:03:16.756]                             next
[16:03:16.756]                           invokeRestart(restart)
[16:03:16.756]                           muffled <- TRUE
[16:03:16.756]                           break
[16:03:16.756]                         }
[16:03:16.756]                       }
[16:03:16.756]                     }
[16:03:16.756]                     invisible(muffled)
[16:03:16.756]                   }
[16:03:16.756]                   muffleCondition(cond)
[16:03:16.756]                 })
[16:03:16.756]             }))
[16:03:16.756]             future::FutureResult(value = ...future.value$value, 
[16:03:16.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:16.756]                   ...future.rng), globalenv = if (FALSE) 
[16:03:16.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:16.756]                     ...future.globalenv.names))
[16:03:16.756]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:16.756]         }, condition = base::local({
[16:03:16.756]             c <- base::c
[16:03:16.756]             inherits <- base::inherits
[16:03:16.756]             invokeRestart <- base::invokeRestart
[16:03:16.756]             length <- base::length
[16:03:16.756]             list <- base::list
[16:03:16.756]             seq.int <- base::seq.int
[16:03:16.756]             signalCondition <- base::signalCondition
[16:03:16.756]             sys.calls <- base::sys.calls
[16:03:16.756]             `[[` <- base::`[[`
[16:03:16.756]             `+` <- base::`+`
[16:03:16.756]             `<<-` <- base::`<<-`
[16:03:16.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:16.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:16.756]                   3L)]
[16:03:16.756]             }
[16:03:16.756]             function(cond) {
[16:03:16.756]                 is_error <- inherits(cond, "error")
[16:03:16.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:16.756]                   NULL)
[16:03:16.756]                 if (is_error) {
[16:03:16.756]                   sessionInformation <- function() {
[16:03:16.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:16.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:16.756]                       search = base::search(), system = base::Sys.info())
[16:03:16.756]                   }
[16:03:16.756]                   ...future.conditions[[length(...future.conditions) + 
[16:03:16.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:16.756]                     cond$call), session = sessionInformation(), 
[16:03:16.756]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:16.756]                   signalCondition(cond)
[16:03:16.756]                 }
[16:03:16.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:16.756]                 "immediateCondition"))) {
[16:03:16.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:16.756]                   ...future.conditions[[length(...future.conditions) + 
[16:03:16.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:16.756]                   if (TRUE && !signal) {
[16:03:16.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.756]                     {
[16:03:16.756]                       inherits <- base::inherits
[16:03:16.756]                       invokeRestart <- base::invokeRestart
[16:03:16.756]                       is.null <- base::is.null
[16:03:16.756]                       muffled <- FALSE
[16:03:16.756]                       if (inherits(cond, "message")) {
[16:03:16.756]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:16.756]                         if (muffled) 
[16:03:16.756]                           invokeRestart("muffleMessage")
[16:03:16.756]                       }
[16:03:16.756]                       else if (inherits(cond, "warning")) {
[16:03:16.756]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:16.756]                         if (muffled) 
[16:03:16.756]                           invokeRestart("muffleWarning")
[16:03:16.756]                       }
[16:03:16.756]                       else if (inherits(cond, "condition")) {
[16:03:16.756]                         if (!is.null(pattern)) {
[16:03:16.756]                           computeRestarts <- base::computeRestarts
[16:03:16.756]                           grepl <- base::grepl
[16:03:16.756]                           restarts <- computeRestarts(cond)
[16:03:16.756]                           for (restart in restarts) {
[16:03:16.756]                             name <- restart$name
[16:03:16.756]                             if (is.null(name)) 
[16:03:16.756]                               next
[16:03:16.756]                             if (!grepl(pattern, name)) 
[16:03:16.756]                               next
[16:03:16.756]                             invokeRestart(restart)
[16:03:16.756]                             muffled <- TRUE
[16:03:16.756]                             break
[16:03:16.756]                           }
[16:03:16.756]                         }
[16:03:16.756]                       }
[16:03:16.756]                       invisible(muffled)
[16:03:16.756]                     }
[16:03:16.756]                     muffleCondition(cond, pattern = "^muffle")
[16:03:16.756]                   }
[16:03:16.756]                 }
[16:03:16.756]                 else {
[16:03:16.756]                   if (TRUE) {
[16:03:16.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:16.756]                     {
[16:03:16.756]                       inherits <- base::inherits
[16:03:16.756]                       invokeRestart <- base::invokeRestart
[16:03:16.756]                       is.null <- base::is.null
[16:03:16.756]                       muffled <- FALSE
[16:03:16.756]                       if (inherits(cond, "message")) {
[16:03:16.756]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:16.756]                         if (muffled) 
[16:03:16.756]                           invokeRestart("muffleMessage")
[16:03:16.756]                       }
[16:03:16.756]                       else if (inherits(cond, "warning")) {
[16:03:16.756]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:16.756]                         if (muffled) 
[16:03:16.756]                           invokeRestart("muffleWarning")
[16:03:16.756]                       }
[16:03:16.756]                       else if (inherits(cond, "condition")) {
[16:03:16.756]                         if (!is.null(pattern)) {
[16:03:16.756]                           computeRestarts <- base::computeRestarts
[16:03:16.756]                           grepl <- base::grepl
[16:03:16.756]                           restarts <- computeRestarts(cond)
[16:03:16.756]                           for (restart in restarts) {
[16:03:16.756]                             name <- restart$name
[16:03:16.756]                             if (is.null(name)) 
[16:03:16.756]                               next
[16:03:16.756]                             if (!grepl(pattern, name)) 
[16:03:16.756]                               next
[16:03:16.756]                             invokeRestart(restart)
[16:03:16.756]                             muffled <- TRUE
[16:03:16.756]                             break
[16:03:16.756]                           }
[16:03:16.756]                         }
[16:03:16.756]                       }
[16:03:16.756]                       invisible(muffled)
[16:03:16.756]                     }
[16:03:16.756]                     muffleCondition(cond, pattern = "^muffle")
[16:03:16.756]                   }
[16:03:16.756]                 }
[16:03:16.756]             }
[16:03:16.756]         }))
[16:03:16.756]     }, error = function(ex) {
[16:03:16.756]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:16.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:16.756]                 ...future.rng), started = ...future.startTime, 
[16:03:16.756]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:16.756]             version = "1.8"), class = "FutureResult")
[16:03:16.756]     }, finally = {
[16:03:16.756]         if (!identical(...future.workdir, getwd())) 
[16:03:16.756]             setwd(...future.workdir)
[16:03:16.756]         {
[16:03:16.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:16.756]                 ...future.oldOptions$nwarnings <- NULL
[16:03:16.756]             }
[16:03:16.756]             base::options(...future.oldOptions)
[16:03:16.756]             if (.Platform$OS.type == "windows") {
[16:03:16.756]                 old_names <- names(...future.oldEnvVars)
[16:03:16.756]                 envs <- base::Sys.getenv()
[16:03:16.756]                 names <- names(envs)
[16:03:16.756]                 common <- intersect(names, old_names)
[16:03:16.756]                 added <- setdiff(names, old_names)
[16:03:16.756]                 removed <- setdiff(old_names, names)
[16:03:16.756]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:16.756]                   envs[common]]
[16:03:16.756]                 NAMES <- toupper(changed)
[16:03:16.756]                 args <- list()
[16:03:16.756]                 for (kk in seq_along(NAMES)) {
[16:03:16.756]                   name <- changed[[kk]]
[16:03:16.756]                   NAME <- NAMES[[kk]]
[16:03:16.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.756]                     next
[16:03:16.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:16.756]                 }
[16:03:16.756]                 NAMES <- toupper(added)
[16:03:16.756]                 for (kk in seq_along(NAMES)) {
[16:03:16.756]                   name <- added[[kk]]
[16:03:16.756]                   NAME <- NAMES[[kk]]
[16:03:16.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.756]                     next
[16:03:16.756]                   args[[name]] <- ""
[16:03:16.756]                 }
[16:03:16.756]                 NAMES <- toupper(removed)
[16:03:16.756]                 for (kk in seq_along(NAMES)) {
[16:03:16.756]                   name <- removed[[kk]]
[16:03:16.756]                   NAME <- NAMES[[kk]]
[16:03:16.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:16.756]                     next
[16:03:16.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:16.756]                 }
[16:03:16.756]                 if (length(args) > 0) 
[16:03:16.756]                   base::do.call(base::Sys.setenv, args = args)
[16:03:16.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:16.756]             }
[16:03:16.756]             else {
[16:03:16.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:16.756]             }
[16:03:16.756]             {
[16:03:16.756]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:16.756]                   0L) {
[16:03:16.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:16.756]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:16.756]                   base::options(opts)
[16:03:16.756]                 }
[16:03:16.756]                 {
[16:03:16.756]                   {
[16:03:16.756]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:16.756]                     NULL
[16:03:16.756]                   }
[16:03:16.756]                   options(future.plan = NULL)
[16:03:16.756]                   if (is.na(NA_character_)) 
[16:03:16.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:16.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:16.756]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:16.756]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:16.756]                     envir = parent.frame()) 
[16:03:16.756]                   {
[16:03:16.756]                     if (is.function(workers)) 
[16:03:16.756]                       workers <- workers()
[16:03:16.756]                     workers <- structure(as.integer(workers), 
[16:03:16.756]                       class = class(workers))
[16:03:16.756]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:16.756]                       workers >= 1)
[16:03:16.756]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:16.756]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:16.756]                     }
[16:03:16.756]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:16.756]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:16.756]                       envir = envir)
[16:03:16.756]                     if (!future$lazy) 
[16:03:16.756]                       future <- run(future)
[16:03:16.756]                     invisible(future)
[16:03:16.756]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:16.756]                 }
[16:03:16.756]             }
[16:03:16.756]         }
[16:03:16.756]     })
[16:03:16.756]     if (TRUE) {
[16:03:16.756]         base::sink(type = "output", split = FALSE)
[16:03:16.756]         if (TRUE) {
[16:03:16.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:16.756]         }
[16:03:16.756]         else {
[16:03:16.756]             ...future.result["stdout"] <- base::list(NULL)
[16:03:16.756]         }
[16:03:16.756]         base::close(...future.stdout)
[16:03:16.756]         ...future.stdout <- NULL
[16:03:16.756]     }
[16:03:16.756]     ...future.result$conditions <- ...future.conditions
[16:03:16.756]     ...future.result$finished <- base::Sys.time()
[16:03:16.756]     ...future.result
[16:03:16.756] }
[16:03:16.759] Exporting 11 global objects (93.23 KiB) to cluster node #2 ...
[16:03:16.759] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:16.807] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:16.807] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[16:03:16.808] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[16:03:16.808] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:16.808] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:16.809] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:16.851] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:16.851] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:16.895] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:16.895] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:03:16.896] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:03:16.896] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:03:16.896] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:03:16.896] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:16.897] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:16.897] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:03:16.897] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:03:16.898] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:16.898] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:16.898] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:16.898] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:16.898] Exporting 11 global objects (93.23 KiB) to cluster node #2 ... DONE
[16:03:16.899] MultisessionFuture started
[16:03:16.899] - Launch lazy future ... done
[16:03:16.899] run() for ‘MultisessionFuture’ ... done
[16:03:16.899] Created future:
[16:03:16.900] MultisessionFuture:
[16:03:16.900] Label: ‘future_vapply-2’
[16:03:16.900] Expression:
[16:03:16.900] {
[16:03:16.900]     do.call(function(...) {
[16:03:16.900]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.900]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:16.900]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.900]             on.exit(options(oopts), add = TRUE)
[16:03:16.900]         }
[16:03:16.900]         {
[16:03:16.900]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:16.900]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.900]                 ...future.FUN(...future.X_jj, ...)
[16:03:16.900]             })
[16:03:16.900]         }
[16:03:16.900]     }, args = future.call.arguments)
[16:03:16.900] }
[16:03:16.900] Lazy evaluation: FALSE
[16:03:16.900] Asynchronous evaluation: TRUE
[16:03:16.900] Local evaluation: TRUE
[16:03:16.900] Environment: R_GlobalEnv
[16:03:16.900] Capture standard output: TRUE
[16:03:16.900] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:16.900] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:16.900] Packages: 1 packages (‘future.apply’)
[16:03:16.900] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:16.900] Resolved: FALSE
[16:03:16.900] Value: <not collected>
[16:03:16.900] Conditions captured: <none>
[16:03:16.900] Early signaling: FALSE
[16:03:16.900] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:16.900] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:16.911] Chunk #2 of 2 ... DONE
[16:03:16.911] Launching 2 futures (chunks) ... DONE
[16:03:16.912] Resolving 2 futures (chunks) ...
[16:03:16.912] resolve() on list ...
[16:03:16.912]  recursive: 0
[16:03:16.912]  length: 2
[16:03:16.912] 
[16:03:16.912] receiveMessageFromWorker() for ClusterFuture ...
[16:03:16.913] - Validating connection of MultisessionFuture
[16:03:16.913] - received message: FutureResult
[16:03:16.913] - Received FutureResult
[16:03:16.913] - Erased future from FutureRegistry
[16:03:16.913] result() for ClusterFuture ...
[16:03:16.913] - result already collected: FutureResult
[16:03:16.913] result() for ClusterFuture ... done
[16:03:16.913] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:16.913] Future #1
[16:03:16.913] result() for ClusterFuture ...
[16:03:16.914] - result already collected: FutureResult
[16:03:16.914] result() for ClusterFuture ... done
[16:03:16.914] result() for ClusterFuture ...
[16:03:16.914] - result already collected: FutureResult
[16:03:16.914] result() for ClusterFuture ... done
[16:03:16.914] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:16.914] - nx: 2
[16:03:16.914] - relay: TRUE
[16:03:16.914] - stdout: TRUE
[16:03:16.914] - signal: TRUE
[16:03:16.914] - resignal: FALSE
[16:03:16.915] - force: TRUE
[16:03:16.915] - relayed: [n=2] FALSE, FALSE
[16:03:16.915] - queued futures: [n=2] FALSE, FALSE
[16:03:16.915]  - until=1
[16:03:16.915]  - relaying element #1
[16:03:16.915] result() for ClusterFuture ...
[16:03:16.915] - result already collected: FutureResult
[16:03:16.915] result() for ClusterFuture ... done
[16:03:16.915] result() for ClusterFuture ...
[16:03:16.915] - result already collected: FutureResult
[16:03:16.915] result() for ClusterFuture ... done
[16:03:16.916] result() for ClusterFuture ...
[16:03:16.916] - result already collected: FutureResult
[16:03:16.916] result() for ClusterFuture ... done
[16:03:16.916] result() for ClusterFuture ...
[16:03:16.916] - result already collected: FutureResult
[16:03:16.916] result() for ClusterFuture ... done
[16:03:16.916] - relayed: [n=2] TRUE, FALSE
[16:03:16.916] - queued futures: [n=2] TRUE, FALSE
[16:03:16.916] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:16.916]  length: 1 (resolved future 1)
[16:03:16.958] receiveMessageFromWorker() for ClusterFuture ...
[16:03:16.958] - Validating connection of MultisessionFuture
[16:03:16.958] - received message: FutureResult
[16:03:16.958] - Received FutureResult
[16:03:16.959] - Erased future from FutureRegistry
[16:03:16.959] result() for ClusterFuture ...
[16:03:16.959] - result already collected: FutureResult
[16:03:16.959] result() for ClusterFuture ... done
[16:03:16.959] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:16.959] Future #2
[16:03:16.959] result() for ClusterFuture ...
[16:03:16.959] - result already collected: FutureResult
[16:03:16.959] result() for ClusterFuture ... done
[16:03:16.960] result() for ClusterFuture ...
[16:03:16.960] - result already collected: FutureResult
[16:03:16.960] result() for ClusterFuture ... done
[16:03:16.960] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:16.960] - nx: 2
[16:03:16.960] - relay: TRUE
[16:03:16.960] - stdout: TRUE
[16:03:16.960] - signal: TRUE
[16:03:16.960] - resignal: FALSE
[16:03:16.960] - force: TRUE
[16:03:16.960] - relayed: [n=2] TRUE, FALSE
[16:03:16.960] - queued futures: [n=2] TRUE, FALSE
[16:03:16.961]  - until=2
[16:03:16.961]  - relaying element #2
[16:03:16.961] result() for ClusterFuture ...
[16:03:16.961] - result already collected: FutureResult
[16:03:16.961] result() for ClusterFuture ... done
[16:03:16.961] result() for ClusterFuture ...
[16:03:16.961] - result already collected: FutureResult
[16:03:16.961] result() for ClusterFuture ... done
[16:03:16.961] result() for ClusterFuture ...
[16:03:16.961] - result already collected: FutureResult
[16:03:16.961] result() for ClusterFuture ... done
[16:03:16.962] result() for ClusterFuture ...
[16:03:16.962] - result already collected: FutureResult
[16:03:16.962] result() for ClusterFuture ... done
[16:03:16.962] - relayed: [n=2] TRUE, TRUE
[16:03:16.962] - queued futures: [n=2] TRUE, TRUE
[16:03:16.962] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:16.962]  length: 0 (resolved future 2)
[16:03:16.962] Relaying remaining futures
[16:03:16.962] signalConditionsASAP(NULL, pos=0) ...
[16:03:16.962] - nx: 2
[16:03:16.962] - relay: TRUE
[16:03:16.962] - stdout: TRUE
[16:03:16.963] - signal: TRUE
[16:03:16.963] - resignal: FALSE
[16:03:16.963] - force: TRUE
[16:03:16.963] - relayed: [n=2] TRUE, TRUE
[16:03:16.963] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:16.963] - relayed: [n=2] TRUE, TRUE
[16:03:16.963] - queued futures: [n=2] TRUE, TRUE
[16:03:16.963] signalConditionsASAP(NULL, pos=0) ... done
[16:03:16.963] resolve() on list ... DONE
[16:03:16.963] result() for ClusterFuture ...
[16:03:16.963] - result already collected: FutureResult
[16:03:16.964] result() for ClusterFuture ... done
[16:03:16.964] result() for ClusterFuture ...
[16:03:16.964] - result already collected: FutureResult
[16:03:16.964] result() for ClusterFuture ... done
[16:03:16.964] result() for ClusterFuture ...
[16:03:16.964] - result already collected: FutureResult
[16:03:16.964] result() for ClusterFuture ... done
[16:03:16.964] result() for ClusterFuture ...
[16:03:16.964] - result already collected: FutureResult
[16:03:16.964] result() for ClusterFuture ... done
[16:03:16.964]  - Number of value chunks collected: 2
[16:03:16.965] Resolving 2 futures (chunks) ... DONE
[16:03:16.965] Reducing values from 2 chunks ...
[16:03:16.965]  - Number of values collected after concatenation: 10
[16:03:16.965]  - Number of values expected: 10
[16:03:16.965] Reducing values from 2 chunks ... DONE
[16:03:16.965] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[16:03:16.966] future_lapply() ...
[16:03:16.976] Number of chunks: 2
[16:03:16.977] getGlobalsAndPackagesXApply() ...
[16:03:16.977]  - future.globals: TRUE
[16:03:16.977] getGlobalsAndPackages() ...
[16:03:16.977] Searching for globals...
[16:03:16.980] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[16:03:16.980] Searching for globals ... DONE
[16:03:16.980] Resolving globals: FALSE
[16:03:16.981] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[16:03:16.982] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:16.982] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:16.982] - packages: [1] ‘future.apply’
[16:03:16.982] getGlobalsAndPackages() ... DONE
[16:03:16.982]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:16.982]  - needed namespaces: [n=1] ‘future.apply’
[16:03:16.982] Finding globals ... DONE
[16:03:16.982]  - use_args: TRUE
[16:03:16.983]  - Getting '...' globals ...
[16:03:16.983] resolve() on list ...
[16:03:16.983]  recursive: 0
[16:03:16.983]  length: 1
[16:03:16.983]  elements: ‘...’
[16:03:16.983]  length: 0 (resolved future 1)
[16:03:16.983] resolve() on list ... DONE
[16:03:16.983]    - '...' content: [n=0] 
[16:03:16.984] List of 1
[16:03:16.984]  $ ...: list()
[16:03:16.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:16.984]  - attr(*, "where")=List of 1
[16:03:16.984]   ..$ ...:<environment: 0x564e456df530> 
[16:03:16.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:16.984]  - attr(*, "resolved")= logi TRUE
[16:03:16.984]  - attr(*, "total_size")= num NA
[16:03:16.986]  - Getting '...' globals ... DONE
[16:03:16.986] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:16.986] List of 8
[16:03:16.986]  $ ...future.FUN:function (x, ...)  
[16:03:16.986]  $ x_FUN        :function (x)  
[16:03:16.986]  $ times        : int 0
[16:03:16.986]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:16.986]  $ stop_if_not  :function (...)  
[16:03:16.986]  $ dim          : NULL
[16:03:16.986]  $ valid_types  : chr [1:2] "logical" "integer"
[16:03:16.986]  $ ...          : list()
[16:03:16.986]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:16.986]  - attr(*, "where")=List of 8
[16:03:16.986]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:16.986]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:16.986]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:16.986]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:16.986]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:16.986]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:16.986]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:16.986]   ..$ ...          :<environment: 0x564e456df530> 
[16:03:16.986]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:16.986]  - attr(*, "resolved")= logi FALSE
[16:03:16.986]  - attr(*, "total_size")= num 95400
[16:03:16.992] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:16.992] getGlobalsAndPackagesXApply() ... DONE
[16:03:16.992] Number of futures (= number of chunks): 2
[16:03:16.992] Launching 2 futures (chunks) ...
[16:03:16.992] Chunk #1 of 2 ...
[16:03:16.993]  - Finding globals in 'X' for chunk #1 ...
[16:03:16.993] getGlobalsAndPackages() ...
[16:03:16.993] Searching for globals...
[16:03:16.993] 
[16:03:16.993] Searching for globals ... DONE
[16:03:16.993] - globals: [0] <none>
[16:03:16.993] getGlobalsAndPackages() ... DONE
[16:03:16.993]    + additional globals found: [n=0] 
[16:03:16.993]    + additional namespaces needed: [n=0] 
[16:03:16.993]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:16.994]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:16.994]  - seeds: <none>
[16:03:16.994]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.994] getGlobalsAndPackages() ...
[16:03:16.994] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.994] Resolving globals: FALSE
[16:03:16.994] Tweak future expression to call with '...' arguments ...
[16:03:16.994] {
[16:03:16.994]     do.call(function(...) {
[16:03:16.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:16.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:16.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:16.994]             on.exit(options(oopts), add = TRUE)
[16:03:16.994]         }
[16:03:16.994]         {
[16:03:16.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:16.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:16.994]                 ...future.FUN(...future.X_jj, ...)
[16:03:16.994]             })
[16:03:16.994]         }
[16:03:16.994]     }, args = future.call.arguments)
[16:03:16.994] }
[16:03:16.995] Tweak future expression to call with '...' arguments ... DONE
[16:03:16.995] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:16.995] - packages: [1] ‘future.apply’
[16:03:16.995] getGlobalsAndPackages() ... DONE
[16:03:16.996] run() for ‘Future’ ...
[16:03:16.996] - state: ‘created’
[16:03:16.996] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:17.009] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:17.010] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:17.010]   - Field: ‘node’
[16:03:17.010]   - Field: ‘label’
[16:03:17.010]   - Field: ‘local’
[16:03:17.010]   - Field: ‘owner’
[16:03:17.010]   - Field: ‘envir’
[16:03:17.010]   - Field: ‘workers’
[16:03:17.010]   - Field: ‘packages’
[16:03:17.010]   - Field: ‘gc’
[16:03:17.010]   - Field: ‘conditions’
[16:03:17.011]   - Field: ‘persistent’
[16:03:17.011]   - Field: ‘expr’
[16:03:17.011]   - Field: ‘uuid’
[16:03:17.011]   - Field: ‘seed’
[16:03:17.011]   - Field: ‘version’
[16:03:17.011]   - Field: ‘result’
[16:03:17.011]   - Field: ‘asynchronous’
[16:03:17.011]   - Field: ‘calls’
[16:03:17.011]   - Field: ‘globals’
[16:03:17.011]   - Field: ‘stdout’
[16:03:17.011]   - Field: ‘earlySignal’
[16:03:17.012]   - Field: ‘lazy’
[16:03:17.012]   - Field: ‘state’
[16:03:17.012] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:17.012] - Launch lazy future ...
[16:03:17.012] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:17.012] Packages needed by future strategies (n = 0): <none>
[16:03:17.013] {
[16:03:17.013]     {
[16:03:17.013]         {
[16:03:17.013]             ...future.startTime <- base::Sys.time()
[16:03:17.013]             {
[16:03:17.013]                 {
[16:03:17.013]                   {
[16:03:17.013]                     {
[16:03:17.013]                       {
[16:03:17.013]                         base::local({
[16:03:17.013]                           has_future <- base::requireNamespace("future", 
[16:03:17.013]                             quietly = TRUE)
[16:03:17.013]                           if (has_future) {
[16:03:17.013]                             ns <- base::getNamespace("future")
[16:03:17.013]                             version <- ns[[".package"]][["version"]]
[16:03:17.013]                             if (is.null(version)) 
[16:03:17.013]                               version <- utils::packageVersion("future")
[16:03:17.013]                           }
[16:03:17.013]                           else {
[16:03:17.013]                             version <- NULL
[16:03:17.013]                           }
[16:03:17.013]                           if (!has_future || version < "1.8.0") {
[16:03:17.013]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:17.013]                               "", base::R.version$version.string), 
[16:03:17.013]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:17.013]                                 base::R.version$platform, 8 * 
[16:03:17.013]                                   base::.Machine$sizeof.pointer), 
[16:03:17.013]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:17.013]                                 "release", "version")], collapse = " "), 
[16:03:17.013]                               hostname = base::Sys.info()[["nodename"]])
[16:03:17.013]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:17.013]                               info)
[16:03:17.013]                             info <- base::paste(info, collapse = "; ")
[16:03:17.013]                             if (!has_future) {
[16:03:17.013]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:17.013]                                 info)
[16:03:17.013]                             }
[16:03:17.013]                             else {
[16:03:17.013]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:17.013]                                 info, version)
[16:03:17.013]                             }
[16:03:17.013]                             base::stop(msg)
[16:03:17.013]                           }
[16:03:17.013]                         })
[16:03:17.013]                       }
[16:03:17.013]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:17.013]                       base::options(mc.cores = 1L)
[16:03:17.013]                     }
[16:03:17.013]                     base::local({
[16:03:17.013]                       for (pkg in "future.apply") {
[16:03:17.013]                         base::loadNamespace(pkg)
[16:03:17.013]                         base::library(pkg, character.only = TRUE)
[16:03:17.013]                       }
[16:03:17.013]                     })
[16:03:17.013]                   }
[16:03:17.013]                   options(future.plan = NULL)
[16:03:17.013]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:17.013]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:17.013]                 }
[16:03:17.013]                 ...future.workdir <- getwd()
[16:03:17.013]             }
[16:03:17.013]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:17.013]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:17.013]         }
[16:03:17.013]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:17.013]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:17.013]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:17.013]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:17.013]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:17.013]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:17.013]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:17.013]             base::names(...future.oldOptions))
[16:03:17.013]     }
[16:03:17.013]     if (FALSE) {
[16:03:17.013]     }
[16:03:17.013]     else {
[16:03:17.013]         if (TRUE) {
[16:03:17.013]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:17.013]                 open = "w")
[16:03:17.013]         }
[16:03:17.013]         else {
[16:03:17.013]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:17.013]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:17.013]         }
[16:03:17.013]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:17.013]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:17.013]             base::sink(type = "output", split = FALSE)
[16:03:17.013]             base::close(...future.stdout)
[16:03:17.013]         }, add = TRUE)
[16:03:17.013]     }
[16:03:17.013]     ...future.frame <- base::sys.nframe()
[16:03:17.013]     ...future.conditions <- base::list()
[16:03:17.013]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:17.013]     if (FALSE) {
[16:03:17.013]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:17.013]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:17.013]     }
[16:03:17.013]     ...future.result <- base::tryCatch({
[16:03:17.013]         base::withCallingHandlers({
[16:03:17.013]             ...future.value <- base::withVisible(base::local({
[16:03:17.013]                 ...future.makeSendCondition <- base::local({
[16:03:17.013]                   sendCondition <- NULL
[16:03:17.013]                   function(frame = 1L) {
[16:03:17.013]                     if (is.function(sendCondition)) 
[16:03:17.013]                       return(sendCondition)
[16:03:17.013]                     ns <- getNamespace("parallel")
[16:03:17.013]                     if (exists("sendData", mode = "function", 
[16:03:17.013]                       envir = ns)) {
[16:03:17.013]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:17.013]                         envir = ns)
[16:03:17.013]                       envir <- sys.frame(frame)
[16:03:17.013]                       master <- NULL
[16:03:17.013]                       while (!identical(envir, .GlobalEnv) && 
[16:03:17.013]                         !identical(envir, emptyenv())) {
[16:03:17.013]                         if (exists("master", mode = "list", envir = envir, 
[16:03:17.013]                           inherits = FALSE)) {
[16:03:17.013]                           master <- get("master", mode = "list", 
[16:03:17.013]                             envir = envir, inherits = FALSE)
[16:03:17.013]                           if (inherits(master, c("SOCKnode", 
[16:03:17.013]                             "SOCK0node"))) {
[16:03:17.013]                             sendCondition <<- function(cond) {
[16:03:17.013]                               data <- list(type = "VALUE", value = cond, 
[16:03:17.013]                                 success = TRUE)
[16:03:17.013]                               parallel_sendData(master, data)
[16:03:17.013]                             }
[16:03:17.013]                             return(sendCondition)
[16:03:17.013]                           }
[16:03:17.013]                         }
[16:03:17.013]                         frame <- frame + 1L
[16:03:17.013]                         envir <- sys.frame(frame)
[16:03:17.013]                       }
[16:03:17.013]                     }
[16:03:17.013]                     sendCondition <<- function(cond) NULL
[16:03:17.013]                   }
[16:03:17.013]                 })
[16:03:17.013]                 withCallingHandlers({
[16:03:17.013]                   {
[16:03:17.013]                     do.call(function(...) {
[16:03:17.013]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.013]                       if (!identical(...future.globals.maxSize.org, 
[16:03:17.013]                         ...future.globals.maxSize)) {
[16:03:17.013]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.013]                         on.exit(options(oopts), add = TRUE)
[16:03:17.013]                       }
[16:03:17.013]                       {
[16:03:17.013]                         lapply(seq_along(...future.elements_ii), 
[16:03:17.013]                           FUN = function(jj) {
[16:03:17.013]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.013]                             ...future.FUN(...future.X_jj, ...)
[16:03:17.013]                           })
[16:03:17.013]                       }
[16:03:17.013]                     }, args = future.call.arguments)
[16:03:17.013]                   }
[16:03:17.013]                 }, immediateCondition = function(cond) {
[16:03:17.013]                   sendCondition <- ...future.makeSendCondition()
[16:03:17.013]                   sendCondition(cond)
[16:03:17.013]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.013]                   {
[16:03:17.013]                     inherits <- base::inherits
[16:03:17.013]                     invokeRestart <- base::invokeRestart
[16:03:17.013]                     is.null <- base::is.null
[16:03:17.013]                     muffled <- FALSE
[16:03:17.013]                     if (inherits(cond, "message")) {
[16:03:17.013]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:17.013]                       if (muffled) 
[16:03:17.013]                         invokeRestart("muffleMessage")
[16:03:17.013]                     }
[16:03:17.013]                     else if (inherits(cond, "warning")) {
[16:03:17.013]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:17.013]                       if (muffled) 
[16:03:17.013]                         invokeRestart("muffleWarning")
[16:03:17.013]                     }
[16:03:17.013]                     else if (inherits(cond, "condition")) {
[16:03:17.013]                       if (!is.null(pattern)) {
[16:03:17.013]                         computeRestarts <- base::computeRestarts
[16:03:17.013]                         grepl <- base::grepl
[16:03:17.013]                         restarts <- computeRestarts(cond)
[16:03:17.013]                         for (restart in restarts) {
[16:03:17.013]                           name <- restart$name
[16:03:17.013]                           if (is.null(name)) 
[16:03:17.013]                             next
[16:03:17.013]                           if (!grepl(pattern, name)) 
[16:03:17.013]                             next
[16:03:17.013]                           invokeRestart(restart)
[16:03:17.013]                           muffled <- TRUE
[16:03:17.013]                           break
[16:03:17.013]                         }
[16:03:17.013]                       }
[16:03:17.013]                     }
[16:03:17.013]                     invisible(muffled)
[16:03:17.013]                   }
[16:03:17.013]                   muffleCondition(cond)
[16:03:17.013]                 })
[16:03:17.013]             }))
[16:03:17.013]             future::FutureResult(value = ...future.value$value, 
[16:03:17.013]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:17.013]                   ...future.rng), globalenv = if (FALSE) 
[16:03:17.013]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:17.013]                     ...future.globalenv.names))
[16:03:17.013]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:17.013]         }, condition = base::local({
[16:03:17.013]             c <- base::c
[16:03:17.013]             inherits <- base::inherits
[16:03:17.013]             invokeRestart <- base::invokeRestart
[16:03:17.013]             length <- base::length
[16:03:17.013]             list <- base::list
[16:03:17.013]             seq.int <- base::seq.int
[16:03:17.013]             signalCondition <- base::signalCondition
[16:03:17.013]             sys.calls <- base::sys.calls
[16:03:17.013]             `[[` <- base::`[[`
[16:03:17.013]             `+` <- base::`+`
[16:03:17.013]             `<<-` <- base::`<<-`
[16:03:17.013]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:17.013]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:17.013]                   3L)]
[16:03:17.013]             }
[16:03:17.013]             function(cond) {
[16:03:17.013]                 is_error <- inherits(cond, "error")
[16:03:17.013]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:17.013]                   NULL)
[16:03:17.013]                 if (is_error) {
[16:03:17.013]                   sessionInformation <- function() {
[16:03:17.013]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:17.013]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:17.013]                       search = base::search(), system = base::Sys.info())
[16:03:17.013]                   }
[16:03:17.013]                   ...future.conditions[[length(...future.conditions) + 
[16:03:17.013]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:17.013]                     cond$call), session = sessionInformation(), 
[16:03:17.013]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:17.013]                   signalCondition(cond)
[16:03:17.013]                 }
[16:03:17.013]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:17.013]                 "immediateCondition"))) {
[16:03:17.013]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:17.013]                   ...future.conditions[[length(...future.conditions) + 
[16:03:17.013]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:17.013]                   if (TRUE && !signal) {
[16:03:17.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.013]                     {
[16:03:17.013]                       inherits <- base::inherits
[16:03:17.013]                       invokeRestart <- base::invokeRestart
[16:03:17.013]                       is.null <- base::is.null
[16:03:17.013]                       muffled <- FALSE
[16:03:17.013]                       if (inherits(cond, "message")) {
[16:03:17.013]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:17.013]                         if (muffled) 
[16:03:17.013]                           invokeRestart("muffleMessage")
[16:03:17.013]                       }
[16:03:17.013]                       else if (inherits(cond, "warning")) {
[16:03:17.013]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:17.013]                         if (muffled) 
[16:03:17.013]                           invokeRestart("muffleWarning")
[16:03:17.013]                       }
[16:03:17.013]                       else if (inherits(cond, "condition")) {
[16:03:17.013]                         if (!is.null(pattern)) {
[16:03:17.013]                           computeRestarts <- base::computeRestarts
[16:03:17.013]                           grepl <- base::grepl
[16:03:17.013]                           restarts <- computeRestarts(cond)
[16:03:17.013]                           for (restart in restarts) {
[16:03:17.013]                             name <- restart$name
[16:03:17.013]                             if (is.null(name)) 
[16:03:17.013]                               next
[16:03:17.013]                             if (!grepl(pattern, name)) 
[16:03:17.013]                               next
[16:03:17.013]                             invokeRestart(restart)
[16:03:17.013]                             muffled <- TRUE
[16:03:17.013]                             break
[16:03:17.013]                           }
[16:03:17.013]                         }
[16:03:17.013]                       }
[16:03:17.013]                       invisible(muffled)
[16:03:17.013]                     }
[16:03:17.013]                     muffleCondition(cond, pattern = "^muffle")
[16:03:17.013]                   }
[16:03:17.013]                 }
[16:03:17.013]                 else {
[16:03:17.013]                   if (TRUE) {
[16:03:17.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.013]                     {
[16:03:17.013]                       inherits <- base::inherits
[16:03:17.013]                       invokeRestart <- base::invokeRestart
[16:03:17.013]                       is.null <- base::is.null
[16:03:17.013]                       muffled <- FALSE
[16:03:17.013]                       if (inherits(cond, "message")) {
[16:03:17.013]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:17.013]                         if (muffled) 
[16:03:17.013]                           invokeRestart("muffleMessage")
[16:03:17.013]                       }
[16:03:17.013]                       else if (inherits(cond, "warning")) {
[16:03:17.013]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:17.013]                         if (muffled) 
[16:03:17.013]                           invokeRestart("muffleWarning")
[16:03:17.013]                       }
[16:03:17.013]                       else if (inherits(cond, "condition")) {
[16:03:17.013]                         if (!is.null(pattern)) {
[16:03:17.013]                           computeRestarts <- base::computeRestarts
[16:03:17.013]                           grepl <- base::grepl
[16:03:17.013]                           restarts <- computeRestarts(cond)
[16:03:17.013]                           for (restart in restarts) {
[16:03:17.013]                             name <- restart$name
[16:03:17.013]                             if (is.null(name)) 
[16:03:17.013]                               next
[16:03:17.013]                             if (!grepl(pattern, name)) 
[16:03:17.013]                               next
[16:03:17.013]                             invokeRestart(restart)
[16:03:17.013]                             muffled <- TRUE
[16:03:17.013]                             break
[16:03:17.013]                           }
[16:03:17.013]                         }
[16:03:17.013]                       }
[16:03:17.013]                       invisible(muffled)
[16:03:17.013]                     }
[16:03:17.013]                     muffleCondition(cond, pattern = "^muffle")
[16:03:17.013]                   }
[16:03:17.013]                 }
[16:03:17.013]             }
[16:03:17.013]         }))
[16:03:17.013]     }, error = function(ex) {
[16:03:17.013]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:17.013]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:17.013]                 ...future.rng), started = ...future.startTime, 
[16:03:17.013]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:17.013]             version = "1.8"), class = "FutureResult")
[16:03:17.013]     }, finally = {
[16:03:17.013]         if (!identical(...future.workdir, getwd())) 
[16:03:17.013]             setwd(...future.workdir)
[16:03:17.013]         {
[16:03:17.013]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:17.013]                 ...future.oldOptions$nwarnings <- NULL
[16:03:17.013]             }
[16:03:17.013]             base::options(...future.oldOptions)
[16:03:17.013]             if (.Platform$OS.type == "windows") {
[16:03:17.013]                 old_names <- names(...future.oldEnvVars)
[16:03:17.013]                 envs <- base::Sys.getenv()
[16:03:17.013]                 names <- names(envs)
[16:03:17.013]                 common <- intersect(names, old_names)
[16:03:17.013]                 added <- setdiff(names, old_names)
[16:03:17.013]                 removed <- setdiff(old_names, names)
[16:03:17.013]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:17.013]                   envs[common]]
[16:03:17.013]                 NAMES <- toupper(changed)
[16:03:17.013]                 args <- list()
[16:03:17.013]                 for (kk in seq_along(NAMES)) {
[16:03:17.013]                   name <- changed[[kk]]
[16:03:17.013]                   NAME <- NAMES[[kk]]
[16:03:17.013]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.013]                     next
[16:03:17.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:17.013]                 }
[16:03:17.013]                 NAMES <- toupper(added)
[16:03:17.013]                 for (kk in seq_along(NAMES)) {
[16:03:17.013]                   name <- added[[kk]]
[16:03:17.013]                   NAME <- NAMES[[kk]]
[16:03:17.013]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.013]                     next
[16:03:17.013]                   args[[name]] <- ""
[16:03:17.013]                 }
[16:03:17.013]                 NAMES <- toupper(removed)
[16:03:17.013]                 for (kk in seq_along(NAMES)) {
[16:03:17.013]                   name <- removed[[kk]]
[16:03:17.013]                   NAME <- NAMES[[kk]]
[16:03:17.013]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.013]                     next
[16:03:17.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:17.013]                 }
[16:03:17.013]                 if (length(args) > 0) 
[16:03:17.013]                   base::do.call(base::Sys.setenv, args = args)
[16:03:17.013]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:17.013]             }
[16:03:17.013]             else {
[16:03:17.013]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:17.013]             }
[16:03:17.013]             {
[16:03:17.013]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:17.013]                   0L) {
[16:03:17.013]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:17.013]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:17.013]                   base::options(opts)
[16:03:17.013]                 }
[16:03:17.013]                 {
[16:03:17.013]                   {
[16:03:17.013]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:17.013]                     NULL
[16:03:17.013]                   }
[16:03:17.013]                   options(future.plan = NULL)
[16:03:17.013]                   if (is.na(NA_character_)) 
[16:03:17.013]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:17.013]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:17.013]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:17.013]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:17.013]                     envir = parent.frame()) 
[16:03:17.013]                   {
[16:03:17.013]                     if (is.function(workers)) 
[16:03:17.013]                       workers <- workers()
[16:03:17.013]                     workers <- structure(as.integer(workers), 
[16:03:17.013]                       class = class(workers))
[16:03:17.013]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:17.013]                       workers >= 1)
[16:03:17.013]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:17.013]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:17.013]                     }
[16:03:17.013]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:17.013]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:17.013]                       envir = envir)
[16:03:17.013]                     if (!future$lazy) 
[16:03:17.013]                       future <- run(future)
[16:03:17.013]                     invisible(future)
[16:03:17.013]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:17.013]                 }
[16:03:17.013]             }
[16:03:17.013]         }
[16:03:17.013]     })
[16:03:17.013]     if (TRUE) {
[16:03:17.013]         base::sink(type = "output", split = FALSE)
[16:03:17.013]         if (TRUE) {
[16:03:17.013]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:17.013]         }
[16:03:17.013]         else {
[16:03:17.013]             ...future.result["stdout"] <- base::list(NULL)
[16:03:17.013]         }
[16:03:17.013]         base::close(...future.stdout)
[16:03:17.013]         ...future.stdout <- NULL
[16:03:17.013]     }
[16:03:17.013]     ...future.result$conditions <- ...future.conditions
[16:03:17.013]     ...future.result$finished <- base::Sys.time()
[16:03:17.013]     ...future.result
[16:03:17.013] }
[16:03:17.016] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[16:03:17.016] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:17.059] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:17.059] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[16:03:17.060] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[16:03:17.060] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:17.060] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:17.060] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:17.103] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:17.103] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:17.147] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:17.147] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:03:17.148] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.148] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[16:03:17.148] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[16:03:17.149] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:17.149] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.149] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:03:17.149] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:03:17.150] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:17.150] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.150] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:17.150] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.151] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[16:03:17.151] MultisessionFuture started
[16:03:17.151] - Launch lazy future ... done
[16:03:17.151] run() for ‘MultisessionFuture’ ... done
[16:03:17.152] Created future:
[16:03:17.152] MultisessionFuture:
[16:03:17.152] Label: ‘future_vapply-1’
[16:03:17.152] Expression:
[16:03:17.152] {
[16:03:17.152]     do.call(function(...) {
[16:03:17.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:17.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.152]             on.exit(options(oopts), add = TRUE)
[16:03:17.152]         }
[16:03:17.152]         {
[16:03:17.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:17.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.152]                 ...future.FUN(...future.X_jj, ...)
[16:03:17.152]             })
[16:03:17.152]         }
[16:03:17.152]     }, args = future.call.arguments)
[16:03:17.152] }
[16:03:17.152] Lazy evaluation: FALSE
[16:03:17.152] Asynchronous evaluation: TRUE
[16:03:17.152] Local evaluation: TRUE
[16:03:17.152] Environment: R_GlobalEnv
[16:03:17.152] Capture standard output: TRUE
[16:03:17.152] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:17.152] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:17.152] Packages: 1 packages (‘future.apply’)
[16:03:17.152] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:17.152] Resolved: FALSE
[16:03:17.152] Value: <not collected>
[16:03:17.152] Conditions captured: <none>
[16:03:17.152] Early signaling: FALSE
[16:03:17.152] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:17.152] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:17.163] Chunk #1 of 2 ... DONE
[16:03:17.164] Chunk #2 of 2 ...
[16:03:17.164]  - Finding globals in 'X' for chunk #2 ...
[16:03:17.164] getGlobalsAndPackages() ...
[16:03:17.164] Searching for globals...
[16:03:17.164] 
[16:03:17.164] Searching for globals ... DONE
[16:03:17.164] - globals: [0] <none>
[16:03:17.165] getGlobalsAndPackages() ... DONE
[16:03:17.165]    + additional globals found: [n=0] 
[16:03:17.165]    + additional namespaces needed: [n=0] 
[16:03:17.165]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:17.165]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:17.165]  - seeds: <none>
[16:03:17.165]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.165] getGlobalsAndPackages() ...
[16:03:17.165] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.165] Resolving globals: FALSE
[16:03:17.166] Tweak future expression to call with '...' arguments ...
[16:03:17.166] {
[16:03:17.166]     do.call(function(...) {
[16:03:17.166]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.166]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:17.166]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.166]             on.exit(options(oopts), add = TRUE)
[16:03:17.166]         }
[16:03:17.166]         {
[16:03:17.166]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:17.166]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.166]                 ...future.FUN(...future.X_jj, ...)
[16:03:17.166]             })
[16:03:17.166]         }
[16:03:17.166]     }, args = future.call.arguments)
[16:03:17.166] }
[16:03:17.166] Tweak future expression to call with '...' arguments ... DONE
[16:03:17.166] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.167] - packages: [1] ‘future.apply’
[16:03:17.167] getGlobalsAndPackages() ... DONE
[16:03:17.167] run() for ‘Future’ ...
[16:03:17.167] - state: ‘created’
[16:03:17.167] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:17.181] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:17.181] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:17.181]   - Field: ‘node’
[16:03:17.182]   - Field: ‘label’
[16:03:17.182]   - Field: ‘local’
[16:03:17.182]   - Field: ‘owner’
[16:03:17.182]   - Field: ‘envir’
[16:03:17.182]   - Field: ‘workers’
[16:03:17.182]   - Field: ‘packages’
[16:03:17.182]   - Field: ‘gc’
[16:03:17.182]   - Field: ‘conditions’
[16:03:17.182]   - Field: ‘persistent’
[16:03:17.182]   - Field: ‘expr’
[16:03:17.183]   - Field: ‘uuid’
[16:03:17.183]   - Field: ‘seed’
[16:03:17.183]   - Field: ‘version’
[16:03:17.183]   - Field: ‘result’
[16:03:17.183]   - Field: ‘asynchronous’
[16:03:17.183]   - Field: ‘calls’
[16:03:17.183]   - Field: ‘globals’
[16:03:17.183]   - Field: ‘stdout’
[16:03:17.183]   - Field: ‘earlySignal’
[16:03:17.183]   - Field: ‘lazy’
[16:03:17.183]   - Field: ‘state’
[16:03:17.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:17.184] - Launch lazy future ...
[16:03:17.184] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:17.184] Packages needed by future strategies (n = 0): <none>
[16:03:17.185] {
[16:03:17.185]     {
[16:03:17.185]         {
[16:03:17.185]             ...future.startTime <- base::Sys.time()
[16:03:17.185]             {
[16:03:17.185]                 {
[16:03:17.185]                   {
[16:03:17.185]                     {
[16:03:17.185]                       {
[16:03:17.185]                         base::local({
[16:03:17.185]                           has_future <- base::requireNamespace("future", 
[16:03:17.185]                             quietly = TRUE)
[16:03:17.185]                           if (has_future) {
[16:03:17.185]                             ns <- base::getNamespace("future")
[16:03:17.185]                             version <- ns[[".package"]][["version"]]
[16:03:17.185]                             if (is.null(version)) 
[16:03:17.185]                               version <- utils::packageVersion("future")
[16:03:17.185]                           }
[16:03:17.185]                           else {
[16:03:17.185]                             version <- NULL
[16:03:17.185]                           }
[16:03:17.185]                           if (!has_future || version < "1.8.0") {
[16:03:17.185]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:17.185]                               "", base::R.version$version.string), 
[16:03:17.185]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:17.185]                                 base::R.version$platform, 8 * 
[16:03:17.185]                                   base::.Machine$sizeof.pointer), 
[16:03:17.185]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:17.185]                                 "release", "version")], collapse = " "), 
[16:03:17.185]                               hostname = base::Sys.info()[["nodename"]])
[16:03:17.185]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:17.185]                               info)
[16:03:17.185]                             info <- base::paste(info, collapse = "; ")
[16:03:17.185]                             if (!has_future) {
[16:03:17.185]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:17.185]                                 info)
[16:03:17.185]                             }
[16:03:17.185]                             else {
[16:03:17.185]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:17.185]                                 info, version)
[16:03:17.185]                             }
[16:03:17.185]                             base::stop(msg)
[16:03:17.185]                           }
[16:03:17.185]                         })
[16:03:17.185]                       }
[16:03:17.185]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:17.185]                       base::options(mc.cores = 1L)
[16:03:17.185]                     }
[16:03:17.185]                     base::local({
[16:03:17.185]                       for (pkg in "future.apply") {
[16:03:17.185]                         base::loadNamespace(pkg)
[16:03:17.185]                         base::library(pkg, character.only = TRUE)
[16:03:17.185]                       }
[16:03:17.185]                     })
[16:03:17.185]                   }
[16:03:17.185]                   options(future.plan = NULL)
[16:03:17.185]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:17.185]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:17.185]                 }
[16:03:17.185]                 ...future.workdir <- getwd()
[16:03:17.185]             }
[16:03:17.185]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:17.185]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:17.185]         }
[16:03:17.185]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:17.185]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:17.185]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:17.185]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:17.185]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:17.185]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:17.185]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:17.185]             base::names(...future.oldOptions))
[16:03:17.185]     }
[16:03:17.185]     if (FALSE) {
[16:03:17.185]     }
[16:03:17.185]     else {
[16:03:17.185]         if (TRUE) {
[16:03:17.185]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:17.185]                 open = "w")
[16:03:17.185]         }
[16:03:17.185]         else {
[16:03:17.185]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:17.185]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:17.185]         }
[16:03:17.185]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:17.185]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:17.185]             base::sink(type = "output", split = FALSE)
[16:03:17.185]             base::close(...future.stdout)
[16:03:17.185]         }, add = TRUE)
[16:03:17.185]     }
[16:03:17.185]     ...future.frame <- base::sys.nframe()
[16:03:17.185]     ...future.conditions <- base::list()
[16:03:17.185]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:17.185]     if (FALSE) {
[16:03:17.185]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:17.185]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:17.185]     }
[16:03:17.185]     ...future.result <- base::tryCatch({
[16:03:17.185]         base::withCallingHandlers({
[16:03:17.185]             ...future.value <- base::withVisible(base::local({
[16:03:17.185]                 ...future.makeSendCondition <- base::local({
[16:03:17.185]                   sendCondition <- NULL
[16:03:17.185]                   function(frame = 1L) {
[16:03:17.185]                     if (is.function(sendCondition)) 
[16:03:17.185]                       return(sendCondition)
[16:03:17.185]                     ns <- getNamespace("parallel")
[16:03:17.185]                     if (exists("sendData", mode = "function", 
[16:03:17.185]                       envir = ns)) {
[16:03:17.185]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:17.185]                         envir = ns)
[16:03:17.185]                       envir <- sys.frame(frame)
[16:03:17.185]                       master <- NULL
[16:03:17.185]                       while (!identical(envir, .GlobalEnv) && 
[16:03:17.185]                         !identical(envir, emptyenv())) {
[16:03:17.185]                         if (exists("master", mode = "list", envir = envir, 
[16:03:17.185]                           inherits = FALSE)) {
[16:03:17.185]                           master <- get("master", mode = "list", 
[16:03:17.185]                             envir = envir, inherits = FALSE)
[16:03:17.185]                           if (inherits(master, c("SOCKnode", 
[16:03:17.185]                             "SOCK0node"))) {
[16:03:17.185]                             sendCondition <<- function(cond) {
[16:03:17.185]                               data <- list(type = "VALUE", value = cond, 
[16:03:17.185]                                 success = TRUE)
[16:03:17.185]                               parallel_sendData(master, data)
[16:03:17.185]                             }
[16:03:17.185]                             return(sendCondition)
[16:03:17.185]                           }
[16:03:17.185]                         }
[16:03:17.185]                         frame <- frame + 1L
[16:03:17.185]                         envir <- sys.frame(frame)
[16:03:17.185]                       }
[16:03:17.185]                     }
[16:03:17.185]                     sendCondition <<- function(cond) NULL
[16:03:17.185]                   }
[16:03:17.185]                 })
[16:03:17.185]                 withCallingHandlers({
[16:03:17.185]                   {
[16:03:17.185]                     do.call(function(...) {
[16:03:17.185]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.185]                       if (!identical(...future.globals.maxSize.org, 
[16:03:17.185]                         ...future.globals.maxSize)) {
[16:03:17.185]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.185]                         on.exit(options(oopts), add = TRUE)
[16:03:17.185]                       }
[16:03:17.185]                       {
[16:03:17.185]                         lapply(seq_along(...future.elements_ii), 
[16:03:17.185]                           FUN = function(jj) {
[16:03:17.185]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.185]                             ...future.FUN(...future.X_jj, ...)
[16:03:17.185]                           })
[16:03:17.185]                       }
[16:03:17.185]                     }, args = future.call.arguments)
[16:03:17.185]                   }
[16:03:17.185]                 }, immediateCondition = function(cond) {
[16:03:17.185]                   sendCondition <- ...future.makeSendCondition()
[16:03:17.185]                   sendCondition(cond)
[16:03:17.185]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.185]                   {
[16:03:17.185]                     inherits <- base::inherits
[16:03:17.185]                     invokeRestart <- base::invokeRestart
[16:03:17.185]                     is.null <- base::is.null
[16:03:17.185]                     muffled <- FALSE
[16:03:17.185]                     if (inherits(cond, "message")) {
[16:03:17.185]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:17.185]                       if (muffled) 
[16:03:17.185]                         invokeRestart("muffleMessage")
[16:03:17.185]                     }
[16:03:17.185]                     else if (inherits(cond, "warning")) {
[16:03:17.185]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:17.185]                       if (muffled) 
[16:03:17.185]                         invokeRestart("muffleWarning")
[16:03:17.185]                     }
[16:03:17.185]                     else if (inherits(cond, "condition")) {
[16:03:17.185]                       if (!is.null(pattern)) {
[16:03:17.185]                         computeRestarts <- base::computeRestarts
[16:03:17.185]                         grepl <- base::grepl
[16:03:17.185]                         restarts <- computeRestarts(cond)
[16:03:17.185]                         for (restart in restarts) {
[16:03:17.185]                           name <- restart$name
[16:03:17.185]                           if (is.null(name)) 
[16:03:17.185]                             next
[16:03:17.185]                           if (!grepl(pattern, name)) 
[16:03:17.185]                             next
[16:03:17.185]                           invokeRestart(restart)
[16:03:17.185]                           muffled <- TRUE
[16:03:17.185]                           break
[16:03:17.185]                         }
[16:03:17.185]                       }
[16:03:17.185]                     }
[16:03:17.185]                     invisible(muffled)
[16:03:17.185]                   }
[16:03:17.185]                   muffleCondition(cond)
[16:03:17.185]                 })
[16:03:17.185]             }))
[16:03:17.185]             future::FutureResult(value = ...future.value$value, 
[16:03:17.185]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:17.185]                   ...future.rng), globalenv = if (FALSE) 
[16:03:17.185]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:17.185]                     ...future.globalenv.names))
[16:03:17.185]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:17.185]         }, condition = base::local({
[16:03:17.185]             c <- base::c
[16:03:17.185]             inherits <- base::inherits
[16:03:17.185]             invokeRestart <- base::invokeRestart
[16:03:17.185]             length <- base::length
[16:03:17.185]             list <- base::list
[16:03:17.185]             seq.int <- base::seq.int
[16:03:17.185]             signalCondition <- base::signalCondition
[16:03:17.185]             sys.calls <- base::sys.calls
[16:03:17.185]             `[[` <- base::`[[`
[16:03:17.185]             `+` <- base::`+`
[16:03:17.185]             `<<-` <- base::`<<-`
[16:03:17.185]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:17.185]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:17.185]                   3L)]
[16:03:17.185]             }
[16:03:17.185]             function(cond) {
[16:03:17.185]                 is_error <- inherits(cond, "error")
[16:03:17.185]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:17.185]                   NULL)
[16:03:17.185]                 if (is_error) {
[16:03:17.185]                   sessionInformation <- function() {
[16:03:17.185]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:17.185]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:17.185]                       search = base::search(), system = base::Sys.info())
[16:03:17.185]                   }
[16:03:17.185]                   ...future.conditions[[length(...future.conditions) + 
[16:03:17.185]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:17.185]                     cond$call), session = sessionInformation(), 
[16:03:17.185]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:17.185]                   signalCondition(cond)
[16:03:17.185]                 }
[16:03:17.185]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:17.185]                 "immediateCondition"))) {
[16:03:17.185]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:17.185]                   ...future.conditions[[length(...future.conditions) + 
[16:03:17.185]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:17.185]                   if (TRUE && !signal) {
[16:03:17.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.185]                     {
[16:03:17.185]                       inherits <- base::inherits
[16:03:17.185]                       invokeRestart <- base::invokeRestart
[16:03:17.185]                       is.null <- base::is.null
[16:03:17.185]                       muffled <- FALSE
[16:03:17.185]                       if (inherits(cond, "message")) {
[16:03:17.185]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:17.185]                         if (muffled) 
[16:03:17.185]                           invokeRestart("muffleMessage")
[16:03:17.185]                       }
[16:03:17.185]                       else if (inherits(cond, "warning")) {
[16:03:17.185]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:17.185]                         if (muffled) 
[16:03:17.185]                           invokeRestart("muffleWarning")
[16:03:17.185]                       }
[16:03:17.185]                       else if (inherits(cond, "condition")) {
[16:03:17.185]                         if (!is.null(pattern)) {
[16:03:17.185]                           computeRestarts <- base::computeRestarts
[16:03:17.185]                           grepl <- base::grepl
[16:03:17.185]                           restarts <- computeRestarts(cond)
[16:03:17.185]                           for (restart in restarts) {
[16:03:17.185]                             name <- restart$name
[16:03:17.185]                             if (is.null(name)) 
[16:03:17.185]                               next
[16:03:17.185]                             if (!grepl(pattern, name)) 
[16:03:17.185]                               next
[16:03:17.185]                             invokeRestart(restart)
[16:03:17.185]                             muffled <- TRUE
[16:03:17.185]                             break
[16:03:17.185]                           }
[16:03:17.185]                         }
[16:03:17.185]                       }
[16:03:17.185]                       invisible(muffled)
[16:03:17.185]                     }
[16:03:17.185]                     muffleCondition(cond, pattern = "^muffle")
[16:03:17.185]                   }
[16:03:17.185]                 }
[16:03:17.185]                 else {
[16:03:17.185]                   if (TRUE) {
[16:03:17.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.185]                     {
[16:03:17.185]                       inherits <- base::inherits
[16:03:17.185]                       invokeRestart <- base::invokeRestart
[16:03:17.185]                       is.null <- base::is.null
[16:03:17.185]                       muffled <- FALSE
[16:03:17.185]                       if (inherits(cond, "message")) {
[16:03:17.185]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:17.185]                         if (muffled) 
[16:03:17.185]                           invokeRestart("muffleMessage")
[16:03:17.185]                       }
[16:03:17.185]                       else if (inherits(cond, "warning")) {
[16:03:17.185]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:17.185]                         if (muffled) 
[16:03:17.185]                           invokeRestart("muffleWarning")
[16:03:17.185]                       }
[16:03:17.185]                       else if (inherits(cond, "condition")) {
[16:03:17.185]                         if (!is.null(pattern)) {
[16:03:17.185]                           computeRestarts <- base::computeRestarts
[16:03:17.185]                           grepl <- base::grepl
[16:03:17.185]                           restarts <- computeRestarts(cond)
[16:03:17.185]                           for (restart in restarts) {
[16:03:17.185]                             name <- restart$name
[16:03:17.185]                             if (is.null(name)) 
[16:03:17.185]                               next
[16:03:17.185]                             if (!grepl(pattern, name)) 
[16:03:17.185]                               next
[16:03:17.185]                             invokeRestart(restart)
[16:03:17.185]                             muffled <- TRUE
[16:03:17.185]                             break
[16:03:17.185]                           }
[16:03:17.185]                         }
[16:03:17.185]                       }
[16:03:17.185]                       invisible(muffled)
[16:03:17.185]                     }
[16:03:17.185]                     muffleCondition(cond, pattern = "^muffle")
[16:03:17.185]                   }
[16:03:17.185]                 }
[16:03:17.185]             }
[16:03:17.185]         }))
[16:03:17.185]     }, error = function(ex) {
[16:03:17.185]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:17.185]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:17.185]                 ...future.rng), started = ...future.startTime, 
[16:03:17.185]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:17.185]             version = "1.8"), class = "FutureResult")
[16:03:17.185]     }, finally = {
[16:03:17.185]         if (!identical(...future.workdir, getwd())) 
[16:03:17.185]             setwd(...future.workdir)
[16:03:17.185]         {
[16:03:17.185]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:17.185]                 ...future.oldOptions$nwarnings <- NULL
[16:03:17.185]             }
[16:03:17.185]             base::options(...future.oldOptions)
[16:03:17.185]             if (.Platform$OS.type == "windows") {
[16:03:17.185]                 old_names <- names(...future.oldEnvVars)
[16:03:17.185]                 envs <- base::Sys.getenv()
[16:03:17.185]                 names <- names(envs)
[16:03:17.185]                 common <- intersect(names, old_names)
[16:03:17.185]                 added <- setdiff(names, old_names)
[16:03:17.185]                 removed <- setdiff(old_names, names)
[16:03:17.185]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:17.185]                   envs[common]]
[16:03:17.185]                 NAMES <- toupper(changed)
[16:03:17.185]                 args <- list()
[16:03:17.185]                 for (kk in seq_along(NAMES)) {
[16:03:17.185]                   name <- changed[[kk]]
[16:03:17.185]                   NAME <- NAMES[[kk]]
[16:03:17.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.185]                     next
[16:03:17.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:17.185]                 }
[16:03:17.185]                 NAMES <- toupper(added)
[16:03:17.185]                 for (kk in seq_along(NAMES)) {
[16:03:17.185]                   name <- added[[kk]]
[16:03:17.185]                   NAME <- NAMES[[kk]]
[16:03:17.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.185]                     next
[16:03:17.185]                   args[[name]] <- ""
[16:03:17.185]                 }
[16:03:17.185]                 NAMES <- toupper(removed)
[16:03:17.185]                 for (kk in seq_along(NAMES)) {
[16:03:17.185]                   name <- removed[[kk]]
[16:03:17.185]                   NAME <- NAMES[[kk]]
[16:03:17.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.185]                     next
[16:03:17.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:17.185]                 }
[16:03:17.185]                 if (length(args) > 0) 
[16:03:17.185]                   base::do.call(base::Sys.setenv, args = args)
[16:03:17.185]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:17.185]             }
[16:03:17.185]             else {
[16:03:17.185]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:17.185]             }
[16:03:17.185]             {
[16:03:17.185]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:17.185]                   0L) {
[16:03:17.185]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:17.185]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:17.185]                   base::options(opts)
[16:03:17.185]                 }
[16:03:17.185]                 {
[16:03:17.185]                   {
[16:03:17.185]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:17.185]                     NULL
[16:03:17.185]                   }
[16:03:17.185]                   options(future.plan = NULL)
[16:03:17.185]                   if (is.na(NA_character_)) 
[16:03:17.185]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:17.185]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:17.185]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:17.185]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:17.185]                     envir = parent.frame()) 
[16:03:17.185]                   {
[16:03:17.185]                     if (is.function(workers)) 
[16:03:17.185]                       workers <- workers()
[16:03:17.185]                     workers <- structure(as.integer(workers), 
[16:03:17.185]                       class = class(workers))
[16:03:17.185]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:17.185]                       workers >= 1)
[16:03:17.185]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:17.185]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:17.185]                     }
[16:03:17.185]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:17.185]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:17.185]                       envir = envir)
[16:03:17.185]                     if (!future$lazy) 
[16:03:17.185]                       future <- run(future)
[16:03:17.185]                     invisible(future)
[16:03:17.185]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:17.185]                 }
[16:03:17.185]             }
[16:03:17.185]         }
[16:03:17.185]     })
[16:03:17.185]     if (TRUE) {
[16:03:17.185]         base::sink(type = "output", split = FALSE)
[16:03:17.185]         if (TRUE) {
[16:03:17.185]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:17.185]         }
[16:03:17.185]         else {
[16:03:17.185]             ...future.result["stdout"] <- base::list(NULL)
[16:03:17.185]         }
[16:03:17.185]         base::close(...future.stdout)
[16:03:17.185]         ...future.stdout <- NULL
[16:03:17.185]     }
[16:03:17.185]     ...future.result$conditions <- ...future.conditions
[16:03:17.185]     ...future.result$finished <- base::Sys.time()
[16:03:17.185]     ...future.result
[16:03:17.185] }
[16:03:17.188] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[16:03:17.188] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:17.235] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:17.235] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[16:03:17.236] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[16:03:17.236] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:17.236] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:17.237] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:17.279] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:17.279] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:17.323] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:17.323] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:03:17.324] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:03:17.324] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[16:03:17.324] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[16:03:17.325] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:17.325] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:17.325] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:03:17.326] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:03:17.326] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:17.326] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:17.326] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:17.327] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:17.327] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[16:03:17.327] MultisessionFuture started
[16:03:17.328] - Launch lazy future ... done
[16:03:17.328] run() for ‘MultisessionFuture’ ... done
[16:03:17.328] Created future:
[16:03:17.328] MultisessionFuture:
[16:03:17.328] Label: ‘future_vapply-2’
[16:03:17.328] Expression:
[16:03:17.328] {
[16:03:17.328]     do.call(function(...) {
[16:03:17.328]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.328]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:17.328]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.328]             on.exit(options(oopts), add = TRUE)
[16:03:17.328]         }
[16:03:17.328]         {
[16:03:17.328]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:17.328]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.328]                 ...future.FUN(...future.X_jj, ...)
[16:03:17.328]             })
[16:03:17.328]         }
[16:03:17.328]     }, args = future.call.arguments)
[16:03:17.328] }
[16:03:17.328] Lazy evaluation: FALSE
[16:03:17.328] Asynchronous evaluation: TRUE
[16:03:17.328] Local evaluation: TRUE
[16:03:17.328] Environment: R_GlobalEnv
[16:03:17.328] Capture standard output: TRUE
[16:03:17.328] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:17.328] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:17.328] Packages: 1 packages (‘future.apply’)
[16:03:17.328] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:17.328] Resolved: FALSE
[16:03:17.328] Value: <not collected>
[16:03:17.328] Conditions captured: <none>
[16:03:17.328] Early signaling: FALSE
[16:03:17.328] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:17.328] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:17.340] Chunk #2 of 2 ... DONE
[16:03:17.340] Launching 2 futures (chunks) ... DONE
[16:03:17.340] Resolving 2 futures (chunks) ...
[16:03:17.340] resolve() on list ...
[16:03:17.340]  recursive: 0
[16:03:17.340]  length: 2
[16:03:17.340] 
[16:03:17.341] receiveMessageFromWorker() for ClusterFuture ...
[16:03:17.341] - Validating connection of MultisessionFuture
[16:03:17.341] - received message: FutureResult
[16:03:17.341] - Received FutureResult
[16:03:17.341] - Erased future from FutureRegistry
[16:03:17.341] result() for ClusterFuture ...
[16:03:17.342] - result already collected: FutureResult
[16:03:17.342] result() for ClusterFuture ... done
[16:03:17.342] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:17.342] Future #1
[16:03:17.342] result() for ClusterFuture ...
[16:03:17.342] - result already collected: FutureResult
[16:03:17.342] result() for ClusterFuture ... done
[16:03:17.342] result() for ClusterFuture ...
[16:03:17.342] - result already collected: FutureResult
[16:03:17.342] result() for ClusterFuture ... done
[16:03:17.343] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:17.343] - nx: 2
[16:03:17.343] - relay: TRUE
[16:03:17.343] - stdout: TRUE
[16:03:17.343] - signal: TRUE
[16:03:17.343] - resignal: FALSE
[16:03:17.343] - force: TRUE
[16:03:17.343] - relayed: [n=2] FALSE, FALSE
[16:03:17.343] - queued futures: [n=2] FALSE, FALSE
[16:03:17.343]  - until=1
[16:03:17.343]  - relaying element #1
[16:03:17.343] result() for ClusterFuture ...
[16:03:17.344] - result already collected: FutureResult
[16:03:17.344] result() for ClusterFuture ... done
[16:03:17.344] result() for ClusterFuture ...
[16:03:17.344] - result already collected: FutureResult
[16:03:17.344] result() for ClusterFuture ... done
[16:03:17.344] result() for ClusterFuture ...
[16:03:17.344] - result already collected: FutureResult
[16:03:17.344] result() for ClusterFuture ... done
[16:03:17.344] result() for ClusterFuture ...
[16:03:17.344] - result already collected: FutureResult
[16:03:17.344] result() for ClusterFuture ... done
[16:03:17.345] - relayed: [n=2] TRUE, FALSE
[16:03:17.345] - queued futures: [n=2] TRUE, FALSE
[16:03:17.345] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:17.345]  length: 1 (resolved future 1)
[16:03:17.376] receiveMessageFromWorker() for ClusterFuture ...
[16:03:17.376] - Validating connection of MultisessionFuture
[16:03:17.376] - received message: FutureResult
[16:03:17.376] - Received FutureResult
[16:03:17.377] - Erased future from FutureRegistry
[16:03:17.377] result() for ClusterFuture ...
[16:03:17.377] - result already collected: FutureResult
[16:03:17.377] result() for ClusterFuture ... done
[16:03:17.377] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:17.377] Future #2
[16:03:17.377] result() for ClusterFuture ...
[16:03:17.377] - result already collected: FutureResult
[16:03:17.377] result() for ClusterFuture ... done
[16:03:17.378] result() for ClusterFuture ...
[16:03:17.378] - result already collected: FutureResult
[16:03:17.378] result() for ClusterFuture ... done
[16:03:17.378] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:17.378] - nx: 2
[16:03:17.378] - relay: TRUE
[16:03:17.378] - stdout: TRUE
[16:03:17.378] - signal: TRUE
[16:03:17.378] - resignal: FALSE
[16:03:17.378] - force: TRUE
[16:03:17.378] - relayed: [n=2] TRUE, FALSE
[16:03:17.379] - queued futures: [n=2] TRUE, FALSE
[16:03:17.379]  - until=2
[16:03:17.379]  - relaying element #2
[16:03:17.379] result() for ClusterFuture ...
[16:03:17.379] - result already collected: FutureResult
[16:03:17.379] result() for ClusterFuture ... done
[16:03:17.379] result() for ClusterFuture ...
[16:03:17.379] - result already collected: FutureResult
[16:03:17.379] result() for ClusterFuture ... done
[16:03:17.380] result() for ClusterFuture ...
[16:03:17.380] - result already collected: FutureResult
[16:03:17.380] result() for ClusterFuture ... done
[16:03:17.380] result() for ClusterFuture ...
[16:03:17.380] - result already collected: FutureResult
[16:03:17.380] result() for ClusterFuture ... done
[16:03:17.380] - relayed: [n=2] TRUE, TRUE
[16:03:17.380] - queued futures: [n=2] TRUE, TRUE
[16:03:17.380] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:17.380]  length: 0 (resolved future 2)
[16:03:17.380] Relaying remaining futures
[16:03:17.381] signalConditionsASAP(NULL, pos=0) ...
[16:03:17.381] - nx: 2
[16:03:17.381] - relay: TRUE
[16:03:17.381] - stdout: TRUE
[16:03:17.381] - signal: TRUE
[16:03:17.381] - resignal: FALSE
[16:03:17.381] - force: TRUE
[16:03:17.381] - relayed: [n=2] TRUE, TRUE
[16:03:17.381] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:17.381] - relayed: [n=2] TRUE, TRUE
[16:03:17.381] - queued futures: [n=2] TRUE, TRUE
[16:03:17.382] signalConditionsASAP(NULL, pos=0) ... done
[16:03:17.382] resolve() on list ... DONE
[16:03:17.382] result() for ClusterFuture ...
[16:03:17.382] - result already collected: FutureResult
[16:03:17.382] result() for ClusterFuture ... done
[16:03:17.382] result() for ClusterFuture ...
[16:03:17.382] - result already collected: FutureResult
[16:03:17.382] result() for ClusterFuture ... done
[16:03:17.382] result() for ClusterFuture ...
[16:03:17.382] - result already collected: FutureResult
[16:03:17.382] result() for ClusterFuture ... done
[16:03:17.383] result() for ClusterFuture ...
[16:03:17.383] - result already collected: FutureResult
[16:03:17.383] result() for ClusterFuture ... done
[16:03:17.383]  - Number of value chunks collected: 2
[16:03:17.383] Resolving 2 futures (chunks) ... DONE
[16:03:17.383] Reducing values from 2 chunks ...
[16:03:17.383]  - Number of values collected after concatenation: 10
[16:03:17.383]  - Number of values expected: 10
[16:03:17.383] Reducing values from 2 chunks ... DONE
[16:03:17.383] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[16:03:17.384] future_lapply() ...
[16:03:17.390] Number of chunks: 2
[16:03:17.390] getGlobalsAndPackagesXApply() ...
[16:03:17.390]  - future.globals: TRUE
[16:03:17.390] getGlobalsAndPackages() ...
[16:03:17.390] Searching for globals...
[16:03:17.393] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:17.393] Searching for globals ... DONE
[16:03:17.393] Resolving globals: FALSE
[16:03:17.394] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[16:03:17.395] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:17.395] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:17.395] - packages: [1] ‘future.apply’
[16:03:17.395] getGlobalsAndPackages() ... DONE
[16:03:17.395]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:17.395]  - needed namespaces: [n=1] ‘future.apply’
[16:03:17.395] Finding globals ... DONE
[16:03:17.395]  - use_args: TRUE
[16:03:17.396]  - Getting '...' globals ...
[16:03:17.396] resolve() on list ...
[16:03:17.396]  recursive: 0
[16:03:17.396]  length: 1
[16:03:17.396]  elements: ‘...’
[16:03:17.396]  length: 0 (resolved future 1)
[16:03:17.396] resolve() on list ... DONE
[16:03:17.396]    - '...' content: [n=0] 
[16:03:17.397] List of 1
[16:03:17.397]  $ ...: list()
[16:03:17.397]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:17.397]  - attr(*, "where")=List of 1
[16:03:17.397]   ..$ ...:<environment: 0x564e456b2a18> 
[16:03:17.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:17.397]  - attr(*, "resolved")= logi TRUE
[16:03:17.397]  - attr(*, "total_size")= num NA
[16:03:17.399]  - Getting '...' globals ... DONE
[16:03:17.399] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:17.399] List of 8
[16:03:17.399]  $ ...future.FUN:function (x, ...)  
[16:03:17.399]  $ x_FUN        :function (x)  
[16:03:17.399]  $ times        : int 1
[16:03:17.399]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:17.399]  $ stop_if_not  :function (...)  
[16:03:17.399]  $ dim          : NULL
[16:03:17.399]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:17.399]  $ ...          : list()
[16:03:17.399]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:17.399]  - attr(*, "where")=List of 8
[16:03:17.399]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:17.399]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:17.399]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:17.399]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:17.399]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:17.399]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:17.399]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:17.399]   ..$ ...          :<environment: 0x564e456b2a18> 
[16:03:17.399]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:17.399]  - attr(*, "resolved")= logi FALSE
[16:03:17.399]  - attr(*, "total_size")= num 94336
[16:03:17.407] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:17.407] getGlobalsAndPackagesXApply() ... DONE
[16:03:17.407] Number of futures (= number of chunks): 2
[16:03:17.407] Launching 2 futures (chunks) ...
[16:03:17.407] Chunk #1 of 2 ...
[16:03:17.408]  - Finding globals in 'X' for chunk #1 ...
[16:03:17.408] getGlobalsAndPackages() ...
[16:03:17.408] Searching for globals...
[16:03:17.408] 
[16:03:17.408] Searching for globals ... DONE
[16:03:17.408] - globals: [0] <none>
[16:03:17.408] getGlobalsAndPackages() ... DONE
[16:03:17.408]    + additional globals found: [n=0] 
[16:03:17.408]    + additional namespaces needed: [n=0] 
[16:03:17.409]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:17.409]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:17.409]  - seeds: <none>
[16:03:17.409]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.409] getGlobalsAndPackages() ...
[16:03:17.409] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.409] Resolving globals: FALSE
[16:03:17.409] Tweak future expression to call with '...' arguments ...
[16:03:17.409] {
[16:03:17.409]     do.call(function(...) {
[16:03:17.409]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.409]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:17.409]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.409]             on.exit(options(oopts), add = TRUE)
[16:03:17.409]         }
[16:03:17.409]         {
[16:03:17.409]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:17.409]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.409]                 ...future.FUN(...future.X_jj, ...)
[16:03:17.409]             })
[16:03:17.409]         }
[16:03:17.409]     }, args = future.call.arguments)
[16:03:17.409] }
[16:03:17.410] Tweak future expression to call with '...' arguments ... DONE
[16:03:17.410] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.410] - packages: [1] ‘future.apply’
[16:03:17.410] getGlobalsAndPackages() ... DONE
[16:03:17.411] run() for ‘Future’ ...
[16:03:17.411] - state: ‘created’
[16:03:17.411] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:17.425] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:17.425] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:17.425]   - Field: ‘node’
[16:03:17.425]   - Field: ‘label’
[16:03:17.425]   - Field: ‘local’
[16:03:17.425]   - Field: ‘owner’
[16:03:17.425]   - Field: ‘envir’
[16:03:17.426]   - Field: ‘workers’
[16:03:17.426]   - Field: ‘packages’
[16:03:17.426]   - Field: ‘gc’
[16:03:17.426]   - Field: ‘conditions’
[16:03:17.426]   - Field: ‘persistent’
[16:03:17.426]   - Field: ‘expr’
[16:03:17.426]   - Field: ‘uuid’
[16:03:17.426]   - Field: ‘seed’
[16:03:17.426]   - Field: ‘version’
[16:03:17.426]   - Field: ‘result’
[16:03:17.426]   - Field: ‘asynchronous’
[16:03:17.427]   - Field: ‘calls’
[16:03:17.427]   - Field: ‘globals’
[16:03:17.427]   - Field: ‘stdout’
[16:03:17.427]   - Field: ‘earlySignal’
[16:03:17.427]   - Field: ‘lazy’
[16:03:17.427]   - Field: ‘state’
[16:03:17.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:17.427] - Launch lazy future ...
[16:03:17.428] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:17.428] Packages needed by future strategies (n = 0): <none>
[16:03:17.428] {
[16:03:17.428]     {
[16:03:17.428]         {
[16:03:17.428]             ...future.startTime <- base::Sys.time()
[16:03:17.428]             {
[16:03:17.428]                 {
[16:03:17.428]                   {
[16:03:17.428]                     {
[16:03:17.428]                       {
[16:03:17.428]                         base::local({
[16:03:17.428]                           has_future <- base::requireNamespace("future", 
[16:03:17.428]                             quietly = TRUE)
[16:03:17.428]                           if (has_future) {
[16:03:17.428]                             ns <- base::getNamespace("future")
[16:03:17.428]                             version <- ns[[".package"]][["version"]]
[16:03:17.428]                             if (is.null(version)) 
[16:03:17.428]                               version <- utils::packageVersion("future")
[16:03:17.428]                           }
[16:03:17.428]                           else {
[16:03:17.428]                             version <- NULL
[16:03:17.428]                           }
[16:03:17.428]                           if (!has_future || version < "1.8.0") {
[16:03:17.428]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:17.428]                               "", base::R.version$version.string), 
[16:03:17.428]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:17.428]                                 base::R.version$platform, 8 * 
[16:03:17.428]                                   base::.Machine$sizeof.pointer), 
[16:03:17.428]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:17.428]                                 "release", "version")], collapse = " "), 
[16:03:17.428]                               hostname = base::Sys.info()[["nodename"]])
[16:03:17.428]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:17.428]                               info)
[16:03:17.428]                             info <- base::paste(info, collapse = "; ")
[16:03:17.428]                             if (!has_future) {
[16:03:17.428]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:17.428]                                 info)
[16:03:17.428]                             }
[16:03:17.428]                             else {
[16:03:17.428]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:17.428]                                 info, version)
[16:03:17.428]                             }
[16:03:17.428]                             base::stop(msg)
[16:03:17.428]                           }
[16:03:17.428]                         })
[16:03:17.428]                       }
[16:03:17.428]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:17.428]                       base::options(mc.cores = 1L)
[16:03:17.428]                     }
[16:03:17.428]                     base::local({
[16:03:17.428]                       for (pkg in "future.apply") {
[16:03:17.428]                         base::loadNamespace(pkg)
[16:03:17.428]                         base::library(pkg, character.only = TRUE)
[16:03:17.428]                       }
[16:03:17.428]                     })
[16:03:17.428]                   }
[16:03:17.428]                   options(future.plan = NULL)
[16:03:17.428]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:17.428]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:17.428]                 }
[16:03:17.428]                 ...future.workdir <- getwd()
[16:03:17.428]             }
[16:03:17.428]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:17.428]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:17.428]         }
[16:03:17.428]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:17.428]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:17.428]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:17.428]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:17.428]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:17.428]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:17.428]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:17.428]             base::names(...future.oldOptions))
[16:03:17.428]     }
[16:03:17.428]     if (FALSE) {
[16:03:17.428]     }
[16:03:17.428]     else {
[16:03:17.428]         if (TRUE) {
[16:03:17.428]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:17.428]                 open = "w")
[16:03:17.428]         }
[16:03:17.428]         else {
[16:03:17.428]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:17.428]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:17.428]         }
[16:03:17.428]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:17.428]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:17.428]             base::sink(type = "output", split = FALSE)
[16:03:17.428]             base::close(...future.stdout)
[16:03:17.428]         }, add = TRUE)
[16:03:17.428]     }
[16:03:17.428]     ...future.frame <- base::sys.nframe()
[16:03:17.428]     ...future.conditions <- base::list()
[16:03:17.428]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:17.428]     if (FALSE) {
[16:03:17.428]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:17.428]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:17.428]     }
[16:03:17.428]     ...future.result <- base::tryCatch({
[16:03:17.428]         base::withCallingHandlers({
[16:03:17.428]             ...future.value <- base::withVisible(base::local({
[16:03:17.428]                 ...future.makeSendCondition <- base::local({
[16:03:17.428]                   sendCondition <- NULL
[16:03:17.428]                   function(frame = 1L) {
[16:03:17.428]                     if (is.function(sendCondition)) 
[16:03:17.428]                       return(sendCondition)
[16:03:17.428]                     ns <- getNamespace("parallel")
[16:03:17.428]                     if (exists("sendData", mode = "function", 
[16:03:17.428]                       envir = ns)) {
[16:03:17.428]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:17.428]                         envir = ns)
[16:03:17.428]                       envir <- sys.frame(frame)
[16:03:17.428]                       master <- NULL
[16:03:17.428]                       while (!identical(envir, .GlobalEnv) && 
[16:03:17.428]                         !identical(envir, emptyenv())) {
[16:03:17.428]                         if (exists("master", mode = "list", envir = envir, 
[16:03:17.428]                           inherits = FALSE)) {
[16:03:17.428]                           master <- get("master", mode = "list", 
[16:03:17.428]                             envir = envir, inherits = FALSE)
[16:03:17.428]                           if (inherits(master, c("SOCKnode", 
[16:03:17.428]                             "SOCK0node"))) {
[16:03:17.428]                             sendCondition <<- function(cond) {
[16:03:17.428]                               data <- list(type = "VALUE", value = cond, 
[16:03:17.428]                                 success = TRUE)
[16:03:17.428]                               parallel_sendData(master, data)
[16:03:17.428]                             }
[16:03:17.428]                             return(sendCondition)
[16:03:17.428]                           }
[16:03:17.428]                         }
[16:03:17.428]                         frame <- frame + 1L
[16:03:17.428]                         envir <- sys.frame(frame)
[16:03:17.428]                       }
[16:03:17.428]                     }
[16:03:17.428]                     sendCondition <<- function(cond) NULL
[16:03:17.428]                   }
[16:03:17.428]                 })
[16:03:17.428]                 withCallingHandlers({
[16:03:17.428]                   {
[16:03:17.428]                     do.call(function(...) {
[16:03:17.428]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.428]                       if (!identical(...future.globals.maxSize.org, 
[16:03:17.428]                         ...future.globals.maxSize)) {
[16:03:17.428]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.428]                         on.exit(options(oopts), add = TRUE)
[16:03:17.428]                       }
[16:03:17.428]                       {
[16:03:17.428]                         lapply(seq_along(...future.elements_ii), 
[16:03:17.428]                           FUN = function(jj) {
[16:03:17.428]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.428]                             ...future.FUN(...future.X_jj, ...)
[16:03:17.428]                           })
[16:03:17.428]                       }
[16:03:17.428]                     }, args = future.call.arguments)
[16:03:17.428]                   }
[16:03:17.428]                 }, immediateCondition = function(cond) {
[16:03:17.428]                   sendCondition <- ...future.makeSendCondition()
[16:03:17.428]                   sendCondition(cond)
[16:03:17.428]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.428]                   {
[16:03:17.428]                     inherits <- base::inherits
[16:03:17.428]                     invokeRestart <- base::invokeRestart
[16:03:17.428]                     is.null <- base::is.null
[16:03:17.428]                     muffled <- FALSE
[16:03:17.428]                     if (inherits(cond, "message")) {
[16:03:17.428]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:17.428]                       if (muffled) 
[16:03:17.428]                         invokeRestart("muffleMessage")
[16:03:17.428]                     }
[16:03:17.428]                     else if (inherits(cond, "warning")) {
[16:03:17.428]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:17.428]                       if (muffled) 
[16:03:17.428]                         invokeRestart("muffleWarning")
[16:03:17.428]                     }
[16:03:17.428]                     else if (inherits(cond, "condition")) {
[16:03:17.428]                       if (!is.null(pattern)) {
[16:03:17.428]                         computeRestarts <- base::computeRestarts
[16:03:17.428]                         grepl <- base::grepl
[16:03:17.428]                         restarts <- computeRestarts(cond)
[16:03:17.428]                         for (restart in restarts) {
[16:03:17.428]                           name <- restart$name
[16:03:17.428]                           if (is.null(name)) 
[16:03:17.428]                             next
[16:03:17.428]                           if (!grepl(pattern, name)) 
[16:03:17.428]                             next
[16:03:17.428]                           invokeRestart(restart)
[16:03:17.428]                           muffled <- TRUE
[16:03:17.428]                           break
[16:03:17.428]                         }
[16:03:17.428]                       }
[16:03:17.428]                     }
[16:03:17.428]                     invisible(muffled)
[16:03:17.428]                   }
[16:03:17.428]                   muffleCondition(cond)
[16:03:17.428]                 })
[16:03:17.428]             }))
[16:03:17.428]             future::FutureResult(value = ...future.value$value, 
[16:03:17.428]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:17.428]                   ...future.rng), globalenv = if (FALSE) 
[16:03:17.428]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:17.428]                     ...future.globalenv.names))
[16:03:17.428]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:17.428]         }, condition = base::local({
[16:03:17.428]             c <- base::c
[16:03:17.428]             inherits <- base::inherits
[16:03:17.428]             invokeRestart <- base::invokeRestart
[16:03:17.428]             length <- base::length
[16:03:17.428]             list <- base::list
[16:03:17.428]             seq.int <- base::seq.int
[16:03:17.428]             signalCondition <- base::signalCondition
[16:03:17.428]             sys.calls <- base::sys.calls
[16:03:17.428]             `[[` <- base::`[[`
[16:03:17.428]             `+` <- base::`+`
[16:03:17.428]             `<<-` <- base::`<<-`
[16:03:17.428]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:17.428]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:17.428]                   3L)]
[16:03:17.428]             }
[16:03:17.428]             function(cond) {
[16:03:17.428]                 is_error <- inherits(cond, "error")
[16:03:17.428]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:17.428]                   NULL)
[16:03:17.428]                 if (is_error) {
[16:03:17.428]                   sessionInformation <- function() {
[16:03:17.428]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:17.428]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:17.428]                       search = base::search(), system = base::Sys.info())
[16:03:17.428]                   }
[16:03:17.428]                   ...future.conditions[[length(...future.conditions) + 
[16:03:17.428]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:17.428]                     cond$call), session = sessionInformation(), 
[16:03:17.428]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:17.428]                   signalCondition(cond)
[16:03:17.428]                 }
[16:03:17.428]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:17.428]                 "immediateCondition"))) {
[16:03:17.428]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:17.428]                   ...future.conditions[[length(...future.conditions) + 
[16:03:17.428]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:17.428]                   if (TRUE && !signal) {
[16:03:17.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.428]                     {
[16:03:17.428]                       inherits <- base::inherits
[16:03:17.428]                       invokeRestart <- base::invokeRestart
[16:03:17.428]                       is.null <- base::is.null
[16:03:17.428]                       muffled <- FALSE
[16:03:17.428]                       if (inherits(cond, "message")) {
[16:03:17.428]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:17.428]                         if (muffled) 
[16:03:17.428]                           invokeRestart("muffleMessage")
[16:03:17.428]                       }
[16:03:17.428]                       else if (inherits(cond, "warning")) {
[16:03:17.428]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:17.428]                         if (muffled) 
[16:03:17.428]                           invokeRestart("muffleWarning")
[16:03:17.428]                       }
[16:03:17.428]                       else if (inherits(cond, "condition")) {
[16:03:17.428]                         if (!is.null(pattern)) {
[16:03:17.428]                           computeRestarts <- base::computeRestarts
[16:03:17.428]                           grepl <- base::grepl
[16:03:17.428]                           restarts <- computeRestarts(cond)
[16:03:17.428]                           for (restart in restarts) {
[16:03:17.428]                             name <- restart$name
[16:03:17.428]                             if (is.null(name)) 
[16:03:17.428]                               next
[16:03:17.428]                             if (!grepl(pattern, name)) 
[16:03:17.428]                               next
[16:03:17.428]                             invokeRestart(restart)
[16:03:17.428]                             muffled <- TRUE
[16:03:17.428]                             break
[16:03:17.428]                           }
[16:03:17.428]                         }
[16:03:17.428]                       }
[16:03:17.428]                       invisible(muffled)
[16:03:17.428]                     }
[16:03:17.428]                     muffleCondition(cond, pattern = "^muffle")
[16:03:17.428]                   }
[16:03:17.428]                 }
[16:03:17.428]                 else {
[16:03:17.428]                   if (TRUE) {
[16:03:17.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.428]                     {
[16:03:17.428]                       inherits <- base::inherits
[16:03:17.428]                       invokeRestart <- base::invokeRestart
[16:03:17.428]                       is.null <- base::is.null
[16:03:17.428]                       muffled <- FALSE
[16:03:17.428]                       if (inherits(cond, "message")) {
[16:03:17.428]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:17.428]                         if (muffled) 
[16:03:17.428]                           invokeRestart("muffleMessage")
[16:03:17.428]                       }
[16:03:17.428]                       else if (inherits(cond, "warning")) {
[16:03:17.428]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:17.428]                         if (muffled) 
[16:03:17.428]                           invokeRestart("muffleWarning")
[16:03:17.428]                       }
[16:03:17.428]                       else if (inherits(cond, "condition")) {
[16:03:17.428]                         if (!is.null(pattern)) {
[16:03:17.428]                           computeRestarts <- base::computeRestarts
[16:03:17.428]                           grepl <- base::grepl
[16:03:17.428]                           restarts <- computeRestarts(cond)
[16:03:17.428]                           for (restart in restarts) {
[16:03:17.428]                             name <- restart$name
[16:03:17.428]                             if (is.null(name)) 
[16:03:17.428]                               next
[16:03:17.428]                             if (!grepl(pattern, name)) 
[16:03:17.428]                               next
[16:03:17.428]                             invokeRestart(restart)
[16:03:17.428]                             muffled <- TRUE
[16:03:17.428]                             break
[16:03:17.428]                           }
[16:03:17.428]                         }
[16:03:17.428]                       }
[16:03:17.428]                       invisible(muffled)
[16:03:17.428]                     }
[16:03:17.428]                     muffleCondition(cond, pattern = "^muffle")
[16:03:17.428]                   }
[16:03:17.428]                 }
[16:03:17.428]             }
[16:03:17.428]         }))
[16:03:17.428]     }, error = function(ex) {
[16:03:17.428]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:17.428]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:17.428]                 ...future.rng), started = ...future.startTime, 
[16:03:17.428]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:17.428]             version = "1.8"), class = "FutureResult")
[16:03:17.428]     }, finally = {
[16:03:17.428]         if (!identical(...future.workdir, getwd())) 
[16:03:17.428]             setwd(...future.workdir)
[16:03:17.428]         {
[16:03:17.428]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:17.428]                 ...future.oldOptions$nwarnings <- NULL
[16:03:17.428]             }
[16:03:17.428]             base::options(...future.oldOptions)
[16:03:17.428]             if (.Platform$OS.type == "windows") {
[16:03:17.428]                 old_names <- names(...future.oldEnvVars)
[16:03:17.428]                 envs <- base::Sys.getenv()
[16:03:17.428]                 names <- names(envs)
[16:03:17.428]                 common <- intersect(names, old_names)
[16:03:17.428]                 added <- setdiff(names, old_names)
[16:03:17.428]                 removed <- setdiff(old_names, names)
[16:03:17.428]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:17.428]                   envs[common]]
[16:03:17.428]                 NAMES <- toupper(changed)
[16:03:17.428]                 args <- list()
[16:03:17.428]                 for (kk in seq_along(NAMES)) {
[16:03:17.428]                   name <- changed[[kk]]
[16:03:17.428]                   NAME <- NAMES[[kk]]
[16:03:17.428]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.428]                     next
[16:03:17.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:17.428]                 }
[16:03:17.428]                 NAMES <- toupper(added)
[16:03:17.428]                 for (kk in seq_along(NAMES)) {
[16:03:17.428]                   name <- added[[kk]]
[16:03:17.428]                   NAME <- NAMES[[kk]]
[16:03:17.428]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.428]                     next
[16:03:17.428]                   args[[name]] <- ""
[16:03:17.428]                 }
[16:03:17.428]                 NAMES <- toupper(removed)
[16:03:17.428]                 for (kk in seq_along(NAMES)) {
[16:03:17.428]                   name <- removed[[kk]]
[16:03:17.428]                   NAME <- NAMES[[kk]]
[16:03:17.428]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.428]                     next
[16:03:17.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:17.428]                 }
[16:03:17.428]                 if (length(args) > 0) 
[16:03:17.428]                   base::do.call(base::Sys.setenv, args = args)
[16:03:17.428]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:17.428]             }
[16:03:17.428]             else {
[16:03:17.428]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:17.428]             }
[16:03:17.428]             {
[16:03:17.428]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:17.428]                   0L) {
[16:03:17.428]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:17.428]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:17.428]                   base::options(opts)
[16:03:17.428]                 }
[16:03:17.428]                 {
[16:03:17.428]                   {
[16:03:17.428]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:17.428]                     NULL
[16:03:17.428]                   }
[16:03:17.428]                   options(future.plan = NULL)
[16:03:17.428]                   if (is.na(NA_character_)) 
[16:03:17.428]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:17.428]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:17.428]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:17.428]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:17.428]                     envir = parent.frame()) 
[16:03:17.428]                   {
[16:03:17.428]                     if (is.function(workers)) 
[16:03:17.428]                       workers <- workers()
[16:03:17.428]                     workers <- structure(as.integer(workers), 
[16:03:17.428]                       class = class(workers))
[16:03:17.428]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:17.428]                       workers >= 1)
[16:03:17.428]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:17.428]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:17.428]                     }
[16:03:17.428]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:17.428]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:17.428]                       envir = envir)
[16:03:17.428]                     if (!future$lazy) 
[16:03:17.428]                       future <- run(future)
[16:03:17.428]                     invisible(future)
[16:03:17.428]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:17.428]                 }
[16:03:17.428]             }
[16:03:17.428]         }
[16:03:17.428]     })
[16:03:17.428]     if (TRUE) {
[16:03:17.428]         base::sink(type = "output", split = FALSE)
[16:03:17.428]         if (TRUE) {
[16:03:17.428]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:17.428]         }
[16:03:17.428]         else {
[16:03:17.428]             ...future.result["stdout"] <- base::list(NULL)
[16:03:17.428]         }
[16:03:17.428]         base::close(...future.stdout)
[16:03:17.428]         ...future.stdout <- NULL
[16:03:17.428]     }
[16:03:17.428]     ...future.result$conditions <- ...future.conditions
[16:03:17.428]     ...future.result$finished <- base::Sys.time()
[16:03:17.428]     ...future.result
[16:03:17.428] }
[16:03:17.431] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[16:03:17.431] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:17.475] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:17.475] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:03:17.476] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:03:17.476] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:17.477] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:17.477] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:17.519] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:17.519] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:17.563] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:17.563] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:03:17.564] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.564] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:03:17.564] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:03:17.565] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:17.565] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.565] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:03:17.566] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:03:17.566] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:17.566] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.566] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:17.567] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.567] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[16:03:17.567] MultisessionFuture started
[16:03:17.567] - Launch lazy future ... done
[16:03:17.568] run() for ‘MultisessionFuture’ ... done
[16:03:17.568] Created future:
[16:03:17.568] MultisessionFuture:
[16:03:17.568] Label: ‘future_vapply-1’
[16:03:17.568] Expression:
[16:03:17.568] {
[16:03:17.568]     do.call(function(...) {
[16:03:17.568]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.568]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:17.568]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.568]             on.exit(options(oopts), add = TRUE)
[16:03:17.568]         }
[16:03:17.568]         {
[16:03:17.568]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:17.568]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.568]                 ...future.FUN(...future.X_jj, ...)
[16:03:17.568]             })
[16:03:17.568]         }
[16:03:17.568]     }, args = future.call.arguments)
[16:03:17.568] }
[16:03:17.568] Lazy evaluation: FALSE
[16:03:17.568] Asynchronous evaluation: TRUE
[16:03:17.568] Local evaluation: TRUE
[16:03:17.568] Environment: R_GlobalEnv
[16:03:17.568] Capture standard output: TRUE
[16:03:17.568] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:17.568] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:17.568] Packages: 1 packages (‘future.apply’)
[16:03:17.568] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:17.568] Resolved: FALSE
[16:03:17.568] Value: <not collected>
[16:03:17.568] Conditions captured: <none>
[16:03:17.568] Early signaling: FALSE
[16:03:17.568] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:17.568] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:17.580] Chunk #1 of 2 ... DONE
[16:03:17.580] Chunk #2 of 2 ...
[16:03:17.580]  - Finding globals in 'X' for chunk #2 ...
[16:03:17.580] getGlobalsAndPackages() ...
[16:03:17.580] Searching for globals...
[16:03:17.580] 
[16:03:17.580] Searching for globals ... DONE
[16:03:17.581] - globals: [0] <none>
[16:03:17.581] getGlobalsAndPackages() ... DONE
[16:03:17.581]    + additional globals found: [n=0] 
[16:03:17.581]    + additional namespaces needed: [n=0] 
[16:03:17.581]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:17.581]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:17.581]  - seeds: <none>
[16:03:17.581]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.581] getGlobalsAndPackages() ...
[16:03:17.581] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.582] Resolving globals: FALSE
[16:03:17.582] Tweak future expression to call with '...' arguments ...
[16:03:17.582] {
[16:03:17.582]     do.call(function(...) {
[16:03:17.582]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.582]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:17.582]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.582]             on.exit(options(oopts), add = TRUE)
[16:03:17.582]         }
[16:03:17.582]         {
[16:03:17.582]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:17.582]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.582]                 ...future.FUN(...future.X_jj, ...)
[16:03:17.582]             })
[16:03:17.582]         }
[16:03:17.582]     }, args = future.call.arguments)
[16:03:17.582] }
[16:03:17.582] Tweak future expression to call with '...' arguments ... DONE
[16:03:17.583] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.583] - packages: [1] ‘future.apply’
[16:03:17.583] getGlobalsAndPackages() ... DONE
[16:03:17.583] run() for ‘Future’ ...
[16:03:17.583] - state: ‘created’
[16:03:17.583] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:17.597] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:17.597] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:17.598]   - Field: ‘node’
[16:03:17.598]   - Field: ‘label’
[16:03:17.598]   - Field: ‘local’
[16:03:17.598]   - Field: ‘owner’
[16:03:17.598]   - Field: ‘envir’
[16:03:17.598]   - Field: ‘workers’
[16:03:17.598]   - Field: ‘packages’
[16:03:17.598]   - Field: ‘gc’
[16:03:17.598]   - Field: ‘conditions’
[16:03:17.598]   - Field: ‘persistent’
[16:03:17.598]   - Field: ‘expr’
[16:03:17.599]   - Field: ‘uuid’
[16:03:17.599]   - Field: ‘seed’
[16:03:17.599]   - Field: ‘version’
[16:03:17.599]   - Field: ‘result’
[16:03:17.599]   - Field: ‘asynchronous’
[16:03:17.599]   - Field: ‘calls’
[16:03:17.599]   - Field: ‘globals’
[16:03:17.599]   - Field: ‘stdout’
[16:03:17.599]   - Field: ‘earlySignal’
[16:03:17.599]   - Field: ‘lazy’
[16:03:17.600]   - Field: ‘state’
[16:03:17.600] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:17.600] - Launch lazy future ...
[16:03:17.600] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:17.600] Packages needed by future strategies (n = 0): <none>
[16:03:17.601] {
[16:03:17.601]     {
[16:03:17.601]         {
[16:03:17.601]             ...future.startTime <- base::Sys.time()
[16:03:17.601]             {
[16:03:17.601]                 {
[16:03:17.601]                   {
[16:03:17.601]                     {
[16:03:17.601]                       {
[16:03:17.601]                         base::local({
[16:03:17.601]                           has_future <- base::requireNamespace("future", 
[16:03:17.601]                             quietly = TRUE)
[16:03:17.601]                           if (has_future) {
[16:03:17.601]                             ns <- base::getNamespace("future")
[16:03:17.601]                             version <- ns[[".package"]][["version"]]
[16:03:17.601]                             if (is.null(version)) 
[16:03:17.601]                               version <- utils::packageVersion("future")
[16:03:17.601]                           }
[16:03:17.601]                           else {
[16:03:17.601]                             version <- NULL
[16:03:17.601]                           }
[16:03:17.601]                           if (!has_future || version < "1.8.0") {
[16:03:17.601]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:17.601]                               "", base::R.version$version.string), 
[16:03:17.601]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:17.601]                                 base::R.version$platform, 8 * 
[16:03:17.601]                                   base::.Machine$sizeof.pointer), 
[16:03:17.601]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:17.601]                                 "release", "version")], collapse = " "), 
[16:03:17.601]                               hostname = base::Sys.info()[["nodename"]])
[16:03:17.601]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:17.601]                               info)
[16:03:17.601]                             info <- base::paste(info, collapse = "; ")
[16:03:17.601]                             if (!has_future) {
[16:03:17.601]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:17.601]                                 info)
[16:03:17.601]                             }
[16:03:17.601]                             else {
[16:03:17.601]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:17.601]                                 info, version)
[16:03:17.601]                             }
[16:03:17.601]                             base::stop(msg)
[16:03:17.601]                           }
[16:03:17.601]                         })
[16:03:17.601]                       }
[16:03:17.601]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:17.601]                       base::options(mc.cores = 1L)
[16:03:17.601]                     }
[16:03:17.601]                     base::local({
[16:03:17.601]                       for (pkg in "future.apply") {
[16:03:17.601]                         base::loadNamespace(pkg)
[16:03:17.601]                         base::library(pkg, character.only = TRUE)
[16:03:17.601]                       }
[16:03:17.601]                     })
[16:03:17.601]                   }
[16:03:17.601]                   options(future.plan = NULL)
[16:03:17.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:17.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:17.601]                 }
[16:03:17.601]                 ...future.workdir <- getwd()
[16:03:17.601]             }
[16:03:17.601]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:17.601]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:17.601]         }
[16:03:17.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:17.601]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:17.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:17.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:17.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:17.601]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:17.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:17.601]             base::names(...future.oldOptions))
[16:03:17.601]     }
[16:03:17.601]     if (FALSE) {
[16:03:17.601]     }
[16:03:17.601]     else {
[16:03:17.601]         if (TRUE) {
[16:03:17.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:17.601]                 open = "w")
[16:03:17.601]         }
[16:03:17.601]         else {
[16:03:17.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:17.601]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:17.601]         }
[16:03:17.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:17.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:17.601]             base::sink(type = "output", split = FALSE)
[16:03:17.601]             base::close(...future.stdout)
[16:03:17.601]         }, add = TRUE)
[16:03:17.601]     }
[16:03:17.601]     ...future.frame <- base::sys.nframe()
[16:03:17.601]     ...future.conditions <- base::list()
[16:03:17.601]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:17.601]     if (FALSE) {
[16:03:17.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:17.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:17.601]     }
[16:03:17.601]     ...future.result <- base::tryCatch({
[16:03:17.601]         base::withCallingHandlers({
[16:03:17.601]             ...future.value <- base::withVisible(base::local({
[16:03:17.601]                 ...future.makeSendCondition <- base::local({
[16:03:17.601]                   sendCondition <- NULL
[16:03:17.601]                   function(frame = 1L) {
[16:03:17.601]                     if (is.function(sendCondition)) 
[16:03:17.601]                       return(sendCondition)
[16:03:17.601]                     ns <- getNamespace("parallel")
[16:03:17.601]                     if (exists("sendData", mode = "function", 
[16:03:17.601]                       envir = ns)) {
[16:03:17.601]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:17.601]                         envir = ns)
[16:03:17.601]                       envir <- sys.frame(frame)
[16:03:17.601]                       master <- NULL
[16:03:17.601]                       while (!identical(envir, .GlobalEnv) && 
[16:03:17.601]                         !identical(envir, emptyenv())) {
[16:03:17.601]                         if (exists("master", mode = "list", envir = envir, 
[16:03:17.601]                           inherits = FALSE)) {
[16:03:17.601]                           master <- get("master", mode = "list", 
[16:03:17.601]                             envir = envir, inherits = FALSE)
[16:03:17.601]                           if (inherits(master, c("SOCKnode", 
[16:03:17.601]                             "SOCK0node"))) {
[16:03:17.601]                             sendCondition <<- function(cond) {
[16:03:17.601]                               data <- list(type = "VALUE", value = cond, 
[16:03:17.601]                                 success = TRUE)
[16:03:17.601]                               parallel_sendData(master, data)
[16:03:17.601]                             }
[16:03:17.601]                             return(sendCondition)
[16:03:17.601]                           }
[16:03:17.601]                         }
[16:03:17.601]                         frame <- frame + 1L
[16:03:17.601]                         envir <- sys.frame(frame)
[16:03:17.601]                       }
[16:03:17.601]                     }
[16:03:17.601]                     sendCondition <<- function(cond) NULL
[16:03:17.601]                   }
[16:03:17.601]                 })
[16:03:17.601]                 withCallingHandlers({
[16:03:17.601]                   {
[16:03:17.601]                     do.call(function(...) {
[16:03:17.601]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.601]                       if (!identical(...future.globals.maxSize.org, 
[16:03:17.601]                         ...future.globals.maxSize)) {
[16:03:17.601]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.601]                         on.exit(options(oopts), add = TRUE)
[16:03:17.601]                       }
[16:03:17.601]                       {
[16:03:17.601]                         lapply(seq_along(...future.elements_ii), 
[16:03:17.601]                           FUN = function(jj) {
[16:03:17.601]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.601]                             ...future.FUN(...future.X_jj, ...)
[16:03:17.601]                           })
[16:03:17.601]                       }
[16:03:17.601]                     }, args = future.call.arguments)
[16:03:17.601]                   }
[16:03:17.601]                 }, immediateCondition = function(cond) {
[16:03:17.601]                   sendCondition <- ...future.makeSendCondition()
[16:03:17.601]                   sendCondition(cond)
[16:03:17.601]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.601]                   {
[16:03:17.601]                     inherits <- base::inherits
[16:03:17.601]                     invokeRestart <- base::invokeRestart
[16:03:17.601]                     is.null <- base::is.null
[16:03:17.601]                     muffled <- FALSE
[16:03:17.601]                     if (inherits(cond, "message")) {
[16:03:17.601]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:17.601]                       if (muffled) 
[16:03:17.601]                         invokeRestart("muffleMessage")
[16:03:17.601]                     }
[16:03:17.601]                     else if (inherits(cond, "warning")) {
[16:03:17.601]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:17.601]                       if (muffled) 
[16:03:17.601]                         invokeRestart("muffleWarning")
[16:03:17.601]                     }
[16:03:17.601]                     else if (inherits(cond, "condition")) {
[16:03:17.601]                       if (!is.null(pattern)) {
[16:03:17.601]                         computeRestarts <- base::computeRestarts
[16:03:17.601]                         grepl <- base::grepl
[16:03:17.601]                         restarts <- computeRestarts(cond)
[16:03:17.601]                         for (restart in restarts) {
[16:03:17.601]                           name <- restart$name
[16:03:17.601]                           if (is.null(name)) 
[16:03:17.601]                             next
[16:03:17.601]                           if (!grepl(pattern, name)) 
[16:03:17.601]                             next
[16:03:17.601]                           invokeRestart(restart)
[16:03:17.601]                           muffled <- TRUE
[16:03:17.601]                           break
[16:03:17.601]                         }
[16:03:17.601]                       }
[16:03:17.601]                     }
[16:03:17.601]                     invisible(muffled)
[16:03:17.601]                   }
[16:03:17.601]                   muffleCondition(cond)
[16:03:17.601]                 })
[16:03:17.601]             }))
[16:03:17.601]             future::FutureResult(value = ...future.value$value, 
[16:03:17.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:17.601]                   ...future.rng), globalenv = if (FALSE) 
[16:03:17.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:17.601]                     ...future.globalenv.names))
[16:03:17.601]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:17.601]         }, condition = base::local({
[16:03:17.601]             c <- base::c
[16:03:17.601]             inherits <- base::inherits
[16:03:17.601]             invokeRestart <- base::invokeRestart
[16:03:17.601]             length <- base::length
[16:03:17.601]             list <- base::list
[16:03:17.601]             seq.int <- base::seq.int
[16:03:17.601]             signalCondition <- base::signalCondition
[16:03:17.601]             sys.calls <- base::sys.calls
[16:03:17.601]             `[[` <- base::`[[`
[16:03:17.601]             `+` <- base::`+`
[16:03:17.601]             `<<-` <- base::`<<-`
[16:03:17.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:17.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:17.601]                   3L)]
[16:03:17.601]             }
[16:03:17.601]             function(cond) {
[16:03:17.601]                 is_error <- inherits(cond, "error")
[16:03:17.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:17.601]                   NULL)
[16:03:17.601]                 if (is_error) {
[16:03:17.601]                   sessionInformation <- function() {
[16:03:17.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:17.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:17.601]                       search = base::search(), system = base::Sys.info())
[16:03:17.601]                   }
[16:03:17.601]                   ...future.conditions[[length(...future.conditions) + 
[16:03:17.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:17.601]                     cond$call), session = sessionInformation(), 
[16:03:17.601]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:17.601]                   signalCondition(cond)
[16:03:17.601]                 }
[16:03:17.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:17.601]                 "immediateCondition"))) {
[16:03:17.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:17.601]                   ...future.conditions[[length(...future.conditions) + 
[16:03:17.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:17.601]                   if (TRUE && !signal) {
[16:03:17.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.601]                     {
[16:03:17.601]                       inherits <- base::inherits
[16:03:17.601]                       invokeRestart <- base::invokeRestart
[16:03:17.601]                       is.null <- base::is.null
[16:03:17.601]                       muffled <- FALSE
[16:03:17.601]                       if (inherits(cond, "message")) {
[16:03:17.601]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:17.601]                         if (muffled) 
[16:03:17.601]                           invokeRestart("muffleMessage")
[16:03:17.601]                       }
[16:03:17.601]                       else if (inherits(cond, "warning")) {
[16:03:17.601]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:17.601]                         if (muffled) 
[16:03:17.601]                           invokeRestart("muffleWarning")
[16:03:17.601]                       }
[16:03:17.601]                       else if (inherits(cond, "condition")) {
[16:03:17.601]                         if (!is.null(pattern)) {
[16:03:17.601]                           computeRestarts <- base::computeRestarts
[16:03:17.601]                           grepl <- base::grepl
[16:03:17.601]                           restarts <- computeRestarts(cond)
[16:03:17.601]                           for (restart in restarts) {
[16:03:17.601]                             name <- restart$name
[16:03:17.601]                             if (is.null(name)) 
[16:03:17.601]                               next
[16:03:17.601]                             if (!grepl(pattern, name)) 
[16:03:17.601]                               next
[16:03:17.601]                             invokeRestart(restart)
[16:03:17.601]                             muffled <- TRUE
[16:03:17.601]                             break
[16:03:17.601]                           }
[16:03:17.601]                         }
[16:03:17.601]                       }
[16:03:17.601]                       invisible(muffled)
[16:03:17.601]                     }
[16:03:17.601]                     muffleCondition(cond, pattern = "^muffle")
[16:03:17.601]                   }
[16:03:17.601]                 }
[16:03:17.601]                 else {
[16:03:17.601]                   if (TRUE) {
[16:03:17.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.601]                     {
[16:03:17.601]                       inherits <- base::inherits
[16:03:17.601]                       invokeRestart <- base::invokeRestart
[16:03:17.601]                       is.null <- base::is.null
[16:03:17.601]                       muffled <- FALSE
[16:03:17.601]                       if (inherits(cond, "message")) {
[16:03:17.601]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:17.601]                         if (muffled) 
[16:03:17.601]                           invokeRestart("muffleMessage")
[16:03:17.601]                       }
[16:03:17.601]                       else if (inherits(cond, "warning")) {
[16:03:17.601]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:17.601]                         if (muffled) 
[16:03:17.601]                           invokeRestart("muffleWarning")
[16:03:17.601]                       }
[16:03:17.601]                       else if (inherits(cond, "condition")) {
[16:03:17.601]                         if (!is.null(pattern)) {
[16:03:17.601]                           computeRestarts <- base::computeRestarts
[16:03:17.601]                           grepl <- base::grepl
[16:03:17.601]                           restarts <- computeRestarts(cond)
[16:03:17.601]                           for (restart in restarts) {
[16:03:17.601]                             name <- restart$name
[16:03:17.601]                             if (is.null(name)) 
[16:03:17.601]                               next
[16:03:17.601]                             if (!grepl(pattern, name)) 
[16:03:17.601]                               next
[16:03:17.601]                             invokeRestart(restart)
[16:03:17.601]                             muffled <- TRUE
[16:03:17.601]                             break
[16:03:17.601]                           }
[16:03:17.601]                         }
[16:03:17.601]                       }
[16:03:17.601]                       invisible(muffled)
[16:03:17.601]                     }
[16:03:17.601]                     muffleCondition(cond, pattern = "^muffle")
[16:03:17.601]                   }
[16:03:17.601]                 }
[16:03:17.601]             }
[16:03:17.601]         }))
[16:03:17.601]     }, error = function(ex) {
[16:03:17.601]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:17.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:17.601]                 ...future.rng), started = ...future.startTime, 
[16:03:17.601]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:17.601]             version = "1.8"), class = "FutureResult")
[16:03:17.601]     }, finally = {
[16:03:17.601]         if (!identical(...future.workdir, getwd())) 
[16:03:17.601]             setwd(...future.workdir)
[16:03:17.601]         {
[16:03:17.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:17.601]                 ...future.oldOptions$nwarnings <- NULL
[16:03:17.601]             }
[16:03:17.601]             base::options(...future.oldOptions)
[16:03:17.601]             if (.Platform$OS.type == "windows") {
[16:03:17.601]                 old_names <- names(...future.oldEnvVars)
[16:03:17.601]                 envs <- base::Sys.getenv()
[16:03:17.601]                 names <- names(envs)
[16:03:17.601]                 common <- intersect(names, old_names)
[16:03:17.601]                 added <- setdiff(names, old_names)
[16:03:17.601]                 removed <- setdiff(old_names, names)
[16:03:17.601]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:17.601]                   envs[common]]
[16:03:17.601]                 NAMES <- toupper(changed)
[16:03:17.601]                 args <- list()
[16:03:17.601]                 for (kk in seq_along(NAMES)) {
[16:03:17.601]                   name <- changed[[kk]]
[16:03:17.601]                   NAME <- NAMES[[kk]]
[16:03:17.601]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.601]                     next
[16:03:17.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:17.601]                 }
[16:03:17.601]                 NAMES <- toupper(added)
[16:03:17.601]                 for (kk in seq_along(NAMES)) {
[16:03:17.601]                   name <- added[[kk]]
[16:03:17.601]                   NAME <- NAMES[[kk]]
[16:03:17.601]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.601]                     next
[16:03:17.601]                   args[[name]] <- ""
[16:03:17.601]                 }
[16:03:17.601]                 NAMES <- toupper(removed)
[16:03:17.601]                 for (kk in seq_along(NAMES)) {
[16:03:17.601]                   name <- removed[[kk]]
[16:03:17.601]                   NAME <- NAMES[[kk]]
[16:03:17.601]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.601]                     next
[16:03:17.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:17.601]                 }
[16:03:17.601]                 if (length(args) > 0) 
[16:03:17.601]                   base::do.call(base::Sys.setenv, args = args)
[16:03:17.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:17.601]             }
[16:03:17.601]             else {
[16:03:17.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:17.601]             }
[16:03:17.601]             {
[16:03:17.601]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:17.601]                   0L) {
[16:03:17.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:17.601]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:17.601]                   base::options(opts)
[16:03:17.601]                 }
[16:03:17.601]                 {
[16:03:17.601]                   {
[16:03:17.601]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:17.601]                     NULL
[16:03:17.601]                   }
[16:03:17.601]                   options(future.plan = NULL)
[16:03:17.601]                   if (is.na(NA_character_)) 
[16:03:17.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:17.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:17.601]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:17.601]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:17.601]                     envir = parent.frame()) 
[16:03:17.601]                   {
[16:03:17.601]                     if (is.function(workers)) 
[16:03:17.601]                       workers <- workers()
[16:03:17.601]                     workers <- structure(as.integer(workers), 
[16:03:17.601]                       class = class(workers))
[16:03:17.601]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:17.601]                       workers >= 1)
[16:03:17.601]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:17.601]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:17.601]                     }
[16:03:17.601]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:17.601]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:17.601]                       envir = envir)
[16:03:17.601]                     if (!future$lazy) 
[16:03:17.601]                       future <- run(future)
[16:03:17.601]                     invisible(future)
[16:03:17.601]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:17.601]                 }
[16:03:17.601]             }
[16:03:17.601]         }
[16:03:17.601]     })
[16:03:17.601]     if (TRUE) {
[16:03:17.601]         base::sink(type = "output", split = FALSE)
[16:03:17.601]         if (TRUE) {
[16:03:17.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:17.601]         }
[16:03:17.601]         else {
[16:03:17.601]             ...future.result["stdout"] <- base::list(NULL)
[16:03:17.601]         }
[16:03:17.601]         base::close(...future.stdout)
[16:03:17.601]         ...future.stdout <- NULL
[16:03:17.601]     }
[16:03:17.601]     ...future.result$conditions <- ...future.conditions
[16:03:17.601]     ...future.result$finished <- base::Sys.time()
[16:03:17.601]     ...future.result
[16:03:17.601] }
[16:03:17.604] Exporting 11 global objects (92.12 KiB) to cluster node #2 ...
[16:03:17.604] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:17.647] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:17.647] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[16:03:17.648] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[16:03:17.648] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:17.648] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:17.648] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:17.691] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:17.691] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:17.735] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:17.735] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:03:17.736] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:03:17.736] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:03:17.736] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:03:17.737] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:17.737] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:17.737] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:03:17.737] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:03:17.738] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:17.738] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:17.738] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:17.738] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:17.739] Exporting 11 global objects (92.12 KiB) to cluster node #2 ... DONE
[16:03:17.739] MultisessionFuture started
[16:03:17.739] - Launch lazy future ... done
[16:03:17.739] run() for ‘MultisessionFuture’ ... done
[16:03:17.740] Created future:
[16:03:17.740] MultisessionFuture:
[16:03:17.740] Label: ‘future_vapply-2’
[16:03:17.740] Expression:
[16:03:17.740] {
[16:03:17.740]     do.call(function(...) {
[16:03:17.740]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.740]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:17.740]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.740]             on.exit(options(oopts), add = TRUE)
[16:03:17.740]         }
[16:03:17.740]         {
[16:03:17.740]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:17.740]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.740]                 ...future.FUN(...future.X_jj, ...)
[16:03:17.740]             })
[16:03:17.740]         }
[16:03:17.740]     }, args = future.call.arguments)
[16:03:17.740] }
[16:03:17.740] Lazy evaluation: FALSE
[16:03:17.740] Asynchronous evaluation: TRUE
[16:03:17.740] Local evaluation: TRUE
[16:03:17.740] Environment: R_GlobalEnv
[16:03:17.740] Capture standard output: TRUE
[16:03:17.740] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:17.740] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:17.740] Packages: 1 packages (‘future.apply’)
[16:03:17.740] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:17.740] Resolved: FALSE
[16:03:17.740] Value: <not collected>
[16:03:17.740] Conditions captured: <none>
[16:03:17.740] Early signaling: FALSE
[16:03:17.740] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:17.740] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:17.751] Chunk #2 of 2 ... DONE
[16:03:17.751] Launching 2 futures (chunks) ... DONE
[16:03:17.752] Resolving 2 futures (chunks) ...
[16:03:17.752] resolve() on list ...
[16:03:17.752]  recursive: 0
[16:03:17.752]  length: 2
[16:03:17.752] 
[16:03:17.753] receiveMessageFromWorker() for ClusterFuture ...
[16:03:17.753] - Validating connection of MultisessionFuture
[16:03:17.753] - received message: FutureResult
[16:03:17.753] - Received FutureResult
[16:03:17.753] - Erased future from FutureRegistry
[16:03:17.753] result() for ClusterFuture ...
[16:03:17.753] - result already collected: FutureResult
[16:03:17.753] result() for ClusterFuture ... done
[16:03:17.753] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:17.754] Future #1
[16:03:17.754] result() for ClusterFuture ...
[16:03:17.754] - result already collected: FutureResult
[16:03:17.754] result() for ClusterFuture ... done
[16:03:17.754] result() for ClusterFuture ...
[16:03:17.754] - result already collected: FutureResult
[16:03:17.754] result() for ClusterFuture ... done
[16:03:17.754] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:17.754] - nx: 2
[16:03:17.754] - relay: TRUE
[16:03:17.754] - stdout: TRUE
[16:03:17.754] - signal: TRUE
[16:03:17.755] - resignal: FALSE
[16:03:17.755] - force: TRUE
[16:03:17.755] - relayed: [n=2] FALSE, FALSE
[16:03:17.755] - queued futures: [n=2] FALSE, FALSE
[16:03:17.755]  - until=1
[16:03:17.755]  - relaying element #1
[16:03:17.755] result() for ClusterFuture ...
[16:03:17.755] - result already collected: FutureResult
[16:03:17.755] result() for ClusterFuture ... done
[16:03:17.755] result() for ClusterFuture ...
[16:03:17.755] - result already collected: FutureResult
[16:03:17.756] result() for ClusterFuture ... done
[16:03:17.756] result() for ClusterFuture ...
[16:03:17.756] - result already collected: FutureResult
[16:03:17.756] result() for ClusterFuture ... done
[16:03:17.756] result() for ClusterFuture ...
[16:03:17.756] - result already collected: FutureResult
[16:03:17.756] result() for ClusterFuture ... done
[16:03:17.756] - relayed: [n=2] TRUE, FALSE
[16:03:17.756] - queued futures: [n=2] TRUE, FALSE
[16:03:17.756] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:17.756]  length: 1 (resolved future 1)
[16:03:17.798] receiveMessageFromWorker() for ClusterFuture ...
[16:03:17.798] - Validating connection of MultisessionFuture
[16:03:17.798] - received message: FutureResult
[16:03:17.799] - Received FutureResult
[16:03:17.799] - Erased future from FutureRegistry
[16:03:17.799] result() for ClusterFuture ...
[16:03:17.799] - result already collected: FutureResult
[16:03:17.799] result() for ClusterFuture ... done
[16:03:17.799] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:17.799] Future #2
[16:03:17.799] result() for ClusterFuture ...
[16:03:17.799] - result already collected: FutureResult
[16:03:17.799] result() for ClusterFuture ... done
[16:03:17.800] result() for ClusterFuture ...
[16:03:17.800] - result already collected: FutureResult
[16:03:17.800] result() for ClusterFuture ... done
[16:03:17.800] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:17.800] - nx: 2
[16:03:17.800] - relay: TRUE
[16:03:17.800] - stdout: TRUE
[16:03:17.800] - signal: TRUE
[16:03:17.800] - resignal: FALSE
[16:03:17.800] - force: TRUE
[16:03:17.800] - relayed: [n=2] TRUE, FALSE
[16:03:17.800] - queued futures: [n=2] TRUE, FALSE
[16:03:17.801]  - until=2
[16:03:17.801]  - relaying element #2
[16:03:17.801] result() for ClusterFuture ...
[16:03:17.801] - result already collected: FutureResult
[16:03:17.801] result() for ClusterFuture ... done
[16:03:17.801] result() for ClusterFuture ...
[16:03:17.801] - result already collected: FutureResult
[16:03:17.801] result() for ClusterFuture ... done
[16:03:17.801] result() for ClusterFuture ...
[16:03:17.801] - result already collected: FutureResult
[16:03:17.802] result() for ClusterFuture ... done
[16:03:17.802] result() for ClusterFuture ...
[16:03:17.802] - result already collected: FutureResult
[16:03:17.802] result() for ClusterFuture ... done
[16:03:17.802] - relayed: [n=2] TRUE, TRUE
[16:03:17.802] - queued futures: [n=2] TRUE, TRUE
[16:03:17.802] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:17.802]  length: 0 (resolved future 2)
[16:03:17.802] Relaying remaining futures
[16:03:17.802] signalConditionsASAP(NULL, pos=0) ...
[16:03:17.802] - nx: 2
[16:03:17.802] - relay: TRUE
[16:03:17.803] - stdout: TRUE
[16:03:17.803] - signal: TRUE
[16:03:17.803] - resignal: FALSE
[16:03:17.803] - force: TRUE
[16:03:17.803] - relayed: [n=2] TRUE, TRUE
[16:03:17.803] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:17.803] - relayed: [n=2] TRUE, TRUE
[16:03:17.803] - queued futures: [n=2] TRUE, TRUE
[16:03:17.803] signalConditionsASAP(NULL, pos=0) ... done
[16:03:17.803] resolve() on list ... DONE
[16:03:17.803] result() for ClusterFuture ...
[16:03:17.804] - result already collected: FutureResult
[16:03:17.804] result() for ClusterFuture ... done
[16:03:17.804] result() for ClusterFuture ...
[16:03:17.804] - result already collected: FutureResult
[16:03:17.804] result() for ClusterFuture ... done
[16:03:17.804] result() for ClusterFuture ...
[16:03:17.804] - result already collected: FutureResult
[16:03:17.804] result() for ClusterFuture ... done
[16:03:17.804] result() for ClusterFuture ...
[16:03:17.804] - result already collected: FutureResult
[16:03:17.804] result() for ClusterFuture ... done
[16:03:17.805]  - Number of value chunks collected: 2
[16:03:17.805] Resolving 2 futures (chunks) ... DONE
[16:03:17.805] Reducing values from 2 chunks ...
[16:03:17.805]  - Number of values collected after concatenation: 10
[16:03:17.805]  - Number of values expected: 10
[16:03:17.805] Reducing values from 2 chunks ... DONE
[16:03:17.805] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[16:03:17.806] future_lapply() ...
[16:03:17.811] Number of chunks: 2
[16:03:17.811] getGlobalsAndPackagesXApply() ...
[16:03:17.811]  - future.globals: TRUE
[16:03:17.811] getGlobalsAndPackages() ...
[16:03:17.812] Searching for globals...
[16:03:17.815] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[16:03:17.815] Searching for globals ... DONE
[16:03:17.815] Resolving globals: FALSE
[16:03:17.816] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[16:03:17.817] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:17.817] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:17.817] - packages: [1] ‘future.apply’
[16:03:17.817] getGlobalsAndPackages() ... DONE
[16:03:17.817]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:17.817]  - needed namespaces: [n=1] ‘future.apply’
[16:03:17.817] Finding globals ... DONE
[16:03:17.817]  - use_args: TRUE
[16:03:17.817]  - Getting '...' globals ...
[16:03:17.818] resolve() on list ...
[16:03:17.818]  recursive: 0
[16:03:17.818]  length: 1
[16:03:17.818]  elements: ‘...’
[16:03:17.818]  length: 0 (resolved future 1)
[16:03:17.818] resolve() on list ... DONE
[16:03:17.818]    - '...' content: [n=0] 
[16:03:17.818] List of 1
[16:03:17.818]  $ ...: list()
[16:03:17.818]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:17.818]  - attr(*, "where")=List of 1
[16:03:17.818]   ..$ ...:<environment: 0x564e44b2ec38> 
[16:03:17.818]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:17.818]  - attr(*, "resolved")= logi TRUE
[16:03:17.818]  - attr(*, "total_size")= num NA
[16:03:17.821]  - Getting '...' globals ... DONE
[16:03:17.821] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:17.821] List of 8
[16:03:17.821]  $ ...future.FUN:function (x, ...)  
[16:03:17.821]  $ x_FUN        :function (x)  
[16:03:17.821]  $ times        : int 2
[16:03:17.821]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:17.821]  $ stop_if_not  :function (...)  
[16:03:17.821]  $ dim          : NULL
[16:03:17.821]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:17.821]  $ ...          : list()
[16:03:17.821]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:17.821]  - attr(*, "where")=List of 8
[16:03:17.821]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:17.821]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:17.821]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:17.821]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:17.821]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:17.821]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:17.821]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:17.821]   ..$ ...          :<environment: 0x564e44b2ec38> 
[16:03:17.821]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:17.821]  - attr(*, "resolved")= logi FALSE
[16:03:17.821]  - attr(*, "total_size")= num 96456
[16:03:17.827] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:17.827] getGlobalsAndPackagesXApply() ... DONE
[16:03:17.827] Number of futures (= number of chunks): 2
[16:03:17.827] Launching 2 futures (chunks) ...
[16:03:17.827] Chunk #1 of 2 ...
[16:03:17.827]  - Finding globals in 'X' for chunk #1 ...
[16:03:17.827] getGlobalsAndPackages() ...
[16:03:17.827] Searching for globals...
[16:03:17.828] 
[16:03:17.828] Searching for globals ... DONE
[16:03:17.828] - globals: [0] <none>
[16:03:17.828] getGlobalsAndPackages() ... DONE
[16:03:17.828]    + additional globals found: [n=0] 
[16:03:17.828]    + additional namespaces needed: [n=0] 
[16:03:17.828]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:17.828]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:17.828]  - seeds: <none>
[16:03:17.828]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.829] getGlobalsAndPackages() ...
[16:03:17.829] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.829] Resolving globals: FALSE
[16:03:17.829] Tweak future expression to call with '...' arguments ...
[16:03:17.829] {
[16:03:17.829]     do.call(function(...) {
[16:03:17.829]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.829]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:17.829]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.829]             on.exit(options(oopts), add = TRUE)
[16:03:17.829]         }
[16:03:17.829]         {
[16:03:17.829]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:17.829]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.829]                 ...future.FUN(...future.X_jj, ...)
[16:03:17.829]             })
[16:03:17.829]         }
[16:03:17.829]     }, args = future.call.arguments)
[16:03:17.829] }
[16:03:17.829] Tweak future expression to call with '...' arguments ... DONE
[16:03:17.830] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:17.830] - packages: [1] ‘future.apply’
[16:03:17.830] getGlobalsAndPackages() ... DONE
[16:03:17.830] run() for ‘Future’ ...
[16:03:17.830] - state: ‘created’
[16:03:17.831] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:17.844] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:17.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:17.844]   - Field: ‘node’
[16:03:17.845]   - Field: ‘label’
[16:03:17.845]   - Field: ‘local’
[16:03:17.845]   - Field: ‘owner’
[16:03:17.845]   - Field: ‘envir’
[16:03:17.845]   - Field: ‘workers’
[16:03:17.845]   - Field: ‘packages’
[16:03:17.845]   - Field: ‘gc’
[16:03:17.845]   - Field: ‘conditions’
[16:03:17.845]   - Field: ‘persistent’
[16:03:17.845]   - Field: ‘expr’
[16:03:17.845]   - Field: ‘uuid’
[16:03:17.846]   - Field: ‘seed’
[16:03:17.846]   - Field: ‘version’
[16:03:17.846]   - Field: ‘result’
[16:03:17.846]   - Field: ‘asynchronous’
[16:03:17.846]   - Field: ‘calls’
[16:03:17.846]   - Field: ‘globals’
[16:03:17.846]   - Field: ‘stdout’
[16:03:17.846]   - Field: ‘earlySignal’
[16:03:17.846]   - Field: ‘lazy’
[16:03:17.846]   - Field: ‘state’
[16:03:17.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:17.847] - Launch lazy future ...
[16:03:17.847] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:17.847] Packages needed by future strategies (n = 0): <none>
[16:03:17.848] {
[16:03:17.848]     {
[16:03:17.848]         {
[16:03:17.848]             ...future.startTime <- base::Sys.time()
[16:03:17.848]             {
[16:03:17.848]                 {
[16:03:17.848]                   {
[16:03:17.848]                     {
[16:03:17.848]                       {
[16:03:17.848]                         base::local({
[16:03:17.848]                           has_future <- base::requireNamespace("future", 
[16:03:17.848]                             quietly = TRUE)
[16:03:17.848]                           if (has_future) {
[16:03:17.848]                             ns <- base::getNamespace("future")
[16:03:17.848]                             version <- ns[[".package"]][["version"]]
[16:03:17.848]                             if (is.null(version)) 
[16:03:17.848]                               version <- utils::packageVersion("future")
[16:03:17.848]                           }
[16:03:17.848]                           else {
[16:03:17.848]                             version <- NULL
[16:03:17.848]                           }
[16:03:17.848]                           if (!has_future || version < "1.8.0") {
[16:03:17.848]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:17.848]                               "", base::R.version$version.string), 
[16:03:17.848]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:17.848]                                 base::R.version$platform, 8 * 
[16:03:17.848]                                   base::.Machine$sizeof.pointer), 
[16:03:17.848]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:17.848]                                 "release", "version")], collapse = " "), 
[16:03:17.848]                               hostname = base::Sys.info()[["nodename"]])
[16:03:17.848]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:17.848]                               info)
[16:03:17.848]                             info <- base::paste(info, collapse = "; ")
[16:03:17.848]                             if (!has_future) {
[16:03:17.848]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:17.848]                                 info)
[16:03:17.848]                             }
[16:03:17.848]                             else {
[16:03:17.848]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:17.848]                                 info, version)
[16:03:17.848]                             }
[16:03:17.848]                             base::stop(msg)
[16:03:17.848]                           }
[16:03:17.848]                         })
[16:03:17.848]                       }
[16:03:17.848]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:17.848]                       base::options(mc.cores = 1L)
[16:03:17.848]                     }
[16:03:17.848]                     base::local({
[16:03:17.848]                       for (pkg in "future.apply") {
[16:03:17.848]                         base::loadNamespace(pkg)
[16:03:17.848]                         base::library(pkg, character.only = TRUE)
[16:03:17.848]                       }
[16:03:17.848]                     })
[16:03:17.848]                   }
[16:03:17.848]                   options(future.plan = NULL)
[16:03:17.848]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:17.848]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:17.848]                 }
[16:03:17.848]                 ...future.workdir <- getwd()
[16:03:17.848]             }
[16:03:17.848]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:17.848]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:17.848]         }
[16:03:17.848]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:17.848]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:17.848]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:17.848]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:17.848]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:17.848]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:17.848]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:17.848]             base::names(...future.oldOptions))
[16:03:17.848]     }
[16:03:17.848]     if (FALSE) {
[16:03:17.848]     }
[16:03:17.848]     else {
[16:03:17.848]         if (TRUE) {
[16:03:17.848]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:17.848]                 open = "w")
[16:03:17.848]         }
[16:03:17.848]         else {
[16:03:17.848]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:17.848]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:17.848]         }
[16:03:17.848]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:17.848]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:17.848]             base::sink(type = "output", split = FALSE)
[16:03:17.848]             base::close(...future.stdout)
[16:03:17.848]         }, add = TRUE)
[16:03:17.848]     }
[16:03:17.848]     ...future.frame <- base::sys.nframe()
[16:03:17.848]     ...future.conditions <- base::list()
[16:03:17.848]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:17.848]     if (FALSE) {
[16:03:17.848]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:17.848]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:17.848]     }
[16:03:17.848]     ...future.result <- base::tryCatch({
[16:03:17.848]         base::withCallingHandlers({
[16:03:17.848]             ...future.value <- base::withVisible(base::local({
[16:03:17.848]                 ...future.makeSendCondition <- base::local({
[16:03:17.848]                   sendCondition <- NULL
[16:03:17.848]                   function(frame = 1L) {
[16:03:17.848]                     if (is.function(sendCondition)) 
[16:03:17.848]                       return(sendCondition)
[16:03:17.848]                     ns <- getNamespace("parallel")
[16:03:17.848]                     if (exists("sendData", mode = "function", 
[16:03:17.848]                       envir = ns)) {
[16:03:17.848]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:17.848]                         envir = ns)
[16:03:17.848]                       envir <- sys.frame(frame)
[16:03:17.848]                       master <- NULL
[16:03:17.848]                       while (!identical(envir, .GlobalEnv) && 
[16:03:17.848]                         !identical(envir, emptyenv())) {
[16:03:17.848]                         if (exists("master", mode = "list", envir = envir, 
[16:03:17.848]                           inherits = FALSE)) {
[16:03:17.848]                           master <- get("master", mode = "list", 
[16:03:17.848]                             envir = envir, inherits = FALSE)
[16:03:17.848]                           if (inherits(master, c("SOCKnode", 
[16:03:17.848]                             "SOCK0node"))) {
[16:03:17.848]                             sendCondition <<- function(cond) {
[16:03:17.848]                               data <- list(type = "VALUE", value = cond, 
[16:03:17.848]                                 success = TRUE)
[16:03:17.848]                               parallel_sendData(master, data)
[16:03:17.848]                             }
[16:03:17.848]                             return(sendCondition)
[16:03:17.848]                           }
[16:03:17.848]                         }
[16:03:17.848]                         frame <- frame + 1L
[16:03:17.848]                         envir <- sys.frame(frame)
[16:03:17.848]                       }
[16:03:17.848]                     }
[16:03:17.848]                     sendCondition <<- function(cond) NULL
[16:03:17.848]                   }
[16:03:17.848]                 })
[16:03:17.848]                 withCallingHandlers({
[16:03:17.848]                   {
[16:03:17.848]                     do.call(function(...) {
[16:03:17.848]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.848]                       if (!identical(...future.globals.maxSize.org, 
[16:03:17.848]                         ...future.globals.maxSize)) {
[16:03:17.848]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.848]                         on.exit(options(oopts), add = TRUE)
[16:03:17.848]                       }
[16:03:17.848]                       {
[16:03:17.848]                         lapply(seq_along(...future.elements_ii), 
[16:03:17.848]                           FUN = function(jj) {
[16:03:17.848]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.848]                             ...future.FUN(...future.X_jj, ...)
[16:03:17.848]                           })
[16:03:17.848]                       }
[16:03:17.848]                     }, args = future.call.arguments)
[16:03:17.848]                   }
[16:03:17.848]                 }, immediateCondition = function(cond) {
[16:03:17.848]                   sendCondition <- ...future.makeSendCondition()
[16:03:17.848]                   sendCondition(cond)
[16:03:17.848]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.848]                   {
[16:03:17.848]                     inherits <- base::inherits
[16:03:17.848]                     invokeRestart <- base::invokeRestart
[16:03:17.848]                     is.null <- base::is.null
[16:03:17.848]                     muffled <- FALSE
[16:03:17.848]                     if (inherits(cond, "message")) {
[16:03:17.848]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:17.848]                       if (muffled) 
[16:03:17.848]                         invokeRestart("muffleMessage")
[16:03:17.848]                     }
[16:03:17.848]                     else if (inherits(cond, "warning")) {
[16:03:17.848]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:17.848]                       if (muffled) 
[16:03:17.848]                         invokeRestart("muffleWarning")
[16:03:17.848]                     }
[16:03:17.848]                     else if (inherits(cond, "condition")) {
[16:03:17.848]                       if (!is.null(pattern)) {
[16:03:17.848]                         computeRestarts <- base::computeRestarts
[16:03:17.848]                         grepl <- base::grepl
[16:03:17.848]                         restarts <- computeRestarts(cond)
[16:03:17.848]                         for (restart in restarts) {
[16:03:17.848]                           name <- restart$name
[16:03:17.848]                           if (is.null(name)) 
[16:03:17.848]                             next
[16:03:17.848]                           if (!grepl(pattern, name)) 
[16:03:17.848]                             next
[16:03:17.848]                           invokeRestart(restart)
[16:03:17.848]                           muffled <- TRUE
[16:03:17.848]                           break
[16:03:17.848]                         }
[16:03:17.848]                       }
[16:03:17.848]                     }
[16:03:17.848]                     invisible(muffled)
[16:03:17.848]                   }
[16:03:17.848]                   muffleCondition(cond)
[16:03:17.848]                 })
[16:03:17.848]             }))
[16:03:17.848]             future::FutureResult(value = ...future.value$value, 
[16:03:17.848]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:17.848]                   ...future.rng), globalenv = if (FALSE) 
[16:03:17.848]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:17.848]                     ...future.globalenv.names))
[16:03:17.848]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:17.848]         }, condition = base::local({
[16:03:17.848]             c <- base::c
[16:03:17.848]             inherits <- base::inherits
[16:03:17.848]             invokeRestart <- base::invokeRestart
[16:03:17.848]             length <- base::length
[16:03:17.848]             list <- base::list
[16:03:17.848]             seq.int <- base::seq.int
[16:03:17.848]             signalCondition <- base::signalCondition
[16:03:17.848]             sys.calls <- base::sys.calls
[16:03:17.848]             `[[` <- base::`[[`
[16:03:17.848]             `+` <- base::`+`
[16:03:17.848]             `<<-` <- base::`<<-`
[16:03:17.848]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:17.848]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:17.848]                   3L)]
[16:03:17.848]             }
[16:03:17.848]             function(cond) {
[16:03:17.848]                 is_error <- inherits(cond, "error")
[16:03:17.848]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:17.848]                   NULL)
[16:03:17.848]                 if (is_error) {
[16:03:17.848]                   sessionInformation <- function() {
[16:03:17.848]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:17.848]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:17.848]                       search = base::search(), system = base::Sys.info())
[16:03:17.848]                   }
[16:03:17.848]                   ...future.conditions[[length(...future.conditions) + 
[16:03:17.848]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:17.848]                     cond$call), session = sessionInformation(), 
[16:03:17.848]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:17.848]                   signalCondition(cond)
[16:03:17.848]                 }
[16:03:17.848]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:17.848]                 "immediateCondition"))) {
[16:03:17.848]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:17.848]                   ...future.conditions[[length(...future.conditions) + 
[16:03:17.848]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:17.848]                   if (TRUE && !signal) {
[16:03:17.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.848]                     {
[16:03:17.848]                       inherits <- base::inherits
[16:03:17.848]                       invokeRestart <- base::invokeRestart
[16:03:17.848]                       is.null <- base::is.null
[16:03:17.848]                       muffled <- FALSE
[16:03:17.848]                       if (inherits(cond, "message")) {
[16:03:17.848]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:17.848]                         if (muffled) 
[16:03:17.848]                           invokeRestart("muffleMessage")
[16:03:17.848]                       }
[16:03:17.848]                       else if (inherits(cond, "warning")) {
[16:03:17.848]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:17.848]                         if (muffled) 
[16:03:17.848]                           invokeRestart("muffleWarning")
[16:03:17.848]                       }
[16:03:17.848]                       else if (inherits(cond, "condition")) {
[16:03:17.848]                         if (!is.null(pattern)) {
[16:03:17.848]                           computeRestarts <- base::computeRestarts
[16:03:17.848]                           grepl <- base::grepl
[16:03:17.848]                           restarts <- computeRestarts(cond)
[16:03:17.848]                           for (restart in restarts) {
[16:03:17.848]                             name <- restart$name
[16:03:17.848]                             if (is.null(name)) 
[16:03:17.848]                               next
[16:03:17.848]                             if (!grepl(pattern, name)) 
[16:03:17.848]                               next
[16:03:17.848]                             invokeRestart(restart)
[16:03:17.848]                             muffled <- TRUE
[16:03:17.848]                             break
[16:03:17.848]                           }
[16:03:17.848]                         }
[16:03:17.848]                       }
[16:03:17.848]                       invisible(muffled)
[16:03:17.848]                     }
[16:03:17.848]                     muffleCondition(cond, pattern = "^muffle")
[16:03:17.848]                   }
[16:03:17.848]                 }
[16:03:17.848]                 else {
[16:03:17.848]                   if (TRUE) {
[16:03:17.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:17.848]                     {
[16:03:17.848]                       inherits <- base::inherits
[16:03:17.848]                       invokeRestart <- base::invokeRestart
[16:03:17.848]                       is.null <- base::is.null
[16:03:17.848]                       muffled <- FALSE
[16:03:17.848]                       if (inherits(cond, "message")) {
[16:03:17.848]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:17.848]                         if (muffled) 
[16:03:17.848]                           invokeRestart("muffleMessage")
[16:03:17.848]                       }
[16:03:17.848]                       else if (inherits(cond, "warning")) {
[16:03:17.848]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:17.848]                         if (muffled) 
[16:03:17.848]                           invokeRestart("muffleWarning")
[16:03:17.848]                       }
[16:03:17.848]                       else if (inherits(cond, "condition")) {
[16:03:17.848]                         if (!is.null(pattern)) {
[16:03:17.848]                           computeRestarts <- base::computeRestarts
[16:03:17.848]                           grepl <- base::grepl
[16:03:17.848]                           restarts <- computeRestarts(cond)
[16:03:17.848]                           for (restart in restarts) {
[16:03:17.848]                             name <- restart$name
[16:03:17.848]                             if (is.null(name)) 
[16:03:17.848]                               next
[16:03:17.848]                             if (!grepl(pattern, name)) 
[16:03:17.848]                               next
[16:03:17.848]                             invokeRestart(restart)
[16:03:17.848]                             muffled <- TRUE
[16:03:17.848]                             break
[16:03:17.848]                           }
[16:03:17.848]                         }
[16:03:17.848]                       }
[16:03:17.848]                       invisible(muffled)
[16:03:17.848]                     }
[16:03:17.848]                     muffleCondition(cond, pattern = "^muffle")
[16:03:17.848]                   }
[16:03:17.848]                 }
[16:03:17.848]             }
[16:03:17.848]         }))
[16:03:17.848]     }, error = function(ex) {
[16:03:17.848]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:17.848]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:17.848]                 ...future.rng), started = ...future.startTime, 
[16:03:17.848]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:17.848]             version = "1.8"), class = "FutureResult")
[16:03:17.848]     }, finally = {
[16:03:17.848]         if (!identical(...future.workdir, getwd())) 
[16:03:17.848]             setwd(...future.workdir)
[16:03:17.848]         {
[16:03:17.848]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:17.848]                 ...future.oldOptions$nwarnings <- NULL
[16:03:17.848]             }
[16:03:17.848]             base::options(...future.oldOptions)
[16:03:17.848]             if (.Platform$OS.type == "windows") {
[16:03:17.848]                 old_names <- names(...future.oldEnvVars)
[16:03:17.848]                 envs <- base::Sys.getenv()
[16:03:17.848]                 names <- names(envs)
[16:03:17.848]                 common <- intersect(names, old_names)
[16:03:17.848]                 added <- setdiff(names, old_names)
[16:03:17.848]                 removed <- setdiff(old_names, names)
[16:03:17.848]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:17.848]                   envs[common]]
[16:03:17.848]                 NAMES <- toupper(changed)
[16:03:17.848]                 args <- list()
[16:03:17.848]                 for (kk in seq_along(NAMES)) {
[16:03:17.848]                   name <- changed[[kk]]
[16:03:17.848]                   NAME <- NAMES[[kk]]
[16:03:17.848]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.848]                     next
[16:03:17.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:17.848]                 }
[16:03:17.848]                 NAMES <- toupper(added)
[16:03:17.848]                 for (kk in seq_along(NAMES)) {
[16:03:17.848]                   name <- added[[kk]]
[16:03:17.848]                   NAME <- NAMES[[kk]]
[16:03:17.848]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.848]                     next
[16:03:17.848]                   args[[name]] <- ""
[16:03:17.848]                 }
[16:03:17.848]                 NAMES <- toupper(removed)
[16:03:17.848]                 for (kk in seq_along(NAMES)) {
[16:03:17.848]                   name <- removed[[kk]]
[16:03:17.848]                   NAME <- NAMES[[kk]]
[16:03:17.848]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:17.848]                     next
[16:03:17.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:17.848]                 }
[16:03:17.848]                 if (length(args) > 0) 
[16:03:17.848]                   base::do.call(base::Sys.setenv, args = args)
[16:03:17.848]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:17.848]             }
[16:03:17.848]             else {
[16:03:17.848]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:17.848]             }
[16:03:17.848]             {
[16:03:17.848]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:17.848]                   0L) {
[16:03:17.848]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:17.848]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:17.848]                   base::options(opts)
[16:03:17.848]                 }
[16:03:17.848]                 {
[16:03:17.848]                   {
[16:03:17.848]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:17.848]                     NULL
[16:03:17.848]                   }
[16:03:17.848]                   options(future.plan = NULL)
[16:03:17.848]                   if (is.na(NA_character_)) 
[16:03:17.848]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:17.848]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:17.848]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:17.848]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:17.848]                     envir = parent.frame()) 
[16:03:17.848]                   {
[16:03:17.848]                     if (is.function(workers)) 
[16:03:17.848]                       workers <- workers()
[16:03:17.848]                     workers <- structure(as.integer(workers), 
[16:03:17.848]                       class = class(workers))
[16:03:17.848]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:17.848]                       workers >= 1)
[16:03:17.848]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:17.848]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:17.848]                     }
[16:03:17.848]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:17.848]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:17.848]                       envir = envir)
[16:03:17.848]                     if (!future$lazy) 
[16:03:17.848]                       future <- run(future)
[16:03:17.848]                     invisible(future)
[16:03:17.848]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:17.848]                 }
[16:03:17.848]             }
[16:03:17.848]         }
[16:03:17.848]     })
[16:03:17.848]     if (TRUE) {
[16:03:17.848]         base::sink(type = "output", split = FALSE)
[16:03:17.848]         if (TRUE) {
[16:03:17.848]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:17.848]         }
[16:03:17.848]         else {
[16:03:17.848]             ...future.result["stdout"] <- base::list(NULL)
[16:03:17.848]         }
[16:03:17.848]         base::close(...future.stdout)
[16:03:17.848]         ...future.stdout <- NULL
[16:03:17.848]     }
[16:03:17.848]     ...future.result$conditions <- ...future.conditions
[16:03:17.848]     ...future.result$finished <- base::Sys.time()
[16:03:17.848]     ...future.result
[16:03:17.848] }
[16:03:17.850] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[16:03:17.851] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:17.891] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:17.891] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[16:03:17.892] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[16:03:17.892] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:17.892] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:17.892] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:17.935] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:17.935] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:17.979] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:17.979] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:03:17.980] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.980] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:03:17.980] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:03:17.980] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:17.981] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.981] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:03:17.981] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:03:17.982] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:17.982] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.982] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:17.982] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:17.983] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[16:03:17.983] MultisessionFuture started
[16:03:17.983] - Launch lazy future ... done
[16:03:17.983] run() for ‘MultisessionFuture’ ... done
[16:03:17.984] Created future:
[16:03:17.984] MultisessionFuture:
[16:03:17.984] Label: ‘future_vapply-1’
[16:03:17.984] Expression:
[16:03:17.984] {
[16:03:17.984]     do.call(function(...) {
[16:03:17.984]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:17.984]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:17.984]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:17.984]             on.exit(options(oopts), add = TRUE)
[16:03:17.984]         }
[16:03:17.984]         {
[16:03:17.984]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:17.984]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:17.984]                 ...future.FUN(...future.X_jj, ...)
[16:03:17.984]             })
[16:03:17.984]         }
[16:03:17.984]     }, args = future.call.arguments)
[16:03:17.984] }
[16:03:17.984] Lazy evaluation: FALSE
[16:03:17.984] Asynchronous evaluation: TRUE
[16:03:17.984] Local evaluation: TRUE
[16:03:17.984] Environment: R_GlobalEnv
[16:03:17.984] Capture standard output: TRUE
[16:03:17.984] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:17.984] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:17.984] Packages: 1 packages (‘future.apply’)
[16:03:17.984] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:17.984] Resolved: FALSE
[16:03:17.984] Value: <not collected>
[16:03:17.984] Conditions captured: <none>
[16:03:17.984] Early signaling: FALSE
[16:03:17.984] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:17.984] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:17.996] Chunk #1 of 2 ... DONE
[16:03:17.996] Chunk #2 of 2 ...
[16:03:17.996]  - Finding globals in 'X' for chunk #2 ...
[16:03:17.996] getGlobalsAndPackages() ...
[16:03:17.996] Searching for globals...
[16:03:17.996] 
[16:03:17.999] Searching for globals ... DONE
[16:03:17.999] - globals: [0] <none>
[16:03:17.999] getGlobalsAndPackages() ... DONE
[16:03:17.999]    + additional globals found: [n=0] 
[16:03:17.999]    + additional namespaces needed: [n=0] 
[16:03:17.999]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:18.000]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:18.000]  - seeds: <none>
[16:03:18.000]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.000] getGlobalsAndPackages() ...
[16:03:18.000] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.000] Resolving globals: FALSE
[16:03:18.000] Tweak future expression to call with '...' arguments ...
[16:03:18.000] {
[16:03:18.000]     do.call(function(...) {
[16:03:18.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:18.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.000]             on.exit(options(oopts), add = TRUE)
[16:03:18.000]         }
[16:03:18.000]         {
[16:03:18.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:18.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.000]                 ...future.FUN(...future.X_jj, ...)
[16:03:18.000]             })
[16:03:18.000]         }
[16:03:18.000]     }, args = future.call.arguments)
[16:03:18.000] }
[16:03:18.001] Tweak future expression to call with '...' arguments ... DONE
[16:03:18.001] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.001] - packages: [1] ‘future.apply’
[16:03:18.001] getGlobalsAndPackages() ... DONE
[16:03:18.002] run() for ‘Future’ ...
[16:03:18.002] - state: ‘created’
[16:03:18.002] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:18.016] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:18.016] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:18.016]   - Field: ‘node’
[16:03:18.017]   - Field: ‘label’
[16:03:18.017]   - Field: ‘local’
[16:03:18.017]   - Field: ‘owner’
[16:03:18.017]   - Field: ‘envir’
[16:03:18.017]   - Field: ‘workers’
[16:03:18.017]   - Field: ‘packages’
[16:03:18.017]   - Field: ‘gc’
[16:03:18.017]   - Field: ‘conditions’
[16:03:18.017]   - Field: ‘persistent’
[16:03:18.017]   - Field: ‘expr’
[16:03:18.017]   - Field: ‘uuid’
[16:03:18.018]   - Field: ‘seed’
[16:03:18.018]   - Field: ‘version’
[16:03:18.018]   - Field: ‘result’
[16:03:18.018]   - Field: ‘asynchronous’
[16:03:18.018]   - Field: ‘calls’
[16:03:18.018]   - Field: ‘globals’
[16:03:18.018]   - Field: ‘stdout’
[16:03:18.018]   - Field: ‘earlySignal’
[16:03:18.018]   - Field: ‘lazy’
[16:03:18.018]   - Field: ‘state’
[16:03:18.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:18.019] - Launch lazy future ...
[16:03:18.019] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:18.019] Packages needed by future strategies (n = 0): <none>
[16:03:18.019] {
[16:03:18.019]     {
[16:03:18.019]         {
[16:03:18.019]             ...future.startTime <- base::Sys.time()
[16:03:18.019]             {
[16:03:18.019]                 {
[16:03:18.019]                   {
[16:03:18.019]                     {
[16:03:18.019]                       {
[16:03:18.019]                         base::local({
[16:03:18.019]                           has_future <- base::requireNamespace("future", 
[16:03:18.019]                             quietly = TRUE)
[16:03:18.019]                           if (has_future) {
[16:03:18.019]                             ns <- base::getNamespace("future")
[16:03:18.019]                             version <- ns[[".package"]][["version"]]
[16:03:18.019]                             if (is.null(version)) 
[16:03:18.019]                               version <- utils::packageVersion("future")
[16:03:18.019]                           }
[16:03:18.019]                           else {
[16:03:18.019]                             version <- NULL
[16:03:18.019]                           }
[16:03:18.019]                           if (!has_future || version < "1.8.0") {
[16:03:18.019]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:18.019]                               "", base::R.version$version.string), 
[16:03:18.019]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:18.019]                                 base::R.version$platform, 8 * 
[16:03:18.019]                                   base::.Machine$sizeof.pointer), 
[16:03:18.019]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:18.019]                                 "release", "version")], collapse = " "), 
[16:03:18.019]                               hostname = base::Sys.info()[["nodename"]])
[16:03:18.019]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:18.019]                               info)
[16:03:18.019]                             info <- base::paste(info, collapse = "; ")
[16:03:18.019]                             if (!has_future) {
[16:03:18.019]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:18.019]                                 info)
[16:03:18.019]                             }
[16:03:18.019]                             else {
[16:03:18.019]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:18.019]                                 info, version)
[16:03:18.019]                             }
[16:03:18.019]                             base::stop(msg)
[16:03:18.019]                           }
[16:03:18.019]                         })
[16:03:18.019]                       }
[16:03:18.019]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:18.019]                       base::options(mc.cores = 1L)
[16:03:18.019]                     }
[16:03:18.019]                     base::local({
[16:03:18.019]                       for (pkg in "future.apply") {
[16:03:18.019]                         base::loadNamespace(pkg)
[16:03:18.019]                         base::library(pkg, character.only = TRUE)
[16:03:18.019]                       }
[16:03:18.019]                     })
[16:03:18.019]                   }
[16:03:18.019]                   options(future.plan = NULL)
[16:03:18.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:18.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:18.019]                 }
[16:03:18.019]                 ...future.workdir <- getwd()
[16:03:18.019]             }
[16:03:18.019]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:18.019]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:18.019]         }
[16:03:18.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:18.019]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:18.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:18.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:18.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:18.019]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:18.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:18.019]             base::names(...future.oldOptions))
[16:03:18.019]     }
[16:03:18.019]     if (FALSE) {
[16:03:18.019]     }
[16:03:18.019]     else {
[16:03:18.019]         if (TRUE) {
[16:03:18.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:18.019]                 open = "w")
[16:03:18.019]         }
[16:03:18.019]         else {
[16:03:18.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:18.019]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:18.019]         }
[16:03:18.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:18.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:18.019]             base::sink(type = "output", split = FALSE)
[16:03:18.019]             base::close(...future.stdout)
[16:03:18.019]         }, add = TRUE)
[16:03:18.019]     }
[16:03:18.019]     ...future.frame <- base::sys.nframe()
[16:03:18.019]     ...future.conditions <- base::list()
[16:03:18.019]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:18.019]     if (FALSE) {
[16:03:18.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:18.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:18.019]     }
[16:03:18.019]     ...future.result <- base::tryCatch({
[16:03:18.019]         base::withCallingHandlers({
[16:03:18.019]             ...future.value <- base::withVisible(base::local({
[16:03:18.019]                 ...future.makeSendCondition <- base::local({
[16:03:18.019]                   sendCondition <- NULL
[16:03:18.019]                   function(frame = 1L) {
[16:03:18.019]                     if (is.function(sendCondition)) 
[16:03:18.019]                       return(sendCondition)
[16:03:18.019]                     ns <- getNamespace("parallel")
[16:03:18.019]                     if (exists("sendData", mode = "function", 
[16:03:18.019]                       envir = ns)) {
[16:03:18.019]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:18.019]                         envir = ns)
[16:03:18.019]                       envir <- sys.frame(frame)
[16:03:18.019]                       master <- NULL
[16:03:18.019]                       while (!identical(envir, .GlobalEnv) && 
[16:03:18.019]                         !identical(envir, emptyenv())) {
[16:03:18.019]                         if (exists("master", mode = "list", envir = envir, 
[16:03:18.019]                           inherits = FALSE)) {
[16:03:18.019]                           master <- get("master", mode = "list", 
[16:03:18.019]                             envir = envir, inherits = FALSE)
[16:03:18.019]                           if (inherits(master, c("SOCKnode", 
[16:03:18.019]                             "SOCK0node"))) {
[16:03:18.019]                             sendCondition <<- function(cond) {
[16:03:18.019]                               data <- list(type = "VALUE", value = cond, 
[16:03:18.019]                                 success = TRUE)
[16:03:18.019]                               parallel_sendData(master, data)
[16:03:18.019]                             }
[16:03:18.019]                             return(sendCondition)
[16:03:18.019]                           }
[16:03:18.019]                         }
[16:03:18.019]                         frame <- frame + 1L
[16:03:18.019]                         envir <- sys.frame(frame)
[16:03:18.019]                       }
[16:03:18.019]                     }
[16:03:18.019]                     sendCondition <<- function(cond) NULL
[16:03:18.019]                   }
[16:03:18.019]                 })
[16:03:18.019]                 withCallingHandlers({
[16:03:18.019]                   {
[16:03:18.019]                     do.call(function(...) {
[16:03:18.019]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.019]                       if (!identical(...future.globals.maxSize.org, 
[16:03:18.019]                         ...future.globals.maxSize)) {
[16:03:18.019]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.019]                         on.exit(options(oopts), add = TRUE)
[16:03:18.019]                       }
[16:03:18.019]                       {
[16:03:18.019]                         lapply(seq_along(...future.elements_ii), 
[16:03:18.019]                           FUN = function(jj) {
[16:03:18.019]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.019]                             ...future.FUN(...future.X_jj, ...)
[16:03:18.019]                           })
[16:03:18.019]                       }
[16:03:18.019]                     }, args = future.call.arguments)
[16:03:18.019]                   }
[16:03:18.019]                 }, immediateCondition = function(cond) {
[16:03:18.019]                   sendCondition <- ...future.makeSendCondition()
[16:03:18.019]                   sendCondition(cond)
[16:03:18.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.019]                   {
[16:03:18.019]                     inherits <- base::inherits
[16:03:18.019]                     invokeRestart <- base::invokeRestart
[16:03:18.019]                     is.null <- base::is.null
[16:03:18.019]                     muffled <- FALSE
[16:03:18.019]                     if (inherits(cond, "message")) {
[16:03:18.019]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:18.019]                       if (muffled) 
[16:03:18.019]                         invokeRestart("muffleMessage")
[16:03:18.019]                     }
[16:03:18.019]                     else if (inherits(cond, "warning")) {
[16:03:18.019]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:18.019]                       if (muffled) 
[16:03:18.019]                         invokeRestart("muffleWarning")
[16:03:18.019]                     }
[16:03:18.019]                     else if (inherits(cond, "condition")) {
[16:03:18.019]                       if (!is.null(pattern)) {
[16:03:18.019]                         computeRestarts <- base::computeRestarts
[16:03:18.019]                         grepl <- base::grepl
[16:03:18.019]                         restarts <- computeRestarts(cond)
[16:03:18.019]                         for (restart in restarts) {
[16:03:18.019]                           name <- restart$name
[16:03:18.019]                           if (is.null(name)) 
[16:03:18.019]                             next
[16:03:18.019]                           if (!grepl(pattern, name)) 
[16:03:18.019]                             next
[16:03:18.019]                           invokeRestart(restart)
[16:03:18.019]                           muffled <- TRUE
[16:03:18.019]                           break
[16:03:18.019]                         }
[16:03:18.019]                       }
[16:03:18.019]                     }
[16:03:18.019]                     invisible(muffled)
[16:03:18.019]                   }
[16:03:18.019]                   muffleCondition(cond)
[16:03:18.019]                 })
[16:03:18.019]             }))
[16:03:18.019]             future::FutureResult(value = ...future.value$value, 
[16:03:18.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:18.019]                   ...future.rng), globalenv = if (FALSE) 
[16:03:18.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:18.019]                     ...future.globalenv.names))
[16:03:18.019]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:18.019]         }, condition = base::local({
[16:03:18.019]             c <- base::c
[16:03:18.019]             inherits <- base::inherits
[16:03:18.019]             invokeRestart <- base::invokeRestart
[16:03:18.019]             length <- base::length
[16:03:18.019]             list <- base::list
[16:03:18.019]             seq.int <- base::seq.int
[16:03:18.019]             signalCondition <- base::signalCondition
[16:03:18.019]             sys.calls <- base::sys.calls
[16:03:18.019]             `[[` <- base::`[[`
[16:03:18.019]             `+` <- base::`+`
[16:03:18.019]             `<<-` <- base::`<<-`
[16:03:18.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:18.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:18.019]                   3L)]
[16:03:18.019]             }
[16:03:18.019]             function(cond) {
[16:03:18.019]                 is_error <- inherits(cond, "error")
[16:03:18.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:18.019]                   NULL)
[16:03:18.019]                 if (is_error) {
[16:03:18.019]                   sessionInformation <- function() {
[16:03:18.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:18.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:18.019]                       search = base::search(), system = base::Sys.info())
[16:03:18.019]                   }
[16:03:18.019]                   ...future.conditions[[length(...future.conditions) + 
[16:03:18.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:18.019]                     cond$call), session = sessionInformation(), 
[16:03:18.019]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:18.019]                   signalCondition(cond)
[16:03:18.019]                 }
[16:03:18.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:18.019]                 "immediateCondition"))) {
[16:03:18.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:18.019]                   ...future.conditions[[length(...future.conditions) + 
[16:03:18.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:18.019]                   if (TRUE && !signal) {
[16:03:18.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.019]                     {
[16:03:18.019]                       inherits <- base::inherits
[16:03:18.019]                       invokeRestart <- base::invokeRestart
[16:03:18.019]                       is.null <- base::is.null
[16:03:18.019]                       muffled <- FALSE
[16:03:18.019]                       if (inherits(cond, "message")) {
[16:03:18.019]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:18.019]                         if (muffled) 
[16:03:18.019]                           invokeRestart("muffleMessage")
[16:03:18.019]                       }
[16:03:18.019]                       else if (inherits(cond, "warning")) {
[16:03:18.019]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:18.019]                         if (muffled) 
[16:03:18.019]                           invokeRestart("muffleWarning")
[16:03:18.019]                       }
[16:03:18.019]                       else if (inherits(cond, "condition")) {
[16:03:18.019]                         if (!is.null(pattern)) {
[16:03:18.019]                           computeRestarts <- base::computeRestarts
[16:03:18.019]                           grepl <- base::grepl
[16:03:18.019]                           restarts <- computeRestarts(cond)
[16:03:18.019]                           for (restart in restarts) {
[16:03:18.019]                             name <- restart$name
[16:03:18.019]                             if (is.null(name)) 
[16:03:18.019]                               next
[16:03:18.019]                             if (!grepl(pattern, name)) 
[16:03:18.019]                               next
[16:03:18.019]                             invokeRestart(restart)
[16:03:18.019]                             muffled <- TRUE
[16:03:18.019]                             break
[16:03:18.019]                           }
[16:03:18.019]                         }
[16:03:18.019]                       }
[16:03:18.019]                       invisible(muffled)
[16:03:18.019]                     }
[16:03:18.019]                     muffleCondition(cond, pattern = "^muffle")
[16:03:18.019]                   }
[16:03:18.019]                 }
[16:03:18.019]                 else {
[16:03:18.019]                   if (TRUE) {
[16:03:18.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.019]                     {
[16:03:18.019]                       inherits <- base::inherits
[16:03:18.019]                       invokeRestart <- base::invokeRestart
[16:03:18.019]                       is.null <- base::is.null
[16:03:18.019]                       muffled <- FALSE
[16:03:18.019]                       if (inherits(cond, "message")) {
[16:03:18.019]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:18.019]                         if (muffled) 
[16:03:18.019]                           invokeRestart("muffleMessage")
[16:03:18.019]                       }
[16:03:18.019]                       else if (inherits(cond, "warning")) {
[16:03:18.019]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:18.019]                         if (muffled) 
[16:03:18.019]                           invokeRestart("muffleWarning")
[16:03:18.019]                       }
[16:03:18.019]                       else if (inherits(cond, "condition")) {
[16:03:18.019]                         if (!is.null(pattern)) {
[16:03:18.019]                           computeRestarts <- base::computeRestarts
[16:03:18.019]                           grepl <- base::grepl
[16:03:18.019]                           restarts <- computeRestarts(cond)
[16:03:18.019]                           for (restart in restarts) {
[16:03:18.019]                             name <- restart$name
[16:03:18.019]                             if (is.null(name)) 
[16:03:18.019]                               next
[16:03:18.019]                             if (!grepl(pattern, name)) 
[16:03:18.019]                               next
[16:03:18.019]                             invokeRestart(restart)
[16:03:18.019]                             muffled <- TRUE
[16:03:18.019]                             break
[16:03:18.019]                           }
[16:03:18.019]                         }
[16:03:18.019]                       }
[16:03:18.019]                       invisible(muffled)
[16:03:18.019]                     }
[16:03:18.019]                     muffleCondition(cond, pattern = "^muffle")
[16:03:18.019]                   }
[16:03:18.019]                 }
[16:03:18.019]             }
[16:03:18.019]         }))
[16:03:18.019]     }, error = function(ex) {
[16:03:18.019]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:18.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:18.019]                 ...future.rng), started = ...future.startTime, 
[16:03:18.019]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:18.019]             version = "1.8"), class = "FutureResult")
[16:03:18.019]     }, finally = {
[16:03:18.019]         if (!identical(...future.workdir, getwd())) 
[16:03:18.019]             setwd(...future.workdir)
[16:03:18.019]         {
[16:03:18.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:18.019]                 ...future.oldOptions$nwarnings <- NULL
[16:03:18.019]             }
[16:03:18.019]             base::options(...future.oldOptions)
[16:03:18.019]             if (.Platform$OS.type == "windows") {
[16:03:18.019]                 old_names <- names(...future.oldEnvVars)
[16:03:18.019]                 envs <- base::Sys.getenv()
[16:03:18.019]                 names <- names(envs)
[16:03:18.019]                 common <- intersect(names, old_names)
[16:03:18.019]                 added <- setdiff(names, old_names)
[16:03:18.019]                 removed <- setdiff(old_names, names)
[16:03:18.019]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:18.019]                   envs[common]]
[16:03:18.019]                 NAMES <- toupper(changed)
[16:03:18.019]                 args <- list()
[16:03:18.019]                 for (kk in seq_along(NAMES)) {
[16:03:18.019]                   name <- changed[[kk]]
[16:03:18.019]                   NAME <- NAMES[[kk]]
[16:03:18.019]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.019]                     next
[16:03:18.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:18.019]                 }
[16:03:18.019]                 NAMES <- toupper(added)
[16:03:18.019]                 for (kk in seq_along(NAMES)) {
[16:03:18.019]                   name <- added[[kk]]
[16:03:18.019]                   NAME <- NAMES[[kk]]
[16:03:18.019]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.019]                     next
[16:03:18.019]                   args[[name]] <- ""
[16:03:18.019]                 }
[16:03:18.019]                 NAMES <- toupper(removed)
[16:03:18.019]                 for (kk in seq_along(NAMES)) {
[16:03:18.019]                   name <- removed[[kk]]
[16:03:18.019]                   NAME <- NAMES[[kk]]
[16:03:18.019]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.019]                     next
[16:03:18.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:18.019]                 }
[16:03:18.019]                 if (length(args) > 0) 
[16:03:18.019]                   base::do.call(base::Sys.setenv, args = args)
[16:03:18.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:18.019]             }
[16:03:18.019]             else {
[16:03:18.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:18.019]             }
[16:03:18.019]             {
[16:03:18.019]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:18.019]                   0L) {
[16:03:18.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:18.019]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:18.019]                   base::options(opts)
[16:03:18.019]                 }
[16:03:18.019]                 {
[16:03:18.019]                   {
[16:03:18.019]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:18.019]                     NULL
[16:03:18.019]                   }
[16:03:18.019]                   options(future.plan = NULL)
[16:03:18.019]                   if (is.na(NA_character_)) 
[16:03:18.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:18.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:18.019]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:18.019]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:18.019]                     envir = parent.frame()) 
[16:03:18.019]                   {
[16:03:18.019]                     if (is.function(workers)) 
[16:03:18.019]                       workers <- workers()
[16:03:18.019]                     workers <- structure(as.integer(workers), 
[16:03:18.019]                       class = class(workers))
[16:03:18.019]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:18.019]                       workers >= 1)
[16:03:18.019]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:18.019]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:18.019]                     }
[16:03:18.019]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:18.019]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:18.019]                       envir = envir)
[16:03:18.019]                     if (!future$lazy) 
[16:03:18.019]                       future <- run(future)
[16:03:18.019]                     invisible(future)
[16:03:18.019]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:18.019]                 }
[16:03:18.019]             }
[16:03:18.019]         }
[16:03:18.019]     })
[16:03:18.019]     if (TRUE) {
[16:03:18.019]         base::sink(type = "output", split = FALSE)
[16:03:18.019]         if (TRUE) {
[16:03:18.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:18.019]         }
[16:03:18.019]         else {
[16:03:18.019]             ...future.result["stdout"] <- base::list(NULL)
[16:03:18.019]         }
[16:03:18.019]         base::close(...future.stdout)
[16:03:18.019]         ...future.stdout <- NULL
[16:03:18.019]     }
[16:03:18.019]     ...future.result$conditions <- ...future.conditions
[16:03:18.019]     ...future.result$finished <- base::Sys.time()
[16:03:18.019]     ...future.result
[16:03:18.019] }
[16:03:18.022] Exporting 11 global objects (94.20 KiB) to cluster node #2 ...
[16:03:18.022] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:18.063] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:18.063] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ...
[16:03:18.064] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ... DONE
[16:03:18.064] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:18.064] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:18.064] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:18.107] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:18.107] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:18.151] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:18.151] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:03:18.152] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:03:18.152] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:03:18.152] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:03:18.153] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:18.153] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:18.153] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:03:18.154] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:03:18.154] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:18.154] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:18.154] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:18.155] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:18.155] Exporting 11 global objects (94.20 KiB) to cluster node #2 ... DONE
[16:03:18.155] MultisessionFuture started
[16:03:18.155] - Launch lazy future ... done
[16:03:18.156] run() for ‘MultisessionFuture’ ... done
[16:03:18.156] Created future:
[16:03:18.156] MultisessionFuture:
[16:03:18.156] Label: ‘future_vapply-2’
[16:03:18.156] Expression:
[16:03:18.156] {
[16:03:18.156]     do.call(function(...) {
[16:03:18.156]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.156]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:18.156]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.156]             on.exit(options(oopts), add = TRUE)
[16:03:18.156]         }
[16:03:18.156]         {
[16:03:18.156]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:18.156]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.156]                 ...future.FUN(...future.X_jj, ...)
[16:03:18.156]             })
[16:03:18.156]         }
[16:03:18.156]     }, args = future.call.arguments)
[16:03:18.156] }
[16:03:18.156] Lazy evaluation: FALSE
[16:03:18.156] Asynchronous evaluation: TRUE
[16:03:18.156] Local evaluation: TRUE
[16:03:18.156] Environment: R_GlobalEnv
[16:03:18.156] Capture standard output: TRUE
[16:03:18.156] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:18.156] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:18.156] Packages: 1 packages (‘future.apply’)
[16:03:18.156] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:18.156] Resolved: FALSE
[16:03:18.156] Value: <not collected>
[16:03:18.156] Conditions captured: <none>
[16:03:18.156] Early signaling: FALSE
[16:03:18.156] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:18.156] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:18.168] Chunk #2 of 2 ... DONE
[16:03:18.168] Launching 2 futures (chunks) ... DONE
[16:03:18.168] Resolving 2 futures (chunks) ...
[16:03:18.168] resolve() on list ...
[16:03:18.168]  recursive: 0
[16:03:18.168]  length: 2
[16:03:18.168] 
[16:03:18.169] receiveMessageFromWorker() for ClusterFuture ...
[16:03:18.169] - Validating connection of MultisessionFuture
[16:03:18.169] - received message: FutureResult
[16:03:18.169] - Received FutureResult
[16:03:18.169] - Erased future from FutureRegistry
[16:03:18.169] result() for ClusterFuture ...
[16:03:18.169] - result already collected: FutureResult
[16:03:18.169] result() for ClusterFuture ... done
[16:03:18.170] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:18.170] Future #1
[16:03:18.170] result() for ClusterFuture ...
[16:03:18.170] - result already collected: FutureResult
[16:03:18.170] result() for ClusterFuture ... done
[16:03:18.170] result() for ClusterFuture ...
[16:03:18.170] - result already collected: FutureResult
[16:03:18.170] result() for ClusterFuture ... done
[16:03:18.170] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:18.170] - nx: 2
[16:03:18.170] - relay: TRUE
[16:03:18.171] - stdout: TRUE
[16:03:18.171] - signal: TRUE
[16:03:18.171] - resignal: FALSE
[16:03:18.171] - force: TRUE
[16:03:18.171] - relayed: [n=2] FALSE, FALSE
[16:03:18.171] - queued futures: [n=2] FALSE, FALSE
[16:03:18.171]  - until=1
[16:03:18.171]  - relaying element #1
[16:03:18.171] result() for ClusterFuture ...
[16:03:18.171] - result already collected: FutureResult
[16:03:18.171] result() for ClusterFuture ... done
[16:03:18.172] result() for ClusterFuture ...
[16:03:18.172] - result already collected: FutureResult
[16:03:18.172] result() for ClusterFuture ... done
[16:03:18.172] result() for ClusterFuture ...
[16:03:18.172] - result already collected: FutureResult
[16:03:18.172] result() for ClusterFuture ... done
[16:03:18.172] result() for ClusterFuture ...
[16:03:18.172] - result already collected: FutureResult
[16:03:18.172] result() for ClusterFuture ... done
[16:03:18.172] - relayed: [n=2] TRUE, FALSE
[16:03:18.172] - queued futures: [n=2] TRUE, FALSE
[16:03:18.173] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:18.173]  length: 1 (resolved future 1)
[16:03:18.214] receiveMessageFromWorker() for ClusterFuture ...
[16:03:18.214] - Validating connection of MultisessionFuture
[16:03:18.215] - received message: FutureResult
[16:03:18.215] - Received FutureResult
[16:03:18.215] - Erased future from FutureRegistry
[16:03:18.215] result() for ClusterFuture ...
[16:03:18.215] - result already collected: FutureResult
[16:03:18.215] result() for ClusterFuture ... done
[16:03:18.215] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:18.215] Future #2
[16:03:18.216] result() for ClusterFuture ...
[16:03:18.216] - result already collected: FutureResult
[16:03:18.216] result() for ClusterFuture ... done
[16:03:18.216] result() for ClusterFuture ...
[16:03:18.216] - result already collected: FutureResult
[16:03:18.216] result() for ClusterFuture ... done
[16:03:18.216] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:18.216] - nx: 2
[16:03:18.216] - relay: TRUE
[16:03:18.216] - stdout: TRUE
[16:03:18.216] - signal: TRUE
[16:03:18.217] - resignal: FALSE
[16:03:18.217] - force: TRUE
[16:03:18.217] - relayed: [n=2] TRUE, FALSE
[16:03:18.217] - queued futures: [n=2] TRUE, FALSE
[16:03:18.217]  - until=2
[16:03:18.217]  - relaying element #2
[16:03:18.217] result() for ClusterFuture ...
[16:03:18.217] - result already collected: FutureResult
[16:03:18.217] result() for ClusterFuture ... done
[16:03:18.217] result() for ClusterFuture ...
[16:03:18.217] - result already collected: FutureResult
[16:03:18.217] result() for ClusterFuture ... done
[16:03:18.218] result() for ClusterFuture ...
[16:03:18.218] - result already collected: FutureResult
[16:03:18.218] result() for ClusterFuture ... done
[16:03:18.218] result() for ClusterFuture ...
[16:03:18.218] - result already collected: FutureResult
[16:03:18.218] result() for ClusterFuture ... done
[16:03:18.218] - relayed: [n=2] TRUE, TRUE
[16:03:18.218] - queued futures: [n=2] TRUE, TRUE
[16:03:18.218] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:18.218]  length: 0 (resolved future 2)
[16:03:18.218] Relaying remaining futures
[16:03:18.219] signalConditionsASAP(NULL, pos=0) ...
[16:03:18.219] - nx: 2
[16:03:18.219] - relay: TRUE
[16:03:18.219] - stdout: TRUE
[16:03:18.219] - signal: TRUE
[16:03:18.219] - resignal: FALSE
[16:03:18.219] - force: TRUE
[16:03:18.219] - relayed: [n=2] TRUE, TRUE
[16:03:18.219] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:18.219] - relayed: [n=2] TRUE, TRUE
[16:03:18.220] - queued futures: [n=2] TRUE, TRUE
[16:03:18.220] signalConditionsASAP(NULL, pos=0) ... done
[16:03:18.220] resolve() on list ... DONE
[16:03:18.220] result() for ClusterFuture ...
[16:03:18.220] - result already collected: FutureResult
[16:03:18.220] result() for ClusterFuture ... done
[16:03:18.220] result() for ClusterFuture ...
[16:03:18.220] - result already collected: FutureResult
[16:03:18.220] result() for ClusterFuture ... done
[16:03:18.220] result() for ClusterFuture ...
[16:03:18.220] - result already collected: FutureResult
[16:03:18.220] result() for ClusterFuture ... done
[16:03:18.221] result() for ClusterFuture ...
[16:03:18.221] - result already collected: FutureResult
[16:03:18.221] result() for ClusterFuture ... done
[16:03:18.221]  - Number of value chunks collected: 2
[16:03:18.221] Resolving 2 futures (chunks) ... DONE
[16:03:18.221] Reducing values from 2 chunks ...
[16:03:18.221]  - Number of values collected after concatenation: 10
[16:03:18.221]  - Number of values expected: 10
[16:03:18.221] Reducing values from 2 chunks ... DONE
[16:03:18.221] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:03:18.222] future_lapply() ...
[16:03:18.228] Number of chunks: 2
[16:03:18.228] getGlobalsAndPackagesXApply() ...
[16:03:18.228]  - future.globals: TRUE
[16:03:18.228] getGlobalsAndPackages() ...
[16:03:18.228] Searching for globals...
[16:03:18.232] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:03:18.232] Searching for globals ... DONE
[16:03:18.232] Resolving globals: FALSE
[16:03:18.233] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[16:03:18.234] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:18.234] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:18.234] - packages: [1] ‘future.apply’
[16:03:18.234] getGlobalsAndPackages() ... DONE
[16:03:18.234]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:18.234]  - needed namespaces: [n=1] ‘future.apply’
[16:03:18.234] Finding globals ... DONE
[16:03:18.234]  - use_args: TRUE
[16:03:18.234]  - Getting '...' globals ...
[16:03:18.235] resolve() on list ...
[16:03:18.235]  recursive: 0
[16:03:18.235]  length: 1
[16:03:18.235]  elements: ‘...’
[16:03:18.235]  length: 0 (resolved future 1)
[16:03:18.235] resolve() on list ... DONE
[16:03:18.235]    - '...' content: [n=0] 
[16:03:18.236] List of 1
[16:03:18.236]  $ ...: list()
[16:03:18.236]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:18.236]  - attr(*, "where")=List of 1
[16:03:18.236]   ..$ ...:<environment: 0x564e43e400b0> 
[16:03:18.236]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:18.236]  - attr(*, "resolved")= logi TRUE
[16:03:18.236]  - attr(*, "total_size")= num NA
[16:03:18.238]  - Getting '...' globals ... DONE
[16:03:18.238] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:18.238] List of 8
[16:03:18.238]  $ ...future.FUN:function (x, ...)  
[16:03:18.238]  $ x_FUN        :function (x)  
[16:03:18.238]  $ times        : int 4
[16:03:18.238]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:18.238]  $ stop_if_not  :function (...)  
[16:03:18.238]  $ dim          : int [1:2] 2 2
[16:03:18.238]  $ valid_types  : chr [1:2] "logical" "integer"
[16:03:18.238]  $ ...          : list()
[16:03:18.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:18.238]  - attr(*, "where")=List of 8
[16:03:18.238]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:18.238]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:18.238]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:18.238]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:18.238]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:18.238]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:18.238]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:18.238]   ..$ ...          :<environment: 0x564e43e400b0> 
[16:03:18.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:18.238]  - attr(*, "resolved")= logi FALSE
[16:03:18.238]  - attr(*, "total_size")= num 97232
[16:03:18.244] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:18.244] getGlobalsAndPackagesXApply() ... DONE
[16:03:18.244] Number of futures (= number of chunks): 2
[16:03:18.244] Launching 2 futures (chunks) ...
[16:03:18.244] Chunk #1 of 2 ...
[16:03:18.244]  - Finding globals in 'X' for chunk #1 ...
[16:03:18.244] getGlobalsAndPackages() ...
[16:03:18.245] Searching for globals...
[16:03:18.245] 
[16:03:18.245] Searching for globals ... DONE
[16:03:18.245] - globals: [0] <none>
[16:03:18.245] getGlobalsAndPackages() ... DONE
[16:03:18.245]    + additional globals found: [n=0] 
[16:03:18.245]    + additional namespaces needed: [n=0] 
[16:03:18.245]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:18.245]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:18.246]  - seeds: <none>
[16:03:18.246]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.246] getGlobalsAndPackages() ...
[16:03:18.246] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.246] Resolving globals: FALSE
[16:03:18.246] Tweak future expression to call with '...' arguments ...
[16:03:18.246] {
[16:03:18.246]     do.call(function(...) {
[16:03:18.246]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.246]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:18.246]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.246]             on.exit(options(oopts), add = TRUE)
[16:03:18.246]         }
[16:03:18.246]         {
[16:03:18.246]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:18.246]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.246]                 ...future.FUN(...future.X_jj, ...)
[16:03:18.246]             })
[16:03:18.246]         }
[16:03:18.246]     }, args = future.call.arguments)
[16:03:18.246] }
[16:03:18.246] Tweak future expression to call with '...' arguments ... DONE
[16:03:18.247] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.247] - packages: [1] ‘future.apply’
[16:03:18.247] getGlobalsAndPackages() ... DONE
[16:03:18.247] run() for ‘Future’ ...
[16:03:18.248] - state: ‘created’
[16:03:18.248] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:18.261] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:18.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:18.261]   - Field: ‘node’
[16:03:18.262]   - Field: ‘label’
[16:03:18.262]   - Field: ‘local’
[16:03:18.262]   - Field: ‘owner’
[16:03:18.262]   - Field: ‘envir’
[16:03:18.262]   - Field: ‘workers’
[16:03:18.262]   - Field: ‘packages’
[16:03:18.262]   - Field: ‘gc’
[16:03:18.262]   - Field: ‘conditions’
[16:03:18.262]   - Field: ‘persistent’
[16:03:18.262]   - Field: ‘expr’
[16:03:18.262]   - Field: ‘uuid’
[16:03:18.263]   - Field: ‘seed’
[16:03:18.263]   - Field: ‘version’
[16:03:18.263]   - Field: ‘result’
[16:03:18.263]   - Field: ‘asynchronous’
[16:03:18.263]   - Field: ‘calls’
[16:03:18.263]   - Field: ‘globals’
[16:03:18.263]   - Field: ‘stdout’
[16:03:18.263]   - Field: ‘earlySignal’
[16:03:18.263]   - Field: ‘lazy’
[16:03:18.263]   - Field: ‘state’
[16:03:18.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:18.264] - Launch lazy future ...
[16:03:18.264] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:18.264] Packages needed by future strategies (n = 0): <none>
[16:03:18.265] {
[16:03:18.265]     {
[16:03:18.265]         {
[16:03:18.265]             ...future.startTime <- base::Sys.time()
[16:03:18.265]             {
[16:03:18.265]                 {
[16:03:18.265]                   {
[16:03:18.265]                     {
[16:03:18.265]                       {
[16:03:18.265]                         base::local({
[16:03:18.265]                           has_future <- base::requireNamespace("future", 
[16:03:18.265]                             quietly = TRUE)
[16:03:18.265]                           if (has_future) {
[16:03:18.265]                             ns <- base::getNamespace("future")
[16:03:18.265]                             version <- ns[[".package"]][["version"]]
[16:03:18.265]                             if (is.null(version)) 
[16:03:18.265]                               version <- utils::packageVersion("future")
[16:03:18.265]                           }
[16:03:18.265]                           else {
[16:03:18.265]                             version <- NULL
[16:03:18.265]                           }
[16:03:18.265]                           if (!has_future || version < "1.8.0") {
[16:03:18.265]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:18.265]                               "", base::R.version$version.string), 
[16:03:18.265]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:18.265]                                 base::R.version$platform, 8 * 
[16:03:18.265]                                   base::.Machine$sizeof.pointer), 
[16:03:18.265]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:18.265]                                 "release", "version")], collapse = " "), 
[16:03:18.265]                               hostname = base::Sys.info()[["nodename"]])
[16:03:18.265]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:18.265]                               info)
[16:03:18.265]                             info <- base::paste(info, collapse = "; ")
[16:03:18.265]                             if (!has_future) {
[16:03:18.265]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:18.265]                                 info)
[16:03:18.265]                             }
[16:03:18.265]                             else {
[16:03:18.265]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:18.265]                                 info, version)
[16:03:18.265]                             }
[16:03:18.265]                             base::stop(msg)
[16:03:18.265]                           }
[16:03:18.265]                         })
[16:03:18.265]                       }
[16:03:18.265]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:18.265]                       base::options(mc.cores = 1L)
[16:03:18.265]                     }
[16:03:18.265]                     base::local({
[16:03:18.265]                       for (pkg in "future.apply") {
[16:03:18.265]                         base::loadNamespace(pkg)
[16:03:18.265]                         base::library(pkg, character.only = TRUE)
[16:03:18.265]                       }
[16:03:18.265]                     })
[16:03:18.265]                   }
[16:03:18.265]                   options(future.plan = NULL)
[16:03:18.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:18.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:18.265]                 }
[16:03:18.265]                 ...future.workdir <- getwd()
[16:03:18.265]             }
[16:03:18.265]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:18.265]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:18.265]         }
[16:03:18.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:18.265]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:18.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:18.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:18.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:18.265]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:18.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:18.265]             base::names(...future.oldOptions))
[16:03:18.265]     }
[16:03:18.265]     if (FALSE) {
[16:03:18.265]     }
[16:03:18.265]     else {
[16:03:18.265]         if (TRUE) {
[16:03:18.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:18.265]                 open = "w")
[16:03:18.265]         }
[16:03:18.265]         else {
[16:03:18.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:18.265]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:18.265]         }
[16:03:18.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:18.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:18.265]             base::sink(type = "output", split = FALSE)
[16:03:18.265]             base::close(...future.stdout)
[16:03:18.265]         }, add = TRUE)
[16:03:18.265]     }
[16:03:18.265]     ...future.frame <- base::sys.nframe()
[16:03:18.265]     ...future.conditions <- base::list()
[16:03:18.265]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:18.265]     if (FALSE) {
[16:03:18.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:18.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:18.265]     }
[16:03:18.265]     ...future.result <- base::tryCatch({
[16:03:18.265]         base::withCallingHandlers({
[16:03:18.265]             ...future.value <- base::withVisible(base::local({
[16:03:18.265]                 ...future.makeSendCondition <- base::local({
[16:03:18.265]                   sendCondition <- NULL
[16:03:18.265]                   function(frame = 1L) {
[16:03:18.265]                     if (is.function(sendCondition)) 
[16:03:18.265]                       return(sendCondition)
[16:03:18.265]                     ns <- getNamespace("parallel")
[16:03:18.265]                     if (exists("sendData", mode = "function", 
[16:03:18.265]                       envir = ns)) {
[16:03:18.265]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:18.265]                         envir = ns)
[16:03:18.265]                       envir <- sys.frame(frame)
[16:03:18.265]                       master <- NULL
[16:03:18.265]                       while (!identical(envir, .GlobalEnv) && 
[16:03:18.265]                         !identical(envir, emptyenv())) {
[16:03:18.265]                         if (exists("master", mode = "list", envir = envir, 
[16:03:18.265]                           inherits = FALSE)) {
[16:03:18.265]                           master <- get("master", mode = "list", 
[16:03:18.265]                             envir = envir, inherits = FALSE)
[16:03:18.265]                           if (inherits(master, c("SOCKnode", 
[16:03:18.265]                             "SOCK0node"))) {
[16:03:18.265]                             sendCondition <<- function(cond) {
[16:03:18.265]                               data <- list(type = "VALUE", value = cond, 
[16:03:18.265]                                 success = TRUE)
[16:03:18.265]                               parallel_sendData(master, data)
[16:03:18.265]                             }
[16:03:18.265]                             return(sendCondition)
[16:03:18.265]                           }
[16:03:18.265]                         }
[16:03:18.265]                         frame <- frame + 1L
[16:03:18.265]                         envir <- sys.frame(frame)
[16:03:18.265]                       }
[16:03:18.265]                     }
[16:03:18.265]                     sendCondition <<- function(cond) NULL
[16:03:18.265]                   }
[16:03:18.265]                 })
[16:03:18.265]                 withCallingHandlers({
[16:03:18.265]                   {
[16:03:18.265]                     do.call(function(...) {
[16:03:18.265]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.265]                       if (!identical(...future.globals.maxSize.org, 
[16:03:18.265]                         ...future.globals.maxSize)) {
[16:03:18.265]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.265]                         on.exit(options(oopts), add = TRUE)
[16:03:18.265]                       }
[16:03:18.265]                       {
[16:03:18.265]                         lapply(seq_along(...future.elements_ii), 
[16:03:18.265]                           FUN = function(jj) {
[16:03:18.265]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.265]                             ...future.FUN(...future.X_jj, ...)
[16:03:18.265]                           })
[16:03:18.265]                       }
[16:03:18.265]                     }, args = future.call.arguments)
[16:03:18.265]                   }
[16:03:18.265]                 }, immediateCondition = function(cond) {
[16:03:18.265]                   sendCondition <- ...future.makeSendCondition()
[16:03:18.265]                   sendCondition(cond)
[16:03:18.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.265]                   {
[16:03:18.265]                     inherits <- base::inherits
[16:03:18.265]                     invokeRestart <- base::invokeRestart
[16:03:18.265]                     is.null <- base::is.null
[16:03:18.265]                     muffled <- FALSE
[16:03:18.265]                     if (inherits(cond, "message")) {
[16:03:18.265]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:18.265]                       if (muffled) 
[16:03:18.265]                         invokeRestart("muffleMessage")
[16:03:18.265]                     }
[16:03:18.265]                     else if (inherits(cond, "warning")) {
[16:03:18.265]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:18.265]                       if (muffled) 
[16:03:18.265]                         invokeRestart("muffleWarning")
[16:03:18.265]                     }
[16:03:18.265]                     else if (inherits(cond, "condition")) {
[16:03:18.265]                       if (!is.null(pattern)) {
[16:03:18.265]                         computeRestarts <- base::computeRestarts
[16:03:18.265]                         grepl <- base::grepl
[16:03:18.265]                         restarts <- computeRestarts(cond)
[16:03:18.265]                         for (restart in restarts) {
[16:03:18.265]                           name <- restart$name
[16:03:18.265]                           if (is.null(name)) 
[16:03:18.265]                             next
[16:03:18.265]                           if (!grepl(pattern, name)) 
[16:03:18.265]                             next
[16:03:18.265]                           invokeRestart(restart)
[16:03:18.265]                           muffled <- TRUE
[16:03:18.265]                           break
[16:03:18.265]                         }
[16:03:18.265]                       }
[16:03:18.265]                     }
[16:03:18.265]                     invisible(muffled)
[16:03:18.265]                   }
[16:03:18.265]                   muffleCondition(cond)
[16:03:18.265]                 })
[16:03:18.265]             }))
[16:03:18.265]             future::FutureResult(value = ...future.value$value, 
[16:03:18.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:18.265]                   ...future.rng), globalenv = if (FALSE) 
[16:03:18.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:18.265]                     ...future.globalenv.names))
[16:03:18.265]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:18.265]         }, condition = base::local({
[16:03:18.265]             c <- base::c
[16:03:18.265]             inherits <- base::inherits
[16:03:18.265]             invokeRestart <- base::invokeRestart
[16:03:18.265]             length <- base::length
[16:03:18.265]             list <- base::list
[16:03:18.265]             seq.int <- base::seq.int
[16:03:18.265]             signalCondition <- base::signalCondition
[16:03:18.265]             sys.calls <- base::sys.calls
[16:03:18.265]             `[[` <- base::`[[`
[16:03:18.265]             `+` <- base::`+`
[16:03:18.265]             `<<-` <- base::`<<-`
[16:03:18.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:18.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:18.265]                   3L)]
[16:03:18.265]             }
[16:03:18.265]             function(cond) {
[16:03:18.265]                 is_error <- inherits(cond, "error")
[16:03:18.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:18.265]                   NULL)
[16:03:18.265]                 if (is_error) {
[16:03:18.265]                   sessionInformation <- function() {
[16:03:18.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:18.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:18.265]                       search = base::search(), system = base::Sys.info())
[16:03:18.265]                   }
[16:03:18.265]                   ...future.conditions[[length(...future.conditions) + 
[16:03:18.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:18.265]                     cond$call), session = sessionInformation(), 
[16:03:18.265]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:18.265]                   signalCondition(cond)
[16:03:18.265]                 }
[16:03:18.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:18.265]                 "immediateCondition"))) {
[16:03:18.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:18.265]                   ...future.conditions[[length(...future.conditions) + 
[16:03:18.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:18.265]                   if (TRUE && !signal) {
[16:03:18.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.265]                     {
[16:03:18.265]                       inherits <- base::inherits
[16:03:18.265]                       invokeRestart <- base::invokeRestart
[16:03:18.265]                       is.null <- base::is.null
[16:03:18.265]                       muffled <- FALSE
[16:03:18.265]                       if (inherits(cond, "message")) {
[16:03:18.265]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:18.265]                         if (muffled) 
[16:03:18.265]                           invokeRestart("muffleMessage")
[16:03:18.265]                       }
[16:03:18.265]                       else if (inherits(cond, "warning")) {
[16:03:18.265]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:18.265]                         if (muffled) 
[16:03:18.265]                           invokeRestart("muffleWarning")
[16:03:18.265]                       }
[16:03:18.265]                       else if (inherits(cond, "condition")) {
[16:03:18.265]                         if (!is.null(pattern)) {
[16:03:18.265]                           computeRestarts <- base::computeRestarts
[16:03:18.265]                           grepl <- base::grepl
[16:03:18.265]                           restarts <- computeRestarts(cond)
[16:03:18.265]                           for (restart in restarts) {
[16:03:18.265]                             name <- restart$name
[16:03:18.265]                             if (is.null(name)) 
[16:03:18.265]                               next
[16:03:18.265]                             if (!grepl(pattern, name)) 
[16:03:18.265]                               next
[16:03:18.265]                             invokeRestart(restart)
[16:03:18.265]                             muffled <- TRUE
[16:03:18.265]                             break
[16:03:18.265]                           }
[16:03:18.265]                         }
[16:03:18.265]                       }
[16:03:18.265]                       invisible(muffled)
[16:03:18.265]                     }
[16:03:18.265]                     muffleCondition(cond, pattern = "^muffle")
[16:03:18.265]                   }
[16:03:18.265]                 }
[16:03:18.265]                 else {
[16:03:18.265]                   if (TRUE) {
[16:03:18.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.265]                     {
[16:03:18.265]                       inherits <- base::inherits
[16:03:18.265]                       invokeRestart <- base::invokeRestart
[16:03:18.265]                       is.null <- base::is.null
[16:03:18.265]                       muffled <- FALSE
[16:03:18.265]                       if (inherits(cond, "message")) {
[16:03:18.265]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:18.265]                         if (muffled) 
[16:03:18.265]                           invokeRestart("muffleMessage")
[16:03:18.265]                       }
[16:03:18.265]                       else if (inherits(cond, "warning")) {
[16:03:18.265]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:18.265]                         if (muffled) 
[16:03:18.265]                           invokeRestart("muffleWarning")
[16:03:18.265]                       }
[16:03:18.265]                       else if (inherits(cond, "condition")) {
[16:03:18.265]                         if (!is.null(pattern)) {
[16:03:18.265]                           computeRestarts <- base::computeRestarts
[16:03:18.265]                           grepl <- base::grepl
[16:03:18.265]                           restarts <- computeRestarts(cond)
[16:03:18.265]                           for (restart in restarts) {
[16:03:18.265]                             name <- restart$name
[16:03:18.265]                             if (is.null(name)) 
[16:03:18.265]                               next
[16:03:18.265]                             if (!grepl(pattern, name)) 
[16:03:18.265]                               next
[16:03:18.265]                             invokeRestart(restart)
[16:03:18.265]                             muffled <- TRUE
[16:03:18.265]                             break
[16:03:18.265]                           }
[16:03:18.265]                         }
[16:03:18.265]                       }
[16:03:18.265]                       invisible(muffled)
[16:03:18.265]                     }
[16:03:18.265]                     muffleCondition(cond, pattern = "^muffle")
[16:03:18.265]                   }
[16:03:18.265]                 }
[16:03:18.265]             }
[16:03:18.265]         }))
[16:03:18.265]     }, error = function(ex) {
[16:03:18.265]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:18.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:18.265]                 ...future.rng), started = ...future.startTime, 
[16:03:18.265]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:18.265]             version = "1.8"), class = "FutureResult")
[16:03:18.265]     }, finally = {
[16:03:18.265]         if (!identical(...future.workdir, getwd())) 
[16:03:18.265]             setwd(...future.workdir)
[16:03:18.265]         {
[16:03:18.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:18.265]                 ...future.oldOptions$nwarnings <- NULL
[16:03:18.265]             }
[16:03:18.265]             base::options(...future.oldOptions)
[16:03:18.265]             if (.Platform$OS.type == "windows") {
[16:03:18.265]                 old_names <- names(...future.oldEnvVars)
[16:03:18.265]                 envs <- base::Sys.getenv()
[16:03:18.265]                 names <- names(envs)
[16:03:18.265]                 common <- intersect(names, old_names)
[16:03:18.265]                 added <- setdiff(names, old_names)
[16:03:18.265]                 removed <- setdiff(old_names, names)
[16:03:18.265]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:18.265]                   envs[common]]
[16:03:18.265]                 NAMES <- toupper(changed)
[16:03:18.265]                 args <- list()
[16:03:18.265]                 for (kk in seq_along(NAMES)) {
[16:03:18.265]                   name <- changed[[kk]]
[16:03:18.265]                   NAME <- NAMES[[kk]]
[16:03:18.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.265]                     next
[16:03:18.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:18.265]                 }
[16:03:18.265]                 NAMES <- toupper(added)
[16:03:18.265]                 for (kk in seq_along(NAMES)) {
[16:03:18.265]                   name <- added[[kk]]
[16:03:18.265]                   NAME <- NAMES[[kk]]
[16:03:18.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.265]                     next
[16:03:18.265]                   args[[name]] <- ""
[16:03:18.265]                 }
[16:03:18.265]                 NAMES <- toupper(removed)
[16:03:18.265]                 for (kk in seq_along(NAMES)) {
[16:03:18.265]                   name <- removed[[kk]]
[16:03:18.265]                   NAME <- NAMES[[kk]]
[16:03:18.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.265]                     next
[16:03:18.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:18.265]                 }
[16:03:18.265]                 if (length(args) > 0) 
[16:03:18.265]                   base::do.call(base::Sys.setenv, args = args)
[16:03:18.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:18.265]             }
[16:03:18.265]             else {
[16:03:18.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:18.265]             }
[16:03:18.265]             {
[16:03:18.265]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:18.265]                   0L) {
[16:03:18.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:18.265]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:18.265]                   base::options(opts)
[16:03:18.265]                 }
[16:03:18.265]                 {
[16:03:18.265]                   {
[16:03:18.265]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:18.265]                     NULL
[16:03:18.265]                   }
[16:03:18.265]                   options(future.plan = NULL)
[16:03:18.265]                   if (is.na(NA_character_)) 
[16:03:18.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:18.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:18.265]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:18.265]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:18.265]                     envir = parent.frame()) 
[16:03:18.265]                   {
[16:03:18.265]                     if (is.function(workers)) 
[16:03:18.265]                       workers <- workers()
[16:03:18.265]                     workers <- structure(as.integer(workers), 
[16:03:18.265]                       class = class(workers))
[16:03:18.265]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:18.265]                       workers >= 1)
[16:03:18.265]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:18.265]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:18.265]                     }
[16:03:18.265]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:18.265]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:18.265]                       envir = envir)
[16:03:18.265]                     if (!future$lazy) 
[16:03:18.265]                       future <- run(future)
[16:03:18.265]                     invisible(future)
[16:03:18.265]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:18.265]                 }
[16:03:18.265]             }
[16:03:18.265]         }
[16:03:18.265]     })
[16:03:18.265]     if (TRUE) {
[16:03:18.265]         base::sink(type = "output", split = FALSE)
[16:03:18.265]         if (TRUE) {
[16:03:18.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:18.265]         }
[16:03:18.265]         else {
[16:03:18.265]             ...future.result["stdout"] <- base::list(NULL)
[16:03:18.265]         }
[16:03:18.265]         base::close(...future.stdout)
[16:03:18.265]         ...future.stdout <- NULL
[16:03:18.265]     }
[16:03:18.265]     ...future.result$conditions <- ...future.conditions
[16:03:18.265]     ...future.result$finished <- base::Sys.time()
[16:03:18.265]     ...future.result
[16:03:18.265] }
[16:03:18.267] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[16:03:18.268] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:18.311] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:18.311] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[16:03:18.312] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[16:03:18.312] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:18.312] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:18.312] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:18.355] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:18.355] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:18.399] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:18.399] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:03:18.400] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:03:18.400] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[16:03:18.400] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[16:03:18.400] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:18.401] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:18.401] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:03:18.401] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:03:18.401] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:18.402] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:18.402] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:18.402] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:18.403] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[16:03:18.403] MultisessionFuture started
[16:03:18.403] - Launch lazy future ... done
[16:03:18.403] run() for ‘MultisessionFuture’ ... done
[16:03:18.404] Created future:
[16:03:18.404] MultisessionFuture:
[16:03:18.404] Label: ‘future_vapply-1’
[16:03:18.404] Expression:
[16:03:18.404] {
[16:03:18.404]     do.call(function(...) {
[16:03:18.404]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.404]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:18.404]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.404]             on.exit(options(oopts), add = TRUE)
[16:03:18.404]         }
[16:03:18.404]         {
[16:03:18.404]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:18.404]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.404]                 ...future.FUN(...future.X_jj, ...)
[16:03:18.404]             })
[16:03:18.404]         }
[16:03:18.404]     }, args = future.call.arguments)
[16:03:18.404] }
[16:03:18.404] Lazy evaluation: FALSE
[16:03:18.404] Asynchronous evaluation: TRUE
[16:03:18.404] Local evaluation: TRUE
[16:03:18.404] Environment: R_GlobalEnv
[16:03:18.404] Capture standard output: TRUE
[16:03:18.404] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:18.404] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:18.404] Packages: 1 packages (‘future.apply’)
[16:03:18.404] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:18.404] Resolved: FALSE
[16:03:18.404] Value: <not collected>
[16:03:18.404] Conditions captured: <none>
[16:03:18.404] Early signaling: FALSE
[16:03:18.404] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:18.404] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:18.415] Chunk #1 of 2 ... DONE
[16:03:18.416] Chunk #2 of 2 ...
[16:03:18.416]  - Finding globals in 'X' for chunk #2 ...
[16:03:18.416] getGlobalsAndPackages() ...
[16:03:18.416] Searching for globals...
[16:03:18.416] 
[16:03:18.416] Searching for globals ... DONE
[16:03:18.416] - globals: [0] <none>
[16:03:18.416] getGlobalsAndPackages() ... DONE
[16:03:18.416]    + additional globals found: [n=0] 
[16:03:18.417]    + additional namespaces needed: [n=0] 
[16:03:18.417]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:18.417]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:18.417]  - seeds: <none>
[16:03:18.417]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.417] getGlobalsAndPackages() ...
[16:03:18.417] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.417] Resolving globals: FALSE
[16:03:18.417] Tweak future expression to call with '...' arguments ...
[16:03:18.418] {
[16:03:18.418]     do.call(function(...) {
[16:03:18.418]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.418]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:18.418]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.418]             on.exit(options(oopts), add = TRUE)
[16:03:18.418]         }
[16:03:18.418]         {
[16:03:18.418]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:18.418]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.418]                 ...future.FUN(...future.X_jj, ...)
[16:03:18.418]             })
[16:03:18.418]         }
[16:03:18.418]     }, args = future.call.arguments)
[16:03:18.418] }
[16:03:18.418] Tweak future expression to call with '...' arguments ... DONE
[16:03:18.418] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.418] - packages: [1] ‘future.apply’
[16:03:18.419] getGlobalsAndPackages() ... DONE
[16:03:18.419] run() for ‘Future’ ...
[16:03:18.419] - state: ‘created’
[16:03:18.419] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:18.433] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:18.433] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:18.433]   - Field: ‘node’
[16:03:18.433]   - Field: ‘label’
[16:03:18.433]   - Field: ‘local’
[16:03:18.433]   - Field: ‘owner’
[16:03:18.433]   - Field: ‘envir’
[16:03:18.434]   - Field: ‘workers’
[16:03:18.434]   - Field: ‘packages’
[16:03:18.434]   - Field: ‘gc’
[16:03:18.434]   - Field: ‘conditions’
[16:03:18.434]   - Field: ‘persistent’
[16:03:18.434]   - Field: ‘expr’
[16:03:18.434]   - Field: ‘uuid’
[16:03:18.434]   - Field: ‘seed’
[16:03:18.434]   - Field: ‘version’
[16:03:18.434]   - Field: ‘result’
[16:03:18.434]   - Field: ‘asynchronous’
[16:03:18.435]   - Field: ‘calls’
[16:03:18.435]   - Field: ‘globals’
[16:03:18.435]   - Field: ‘stdout’
[16:03:18.435]   - Field: ‘earlySignal’
[16:03:18.435]   - Field: ‘lazy’
[16:03:18.435]   - Field: ‘state’
[16:03:18.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:18.435] - Launch lazy future ...
[16:03:18.436] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:18.436] Packages needed by future strategies (n = 0): <none>
[16:03:18.436] {
[16:03:18.436]     {
[16:03:18.436]         {
[16:03:18.436]             ...future.startTime <- base::Sys.time()
[16:03:18.436]             {
[16:03:18.436]                 {
[16:03:18.436]                   {
[16:03:18.436]                     {
[16:03:18.436]                       {
[16:03:18.436]                         base::local({
[16:03:18.436]                           has_future <- base::requireNamespace("future", 
[16:03:18.436]                             quietly = TRUE)
[16:03:18.436]                           if (has_future) {
[16:03:18.436]                             ns <- base::getNamespace("future")
[16:03:18.436]                             version <- ns[[".package"]][["version"]]
[16:03:18.436]                             if (is.null(version)) 
[16:03:18.436]                               version <- utils::packageVersion("future")
[16:03:18.436]                           }
[16:03:18.436]                           else {
[16:03:18.436]                             version <- NULL
[16:03:18.436]                           }
[16:03:18.436]                           if (!has_future || version < "1.8.0") {
[16:03:18.436]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:18.436]                               "", base::R.version$version.string), 
[16:03:18.436]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:18.436]                                 base::R.version$platform, 8 * 
[16:03:18.436]                                   base::.Machine$sizeof.pointer), 
[16:03:18.436]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:18.436]                                 "release", "version")], collapse = " "), 
[16:03:18.436]                               hostname = base::Sys.info()[["nodename"]])
[16:03:18.436]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:18.436]                               info)
[16:03:18.436]                             info <- base::paste(info, collapse = "; ")
[16:03:18.436]                             if (!has_future) {
[16:03:18.436]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:18.436]                                 info)
[16:03:18.436]                             }
[16:03:18.436]                             else {
[16:03:18.436]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:18.436]                                 info, version)
[16:03:18.436]                             }
[16:03:18.436]                             base::stop(msg)
[16:03:18.436]                           }
[16:03:18.436]                         })
[16:03:18.436]                       }
[16:03:18.436]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:18.436]                       base::options(mc.cores = 1L)
[16:03:18.436]                     }
[16:03:18.436]                     base::local({
[16:03:18.436]                       for (pkg in "future.apply") {
[16:03:18.436]                         base::loadNamespace(pkg)
[16:03:18.436]                         base::library(pkg, character.only = TRUE)
[16:03:18.436]                       }
[16:03:18.436]                     })
[16:03:18.436]                   }
[16:03:18.436]                   options(future.plan = NULL)
[16:03:18.436]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:18.436]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:18.436]                 }
[16:03:18.436]                 ...future.workdir <- getwd()
[16:03:18.436]             }
[16:03:18.436]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:18.436]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:18.436]         }
[16:03:18.436]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:18.436]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:18.436]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:18.436]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:18.436]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:18.436]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:18.436]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:18.436]             base::names(...future.oldOptions))
[16:03:18.436]     }
[16:03:18.436]     if (FALSE) {
[16:03:18.436]     }
[16:03:18.436]     else {
[16:03:18.436]         if (TRUE) {
[16:03:18.436]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:18.436]                 open = "w")
[16:03:18.436]         }
[16:03:18.436]         else {
[16:03:18.436]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:18.436]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:18.436]         }
[16:03:18.436]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:18.436]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:18.436]             base::sink(type = "output", split = FALSE)
[16:03:18.436]             base::close(...future.stdout)
[16:03:18.436]         }, add = TRUE)
[16:03:18.436]     }
[16:03:18.436]     ...future.frame <- base::sys.nframe()
[16:03:18.436]     ...future.conditions <- base::list()
[16:03:18.436]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:18.436]     if (FALSE) {
[16:03:18.436]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:18.436]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:18.436]     }
[16:03:18.436]     ...future.result <- base::tryCatch({
[16:03:18.436]         base::withCallingHandlers({
[16:03:18.436]             ...future.value <- base::withVisible(base::local({
[16:03:18.436]                 ...future.makeSendCondition <- base::local({
[16:03:18.436]                   sendCondition <- NULL
[16:03:18.436]                   function(frame = 1L) {
[16:03:18.436]                     if (is.function(sendCondition)) 
[16:03:18.436]                       return(sendCondition)
[16:03:18.436]                     ns <- getNamespace("parallel")
[16:03:18.436]                     if (exists("sendData", mode = "function", 
[16:03:18.436]                       envir = ns)) {
[16:03:18.436]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:18.436]                         envir = ns)
[16:03:18.436]                       envir <- sys.frame(frame)
[16:03:18.436]                       master <- NULL
[16:03:18.436]                       while (!identical(envir, .GlobalEnv) && 
[16:03:18.436]                         !identical(envir, emptyenv())) {
[16:03:18.436]                         if (exists("master", mode = "list", envir = envir, 
[16:03:18.436]                           inherits = FALSE)) {
[16:03:18.436]                           master <- get("master", mode = "list", 
[16:03:18.436]                             envir = envir, inherits = FALSE)
[16:03:18.436]                           if (inherits(master, c("SOCKnode", 
[16:03:18.436]                             "SOCK0node"))) {
[16:03:18.436]                             sendCondition <<- function(cond) {
[16:03:18.436]                               data <- list(type = "VALUE", value = cond, 
[16:03:18.436]                                 success = TRUE)
[16:03:18.436]                               parallel_sendData(master, data)
[16:03:18.436]                             }
[16:03:18.436]                             return(sendCondition)
[16:03:18.436]                           }
[16:03:18.436]                         }
[16:03:18.436]                         frame <- frame + 1L
[16:03:18.436]                         envir <- sys.frame(frame)
[16:03:18.436]                       }
[16:03:18.436]                     }
[16:03:18.436]                     sendCondition <<- function(cond) NULL
[16:03:18.436]                   }
[16:03:18.436]                 })
[16:03:18.436]                 withCallingHandlers({
[16:03:18.436]                   {
[16:03:18.436]                     do.call(function(...) {
[16:03:18.436]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.436]                       if (!identical(...future.globals.maxSize.org, 
[16:03:18.436]                         ...future.globals.maxSize)) {
[16:03:18.436]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.436]                         on.exit(options(oopts), add = TRUE)
[16:03:18.436]                       }
[16:03:18.436]                       {
[16:03:18.436]                         lapply(seq_along(...future.elements_ii), 
[16:03:18.436]                           FUN = function(jj) {
[16:03:18.436]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.436]                             ...future.FUN(...future.X_jj, ...)
[16:03:18.436]                           })
[16:03:18.436]                       }
[16:03:18.436]                     }, args = future.call.arguments)
[16:03:18.436]                   }
[16:03:18.436]                 }, immediateCondition = function(cond) {
[16:03:18.436]                   sendCondition <- ...future.makeSendCondition()
[16:03:18.436]                   sendCondition(cond)
[16:03:18.436]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.436]                   {
[16:03:18.436]                     inherits <- base::inherits
[16:03:18.436]                     invokeRestart <- base::invokeRestart
[16:03:18.436]                     is.null <- base::is.null
[16:03:18.436]                     muffled <- FALSE
[16:03:18.436]                     if (inherits(cond, "message")) {
[16:03:18.436]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:18.436]                       if (muffled) 
[16:03:18.436]                         invokeRestart("muffleMessage")
[16:03:18.436]                     }
[16:03:18.436]                     else if (inherits(cond, "warning")) {
[16:03:18.436]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:18.436]                       if (muffled) 
[16:03:18.436]                         invokeRestart("muffleWarning")
[16:03:18.436]                     }
[16:03:18.436]                     else if (inherits(cond, "condition")) {
[16:03:18.436]                       if (!is.null(pattern)) {
[16:03:18.436]                         computeRestarts <- base::computeRestarts
[16:03:18.436]                         grepl <- base::grepl
[16:03:18.436]                         restarts <- computeRestarts(cond)
[16:03:18.436]                         for (restart in restarts) {
[16:03:18.436]                           name <- restart$name
[16:03:18.436]                           if (is.null(name)) 
[16:03:18.436]                             next
[16:03:18.436]                           if (!grepl(pattern, name)) 
[16:03:18.436]                             next
[16:03:18.436]                           invokeRestart(restart)
[16:03:18.436]                           muffled <- TRUE
[16:03:18.436]                           break
[16:03:18.436]                         }
[16:03:18.436]                       }
[16:03:18.436]                     }
[16:03:18.436]                     invisible(muffled)
[16:03:18.436]                   }
[16:03:18.436]                   muffleCondition(cond)
[16:03:18.436]                 })
[16:03:18.436]             }))
[16:03:18.436]             future::FutureResult(value = ...future.value$value, 
[16:03:18.436]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:18.436]                   ...future.rng), globalenv = if (FALSE) 
[16:03:18.436]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:18.436]                     ...future.globalenv.names))
[16:03:18.436]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:18.436]         }, condition = base::local({
[16:03:18.436]             c <- base::c
[16:03:18.436]             inherits <- base::inherits
[16:03:18.436]             invokeRestart <- base::invokeRestart
[16:03:18.436]             length <- base::length
[16:03:18.436]             list <- base::list
[16:03:18.436]             seq.int <- base::seq.int
[16:03:18.436]             signalCondition <- base::signalCondition
[16:03:18.436]             sys.calls <- base::sys.calls
[16:03:18.436]             `[[` <- base::`[[`
[16:03:18.436]             `+` <- base::`+`
[16:03:18.436]             `<<-` <- base::`<<-`
[16:03:18.436]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:18.436]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:18.436]                   3L)]
[16:03:18.436]             }
[16:03:18.436]             function(cond) {
[16:03:18.436]                 is_error <- inherits(cond, "error")
[16:03:18.436]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:18.436]                   NULL)
[16:03:18.436]                 if (is_error) {
[16:03:18.436]                   sessionInformation <- function() {
[16:03:18.436]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:18.436]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:18.436]                       search = base::search(), system = base::Sys.info())
[16:03:18.436]                   }
[16:03:18.436]                   ...future.conditions[[length(...future.conditions) + 
[16:03:18.436]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:18.436]                     cond$call), session = sessionInformation(), 
[16:03:18.436]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:18.436]                   signalCondition(cond)
[16:03:18.436]                 }
[16:03:18.436]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:18.436]                 "immediateCondition"))) {
[16:03:18.436]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:18.436]                   ...future.conditions[[length(...future.conditions) + 
[16:03:18.436]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:18.436]                   if (TRUE && !signal) {
[16:03:18.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.436]                     {
[16:03:18.436]                       inherits <- base::inherits
[16:03:18.436]                       invokeRestart <- base::invokeRestart
[16:03:18.436]                       is.null <- base::is.null
[16:03:18.436]                       muffled <- FALSE
[16:03:18.436]                       if (inherits(cond, "message")) {
[16:03:18.436]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:18.436]                         if (muffled) 
[16:03:18.436]                           invokeRestart("muffleMessage")
[16:03:18.436]                       }
[16:03:18.436]                       else if (inherits(cond, "warning")) {
[16:03:18.436]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:18.436]                         if (muffled) 
[16:03:18.436]                           invokeRestart("muffleWarning")
[16:03:18.436]                       }
[16:03:18.436]                       else if (inherits(cond, "condition")) {
[16:03:18.436]                         if (!is.null(pattern)) {
[16:03:18.436]                           computeRestarts <- base::computeRestarts
[16:03:18.436]                           grepl <- base::grepl
[16:03:18.436]                           restarts <- computeRestarts(cond)
[16:03:18.436]                           for (restart in restarts) {
[16:03:18.436]                             name <- restart$name
[16:03:18.436]                             if (is.null(name)) 
[16:03:18.436]                               next
[16:03:18.436]                             if (!grepl(pattern, name)) 
[16:03:18.436]                               next
[16:03:18.436]                             invokeRestart(restart)
[16:03:18.436]                             muffled <- TRUE
[16:03:18.436]                             break
[16:03:18.436]                           }
[16:03:18.436]                         }
[16:03:18.436]                       }
[16:03:18.436]                       invisible(muffled)
[16:03:18.436]                     }
[16:03:18.436]                     muffleCondition(cond, pattern = "^muffle")
[16:03:18.436]                   }
[16:03:18.436]                 }
[16:03:18.436]                 else {
[16:03:18.436]                   if (TRUE) {
[16:03:18.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.436]                     {
[16:03:18.436]                       inherits <- base::inherits
[16:03:18.436]                       invokeRestart <- base::invokeRestart
[16:03:18.436]                       is.null <- base::is.null
[16:03:18.436]                       muffled <- FALSE
[16:03:18.436]                       if (inherits(cond, "message")) {
[16:03:18.436]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:18.436]                         if (muffled) 
[16:03:18.436]                           invokeRestart("muffleMessage")
[16:03:18.436]                       }
[16:03:18.436]                       else if (inherits(cond, "warning")) {
[16:03:18.436]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:18.436]                         if (muffled) 
[16:03:18.436]                           invokeRestart("muffleWarning")
[16:03:18.436]                       }
[16:03:18.436]                       else if (inherits(cond, "condition")) {
[16:03:18.436]                         if (!is.null(pattern)) {
[16:03:18.436]                           computeRestarts <- base::computeRestarts
[16:03:18.436]                           grepl <- base::grepl
[16:03:18.436]                           restarts <- computeRestarts(cond)
[16:03:18.436]                           for (restart in restarts) {
[16:03:18.436]                             name <- restart$name
[16:03:18.436]                             if (is.null(name)) 
[16:03:18.436]                               next
[16:03:18.436]                             if (!grepl(pattern, name)) 
[16:03:18.436]                               next
[16:03:18.436]                             invokeRestart(restart)
[16:03:18.436]                             muffled <- TRUE
[16:03:18.436]                             break
[16:03:18.436]                           }
[16:03:18.436]                         }
[16:03:18.436]                       }
[16:03:18.436]                       invisible(muffled)
[16:03:18.436]                     }
[16:03:18.436]                     muffleCondition(cond, pattern = "^muffle")
[16:03:18.436]                   }
[16:03:18.436]                 }
[16:03:18.436]             }
[16:03:18.436]         }))
[16:03:18.436]     }, error = function(ex) {
[16:03:18.436]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:18.436]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:18.436]                 ...future.rng), started = ...future.startTime, 
[16:03:18.436]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:18.436]             version = "1.8"), class = "FutureResult")
[16:03:18.436]     }, finally = {
[16:03:18.436]         if (!identical(...future.workdir, getwd())) 
[16:03:18.436]             setwd(...future.workdir)
[16:03:18.436]         {
[16:03:18.436]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:18.436]                 ...future.oldOptions$nwarnings <- NULL
[16:03:18.436]             }
[16:03:18.436]             base::options(...future.oldOptions)
[16:03:18.436]             if (.Platform$OS.type == "windows") {
[16:03:18.436]                 old_names <- names(...future.oldEnvVars)
[16:03:18.436]                 envs <- base::Sys.getenv()
[16:03:18.436]                 names <- names(envs)
[16:03:18.436]                 common <- intersect(names, old_names)
[16:03:18.436]                 added <- setdiff(names, old_names)
[16:03:18.436]                 removed <- setdiff(old_names, names)
[16:03:18.436]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:18.436]                   envs[common]]
[16:03:18.436]                 NAMES <- toupper(changed)
[16:03:18.436]                 args <- list()
[16:03:18.436]                 for (kk in seq_along(NAMES)) {
[16:03:18.436]                   name <- changed[[kk]]
[16:03:18.436]                   NAME <- NAMES[[kk]]
[16:03:18.436]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.436]                     next
[16:03:18.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:18.436]                 }
[16:03:18.436]                 NAMES <- toupper(added)
[16:03:18.436]                 for (kk in seq_along(NAMES)) {
[16:03:18.436]                   name <- added[[kk]]
[16:03:18.436]                   NAME <- NAMES[[kk]]
[16:03:18.436]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.436]                     next
[16:03:18.436]                   args[[name]] <- ""
[16:03:18.436]                 }
[16:03:18.436]                 NAMES <- toupper(removed)
[16:03:18.436]                 for (kk in seq_along(NAMES)) {
[16:03:18.436]                   name <- removed[[kk]]
[16:03:18.436]                   NAME <- NAMES[[kk]]
[16:03:18.436]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.436]                     next
[16:03:18.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:18.436]                 }
[16:03:18.436]                 if (length(args) > 0) 
[16:03:18.436]                   base::do.call(base::Sys.setenv, args = args)
[16:03:18.436]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:18.436]             }
[16:03:18.436]             else {
[16:03:18.436]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:18.436]             }
[16:03:18.436]             {
[16:03:18.436]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:18.436]                   0L) {
[16:03:18.436]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:18.436]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:18.436]                   base::options(opts)
[16:03:18.436]                 }
[16:03:18.436]                 {
[16:03:18.436]                   {
[16:03:18.436]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:18.436]                     NULL
[16:03:18.436]                   }
[16:03:18.436]                   options(future.plan = NULL)
[16:03:18.436]                   if (is.na(NA_character_)) 
[16:03:18.436]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:18.436]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:18.436]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:18.436]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:18.436]                     envir = parent.frame()) 
[16:03:18.436]                   {
[16:03:18.436]                     if (is.function(workers)) 
[16:03:18.436]                       workers <- workers()
[16:03:18.436]                     workers <- structure(as.integer(workers), 
[16:03:18.436]                       class = class(workers))
[16:03:18.436]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:18.436]                       workers >= 1)
[16:03:18.436]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:18.436]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:18.436]                     }
[16:03:18.436]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:18.436]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:18.436]                       envir = envir)
[16:03:18.436]                     if (!future$lazy) 
[16:03:18.436]                       future <- run(future)
[16:03:18.436]                     invisible(future)
[16:03:18.436]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:18.436]                 }
[16:03:18.436]             }
[16:03:18.436]         }
[16:03:18.436]     })
[16:03:18.436]     if (TRUE) {
[16:03:18.436]         base::sink(type = "output", split = FALSE)
[16:03:18.436]         if (TRUE) {
[16:03:18.436]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:18.436]         }
[16:03:18.436]         else {
[16:03:18.436]             ...future.result["stdout"] <- base::list(NULL)
[16:03:18.436]         }
[16:03:18.436]         base::close(...future.stdout)
[16:03:18.436]         ...future.stdout <- NULL
[16:03:18.436]     }
[16:03:18.436]     ...future.result$conditions <- ...future.conditions
[16:03:18.436]     ...future.result$finished <- base::Sys.time()
[16:03:18.436]     ...future.result
[16:03:18.436] }
[16:03:18.439] Exporting 11 global objects (94.95 KiB) to cluster node #2 ...
[16:03:18.439] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:18.483] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:18.483] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[16:03:18.484] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[16:03:18.484] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:18.484] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:18.485] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:18.527] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:18.527] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:18.571] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:18.571] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[16:03:18.572] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[16:03:18.572] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[16:03:18.572] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[16:03:18.572] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:18.573] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:18.573] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:03:18.573] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:03:18.574] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:18.574] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:18.574] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:18.574] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:18.575] Exporting 11 global objects (94.95 KiB) to cluster node #2 ... DONE
[16:03:18.575] MultisessionFuture started
[16:03:18.575] - Launch lazy future ... done
[16:03:18.576] run() for ‘MultisessionFuture’ ... done
[16:03:18.576] Created future:
[16:03:18.576] MultisessionFuture:
[16:03:18.576] Label: ‘future_vapply-2’
[16:03:18.576] Expression:
[16:03:18.576] {
[16:03:18.576]     do.call(function(...) {
[16:03:18.576]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.576]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:18.576]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.576]             on.exit(options(oopts), add = TRUE)
[16:03:18.576]         }
[16:03:18.576]         {
[16:03:18.576]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:18.576]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.576]                 ...future.FUN(...future.X_jj, ...)
[16:03:18.576]             })
[16:03:18.576]         }
[16:03:18.576]     }, args = future.call.arguments)
[16:03:18.576] }
[16:03:18.576] Lazy evaluation: FALSE
[16:03:18.576] Asynchronous evaluation: TRUE
[16:03:18.576] Local evaluation: TRUE
[16:03:18.576] Environment: R_GlobalEnv
[16:03:18.576] Capture standard output: TRUE
[16:03:18.576] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:18.576] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:18.576] Packages: 1 packages (‘future.apply’)
[16:03:18.576] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:18.576] Resolved: FALSE
[16:03:18.576] Value: <not collected>
[16:03:18.576] Conditions captured: <none>
[16:03:18.576] Early signaling: FALSE
[16:03:18.576] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:18.576] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:18.588] Chunk #2 of 2 ... DONE
[16:03:18.588] Launching 2 futures (chunks) ... DONE
[16:03:18.588] Resolving 2 futures (chunks) ...
[16:03:18.588] resolve() on list ...
[16:03:18.588]  recursive: 0
[16:03:18.589]  length: 2
[16:03:18.589] 
[16:03:18.589] receiveMessageFromWorker() for ClusterFuture ...
[16:03:18.589] - Validating connection of MultisessionFuture
[16:03:18.589] - received message: FutureResult
[16:03:18.590] - Received FutureResult
[16:03:18.590] - Erased future from FutureRegistry
[16:03:18.590] result() for ClusterFuture ...
[16:03:18.590] - result already collected: FutureResult
[16:03:18.590] result() for ClusterFuture ... done
[16:03:18.590] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:18.590] Future #1
[16:03:18.590] result() for ClusterFuture ...
[16:03:18.593] - result already collected: FutureResult
[16:03:18.593] result() for ClusterFuture ... done
[16:03:18.593] result() for ClusterFuture ...
[16:03:18.593] - result already collected: FutureResult
[16:03:18.593] result() for ClusterFuture ... done
[16:03:18.593] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:18.593] - nx: 2
[16:03:18.593] - relay: TRUE
[16:03:18.593] - stdout: TRUE
[16:03:18.593] - signal: TRUE
[16:03:18.593] - resignal: FALSE
[16:03:18.594] - force: TRUE
[16:03:18.594] - relayed: [n=2] FALSE, FALSE
[16:03:18.594] - queued futures: [n=2] FALSE, FALSE
[16:03:18.594]  - until=1
[16:03:18.594]  - relaying element #1
[16:03:18.594] result() for ClusterFuture ...
[16:03:18.594] - result already collected: FutureResult
[16:03:18.594] result() for ClusterFuture ... done
[16:03:18.594] result() for ClusterFuture ...
[16:03:18.594] - result already collected: FutureResult
[16:03:18.594] result() for ClusterFuture ... done
[16:03:18.595] result() for ClusterFuture ...
[16:03:18.595] - result already collected: FutureResult
[16:03:18.595] result() for ClusterFuture ... done
[16:03:18.595] result() for ClusterFuture ...
[16:03:18.595] - result already collected: FutureResult
[16:03:18.595] result() for ClusterFuture ... done
[16:03:18.595] - relayed: [n=2] TRUE, FALSE
[16:03:18.595] - queued futures: [n=2] TRUE, FALSE
[16:03:18.595] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:18.595]  length: 1 (resolved future 1)
[16:03:18.624] receiveMessageFromWorker() for ClusterFuture ...
[16:03:18.624] - Validating connection of MultisessionFuture
[16:03:18.625] - received message: FutureResult
[16:03:18.625] - Received FutureResult
[16:03:18.625] - Erased future from FutureRegistry
[16:03:18.625] result() for ClusterFuture ...
[16:03:18.625] - result already collected: FutureResult
[16:03:18.625] result() for ClusterFuture ... done
[16:03:18.625] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:18.625] Future #2
[16:03:18.626] result() for ClusterFuture ...
[16:03:18.626] - result already collected: FutureResult
[16:03:18.626] result() for ClusterFuture ... done
[16:03:18.626] result() for ClusterFuture ...
[16:03:18.626] - result already collected: FutureResult
[16:03:18.626] result() for ClusterFuture ... done
[16:03:18.626] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:18.626] - nx: 2
[16:03:18.626] - relay: TRUE
[16:03:18.626] - stdout: TRUE
[16:03:18.626] - signal: TRUE
[16:03:18.627] - resignal: FALSE
[16:03:18.627] - force: TRUE
[16:03:18.627] - relayed: [n=2] TRUE, FALSE
[16:03:18.627] - queued futures: [n=2] TRUE, FALSE
[16:03:18.627]  - until=2
[16:03:18.627]  - relaying element #2
[16:03:18.627] result() for ClusterFuture ...
[16:03:18.627] - result already collected: FutureResult
[16:03:18.627] result() for ClusterFuture ... done
[16:03:18.627] result() for ClusterFuture ...
[16:03:18.628] - result already collected: FutureResult
[16:03:18.628] result() for ClusterFuture ... done
[16:03:18.628] result() for ClusterFuture ...
[16:03:18.628] - result already collected: FutureResult
[16:03:18.628] result() for ClusterFuture ... done
[16:03:18.628] result() for ClusterFuture ...
[16:03:18.628] - result already collected: FutureResult
[16:03:18.628] result() for ClusterFuture ... done
[16:03:18.628] - relayed: [n=2] TRUE, TRUE
[16:03:18.628] - queued futures: [n=2] TRUE, TRUE
[16:03:18.628] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:18.629]  length: 0 (resolved future 2)
[16:03:18.629] Relaying remaining futures
[16:03:18.629] signalConditionsASAP(NULL, pos=0) ...
[16:03:18.629] - nx: 2
[16:03:18.629] - relay: TRUE
[16:03:18.629] - stdout: TRUE
[16:03:18.629] - signal: TRUE
[16:03:18.629] - resignal: FALSE
[16:03:18.629] - force: TRUE
[16:03:18.629] - relayed: [n=2] TRUE, TRUE
[16:03:18.629] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:18.630] - relayed: [n=2] TRUE, TRUE
[16:03:18.630] - queued futures: [n=2] TRUE, TRUE
[16:03:18.630] signalConditionsASAP(NULL, pos=0) ... done
[16:03:18.630] resolve() on list ... DONE
[16:03:18.630] result() for ClusterFuture ...
[16:03:18.630] - result already collected: FutureResult
[16:03:18.630] result() for ClusterFuture ... done
[16:03:18.630] result() for ClusterFuture ...
[16:03:18.630] - result already collected: FutureResult
[16:03:18.630] result() for ClusterFuture ... done
[16:03:18.630] result() for ClusterFuture ...
[16:03:18.631] - result already collected: FutureResult
[16:03:18.631] result() for ClusterFuture ... done
[16:03:18.631] result() for ClusterFuture ...
[16:03:18.631] - result already collected: FutureResult
[16:03:18.631] result() for ClusterFuture ... done
[16:03:18.631]  - Number of value chunks collected: 2
[16:03:18.631] Resolving 2 futures (chunks) ... DONE
[16:03:18.631] Reducing values from 2 chunks ...
[16:03:18.631]  - Number of values collected after concatenation: 10
[16:03:18.631]  - Number of values expected: 10
[16:03:18.632] Reducing values from 2 chunks ... DONE
[16:03:18.632] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:03:18.633] future_lapply() ...
[16:03:18.638] Number of chunks: 2
[16:03:18.638] getGlobalsAndPackagesXApply() ...
[16:03:18.638]  - future.globals: TRUE
[16:03:18.638] getGlobalsAndPackages() ...
[16:03:18.639] Searching for globals...
[16:03:18.642] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:03:18.642] Searching for globals ... DONE
[16:03:18.642] Resolving globals: FALSE
[16:03:18.643] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[16:03:18.644] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:18.644] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:18.644] - packages: [1] ‘future.apply’
[16:03:18.644] getGlobalsAndPackages() ... DONE
[16:03:18.644]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:18.644]  - needed namespaces: [n=1] ‘future.apply’
[16:03:18.644] Finding globals ... DONE
[16:03:18.645]  - use_args: TRUE
[16:03:18.645]  - Getting '...' globals ...
[16:03:18.645] resolve() on list ...
[16:03:18.645]  recursive: 0
[16:03:18.645]  length: 1
[16:03:18.645]  elements: ‘...’
[16:03:18.645]  length: 0 (resolved future 1)
[16:03:18.645] resolve() on list ... DONE
[16:03:18.646]    - '...' content: [n=0] 
[16:03:18.646] List of 1
[16:03:18.646]  $ ...: list()
[16:03:18.646]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:18.646]  - attr(*, "where")=List of 1
[16:03:18.646]   ..$ ...:<environment: 0x564e4294d670> 
[16:03:18.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:18.646]  - attr(*, "resolved")= logi TRUE
[16:03:18.646]  - attr(*, "total_size")= num NA
[16:03:18.648]  - Getting '...' globals ... DONE
[16:03:18.648] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:18.648] List of 8
[16:03:18.648]  $ ...future.FUN:function (x, ...)  
[16:03:18.648]  $ x_FUN        :function (x)  
[16:03:18.648]  $ times        : int 4
[16:03:18.648]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:18.648]  $ stop_if_not  :function (...)  
[16:03:18.648]  $ dim          : int [1:2] 2 2
[16:03:18.648]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:18.648]  $ ...          : list()
[16:03:18.648]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:18.648]  - attr(*, "where")=List of 8
[16:03:18.648]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:18.648]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:18.648]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:18.648]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:18.648]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:18.648]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:18.648]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:18.648]   ..$ ...          :<environment: 0x564e4294d670> 
[16:03:18.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:18.648]  - attr(*, "resolved")= logi FALSE
[16:03:18.648]  - attr(*, "total_size")= num 97304
[16:03:18.654] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:18.654] getGlobalsAndPackagesXApply() ... DONE
[16:03:18.654] Number of futures (= number of chunks): 2
[16:03:18.654] Launching 2 futures (chunks) ...
[16:03:18.654] Chunk #1 of 2 ...
[16:03:18.654]  - Finding globals in 'X' for chunk #1 ...
[16:03:18.654] getGlobalsAndPackages() ...
[16:03:18.655] Searching for globals...
[16:03:18.655] 
[16:03:18.655] Searching for globals ... DONE
[16:03:18.655] - globals: [0] <none>
[16:03:18.655] getGlobalsAndPackages() ... DONE
[16:03:18.655]    + additional globals found: [n=0] 
[16:03:18.655]    + additional namespaces needed: [n=0] 
[16:03:18.655]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:18.656]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:18.656]  - seeds: <none>
[16:03:18.656]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.656] getGlobalsAndPackages() ...
[16:03:18.656] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.656] Resolving globals: FALSE
[16:03:18.656] Tweak future expression to call with '...' arguments ...
[16:03:18.656] {
[16:03:18.656]     do.call(function(...) {
[16:03:18.656]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.656]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:18.656]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.656]             on.exit(options(oopts), add = TRUE)
[16:03:18.656]         }
[16:03:18.656]         {
[16:03:18.656]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:18.656]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.656]                 ...future.FUN(...future.X_jj, ...)
[16:03:18.656]             })
[16:03:18.656]         }
[16:03:18.656]     }, args = future.call.arguments)
[16:03:18.656] }
[16:03:18.657] Tweak future expression to call with '...' arguments ... DONE
[16:03:18.657] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.657] - packages: [1] ‘future.apply’
[16:03:18.657] getGlobalsAndPackages() ... DONE
[16:03:18.658] run() for ‘Future’ ...
[16:03:18.658] - state: ‘created’
[16:03:18.658] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:18.672] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:18.672] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:18.672]   - Field: ‘node’
[16:03:18.672]   - Field: ‘label’
[16:03:18.673]   - Field: ‘local’
[16:03:18.673]   - Field: ‘owner’
[16:03:18.673]   - Field: ‘envir’
[16:03:18.673]   - Field: ‘workers’
[16:03:18.673]   - Field: ‘packages’
[16:03:18.673]   - Field: ‘gc’
[16:03:18.673]   - Field: ‘conditions’
[16:03:18.673]   - Field: ‘persistent’
[16:03:18.673]   - Field: ‘expr’
[16:03:18.673]   - Field: ‘uuid’
[16:03:18.673]   - Field: ‘seed’
[16:03:18.674]   - Field: ‘version’
[16:03:18.674]   - Field: ‘result’
[16:03:18.674]   - Field: ‘asynchronous’
[16:03:18.674]   - Field: ‘calls’
[16:03:18.674]   - Field: ‘globals’
[16:03:18.674]   - Field: ‘stdout’
[16:03:18.674]   - Field: ‘earlySignal’
[16:03:18.674]   - Field: ‘lazy’
[16:03:18.674]   - Field: ‘state’
[16:03:18.674] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:18.675] - Launch lazy future ...
[16:03:18.675] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:18.675] Packages needed by future strategies (n = 0): <none>
[16:03:18.676] {
[16:03:18.676]     {
[16:03:18.676]         {
[16:03:18.676]             ...future.startTime <- base::Sys.time()
[16:03:18.676]             {
[16:03:18.676]                 {
[16:03:18.676]                   {
[16:03:18.676]                     {
[16:03:18.676]                       {
[16:03:18.676]                         base::local({
[16:03:18.676]                           has_future <- base::requireNamespace("future", 
[16:03:18.676]                             quietly = TRUE)
[16:03:18.676]                           if (has_future) {
[16:03:18.676]                             ns <- base::getNamespace("future")
[16:03:18.676]                             version <- ns[[".package"]][["version"]]
[16:03:18.676]                             if (is.null(version)) 
[16:03:18.676]                               version <- utils::packageVersion("future")
[16:03:18.676]                           }
[16:03:18.676]                           else {
[16:03:18.676]                             version <- NULL
[16:03:18.676]                           }
[16:03:18.676]                           if (!has_future || version < "1.8.0") {
[16:03:18.676]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:18.676]                               "", base::R.version$version.string), 
[16:03:18.676]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:18.676]                                 base::R.version$platform, 8 * 
[16:03:18.676]                                   base::.Machine$sizeof.pointer), 
[16:03:18.676]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:18.676]                                 "release", "version")], collapse = " "), 
[16:03:18.676]                               hostname = base::Sys.info()[["nodename"]])
[16:03:18.676]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:18.676]                               info)
[16:03:18.676]                             info <- base::paste(info, collapse = "; ")
[16:03:18.676]                             if (!has_future) {
[16:03:18.676]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:18.676]                                 info)
[16:03:18.676]                             }
[16:03:18.676]                             else {
[16:03:18.676]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:18.676]                                 info, version)
[16:03:18.676]                             }
[16:03:18.676]                             base::stop(msg)
[16:03:18.676]                           }
[16:03:18.676]                         })
[16:03:18.676]                       }
[16:03:18.676]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:18.676]                       base::options(mc.cores = 1L)
[16:03:18.676]                     }
[16:03:18.676]                     base::local({
[16:03:18.676]                       for (pkg in "future.apply") {
[16:03:18.676]                         base::loadNamespace(pkg)
[16:03:18.676]                         base::library(pkg, character.only = TRUE)
[16:03:18.676]                       }
[16:03:18.676]                     })
[16:03:18.676]                   }
[16:03:18.676]                   options(future.plan = NULL)
[16:03:18.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:18.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:18.676]                 }
[16:03:18.676]                 ...future.workdir <- getwd()
[16:03:18.676]             }
[16:03:18.676]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:18.676]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:18.676]         }
[16:03:18.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:18.676]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:18.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:18.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:18.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:18.676]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:18.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:18.676]             base::names(...future.oldOptions))
[16:03:18.676]     }
[16:03:18.676]     if (FALSE) {
[16:03:18.676]     }
[16:03:18.676]     else {
[16:03:18.676]         if (TRUE) {
[16:03:18.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:18.676]                 open = "w")
[16:03:18.676]         }
[16:03:18.676]         else {
[16:03:18.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:18.676]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:18.676]         }
[16:03:18.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:18.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:18.676]             base::sink(type = "output", split = FALSE)
[16:03:18.676]             base::close(...future.stdout)
[16:03:18.676]         }, add = TRUE)
[16:03:18.676]     }
[16:03:18.676]     ...future.frame <- base::sys.nframe()
[16:03:18.676]     ...future.conditions <- base::list()
[16:03:18.676]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:18.676]     if (FALSE) {
[16:03:18.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:18.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:18.676]     }
[16:03:18.676]     ...future.result <- base::tryCatch({
[16:03:18.676]         base::withCallingHandlers({
[16:03:18.676]             ...future.value <- base::withVisible(base::local({
[16:03:18.676]                 ...future.makeSendCondition <- base::local({
[16:03:18.676]                   sendCondition <- NULL
[16:03:18.676]                   function(frame = 1L) {
[16:03:18.676]                     if (is.function(sendCondition)) 
[16:03:18.676]                       return(sendCondition)
[16:03:18.676]                     ns <- getNamespace("parallel")
[16:03:18.676]                     if (exists("sendData", mode = "function", 
[16:03:18.676]                       envir = ns)) {
[16:03:18.676]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:18.676]                         envir = ns)
[16:03:18.676]                       envir <- sys.frame(frame)
[16:03:18.676]                       master <- NULL
[16:03:18.676]                       while (!identical(envir, .GlobalEnv) && 
[16:03:18.676]                         !identical(envir, emptyenv())) {
[16:03:18.676]                         if (exists("master", mode = "list", envir = envir, 
[16:03:18.676]                           inherits = FALSE)) {
[16:03:18.676]                           master <- get("master", mode = "list", 
[16:03:18.676]                             envir = envir, inherits = FALSE)
[16:03:18.676]                           if (inherits(master, c("SOCKnode", 
[16:03:18.676]                             "SOCK0node"))) {
[16:03:18.676]                             sendCondition <<- function(cond) {
[16:03:18.676]                               data <- list(type = "VALUE", value = cond, 
[16:03:18.676]                                 success = TRUE)
[16:03:18.676]                               parallel_sendData(master, data)
[16:03:18.676]                             }
[16:03:18.676]                             return(sendCondition)
[16:03:18.676]                           }
[16:03:18.676]                         }
[16:03:18.676]                         frame <- frame + 1L
[16:03:18.676]                         envir <- sys.frame(frame)
[16:03:18.676]                       }
[16:03:18.676]                     }
[16:03:18.676]                     sendCondition <<- function(cond) NULL
[16:03:18.676]                   }
[16:03:18.676]                 })
[16:03:18.676]                 withCallingHandlers({
[16:03:18.676]                   {
[16:03:18.676]                     do.call(function(...) {
[16:03:18.676]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.676]                       if (!identical(...future.globals.maxSize.org, 
[16:03:18.676]                         ...future.globals.maxSize)) {
[16:03:18.676]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.676]                         on.exit(options(oopts), add = TRUE)
[16:03:18.676]                       }
[16:03:18.676]                       {
[16:03:18.676]                         lapply(seq_along(...future.elements_ii), 
[16:03:18.676]                           FUN = function(jj) {
[16:03:18.676]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.676]                             ...future.FUN(...future.X_jj, ...)
[16:03:18.676]                           })
[16:03:18.676]                       }
[16:03:18.676]                     }, args = future.call.arguments)
[16:03:18.676]                   }
[16:03:18.676]                 }, immediateCondition = function(cond) {
[16:03:18.676]                   sendCondition <- ...future.makeSendCondition()
[16:03:18.676]                   sendCondition(cond)
[16:03:18.676]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.676]                   {
[16:03:18.676]                     inherits <- base::inherits
[16:03:18.676]                     invokeRestart <- base::invokeRestart
[16:03:18.676]                     is.null <- base::is.null
[16:03:18.676]                     muffled <- FALSE
[16:03:18.676]                     if (inherits(cond, "message")) {
[16:03:18.676]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:18.676]                       if (muffled) 
[16:03:18.676]                         invokeRestart("muffleMessage")
[16:03:18.676]                     }
[16:03:18.676]                     else if (inherits(cond, "warning")) {
[16:03:18.676]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:18.676]                       if (muffled) 
[16:03:18.676]                         invokeRestart("muffleWarning")
[16:03:18.676]                     }
[16:03:18.676]                     else if (inherits(cond, "condition")) {
[16:03:18.676]                       if (!is.null(pattern)) {
[16:03:18.676]                         computeRestarts <- base::computeRestarts
[16:03:18.676]                         grepl <- base::grepl
[16:03:18.676]                         restarts <- computeRestarts(cond)
[16:03:18.676]                         for (restart in restarts) {
[16:03:18.676]                           name <- restart$name
[16:03:18.676]                           if (is.null(name)) 
[16:03:18.676]                             next
[16:03:18.676]                           if (!grepl(pattern, name)) 
[16:03:18.676]                             next
[16:03:18.676]                           invokeRestart(restart)
[16:03:18.676]                           muffled <- TRUE
[16:03:18.676]                           break
[16:03:18.676]                         }
[16:03:18.676]                       }
[16:03:18.676]                     }
[16:03:18.676]                     invisible(muffled)
[16:03:18.676]                   }
[16:03:18.676]                   muffleCondition(cond)
[16:03:18.676]                 })
[16:03:18.676]             }))
[16:03:18.676]             future::FutureResult(value = ...future.value$value, 
[16:03:18.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:18.676]                   ...future.rng), globalenv = if (FALSE) 
[16:03:18.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:18.676]                     ...future.globalenv.names))
[16:03:18.676]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:18.676]         }, condition = base::local({
[16:03:18.676]             c <- base::c
[16:03:18.676]             inherits <- base::inherits
[16:03:18.676]             invokeRestart <- base::invokeRestart
[16:03:18.676]             length <- base::length
[16:03:18.676]             list <- base::list
[16:03:18.676]             seq.int <- base::seq.int
[16:03:18.676]             signalCondition <- base::signalCondition
[16:03:18.676]             sys.calls <- base::sys.calls
[16:03:18.676]             `[[` <- base::`[[`
[16:03:18.676]             `+` <- base::`+`
[16:03:18.676]             `<<-` <- base::`<<-`
[16:03:18.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:18.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:18.676]                   3L)]
[16:03:18.676]             }
[16:03:18.676]             function(cond) {
[16:03:18.676]                 is_error <- inherits(cond, "error")
[16:03:18.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:18.676]                   NULL)
[16:03:18.676]                 if (is_error) {
[16:03:18.676]                   sessionInformation <- function() {
[16:03:18.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:18.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:18.676]                       search = base::search(), system = base::Sys.info())
[16:03:18.676]                   }
[16:03:18.676]                   ...future.conditions[[length(...future.conditions) + 
[16:03:18.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:18.676]                     cond$call), session = sessionInformation(), 
[16:03:18.676]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:18.676]                   signalCondition(cond)
[16:03:18.676]                 }
[16:03:18.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:18.676]                 "immediateCondition"))) {
[16:03:18.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:18.676]                   ...future.conditions[[length(...future.conditions) + 
[16:03:18.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:18.676]                   if (TRUE && !signal) {
[16:03:18.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.676]                     {
[16:03:18.676]                       inherits <- base::inherits
[16:03:18.676]                       invokeRestart <- base::invokeRestart
[16:03:18.676]                       is.null <- base::is.null
[16:03:18.676]                       muffled <- FALSE
[16:03:18.676]                       if (inherits(cond, "message")) {
[16:03:18.676]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:18.676]                         if (muffled) 
[16:03:18.676]                           invokeRestart("muffleMessage")
[16:03:18.676]                       }
[16:03:18.676]                       else if (inherits(cond, "warning")) {
[16:03:18.676]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:18.676]                         if (muffled) 
[16:03:18.676]                           invokeRestart("muffleWarning")
[16:03:18.676]                       }
[16:03:18.676]                       else if (inherits(cond, "condition")) {
[16:03:18.676]                         if (!is.null(pattern)) {
[16:03:18.676]                           computeRestarts <- base::computeRestarts
[16:03:18.676]                           grepl <- base::grepl
[16:03:18.676]                           restarts <- computeRestarts(cond)
[16:03:18.676]                           for (restart in restarts) {
[16:03:18.676]                             name <- restart$name
[16:03:18.676]                             if (is.null(name)) 
[16:03:18.676]                               next
[16:03:18.676]                             if (!grepl(pattern, name)) 
[16:03:18.676]                               next
[16:03:18.676]                             invokeRestart(restart)
[16:03:18.676]                             muffled <- TRUE
[16:03:18.676]                             break
[16:03:18.676]                           }
[16:03:18.676]                         }
[16:03:18.676]                       }
[16:03:18.676]                       invisible(muffled)
[16:03:18.676]                     }
[16:03:18.676]                     muffleCondition(cond, pattern = "^muffle")
[16:03:18.676]                   }
[16:03:18.676]                 }
[16:03:18.676]                 else {
[16:03:18.676]                   if (TRUE) {
[16:03:18.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.676]                     {
[16:03:18.676]                       inherits <- base::inherits
[16:03:18.676]                       invokeRestart <- base::invokeRestart
[16:03:18.676]                       is.null <- base::is.null
[16:03:18.676]                       muffled <- FALSE
[16:03:18.676]                       if (inherits(cond, "message")) {
[16:03:18.676]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:18.676]                         if (muffled) 
[16:03:18.676]                           invokeRestart("muffleMessage")
[16:03:18.676]                       }
[16:03:18.676]                       else if (inherits(cond, "warning")) {
[16:03:18.676]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:18.676]                         if (muffled) 
[16:03:18.676]                           invokeRestart("muffleWarning")
[16:03:18.676]                       }
[16:03:18.676]                       else if (inherits(cond, "condition")) {
[16:03:18.676]                         if (!is.null(pattern)) {
[16:03:18.676]                           computeRestarts <- base::computeRestarts
[16:03:18.676]                           grepl <- base::grepl
[16:03:18.676]                           restarts <- computeRestarts(cond)
[16:03:18.676]                           for (restart in restarts) {
[16:03:18.676]                             name <- restart$name
[16:03:18.676]                             if (is.null(name)) 
[16:03:18.676]                               next
[16:03:18.676]                             if (!grepl(pattern, name)) 
[16:03:18.676]                               next
[16:03:18.676]                             invokeRestart(restart)
[16:03:18.676]                             muffled <- TRUE
[16:03:18.676]                             break
[16:03:18.676]                           }
[16:03:18.676]                         }
[16:03:18.676]                       }
[16:03:18.676]                       invisible(muffled)
[16:03:18.676]                     }
[16:03:18.676]                     muffleCondition(cond, pattern = "^muffle")
[16:03:18.676]                   }
[16:03:18.676]                 }
[16:03:18.676]             }
[16:03:18.676]         }))
[16:03:18.676]     }, error = function(ex) {
[16:03:18.676]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:18.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:18.676]                 ...future.rng), started = ...future.startTime, 
[16:03:18.676]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:18.676]             version = "1.8"), class = "FutureResult")
[16:03:18.676]     }, finally = {
[16:03:18.676]         if (!identical(...future.workdir, getwd())) 
[16:03:18.676]             setwd(...future.workdir)
[16:03:18.676]         {
[16:03:18.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:18.676]                 ...future.oldOptions$nwarnings <- NULL
[16:03:18.676]             }
[16:03:18.676]             base::options(...future.oldOptions)
[16:03:18.676]             if (.Platform$OS.type == "windows") {
[16:03:18.676]                 old_names <- names(...future.oldEnvVars)
[16:03:18.676]                 envs <- base::Sys.getenv()
[16:03:18.676]                 names <- names(envs)
[16:03:18.676]                 common <- intersect(names, old_names)
[16:03:18.676]                 added <- setdiff(names, old_names)
[16:03:18.676]                 removed <- setdiff(old_names, names)
[16:03:18.676]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:18.676]                   envs[common]]
[16:03:18.676]                 NAMES <- toupper(changed)
[16:03:18.676]                 args <- list()
[16:03:18.676]                 for (kk in seq_along(NAMES)) {
[16:03:18.676]                   name <- changed[[kk]]
[16:03:18.676]                   NAME <- NAMES[[kk]]
[16:03:18.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.676]                     next
[16:03:18.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:18.676]                 }
[16:03:18.676]                 NAMES <- toupper(added)
[16:03:18.676]                 for (kk in seq_along(NAMES)) {
[16:03:18.676]                   name <- added[[kk]]
[16:03:18.676]                   NAME <- NAMES[[kk]]
[16:03:18.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.676]                     next
[16:03:18.676]                   args[[name]] <- ""
[16:03:18.676]                 }
[16:03:18.676]                 NAMES <- toupper(removed)
[16:03:18.676]                 for (kk in seq_along(NAMES)) {
[16:03:18.676]                   name <- removed[[kk]]
[16:03:18.676]                   NAME <- NAMES[[kk]]
[16:03:18.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.676]                     next
[16:03:18.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:18.676]                 }
[16:03:18.676]                 if (length(args) > 0) 
[16:03:18.676]                   base::do.call(base::Sys.setenv, args = args)
[16:03:18.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:18.676]             }
[16:03:18.676]             else {
[16:03:18.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:18.676]             }
[16:03:18.676]             {
[16:03:18.676]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:18.676]                   0L) {
[16:03:18.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:18.676]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:18.676]                   base::options(opts)
[16:03:18.676]                 }
[16:03:18.676]                 {
[16:03:18.676]                   {
[16:03:18.676]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:18.676]                     NULL
[16:03:18.676]                   }
[16:03:18.676]                   options(future.plan = NULL)
[16:03:18.676]                   if (is.na(NA_character_)) 
[16:03:18.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:18.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:18.676]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:18.676]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:18.676]                     envir = parent.frame()) 
[16:03:18.676]                   {
[16:03:18.676]                     if (is.function(workers)) 
[16:03:18.676]                       workers <- workers()
[16:03:18.676]                     workers <- structure(as.integer(workers), 
[16:03:18.676]                       class = class(workers))
[16:03:18.676]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:18.676]                       workers >= 1)
[16:03:18.676]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:18.676]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:18.676]                     }
[16:03:18.676]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:18.676]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:18.676]                       envir = envir)
[16:03:18.676]                     if (!future$lazy) 
[16:03:18.676]                       future <- run(future)
[16:03:18.676]                     invisible(future)
[16:03:18.676]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:18.676]                 }
[16:03:18.676]             }
[16:03:18.676]         }
[16:03:18.676]     })
[16:03:18.676]     if (TRUE) {
[16:03:18.676]         base::sink(type = "output", split = FALSE)
[16:03:18.676]         if (TRUE) {
[16:03:18.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:18.676]         }
[16:03:18.676]         else {
[16:03:18.676]             ...future.result["stdout"] <- base::list(NULL)
[16:03:18.676]         }
[16:03:18.676]         base::close(...future.stdout)
[16:03:18.676]         ...future.stdout <- NULL
[16:03:18.676]     }
[16:03:18.676]     ...future.result$conditions <- ...future.conditions
[16:03:18.676]     ...future.result$finished <- base::Sys.time()
[16:03:18.676]     ...future.result
[16:03:18.676] }
[16:03:18.679] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[16:03:18.679] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:18.723] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:18.724] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[16:03:18.724] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[16:03:18.724] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:18.725] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:18.725] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:18.767] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:18.767] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:18.811] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:18.811] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:03:18.812] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:03:18.812] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:03:18.812] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:03:18.813] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:18.813] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:18.813] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:03:18.813] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:03:18.814] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:18.814] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:18.814] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:18.814] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:18.815] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[16:03:18.815] MultisessionFuture started
[16:03:18.815] - Launch lazy future ... done
[16:03:18.815] run() for ‘MultisessionFuture’ ... done
[16:03:18.816] Created future:
[16:03:18.816] MultisessionFuture:
[16:03:18.816] Label: ‘future_vapply-1’
[16:03:18.816] Expression:
[16:03:18.816] {
[16:03:18.816]     do.call(function(...) {
[16:03:18.816]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.816]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:18.816]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.816]             on.exit(options(oopts), add = TRUE)
[16:03:18.816]         }
[16:03:18.816]         {
[16:03:18.816]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:18.816]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.816]                 ...future.FUN(...future.X_jj, ...)
[16:03:18.816]             })
[16:03:18.816]         }
[16:03:18.816]     }, args = future.call.arguments)
[16:03:18.816] }
[16:03:18.816] Lazy evaluation: FALSE
[16:03:18.816] Asynchronous evaluation: TRUE
[16:03:18.816] Local evaluation: TRUE
[16:03:18.816] Environment: R_GlobalEnv
[16:03:18.816] Capture standard output: TRUE
[16:03:18.816] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:18.816] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:18.816] Packages: 1 packages (‘future.apply’)
[16:03:18.816] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:18.816] Resolved: FALSE
[16:03:18.816] Value: <not collected>
[16:03:18.816] Conditions captured: <none>
[16:03:18.816] Early signaling: FALSE
[16:03:18.816] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:18.816] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:18.827] Chunk #1 of 2 ... DONE
[16:03:18.828] Chunk #2 of 2 ...
[16:03:18.828]  - Finding globals in 'X' for chunk #2 ...
[16:03:18.828] getGlobalsAndPackages() ...
[16:03:18.828] Searching for globals...
[16:03:18.828] 
[16:03:18.828] Searching for globals ... DONE
[16:03:18.828] - globals: [0] <none>
[16:03:18.829] getGlobalsAndPackages() ... DONE
[16:03:18.829]    + additional globals found: [n=0] 
[16:03:18.829]    + additional namespaces needed: [n=0] 
[16:03:18.829]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:18.829]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:18.829]  - seeds: <none>
[16:03:18.829]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.829] getGlobalsAndPackages() ...
[16:03:18.829] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.829] Resolving globals: FALSE
[16:03:18.830] Tweak future expression to call with '...' arguments ...
[16:03:18.830] {
[16:03:18.830]     do.call(function(...) {
[16:03:18.830]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.830]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:18.830]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.830]             on.exit(options(oopts), add = TRUE)
[16:03:18.830]         }
[16:03:18.830]         {
[16:03:18.830]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:18.830]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.830]                 ...future.FUN(...future.X_jj, ...)
[16:03:18.830]             })
[16:03:18.830]         }
[16:03:18.830]     }, args = future.call.arguments)
[16:03:18.830] }
[16:03:18.830] Tweak future expression to call with '...' arguments ... DONE
[16:03:18.830] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:18.831] - packages: [1] ‘future.apply’
[16:03:18.831] getGlobalsAndPackages() ... DONE
[16:03:18.831] run() for ‘Future’ ...
[16:03:18.831] - state: ‘created’
[16:03:18.831] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:18.845] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:18.845] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:18.845]   - Field: ‘node’
[16:03:18.845]   - Field: ‘label’
[16:03:18.846]   - Field: ‘local’
[16:03:18.846]   - Field: ‘owner’
[16:03:18.846]   - Field: ‘envir’
[16:03:18.846]   - Field: ‘workers’
[16:03:18.846]   - Field: ‘packages’
[16:03:18.846]   - Field: ‘gc’
[16:03:18.846]   - Field: ‘conditions’
[16:03:18.846]   - Field: ‘persistent’
[16:03:18.846]   - Field: ‘expr’
[16:03:18.846]   - Field: ‘uuid’
[16:03:18.847]   - Field: ‘seed’
[16:03:18.847]   - Field: ‘version’
[16:03:18.847]   - Field: ‘result’
[16:03:18.847]   - Field: ‘asynchronous’
[16:03:18.847]   - Field: ‘calls’
[16:03:18.847]   - Field: ‘globals’
[16:03:18.847]   - Field: ‘stdout’
[16:03:18.847]   - Field: ‘earlySignal’
[16:03:18.847]   - Field: ‘lazy’
[16:03:18.847]   - Field: ‘state’
[16:03:18.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:18.848] - Launch lazy future ...
[16:03:18.848] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:18.848] Packages needed by future strategies (n = 0): <none>
[16:03:18.849] {
[16:03:18.849]     {
[16:03:18.849]         {
[16:03:18.849]             ...future.startTime <- base::Sys.time()
[16:03:18.849]             {
[16:03:18.849]                 {
[16:03:18.849]                   {
[16:03:18.849]                     {
[16:03:18.849]                       {
[16:03:18.849]                         base::local({
[16:03:18.849]                           has_future <- base::requireNamespace("future", 
[16:03:18.849]                             quietly = TRUE)
[16:03:18.849]                           if (has_future) {
[16:03:18.849]                             ns <- base::getNamespace("future")
[16:03:18.849]                             version <- ns[[".package"]][["version"]]
[16:03:18.849]                             if (is.null(version)) 
[16:03:18.849]                               version <- utils::packageVersion("future")
[16:03:18.849]                           }
[16:03:18.849]                           else {
[16:03:18.849]                             version <- NULL
[16:03:18.849]                           }
[16:03:18.849]                           if (!has_future || version < "1.8.0") {
[16:03:18.849]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:18.849]                               "", base::R.version$version.string), 
[16:03:18.849]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:18.849]                                 base::R.version$platform, 8 * 
[16:03:18.849]                                   base::.Machine$sizeof.pointer), 
[16:03:18.849]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:18.849]                                 "release", "version")], collapse = " "), 
[16:03:18.849]                               hostname = base::Sys.info()[["nodename"]])
[16:03:18.849]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:18.849]                               info)
[16:03:18.849]                             info <- base::paste(info, collapse = "; ")
[16:03:18.849]                             if (!has_future) {
[16:03:18.849]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:18.849]                                 info)
[16:03:18.849]                             }
[16:03:18.849]                             else {
[16:03:18.849]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:18.849]                                 info, version)
[16:03:18.849]                             }
[16:03:18.849]                             base::stop(msg)
[16:03:18.849]                           }
[16:03:18.849]                         })
[16:03:18.849]                       }
[16:03:18.849]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:18.849]                       base::options(mc.cores = 1L)
[16:03:18.849]                     }
[16:03:18.849]                     base::local({
[16:03:18.849]                       for (pkg in "future.apply") {
[16:03:18.849]                         base::loadNamespace(pkg)
[16:03:18.849]                         base::library(pkg, character.only = TRUE)
[16:03:18.849]                       }
[16:03:18.849]                     })
[16:03:18.849]                   }
[16:03:18.849]                   options(future.plan = NULL)
[16:03:18.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:18.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:18.849]                 }
[16:03:18.849]                 ...future.workdir <- getwd()
[16:03:18.849]             }
[16:03:18.849]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:18.849]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:18.849]         }
[16:03:18.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:18.849]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:18.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:18.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:18.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:18.849]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:18.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:18.849]             base::names(...future.oldOptions))
[16:03:18.849]     }
[16:03:18.849]     if (FALSE) {
[16:03:18.849]     }
[16:03:18.849]     else {
[16:03:18.849]         if (TRUE) {
[16:03:18.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:18.849]                 open = "w")
[16:03:18.849]         }
[16:03:18.849]         else {
[16:03:18.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:18.849]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:18.849]         }
[16:03:18.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:18.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:18.849]             base::sink(type = "output", split = FALSE)
[16:03:18.849]             base::close(...future.stdout)
[16:03:18.849]         }, add = TRUE)
[16:03:18.849]     }
[16:03:18.849]     ...future.frame <- base::sys.nframe()
[16:03:18.849]     ...future.conditions <- base::list()
[16:03:18.849]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:18.849]     if (FALSE) {
[16:03:18.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:18.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:18.849]     }
[16:03:18.849]     ...future.result <- base::tryCatch({
[16:03:18.849]         base::withCallingHandlers({
[16:03:18.849]             ...future.value <- base::withVisible(base::local({
[16:03:18.849]                 ...future.makeSendCondition <- base::local({
[16:03:18.849]                   sendCondition <- NULL
[16:03:18.849]                   function(frame = 1L) {
[16:03:18.849]                     if (is.function(sendCondition)) 
[16:03:18.849]                       return(sendCondition)
[16:03:18.849]                     ns <- getNamespace("parallel")
[16:03:18.849]                     if (exists("sendData", mode = "function", 
[16:03:18.849]                       envir = ns)) {
[16:03:18.849]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:18.849]                         envir = ns)
[16:03:18.849]                       envir <- sys.frame(frame)
[16:03:18.849]                       master <- NULL
[16:03:18.849]                       while (!identical(envir, .GlobalEnv) && 
[16:03:18.849]                         !identical(envir, emptyenv())) {
[16:03:18.849]                         if (exists("master", mode = "list", envir = envir, 
[16:03:18.849]                           inherits = FALSE)) {
[16:03:18.849]                           master <- get("master", mode = "list", 
[16:03:18.849]                             envir = envir, inherits = FALSE)
[16:03:18.849]                           if (inherits(master, c("SOCKnode", 
[16:03:18.849]                             "SOCK0node"))) {
[16:03:18.849]                             sendCondition <<- function(cond) {
[16:03:18.849]                               data <- list(type = "VALUE", value = cond, 
[16:03:18.849]                                 success = TRUE)
[16:03:18.849]                               parallel_sendData(master, data)
[16:03:18.849]                             }
[16:03:18.849]                             return(sendCondition)
[16:03:18.849]                           }
[16:03:18.849]                         }
[16:03:18.849]                         frame <- frame + 1L
[16:03:18.849]                         envir <- sys.frame(frame)
[16:03:18.849]                       }
[16:03:18.849]                     }
[16:03:18.849]                     sendCondition <<- function(cond) NULL
[16:03:18.849]                   }
[16:03:18.849]                 })
[16:03:18.849]                 withCallingHandlers({
[16:03:18.849]                   {
[16:03:18.849]                     do.call(function(...) {
[16:03:18.849]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.849]                       if (!identical(...future.globals.maxSize.org, 
[16:03:18.849]                         ...future.globals.maxSize)) {
[16:03:18.849]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.849]                         on.exit(options(oopts), add = TRUE)
[16:03:18.849]                       }
[16:03:18.849]                       {
[16:03:18.849]                         lapply(seq_along(...future.elements_ii), 
[16:03:18.849]                           FUN = function(jj) {
[16:03:18.849]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.849]                             ...future.FUN(...future.X_jj, ...)
[16:03:18.849]                           })
[16:03:18.849]                       }
[16:03:18.849]                     }, args = future.call.arguments)
[16:03:18.849]                   }
[16:03:18.849]                 }, immediateCondition = function(cond) {
[16:03:18.849]                   sendCondition <- ...future.makeSendCondition()
[16:03:18.849]                   sendCondition(cond)
[16:03:18.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.849]                   {
[16:03:18.849]                     inherits <- base::inherits
[16:03:18.849]                     invokeRestart <- base::invokeRestart
[16:03:18.849]                     is.null <- base::is.null
[16:03:18.849]                     muffled <- FALSE
[16:03:18.849]                     if (inherits(cond, "message")) {
[16:03:18.849]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:18.849]                       if (muffled) 
[16:03:18.849]                         invokeRestart("muffleMessage")
[16:03:18.849]                     }
[16:03:18.849]                     else if (inherits(cond, "warning")) {
[16:03:18.849]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:18.849]                       if (muffled) 
[16:03:18.849]                         invokeRestart("muffleWarning")
[16:03:18.849]                     }
[16:03:18.849]                     else if (inherits(cond, "condition")) {
[16:03:18.849]                       if (!is.null(pattern)) {
[16:03:18.849]                         computeRestarts <- base::computeRestarts
[16:03:18.849]                         grepl <- base::grepl
[16:03:18.849]                         restarts <- computeRestarts(cond)
[16:03:18.849]                         for (restart in restarts) {
[16:03:18.849]                           name <- restart$name
[16:03:18.849]                           if (is.null(name)) 
[16:03:18.849]                             next
[16:03:18.849]                           if (!grepl(pattern, name)) 
[16:03:18.849]                             next
[16:03:18.849]                           invokeRestart(restart)
[16:03:18.849]                           muffled <- TRUE
[16:03:18.849]                           break
[16:03:18.849]                         }
[16:03:18.849]                       }
[16:03:18.849]                     }
[16:03:18.849]                     invisible(muffled)
[16:03:18.849]                   }
[16:03:18.849]                   muffleCondition(cond)
[16:03:18.849]                 })
[16:03:18.849]             }))
[16:03:18.849]             future::FutureResult(value = ...future.value$value, 
[16:03:18.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:18.849]                   ...future.rng), globalenv = if (FALSE) 
[16:03:18.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:18.849]                     ...future.globalenv.names))
[16:03:18.849]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:18.849]         }, condition = base::local({
[16:03:18.849]             c <- base::c
[16:03:18.849]             inherits <- base::inherits
[16:03:18.849]             invokeRestart <- base::invokeRestart
[16:03:18.849]             length <- base::length
[16:03:18.849]             list <- base::list
[16:03:18.849]             seq.int <- base::seq.int
[16:03:18.849]             signalCondition <- base::signalCondition
[16:03:18.849]             sys.calls <- base::sys.calls
[16:03:18.849]             `[[` <- base::`[[`
[16:03:18.849]             `+` <- base::`+`
[16:03:18.849]             `<<-` <- base::`<<-`
[16:03:18.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:18.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:18.849]                   3L)]
[16:03:18.849]             }
[16:03:18.849]             function(cond) {
[16:03:18.849]                 is_error <- inherits(cond, "error")
[16:03:18.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:18.849]                   NULL)
[16:03:18.849]                 if (is_error) {
[16:03:18.849]                   sessionInformation <- function() {
[16:03:18.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:18.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:18.849]                       search = base::search(), system = base::Sys.info())
[16:03:18.849]                   }
[16:03:18.849]                   ...future.conditions[[length(...future.conditions) + 
[16:03:18.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:18.849]                     cond$call), session = sessionInformation(), 
[16:03:18.849]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:18.849]                   signalCondition(cond)
[16:03:18.849]                 }
[16:03:18.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:18.849]                 "immediateCondition"))) {
[16:03:18.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:18.849]                   ...future.conditions[[length(...future.conditions) + 
[16:03:18.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:18.849]                   if (TRUE && !signal) {
[16:03:18.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.849]                     {
[16:03:18.849]                       inherits <- base::inherits
[16:03:18.849]                       invokeRestart <- base::invokeRestart
[16:03:18.849]                       is.null <- base::is.null
[16:03:18.849]                       muffled <- FALSE
[16:03:18.849]                       if (inherits(cond, "message")) {
[16:03:18.849]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:18.849]                         if (muffled) 
[16:03:18.849]                           invokeRestart("muffleMessage")
[16:03:18.849]                       }
[16:03:18.849]                       else if (inherits(cond, "warning")) {
[16:03:18.849]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:18.849]                         if (muffled) 
[16:03:18.849]                           invokeRestart("muffleWarning")
[16:03:18.849]                       }
[16:03:18.849]                       else if (inherits(cond, "condition")) {
[16:03:18.849]                         if (!is.null(pattern)) {
[16:03:18.849]                           computeRestarts <- base::computeRestarts
[16:03:18.849]                           grepl <- base::grepl
[16:03:18.849]                           restarts <- computeRestarts(cond)
[16:03:18.849]                           for (restart in restarts) {
[16:03:18.849]                             name <- restart$name
[16:03:18.849]                             if (is.null(name)) 
[16:03:18.849]                               next
[16:03:18.849]                             if (!grepl(pattern, name)) 
[16:03:18.849]                               next
[16:03:18.849]                             invokeRestart(restart)
[16:03:18.849]                             muffled <- TRUE
[16:03:18.849]                             break
[16:03:18.849]                           }
[16:03:18.849]                         }
[16:03:18.849]                       }
[16:03:18.849]                       invisible(muffled)
[16:03:18.849]                     }
[16:03:18.849]                     muffleCondition(cond, pattern = "^muffle")
[16:03:18.849]                   }
[16:03:18.849]                 }
[16:03:18.849]                 else {
[16:03:18.849]                   if (TRUE) {
[16:03:18.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:18.849]                     {
[16:03:18.849]                       inherits <- base::inherits
[16:03:18.849]                       invokeRestart <- base::invokeRestart
[16:03:18.849]                       is.null <- base::is.null
[16:03:18.849]                       muffled <- FALSE
[16:03:18.849]                       if (inherits(cond, "message")) {
[16:03:18.849]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:18.849]                         if (muffled) 
[16:03:18.849]                           invokeRestart("muffleMessage")
[16:03:18.849]                       }
[16:03:18.849]                       else if (inherits(cond, "warning")) {
[16:03:18.849]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:18.849]                         if (muffled) 
[16:03:18.849]                           invokeRestart("muffleWarning")
[16:03:18.849]                       }
[16:03:18.849]                       else if (inherits(cond, "condition")) {
[16:03:18.849]                         if (!is.null(pattern)) {
[16:03:18.849]                           computeRestarts <- base::computeRestarts
[16:03:18.849]                           grepl <- base::grepl
[16:03:18.849]                           restarts <- computeRestarts(cond)
[16:03:18.849]                           for (restart in restarts) {
[16:03:18.849]                             name <- restart$name
[16:03:18.849]                             if (is.null(name)) 
[16:03:18.849]                               next
[16:03:18.849]                             if (!grepl(pattern, name)) 
[16:03:18.849]                               next
[16:03:18.849]                             invokeRestart(restart)
[16:03:18.849]                             muffled <- TRUE
[16:03:18.849]                             break
[16:03:18.849]                           }
[16:03:18.849]                         }
[16:03:18.849]                       }
[16:03:18.849]                       invisible(muffled)
[16:03:18.849]                     }
[16:03:18.849]                     muffleCondition(cond, pattern = "^muffle")
[16:03:18.849]                   }
[16:03:18.849]                 }
[16:03:18.849]             }
[16:03:18.849]         }))
[16:03:18.849]     }, error = function(ex) {
[16:03:18.849]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:18.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:18.849]                 ...future.rng), started = ...future.startTime, 
[16:03:18.849]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:18.849]             version = "1.8"), class = "FutureResult")
[16:03:18.849]     }, finally = {
[16:03:18.849]         if (!identical(...future.workdir, getwd())) 
[16:03:18.849]             setwd(...future.workdir)
[16:03:18.849]         {
[16:03:18.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:18.849]                 ...future.oldOptions$nwarnings <- NULL
[16:03:18.849]             }
[16:03:18.849]             base::options(...future.oldOptions)
[16:03:18.849]             if (.Platform$OS.type == "windows") {
[16:03:18.849]                 old_names <- names(...future.oldEnvVars)
[16:03:18.849]                 envs <- base::Sys.getenv()
[16:03:18.849]                 names <- names(envs)
[16:03:18.849]                 common <- intersect(names, old_names)
[16:03:18.849]                 added <- setdiff(names, old_names)
[16:03:18.849]                 removed <- setdiff(old_names, names)
[16:03:18.849]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:18.849]                   envs[common]]
[16:03:18.849]                 NAMES <- toupper(changed)
[16:03:18.849]                 args <- list()
[16:03:18.849]                 for (kk in seq_along(NAMES)) {
[16:03:18.849]                   name <- changed[[kk]]
[16:03:18.849]                   NAME <- NAMES[[kk]]
[16:03:18.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.849]                     next
[16:03:18.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:18.849]                 }
[16:03:18.849]                 NAMES <- toupper(added)
[16:03:18.849]                 for (kk in seq_along(NAMES)) {
[16:03:18.849]                   name <- added[[kk]]
[16:03:18.849]                   NAME <- NAMES[[kk]]
[16:03:18.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.849]                     next
[16:03:18.849]                   args[[name]] <- ""
[16:03:18.849]                 }
[16:03:18.849]                 NAMES <- toupper(removed)
[16:03:18.849]                 for (kk in seq_along(NAMES)) {
[16:03:18.849]                   name <- removed[[kk]]
[16:03:18.849]                   NAME <- NAMES[[kk]]
[16:03:18.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:18.849]                     next
[16:03:18.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:18.849]                 }
[16:03:18.849]                 if (length(args) > 0) 
[16:03:18.849]                   base::do.call(base::Sys.setenv, args = args)
[16:03:18.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:18.849]             }
[16:03:18.849]             else {
[16:03:18.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:18.849]             }
[16:03:18.849]             {
[16:03:18.849]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:18.849]                   0L) {
[16:03:18.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:18.849]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:18.849]                   base::options(opts)
[16:03:18.849]                 }
[16:03:18.849]                 {
[16:03:18.849]                   {
[16:03:18.849]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:18.849]                     NULL
[16:03:18.849]                   }
[16:03:18.849]                   options(future.plan = NULL)
[16:03:18.849]                   if (is.na(NA_character_)) 
[16:03:18.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:18.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:18.849]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:18.849]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:18.849]                     envir = parent.frame()) 
[16:03:18.849]                   {
[16:03:18.849]                     if (is.function(workers)) 
[16:03:18.849]                       workers <- workers()
[16:03:18.849]                     workers <- structure(as.integer(workers), 
[16:03:18.849]                       class = class(workers))
[16:03:18.849]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:18.849]                       workers >= 1)
[16:03:18.849]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:18.849]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:18.849]                     }
[16:03:18.849]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:18.849]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:18.849]                       envir = envir)
[16:03:18.849]                     if (!future$lazy) 
[16:03:18.849]                       future <- run(future)
[16:03:18.849]                     invisible(future)
[16:03:18.849]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:18.849]                 }
[16:03:18.849]             }
[16:03:18.849]         }
[16:03:18.849]     })
[16:03:18.849]     if (TRUE) {
[16:03:18.849]         base::sink(type = "output", split = FALSE)
[16:03:18.849]         if (TRUE) {
[16:03:18.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:18.849]         }
[16:03:18.849]         else {
[16:03:18.849]             ...future.result["stdout"] <- base::list(NULL)
[16:03:18.849]         }
[16:03:18.849]         base::close(...future.stdout)
[16:03:18.849]         ...future.stdout <- NULL
[16:03:18.849]     }
[16:03:18.849]     ...future.result$conditions <- ...future.conditions
[16:03:18.849]     ...future.result$finished <- base::Sys.time()
[16:03:18.849]     ...future.result
[16:03:18.849] }
[16:03:18.851] Exporting 11 global objects (95.02 KiB) to cluster node #2 ...
[16:03:18.852] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:18.895] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:18.895] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[16:03:18.896] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[16:03:18.896] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:18.896] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:18.896] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:18.939] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:18.939] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:18.983] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:18.983] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[16:03:18.984] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[16:03:18.984] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:03:18.984] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:03:18.984] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:18.985] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:18.985] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:03:18.985] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:03:18.985] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:18.986] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:18.986] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:18.986] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:18.986] Exporting 11 global objects (95.02 KiB) to cluster node #2 ... DONE
[16:03:18.987] MultisessionFuture started
[16:03:18.987] - Launch lazy future ... done
[16:03:18.987] run() for ‘MultisessionFuture’ ... done
[16:03:18.987] Created future:
[16:03:18.987] MultisessionFuture:
[16:03:18.987] Label: ‘future_vapply-2’
[16:03:18.987] Expression:
[16:03:18.987] {
[16:03:18.987]     do.call(function(...) {
[16:03:18.987]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:18.987]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:18.987]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:18.987]             on.exit(options(oopts), add = TRUE)
[16:03:18.987]         }
[16:03:18.987]         {
[16:03:18.987]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:18.987]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:18.987]                 ...future.FUN(...future.X_jj, ...)
[16:03:18.987]             })
[16:03:18.987]         }
[16:03:18.987]     }, args = future.call.arguments)
[16:03:18.987] }
[16:03:18.987] Lazy evaluation: FALSE
[16:03:18.987] Asynchronous evaluation: TRUE
[16:03:18.987] Local evaluation: TRUE
[16:03:18.987] Environment: R_GlobalEnv
[16:03:18.987] Capture standard output: TRUE
[16:03:18.987] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:18.987] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:18.987] Packages: 1 packages (‘future.apply’)
[16:03:18.987] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:18.987] Resolved: FALSE
[16:03:18.987] Value: <not collected>
[16:03:18.987] Conditions captured: <none>
[16:03:18.987] Early signaling: FALSE
[16:03:18.987] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:18.987] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:18.999] Chunk #2 of 2 ... DONE
[16:03:18.999] Launching 2 futures (chunks) ... DONE
[16:03:18.999] Resolving 2 futures (chunks) ...
[16:03:19.000] resolve() on list ...
[16:03:19.000]  recursive: 0
[16:03:19.000]  length: 2
[16:03:19.000] 
[16:03:19.000] receiveMessageFromWorker() for ClusterFuture ...
[16:03:19.000] - Validating connection of MultisessionFuture
[16:03:19.001] - received message: FutureResult
[16:03:19.001] - Received FutureResult
[16:03:19.001] - Erased future from FutureRegistry
[16:03:19.001] result() for ClusterFuture ...
[16:03:19.001] - result already collected: FutureResult
[16:03:19.001] result() for ClusterFuture ... done
[16:03:19.001] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:19.001] Future #1
[16:03:19.001] result() for ClusterFuture ...
[16:03:19.002] - result already collected: FutureResult
[16:03:19.002] result() for ClusterFuture ... done
[16:03:19.002] result() for ClusterFuture ...
[16:03:19.002] - result already collected: FutureResult
[16:03:19.002] result() for ClusterFuture ... done
[16:03:19.002] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:19.002] - nx: 2
[16:03:19.002] - relay: TRUE
[16:03:19.002] - stdout: TRUE
[16:03:19.002] - signal: TRUE
[16:03:19.002] - resignal: FALSE
[16:03:19.002] - force: TRUE
[16:03:19.003] - relayed: [n=2] FALSE, FALSE
[16:03:19.003] - queued futures: [n=2] FALSE, FALSE
[16:03:19.003]  - until=1
[16:03:19.003]  - relaying element #1
[16:03:19.003] result() for ClusterFuture ...
[16:03:19.003] - result already collected: FutureResult
[16:03:19.003] result() for ClusterFuture ... done
[16:03:19.003] result() for ClusterFuture ...
[16:03:19.003] - result already collected: FutureResult
[16:03:19.003] result() for ClusterFuture ... done
[16:03:19.004] result() for ClusterFuture ...
[16:03:19.004] - result already collected: FutureResult
[16:03:19.004] result() for ClusterFuture ... done
[16:03:19.004] result() for ClusterFuture ...
[16:03:19.004] - result already collected: FutureResult
[16:03:19.004] result() for ClusterFuture ... done
[16:03:19.004] - relayed: [n=2] TRUE, FALSE
[16:03:19.004] - queued futures: [n=2] TRUE, FALSE
[16:03:19.004] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:19.004]  length: 1 (resolved future 1)
[16:03:19.046] receiveMessageFromWorker() for ClusterFuture ...
[16:03:19.046] - Validating connection of MultisessionFuture
[16:03:19.046] - received message: FutureResult
[16:03:19.047] - Received FutureResult
[16:03:19.047] - Erased future from FutureRegistry
[16:03:19.047] result() for ClusterFuture ...
[16:03:19.047] - result already collected: FutureResult
[16:03:19.047] result() for ClusterFuture ... done
[16:03:19.047] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:19.047] Future #2
[16:03:19.047] result() for ClusterFuture ...
[16:03:19.047] - result already collected: FutureResult
[16:03:19.047] result() for ClusterFuture ... done
[16:03:19.047] result() for ClusterFuture ...
[16:03:19.048] - result already collected: FutureResult
[16:03:19.048] result() for ClusterFuture ... done
[16:03:19.048] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:19.048] - nx: 2
[16:03:19.048] - relay: TRUE
[16:03:19.048] - stdout: TRUE
[16:03:19.048] - signal: TRUE
[16:03:19.048] - resignal: FALSE
[16:03:19.048] - force: TRUE
[16:03:19.048] - relayed: [n=2] TRUE, FALSE
[16:03:19.048] - queued futures: [n=2] TRUE, FALSE
[16:03:19.049]  - until=2
[16:03:19.049]  - relaying element #2
[16:03:19.049] result() for ClusterFuture ...
[16:03:19.049] - result already collected: FutureResult
[16:03:19.049] result() for ClusterFuture ... done
[16:03:19.049] result() for ClusterFuture ...
[16:03:19.049] - result already collected: FutureResult
[16:03:19.049] result() for ClusterFuture ... done
[16:03:19.049] result() for ClusterFuture ...
[16:03:19.049] - result already collected: FutureResult
[16:03:19.050] result() for ClusterFuture ... done
[16:03:19.050] result() for ClusterFuture ...
[16:03:19.050] - result already collected: FutureResult
[16:03:19.050] result() for ClusterFuture ... done
[16:03:19.050] - relayed: [n=2] TRUE, TRUE
[16:03:19.050] - queued futures: [n=2] TRUE, TRUE
[16:03:19.050] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:19.050]  length: 0 (resolved future 2)
[16:03:19.050] Relaying remaining futures
[16:03:19.050] signalConditionsASAP(NULL, pos=0) ...
[16:03:19.050] - nx: 2
[16:03:19.050] - relay: TRUE
[16:03:19.051] - stdout: TRUE
[16:03:19.051] - signal: TRUE
[16:03:19.051] - resignal: FALSE
[16:03:19.051] - force: TRUE
[16:03:19.051] - relayed: [n=2] TRUE, TRUE
[16:03:19.051] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:19.051] - relayed: [n=2] TRUE, TRUE
[16:03:19.051] - queued futures: [n=2] TRUE, TRUE
[16:03:19.051] signalConditionsASAP(NULL, pos=0) ... done
[16:03:19.051] resolve() on list ... DONE
[16:03:19.051] result() for ClusterFuture ...
[16:03:19.052] - result already collected: FutureResult
[16:03:19.052] result() for ClusterFuture ... done
[16:03:19.052] result() for ClusterFuture ...
[16:03:19.052] - result already collected: FutureResult
[16:03:19.052] result() for ClusterFuture ... done
[16:03:19.052] result() for ClusterFuture ...
[16:03:19.052] - result already collected: FutureResult
[16:03:19.052] result() for ClusterFuture ... done
[16:03:19.052] result() for ClusterFuture ...
[16:03:19.052] - result already collected: FutureResult
[16:03:19.052] result() for ClusterFuture ... done
[16:03:19.053]  - Number of value chunks collected: 2
[16:03:19.053] Resolving 2 futures (chunks) ... DONE
[16:03:19.053] Reducing values from 2 chunks ...
[16:03:19.053]  - Number of values collected after concatenation: 10
[16:03:19.053]  - Number of values expected: 10
[16:03:19.053] Reducing values from 2 chunks ... DONE
[16:03:19.053] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[16:03:19.055] future_lapply() ...
[16:03:19.060] Number of chunks: 2
[16:03:19.061] getGlobalsAndPackagesXApply() ...
[16:03:19.061]  - future.globals: TRUE
[16:03:19.061] getGlobalsAndPackages() ...
[16:03:19.061] Searching for globals...
[16:03:19.067] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[16:03:19.067] Searching for globals ... DONE
[16:03:19.067] Resolving globals: FALSE
[16:03:19.068] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[16:03:19.069] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:19.069] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:19.069] - packages: [1] ‘future.apply’
[16:03:19.069] getGlobalsAndPackages() ... DONE
[16:03:19.069]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:19.069]  - needed namespaces: [n=1] ‘future.apply’
[16:03:19.069] Finding globals ... DONE
[16:03:19.069]  - use_args: TRUE
[16:03:19.069]  - Getting '...' globals ...
[16:03:19.070] resolve() on list ...
[16:03:19.070]  recursive: 0
[16:03:19.070]  length: 1
[16:03:19.070]  elements: ‘...’
[16:03:19.070]  length: 0 (resolved future 1)
[16:03:19.070] resolve() on list ... DONE
[16:03:19.070]    - '...' content: [n=0] 
[16:03:19.070] List of 1
[16:03:19.070]  $ ...: list()
[16:03:19.070]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:19.070]  - attr(*, "where")=List of 1
[16:03:19.070]   ..$ ...:<environment: 0x564e44768948> 
[16:03:19.070]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:19.070]  - attr(*, "resolved")= logi TRUE
[16:03:19.070]  - attr(*, "total_size")= num NA
[16:03:19.073]  - Getting '...' globals ... DONE
[16:03:19.073] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:19.073] List of 8
[16:03:19.073]  $ ...future.FUN:function (x, ...)  
[16:03:19.073]  $ x_FUN        :function (x)  
[16:03:19.073]  $ times        : int 4
[16:03:19.073]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:19.073]  $ stop_if_not  :function (...)  
[16:03:19.073]  $ dim          : int [1:2] 2 2
[16:03:19.073]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:19.073]  $ ...          : list()
[16:03:19.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:19.073]  - attr(*, "where")=List of 8
[16:03:19.073]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:19.073]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:19.073]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:19.073]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:19.073]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:19.073]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:19.073]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:19.073]   ..$ ...          :<environment: 0x564e44768948> 
[16:03:19.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:19.073]  - attr(*, "resolved")= logi FALSE
[16:03:19.073]  - attr(*, "total_size")= num 105552
[16:03:19.079] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:19.079] getGlobalsAndPackagesXApply() ... DONE
[16:03:19.079] Number of futures (= number of chunks): 2
[16:03:19.079] Launching 2 futures (chunks) ...
[16:03:19.079] Chunk #1 of 2 ...
[16:03:19.080]  - Finding globals in 'X' for chunk #1 ...
[16:03:19.080] getGlobalsAndPackages() ...
[16:03:19.080] Searching for globals...
[16:03:19.080] 
[16:03:19.080] Searching for globals ... DONE
[16:03:19.080] - globals: [0] <none>
[16:03:19.080] getGlobalsAndPackages() ... DONE
[16:03:19.080]    + additional globals found: [n=0] 
[16:03:19.081]    + additional namespaces needed: [n=0] 
[16:03:19.081]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:19.081]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:19.081]  - seeds: <none>
[16:03:19.081]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.081] getGlobalsAndPackages() ...
[16:03:19.081] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.081] Resolving globals: FALSE
[16:03:19.081] Tweak future expression to call with '...' arguments ...
[16:03:19.081] {
[16:03:19.081]     do.call(function(...) {
[16:03:19.081]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.081]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:19.081]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.081]             on.exit(options(oopts), add = TRUE)
[16:03:19.081]         }
[16:03:19.081]         {
[16:03:19.081]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:19.081]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.081]                 ...future.FUN(...future.X_jj, ...)
[16:03:19.081]             })
[16:03:19.081]         }
[16:03:19.081]     }, args = future.call.arguments)
[16:03:19.081] }
[16:03:19.082] Tweak future expression to call with '...' arguments ... DONE
[16:03:19.082] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.082] - packages: [1] ‘future.apply’
[16:03:19.082] getGlobalsAndPackages() ... DONE
[16:03:19.083] run() for ‘Future’ ...
[16:03:19.083] - state: ‘created’
[16:03:19.083] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:19.097] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:19.097] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:19.097]   - Field: ‘node’
[16:03:19.097]   - Field: ‘label’
[16:03:19.097]   - Field: ‘local’
[16:03:19.097]   - Field: ‘owner’
[16:03:19.097]   - Field: ‘envir’
[16:03:19.097]   - Field: ‘workers’
[16:03:19.097]   - Field: ‘packages’
[16:03:19.097]   - Field: ‘gc’
[16:03:19.098]   - Field: ‘conditions’
[16:03:19.098]   - Field: ‘persistent’
[16:03:19.098]   - Field: ‘expr’
[16:03:19.098]   - Field: ‘uuid’
[16:03:19.098]   - Field: ‘seed’
[16:03:19.098]   - Field: ‘version’
[16:03:19.098]   - Field: ‘result’
[16:03:19.098]   - Field: ‘asynchronous’
[16:03:19.098]   - Field: ‘calls’
[16:03:19.098]   - Field: ‘globals’
[16:03:19.098]   - Field: ‘stdout’
[16:03:19.099]   - Field: ‘earlySignal’
[16:03:19.099]   - Field: ‘lazy’
[16:03:19.099]   - Field: ‘state’
[16:03:19.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:19.099] - Launch lazy future ...
[16:03:19.099] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:19.099] Packages needed by future strategies (n = 0): <none>
[16:03:19.100] {
[16:03:19.100]     {
[16:03:19.100]         {
[16:03:19.100]             ...future.startTime <- base::Sys.time()
[16:03:19.100]             {
[16:03:19.100]                 {
[16:03:19.100]                   {
[16:03:19.100]                     {
[16:03:19.100]                       {
[16:03:19.100]                         base::local({
[16:03:19.100]                           has_future <- base::requireNamespace("future", 
[16:03:19.100]                             quietly = TRUE)
[16:03:19.100]                           if (has_future) {
[16:03:19.100]                             ns <- base::getNamespace("future")
[16:03:19.100]                             version <- ns[[".package"]][["version"]]
[16:03:19.100]                             if (is.null(version)) 
[16:03:19.100]                               version <- utils::packageVersion("future")
[16:03:19.100]                           }
[16:03:19.100]                           else {
[16:03:19.100]                             version <- NULL
[16:03:19.100]                           }
[16:03:19.100]                           if (!has_future || version < "1.8.0") {
[16:03:19.100]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:19.100]                               "", base::R.version$version.string), 
[16:03:19.100]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:19.100]                                 base::R.version$platform, 8 * 
[16:03:19.100]                                   base::.Machine$sizeof.pointer), 
[16:03:19.100]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:19.100]                                 "release", "version")], collapse = " "), 
[16:03:19.100]                               hostname = base::Sys.info()[["nodename"]])
[16:03:19.100]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:19.100]                               info)
[16:03:19.100]                             info <- base::paste(info, collapse = "; ")
[16:03:19.100]                             if (!has_future) {
[16:03:19.100]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:19.100]                                 info)
[16:03:19.100]                             }
[16:03:19.100]                             else {
[16:03:19.100]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:19.100]                                 info, version)
[16:03:19.100]                             }
[16:03:19.100]                             base::stop(msg)
[16:03:19.100]                           }
[16:03:19.100]                         })
[16:03:19.100]                       }
[16:03:19.100]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:19.100]                       base::options(mc.cores = 1L)
[16:03:19.100]                     }
[16:03:19.100]                     base::local({
[16:03:19.100]                       for (pkg in "future.apply") {
[16:03:19.100]                         base::loadNamespace(pkg)
[16:03:19.100]                         base::library(pkg, character.only = TRUE)
[16:03:19.100]                       }
[16:03:19.100]                     })
[16:03:19.100]                   }
[16:03:19.100]                   options(future.plan = NULL)
[16:03:19.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:19.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:19.100]                 }
[16:03:19.100]                 ...future.workdir <- getwd()
[16:03:19.100]             }
[16:03:19.100]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:19.100]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:19.100]         }
[16:03:19.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:19.100]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:19.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:19.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:19.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:19.100]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:19.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:19.100]             base::names(...future.oldOptions))
[16:03:19.100]     }
[16:03:19.100]     if (FALSE) {
[16:03:19.100]     }
[16:03:19.100]     else {
[16:03:19.100]         if (TRUE) {
[16:03:19.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:19.100]                 open = "w")
[16:03:19.100]         }
[16:03:19.100]         else {
[16:03:19.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:19.100]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:19.100]         }
[16:03:19.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:19.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:19.100]             base::sink(type = "output", split = FALSE)
[16:03:19.100]             base::close(...future.stdout)
[16:03:19.100]         }, add = TRUE)
[16:03:19.100]     }
[16:03:19.100]     ...future.frame <- base::sys.nframe()
[16:03:19.100]     ...future.conditions <- base::list()
[16:03:19.100]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:19.100]     if (FALSE) {
[16:03:19.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:19.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:19.100]     }
[16:03:19.100]     ...future.result <- base::tryCatch({
[16:03:19.100]         base::withCallingHandlers({
[16:03:19.100]             ...future.value <- base::withVisible(base::local({
[16:03:19.100]                 ...future.makeSendCondition <- base::local({
[16:03:19.100]                   sendCondition <- NULL
[16:03:19.100]                   function(frame = 1L) {
[16:03:19.100]                     if (is.function(sendCondition)) 
[16:03:19.100]                       return(sendCondition)
[16:03:19.100]                     ns <- getNamespace("parallel")
[16:03:19.100]                     if (exists("sendData", mode = "function", 
[16:03:19.100]                       envir = ns)) {
[16:03:19.100]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:19.100]                         envir = ns)
[16:03:19.100]                       envir <- sys.frame(frame)
[16:03:19.100]                       master <- NULL
[16:03:19.100]                       while (!identical(envir, .GlobalEnv) && 
[16:03:19.100]                         !identical(envir, emptyenv())) {
[16:03:19.100]                         if (exists("master", mode = "list", envir = envir, 
[16:03:19.100]                           inherits = FALSE)) {
[16:03:19.100]                           master <- get("master", mode = "list", 
[16:03:19.100]                             envir = envir, inherits = FALSE)
[16:03:19.100]                           if (inherits(master, c("SOCKnode", 
[16:03:19.100]                             "SOCK0node"))) {
[16:03:19.100]                             sendCondition <<- function(cond) {
[16:03:19.100]                               data <- list(type = "VALUE", value = cond, 
[16:03:19.100]                                 success = TRUE)
[16:03:19.100]                               parallel_sendData(master, data)
[16:03:19.100]                             }
[16:03:19.100]                             return(sendCondition)
[16:03:19.100]                           }
[16:03:19.100]                         }
[16:03:19.100]                         frame <- frame + 1L
[16:03:19.100]                         envir <- sys.frame(frame)
[16:03:19.100]                       }
[16:03:19.100]                     }
[16:03:19.100]                     sendCondition <<- function(cond) NULL
[16:03:19.100]                   }
[16:03:19.100]                 })
[16:03:19.100]                 withCallingHandlers({
[16:03:19.100]                   {
[16:03:19.100]                     do.call(function(...) {
[16:03:19.100]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.100]                       if (!identical(...future.globals.maxSize.org, 
[16:03:19.100]                         ...future.globals.maxSize)) {
[16:03:19.100]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.100]                         on.exit(options(oopts), add = TRUE)
[16:03:19.100]                       }
[16:03:19.100]                       {
[16:03:19.100]                         lapply(seq_along(...future.elements_ii), 
[16:03:19.100]                           FUN = function(jj) {
[16:03:19.100]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.100]                             ...future.FUN(...future.X_jj, ...)
[16:03:19.100]                           })
[16:03:19.100]                       }
[16:03:19.100]                     }, args = future.call.arguments)
[16:03:19.100]                   }
[16:03:19.100]                 }, immediateCondition = function(cond) {
[16:03:19.100]                   sendCondition <- ...future.makeSendCondition()
[16:03:19.100]                   sendCondition(cond)
[16:03:19.100]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.100]                   {
[16:03:19.100]                     inherits <- base::inherits
[16:03:19.100]                     invokeRestart <- base::invokeRestart
[16:03:19.100]                     is.null <- base::is.null
[16:03:19.100]                     muffled <- FALSE
[16:03:19.100]                     if (inherits(cond, "message")) {
[16:03:19.100]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:19.100]                       if (muffled) 
[16:03:19.100]                         invokeRestart("muffleMessage")
[16:03:19.100]                     }
[16:03:19.100]                     else if (inherits(cond, "warning")) {
[16:03:19.100]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:19.100]                       if (muffled) 
[16:03:19.100]                         invokeRestart("muffleWarning")
[16:03:19.100]                     }
[16:03:19.100]                     else if (inherits(cond, "condition")) {
[16:03:19.100]                       if (!is.null(pattern)) {
[16:03:19.100]                         computeRestarts <- base::computeRestarts
[16:03:19.100]                         grepl <- base::grepl
[16:03:19.100]                         restarts <- computeRestarts(cond)
[16:03:19.100]                         for (restart in restarts) {
[16:03:19.100]                           name <- restart$name
[16:03:19.100]                           if (is.null(name)) 
[16:03:19.100]                             next
[16:03:19.100]                           if (!grepl(pattern, name)) 
[16:03:19.100]                             next
[16:03:19.100]                           invokeRestart(restart)
[16:03:19.100]                           muffled <- TRUE
[16:03:19.100]                           break
[16:03:19.100]                         }
[16:03:19.100]                       }
[16:03:19.100]                     }
[16:03:19.100]                     invisible(muffled)
[16:03:19.100]                   }
[16:03:19.100]                   muffleCondition(cond)
[16:03:19.100]                 })
[16:03:19.100]             }))
[16:03:19.100]             future::FutureResult(value = ...future.value$value, 
[16:03:19.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:19.100]                   ...future.rng), globalenv = if (FALSE) 
[16:03:19.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:19.100]                     ...future.globalenv.names))
[16:03:19.100]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:19.100]         }, condition = base::local({
[16:03:19.100]             c <- base::c
[16:03:19.100]             inherits <- base::inherits
[16:03:19.100]             invokeRestart <- base::invokeRestart
[16:03:19.100]             length <- base::length
[16:03:19.100]             list <- base::list
[16:03:19.100]             seq.int <- base::seq.int
[16:03:19.100]             signalCondition <- base::signalCondition
[16:03:19.100]             sys.calls <- base::sys.calls
[16:03:19.100]             `[[` <- base::`[[`
[16:03:19.100]             `+` <- base::`+`
[16:03:19.100]             `<<-` <- base::`<<-`
[16:03:19.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:19.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:19.100]                   3L)]
[16:03:19.100]             }
[16:03:19.100]             function(cond) {
[16:03:19.100]                 is_error <- inherits(cond, "error")
[16:03:19.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:19.100]                   NULL)
[16:03:19.100]                 if (is_error) {
[16:03:19.100]                   sessionInformation <- function() {
[16:03:19.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:19.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:19.100]                       search = base::search(), system = base::Sys.info())
[16:03:19.100]                   }
[16:03:19.100]                   ...future.conditions[[length(...future.conditions) + 
[16:03:19.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:19.100]                     cond$call), session = sessionInformation(), 
[16:03:19.100]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:19.100]                   signalCondition(cond)
[16:03:19.100]                 }
[16:03:19.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:19.100]                 "immediateCondition"))) {
[16:03:19.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:19.100]                   ...future.conditions[[length(...future.conditions) + 
[16:03:19.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:19.100]                   if (TRUE && !signal) {
[16:03:19.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.100]                     {
[16:03:19.100]                       inherits <- base::inherits
[16:03:19.100]                       invokeRestart <- base::invokeRestart
[16:03:19.100]                       is.null <- base::is.null
[16:03:19.100]                       muffled <- FALSE
[16:03:19.100]                       if (inherits(cond, "message")) {
[16:03:19.100]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:19.100]                         if (muffled) 
[16:03:19.100]                           invokeRestart("muffleMessage")
[16:03:19.100]                       }
[16:03:19.100]                       else if (inherits(cond, "warning")) {
[16:03:19.100]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:19.100]                         if (muffled) 
[16:03:19.100]                           invokeRestart("muffleWarning")
[16:03:19.100]                       }
[16:03:19.100]                       else if (inherits(cond, "condition")) {
[16:03:19.100]                         if (!is.null(pattern)) {
[16:03:19.100]                           computeRestarts <- base::computeRestarts
[16:03:19.100]                           grepl <- base::grepl
[16:03:19.100]                           restarts <- computeRestarts(cond)
[16:03:19.100]                           for (restart in restarts) {
[16:03:19.100]                             name <- restart$name
[16:03:19.100]                             if (is.null(name)) 
[16:03:19.100]                               next
[16:03:19.100]                             if (!grepl(pattern, name)) 
[16:03:19.100]                               next
[16:03:19.100]                             invokeRestart(restart)
[16:03:19.100]                             muffled <- TRUE
[16:03:19.100]                             break
[16:03:19.100]                           }
[16:03:19.100]                         }
[16:03:19.100]                       }
[16:03:19.100]                       invisible(muffled)
[16:03:19.100]                     }
[16:03:19.100]                     muffleCondition(cond, pattern = "^muffle")
[16:03:19.100]                   }
[16:03:19.100]                 }
[16:03:19.100]                 else {
[16:03:19.100]                   if (TRUE) {
[16:03:19.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.100]                     {
[16:03:19.100]                       inherits <- base::inherits
[16:03:19.100]                       invokeRestart <- base::invokeRestart
[16:03:19.100]                       is.null <- base::is.null
[16:03:19.100]                       muffled <- FALSE
[16:03:19.100]                       if (inherits(cond, "message")) {
[16:03:19.100]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:19.100]                         if (muffled) 
[16:03:19.100]                           invokeRestart("muffleMessage")
[16:03:19.100]                       }
[16:03:19.100]                       else if (inherits(cond, "warning")) {
[16:03:19.100]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:19.100]                         if (muffled) 
[16:03:19.100]                           invokeRestart("muffleWarning")
[16:03:19.100]                       }
[16:03:19.100]                       else if (inherits(cond, "condition")) {
[16:03:19.100]                         if (!is.null(pattern)) {
[16:03:19.100]                           computeRestarts <- base::computeRestarts
[16:03:19.100]                           grepl <- base::grepl
[16:03:19.100]                           restarts <- computeRestarts(cond)
[16:03:19.100]                           for (restart in restarts) {
[16:03:19.100]                             name <- restart$name
[16:03:19.100]                             if (is.null(name)) 
[16:03:19.100]                               next
[16:03:19.100]                             if (!grepl(pattern, name)) 
[16:03:19.100]                               next
[16:03:19.100]                             invokeRestart(restart)
[16:03:19.100]                             muffled <- TRUE
[16:03:19.100]                             break
[16:03:19.100]                           }
[16:03:19.100]                         }
[16:03:19.100]                       }
[16:03:19.100]                       invisible(muffled)
[16:03:19.100]                     }
[16:03:19.100]                     muffleCondition(cond, pattern = "^muffle")
[16:03:19.100]                   }
[16:03:19.100]                 }
[16:03:19.100]             }
[16:03:19.100]         }))
[16:03:19.100]     }, error = function(ex) {
[16:03:19.100]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:19.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:19.100]                 ...future.rng), started = ...future.startTime, 
[16:03:19.100]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:19.100]             version = "1.8"), class = "FutureResult")
[16:03:19.100]     }, finally = {
[16:03:19.100]         if (!identical(...future.workdir, getwd())) 
[16:03:19.100]             setwd(...future.workdir)
[16:03:19.100]         {
[16:03:19.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:19.100]                 ...future.oldOptions$nwarnings <- NULL
[16:03:19.100]             }
[16:03:19.100]             base::options(...future.oldOptions)
[16:03:19.100]             if (.Platform$OS.type == "windows") {
[16:03:19.100]                 old_names <- names(...future.oldEnvVars)
[16:03:19.100]                 envs <- base::Sys.getenv()
[16:03:19.100]                 names <- names(envs)
[16:03:19.100]                 common <- intersect(names, old_names)
[16:03:19.100]                 added <- setdiff(names, old_names)
[16:03:19.100]                 removed <- setdiff(old_names, names)
[16:03:19.100]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:19.100]                   envs[common]]
[16:03:19.100]                 NAMES <- toupper(changed)
[16:03:19.100]                 args <- list()
[16:03:19.100]                 for (kk in seq_along(NAMES)) {
[16:03:19.100]                   name <- changed[[kk]]
[16:03:19.100]                   NAME <- NAMES[[kk]]
[16:03:19.100]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.100]                     next
[16:03:19.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:19.100]                 }
[16:03:19.100]                 NAMES <- toupper(added)
[16:03:19.100]                 for (kk in seq_along(NAMES)) {
[16:03:19.100]                   name <- added[[kk]]
[16:03:19.100]                   NAME <- NAMES[[kk]]
[16:03:19.100]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.100]                     next
[16:03:19.100]                   args[[name]] <- ""
[16:03:19.100]                 }
[16:03:19.100]                 NAMES <- toupper(removed)
[16:03:19.100]                 for (kk in seq_along(NAMES)) {
[16:03:19.100]                   name <- removed[[kk]]
[16:03:19.100]                   NAME <- NAMES[[kk]]
[16:03:19.100]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.100]                     next
[16:03:19.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:19.100]                 }
[16:03:19.100]                 if (length(args) > 0) 
[16:03:19.100]                   base::do.call(base::Sys.setenv, args = args)
[16:03:19.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:19.100]             }
[16:03:19.100]             else {
[16:03:19.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:19.100]             }
[16:03:19.100]             {
[16:03:19.100]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:19.100]                   0L) {
[16:03:19.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:19.100]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:19.100]                   base::options(opts)
[16:03:19.100]                 }
[16:03:19.100]                 {
[16:03:19.100]                   {
[16:03:19.100]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:19.100]                     NULL
[16:03:19.100]                   }
[16:03:19.100]                   options(future.plan = NULL)
[16:03:19.100]                   if (is.na(NA_character_)) 
[16:03:19.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:19.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:19.100]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:19.100]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:19.100]                     envir = parent.frame()) 
[16:03:19.100]                   {
[16:03:19.100]                     if (is.function(workers)) 
[16:03:19.100]                       workers <- workers()
[16:03:19.100]                     workers <- structure(as.integer(workers), 
[16:03:19.100]                       class = class(workers))
[16:03:19.100]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:19.100]                       workers >= 1)
[16:03:19.100]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:19.100]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:19.100]                     }
[16:03:19.100]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:19.100]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:19.100]                       envir = envir)
[16:03:19.100]                     if (!future$lazy) 
[16:03:19.100]                       future <- run(future)
[16:03:19.100]                     invisible(future)
[16:03:19.100]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:19.100]                 }
[16:03:19.100]             }
[16:03:19.100]         }
[16:03:19.100]     })
[16:03:19.100]     if (TRUE) {
[16:03:19.100]         base::sink(type = "output", split = FALSE)
[16:03:19.100]         if (TRUE) {
[16:03:19.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:19.100]         }
[16:03:19.100]         else {
[16:03:19.100]             ...future.result["stdout"] <- base::list(NULL)
[16:03:19.100]         }
[16:03:19.100]         base::close(...future.stdout)
[16:03:19.100]         ...future.stdout <- NULL
[16:03:19.100]     }
[16:03:19.100]     ...future.result$conditions <- ...future.conditions
[16:03:19.100]     ...future.result$finished <- base::Sys.time()
[16:03:19.100]     ...future.result
[16:03:19.100] }
[16:03:19.103] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[16:03:19.103] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:19.147] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:19.147] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[16:03:19.148] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[16:03:19.148] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:19.148] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:19.149] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:19.191] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:19.191] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:19.235] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:19.235] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:03:19.236] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:03:19.236] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:03:19.236] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:03:19.237] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:19.237] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:19.237] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:03:19.237] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:03:19.238] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:19.238] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:19.238] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:19.239] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:19.239] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[16:03:19.239] MultisessionFuture started
[16:03:19.239] - Launch lazy future ... done
[16:03:19.240] run() for ‘MultisessionFuture’ ... done
[16:03:19.240] Created future:
[16:03:19.240] MultisessionFuture:
[16:03:19.240] Label: ‘future_vapply-1’
[16:03:19.240] Expression:
[16:03:19.240] {
[16:03:19.240]     do.call(function(...) {
[16:03:19.240]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.240]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:19.240]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.240]             on.exit(options(oopts), add = TRUE)
[16:03:19.240]         }
[16:03:19.240]         {
[16:03:19.240]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:19.240]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.240]                 ...future.FUN(...future.X_jj, ...)
[16:03:19.240]             })
[16:03:19.240]         }
[16:03:19.240]     }, args = future.call.arguments)
[16:03:19.240] }
[16:03:19.240] Lazy evaluation: FALSE
[16:03:19.240] Asynchronous evaluation: TRUE
[16:03:19.240] Local evaluation: TRUE
[16:03:19.240] Environment: R_GlobalEnv
[16:03:19.240] Capture standard output: TRUE
[16:03:19.240] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:19.240] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:19.240] Packages: 1 packages (‘future.apply’)
[16:03:19.240] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:19.240] Resolved: FALSE
[16:03:19.240] Value: <not collected>
[16:03:19.240] Conditions captured: <none>
[16:03:19.240] Early signaling: FALSE
[16:03:19.240] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:19.240] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:19.252] Chunk #1 of 2 ... DONE
[16:03:19.252] Chunk #2 of 2 ...
[16:03:19.252]  - Finding globals in 'X' for chunk #2 ...
[16:03:19.252] getGlobalsAndPackages() ...
[16:03:19.252] Searching for globals...
[16:03:19.252] 
[16:03:19.252] Searching for globals ... DONE
[16:03:19.253] - globals: [0] <none>
[16:03:19.253] getGlobalsAndPackages() ... DONE
[16:03:19.253]    + additional globals found: [n=0] 
[16:03:19.253]    + additional namespaces needed: [n=0] 
[16:03:19.253]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:19.253]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:19.253]  - seeds: <none>
[16:03:19.253]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.253] getGlobalsAndPackages() ...
[16:03:19.253] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.254] Resolving globals: FALSE
[16:03:19.254] Tweak future expression to call with '...' arguments ...
[16:03:19.254] {
[16:03:19.254]     do.call(function(...) {
[16:03:19.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:19.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.254]             on.exit(options(oopts), add = TRUE)
[16:03:19.254]         }
[16:03:19.254]         {
[16:03:19.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:19.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.254]                 ...future.FUN(...future.X_jj, ...)
[16:03:19.254]             })
[16:03:19.254]         }
[16:03:19.254]     }, args = future.call.arguments)
[16:03:19.254] }
[16:03:19.254] Tweak future expression to call with '...' arguments ... DONE
[16:03:19.255] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.255] - packages: [1] ‘future.apply’
[16:03:19.255] getGlobalsAndPackages() ... DONE
[16:03:19.255] run() for ‘Future’ ...
[16:03:19.255] - state: ‘created’
[16:03:19.255] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:19.269] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:19.270] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:19.270]   - Field: ‘node’
[16:03:19.270]   - Field: ‘label’
[16:03:19.270]   - Field: ‘local’
[16:03:19.270]   - Field: ‘owner’
[16:03:19.270]   - Field: ‘envir’
[16:03:19.270]   - Field: ‘workers’
[16:03:19.270]   - Field: ‘packages’
[16:03:19.270]   - Field: ‘gc’
[16:03:19.270]   - Field: ‘conditions’
[16:03:19.270]   - Field: ‘persistent’
[16:03:19.271]   - Field: ‘expr’
[16:03:19.271]   - Field: ‘uuid’
[16:03:19.271]   - Field: ‘seed’
[16:03:19.271]   - Field: ‘version’
[16:03:19.271]   - Field: ‘result’
[16:03:19.271]   - Field: ‘asynchronous’
[16:03:19.271]   - Field: ‘calls’
[16:03:19.271]   - Field: ‘globals’
[16:03:19.271]   - Field: ‘stdout’
[16:03:19.271]   - Field: ‘earlySignal’
[16:03:19.272]   - Field: ‘lazy’
[16:03:19.272]   - Field: ‘state’
[16:03:19.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:19.272] - Launch lazy future ...
[16:03:19.272] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:19.272] Packages needed by future strategies (n = 0): <none>
[16:03:19.273] {
[16:03:19.273]     {
[16:03:19.273]         {
[16:03:19.273]             ...future.startTime <- base::Sys.time()
[16:03:19.273]             {
[16:03:19.273]                 {
[16:03:19.273]                   {
[16:03:19.273]                     {
[16:03:19.273]                       {
[16:03:19.273]                         base::local({
[16:03:19.273]                           has_future <- base::requireNamespace("future", 
[16:03:19.273]                             quietly = TRUE)
[16:03:19.273]                           if (has_future) {
[16:03:19.273]                             ns <- base::getNamespace("future")
[16:03:19.273]                             version <- ns[[".package"]][["version"]]
[16:03:19.273]                             if (is.null(version)) 
[16:03:19.273]                               version <- utils::packageVersion("future")
[16:03:19.273]                           }
[16:03:19.273]                           else {
[16:03:19.273]                             version <- NULL
[16:03:19.273]                           }
[16:03:19.273]                           if (!has_future || version < "1.8.0") {
[16:03:19.273]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:19.273]                               "", base::R.version$version.string), 
[16:03:19.273]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:19.273]                                 base::R.version$platform, 8 * 
[16:03:19.273]                                   base::.Machine$sizeof.pointer), 
[16:03:19.273]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:19.273]                                 "release", "version")], collapse = " "), 
[16:03:19.273]                               hostname = base::Sys.info()[["nodename"]])
[16:03:19.273]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:19.273]                               info)
[16:03:19.273]                             info <- base::paste(info, collapse = "; ")
[16:03:19.273]                             if (!has_future) {
[16:03:19.273]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:19.273]                                 info)
[16:03:19.273]                             }
[16:03:19.273]                             else {
[16:03:19.273]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:19.273]                                 info, version)
[16:03:19.273]                             }
[16:03:19.273]                             base::stop(msg)
[16:03:19.273]                           }
[16:03:19.273]                         })
[16:03:19.273]                       }
[16:03:19.273]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:19.273]                       base::options(mc.cores = 1L)
[16:03:19.273]                     }
[16:03:19.273]                     base::local({
[16:03:19.273]                       for (pkg in "future.apply") {
[16:03:19.273]                         base::loadNamespace(pkg)
[16:03:19.273]                         base::library(pkg, character.only = TRUE)
[16:03:19.273]                       }
[16:03:19.273]                     })
[16:03:19.273]                   }
[16:03:19.273]                   options(future.plan = NULL)
[16:03:19.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:19.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:19.273]                 }
[16:03:19.273]                 ...future.workdir <- getwd()
[16:03:19.273]             }
[16:03:19.273]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:19.273]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:19.273]         }
[16:03:19.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:19.273]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:19.273]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:19.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:19.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:19.273]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:19.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:19.273]             base::names(...future.oldOptions))
[16:03:19.273]     }
[16:03:19.273]     if (FALSE) {
[16:03:19.273]     }
[16:03:19.273]     else {
[16:03:19.273]         if (TRUE) {
[16:03:19.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:19.273]                 open = "w")
[16:03:19.273]         }
[16:03:19.273]         else {
[16:03:19.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:19.273]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:19.273]         }
[16:03:19.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:19.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:19.273]             base::sink(type = "output", split = FALSE)
[16:03:19.273]             base::close(...future.stdout)
[16:03:19.273]         }, add = TRUE)
[16:03:19.273]     }
[16:03:19.273]     ...future.frame <- base::sys.nframe()
[16:03:19.273]     ...future.conditions <- base::list()
[16:03:19.273]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:19.273]     if (FALSE) {
[16:03:19.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:19.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:19.273]     }
[16:03:19.273]     ...future.result <- base::tryCatch({
[16:03:19.273]         base::withCallingHandlers({
[16:03:19.273]             ...future.value <- base::withVisible(base::local({
[16:03:19.273]                 ...future.makeSendCondition <- base::local({
[16:03:19.273]                   sendCondition <- NULL
[16:03:19.273]                   function(frame = 1L) {
[16:03:19.273]                     if (is.function(sendCondition)) 
[16:03:19.273]                       return(sendCondition)
[16:03:19.273]                     ns <- getNamespace("parallel")
[16:03:19.273]                     if (exists("sendData", mode = "function", 
[16:03:19.273]                       envir = ns)) {
[16:03:19.273]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:19.273]                         envir = ns)
[16:03:19.273]                       envir <- sys.frame(frame)
[16:03:19.273]                       master <- NULL
[16:03:19.273]                       while (!identical(envir, .GlobalEnv) && 
[16:03:19.273]                         !identical(envir, emptyenv())) {
[16:03:19.273]                         if (exists("master", mode = "list", envir = envir, 
[16:03:19.273]                           inherits = FALSE)) {
[16:03:19.273]                           master <- get("master", mode = "list", 
[16:03:19.273]                             envir = envir, inherits = FALSE)
[16:03:19.273]                           if (inherits(master, c("SOCKnode", 
[16:03:19.273]                             "SOCK0node"))) {
[16:03:19.273]                             sendCondition <<- function(cond) {
[16:03:19.273]                               data <- list(type = "VALUE", value = cond, 
[16:03:19.273]                                 success = TRUE)
[16:03:19.273]                               parallel_sendData(master, data)
[16:03:19.273]                             }
[16:03:19.273]                             return(sendCondition)
[16:03:19.273]                           }
[16:03:19.273]                         }
[16:03:19.273]                         frame <- frame + 1L
[16:03:19.273]                         envir <- sys.frame(frame)
[16:03:19.273]                       }
[16:03:19.273]                     }
[16:03:19.273]                     sendCondition <<- function(cond) NULL
[16:03:19.273]                   }
[16:03:19.273]                 })
[16:03:19.273]                 withCallingHandlers({
[16:03:19.273]                   {
[16:03:19.273]                     do.call(function(...) {
[16:03:19.273]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.273]                       if (!identical(...future.globals.maxSize.org, 
[16:03:19.273]                         ...future.globals.maxSize)) {
[16:03:19.273]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.273]                         on.exit(options(oopts), add = TRUE)
[16:03:19.273]                       }
[16:03:19.273]                       {
[16:03:19.273]                         lapply(seq_along(...future.elements_ii), 
[16:03:19.273]                           FUN = function(jj) {
[16:03:19.273]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.273]                             ...future.FUN(...future.X_jj, ...)
[16:03:19.273]                           })
[16:03:19.273]                       }
[16:03:19.273]                     }, args = future.call.arguments)
[16:03:19.273]                   }
[16:03:19.273]                 }, immediateCondition = function(cond) {
[16:03:19.273]                   sendCondition <- ...future.makeSendCondition()
[16:03:19.273]                   sendCondition(cond)
[16:03:19.273]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.273]                   {
[16:03:19.273]                     inherits <- base::inherits
[16:03:19.273]                     invokeRestart <- base::invokeRestart
[16:03:19.273]                     is.null <- base::is.null
[16:03:19.273]                     muffled <- FALSE
[16:03:19.273]                     if (inherits(cond, "message")) {
[16:03:19.273]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:19.273]                       if (muffled) 
[16:03:19.273]                         invokeRestart("muffleMessage")
[16:03:19.273]                     }
[16:03:19.273]                     else if (inherits(cond, "warning")) {
[16:03:19.273]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:19.273]                       if (muffled) 
[16:03:19.273]                         invokeRestart("muffleWarning")
[16:03:19.273]                     }
[16:03:19.273]                     else if (inherits(cond, "condition")) {
[16:03:19.273]                       if (!is.null(pattern)) {
[16:03:19.273]                         computeRestarts <- base::computeRestarts
[16:03:19.273]                         grepl <- base::grepl
[16:03:19.273]                         restarts <- computeRestarts(cond)
[16:03:19.273]                         for (restart in restarts) {
[16:03:19.273]                           name <- restart$name
[16:03:19.273]                           if (is.null(name)) 
[16:03:19.273]                             next
[16:03:19.273]                           if (!grepl(pattern, name)) 
[16:03:19.273]                             next
[16:03:19.273]                           invokeRestart(restart)
[16:03:19.273]                           muffled <- TRUE
[16:03:19.273]                           break
[16:03:19.273]                         }
[16:03:19.273]                       }
[16:03:19.273]                     }
[16:03:19.273]                     invisible(muffled)
[16:03:19.273]                   }
[16:03:19.273]                   muffleCondition(cond)
[16:03:19.273]                 })
[16:03:19.273]             }))
[16:03:19.273]             future::FutureResult(value = ...future.value$value, 
[16:03:19.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:19.273]                   ...future.rng), globalenv = if (FALSE) 
[16:03:19.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:19.273]                     ...future.globalenv.names))
[16:03:19.273]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:19.273]         }, condition = base::local({
[16:03:19.273]             c <- base::c
[16:03:19.273]             inherits <- base::inherits
[16:03:19.273]             invokeRestart <- base::invokeRestart
[16:03:19.273]             length <- base::length
[16:03:19.273]             list <- base::list
[16:03:19.273]             seq.int <- base::seq.int
[16:03:19.273]             signalCondition <- base::signalCondition
[16:03:19.273]             sys.calls <- base::sys.calls
[16:03:19.273]             `[[` <- base::`[[`
[16:03:19.273]             `+` <- base::`+`
[16:03:19.273]             `<<-` <- base::`<<-`
[16:03:19.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:19.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:19.273]                   3L)]
[16:03:19.273]             }
[16:03:19.273]             function(cond) {
[16:03:19.273]                 is_error <- inherits(cond, "error")
[16:03:19.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:19.273]                   NULL)
[16:03:19.273]                 if (is_error) {
[16:03:19.273]                   sessionInformation <- function() {
[16:03:19.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:19.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:19.273]                       search = base::search(), system = base::Sys.info())
[16:03:19.273]                   }
[16:03:19.273]                   ...future.conditions[[length(...future.conditions) + 
[16:03:19.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:19.273]                     cond$call), session = sessionInformation(), 
[16:03:19.273]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:19.273]                   signalCondition(cond)
[16:03:19.273]                 }
[16:03:19.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:19.273]                 "immediateCondition"))) {
[16:03:19.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:19.273]                   ...future.conditions[[length(...future.conditions) + 
[16:03:19.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:19.273]                   if (TRUE && !signal) {
[16:03:19.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.273]                     {
[16:03:19.273]                       inherits <- base::inherits
[16:03:19.273]                       invokeRestart <- base::invokeRestart
[16:03:19.273]                       is.null <- base::is.null
[16:03:19.273]                       muffled <- FALSE
[16:03:19.273]                       if (inherits(cond, "message")) {
[16:03:19.273]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:19.273]                         if (muffled) 
[16:03:19.273]                           invokeRestart("muffleMessage")
[16:03:19.273]                       }
[16:03:19.273]                       else if (inherits(cond, "warning")) {
[16:03:19.273]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:19.273]                         if (muffled) 
[16:03:19.273]                           invokeRestart("muffleWarning")
[16:03:19.273]                       }
[16:03:19.273]                       else if (inherits(cond, "condition")) {
[16:03:19.273]                         if (!is.null(pattern)) {
[16:03:19.273]                           computeRestarts <- base::computeRestarts
[16:03:19.273]                           grepl <- base::grepl
[16:03:19.273]                           restarts <- computeRestarts(cond)
[16:03:19.273]                           for (restart in restarts) {
[16:03:19.273]                             name <- restart$name
[16:03:19.273]                             if (is.null(name)) 
[16:03:19.273]                               next
[16:03:19.273]                             if (!grepl(pattern, name)) 
[16:03:19.273]                               next
[16:03:19.273]                             invokeRestart(restart)
[16:03:19.273]                             muffled <- TRUE
[16:03:19.273]                             break
[16:03:19.273]                           }
[16:03:19.273]                         }
[16:03:19.273]                       }
[16:03:19.273]                       invisible(muffled)
[16:03:19.273]                     }
[16:03:19.273]                     muffleCondition(cond, pattern = "^muffle")
[16:03:19.273]                   }
[16:03:19.273]                 }
[16:03:19.273]                 else {
[16:03:19.273]                   if (TRUE) {
[16:03:19.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.273]                     {
[16:03:19.273]                       inherits <- base::inherits
[16:03:19.273]                       invokeRestart <- base::invokeRestart
[16:03:19.273]                       is.null <- base::is.null
[16:03:19.273]                       muffled <- FALSE
[16:03:19.273]                       if (inherits(cond, "message")) {
[16:03:19.273]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:19.273]                         if (muffled) 
[16:03:19.273]                           invokeRestart("muffleMessage")
[16:03:19.273]                       }
[16:03:19.273]                       else if (inherits(cond, "warning")) {
[16:03:19.273]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:19.273]                         if (muffled) 
[16:03:19.273]                           invokeRestart("muffleWarning")
[16:03:19.273]                       }
[16:03:19.273]                       else if (inherits(cond, "condition")) {
[16:03:19.273]                         if (!is.null(pattern)) {
[16:03:19.273]                           computeRestarts <- base::computeRestarts
[16:03:19.273]                           grepl <- base::grepl
[16:03:19.273]                           restarts <- computeRestarts(cond)
[16:03:19.273]                           for (restart in restarts) {
[16:03:19.273]                             name <- restart$name
[16:03:19.273]                             if (is.null(name)) 
[16:03:19.273]                               next
[16:03:19.273]                             if (!grepl(pattern, name)) 
[16:03:19.273]                               next
[16:03:19.273]                             invokeRestart(restart)
[16:03:19.273]                             muffled <- TRUE
[16:03:19.273]                             break
[16:03:19.273]                           }
[16:03:19.273]                         }
[16:03:19.273]                       }
[16:03:19.273]                       invisible(muffled)
[16:03:19.273]                     }
[16:03:19.273]                     muffleCondition(cond, pattern = "^muffle")
[16:03:19.273]                   }
[16:03:19.273]                 }
[16:03:19.273]             }
[16:03:19.273]         }))
[16:03:19.273]     }, error = function(ex) {
[16:03:19.273]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:19.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:19.273]                 ...future.rng), started = ...future.startTime, 
[16:03:19.273]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:19.273]             version = "1.8"), class = "FutureResult")
[16:03:19.273]     }, finally = {
[16:03:19.273]         if (!identical(...future.workdir, getwd())) 
[16:03:19.273]             setwd(...future.workdir)
[16:03:19.273]         {
[16:03:19.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:19.273]                 ...future.oldOptions$nwarnings <- NULL
[16:03:19.273]             }
[16:03:19.273]             base::options(...future.oldOptions)
[16:03:19.273]             if (.Platform$OS.type == "windows") {
[16:03:19.273]                 old_names <- names(...future.oldEnvVars)
[16:03:19.273]                 envs <- base::Sys.getenv()
[16:03:19.273]                 names <- names(envs)
[16:03:19.273]                 common <- intersect(names, old_names)
[16:03:19.273]                 added <- setdiff(names, old_names)
[16:03:19.273]                 removed <- setdiff(old_names, names)
[16:03:19.273]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:19.273]                   envs[common]]
[16:03:19.273]                 NAMES <- toupper(changed)
[16:03:19.273]                 args <- list()
[16:03:19.273]                 for (kk in seq_along(NAMES)) {
[16:03:19.273]                   name <- changed[[kk]]
[16:03:19.273]                   NAME <- NAMES[[kk]]
[16:03:19.273]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.273]                     next
[16:03:19.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:19.273]                 }
[16:03:19.273]                 NAMES <- toupper(added)
[16:03:19.273]                 for (kk in seq_along(NAMES)) {
[16:03:19.273]                   name <- added[[kk]]
[16:03:19.273]                   NAME <- NAMES[[kk]]
[16:03:19.273]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.273]                     next
[16:03:19.273]                   args[[name]] <- ""
[16:03:19.273]                 }
[16:03:19.273]                 NAMES <- toupper(removed)
[16:03:19.273]                 for (kk in seq_along(NAMES)) {
[16:03:19.273]                   name <- removed[[kk]]
[16:03:19.273]                   NAME <- NAMES[[kk]]
[16:03:19.273]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.273]                     next
[16:03:19.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:19.273]                 }
[16:03:19.273]                 if (length(args) > 0) 
[16:03:19.273]                   base::do.call(base::Sys.setenv, args = args)
[16:03:19.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:19.273]             }
[16:03:19.273]             else {
[16:03:19.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:19.273]             }
[16:03:19.273]             {
[16:03:19.273]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:19.273]                   0L) {
[16:03:19.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:19.273]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:19.273]                   base::options(opts)
[16:03:19.273]                 }
[16:03:19.273]                 {
[16:03:19.273]                   {
[16:03:19.273]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:19.273]                     NULL
[16:03:19.273]                   }
[16:03:19.273]                   options(future.plan = NULL)
[16:03:19.273]                   if (is.na(NA_character_)) 
[16:03:19.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:19.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:19.273]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:19.273]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:19.273]                     envir = parent.frame()) 
[16:03:19.273]                   {
[16:03:19.273]                     if (is.function(workers)) 
[16:03:19.273]                       workers <- workers()
[16:03:19.273]                     workers <- structure(as.integer(workers), 
[16:03:19.273]                       class = class(workers))
[16:03:19.273]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:19.273]                       workers >= 1)
[16:03:19.273]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:19.273]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:19.273]                     }
[16:03:19.273]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:19.273]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:19.273]                       envir = envir)
[16:03:19.273]                     if (!future$lazy) 
[16:03:19.273]                       future <- run(future)
[16:03:19.273]                     invisible(future)
[16:03:19.273]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:19.273]                 }
[16:03:19.273]             }
[16:03:19.273]         }
[16:03:19.273]     })
[16:03:19.273]     if (TRUE) {
[16:03:19.273]         base::sink(type = "output", split = FALSE)
[16:03:19.273]         if (TRUE) {
[16:03:19.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:19.273]         }
[16:03:19.273]         else {
[16:03:19.273]             ...future.result["stdout"] <- base::list(NULL)
[16:03:19.273]         }
[16:03:19.273]         base::close(...future.stdout)
[16:03:19.273]         ...future.stdout <- NULL
[16:03:19.273]     }
[16:03:19.273]     ...future.result$conditions <- ...future.conditions
[16:03:19.273]     ...future.result$finished <- base::Sys.time()
[16:03:19.273]     ...future.result
[16:03:19.273] }
[16:03:19.276] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[16:03:19.276] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:19.319] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:19.319] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[16:03:19.320] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[16:03:19.320] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:19.320] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:19.320] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:19.363] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:19.363] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:19.407] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:19.407] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[16:03:19.408] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[16:03:19.408] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:03:19.408] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:03:19.408] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:19.409] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:19.409] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:03:19.409] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:03:19.410] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:19.410] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:19.410] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:19.410] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:19.411] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[16:03:19.411] MultisessionFuture started
[16:03:19.411] - Launch lazy future ... done
[16:03:19.412] run() for ‘MultisessionFuture’ ... done
[16:03:19.412] Created future:
[16:03:19.412] MultisessionFuture:
[16:03:19.412] Label: ‘future_vapply-2’
[16:03:19.412] Expression:
[16:03:19.412] {
[16:03:19.412]     do.call(function(...) {
[16:03:19.412]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.412]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:19.412]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.412]             on.exit(options(oopts), add = TRUE)
[16:03:19.412]         }
[16:03:19.412]         {
[16:03:19.412]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:19.412]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.412]                 ...future.FUN(...future.X_jj, ...)
[16:03:19.412]             })
[16:03:19.412]         }
[16:03:19.412]     }, args = future.call.arguments)
[16:03:19.412] }
[16:03:19.412] Lazy evaluation: FALSE
[16:03:19.412] Asynchronous evaluation: TRUE
[16:03:19.412] Local evaluation: TRUE
[16:03:19.412] Environment: R_GlobalEnv
[16:03:19.412] Capture standard output: TRUE
[16:03:19.412] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:19.412] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:19.412] Packages: 1 packages (‘future.apply’)
[16:03:19.412] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:19.412] Resolved: FALSE
[16:03:19.412] Value: <not collected>
[16:03:19.412] Conditions captured: <none>
[16:03:19.412] Early signaling: FALSE
[16:03:19.412] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:19.412] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:19.424] Chunk #2 of 2 ... DONE
[16:03:19.424] Launching 2 futures (chunks) ... DONE
[16:03:19.424] Resolving 2 futures (chunks) ...
[16:03:19.424] resolve() on list ...
[16:03:19.424]  recursive: 0
[16:03:19.424]  length: 2
[16:03:19.424] 
[16:03:19.425] receiveMessageFromWorker() for ClusterFuture ...
[16:03:19.425] - Validating connection of MultisessionFuture
[16:03:19.425] - received message: FutureResult
[16:03:19.425] - Received FutureResult
[16:03:19.425] - Erased future from FutureRegistry
[16:03:19.425] result() for ClusterFuture ...
[16:03:19.426] - result already collected: FutureResult
[16:03:19.426] result() for ClusterFuture ... done
[16:03:19.426] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:19.426] Future #1
[16:03:19.426] result() for ClusterFuture ...
[16:03:19.426] - result already collected: FutureResult
[16:03:19.426] result() for ClusterFuture ... done
[16:03:19.426] result() for ClusterFuture ...
[16:03:19.426] - result already collected: FutureResult
[16:03:19.426] result() for ClusterFuture ... done
[16:03:19.426] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:19.427] - nx: 2
[16:03:19.427] - relay: TRUE
[16:03:19.427] - stdout: TRUE
[16:03:19.427] - signal: TRUE
[16:03:19.427] - resignal: FALSE
[16:03:19.427] - force: TRUE
[16:03:19.427] - relayed: [n=2] FALSE, FALSE
[16:03:19.427] - queued futures: [n=2] FALSE, FALSE
[16:03:19.427]  - until=1
[16:03:19.427]  - relaying element #1
[16:03:19.427] result() for ClusterFuture ...
[16:03:19.427] - result already collected: FutureResult
[16:03:19.428] result() for ClusterFuture ... done
[16:03:19.428] result() for ClusterFuture ...
[16:03:19.428] - result already collected: FutureResult
[16:03:19.428] result() for ClusterFuture ... done
[16:03:19.428] result() for ClusterFuture ...
[16:03:19.428] - result already collected: FutureResult
[16:03:19.428] result() for ClusterFuture ... done
[16:03:19.428] result() for ClusterFuture ...
[16:03:19.428] - result already collected: FutureResult
[16:03:19.428] result() for ClusterFuture ... done
[16:03:19.428] - relayed: [n=2] TRUE, FALSE
[16:03:19.429] - queued futures: [n=2] TRUE, FALSE
[16:03:19.429] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:19.429]  length: 1 (resolved future 1)
[16:03:19.460] receiveMessageFromWorker() for ClusterFuture ...
[16:03:19.460] - Validating connection of MultisessionFuture
[16:03:19.460] - received message: FutureResult
[16:03:19.460] - Received FutureResult
[16:03:19.460] - Erased future from FutureRegistry
[16:03:19.460] result() for ClusterFuture ...
[16:03:19.461] - result already collected: FutureResult
[16:03:19.461] result() for ClusterFuture ... done
[16:03:19.461] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:19.461] Future #2
[16:03:19.461] result() for ClusterFuture ...
[16:03:19.461] - result already collected: FutureResult
[16:03:19.461] result() for ClusterFuture ... done
[16:03:19.461] result() for ClusterFuture ...
[16:03:19.461] - result already collected: FutureResult
[16:03:19.461] result() for ClusterFuture ... done
[16:03:19.461] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:19.462] - nx: 2
[16:03:19.462] - relay: TRUE
[16:03:19.462] - stdout: TRUE
[16:03:19.462] - signal: TRUE
[16:03:19.462] - resignal: FALSE
[16:03:19.462] - force: TRUE
[16:03:19.462] - relayed: [n=2] TRUE, FALSE
[16:03:19.462] - queued futures: [n=2] TRUE, FALSE
[16:03:19.462]  - until=2
[16:03:19.462]  - relaying element #2
[16:03:19.462] result() for ClusterFuture ...
[16:03:19.463] - result already collected: FutureResult
[16:03:19.463] result() for ClusterFuture ... done
[16:03:19.463] result() for ClusterFuture ...
[16:03:19.463] - result already collected: FutureResult
[16:03:19.463] result() for ClusterFuture ... done
[16:03:19.463] result() for ClusterFuture ...
[16:03:19.463] - result already collected: FutureResult
[16:03:19.463] result() for ClusterFuture ... done
[16:03:19.463] result() for ClusterFuture ...
[16:03:19.463] - result already collected: FutureResult
[16:03:19.463] result() for ClusterFuture ... done
[16:03:19.464] - relayed: [n=2] TRUE, TRUE
[16:03:19.464] - queued futures: [n=2] TRUE, TRUE
[16:03:19.464] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:19.464]  length: 0 (resolved future 2)
[16:03:19.464] Relaying remaining futures
[16:03:19.464] signalConditionsASAP(NULL, pos=0) ...
[16:03:19.464] - nx: 2
[16:03:19.464] - relay: TRUE
[16:03:19.464] - stdout: TRUE
[16:03:19.464] - signal: TRUE
[16:03:19.464] - resignal: FALSE
[16:03:19.464] - force: TRUE
[16:03:19.465] - relayed: [n=2] TRUE, TRUE
[16:03:19.465] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:19.465] - relayed: [n=2] TRUE, TRUE
[16:03:19.465] - queued futures: [n=2] TRUE, TRUE
[16:03:19.465] signalConditionsASAP(NULL, pos=0) ... done
[16:03:19.465] resolve() on list ... DONE
[16:03:19.465] result() for ClusterFuture ...
[16:03:19.465] - result already collected: FutureResult
[16:03:19.465] result() for ClusterFuture ... done
[16:03:19.465] result() for ClusterFuture ...
[16:03:19.465] - result already collected: FutureResult
[16:03:19.466] result() for ClusterFuture ... done
[16:03:19.466] result() for ClusterFuture ...
[16:03:19.466] - result already collected: FutureResult
[16:03:19.466] result() for ClusterFuture ... done
[16:03:19.466] result() for ClusterFuture ...
[16:03:19.466] - result already collected: FutureResult
[16:03:19.466] result() for ClusterFuture ... done
[16:03:19.466]  - Number of value chunks collected: 2
[16:03:19.466] Resolving 2 futures (chunks) ... DONE
[16:03:19.466] Reducing values from 2 chunks ...
[16:03:19.466]  - Number of values collected after concatenation: 10
[16:03:19.467]  - Number of values expected: 10
[16:03:19.467] Reducing values from 2 chunks ... DONE
[16:03:19.467] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[16:03:19.469] future_lapply() ...
[16:03:19.474] Number of chunks: 2
[16:03:19.474] getGlobalsAndPackagesXApply() ...
[16:03:19.474]  - future.globals: TRUE
[16:03:19.475] getGlobalsAndPackages() ...
[16:03:19.475] Searching for globals...
[16:03:19.478] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[16:03:19.478] Searching for globals ... DONE
[16:03:19.478] Resolving globals: FALSE
[16:03:19.479] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[16:03:19.480] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:19.480] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:19.480] - packages: [2] ‘stats’, ‘future.apply’
[16:03:19.480] getGlobalsAndPackages() ... DONE
[16:03:19.480]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:19.480]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:03:19.480] Finding globals ... DONE
[16:03:19.480]  - use_args: TRUE
[16:03:19.480]  - Getting '...' globals ...
[16:03:19.481] resolve() on list ...
[16:03:19.481]  recursive: 0
[16:03:19.481]  length: 1
[16:03:19.481]  elements: ‘...’
[16:03:19.481]  length: 0 (resolved future 1)
[16:03:19.481] resolve() on list ... DONE
[16:03:19.481]    - '...' content: [n=0] 
[16:03:19.481] List of 1
[16:03:19.481]  $ ...: list()
[16:03:19.481]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:19.481]  - attr(*, "where")=List of 1
[16:03:19.481]   ..$ ...:<environment: 0x564e4569ce30> 
[16:03:19.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:19.481]  - attr(*, "resolved")= logi TRUE
[16:03:19.481]  - attr(*, "total_size")= num NA
[16:03:19.484]  - Getting '...' globals ... DONE
[16:03:19.484] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:19.484] List of 8
[16:03:19.484]  $ ...future.FUN:function (x, ...)  
[16:03:19.484]  $ x_FUN        :function (x, ...)  
[16:03:19.484]  $ times        : int 5
[16:03:19.484]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:19.484]  $ stop_if_not  :function (...)  
[16:03:19.484]  $ dim          : NULL
[16:03:19.484]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:19.484]  $ ...          : list()
[16:03:19.484]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:19.484]  - attr(*, "where")=List of 8
[16:03:19.484]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:19.484]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:19.484]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:19.484]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:19.484]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:19.484]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:19.484]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:19.484]   ..$ ...          :<environment: 0x564e4569ce30> 
[16:03:19.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:19.484]  - attr(*, "resolved")= logi FALSE
[16:03:19.484]  - attr(*, "total_size")= num 95528
[16:03:19.492] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:03:19.492] getGlobalsAndPackagesXApply() ... DONE
[16:03:19.492] Number of futures (= number of chunks): 2
[16:03:19.492] Launching 2 futures (chunks) ...
[16:03:19.493] Chunk #1 of 2 ...
[16:03:19.493]  - Finding globals in 'X' for chunk #1 ...
[16:03:19.493] getGlobalsAndPackages() ...
[16:03:19.493] Searching for globals...
[16:03:19.493] 
[16:03:19.493] Searching for globals ... DONE
[16:03:19.493] - globals: [0] <none>
[16:03:19.493] getGlobalsAndPackages() ... DONE
[16:03:19.493]    + additional globals found: [n=0] 
[16:03:19.494]    + additional namespaces needed: [n=0] 
[16:03:19.494]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:19.494]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:19.494]  - seeds: <none>
[16:03:19.494]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.494] getGlobalsAndPackages() ...
[16:03:19.494] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.494] Resolving globals: FALSE
[16:03:19.494] Tweak future expression to call with '...' arguments ...
[16:03:19.494] {
[16:03:19.494]     do.call(function(...) {
[16:03:19.494]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.494]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:19.494]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.494]             on.exit(options(oopts), add = TRUE)
[16:03:19.494]         }
[16:03:19.494]         {
[16:03:19.494]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:19.494]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.494]                 ...future.FUN(...future.X_jj, ...)
[16:03:19.494]             })
[16:03:19.494]         }
[16:03:19.494]     }, args = future.call.arguments)
[16:03:19.494] }
[16:03:19.495] Tweak future expression to call with '...' arguments ... DONE
[16:03:19.495] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.495] - packages: [2] ‘stats’, ‘future.apply’
[16:03:19.495] getGlobalsAndPackages() ... DONE
[16:03:19.496] run() for ‘Future’ ...
[16:03:19.496] - state: ‘created’
[16:03:19.496] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:19.510] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:19.510] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:19.510]   - Field: ‘node’
[16:03:19.510]   - Field: ‘label’
[16:03:19.510]   - Field: ‘local’
[16:03:19.510]   - Field: ‘owner’
[16:03:19.510]   - Field: ‘envir’
[16:03:19.511]   - Field: ‘workers’
[16:03:19.511]   - Field: ‘packages’
[16:03:19.511]   - Field: ‘gc’
[16:03:19.511]   - Field: ‘conditions’
[16:03:19.511]   - Field: ‘persistent’
[16:03:19.511]   - Field: ‘expr’
[16:03:19.511]   - Field: ‘uuid’
[16:03:19.511]   - Field: ‘seed’
[16:03:19.511]   - Field: ‘version’
[16:03:19.511]   - Field: ‘result’
[16:03:19.512]   - Field: ‘asynchronous’
[16:03:19.512]   - Field: ‘calls’
[16:03:19.512]   - Field: ‘globals’
[16:03:19.512]   - Field: ‘stdout’
[16:03:19.512]   - Field: ‘earlySignal’
[16:03:19.512]   - Field: ‘lazy’
[16:03:19.512]   - Field: ‘state’
[16:03:19.512] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:19.512] - Launch lazy future ...
[16:03:19.513] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:03:19.513] Packages needed by future strategies (n = 0): <none>
[16:03:19.513] {
[16:03:19.513]     {
[16:03:19.513]         {
[16:03:19.513]             ...future.startTime <- base::Sys.time()
[16:03:19.513]             {
[16:03:19.513]                 {
[16:03:19.513]                   {
[16:03:19.513]                     {
[16:03:19.513]                       {
[16:03:19.513]                         base::local({
[16:03:19.513]                           has_future <- base::requireNamespace("future", 
[16:03:19.513]                             quietly = TRUE)
[16:03:19.513]                           if (has_future) {
[16:03:19.513]                             ns <- base::getNamespace("future")
[16:03:19.513]                             version <- ns[[".package"]][["version"]]
[16:03:19.513]                             if (is.null(version)) 
[16:03:19.513]                               version <- utils::packageVersion("future")
[16:03:19.513]                           }
[16:03:19.513]                           else {
[16:03:19.513]                             version <- NULL
[16:03:19.513]                           }
[16:03:19.513]                           if (!has_future || version < "1.8.0") {
[16:03:19.513]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:19.513]                               "", base::R.version$version.string), 
[16:03:19.513]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:19.513]                                 base::R.version$platform, 8 * 
[16:03:19.513]                                   base::.Machine$sizeof.pointer), 
[16:03:19.513]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:19.513]                                 "release", "version")], collapse = " "), 
[16:03:19.513]                               hostname = base::Sys.info()[["nodename"]])
[16:03:19.513]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:19.513]                               info)
[16:03:19.513]                             info <- base::paste(info, collapse = "; ")
[16:03:19.513]                             if (!has_future) {
[16:03:19.513]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:19.513]                                 info)
[16:03:19.513]                             }
[16:03:19.513]                             else {
[16:03:19.513]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:19.513]                                 info, version)
[16:03:19.513]                             }
[16:03:19.513]                             base::stop(msg)
[16:03:19.513]                           }
[16:03:19.513]                         })
[16:03:19.513]                       }
[16:03:19.513]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:19.513]                       base::options(mc.cores = 1L)
[16:03:19.513]                     }
[16:03:19.513]                     base::local({
[16:03:19.513]                       for (pkg in c("stats", "future.apply")) {
[16:03:19.513]                         base::loadNamespace(pkg)
[16:03:19.513]                         base::library(pkg, character.only = TRUE)
[16:03:19.513]                       }
[16:03:19.513]                     })
[16:03:19.513]                   }
[16:03:19.513]                   options(future.plan = NULL)
[16:03:19.513]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:19.513]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:19.513]                 }
[16:03:19.513]                 ...future.workdir <- getwd()
[16:03:19.513]             }
[16:03:19.513]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:19.513]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:19.513]         }
[16:03:19.513]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:19.513]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:19.513]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:19.513]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:19.513]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:19.513]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:19.513]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:19.513]             base::names(...future.oldOptions))
[16:03:19.513]     }
[16:03:19.513]     if (FALSE) {
[16:03:19.513]     }
[16:03:19.513]     else {
[16:03:19.513]         if (TRUE) {
[16:03:19.513]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:19.513]                 open = "w")
[16:03:19.513]         }
[16:03:19.513]         else {
[16:03:19.513]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:19.513]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:19.513]         }
[16:03:19.513]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:19.513]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:19.513]             base::sink(type = "output", split = FALSE)
[16:03:19.513]             base::close(...future.stdout)
[16:03:19.513]         }, add = TRUE)
[16:03:19.513]     }
[16:03:19.513]     ...future.frame <- base::sys.nframe()
[16:03:19.513]     ...future.conditions <- base::list()
[16:03:19.513]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:19.513]     if (FALSE) {
[16:03:19.513]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:19.513]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:19.513]     }
[16:03:19.513]     ...future.result <- base::tryCatch({
[16:03:19.513]         base::withCallingHandlers({
[16:03:19.513]             ...future.value <- base::withVisible(base::local({
[16:03:19.513]                 ...future.makeSendCondition <- base::local({
[16:03:19.513]                   sendCondition <- NULL
[16:03:19.513]                   function(frame = 1L) {
[16:03:19.513]                     if (is.function(sendCondition)) 
[16:03:19.513]                       return(sendCondition)
[16:03:19.513]                     ns <- getNamespace("parallel")
[16:03:19.513]                     if (exists("sendData", mode = "function", 
[16:03:19.513]                       envir = ns)) {
[16:03:19.513]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:19.513]                         envir = ns)
[16:03:19.513]                       envir <- sys.frame(frame)
[16:03:19.513]                       master <- NULL
[16:03:19.513]                       while (!identical(envir, .GlobalEnv) && 
[16:03:19.513]                         !identical(envir, emptyenv())) {
[16:03:19.513]                         if (exists("master", mode = "list", envir = envir, 
[16:03:19.513]                           inherits = FALSE)) {
[16:03:19.513]                           master <- get("master", mode = "list", 
[16:03:19.513]                             envir = envir, inherits = FALSE)
[16:03:19.513]                           if (inherits(master, c("SOCKnode", 
[16:03:19.513]                             "SOCK0node"))) {
[16:03:19.513]                             sendCondition <<- function(cond) {
[16:03:19.513]                               data <- list(type = "VALUE", value = cond, 
[16:03:19.513]                                 success = TRUE)
[16:03:19.513]                               parallel_sendData(master, data)
[16:03:19.513]                             }
[16:03:19.513]                             return(sendCondition)
[16:03:19.513]                           }
[16:03:19.513]                         }
[16:03:19.513]                         frame <- frame + 1L
[16:03:19.513]                         envir <- sys.frame(frame)
[16:03:19.513]                       }
[16:03:19.513]                     }
[16:03:19.513]                     sendCondition <<- function(cond) NULL
[16:03:19.513]                   }
[16:03:19.513]                 })
[16:03:19.513]                 withCallingHandlers({
[16:03:19.513]                   {
[16:03:19.513]                     do.call(function(...) {
[16:03:19.513]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.513]                       if (!identical(...future.globals.maxSize.org, 
[16:03:19.513]                         ...future.globals.maxSize)) {
[16:03:19.513]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.513]                         on.exit(options(oopts), add = TRUE)
[16:03:19.513]                       }
[16:03:19.513]                       {
[16:03:19.513]                         lapply(seq_along(...future.elements_ii), 
[16:03:19.513]                           FUN = function(jj) {
[16:03:19.513]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.513]                             ...future.FUN(...future.X_jj, ...)
[16:03:19.513]                           })
[16:03:19.513]                       }
[16:03:19.513]                     }, args = future.call.arguments)
[16:03:19.513]                   }
[16:03:19.513]                 }, immediateCondition = function(cond) {
[16:03:19.513]                   sendCondition <- ...future.makeSendCondition()
[16:03:19.513]                   sendCondition(cond)
[16:03:19.513]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.513]                   {
[16:03:19.513]                     inherits <- base::inherits
[16:03:19.513]                     invokeRestart <- base::invokeRestart
[16:03:19.513]                     is.null <- base::is.null
[16:03:19.513]                     muffled <- FALSE
[16:03:19.513]                     if (inherits(cond, "message")) {
[16:03:19.513]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:19.513]                       if (muffled) 
[16:03:19.513]                         invokeRestart("muffleMessage")
[16:03:19.513]                     }
[16:03:19.513]                     else if (inherits(cond, "warning")) {
[16:03:19.513]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:19.513]                       if (muffled) 
[16:03:19.513]                         invokeRestart("muffleWarning")
[16:03:19.513]                     }
[16:03:19.513]                     else if (inherits(cond, "condition")) {
[16:03:19.513]                       if (!is.null(pattern)) {
[16:03:19.513]                         computeRestarts <- base::computeRestarts
[16:03:19.513]                         grepl <- base::grepl
[16:03:19.513]                         restarts <- computeRestarts(cond)
[16:03:19.513]                         for (restart in restarts) {
[16:03:19.513]                           name <- restart$name
[16:03:19.513]                           if (is.null(name)) 
[16:03:19.513]                             next
[16:03:19.513]                           if (!grepl(pattern, name)) 
[16:03:19.513]                             next
[16:03:19.513]                           invokeRestart(restart)
[16:03:19.513]                           muffled <- TRUE
[16:03:19.513]                           break
[16:03:19.513]                         }
[16:03:19.513]                       }
[16:03:19.513]                     }
[16:03:19.513]                     invisible(muffled)
[16:03:19.513]                   }
[16:03:19.513]                   muffleCondition(cond)
[16:03:19.513]                 })
[16:03:19.513]             }))
[16:03:19.513]             future::FutureResult(value = ...future.value$value, 
[16:03:19.513]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:19.513]                   ...future.rng), globalenv = if (FALSE) 
[16:03:19.513]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:19.513]                     ...future.globalenv.names))
[16:03:19.513]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:19.513]         }, condition = base::local({
[16:03:19.513]             c <- base::c
[16:03:19.513]             inherits <- base::inherits
[16:03:19.513]             invokeRestart <- base::invokeRestart
[16:03:19.513]             length <- base::length
[16:03:19.513]             list <- base::list
[16:03:19.513]             seq.int <- base::seq.int
[16:03:19.513]             signalCondition <- base::signalCondition
[16:03:19.513]             sys.calls <- base::sys.calls
[16:03:19.513]             `[[` <- base::`[[`
[16:03:19.513]             `+` <- base::`+`
[16:03:19.513]             `<<-` <- base::`<<-`
[16:03:19.513]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:19.513]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:19.513]                   3L)]
[16:03:19.513]             }
[16:03:19.513]             function(cond) {
[16:03:19.513]                 is_error <- inherits(cond, "error")
[16:03:19.513]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:19.513]                   NULL)
[16:03:19.513]                 if (is_error) {
[16:03:19.513]                   sessionInformation <- function() {
[16:03:19.513]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:19.513]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:19.513]                       search = base::search(), system = base::Sys.info())
[16:03:19.513]                   }
[16:03:19.513]                   ...future.conditions[[length(...future.conditions) + 
[16:03:19.513]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:19.513]                     cond$call), session = sessionInformation(), 
[16:03:19.513]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:19.513]                   signalCondition(cond)
[16:03:19.513]                 }
[16:03:19.513]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:19.513]                 "immediateCondition"))) {
[16:03:19.513]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:19.513]                   ...future.conditions[[length(...future.conditions) + 
[16:03:19.513]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:19.513]                   if (TRUE && !signal) {
[16:03:19.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.513]                     {
[16:03:19.513]                       inherits <- base::inherits
[16:03:19.513]                       invokeRestart <- base::invokeRestart
[16:03:19.513]                       is.null <- base::is.null
[16:03:19.513]                       muffled <- FALSE
[16:03:19.513]                       if (inherits(cond, "message")) {
[16:03:19.513]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:19.513]                         if (muffled) 
[16:03:19.513]                           invokeRestart("muffleMessage")
[16:03:19.513]                       }
[16:03:19.513]                       else if (inherits(cond, "warning")) {
[16:03:19.513]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:19.513]                         if (muffled) 
[16:03:19.513]                           invokeRestart("muffleWarning")
[16:03:19.513]                       }
[16:03:19.513]                       else if (inherits(cond, "condition")) {
[16:03:19.513]                         if (!is.null(pattern)) {
[16:03:19.513]                           computeRestarts <- base::computeRestarts
[16:03:19.513]                           grepl <- base::grepl
[16:03:19.513]                           restarts <- computeRestarts(cond)
[16:03:19.513]                           for (restart in restarts) {
[16:03:19.513]                             name <- restart$name
[16:03:19.513]                             if (is.null(name)) 
[16:03:19.513]                               next
[16:03:19.513]                             if (!grepl(pattern, name)) 
[16:03:19.513]                               next
[16:03:19.513]                             invokeRestart(restart)
[16:03:19.513]                             muffled <- TRUE
[16:03:19.513]                             break
[16:03:19.513]                           }
[16:03:19.513]                         }
[16:03:19.513]                       }
[16:03:19.513]                       invisible(muffled)
[16:03:19.513]                     }
[16:03:19.513]                     muffleCondition(cond, pattern = "^muffle")
[16:03:19.513]                   }
[16:03:19.513]                 }
[16:03:19.513]                 else {
[16:03:19.513]                   if (TRUE) {
[16:03:19.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.513]                     {
[16:03:19.513]                       inherits <- base::inherits
[16:03:19.513]                       invokeRestart <- base::invokeRestart
[16:03:19.513]                       is.null <- base::is.null
[16:03:19.513]                       muffled <- FALSE
[16:03:19.513]                       if (inherits(cond, "message")) {
[16:03:19.513]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:19.513]                         if (muffled) 
[16:03:19.513]                           invokeRestart("muffleMessage")
[16:03:19.513]                       }
[16:03:19.513]                       else if (inherits(cond, "warning")) {
[16:03:19.513]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:19.513]                         if (muffled) 
[16:03:19.513]                           invokeRestart("muffleWarning")
[16:03:19.513]                       }
[16:03:19.513]                       else if (inherits(cond, "condition")) {
[16:03:19.513]                         if (!is.null(pattern)) {
[16:03:19.513]                           computeRestarts <- base::computeRestarts
[16:03:19.513]                           grepl <- base::grepl
[16:03:19.513]                           restarts <- computeRestarts(cond)
[16:03:19.513]                           for (restart in restarts) {
[16:03:19.513]                             name <- restart$name
[16:03:19.513]                             if (is.null(name)) 
[16:03:19.513]                               next
[16:03:19.513]                             if (!grepl(pattern, name)) 
[16:03:19.513]                               next
[16:03:19.513]                             invokeRestart(restart)
[16:03:19.513]                             muffled <- TRUE
[16:03:19.513]                             break
[16:03:19.513]                           }
[16:03:19.513]                         }
[16:03:19.513]                       }
[16:03:19.513]                       invisible(muffled)
[16:03:19.513]                     }
[16:03:19.513]                     muffleCondition(cond, pattern = "^muffle")
[16:03:19.513]                   }
[16:03:19.513]                 }
[16:03:19.513]             }
[16:03:19.513]         }))
[16:03:19.513]     }, error = function(ex) {
[16:03:19.513]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:19.513]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:19.513]                 ...future.rng), started = ...future.startTime, 
[16:03:19.513]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:19.513]             version = "1.8"), class = "FutureResult")
[16:03:19.513]     }, finally = {
[16:03:19.513]         if (!identical(...future.workdir, getwd())) 
[16:03:19.513]             setwd(...future.workdir)
[16:03:19.513]         {
[16:03:19.513]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:19.513]                 ...future.oldOptions$nwarnings <- NULL
[16:03:19.513]             }
[16:03:19.513]             base::options(...future.oldOptions)
[16:03:19.513]             if (.Platform$OS.type == "windows") {
[16:03:19.513]                 old_names <- names(...future.oldEnvVars)
[16:03:19.513]                 envs <- base::Sys.getenv()
[16:03:19.513]                 names <- names(envs)
[16:03:19.513]                 common <- intersect(names, old_names)
[16:03:19.513]                 added <- setdiff(names, old_names)
[16:03:19.513]                 removed <- setdiff(old_names, names)
[16:03:19.513]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:19.513]                   envs[common]]
[16:03:19.513]                 NAMES <- toupper(changed)
[16:03:19.513]                 args <- list()
[16:03:19.513]                 for (kk in seq_along(NAMES)) {
[16:03:19.513]                   name <- changed[[kk]]
[16:03:19.513]                   NAME <- NAMES[[kk]]
[16:03:19.513]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.513]                     next
[16:03:19.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:19.513]                 }
[16:03:19.513]                 NAMES <- toupper(added)
[16:03:19.513]                 for (kk in seq_along(NAMES)) {
[16:03:19.513]                   name <- added[[kk]]
[16:03:19.513]                   NAME <- NAMES[[kk]]
[16:03:19.513]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.513]                     next
[16:03:19.513]                   args[[name]] <- ""
[16:03:19.513]                 }
[16:03:19.513]                 NAMES <- toupper(removed)
[16:03:19.513]                 for (kk in seq_along(NAMES)) {
[16:03:19.513]                   name <- removed[[kk]]
[16:03:19.513]                   NAME <- NAMES[[kk]]
[16:03:19.513]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.513]                     next
[16:03:19.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:19.513]                 }
[16:03:19.513]                 if (length(args) > 0) 
[16:03:19.513]                   base::do.call(base::Sys.setenv, args = args)
[16:03:19.513]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:19.513]             }
[16:03:19.513]             else {
[16:03:19.513]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:19.513]             }
[16:03:19.513]             {
[16:03:19.513]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:19.513]                   0L) {
[16:03:19.513]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:19.513]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:19.513]                   base::options(opts)
[16:03:19.513]                 }
[16:03:19.513]                 {
[16:03:19.513]                   {
[16:03:19.513]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:19.513]                     NULL
[16:03:19.513]                   }
[16:03:19.513]                   options(future.plan = NULL)
[16:03:19.513]                   if (is.na(NA_character_)) 
[16:03:19.513]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:19.513]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:19.513]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:19.513]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:19.513]                     envir = parent.frame()) 
[16:03:19.513]                   {
[16:03:19.513]                     if (is.function(workers)) 
[16:03:19.513]                       workers <- workers()
[16:03:19.513]                     workers <- structure(as.integer(workers), 
[16:03:19.513]                       class = class(workers))
[16:03:19.513]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:19.513]                       workers >= 1)
[16:03:19.513]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:19.513]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:19.513]                     }
[16:03:19.513]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:19.513]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:19.513]                       envir = envir)
[16:03:19.513]                     if (!future$lazy) 
[16:03:19.513]                       future <- run(future)
[16:03:19.513]                     invisible(future)
[16:03:19.513]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:19.513]                 }
[16:03:19.513]             }
[16:03:19.513]         }
[16:03:19.513]     })
[16:03:19.513]     if (TRUE) {
[16:03:19.513]         base::sink(type = "output", split = FALSE)
[16:03:19.513]         if (TRUE) {
[16:03:19.513]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:19.513]         }
[16:03:19.513]         else {
[16:03:19.513]             ...future.result["stdout"] <- base::list(NULL)
[16:03:19.513]         }
[16:03:19.513]         base::close(...future.stdout)
[16:03:19.513]         ...future.stdout <- NULL
[16:03:19.513]     }
[16:03:19.513]     ...future.result$conditions <- ...future.conditions
[16:03:19.513]     ...future.result$finished <- base::Sys.time()
[16:03:19.513]     ...future.result
[16:03:19.513] }
[16:03:19.516] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[16:03:19.516] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:19.559] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:19.559] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[16:03:19.560] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:03:19.560] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:19.560] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:19.560] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:19.603] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:19.603] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:19.647] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:19.647] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:03:19.648] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:03:19.648] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:03:19.648] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:03:19.648] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:19.649] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:19.649] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[16:03:19.649] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[16:03:19.649] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:19.650] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:19.650] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:19.650] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:19.650] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[16:03:19.651] MultisessionFuture started
[16:03:19.651] - Launch lazy future ... done
[16:03:19.651] run() for ‘MultisessionFuture’ ... done
[16:03:19.651] Created future:
[16:03:19.651] MultisessionFuture:
[16:03:19.651] Label: ‘future_vapply-1’
[16:03:19.651] Expression:
[16:03:19.651] {
[16:03:19.651]     do.call(function(...) {
[16:03:19.651]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.651]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:19.651]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.651]             on.exit(options(oopts), add = TRUE)
[16:03:19.651]         }
[16:03:19.651]         {
[16:03:19.651]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:19.651]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.651]                 ...future.FUN(...future.X_jj, ...)
[16:03:19.651]             })
[16:03:19.651]         }
[16:03:19.651]     }, args = future.call.arguments)
[16:03:19.651] }
[16:03:19.651] Lazy evaluation: FALSE
[16:03:19.651] Asynchronous evaluation: TRUE
[16:03:19.651] Local evaluation: TRUE
[16:03:19.651] Environment: R_GlobalEnv
[16:03:19.651] Capture standard output: TRUE
[16:03:19.651] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:19.651] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:19.651] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:03:19.651] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:19.651] Resolved: FALSE
[16:03:19.651] Value: <not collected>
[16:03:19.651] Conditions captured: <none>
[16:03:19.651] Early signaling: FALSE
[16:03:19.651] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:19.651] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:19.663] Chunk #1 of 2 ... DONE
[16:03:19.663] Chunk #2 of 2 ...
[16:03:19.663]  - Finding globals in 'X' for chunk #2 ...
[16:03:19.664] getGlobalsAndPackages() ...
[16:03:19.664] Searching for globals...
[16:03:19.664] 
[16:03:19.664] Searching for globals ... DONE
[16:03:19.664] - globals: [0] <none>
[16:03:19.664] getGlobalsAndPackages() ... DONE
[16:03:19.664]    + additional globals found: [n=0] 
[16:03:19.664]    + additional namespaces needed: [n=0] 
[16:03:19.665]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:19.665]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:19.665]  - seeds: <none>
[16:03:19.665]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.665] getGlobalsAndPackages() ...
[16:03:19.665] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.665] Resolving globals: FALSE
[16:03:19.665] Tweak future expression to call with '...' arguments ...
[16:03:19.665] {
[16:03:19.665]     do.call(function(...) {
[16:03:19.665]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.665]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:19.665]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.665]             on.exit(options(oopts), add = TRUE)
[16:03:19.665]         }
[16:03:19.665]         {
[16:03:19.665]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:19.665]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.665]                 ...future.FUN(...future.X_jj, ...)
[16:03:19.665]             })
[16:03:19.665]         }
[16:03:19.665]     }, args = future.call.arguments)
[16:03:19.665] }
[16:03:19.666] Tweak future expression to call with '...' arguments ... DONE
[16:03:19.666] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.666] - packages: [2] ‘stats’, ‘future.apply’
[16:03:19.666] getGlobalsAndPackages() ... DONE
[16:03:19.667] run() for ‘Future’ ...
[16:03:19.667] - state: ‘created’
[16:03:19.667] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:19.681] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:19.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:19.682]   - Field: ‘node’
[16:03:19.682]   - Field: ‘label’
[16:03:19.682]   - Field: ‘local’
[16:03:19.682]   - Field: ‘owner’
[16:03:19.682]   - Field: ‘envir’
[16:03:19.682]   - Field: ‘workers’
[16:03:19.682]   - Field: ‘packages’
[16:03:19.682]   - Field: ‘gc’
[16:03:19.682]   - Field: ‘conditions’
[16:03:19.682]   - Field: ‘persistent’
[16:03:19.683]   - Field: ‘expr’
[16:03:19.683]   - Field: ‘uuid’
[16:03:19.683]   - Field: ‘seed’
[16:03:19.683]   - Field: ‘version’
[16:03:19.683]   - Field: ‘result’
[16:03:19.683]   - Field: ‘asynchronous’
[16:03:19.683]   - Field: ‘calls’
[16:03:19.683]   - Field: ‘globals’
[16:03:19.683]   - Field: ‘stdout’
[16:03:19.684]   - Field: ‘earlySignal’
[16:03:19.684]   - Field: ‘lazy’
[16:03:19.684]   - Field: ‘state’
[16:03:19.684] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:19.684] - Launch lazy future ...
[16:03:19.684] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:03:19.684] Packages needed by future strategies (n = 0): <none>
[16:03:19.685] {
[16:03:19.685]     {
[16:03:19.685]         {
[16:03:19.685]             ...future.startTime <- base::Sys.time()
[16:03:19.685]             {
[16:03:19.685]                 {
[16:03:19.685]                   {
[16:03:19.685]                     {
[16:03:19.685]                       {
[16:03:19.685]                         base::local({
[16:03:19.685]                           has_future <- base::requireNamespace("future", 
[16:03:19.685]                             quietly = TRUE)
[16:03:19.685]                           if (has_future) {
[16:03:19.685]                             ns <- base::getNamespace("future")
[16:03:19.685]                             version <- ns[[".package"]][["version"]]
[16:03:19.685]                             if (is.null(version)) 
[16:03:19.685]                               version <- utils::packageVersion("future")
[16:03:19.685]                           }
[16:03:19.685]                           else {
[16:03:19.685]                             version <- NULL
[16:03:19.685]                           }
[16:03:19.685]                           if (!has_future || version < "1.8.0") {
[16:03:19.685]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:19.685]                               "", base::R.version$version.string), 
[16:03:19.685]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:19.685]                                 base::R.version$platform, 8 * 
[16:03:19.685]                                   base::.Machine$sizeof.pointer), 
[16:03:19.685]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:19.685]                                 "release", "version")], collapse = " "), 
[16:03:19.685]                               hostname = base::Sys.info()[["nodename"]])
[16:03:19.685]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:19.685]                               info)
[16:03:19.685]                             info <- base::paste(info, collapse = "; ")
[16:03:19.685]                             if (!has_future) {
[16:03:19.685]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:19.685]                                 info)
[16:03:19.685]                             }
[16:03:19.685]                             else {
[16:03:19.685]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:19.685]                                 info, version)
[16:03:19.685]                             }
[16:03:19.685]                             base::stop(msg)
[16:03:19.685]                           }
[16:03:19.685]                         })
[16:03:19.685]                       }
[16:03:19.685]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:19.685]                       base::options(mc.cores = 1L)
[16:03:19.685]                     }
[16:03:19.685]                     base::local({
[16:03:19.685]                       for (pkg in c("stats", "future.apply")) {
[16:03:19.685]                         base::loadNamespace(pkg)
[16:03:19.685]                         base::library(pkg, character.only = TRUE)
[16:03:19.685]                       }
[16:03:19.685]                     })
[16:03:19.685]                   }
[16:03:19.685]                   options(future.plan = NULL)
[16:03:19.685]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:19.685]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:19.685]                 }
[16:03:19.685]                 ...future.workdir <- getwd()
[16:03:19.685]             }
[16:03:19.685]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:19.685]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:19.685]         }
[16:03:19.685]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:19.685]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:19.685]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:19.685]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:19.685]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:19.685]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:19.685]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:19.685]             base::names(...future.oldOptions))
[16:03:19.685]     }
[16:03:19.685]     if (FALSE) {
[16:03:19.685]     }
[16:03:19.685]     else {
[16:03:19.685]         if (TRUE) {
[16:03:19.685]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:19.685]                 open = "w")
[16:03:19.685]         }
[16:03:19.685]         else {
[16:03:19.685]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:19.685]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:19.685]         }
[16:03:19.685]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:19.685]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:19.685]             base::sink(type = "output", split = FALSE)
[16:03:19.685]             base::close(...future.stdout)
[16:03:19.685]         }, add = TRUE)
[16:03:19.685]     }
[16:03:19.685]     ...future.frame <- base::sys.nframe()
[16:03:19.685]     ...future.conditions <- base::list()
[16:03:19.685]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:19.685]     if (FALSE) {
[16:03:19.685]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:19.685]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:19.685]     }
[16:03:19.685]     ...future.result <- base::tryCatch({
[16:03:19.685]         base::withCallingHandlers({
[16:03:19.685]             ...future.value <- base::withVisible(base::local({
[16:03:19.685]                 ...future.makeSendCondition <- base::local({
[16:03:19.685]                   sendCondition <- NULL
[16:03:19.685]                   function(frame = 1L) {
[16:03:19.685]                     if (is.function(sendCondition)) 
[16:03:19.685]                       return(sendCondition)
[16:03:19.685]                     ns <- getNamespace("parallel")
[16:03:19.685]                     if (exists("sendData", mode = "function", 
[16:03:19.685]                       envir = ns)) {
[16:03:19.685]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:19.685]                         envir = ns)
[16:03:19.685]                       envir <- sys.frame(frame)
[16:03:19.685]                       master <- NULL
[16:03:19.685]                       while (!identical(envir, .GlobalEnv) && 
[16:03:19.685]                         !identical(envir, emptyenv())) {
[16:03:19.685]                         if (exists("master", mode = "list", envir = envir, 
[16:03:19.685]                           inherits = FALSE)) {
[16:03:19.685]                           master <- get("master", mode = "list", 
[16:03:19.685]                             envir = envir, inherits = FALSE)
[16:03:19.685]                           if (inherits(master, c("SOCKnode", 
[16:03:19.685]                             "SOCK0node"))) {
[16:03:19.685]                             sendCondition <<- function(cond) {
[16:03:19.685]                               data <- list(type = "VALUE", value = cond, 
[16:03:19.685]                                 success = TRUE)
[16:03:19.685]                               parallel_sendData(master, data)
[16:03:19.685]                             }
[16:03:19.685]                             return(sendCondition)
[16:03:19.685]                           }
[16:03:19.685]                         }
[16:03:19.685]                         frame <- frame + 1L
[16:03:19.685]                         envir <- sys.frame(frame)
[16:03:19.685]                       }
[16:03:19.685]                     }
[16:03:19.685]                     sendCondition <<- function(cond) NULL
[16:03:19.685]                   }
[16:03:19.685]                 })
[16:03:19.685]                 withCallingHandlers({
[16:03:19.685]                   {
[16:03:19.685]                     do.call(function(...) {
[16:03:19.685]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.685]                       if (!identical(...future.globals.maxSize.org, 
[16:03:19.685]                         ...future.globals.maxSize)) {
[16:03:19.685]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.685]                         on.exit(options(oopts), add = TRUE)
[16:03:19.685]                       }
[16:03:19.685]                       {
[16:03:19.685]                         lapply(seq_along(...future.elements_ii), 
[16:03:19.685]                           FUN = function(jj) {
[16:03:19.685]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.685]                             ...future.FUN(...future.X_jj, ...)
[16:03:19.685]                           })
[16:03:19.685]                       }
[16:03:19.685]                     }, args = future.call.arguments)
[16:03:19.685]                   }
[16:03:19.685]                 }, immediateCondition = function(cond) {
[16:03:19.685]                   sendCondition <- ...future.makeSendCondition()
[16:03:19.685]                   sendCondition(cond)
[16:03:19.685]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.685]                   {
[16:03:19.685]                     inherits <- base::inherits
[16:03:19.685]                     invokeRestart <- base::invokeRestart
[16:03:19.685]                     is.null <- base::is.null
[16:03:19.685]                     muffled <- FALSE
[16:03:19.685]                     if (inherits(cond, "message")) {
[16:03:19.685]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:19.685]                       if (muffled) 
[16:03:19.685]                         invokeRestart("muffleMessage")
[16:03:19.685]                     }
[16:03:19.685]                     else if (inherits(cond, "warning")) {
[16:03:19.685]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:19.685]                       if (muffled) 
[16:03:19.685]                         invokeRestart("muffleWarning")
[16:03:19.685]                     }
[16:03:19.685]                     else if (inherits(cond, "condition")) {
[16:03:19.685]                       if (!is.null(pattern)) {
[16:03:19.685]                         computeRestarts <- base::computeRestarts
[16:03:19.685]                         grepl <- base::grepl
[16:03:19.685]                         restarts <- computeRestarts(cond)
[16:03:19.685]                         for (restart in restarts) {
[16:03:19.685]                           name <- restart$name
[16:03:19.685]                           if (is.null(name)) 
[16:03:19.685]                             next
[16:03:19.685]                           if (!grepl(pattern, name)) 
[16:03:19.685]                             next
[16:03:19.685]                           invokeRestart(restart)
[16:03:19.685]                           muffled <- TRUE
[16:03:19.685]                           break
[16:03:19.685]                         }
[16:03:19.685]                       }
[16:03:19.685]                     }
[16:03:19.685]                     invisible(muffled)
[16:03:19.685]                   }
[16:03:19.685]                   muffleCondition(cond)
[16:03:19.685]                 })
[16:03:19.685]             }))
[16:03:19.685]             future::FutureResult(value = ...future.value$value, 
[16:03:19.685]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:19.685]                   ...future.rng), globalenv = if (FALSE) 
[16:03:19.685]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:19.685]                     ...future.globalenv.names))
[16:03:19.685]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:19.685]         }, condition = base::local({
[16:03:19.685]             c <- base::c
[16:03:19.685]             inherits <- base::inherits
[16:03:19.685]             invokeRestart <- base::invokeRestart
[16:03:19.685]             length <- base::length
[16:03:19.685]             list <- base::list
[16:03:19.685]             seq.int <- base::seq.int
[16:03:19.685]             signalCondition <- base::signalCondition
[16:03:19.685]             sys.calls <- base::sys.calls
[16:03:19.685]             `[[` <- base::`[[`
[16:03:19.685]             `+` <- base::`+`
[16:03:19.685]             `<<-` <- base::`<<-`
[16:03:19.685]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:19.685]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:19.685]                   3L)]
[16:03:19.685]             }
[16:03:19.685]             function(cond) {
[16:03:19.685]                 is_error <- inherits(cond, "error")
[16:03:19.685]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:19.685]                   NULL)
[16:03:19.685]                 if (is_error) {
[16:03:19.685]                   sessionInformation <- function() {
[16:03:19.685]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:19.685]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:19.685]                       search = base::search(), system = base::Sys.info())
[16:03:19.685]                   }
[16:03:19.685]                   ...future.conditions[[length(...future.conditions) + 
[16:03:19.685]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:19.685]                     cond$call), session = sessionInformation(), 
[16:03:19.685]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:19.685]                   signalCondition(cond)
[16:03:19.685]                 }
[16:03:19.685]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:19.685]                 "immediateCondition"))) {
[16:03:19.685]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:19.685]                   ...future.conditions[[length(...future.conditions) + 
[16:03:19.685]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:19.685]                   if (TRUE && !signal) {
[16:03:19.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.685]                     {
[16:03:19.685]                       inherits <- base::inherits
[16:03:19.685]                       invokeRestart <- base::invokeRestart
[16:03:19.685]                       is.null <- base::is.null
[16:03:19.685]                       muffled <- FALSE
[16:03:19.685]                       if (inherits(cond, "message")) {
[16:03:19.685]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:19.685]                         if (muffled) 
[16:03:19.685]                           invokeRestart("muffleMessage")
[16:03:19.685]                       }
[16:03:19.685]                       else if (inherits(cond, "warning")) {
[16:03:19.685]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:19.685]                         if (muffled) 
[16:03:19.685]                           invokeRestart("muffleWarning")
[16:03:19.685]                       }
[16:03:19.685]                       else if (inherits(cond, "condition")) {
[16:03:19.685]                         if (!is.null(pattern)) {
[16:03:19.685]                           computeRestarts <- base::computeRestarts
[16:03:19.685]                           grepl <- base::grepl
[16:03:19.685]                           restarts <- computeRestarts(cond)
[16:03:19.685]                           for (restart in restarts) {
[16:03:19.685]                             name <- restart$name
[16:03:19.685]                             if (is.null(name)) 
[16:03:19.685]                               next
[16:03:19.685]                             if (!grepl(pattern, name)) 
[16:03:19.685]                               next
[16:03:19.685]                             invokeRestart(restart)
[16:03:19.685]                             muffled <- TRUE
[16:03:19.685]                             break
[16:03:19.685]                           }
[16:03:19.685]                         }
[16:03:19.685]                       }
[16:03:19.685]                       invisible(muffled)
[16:03:19.685]                     }
[16:03:19.685]                     muffleCondition(cond, pattern = "^muffle")
[16:03:19.685]                   }
[16:03:19.685]                 }
[16:03:19.685]                 else {
[16:03:19.685]                   if (TRUE) {
[16:03:19.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.685]                     {
[16:03:19.685]                       inherits <- base::inherits
[16:03:19.685]                       invokeRestart <- base::invokeRestart
[16:03:19.685]                       is.null <- base::is.null
[16:03:19.685]                       muffled <- FALSE
[16:03:19.685]                       if (inherits(cond, "message")) {
[16:03:19.685]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:19.685]                         if (muffled) 
[16:03:19.685]                           invokeRestart("muffleMessage")
[16:03:19.685]                       }
[16:03:19.685]                       else if (inherits(cond, "warning")) {
[16:03:19.685]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:19.685]                         if (muffled) 
[16:03:19.685]                           invokeRestart("muffleWarning")
[16:03:19.685]                       }
[16:03:19.685]                       else if (inherits(cond, "condition")) {
[16:03:19.685]                         if (!is.null(pattern)) {
[16:03:19.685]                           computeRestarts <- base::computeRestarts
[16:03:19.685]                           grepl <- base::grepl
[16:03:19.685]                           restarts <- computeRestarts(cond)
[16:03:19.685]                           for (restart in restarts) {
[16:03:19.685]                             name <- restart$name
[16:03:19.685]                             if (is.null(name)) 
[16:03:19.685]                               next
[16:03:19.685]                             if (!grepl(pattern, name)) 
[16:03:19.685]                               next
[16:03:19.685]                             invokeRestart(restart)
[16:03:19.685]                             muffled <- TRUE
[16:03:19.685]                             break
[16:03:19.685]                           }
[16:03:19.685]                         }
[16:03:19.685]                       }
[16:03:19.685]                       invisible(muffled)
[16:03:19.685]                     }
[16:03:19.685]                     muffleCondition(cond, pattern = "^muffle")
[16:03:19.685]                   }
[16:03:19.685]                 }
[16:03:19.685]             }
[16:03:19.685]         }))
[16:03:19.685]     }, error = function(ex) {
[16:03:19.685]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:19.685]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:19.685]                 ...future.rng), started = ...future.startTime, 
[16:03:19.685]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:19.685]             version = "1.8"), class = "FutureResult")
[16:03:19.685]     }, finally = {
[16:03:19.685]         if (!identical(...future.workdir, getwd())) 
[16:03:19.685]             setwd(...future.workdir)
[16:03:19.685]         {
[16:03:19.685]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:19.685]                 ...future.oldOptions$nwarnings <- NULL
[16:03:19.685]             }
[16:03:19.685]             base::options(...future.oldOptions)
[16:03:19.685]             if (.Platform$OS.type == "windows") {
[16:03:19.685]                 old_names <- names(...future.oldEnvVars)
[16:03:19.685]                 envs <- base::Sys.getenv()
[16:03:19.685]                 names <- names(envs)
[16:03:19.685]                 common <- intersect(names, old_names)
[16:03:19.685]                 added <- setdiff(names, old_names)
[16:03:19.685]                 removed <- setdiff(old_names, names)
[16:03:19.685]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:19.685]                   envs[common]]
[16:03:19.685]                 NAMES <- toupper(changed)
[16:03:19.685]                 args <- list()
[16:03:19.685]                 for (kk in seq_along(NAMES)) {
[16:03:19.685]                   name <- changed[[kk]]
[16:03:19.685]                   NAME <- NAMES[[kk]]
[16:03:19.685]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.685]                     next
[16:03:19.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:19.685]                 }
[16:03:19.685]                 NAMES <- toupper(added)
[16:03:19.685]                 for (kk in seq_along(NAMES)) {
[16:03:19.685]                   name <- added[[kk]]
[16:03:19.685]                   NAME <- NAMES[[kk]]
[16:03:19.685]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.685]                     next
[16:03:19.685]                   args[[name]] <- ""
[16:03:19.685]                 }
[16:03:19.685]                 NAMES <- toupper(removed)
[16:03:19.685]                 for (kk in seq_along(NAMES)) {
[16:03:19.685]                   name <- removed[[kk]]
[16:03:19.685]                   NAME <- NAMES[[kk]]
[16:03:19.685]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.685]                     next
[16:03:19.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:19.685]                 }
[16:03:19.685]                 if (length(args) > 0) 
[16:03:19.685]                   base::do.call(base::Sys.setenv, args = args)
[16:03:19.685]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:19.685]             }
[16:03:19.685]             else {
[16:03:19.685]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:19.685]             }
[16:03:19.685]             {
[16:03:19.685]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:19.685]                   0L) {
[16:03:19.685]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:19.685]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:19.685]                   base::options(opts)
[16:03:19.685]                 }
[16:03:19.685]                 {
[16:03:19.685]                   {
[16:03:19.685]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:19.685]                     NULL
[16:03:19.685]                   }
[16:03:19.685]                   options(future.plan = NULL)
[16:03:19.685]                   if (is.na(NA_character_)) 
[16:03:19.685]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:19.685]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:19.685]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:19.685]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:19.685]                     envir = parent.frame()) 
[16:03:19.685]                   {
[16:03:19.685]                     if (is.function(workers)) 
[16:03:19.685]                       workers <- workers()
[16:03:19.685]                     workers <- structure(as.integer(workers), 
[16:03:19.685]                       class = class(workers))
[16:03:19.685]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:19.685]                       workers >= 1)
[16:03:19.685]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:19.685]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:19.685]                     }
[16:03:19.685]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:19.685]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:19.685]                       envir = envir)
[16:03:19.685]                     if (!future$lazy) 
[16:03:19.685]                       future <- run(future)
[16:03:19.685]                     invisible(future)
[16:03:19.685]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:19.685]                 }
[16:03:19.685]             }
[16:03:19.685]         }
[16:03:19.685]     })
[16:03:19.685]     if (TRUE) {
[16:03:19.685]         base::sink(type = "output", split = FALSE)
[16:03:19.685]         if (TRUE) {
[16:03:19.685]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:19.685]         }
[16:03:19.685]         else {
[16:03:19.685]             ...future.result["stdout"] <- base::list(NULL)
[16:03:19.685]         }
[16:03:19.685]         base::close(...future.stdout)
[16:03:19.685]         ...future.stdout <- NULL
[16:03:19.685]     }
[16:03:19.685]     ...future.result$conditions <- ...future.conditions
[16:03:19.685]     ...future.result$finished <- base::Sys.time()
[16:03:19.685]     ...future.result
[16:03:19.685] }
[16:03:19.688] Exporting 11 global objects (93.29 KiB) to cluster node #2 ...
[16:03:19.688] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:19.731] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:19.731] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ...
[16:03:19.732] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:03:19.732] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:19.732] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:19.732] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:19.775] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:19.775] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:19.819] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:19.819] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:03:19.820] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:03:19.820] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:03:19.820] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:03:19.821] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:19.821] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:19.821] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ...
[16:03:19.821] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ... DONE
[16:03:19.822] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:19.822] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:19.822] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:19.822] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:19.823] Exporting 11 global objects (93.29 KiB) to cluster node #2 ... DONE
[16:03:19.823] MultisessionFuture started
[16:03:19.823] - Launch lazy future ... done
[16:03:19.824] run() for ‘MultisessionFuture’ ... done
[16:03:19.824] Created future:
[16:03:19.824] MultisessionFuture:
[16:03:19.824] Label: ‘future_vapply-2’
[16:03:19.824] Expression:
[16:03:19.824] {
[16:03:19.824]     do.call(function(...) {
[16:03:19.824]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.824]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:19.824]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.824]             on.exit(options(oopts), add = TRUE)
[16:03:19.824]         }
[16:03:19.824]         {
[16:03:19.824]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:19.824]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.824]                 ...future.FUN(...future.X_jj, ...)
[16:03:19.824]             })
[16:03:19.824]         }
[16:03:19.824]     }, args = future.call.arguments)
[16:03:19.824] }
[16:03:19.824] Lazy evaluation: FALSE
[16:03:19.824] Asynchronous evaluation: TRUE
[16:03:19.824] Local evaluation: TRUE
[16:03:19.824] Environment: R_GlobalEnv
[16:03:19.824] Capture standard output: TRUE
[16:03:19.824] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:19.824] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:19.824] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:03:19.824] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:19.824] Resolved: FALSE
[16:03:19.824] Value: <not collected>
[16:03:19.824] Conditions captured: <none>
[16:03:19.824] Early signaling: FALSE
[16:03:19.824] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:19.824] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:19.836] Chunk #2 of 2 ... DONE
[16:03:19.836] Launching 2 futures (chunks) ... DONE
[16:03:19.836] Resolving 2 futures (chunks) ...
[16:03:19.836] resolve() on list ...
[16:03:19.836]  recursive: 0
[16:03:19.836]  length: 2
[16:03:19.836] 
[16:03:19.837] receiveMessageFromWorker() for ClusterFuture ...
[16:03:19.837] - Validating connection of MultisessionFuture
[16:03:19.837] - received message: FutureResult
[16:03:19.837] - Received FutureResult
[16:03:19.837] - Erased future from FutureRegistry
[16:03:19.837] result() for ClusterFuture ...
[16:03:19.837] - result already collected: FutureResult
[16:03:19.837] result() for ClusterFuture ... done
[16:03:19.838] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:19.838] Future #1
[16:03:19.838] result() for ClusterFuture ...
[16:03:19.838] - result already collected: FutureResult
[16:03:19.838] result() for ClusterFuture ... done
[16:03:19.838] result() for ClusterFuture ...
[16:03:19.838] - result already collected: FutureResult
[16:03:19.838] result() for ClusterFuture ... done
[16:03:19.838] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:19.838] - nx: 2
[16:03:19.838] - relay: TRUE
[16:03:19.839] - stdout: TRUE
[16:03:19.839] - signal: TRUE
[16:03:19.839] - resignal: FALSE
[16:03:19.839] - force: TRUE
[16:03:19.839] - relayed: [n=2] FALSE, FALSE
[16:03:19.839] - queued futures: [n=2] FALSE, FALSE
[16:03:19.839]  - until=1
[16:03:19.839]  - relaying element #1
[16:03:19.839] result() for ClusterFuture ...
[16:03:19.839] - result already collected: FutureResult
[16:03:19.839] result() for ClusterFuture ... done
[16:03:19.840] result() for ClusterFuture ...
[16:03:19.840] - result already collected: FutureResult
[16:03:19.840] result() for ClusterFuture ... done
[16:03:19.840] result() for ClusterFuture ...
[16:03:19.840] - result already collected: FutureResult
[16:03:19.840] result() for ClusterFuture ... done
[16:03:19.840] result() for ClusterFuture ...
[16:03:19.840] - result already collected: FutureResult
[16:03:19.840] result() for ClusterFuture ... done
[16:03:19.840] - relayed: [n=2] TRUE, FALSE
[16:03:19.840] - queued futures: [n=2] TRUE, FALSE
[16:03:19.841] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:19.841]  length: 1 (resolved future 1)
[16:03:19.882] receiveMessageFromWorker() for ClusterFuture ...
[16:03:19.883] - Validating connection of MultisessionFuture
[16:03:19.883] - received message: FutureResult
[16:03:19.883] - Received FutureResult
[16:03:19.883] - Erased future from FutureRegistry
[16:03:19.883] result() for ClusterFuture ...
[16:03:19.883] - result already collected: FutureResult
[16:03:19.883] result() for ClusterFuture ... done
[16:03:19.883] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:19.884] Future #2
[16:03:19.884] result() for ClusterFuture ...
[16:03:19.884] - result already collected: FutureResult
[16:03:19.884] result() for ClusterFuture ... done
[16:03:19.884] result() for ClusterFuture ...
[16:03:19.884] - result already collected: FutureResult
[16:03:19.884] result() for ClusterFuture ... done
[16:03:19.884] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:19.884] - nx: 2
[16:03:19.884] - relay: TRUE
[16:03:19.884] - stdout: TRUE
[16:03:19.885] - signal: TRUE
[16:03:19.885] - resignal: FALSE
[16:03:19.885] - force: TRUE
[16:03:19.885] - relayed: [n=2] TRUE, FALSE
[16:03:19.885] - queued futures: [n=2] TRUE, FALSE
[16:03:19.885]  - until=2
[16:03:19.885]  - relaying element #2
[16:03:19.885] result() for ClusterFuture ...
[16:03:19.885] - result already collected: FutureResult
[16:03:19.885] result() for ClusterFuture ... done
[16:03:19.885] result() for ClusterFuture ...
[16:03:19.885] - result already collected: FutureResult
[16:03:19.886] result() for ClusterFuture ... done
[16:03:19.886] result() for ClusterFuture ...
[16:03:19.886] - result already collected: FutureResult
[16:03:19.886] result() for ClusterFuture ... done
[16:03:19.886] result() for ClusterFuture ...
[16:03:19.886] - result already collected: FutureResult
[16:03:19.886] result() for ClusterFuture ... done
[16:03:19.886] - relayed: [n=2] TRUE, TRUE
[16:03:19.886] - queued futures: [n=2] TRUE, TRUE
[16:03:19.886] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:19.887]  length: 0 (resolved future 2)
[16:03:19.887] Relaying remaining futures
[16:03:19.887] signalConditionsASAP(NULL, pos=0) ...
[16:03:19.887] - nx: 2
[16:03:19.887] - relay: TRUE
[16:03:19.887] - stdout: TRUE
[16:03:19.887] - signal: TRUE
[16:03:19.887] - resignal: FALSE
[16:03:19.887] - force: TRUE
[16:03:19.887] - relayed: [n=2] TRUE, TRUE
[16:03:19.887] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:19.888] - relayed: [n=2] TRUE, TRUE
[16:03:19.888] - queued futures: [n=2] TRUE, TRUE
[16:03:19.888] signalConditionsASAP(NULL, pos=0) ... done
[16:03:19.888] resolve() on list ... DONE
[16:03:19.888] result() for ClusterFuture ...
[16:03:19.888] - result already collected: FutureResult
[16:03:19.888] result() for ClusterFuture ... done
[16:03:19.888] result() for ClusterFuture ...
[16:03:19.888] - result already collected: FutureResult
[16:03:19.888] result() for ClusterFuture ... done
[16:03:19.888] result() for ClusterFuture ...
[16:03:19.889] - result already collected: FutureResult
[16:03:19.889] result() for ClusterFuture ... done
[16:03:19.889] result() for ClusterFuture ...
[16:03:19.889] - result already collected: FutureResult
[16:03:19.889] result() for ClusterFuture ... done
[16:03:19.889]  - Number of value chunks collected: 2
[16:03:19.889] Resolving 2 futures (chunks) ... DONE
[16:03:19.889] Reducing values from 2 chunks ...
[16:03:19.889]  - Number of values collected after concatenation: 3
[16:03:19.889]  - Number of values expected: 3
[16:03:19.889] Reducing values from 2 chunks ... DONE
[16:03:19.889] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[16:03:19.891] future_lapply() ...
[16:03:19.898] Number of chunks: 2
[16:03:19.899] getGlobalsAndPackagesXApply() ...
[16:03:19.899]  - future.globals: TRUE
[16:03:19.899] getGlobalsAndPackages() ...
[16:03:19.899] Searching for globals...
[16:03:19.903] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:03:19.904] Searching for globals ... DONE
[16:03:19.904] Resolving globals: FALSE
[16:03:19.905] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[16:03:19.905] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[16:03:19.905] - globals: [1] ‘FUN’
[16:03:19.905] - packages: [1] ‘stats’
[16:03:19.905] getGlobalsAndPackages() ... DONE
[16:03:19.905]  - globals found/used: [n=1] ‘FUN’
[16:03:19.905]  - needed namespaces: [n=1] ‘stats’
[16:03:19.905] Finding globals ... DONE
[16:03:19.906]  - use_args: TRUE
[16:03:19.906]  - Getting '...' globals ...
[16:03:19.906] resolve() on list ...
[16:03:19.906]  recursive: 0
[16:03:19.906]  length: 1
[16:03:19.906]  elements: ‘...’
[16:03:19.906]  length: 0 (resolved future 1)
[16:03:19.906] resolve() on list ... DONE
[16:03:19.907]    - '...' content: [n=0] 
[16:03:19.907] List of 1
[16:03:19.907]  $ ...: list()
[16:03:19.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:19.907]  - attr(*, "where")=List of 1
[16:03:19.907]   ..$ ...:<environment: 0x564e45323e08> 
[16:03:19.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:19.907]  - attr(*, "resolved")= logi TRUE
[16:03:19.907]  - attr(*, "total_size")= num NA
[16:03:19.909]  - Getting '...' globals ... DONE
[16:03:19.909] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:19.909] List of 2
[16:03:19.909]  $ ...future.FUN:function (x, na.rm = TRUE)  
[16:03:19.909]  $ ...          : list()
[16:03:19.909]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:19.909]  - attr(*, "where")=List of 2
[16:03:19.909]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:19.909]   ..$ ...          :<environment: 0x564e45323e08> 
[16:03:19.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:19.909]  - attr(*, "resolved")= logi FALSE
[16:03:19.909]  - attr(*, "total_size")= num 46960
[16:03:19.912] Packages to be attached in all futures: [n=1] ‘stats’
[16:03:19.912] getGlobalsAndPackagesXApply() ... DONE
[16:03:19.912] Number of futures (= number of chunks): 2
[16:03:19.912] Launching 2 futures (chunks) ...
[16:03:19.912] Chunk #1 of 2 ...
[16:03:19.913]  - Finding globals in 'X' for chunk #1 ...
[16:03:19.913] getGlobalsAndPackages() ...
[16:03:19.913] Searching for globals...
[16:03:19.913] 
[16:03:19.913] Searching for globals ... DONE
[16:03:19.913] - globals: [0] <none>
[16:03:19.913] getGlobalsAndPackages() ... DONE
[16:03:19.913]    + additional globals found: [n=0] 
[16:03:19.913]    + additional namespaces needed: [n=0] 
[16:03:19.913]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:19.914]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:19.914]  - seeds: <none>
[16:03:19.914]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.914] getGlobalsAndPackages() ...
[16:03:19.914] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.914] Resolving globals: FALSE
[16:03:19.914] Tweak future expression to call with '...' arguments ...
[16:03:19.914] {
[16:03:19.914]     do.call(function(...) {
[16:03:19.914]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.914]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:19.914]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.914]             on.exit(options(oopts), add = TRUE)
[16:03:19.914]         }
[16:03:19.914]         {
[16:03:19.914]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:19.914]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.914]                 ...future.FUN(...future.X_jj, ...)
[16:03:19.914]             })
[16:03:19.914]         }
[16:03:19.914]     }, args = future.call.arguments)
[16:03:19.914] }
[16:03:19.915] Tweak future expression to call with '...' arguments ... DONE
[16:03:19.915] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.915] - packages: [1] ‘stats’
[16:03:19.915] getGlobalsAndPackages() ... DONE
[16:03:19.915] run() for ‘Future’ ...
[16:03:19.916] - state: ‘created’
[16:03:19.916] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:19.929] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:19.929] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:19.929]   - Field: ‘node’
[16:03:19.929]   - Field: ‘label’
[16:03:19.930]   - Field: ‘local’
[16:03:19.930]   - Field: ‘owner’
[16:03:19.930]   - Field: ‘envir’
[16:03:19.930]   - Field: ‘workers’
[16:03:19.930]   - Field: ‘packages’
[16:03:19.930]   - Field: ‘gc’
[16:03:19.930]   - Field: ‘conditions’
[16:03:19.930]   - Field: ‘persistent’
[16:03:19.930]   - Field: ‘expr’
[16:03:19.930]   - Field: ‘uuid’
[16:03:19.930]   - Field: ‘seed’
[16:03:19.931]   - Field: ‘version’
[16:03:19.931]   - Field: ‘result’
[16:03:19.931]   - Field: ‘asynchronous’
[16:03:19.931]   - Field: ‘calls’
[16:03:19.931]   - Field: ‘globals’
[16:03:19.931]   - Field: ‘stdout’
[16:03:19.931]   - Field: ‘earlySignal’
[16:03:19.931]   - Field: ‘lazy’
[16:03:19.931]   - Field: ‘state’
[16:03:19.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:19.932] - Launch lazy future ...
[16:03:19.932] Packages needed by the future expression (n = 1): ‘stats’
[16:03:19.932] Packages needed by future strategies (n = 0): <none>
[16:03:19.932] {
[16:03:19.932]     {
[16:03:19.932]         {
[16:03:19.932]             ...future.startTime <- base::Sys.time()
[16:03:19.932]             {
[16:03:19.932]                 {
[16:03:19.932]                   {
[16:03:19.932]                     {
[16:03:19.932]                       {
[16:03:19.932]                         base::local({
[16:03:19.932]                           has_future <- base::requireNamespace("future", 
[16:03:19.932]                             quietly = TRUE)
[16:03:19.932]                           if (has_future) {
[16:03:19.932]                             ns <- base::getNamespace("future")
[16:03:19.932]                             version <- ns[[".package"]][["version"]]
[16:03:19.932]                             if (is.null(version)) 
[16:03:19.932]                               version <- utils::packageVersion("future")
[16:03:19.932]                           }
[16:03:19.932]                           else {
[16:03:19.932]                             version <- NULL
[16:03:19.932]                           }
[16:03:19.932]                           if (!has_future || version < "1.8.0") {
[16:03:19.932]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:19.932]                               "", base::R.version$version.string), 
[16:03:19.932]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:19.932]                                 base::R.version$platform, 8 * 
[16:03:19.932]                                   base::.Machine$sizeof.pointer), 
[16:03:19.932]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:19.932]                                 "release", "version")], collapse = " "), 
[16:03:19.932]                               hostname = base::Sys.info()[["nodename"]])
[16:03:19.932]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:19.932]                               info)
[16:03:19.932]                             info <- base::paste(info, collapse = "; ")
[16:03:19.932]                             if (!has_future) {
[16:03:19.932]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:19.932]                                 info)
[16:03:19.932]                             }
[16:03:19.932]                             else {
[16:03:19.932]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:19.932]                                 info, version)
[16:03:19.932]                             }
[16:03:19.932]                             base::stop(msg)
[16:03:19.932]                           }
[16:03:19.932]                         })
[16:03:19.932]                       }
[16:03:19.932]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:19.932]                       base::options(mc.cores = 1L)
[16:03:19.932]                     }
[16:03:19.932]                     base::local({
[16:03:19.932]                       for (pkg in "stats") {
[16:03:19.932]                         base::loadNamespace(pkg)
[16:03:19.932]                         base::library(pkg, character.only = TRUE)
[16:03:19.932]                       }
[16:03:19.932]                     })
[16:03:19.932]                   }
[16:03:19.932]                   options(future.plan = NULL)
[16:03:19.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:19.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:19.932]                 }
[16:03:19.932]                 ...future.workdir <- getwd()
[16:03:19.932]             }
[16:03:19.932]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:19.932]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:19.932]         }
[16:03:19.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:19.932]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:19.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:19.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:19.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:19.932]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:19.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:19.932]             base::names(...future.oldOptions))
[16:03:19.932]     }
[16:03:19.932]     if (FALSE) {
[16:03:19.932]     }
[16:03:19.932]     else {
[16:03:19.932]         if (TRUE) {
[16:03:19.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:19.932]                 open = "w")
[16:03:19.932]         }
[16:03:19.932]         else {
[16:03:19.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:19.932]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:19.932]         }
[16:03:19.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:19.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:19.932]             base::sink(type = "output", split = FALSE)
[16:03:19.932]             base::close(...future.stdout)
[16:03:19.932]         }, add = TRUE)
[16:03:19.932]     }
[16:03:19.932]     ...future.frame <- base::sys.nframe()
[16:03:19.932]     ...future.conditions <- base::list()
[16:03:19.932]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:19.932]     if (FALSE) {
[16:03:19.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:19.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:19.932]     }
[16:03:19.932]     ...future.result <- base::tryCatch({
[16:03:19.932]         base::withCallingHandlers({
[16:03:19.932]             ...future.value <- base::withVisible(base::local({
[16:03:19.932]                 ...future.makeSendCondition <- base::local({
[16:03:19.932]                   sendCondition <- NULL
[16:03:19.932]                   function(frame = 1L) {
[16:03:19.932]                     if (is.function(sendCondition)) 
[16:03:19.932]                       return(sendCondition)
[16:03:19.932]                     ns <- getNamespace("parallel")
[16:03:19.932]                     if (exists("sendData", mode = "function", 
[16:03:19.932]                       envir = ns)) {
[16:03:19.932]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:19.932]                         envir = ns)
[16:03:19.932]                       envir <- sys.frame(frame)
[16:03:19.932]                       master <- NULL
[16:03:19.932]                       while (!identical(envir, .GlobalEnv) && 
[16:03:19.932]                         !identical(envir, emptyenv())) {
[16:03:19.932]                         if (exists("master", mode = "list", envir = envir, 
[16:03:19.932]                           inherits = FALSE)) {
[16:03:19.932]                           master <- get("master", mode = "list", 
[16:03:19.932]                             envir = envir, inherits = FALSE)
[16:03:19.932]                           if (inherits(master, c("SOCKnode", 
[16:03:19.932]                             "SOCK0node"))) {
[16:03:19.932]                             sendCondition <<- function(cond) {
[16:03:19.932]                               data <- list(type = "VALUE", value = cond, 
[16:03:19.932]                                 success = TRUE)
[16:03:19.932]                               parallel_sendData(master, data)
[16:03:19.932]                             }
[16:03:19.932]                             return(sendCondition)
[16:03:19.932]                           }
[16:03:19.932]                         }
[16:03:19.932]                         frame <- frame + 1L
[16:03:19.932]                         envir <- sys.frame(frame)
[16:03:19.932]                       }
[16:03:19.932]                     }
[16:03:19.932]                     sendCondition <<- function(cond) NULL
[16:03:19.932]                   }
[16:03:19.932]                 })
[16:03:19.932]                 withCallingHandlers({
[16:03:19.932]                   {
[16:03:19.932]                     do.call(function(...) {
[16:03:19.932]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.932]                       if (!identical(...future.globals.maxSize.org, 
[16:03:19.932]                         ...future.globals.maxSize)) {
[16:03:19.932]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.932]                         on.exit(options(oopts), add = TRUE)
[16:03:19.932]                       }
[16:03:19.932]                       {
[16:03:19.932]                         lapply(seq_along(...future.elements_ii), 
[16:03:19.932]                           FUN = function(jj) {
[16:03:19.932]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.932]                             ...future.FUN(...future.X_jj, ...)
[16:03:19.932]                           })
[16:03:19.932]                       }
[16:03:19.932]                     }, args = future.call.arguments)
[16:03:19.932]                   }
[16:03:19.932]                 }, immediateCondition = function(cond) {
[16:03:19.932]                   sendCondition <- ...future.makeSendCondition()
[16:03:19.932]                   sendCondition(cond)
[16:03:19.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.932]                   {
[16:03:19.932]                     inherits <- base::inherits
[16:03:19.932]                     invokeRestart <- base::invokeRestart
[16:03:19.932]                     is.null <- base::is.null
[16:03:19.932]                     muffled <- FALSE
[16:03:19.932]                     if (inherits(cond, "message")) {
[16:03:19.932]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:19.932]                       if (muffled) 
[16:03:19.932]                         invokeRestart("muffleMessage")
[16:03:19.932]                     }
[16:03:19.932]                     else if (inherits(cond, "warning")) {
[16:03:19.932]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:19.932]                       if (muffled) 
[16:03:19.932]                         invokeRestart("muffleWarning")
[16:03:19.932]                     }
[16:03:19.932]                     else if (inherits(cond, "condition")) {
[16:03:19.932]                       if (!is.null(pattern)) {
[16:03:19.932]                         computeRestarts <- base::computeRestarts
[16:03:19.932]                         grepl <- base::grepl
[16:03:19.932]                         restarts <- computeRestarts(cond)
[16:03:19.932]                         for (restart in restarts) {
[16:03:19.932]                           name <- restart$name
[16:03:19.932]                           if (is.null(name)) 
[16:03:19.932]                             next
[16:03:19.932]                           if (!grepl(pattern, name)) 
[16:03:19.932]                             next
[16:03:19.932]                           invokeRestart(restart)
[16:03:19.932]                           muffled <- TRUE
[16:03:19.932]                           break
[16:03:19.932]                         }
[16:03:19.932]                       }
[16:03:19.932]                     }
[16:03:19.932]                     invisible(muffled)
[16:03:19.932]                   }
[16:03:19.932]                   muffleCondition(cond)
[16:03:19.932]                 })
[16:03:19.932]             }))
[16:03:19.932]             future::FutureResult(value = ...future.value$value, 
[16:03:19.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:19.932]                   ...future.rng), globalenv = if (FALSE) 
[16:03:19.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:19.932]                     ...future.globalenv.names))
[16:03:19.932]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:19.932]         }, condition = base::local({
[16:03:19.932]             c <- base::c
[16:03:19.932]             inherits <- base::inherits
[16:03:19.932]             invokeRestart <- base::invokeRestart
[16:03:19.932]             length <- base::length
[16:03:19.932]             list <- base::list
[16:03:19.932]             seq.int <- base::seq.int
[16:03:19.932]             signalCondition <- base::signalCondition
[16:03:19.932]             sys.calls <- base::sys.calls
[16:03:19.932]             `[[` <- base::`[[`
[16:03:19.932]             `+` <- base::`+`
[16:03:19.932]             `<<-` <- base::`<<-`
[16:03:19.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:19.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:19.932]                   3L)]
[16:03:19.932]             }
[16:03:19.932]             function(cond) {
[16:03:19.932]                 is_error <- inherits(cond, "error")
[16:03:19.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:19.932]                   NULL)
[16:03:19.932]                 if (is_error) {
[16:03:19.932]                   sessionInformation <- function() {
[16:03:19.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:19.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:19.932]                       search = base::search(), system = base::Sys.info())
[16:03:19.932]                   }
[16:03:19.932]                   ...future.conditions[[length(...future.conditions) + 
[16:03:19.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:19.932]                     cond$call), session = sessionInformation(), 
[16:03:19.932]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:19.932]                   signalCondition(cond)
[16:03:19.932]                 }
[16:03:19.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:19.932]                 "immediateCondition"))) {
[16:03:19.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:19.932]                   ...future.conditions[[length(...future.conditions) + 
[16:03:19.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:19.932]                   if (TRUE && !signal) {
[16:03:19.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.932]                     {
[16:03:19.932]                       inherits <- base::inherits
[16:03:19.932]                       invokeRestart <- base::invokeRestart
[16:03:19.932]                       is.null <- base::is.null
[16:03:19.932]                       muffled <- FALSE
[16:03:19.932]                       if (inherits(cond, "message")) {
[16:03:19.932]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:19.932]                         if (muffled) 
[16:03:19.932]                           invokeRestart("muffleMessage")
[16:03:19.932]                       }
[16:03:19.932]                       else if (inherits(cond, "warning")) {
[16:03:19.932]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:19.932]                         if (muffled) 
[16:03:19.932]                           invokeRestart("muffleWarning")
[16:03:19.932]                       }
[16:03:19.932]                       else if (inherits(cond, "condition")) {
[16:03:19.932]                         if (!is.null(pattern)) {
[16:03:19.932]                           computeRestarts <- base::computeRestarts
[16:03:19.932]                           grepl <- base::grepl
[16:03:19.932]                           restarts <- computeRestarts(cond)
[16:03:19.932]                           for (restart in restarts) {
[16:03:19.932]                             name <- restart$name
[16:03:19.932]                             if (is.null(name)) 
[16:03:19.932]                               next
[16:03:19.932]                             if (!grepl(pattern, name)) 
[16:03:19.932]                               next
[16:03:19.932]                             invokeRestart(restart)
[16:03:19.932]                             muffled <- TRUE
[16:03:19.932]                             break
[16:03:19.932]                           }
[16:03:19.932]                         }
[16:03:19.932]                       }
[16:03:19.932]                       invisible(muffled)
[16:03:19.932]                     }
[16:03:19.932]                     muffleCondition(cond, pattern = "^muffle")
[16:03:19.932]                   }
[16:03:19.932]                 }
[16:03:19.932]                 else {
[16:03:19.932]                   if (TRUE) {
[16:03:19.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:19.932]                     {
[16:03:19.932]                       inherits <- base::inherits
[16:03:19.932]                       invokeRestart <- base::invokeRestart
[16:03:19.932]                       is.null <- base::is.null
[16:03:19.932]                       muffled <- FALSE
[16:03:19.932]                       if (inherits(cond, "message")) {
[16:03:19.932]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:19.932]                         if (muffled) 
[16:03:19.932]                           invokeRestart("muffleMessage")
[16:03:19.932]                       }
[16:03:19.932]                       else if (inherits(cond, "warning")) {
[16:03:19.932]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:19.932]                         if (muffled) 
[16:03:19.932]                           invokeRestart("muffleWarning")
[16:03:19.932]                       }
[16:03:19.932]                       else if (inherits(cond, "condition")) {
[16:03:19.932]                         if (!is.null(pattern)) {
[16:03:19.932]                           computeRestarts <- base::computeRestarts
[16:03:19.932]                           grepl <- base::grepl
[16:03:19.932]                           restarts <- computeRestarts(cond)
[16:03:19.932]                           for (restart in restarts) {
[16:03:19.932]                             name <- restart$name
[16:03:19.932]                             if (is.null(name)) 
[16:03:19.932]                               next
[16:03:19.932]                             if (!grepl(pattern, name)) 
[16:03:19.932]                               next
[16:03:19.932]                             invokeRestart(restart)
[16:03:19.932]                             muffled <- TRUE
[16:03:19.932]                             break
[16:03:19.932]                           }
[16:03:19.932]                         }
[16:03:19.932]                       }
[16:03:19.932]                       invisible(muffled)
[16:03:19.932]                     }
[16:03:19.932]                     muffleCondition(cond, pattern = "^muffle")
[16:03:19.932]                   }
[16:03:19.932]                 }
[16:03:19.932]             }
[16:03:19.932]         }))
[16:03:19.932]     }, error = function(ex) {
[16:03:19.932]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:19.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:19.932]                 ...future.rng), started = ...future.startTime, 
[16:03:19.932]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:19.932]             version = "1.8"), class = "FutureResult")
[16:03:19.932]     }, finally = {
[16:03:19.932]         if (!identical(...future.workdir, getwd())) 
[16:03:19.932]             setwd(...future.workdir)
[16:03:19.932]         {
[16:03:19.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:19.932]                 ...future.oldOptions$nwarnings <- NULL
[16:03:19.932]             }
[16:03:19.932]             base::options(...future.oldOptions)
[16:03:19.932]             if (.Platform$OS.type == "windows") {
[16:03:19.932]                 old_names <- names(...future.oldEnvVars)
[16:03:19.932]                 envs <- base::Sys.getenv()
[16:03:19.932]                 names <- names(envs)
[16:03:19.932]                 common <- intersect(names, old_names)
[16:03:19.932]                 added <- setdiff(names, old_names)
[16:03:19.932]                 removed <- setdiff(old_names, names)
[16:03:19.932]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:19.932]                   envs[common]]
[16:03:19.932]                 NAMES <- toupper(changed)
[16:03:19.932]                 args <- list()
[16:03:19.932]                 for (kk in seq_along(NAMES)) {
[16:03:19.932]                   name <- changed[[kk]]
[16:03:19.932]                   NAME <- NAMES[[kk]]
[16:03:19.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.932]                     next
[16:03:19.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:19.932]                 }
[16:03:19.932]                 NAMES <- toupper(added)
[16:03:19.932]                 for (kk in seq_along(NAMES)) {
[16:03:19.932]                   name <- added[[kk]]
[16:03:19.932]                   NAME <- NAMES[[kk]]
[16:03:19.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.932]                     next
[16:03:19.932]                   args[[name]] <- ""
[16:03:19.932]                 }
[16:03:19.932]                 NAMES <- toupper(removed)
[16:03:19.932]                 for (kk in seq_along(NAMES)) {
[16:03:19.932]                   name <- removed[[kk]]
[16:03:19.932]                   NAME <- NAMES[[kk]]
[16:03:19.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:19.932]                     next
[16:03:19.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:19.932]                 }
[16:03:19.932]                 if (length(args) > 0) 
[16:03:19.932]                   base::do.call(base::Sys.setenv, args = args)
[16:03:19.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:19.932]             }
[16:03:19.932]             else {
[16:03:19.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:19.932]             }
[16:03:19.932]             {
[16:03:19.932]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:19.932]                   0L) {
[16:03:19.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:19.932]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:19.932]                   base::options(opts)
[16:03:19.932]                 }
[16:03:19.932]                 {
[16:03:19.932]                   {
[16:03:19.932]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:19.932]                     NULL
[16:03:19.932]                   }
[16:03:19.932]                   options(future.plan = NULL)
[16:03:19.932]                   if (is.na(NA_character_)) 
[16:03:19.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:19.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:19.932]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:19.932]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:19.932]                     envir = parent.frame()) 
[16:03:19.932]                   {
[16:03:19.932]                     if (is.function(workers)) 
[16:03:19.932]                       workers <- workers()
[16:03:19.932]                     workers <- structure(as.integer(workers), 
[16:03:19.932]                       class = class(workers))
[16:03:19.932]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:19.932]                       workers >= 1)
[16:03:19.932]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:19.932]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:19.932]                     }
[16:03:19.932]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:19.932]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:19.932]                       envir = envir)
[16:03:19.932]                     if (!future$lazy) 
[16:03:19.932]                       future <- run(future)
[16:03:19.932]                     invisible(future)
[16:03:19.932]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:19.932]                 }
[16:03:19.932]             }
[16:03:19.932]         }
[16:03:19.932]     })
[16:03:19.932]     if (TRUE) {
[16:03:19.932]         base::sink(type = "output", split = FALSE)
[16:03:19.932]         if (TRUE) {
[16:03:19.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:19.932]         }
[16:03:19.932]         else {
[16:03:19.932]             ...future.result["stdout"] <- base::list(NULL)
[16:03:19.932]         }
[16:03:19.932]         base::close(...future.stdout)
[16:03:19.932]         ...future.stdout <- NULL
[16:03:19.932]     }
[16:03:19.932]     ...future.result$conditions <- ...future.conditions
[16:03:19.932]     ...future.result$finished <- base::Sys.time()
[16:03:19.932]     ...future.result
[16:03:19.932] }
[16:03:19.936] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[16:03:19.936] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[16:03:19.979] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[16:03:19.979] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:19.980] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:19.980] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[16:03:19.980] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[16:03:19.980] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:19.983] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:19.983] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:19.984] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:19.984] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[16:03:19.984] MultisessionFuture started
[16:03:19.984] - Launch lazy future ... done
[16:03:19.985] run() for ‘MultisessionFuture’ ... done
[16:03:19.985] Created future:
[16:03:19.985] MultisessionFuture:
[16:03:19.985] Label: ‘future_sapply-1’
[16:03:19.985] Expression:
[16:03:19.985] {
[16:03:19.985]     do.call(function(...) {
[16:03:19.985]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.985]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:19.985]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.985]             on.exit(options(oopts), add = TRUE)
[16:03:19.985]         }
[16:03:19.985]         {
[16:03:19.985]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:19.985]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.985]                 ...future.FUN(...future.X_jj, ...)
[16:03:19.985]             })
[16:03:19.985]         }
[16:03:19.985]     }, args = future.call.arguments)
[16:03:19.985] }
[16:03:19.985] Lazy evaluation: FALSE
[16:03:19.985] Asynchronous evaluation: TRUE
[16:03:19.985] Local evaluation: TRUE
[16:03:19.985] Environment: R_GlobalEnv
[16:03:19.985] Capture standard output: TRUE
[16:03:19.985] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:19.985] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:19.985] Packages: 1 packages (‘stats’)
[16:03:19.985] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:19.985] Resolved: FALSE
[16:03:19.985] Value: <not collected>
[16:03:19.985] Conditions captured: <none>
[16:03:19.985] Early signaling: FALSE
[16:03:19.985] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:19.985] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:19.996] Chunk #1 of 2 ... DONE
[16:03:19.996] Chunk #2 of 2 ...
[16:03:19.996]  - Finding globals in 'X' for chunk #2 ...
[16:03:19.997] getGlobalsAndPackages() ...
[16:03:19.997] Searching for globals...
[16:03:19.997] 
[16:03:19.997] Searching for globals ... DONE
[16:03:19.997] - globals: [0] <none>
[16:03:19.997] getGlobalsAndPackages() ... DONE
[16:03:19.997]    + additional globals found: [n=0] 
[16:03:19.997]    + additional namespaces needed: [n=0] 
[16:03:19.997]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:19.998]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:19.998]  - seeds: <none>
[16:03:19.998]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.998] getGlobalsAndPackages() ...
[16:03:19.998] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.998] Resolving globals: FALSE
[16:03:19.998] Tweak future expression to call with '...' arguments ...
[16:03:19.998] {
[16:03:19.998]     do.call(function(...) {
[16:03:19.998]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:19.998]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:19.998]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:19.998]             on.exit(options(oopts), add = TRUE)
[16:03:19.998]         }
[16:03:19.998]         {
[16:03:19.998]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:19.998]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:19.998]                 ...future.FUN(...future.X_jj, ...)
[16:03:19.998]             })
[16:03:19.998]         }
[16:03:19.998]     }, args = future.call.arguments)
[16:03:19.998] }
[16:03:19.999] Tweak future expression to call with '...' arguments ... DONE
[16:03:19.999] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:19.999] - packages: [1] ‘stats’
[16:03:19.999] getGlobalsAndPackages() ... DONE
[16:03:19.999] run() for ‘Future’ ...
[16:03:19.999] - state: ‘created’
[16:03:20.000] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:20.014] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.014] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:20.014]   - Field: ‘node’
[16:03:20.014]   - Field: ‘label’
[16:03:20.014]   - Field: ‘local’
[16:03:20.014]   - Field: ‘owner’
[16:03:20.014]   - Field: ‘envir’
[16:03:20.014]   - Field: ‘workers’
[16:03:20.015]   - Field: ‘packages’
[16:03:20.015]   - Field: ‘gc’
[16:03:20.015]   - Field: ‘conditions’
[16:03:20.015]   - Field: ‘persistent’
[16:03:20.015]   - Field: ‘expr’
[16:03:20.015]   - Field: ‘uuid’
[16:03:20.015]   - Field: ‘seed’
[16:03:20.015]   - Field: ‘version’
[16:03:20.015]   - Field: ‘result’
[16:03:20.015]   - Field: ‘asynchronous’
[16:03:20.016]   - Field: ‘calls’
[16:03:20.016]   - Field: ‘globals’
[16:03:20.016]   - Field: ‘stdout’
[16:03:20.016]   - Field: ‘earlySignal’
[16:03:20.016]   - Field: ‘lazy’
[16:03:20.016]   - Field: ‘state’
[16:03:20.016] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:20.016] - Launch lazy future ...
[16:03:20.016] Packages needed by the future expression (n = 1): ‘stats’
[16:03:20.017] Packages needed by future strategies (n = 0): <none>
[16:03:20.017] {
[16:03:20.017]     {
[16:03:20.017]         {
[16:03:20.017]             ...future.startTime <- base::Sys.time()
[16:03:20.017]             {
[16:03:20.017]                 {
[16:03:20.017]                   {
[16:03:20.017]                     {
[16:03:20.017]                       {
[16:03:20.017]                         base::local({
[16:03:20.017]                           has_future <- base::requireNamespace("future", 
[16:03:20.017]                             quietly = TRUE)
[16:03:20.017]                           if (has_future) {
[16:03:20.017]                             ns <- base::getNamespace("future")
[16:03:20.017]                             version <- ns[[".package"]][["version"]]
[16:03:20.017]                             if (is.null(version)) 
[16:03:20.017]                               version <- utils::packageVersion("future")
[16:03:20.017]                           }
[16:03:20.017]                           else {
[16:03:20.017]                             version <- NULL
[16:03:20.017]                           }
[16:03:20.017]                           if (!has_future || version < "1.8.0") {
[16:03:20.017]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:20.017]                               "", base::R.version$version.string), 
[16:03:20.017]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:20.017]                                 base::R.version$platform, 8 * 
[16:03:20.017]                                   base::.Machine$sizeof.pointer), 
[16:03:20.017]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:20.017]                                 "release", "version")], collapse = " "), 
[16:03:20.017]                               hostname = base::Sys.info()[["nodename"]])
[16:03:20.017]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:20.017]                               info)
[16:03:20.017]                             info <- base::paste(info, collapse = "; ")
[16:03:20.017]                             if (!has_future) {
[16:03:20.017]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:20.017]                                 info)
[16:03:20.017]                             }
[16:03:20.017]                             else {
[16:03:20.017]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:20.017]                                 info, version)
[16:03:20.017]                             }
[16:03:20.017]                             base::stop(msg)
[16:03:20.017]                           }
[16:03:20.017]                         })
[16:03:20.017]                       }
[16:03:20.017]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:20.017]                       base::options(mc.cores = 1L)
[16:03:20.017]                     }
[16:03:20.017]                     base::local({
[16:03:20.017]                       for (pkg in "stats") {
[16:03:20.017]                         base::loadNamespace(pkg)
[16:03:20.017]                         base::library(pkg, character.only = TRUE)
[16:03:20.017]                       }
[16:03:20.017]                     })
[16:03:20.017]                   }
[16:03:20.017]                   options(future.plan = NULL)
[16:03:20.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:20.017]                 }
[16:03:20.017]                 ...future.workdir <- getwd()
[16:03:20.017]             }
[16:03:20.017]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:20.017]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:20.017]         }
[16:03:20.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:20.017]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:20.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:20.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:20.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:20.017]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:20.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:20.017]             base::names(...future.oldOptions))
[16:03:20.017]     }
[16:03:20.017]     if (FALSE) {
[16:03:20.017]     }
[16:03:20.017]     else {
[16:03:20.017]         if (TRUE) {
[16:03:20.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:20.017]                 open = "w")
[16:03:20.017]         }
[16:03:20.017]         else {
[16:03:20.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:20.017]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:20.017]         }
[16:03:20.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:20.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:20.017]             base::sink(type = "output", split = FALSE)
[16:03:20.017]             base::close(...future.stdout)
[16:03:20.017]         }, add = TRUE)
[16:03:20.017]     }
[16:03:20.017]     ...future.frame <- base::sys.nframe()
[16:03:20.017]     ...future.conditions <- base::list()
[16:03:20.017]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:20.017]     if (FALSE) {
[16:03:20.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:20.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:20.017]     }
[16:03:20.017]     ...future.result <- base::tryCatch({
[16:03:20.017]         base::withCallingHandlers({
[16:03:20.017]             ...future.value <- base::withVisible(base::local({
[16:03:20.017]                 ...future.makeSendCondition <- base::local({
[16:03:20.017]                   sendCondition <- NULL
[16:03:20.017]                   function(frame = 1L) {
[16:03:20.017]                     if (is.function(sendCondition)) 
[16:03:20.017]                       return(sendCondition)
[16:03:20.017]                     ns <- getNamespace("parallel")
[16:03:20.017]                     if (exists("sendData", mode = "function", 
[16:03:20.017]                       envir = ns)) {
[16:03:20.017]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:20.017]                         envir = ns)
[16:03:20.017]                       envir <- sys.frame(frame)
[16:03:20.017]                       master <- NULL
[16:03:20.017]                       while (!identical(envir, .GlobalEnv) && 
[16:03:20.017]                         !identical(envir, emptyenv())) {
[16:03:20.017]                         if (exists("master", mode = "list", envir = envir, 
[16:03:20.017]                           inherits = FALSE)) {
[16:03:20.017]                           master <- get("master", mode = "list", 
[16:03:20.017]                             envir = envir, inherits = FALSE)
[16:03:20.017]                           if (inherits(master, c("SOCKnode", 
[16:03:20.017]                             "SOCK0node"))) {
[16:03:20.017]                             sendCondition <<- function(cond) {
[16:03:20.017]                               data <- list(type = "VALUE", value = cond, 
[16:03:20.017]                                 success = TRUE)
[16:03:20.017]                               parallel_sendData(master, data)
[16:03:20.017]                             }
[16:03:20.017]                             return(sendCondition)
[16:03:20.017]                           }
[16:03:20.017]                         }
[16:03:20.017]                         frame <- frame + 1L
[16:03:20.017]                         envir <- sys.frame(frame)
[16:03:20.017]                       }
[16:03:20.017]                     }
[16:03:20.017]                     sendCondition <<- function(cond) NULL
[16:03:20.017]                   }
[16:03:20.017]                 })
[16:03:20.017]                 withCallingHandlers({
[16:03:20.017]                   {
[16:03:20.017]                     do.call(function(...) {
[16:03:20.017]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.017]                       if (!identical(...future.globals.maxSize.org, 
[16:03:20.017]                         ...future.globals.maxSize)) {
[16:03:20.017]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.017]                         on.exit(options(oopts), add = TRUE)
[16:03:20.017]                       }
[16:03:20.017]                       {
[16:03:20.017]                         lapply(seq_along(...future.elements_ii), 
[16:03:20.017]                           FUN = function(jj) {
[16:03:20.017]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.017]                             ...future.FUN(...future.X_jj, ...)
[16:03:20.017]                           })
[16:03:20.017]                       }
[16:03:20.017]                     }, args = future.call.arguments)
[16:03:20.017]                   }
[16:03:20.017]                 }, immediateCondition = function(cond) {
[16:03:20.017]                   sendCondition <- ...future.makeSendCondition()
[16:03:20.017]                   sendCondition(cond)
[16:03:20.017]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.017]                   {
[16:03:20.017]                     inherits <- base::inherits
[16:03:20.017]                     invokeRestart <- base::invokeRestart
[16:03:20.017]                     is.null <- base::is.null
[16:03:20.017]                     muffled <- FALSE
[16:03:20.017]                     if (inherits(cond, "message")) {
[16:03:20.017]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:20.017]                       if (muffled) 
[16:03:20.017]                         invokeRestart("muffleMessage")
[16:03:20.017]                     }
[16:03:20.017]                     else if (inherits(cond, "warning")) {
[16:03:20.017]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:20.017]                       if (muffled) 
[16:03:20.017]                         invokeRestart("muffleWarning")
[16:03:20.017]                     }
[16:03:20.017]                     else if (inherits(cond, "condition")) {
[16:03:20.017]                       if (!is.null(pattern)) {
[16:03:20.017]                         computeRestarts <- base::computeRestarts
[16:03:20.017]                         grepl <- base::grepl
[16:03:20.017]                         restarts <- computeRestarts(cond)
[16:03:20.017]                         for (restart in restarts) {
[16:03:20.017]                           name <- restart$name
[16:03:20.017]                           if (is.null(name)) 
[16:03:20.017]                             next
[16:03:20.017]                           if (!grepl(pattern, name)) 
[16:03:20.017]                             next
[16:03:20.017]                           invokeRestart(restart)
[16:03:20.017]                           muffled <- TRUE
[16:03:20.017]                           break
[16:03:20.017]                         }
[16:03:20.017]                       }
[16:03:20.017]                     }
[16:03:20.017]                     invisible(muffled)
[16:03:20.017]                   }
[16:03:20.017]                   muffleCondition(cond)
[16:03:20.017]                 })
[16:03:20.017]             }))
[16:03:20.017]             future::FutureResult(value = ...future.value$value, 
[16:03:20.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.017]                   ...future.rng), globalenv = if (FALSE) 
[16:03:20.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:20.017]                     ...future.globalenv.names))
[16:03:20.017]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:20.017]         }, condition = base::local({
[16:03:20.017]             c <- base::c
[16:03:20.017]             inherits <- base::inherits
[16:03:20.017]             invokeRestart <- base::invokeRestart
[16:03:20.017]             length <- base::length
[16:03:20.017]             list <- base::list
[16:03:20.017]             seq.int <- base::seq.int
[16:03:20.017]             signalCondition <- base::signalCondition
[16:03:20.017]             sys.calls <- base::sys.calls
[16:03:20.017]             `[[` <- base::`[[`
[16:03:20.017]             `+` <- base::`+`
[16:03:20.017]             `<<-` <- base::`<<-`
[16:03:20.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:20.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:20.017]                   3L)]
[16:03:20.017]             }
[16:03:20.017]             function(cond) {
[16:03:20.017]                 is_error <- inherits(cond, "error")
[16:03:20.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:20.017]                   NULL)
[16:03:20.017]                 if (is_error) {
[16:03:20.017]                   sessionInformation <- function() {
[16:03:20.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:20.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:20.017]                       search = base::search(), system = base::Sys.info())
[16:03:20.017]                   }
[16:03:20.017]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:20.017]                     cond$call), session = sessionInformation(), 
[16:03:20.017]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:20.017]                   signalCondition(cond)
[16:03:20.017]                 }
[16:03:20.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:20.017]                 "immediateCondition"))) {
[16:03:20.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:20.017]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:20.017]                   if (TRUE && !signal) {
[16:03:20.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.017]                     {
[16:03:20.017]                       inherits <- base::inherits
[16:03:20.017]                       invokeRestart <- base::invokeRestart
[16:03:20.017]                       is.null <- base::is.null
[16:03:20.017]                       muffled <- FALSE
[16:03:20.017]                       if (inherits(cond, "message")) {
[16:03:20.017]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.017]                         if (muffled) 
[16:03:20.017]                           invokeRestart("muffleMessage")
[16:03:20.017]                       }
[16:03:20.017]                       else if (inherits(cond, "warning")) {
[16:03:20.017]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.017]                         if (muffled) 
[16:03:20.017]                           invokeRestart("muffleWarning")
[16:03:20.017]                       }
[16:03:20.017]                       else if (inherits(cond, "condition")) {
[16:03:20.017]                         if (!is.null(pattern)) {
[16:03:20.017]                           computeRestarts <- base::computeRestarts
[16:03:20.017]                           grepl <- base::grepl
[16:03:20.017]                           restarts <- computeRestarts(cond)
[16:03:20.017]                           for (restart in restarts) {
[16:03:20.017]                             name <- restart$name
[16:03:20.017]                             if (is.null(name)) 
[16:03:20.017]                               next
[16:03:20.017]                             if (!grepl(pattern, name)) 
[16:03:20.017]                               next
[16:03:20.017]                             invokeRestart(restart)
[16:03:20.017]                             muffled <- TRUE
[16:03:20.017]                             break
[16:03:20.017]                           }
[16:03:20.017]                         }
[16:03:20.017]                       }
[16:03:20.017]                       invisible(muffled)
[16:03:20.017]                     }
[16:03:20.017]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.017]                   }
[16:03:20.017]                 }
[16:03:20.017]                 else {
[16:03:20.017]                   if (TRUE) {
[16:03:20.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.017]                     {
[16:03:20.017]                       inherits <- base::inherits
[16:03:20.017]                       invokeRestart <- base::invokeRestart
[16:03:20.017]                       is.null <- base::is.null
[16:03:20.017]                       muffled <- FALSE
[16:03:20.017]                       if (inherits(cond, "message")) {
[16:03:20.017]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.017]                         if (muffled) 
[16:03:20.017]                           invokeRestart("muffleMessage")
[16:03:20.017]                       }
[16:03:20.017]                       else if (inherits(cond, "warning")) {
[16:03:20.017]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.017]                         if (muffled) 
[16:03:20.017]                           invokeRestart("muffleWarning")
[16:03:20.017]                       }
[16:03:20.017]                       else if (inherits(cond, "condition")) {
[16:03:20.017]                         if (!is.null(pattern)) {
[16:03:20.017]                           computeRestarts <- base::computeRestarts
[16:03:20.017]                           grepl <- base::grepl
[16:03:20.017]                           restarts <- computeRestarts(cond)
[16:03:20.017]                           for (restart in restarts) {
[16:03:20.017]                             name <- restart$name
[16:03:20.017]                             if (is.null(name)) 
[16:03:20.017]                               next
[16:03:20.017]                             if (!grepl(pattern, name)) 
[16:03:20.017]                               next
[16:03:20.017]                             invokeRestart(restart)
[16:03:20.017]                             muffled <- TRUE
[16:03:20.017]                             break
[16:03:20.017]                           }
[16:03:20.017]                         }
[16:03:20.017]                       }
[16:03:20.017]                       invisible(muffled)
[16:03:20.017]                     }
[16:03:20.017]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.017]                   }
[16:03:20.017]                 }
[16:03:20.017]             }
[16:03:20.017]         }))
[16:03:20.017]     }, error = function(ex) {
[16:03:20.017]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:20.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.017]                 ...future.rng), started = ...future.startTime, 
[16:03:20.017]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:20.017]             version = "1.8"), class = "FutureResult")
[16:03:20.017]     }, finally = {
[16:03:20.017]         if (!identical(...future.workdir, getwd())) 
[16:03:20.017]             setwd(...future.workdir)
[16:03:20.017]         {
[16:03:20.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:20.017]                 ...future.oldOptions$nwarnings <- NULL
[16:03:20.017]             }
[16:03:20.017]             base::options(...future.oldOptions)
[16:03:20.017]             if (.Platform$OS.type == "windows") {
[16:03:20.017]                 old_names <- names(...future.oldEnvVars)
[16:03:20.017]                 envs <- base::Sys.getenv()
[16:03:20.017]                 names <- names(envs)
[16:03:20.017]                 common <- intersect(names, old_names)
[16:03:20.017]                 added <- setdiff(names, old_names)
[16:03:20.017]                 removed <- setdiff(old_names, names)
[16:03:20.017]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:20.017]                   envs[common]]
[16:03:20.017]                 NAMES <- toupper(changed)
[16:03:20.017]                 args <- list()
[16:03:20.017]                 for (kk in seq_along(NAMES)) {
[16:03:20.017]                   name <- changed[[kk]]
[16:03:20.017]                   NAME <- NAMES[[kk]]
[16:03:20.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.017]                     next
[16:03:20.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.017]                 }
[16:03:20.017]                 NAMES <- toupper(added)
[16:03:20.017]                 for (kk in seq_along(NAMES)) {
[16:03:20.017]                   name <- added[[kk]]
[16:03:20.017]                   NAME <- NAMES[[kk]]
[16:03:20.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.017]                     next
[16:03:20.017]                   args[[name]] <- ""
[16:03:20.017]                 }
[16:03:20.017]                 NAMES <- toupper(removed)
[16:03:20.017]                 for (kk in seq_along(NAMES)) {
[16:03:20.017]                   name <- removed[[kk]]
[16:03:20.017]                   NAME <- NAMES[[kk]]
[16:03:20.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.017]                     next
[16:03:20.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.017]                 }
[16:03:20.017]                 if (length(args) > 0) 
[16:03:20.017]                   base::do.call(base::Sys.setenv, args = args)
[16:03:20.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:20.017]             }
[16:03:20.017]             else {
[16:03:20.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:20.017]             }
[16:03:20.017]             {
[16:03:20.017]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:20.017]                   0L) {
[16:03:20.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:20.017]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:20.017]                   base::options(opts)
[16:03:20.017]                 }
[16:03:20.017]                 {
[16:03:20.017]                   {
[16:03:20.017]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:20.017]                     NULL
[16:03:20.017]                   }
[16:03:20.017]                   options(future.plan = NULL)
[16:03:20.017]                   if (is.na(NA_character_)) 
[16:03:20.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:20.017]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:20.017]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:20.017]                     envir = parent.frame()) 
[16:03:20.017]                   {
[16:03:20.017]                     if (is.function(workers)) 
[16:03:20.017]                       workers <- workers()
[16:03:20.017]                     workers <- structure(as.integer(workers), 
[16:03:20.017]                       class = class(workers))
[16:03:20.017]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:20.017]                       workers >= 1)
[16:03:20.017]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:20.017]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:20.017]                     }
[16:03:20.017]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:20.017]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:20.017]                       envir = envir)
[16:03:20.017]                     if (!future$lazy) 
[16:03:20.017]                       future <- run(future)
[16:03:20.017]                     invisible(future)
[16:03:20.017]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:20.017]                 }
[16:03:20.017]             }
[16:03:20.017]         }
[16:03:20.017]     })
[16:03:20.017]     if (TRUE) {
[16:03:20.017]         base::sink(type = "output", split = FALSE)
[16:03:20.017]         if (TRUE) {
[16:03:20.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:20.017]         }
[16:03:20.017]         else {
[16:03:20.017]             ...future.result["stdout"] <- base::list(NULL)
[16:03:20.017]         }
[16:03:20.017]         base::close(...future.stdout)
[16:03:20.017]         ...future.stdout <- NULL
[16:03:20.017]     }
[16:03:20.017]     ...future.result$conditions <- ...future.conditions
[16:03:20.017]     ...future.result$finished <- base::Sys.time()
[16:03:20.017]     ...future.result
[16:03:20.017] }
[16:03:20.020] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[16:03:20.020] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[16:03:20.063] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[16:03:20.063] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:20.064] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:20.064] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[16:03:20.064] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[16:03:20.065] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:20.065] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:20.065] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:20.065] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:20.065] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[16:03:20.066] MultisessionFuture started
[16:03:20.066] - Launch lazy future ... done
[16:03:20.066] run() for ‘MultisessionFuture’ ... done
[16:03:20.066] Created future:
[16:03:20.066] MultisessionFuture:
[16:03:20.066] Label: ‘future_sapply-2’
[16:03:20.066] Expression:
[16:03:20.066] {
[16:03:20.066]     do.call(function(...) {
[16:03:20.066]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.066]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.066]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.066]             on.exit(options(oopts), add = TRUE)
[16:03:20.066]         }
[16:03:20.066]         {
[16:03:20.066]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.066]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.066]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.066]             })
[16:03:20.066]         }
[16:03:20.066]     }, args = future.call.arguments)
[16:03:20.066] }
[16:03:20.066] Lazy evaluation: FALSE
[16:03:20.066] Asynchronous evaluation: TRUE
[16:03:20.066] Local evaluation: TRUE
[16:03:20.066] Environment: R_GlobalEnv
[16:03:20.066] Capture standard output: TRUE
[16:03:20.066] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:20.066] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:20.066] Packages: 1 packages (‘stats’)
[16:03:20.066] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:20.066] Resolved: FALSE
[16:03:20.066] Value: <not collected>
[16:03:20.066] Conditions captured: <none>
[16:03:20.066] Early signaling: FALSE
[16:03:20.066] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:20.066] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.078] Chunk #2 of 2 ... DONE
[16:03:20.078] Launching 2 futures (chunks) ... DONE
[16:03:20.078] Resolving 2 futures (chunks) ...
[16:03:20.078] resolve() on list ...
[16:03:20.078]  recursive: 0
[16:03:20.079]  length: 2
[16:03:20.079] 
[16:03:20.079] receiveMessageFromWorker() for ClusterFuture ...
[16:03:20.079] - Validating connection of MultisessionFuture
[16:03:20.079] - received message: FutureResult
[16:03:20.080] - Received FutureResult
[16:03:20.080] - Erased future from FutureRegistry
[16:03:20.080] result() for ClusterFuture ...
[16:03:20.080] - result already collected: FutureResult
[16:03:20.080] result() for ClusterFuture ... done
[16:03:20.080] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:20.080] Future #1
[16:03:20.080] result() for ClusterFuture ...
[16:03:20.080] - result already collected: FutureResult
[16:03:20.081] result() for ClusterFuture ... done
[16:03:20.081] result() for ClusterFuture ...
[16:03:20.081] - result already collected: FutureResult
[16:03:20.081] result() for ClusterFuture ... done
[16:03:20.081] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:20.081] - nx: 2
[16:03:20.081] - relay: TRUE
[16:03:20.081] - stdout: TRUE
[16:03:20.081] - signal: TRUE
[16:03:20.081] - resignal: FALSE
[16:03:20.081] - force: TRUE
[16:03:20.081] - relayed: [n=2] FALSE, FALSE
[16:03:20.082] - queued futures: [n=2] FALSE, FALSE
[16:03:20.082]  - until=1
[16:03:20.082]  - relaying element #1
[16:03:20.082] result() for ClusterFuture ...
[16:03:20.082] - result already collected: FutureResult
[16:03:20.082] result() for ClusterFuture ... done
[16:03:20.082] result() for ClusterFuture ...
[16:03:20.082] - result already collected: FutureResult
[16:03:20.082] result() for ClusterFuture ... done
[16:03:20.082] result() for ClusterFuture ...
[16:03:20.083] - result already collected: FutureResult
[16:03:20.083] result() for ClusterFuture ... done
[16:03:20.083] result() for ClusterFuture ...
[16:03:20.083] - result already collected: FutureResult
[16:03:20.083] result() for ClusterFuture ... done
[16:03:20.083] - relayed: [n=2] TRUE, FALSE
[16:03:20.083] - queued futures: [n=2] TRUE, FALSE
[16:03:20.083] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:20.083]  length: 1 (resolved future 1)
[16:03:20.112] receiveMessageFromWorker() for ClusterFuture ...
[16:03:20.112] - Validating connection of MultisessionFuture
[16:03:20.112] - received message: FutureResult
[16:03:20.112] - Received FutureResult
[16:03:20.112] - Erased future from FutureRegistry
[16:03:20.112] result() for ClusterFuture ...
[16:03:20.113] - result already collected: FutureResult
[16:03:20.113] result() for ClusterFuture ... done
[16:03:20.113] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:20.113] Future #2
[16:03:20.113] result() for ClusterFuture ...
[16:03:20.113] - result already collected: FutureResult
[16:03:20.113] result() for ClusterFuture ... done
[16:03:20.113] result() for ClusterFuture ...
[16:03:20.113] - result already collected: FutureResult
[16:03:20.113] result() for ClusterFuture ... done
[16:03:20.113] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:20.114] - nx: 2
[16:03:20.114] - relay: TRUE
[16:03:20.114] - stdout: TRUE
[16:03:20.114] - signal: TRUE
[16:03:20.114] - resignal: FALSE
[16:03:20.114] - force: TRUE
[16:03:20.114] - relayed: [n=2] TRUE, FALSE
[16:03:20.114] - queued futures: [n=2] TRUE, FALSE
[16:03:20.114]  - until=2
[16:03:20.114]  - relaying element #2
[16:03:20.114] result() for ClusterFuture ...
[16:03:20.114] - result already collected: FutureResult
[16:03:20.115] result() for ClusterFuture ... done
[16:03:20.115] result() for ClusterFuture ...
[16:03:20.115] - result already collected: FutureResult
[16:03:20.115] result() for ClusterFuture ... done
[16:03:20.115] result() for ClusterFuture ...
[16:03:20.115] - result already collected: FutureResult
[16:03:20.115] result() for ClusterFuture ... done
[16:03:20.115] result() for ClusterFuture ...
[16:03:20.115] - result already collected: FutureResult
[16:03:20.115] result() for ClusterFuture ... done
[16:03:20.115] - relayed: [n=2] TRUE, TRUE
[16:03:20.116] - queued futures: [n=2] TRUE, TRUE
[16:03:20.116] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:20.116]  length: 0 (resolved future 2)
[16:03:20.116] Relaying remaining futures
[16:03:20.116] signalConditionsASAP(NULL, pos=0) ...
[16:03:20.116] - nx: 2
[16:03:20.116] - relay: TRUE
[16:03:20.116] - stdout: TRUE
[16:03:20.116] - signal: TRUE
[16:03:20.116] - resignal: FALSE
[16:03:20.116] - force: TRUE
[16:03:20.117] - relayed: [n=2] TRUE, TRUE
[16:03:20.117] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:20.117] - relayed: [n=2] TRUE, TRUE
[16:03:20.117] - queued futures: [n=2] TRUE, TRUE
[16:03:20.117] signalConditionsASAP(NULL, pos=0) ... done
[16:03:20.117] resolve() on list ... DONE
[16:03:20.117] result() for ClusterFuture ...
[16:03:20.117] - result already collected: FutureResult
[16:03:20.117] result() for ClusterFuture ... done
[16:03:20.117] result() for ClusterFuture ...
[16:03:20.117] - result already collected: FutureResult
[16:03:20.118] result() for ClusterFuture ... done
[16:03:20.118] result() for ClusterFuture ...
[16:03:20.118] - result already collected: FutureResult
[16:03:20.118] result() for ClusterFuture ... done
[16:03:20.118] result() for ClusterFuture ...
[16:03:20.118] - result already collected: FutureResult
[16:03:20.118] result() for ClusterFuture ... done
[16:03:20.118]  - Number of value chunks collected: 2
[16:03:20.118] Resolving 2 futures (chunks) ... DONE
[16:03:20.118] Reducing values from 2 chunks ...
[16:03:20.118]  - Number of values collected after concatenation: 7
[16:03:20.119]  - Number of values expected: 7
[16:03:20.119] Reducing values from 2 chunks ... DONE
[16:03:20.119] future_lapply() ... DONE
[16:03:20.119] future_lapply() ...
[16:03:20.124] Number of chunks: 2
[16:03:20.124] getGlobalsAndPackagesXApply() ...
[16:03:20.125]  - future.globals: TRUE
[16:03:20.125] getGlobalsAndPackages() ...
[16:03:20.125] Searching for globals...
[16:03:20.132] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:03:20.132] Searching for globals ... DONE
[16:03:20.132] Resolving globals: FALSE
[16:03:20.133] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[16:03:20.134] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[16:03:20.134] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:20.134] - packages: [2] ‘stats’, ‘future.apply’
[16:03:20.134] getGlobalsAndPackages() ... DONE
[16:03:20.134]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:20.134]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:03:20.134] Finding globals ... DONE
[16:03:20.134]  - use_args: TRUE
[16:03:20.135]  - Getting '...' globals ...
[16:03:20.135] resolve() on list ...
[16:03:20.135]  recursive: 0
[16:03:20.135]  length: 1
[16:03:20.135]  elements: ‘...’
[16:03:20.135]  length: 0 (resolved future 1)
[16:03:20.135] resolve() on list ... DONE
[16:03:20.135]    - '...' content: [n=0] 
[16:03:20.136] List of 1
[16:03:20.136]  $ ...: list()
[16:03:20.136]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:20.136]  - attr(*, "where")=List of 1
[16:03:20.136]   ..$ ...:<environment: 0x564e43ed9e20> 
[16:03:20.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:20.136]  - attr(*, "resolved")= logi TRUE
[16:03:20.136]  - attr(*, "total_size")= num NA
[16:03:20.138]  - Getting '...' globals ... DONE
[16:03:20.138] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:20.138] List of 8
[16:03:20.138]  $ ...future.FUN:function (x, ...)  
[16:03:20.138]  $ x_FUN        :function (x, na.rm = TRUE)  
[16:03:20.138]  $ times        : int 5
[16:03:20.138]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:20.138]  $ stop_if_not  :function (...)  
[16:03:20.138]  $ dim          : NULL
[16:03:20.138]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:20.138]  $ ...          : list()
[16:03:20.138]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:20.138]  - attr(*, "where")=List of 8
[16:03:20.138]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:20.138]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:20.138]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:20.138]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:20.138]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:20.138]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:20.138]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:20.138]   ..$ ...          :<environment: 0x564e43ed9e20> 
[16:03:20.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:20.138]  - attr(*, "resolved")= logi FALSE
[16:03:20.138]  - attr(*, "total_size")= num 141240
[16:03:20.143] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:03:20.144] getGlobalsAndPackagesXApply() ... DONE
[16:03:20.144] Number of futures (= number of chunks): 2
[16:03:20.144] Launching 2 futures (chunks) ...
[16:03:20.144] Chunk #1 of 2 ...
[16:03:20.144]  - Finding globals in 'X' for chunk #1 ...
[16:03:20.144] getGlobalsAndPackages() ...
[16:03:20.144] Searching for globals...
[16:03:20.145] 
[16:03:20.145] Searching for globals ... DONE
[16:03:20.145] - globals: [0] <none>
[16:03:20.145] getGlobalsAndPackages() ... DONE
[16:03:20.145]    + additional globals found: [n=0] 
[16:03:20.145]    + additional namespaces needed: [n=0] 
[16:03:20.145]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:20.145]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:20.145]  - seeds: <none>
[16:03:20.145]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.145] getGlobalsAndPackages() ...
[16:03:20.146] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.146] Resolving globals: FALSE
[16:03:20.146] Tweak future expression to call with '...' arguments ...
[16:03:20.146] {
[16:03:20.146]     do.call(function(...) {
[16:03:20.146]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.146]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.146]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.146]             on.exit(options(oopts), add = TRUE)
[16:03:20.146]         }
[16:03:20.146]         {
[16:03:20.146]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.146]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.146]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.146]             })
[16:03:20.146]         }
[16:03:20.146]     }, args = future.call.arguments)
[16:03:20.146] }
[16:03:20.146] Tweak future expression to call with '...' arguments ... DONE
[16:03:20.147] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.147] - packages: [2] ‘stats’, ‘future.apply’
[16:03:20.147] getGlobalsAndPackages() ... DONE
[16:03:20.147] run() for ‘Future’ ...
[16:03:20.147] - state: ‘created’
[16:03:20.147] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:20.161] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:20.161]   - Field: ‘node’
[16:03:20.161]   - Field: ‘label’
[16:03:20.161]   - Field: ‘local’
[16:03:20.161]   - Field: ‘owner’
[16:03:20.161]   - Field: ‘envir’
[16:03:20.161]   - Field: ‘workers’
[16:03:20.162]   - Field: ‘packages’
[16:03:20.162]   - Field: ‘gc’
[16:03:20.162]   - Field: ‘conditions’
[16:03:20.162]   - Field: ‘persistent’
[16:03:20.162]   - Field: ‘expr’
[16:03:20.162]   - Field: ‘uuid’
[16:03:20.162]   - Field: ‘seed’
[16:03:20.162]   - Field: ‘version’
[16:03:20.162]   - Field: ‘result’
[16:03:20.162]   - Field: ‘asynchronous’
[16:03:20.162]   - Field: ‘calls’
[16:03:20.163]   - Field: ‘globals’
[16:03:20.163]   - Field: ‘stdout’
[16:03:20.163]   - Field: ‘earlySignal’
[16:03:20.163]   - Field: ‘lazy’
[16:03:20.163]   - Field: ‘state’
[16:03:20.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:20.163] - Launch lazy future ...
[16:03:20.163] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:03:20.164] Packages needed by future strategies (n = 0): <none>
[16:03:20.164] {
[16:03:20.164]     {
[16:03:20.164]         {
[16:03:20.164]             ...future.startTime <- base::Sys.time()
[16:03:20.164]             {
[16:03:20.164]                 {
[16:03:20.164]                   {
[16:03:20.164]                     {
[16:03:20.164]                       {
[16:03:20.164]                         base::local({
[16:03:20.164]                           has_future <- base::requireNamespace("future", 
[16:03:20.164]                             quietly = TRUE)
[16:03:20.164]                           if (has_future) {
[16:03:20.164]                             ns <- base::getNamespace("future")
[16:03:20.164]                             version <- ns[[".package"]][["version"]]
[16:03:20.164]                             if (is.null(version)) 
[16:03:20.164]                               version <- utils::packageVersion("future")
[16:03:20.164]                           }
[16:03:20.164]                           else {
[16:03:20.164]                             version <- NULL
[16:03:20.164]                           }
[16:03:20.164]                           if (!has_future || version < "1.8.0") {
[16:03:20.164]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:20.164]                               "", base::R.version$version.string), 
[16:03:20.164]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:20.164]                                 base::R.version$platform, 8 * 
[16:03:20.164]                                   base::.Machine$sizeof.pointer), 
[16:03:20.164]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:20.164]                                 "release", "version")], collapse = " "), 
[16:03:20.164]                               hostname = base::Sys.info()[["nodename"]])
[16:03:20.164]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:20.164]                               info)
[16:03:20.164]                             info <- base::paste(info, collapse = "; ")
[16:03:20.164]                             if (!has_future) {
[16:03:20.164]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:20.164]                                 info)
[16:03:20.164]                             }
[16:03:20.164]                             else {
[16:03:20.164]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:20.164]                                 info, version)
[16:03:20.164]                             }
[16:03:20.164]                             base::stop(msg)
[16:03:20.164]                           }
[16:03:20.164]                         })
[16:03:20.164]                       }
[16:03:20.164]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:20.164]                       base::options(mc.cores = 1L)
[16:03:20.164]                     }
[16:03:20.164]                     base::local({
[16:03:20.164]                       for (pkg in c("stats", "future.apply")) {
[16:03:20.164]                         base::loadNamespace(pkg)
[16:03:20.164]                         base::library(pkg, character.only = TRUE)
[16:03:20.164]                       }
[16:03:20.164]                     })
[16:03:20.164]                   }
[16:03:20.164]                   options(future.plan = NULL)
[16:03:20.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:20.164]                 }
[16:03:20.164]                 ...future.workdir <- getwd()
[16:03:20.164]             }
[16:03:20.164]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:20.164]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:20.164]         }
[16:03:20.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:20.164]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:20.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:20.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:20.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:20.164]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:20.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:20.164]             base::names(...future.oldOptions))
[16:03:20.164]     }
[16:03:20.164]     if (FALSE) {
[16:03:20.164]     }
[16:03:20.164]     else {
[16:03:20.164]         if (TRUE) {
[16:03:20.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:20.164]                 open = "w")
[16:03:20.164]         }
[16:03:20.164]         else {
[16:03:20.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:20.164]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:20.164]         }
[16:03:20.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:20.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:20.164]             base::sink(type = "output", split = FALSE)
[16:03:20.164]             base::close(...future.stdout)
[16:03:20.164]         }, add = TRUE)
[16:03:20.164]     }
[16:03:20.164]     ...future.frame <- base::sys.nframe()
[16:03:20.164]     ...future.conditions <- base::list()
[16:03:20.164]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:20.164]     if (FALSE) {
[16:03:20.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:20.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:20.164]     }
[16:03:20.164]     ...future.result <- base::tryCatch({
[16:03:20.164]         base::withCallingHandlers({
[16:03:20.164]             ...future.value <- base::withVisible(base::local({
[16:03:20.164]                 ...future.makeSendCondition <- base::local({
[16:03:20.164]                   sendCondition <- NULL
[16:03:20.164]                   function(frame = 1L) {
[16:03:20.164]                     if (is.function(sendCondition)) 
[16:03:20.164]                       return(sendCondition)
[16:03:20.164]                     ns <- getNamespace("parallel")
[16:03:20.164]                     if (exists("sendData", mode = "function", 
[16:03:20.164]                       envir = ns)) {
[16:03:20.164]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:20.164]                         envir = ns)
[16:03:20.164]                       envir <- sys.frame(frame)
[16:03:20.164]                       master <- NULL
[16:03:20.164]                       while (!identical(envir, .GlobalEnv) && 
[16:03:20.164]                         !identical(envir, emptyenv())) {
[16:03:20.164]                         if (exists("master", mode = "list", envir = envir, 
[16:03:20.164]                           inherits = FALSE)) {
[16:03:20.164]                           master <- get("master", mode = "list", 
[16:03:20.164]                             envir = envir, inherits = FALSE)
[16:03:20.164]                           if (inherits(master, c("SOCKnode", 
[16:03:20.164]                             "SOCK0node"))) {
[16:03:20.164]                             sendCondition <<- function(cond) {
[16:03:20.164]                               data <- list(type = "VALUE", value = cond, 
[16:03:20.164]                                 success = TRUE)
[16:03:20.164]                               parallel_sendData(master, data)
[16:03:20.164]                             }
[16:03:20.164]                             return(sendCondition)
[16:03:20.164]                           }
[16:03:20.164]                         }
[16:03:20.164]                         frame <- frame + 1L
[16:03:20.164]                         envir <- sys.frame(frame)
[16:03:20.164]                       }
[16:03:20.164]                     }
[16:03:20.164]                     sendCondition <<- function(cond) NULL
[16:03:20.164]                   }
[16:03:20.164]                 })
[16:03:20.164]                 withCallingHandlers({
[16:03:20.164]                   {
[16:03:20.164]                     do.call(function(...) {
[16:03:20.164]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.164]                       if (!identical(...future.globals.maxSize.org, 
[16:03:20.164]                         ...future.globals.maxSize)) {
[16:03:20.164]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.164]                         on.exit(options(oopts), add = TRUE)
[16:03:20.164]                       }
[16:03:20.164]                       {
[16:03:20.164]                         lapply(seq_along(...future.elements_ii), 
[16:03:20.164]                           FUN = function(jj) {
[16:03:20.164]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.164]                             ...future.FUN(...future.X_jj, ...)
[16:03:20.164]                           })
[16:03:20.164]                       }
[16:03:20.164]                     }, args = future.call.arguments)
[16:03:20.164]                   }
[16:03:20.164]                 }, immediateCondition = function(cond) {
[16:03:20.164]                   sendCondition <- ...future.makeSendCondition()
[16:03:20.164]                   sendCondition(cond)
[16:03:20.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.164]                   {
[16:03:20.164]                     inherits <- base::inherits
[16:03:20.164]                     invokeRestart <- base::invokeRestart
[16:03:20.164]                     is.null <- base::is.null
[16:03:20.164]                     muffled <- FALSE
[16:03:20.164]                     if (inherits(cond, "message")) {
[16:03:20.164]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:20.164]                       if (muffled) 
[16:03:20.164]                         invokeRestart("muffleMessage")
[16:03:20.164]                     }
[16:03:20.164]                     else if (inherits(cond, "warning")) {
[16:03:20.164]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:20.164]                       if (muffled) 
[16:03:20.164]                         invokeRestart("muffleWarning")
[16:03:20.164]                     }
[16:03:20.164]                     else if (inherits(cond, "condition")) {
[16:03:20.164]                       if (!is.null(pattern)) {
[16:03:20.164]                         computeRestarts <- base::computeRestarts
[16:03:20.164]                         grepl <- base::grepl
[16:03:20.164]                         restarts <- computeRestarts(cond)
[16:03:20.164]                         for (restart in restarts) {
[16:03:20.164]                           name <- restart$name
[16:03:20.164]                           if (is.null(name)) 
[16:03:20.164]                             next
[16:03:20.164]                           if (!grepl(pattern, name)) 
[16:03:20.164]                             next
[16:03:20.164]                           invokeRestart(restart)
[16:03:20.164]                           muffled <- TRUE
[16:03:20.164]                           break
[16:03:20.164]                         }
[16:03:20.164]                       }
[16:03:20.164]                     }
[16:03:20.164]                     invisible(muffled)
[16:03:20.164]                   }
[16:03:20.164]                   muffleCondition(cond)
[16:03:20.164]                 })
[16:03:20.164]             }))
[16:03:20.164]             future::FutureResult(value = ...future.value$value, 
[16:03:20.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.164]                   ...future.rng), globalenv = if (FALSE) 
[16:03:20.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:20.164]                     ...future.globalenv.names))
[16:03:20.164]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:20.164]         }, condition = base::local({
[16:03:20.164]             c <- base::c
[16:03:20.164]             inherits <- base::inherits
[16:03:20.164]             invokeRestart <- base::invokeRestart
[16:03:20.164]             length <- base::length
[16:03:20.164]             list <- base::list
[16:03:20.164]             seq.int <- base::seq.int
[16:03:20.164]             signalCondition <- base::signalCondition
[16:03:20.164]             sys.calls <- base::sys.calls
[16:03:20.164]             `[[` <- base::`[[`
[16:03:20.164]             `+` <- base::`+`
[16:03:20.164]             `<<-` <- base::`<<-`
[16:03:20.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:20.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:20.164]                   3L)]
[16:03:20.164]             }
[16:03:20.164]             function(cond) {
[16:03:20.164]                 is_error <- inherits(cond, "error")
[16:03:20.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:20.164]                   NULL)
[16:03:20.164]                 if (is_error) {
[16:03:20.164]                   sessionInformation <- function() {
[16:03:20.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:20.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:20.164]                       search = base::search(), system = base::Sys.info())
[16:03:20.164]                   }
[16:03:20.164]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:20.164]                     cond$call), session = sessionInformation(), 
[16:03:20.164]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:20.164]                   signalCondition(cond)
[16:03:20.164]                 }
[16:03:20.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:20.164]                 "immediateCondition"))) {
[16:03:20.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:20.164]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:20.164]                   if (TRUE && !signal) {
[16:03:20.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.164]                     {
[16:03:20.164]                       inherits <- base::inherits
[16:03:20.164]                       invokeRestart <- base::invokeRestart
[16:03:20.164]                       is.null <- base::is.null
[16:03:20.164]                       muffled <- FALSE
[16:03:20.164]                       if (inherits(cond, "message")) {
[16:03:20.164]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.164]                         if (muffled) 
[16:03:20.164]                           invokeRestart("muffleMessage")
[16:03:20.164]                       }
[16:03:20.164]                       else if (inherits(cond, "warning")) {
[16:03:20.164]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.164]                         if (muffled) 
[16:03:20.164]                           invokeRestart("muffleWarning")
[16:03:20.164]                       }
[16:03:20.164]                       else if (inherits(cond, "condition")) {
[16:03:20.164]                         if (!is.null(pattern)) {
[16:03:20.164]                           computeRestarts <- base::computeRestarts
[16:03:20.164]                           grepl <- base::grepl
[16:03:20.164]                           restarts <- computeRestarts(cond)
[16:03:20.164]                           for (restart in restarts) {
[16:03:20.164]                             name <- restart$name
[16:03:20.164]                             if (is.null(name)) 
[16:03:20.164]                               next
[16:03:20.164]                             if (!grepl(pattern, name)) 
[16:03:20.164]                               next
[16:03:20.164]                             invokeRestart(restart)
[16:03:20.164]                             muffled <- TRUE
[16:03:20.164]                             break
[16:03:20.164]                           }
[16:03:20.164]                         }
[16:03:20.164]                       }
[16:03:20.164]                       invisible(muffled)
[16:03:20.164]                     }
[16:03:20.164]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.164]                   }
[16:03:20.164]                 }
[16:03:20.164]                 else {
[16:03:20.164]                   if (TRUE) {
[16:03:20.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.164]                     {
[16:03:20.164]                       inherits <- base::inherits
[16:03:20.164]                       invokeRestart <- base::invokeRestart
[16:03:20.164]                       is.null <- base::is.null
[16:03:20.164]                       muffled <- FALSE
[16:03:20.164]                       if (inherits(cond, "message")) {
[16:03:20.164]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.164]                         if (muffled) 
[16:03:20.164]                           invokeRestart("muffleMessage")
[16:03:20.164]                       }
[16:03:20.164]                       else if (inherits(cond, "warning")) {
[16:03:20.164]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.164]                         if (muffled) 
[16:03:20.164]                           invokeRestart("muffleWarning")
[16:03:20.164]                       }
[16:03:20.164]                       else if (inherits(cond, "condition")) {
[16:03:20.164]                         if (!is.null(pattern)) {
[16:03:20.164]                           computeRestarts <- base::computeRestarts
[16:03:20.164]                           grepl <- base::grepl
[16:03:20.164]                           restarts <- computeRestarts(cond)
[16:03:20.164]                           for (restart in restarts) {
[16:03:20.164]                             name <- restart$name
[16:03:20.164]                             if (is.null(name)) 
[16:03:20.164]                               next
[16:03:20.164]                             if (!grepl(pattern, name)) 
[16:03:20.164]                               next
[16:03:20.164]                             invokeRestart(restart)
[16:03:20.164]                             muffled <- TRUE
[16:03:20.164]                             break
[16:03:20.164]                           }
[16:03:20.164]                         }
[16:03:20.164]                       }
[16:03:20.164]                       invisible(muffled)
[16:03:20.164]                     }
[16:03:20.164]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.164]                   }
[16:03:20.164]                 }
[16:03:20.164]             }
[16:03:20.164]         }))
[16:03:20.164]     }, error = function(ex) {
[16:03:20.164]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:20.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.164]                 ...future.rng), started = ...future.startTime, 
[16:03:20.164]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:20.164]             version = "1.8"), class = "FutureResult")
[16:03:20.164]     }, finally = {
[16:03:20.164]         if (!identical(...future.workdir, getwd())) 
[16:03:20.164]             setwd(...future.workdir)
[16:03:20.164]         {
[16:03:20.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:20.164]                 ...future.oldOptions$nwarnings <- NULL
[16:03:20.164]             }
[16:03:20.164]             base::options(...future.oldOptions)
[16:03:20.164]             if (.Platform$OS.type == "windows") {
[16:03:20.164]                 old_names <- names(...future.oldEnvVars)
[16:03:20.164]                 envs <- base::Sys.getenv()
[16:03:20.164]                 names <- names(envs)
[16:03:20.164]                 common <- intersect(names, old_names)
[16:03:20.164]                 added <- setdiff(names, old_names)
[16:03:20.164]                 removed <- setdiff(old_names, names)
[16:03:20.164]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:20.164]                   envs[common]]
[16:03:20.164]                 NAMES <- toupper(changed)
[16:03:20.164]                 args <- list()
[16:03:20.164]                 for (kk in seq_along(NAMES)) {
[16:03:20.164]                   name <- changed[[kk]]
[16:03:20.164]                   NAME <- NAMES[[kk]]
[16:03:20.164]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.164]                     next
[16:03:20.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.164]                 }
[16:03:20.164]                 NAMES <- toupper(added)
[16:03:20.164]                 for (kk in seq_along(NAMES)) {
[16:03:20.164]                   name <- added[[kk]]
[16:03:20.164]                   NAME <- NAMES[[kk]]
[16:03:20.164]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.164]                     next
[16:03:20.164]                   args[[name]] <- ""
[16:03:20.164]                 }
[16:03:20.164]                 NAMES <- toupper(removed)
[16:03:20.164]                 for (kk in seq_along(NAMES)) {
[16:03:20.164]                   name <- removed[[kk]]
[16:03:20.164]                   NAME <- NAMES[[kk]]
[16:03:20.164]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.164]                     next
[16:03:20.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.164]                 }
[16:03:20.164]                 if (length(args) > 0) 
[16:03:20.164]                   base::do.call(base::Sys.setenv, args = args)
[16:03:20.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:20.164]             }
[16:03:20.164]             else {
[16:03:20.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:20.164]             }
[16:03:20.164]             {
[16:03:20.164]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:20.164]                   0L) {
[16:03:20.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:20.164]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:20.164]                   base::options(opts)
[16:03:20.164]                 }
[16:03:20.164]                 {
[16:03:20.164]                   {
[16:03:20.164]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:20.164]                     NULL
[16:03:20.164]                   }
[16:03:20.164]                   options(future.plan = NULL)
[16:03:20.164]                   if (is.na(NA_character_)) 
[16:03:20.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:20.164]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:20.164]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:20.164]                     envir = parent.frame()) 
[16:03:20.164]                   {
[16:03:20.164]                     if (is.function(workers)) 
[16:03:20.164]                       workers <- workers()
[16:03:20.164]                     workers <- structure(as.integer(workers), 
[16:03:20.164]                       class = class(workers))
[16:03:20.164]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:20.164]                       workers >= 1)
[16:03:20.164]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:20.164]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:20.164]                     }
[16:03:20.164]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:20.164]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:20.164]                       envir = envir)
[16:03:20.164]                     if (!future$lazy) 
[16:03:20.164]                       future <- run(future)
[16:03:20.164]                     invisible(future)
[16:03:20.164]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:20.164]                 }
[16:03:20.164]             }
[16:03:20.164]         }
[16:03:20.164]     })
[16:03:20.164]     if (TRUE) {
[16:03:20.164]         base::sink(type = "output", split = FALSE)
[16:03:20.164]         if (TRUE) {
[16:03:20.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:20.164]         }
[16:03:20.164]         else {
[16:03:20.164]             ...future.result["stdout"] <- base::list(NULL)
[16:03:20.164]         }
[16:03:20.164]         base::close(...future.stdout)
[16:03:20.164]         ...future.stdout <- NULL
[16:03:20.164]     }
[16:03:20.164]     ...future.result$conditions <- ...future.conditions
[16:03:20.164]     ...future.result$finished <- base::Sys.time()
[16:03:20.164]     ...future.result
[16:03:20.164] }
[16:03:20.167] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[16:03:20.167] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:20.211] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:20.211] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[16:03:20.255] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[16:03:20.255] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:20.256] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:20.256] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:20.299] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:20.299] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:20.343] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:20.343] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:03:20.344] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:03:20.344] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:03:20.344] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:03:20.344] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:20.345] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:20.345] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[16:03:20.345] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[16:03:20.346] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:20.346] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:20.346] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:20.346] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:20.347] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[16:03:20.347] MultisessionFuture started
[16:03:20.347] - Launch lazy future ... done
[16:03:20.348] run() for ‘MultisessionFuture’ ... done
[16:03:20.348] Created future:
[16:03:20.348] MultisessionFuture:
[16:03:20.348] Label: ‘future_vapply-1’
[16:03:20.348] Expression:
[16:03:20.348] {
[16:03:20.348]     do.call(function(...) {
[16:03:20.348]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.348]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.348]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.348]             on.exit(options(oopts), add = TRUE)
[16:03:20.348]         }
[16:03:20.348]         {
[16:03:20.348]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.348]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.348]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.348]             })
[16:03:20.348]         }
[16:03:20.348]     }, args = future.call.arguments)
[16:03:20.348] }
[16:03:20.348] Lazy evaluation: FALSE
[16:03:20.348] Asynchronous evaluation: TRUE
[16:03:20.348] Local evaluation: TRUE
[16:03:20.348] Environment: R_GlobalEnv
[16:03:20.348] Capture standard output: TRUE
[16:03:20.348] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:20.348] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:20.348] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:03:20.348] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:20.348] Resolved: FALSE
[16:03:20.348] Value: <not collected>
[16:03:20.348] Conditions captured: <none>
[16:03:20.348] Early signaling: FALSE
[16:03:20.348] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:20.348] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.359] Chunk #1 of 2 ... DONE
[16:03:20.360] Chunk #2 of 2 ...
[16:03:20.360]  - Finding globals in 'X' for chunk #2 ...
[16:03:20.360] getGlobalsAndPackages() ...
[16:03:20.360] Searching for globals...
[16:03:20.360] 
[16:03:20.360] Searching for globals ... DONE
[16:03:20.360] - globals: [0] <none>
[16:03:20.360] getGlobalsAndPackages() ... DONE
[16:03:20.361]    + additional globals found: [n=0] 
[16:03:20.361]    + additional namespaces needed: [n=0] 
[16:03:20.361]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:20.361]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:20.361]  - seeds: <none>
[16:03:20.361]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.361] getGlobalsAndPackages() ...
[16:03:20.361] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.361] Resolving globals: FALSE
[16:03:20.361] Tweak future expression to call with '...' arguments ...
[16:03:20.362] {
[16:03:20.362]     do.call(function(...) {
[16:03:20.362]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.362]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.362]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.362]             on.exit(options(oopts), add = TRUE)
[16:03:20.362]         }
[16:03:20.362]         {
[16:03:20.362]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.362]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.362]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.362]             })
[16:03:20.362]         }
[16:03:20.362]     }, args = future.call.arguments)
[16:03:20.362] }
[16:03:20.362] Tweak future expression to call with '...' arguments ... DONE
[16:03:20.362] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.362] - packages: [2] ‘stats’, ‘future.apply’
[16:03:20.363] getGlobalsAndPackages() ... DONE
[16:03:20.363] run() for ‘Future’ ...
[16:03:20.363] - state: ‘created’
[16:03:20.363] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:20.377] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.377] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:20.377]   - Field: ‘node’
[16:03:20.377]   - Field: ‘label’
[16:03:20.377]   - Field: ‘local’
[16:03:20.377]   - Field: ‘owner’
[16:03:20.377]   - Field: ‘envir’
[16:03:20.378]   - Field: ‘workers’
[16:03:20.378]   - Field: ‘packages’
[16:03:20.378]   - Field: ‘gc’
[16:03:20.378]   - Field: ‘conditions’
[16:03:20.378]   - Field: ‘persistent’
[16:03:20.378]   - Field: ‘expr’
[16:03:20.378]   - Field: ‘uuid’
[16:03:20.378]   - Field: ‘seed’
[16:03:20.378]   - Field: ‘version’
[16:03:20.378]   - Field: ‘result’
[16:03:20.378]   - Field: ‘asynchronous’
[16:03:20.379]   - Field: ‘calls’
[16:03:20.379]   - Field: ‘globals’
[16:03:20.379]   - Field: ‘stdout’
[16:03:20.379]   - Field: ‘earlySignal’
[16:03:20.379]   - Field: ‘lazy’
[16:03:20.379]   - Field: ‘state’
[16:03:20.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:20.379] - Launch lazy future ...
[16:03:20.380] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:03:20.380] Packages needed by future strategies (n = 0): <none>
[16:03:20.380] {
[16:03:20.380]     {
[16:03:20.380]         {
[16:03:20.380]             ...future.startTime <- base::Sys.time()
[16:03:20.380]             {
[16:03:20.380]                 {
[16:03:20.380]                   {
[16:03:20.380]                     {
[16:03:20.380]                       {
[16:03:20.380]                         base::local({
[16:03:20.380]                           has_future <- base::requireNamespace("future", 
[16:03:20.380]                             quietly = TRUE)
[16:03:20.380]                           if (has_future) {
[16:03:20.380]                             ns <- base::getNamespace("future")
[16:03:20.380]                             version <- ns[[".package"]][["version"]]
[16:03:20.380]                             if (is.null(version)) 
[16:03:20.380]                               version <- utils::packageVersion("future")
[16:03:20.380]                           }
[16:03:20.380]                           else {
[16:03:20.380]                             version <- NULL
[16:03:20.380]                           }
[16:03:20.380]                           if (!has_future || version < "1.8.0") {
[16:03:20.380]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:20.380]                               "", base::R.version$version.string), 
[16:03:20.380]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:20.380]                                 base::R.version$platform, 8 * 
[16:03:20.380]                                   base::.Machine$sizeof.pointer), 
[16:03:20.380]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:20.380]                                 "release", "version")], collapse = " "), 
[16:03:20.380]                               hostname = base::Sys.info()[["nodename"]])
[16:03:20.380]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:20.380]                               info)
[16:03:20.380]                             info <- base::paste(info, collapse = "; ")
[16:03:20.380]                             if (!has_future) {
[16:03:20.380]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:20.380]                                 info)
[16:03:20.380]                             }
[16:03:20.380]                             else {
[16:03:20.380]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:20.380]                                 info, version)
[16:03:20.380]                             }
[16:03:20.380]                             base::stop(msg)
[16:03:20.380]                           }
[16:03:20.380]                         })
[16:03:20.380]                       }
[16:03:20.380]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:20.380]                       base::options(mc.cores = 1L)
[16:03:20.380]                     }
[16:03:20.380]                     base::local({
[16:03:20.380]                       for (pkg in c("stats", "future.apply")) {
[16:03:20.380]                         base::loadNamespace(pkg)
[16:03:20.380]                         base::library(pkg, character.only = TRUE)
[16:03:20.380]                       }
[16:03:20.380]                     })
[16:03:20.380]                   }
[16:03:20.380]                   options(future.plan = NULL)
[16:03:20.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.380]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:20.380]                 }
[16:03:20.380]                 ...future.workdir <- getwd()
[16:03:20.380]             }
[16:03:20.380]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:20.380]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:20.380]         }
[16:03:20.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:20.380]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:20.380]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:20.380]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:20.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:20.380]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:20.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:20.380]             base::names(...future.oldOptions))
[16:03:20.380]     }
[16:03:20.380]     if (FALSE) {
[16:03:20.380]     }
[16:03:20.380]     else {
[16:03:20.380]         if (TRUE) {
[16:03:20.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:20.380]                 open = "w")
[16:03:20.380]         }
[16:03:20.380]         else {
[16:03:20.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:20.380]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:20.380]         }
[16:03:20.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:20.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:20.380]             base::sink(type = "output", split = FALSE)
[16:03:20.380]             base::close(...future.stdout)
[16:03:20.380]         }, add = TRUE)
[16:03:20.380]     }
[16:03:20.380]     ...future.frame <- base::sys.nframe()
[16:03:20.380]     ...future.conditions <- base::list()
[16:03:20.380]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:20.380]     if (FALSE) {
[16:03:20.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:20.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:20.380]     }
[16:03:20.380]     ...future.result <- base::tryCatch({
[16:03:20.380]         base::withCallingHandlers({
[16:03:20.380]             ...future.value <- base::withVisible(base::local({
[16:03:20.380]                 ...future.makeSendCondition <- base::local({
[16:03:20.380]                   sendCondition <- NULL
[16:03:20.380]                   function(frame = 1L) {
[16:03:20.380]                     if (is.function(sendCondition)) 
[16:03:20.380]                       return(sendCondition)
[16:03:20.380]                     ns <- getNamespace("parallel")
[16:03:20.380]                     if (exists("sendData", mode = "function", 
[16:03:20.380]                       envir = ns)) {
[16:03:20.380]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:20.380]                         envir = ns)
[16:03:20.380]                       envir <- sys.frame(frame)
[16:03:20.380]                       master <- NULL
[16:03:20.380]                       while (!identical(envir, .GlobalEnv) && 
[16:03:20.380]                         !identical(envir, emptyenv())) {
[16:03:20.380]                         if (exists("master", mode = "list", envir = envir, 
[16:03:20.380]                           inherits = FALSE)) {
[16:03:20.380]                           master <- get("master", mode = "list", 
[16:03:20.380]                             envir = envir, inherits = FALSE)
[16:03:20.380]                           if (inherits(master, c("SOCKnode", 
[16:03:20.380]                             "SOCK0node"))) {
[16:03:20.380]                             sendCondition <<- function(cond) {
[16:03:20.380]                               data <- list(type = "VALUE", value = cond, 
[16:03:20.380]                                 success = TRUE)
[16:03:20.380]                               parallel_sendData(master, data)
[16:03:20.380]                             }
[16:03:20.380]                             return(sendCondition)
[16:03:20.380]                           }
[16:03:20.380]                         }
[16:03:20.380]                         frame <- frame + 1L
[16:03:20.380]                         envir <- sys.frame(frame)
[16:03:20.380]                       }
[16:03:20.380]                     }
[16:03:20.380]                     sendCondition <<- function(cond) NULL
[16:03:20.380]                   }
[16:03:20.380]                 })
[16:03:20.380]                 withCallingHandlers({
[16:03:20.380]                   {
[16:03:20.380]                     do.call(function(...) {
[16:03:20.380]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.380]                       if (!identical(...future.globals.maxSize.org, 
[16:03:20.380]                         ...future.globals.maxSize)) {
[16:03:20.380]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.380]                         on.exit(options(oopts), add = TRUE)
[16:03:20.380]                       }
[16:03:20.380]                       {
[16:03:20.380]                         lapply(seq_along(...future.elements_ii), 
[16:03:20.380]                           FUN = function(jj) {
[16:03:20.380]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.380]                             ...future.FUN(...future.X_jj, ...)
[16:03:20.380]                           })
[16:03:20.380]                       }
[16:03:20.380]                     }, args = future.call.arguments)
[16:03:20.380]                   }
[16:03:20.380]                 }, immediateCondition = function(cond) {
[16:03:20.380]                   sendCondition <- ...future.makeSendCondition()
[16:03:20.380]                   sendCondition(cond)
[16:03:20.380]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.380]                   {
[16:03:20.380]                     inherits <- base::inherits
[16:03:20.380]                     invokeRestart <- base::invokeRestart
[16:03:20.380]                     is.null <- base::is.null
[16:03:20.380]                     muffled <- FALSE
[16:03:20.380]                     if (inherits(cond, "message")) {
[16:03:20.380]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:20.380]                       if (muffled) 
[16:03:20.380]                         invokeRestart("muffleMessage")
[16:03:20.380]                     }
[16:03:20.380]                     else if (inherits(cond, "warning")) {
[16:03:20.380]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:20.380]                       if (muffled) 
[16:03:20.380]                         invokeRestart("muffleWarning")
[16:03:20.380]                     }
[16:03:20.380]                     else if (inherits(cond, "condition")) {
[16:03:20.380]                       if (!is.null(pattern)) {
[16:03:20.380]                         computeRestarts <- base::computeRestarts
[16:03:20.380]                         grepl <- base::grepl
[16:03:20.380]                         restarts <- computeRestarts(cond)
[16:03:20.380]                         for (restart in restarts) {
[16:03:20.380]                           name <- restart$name
[16:03:20.380]                           if (is.null(name)) 
[16:03:20.380]                             next
[16:03:20.380]                           if (!grepl(pattern, name)) 
[16:03:20.380]                             next
[16:03:20.380]                           invokeRestart(restart)
[16:03:20.380]                           muffled <- TRUE
[16:03:20.380]                           break
[16:03:20.380]                         }
[16:03:20.380]                       }
[16:03:20.380]                     }
[16:03:20.380]                     invisible(muffled)
[16:03:20.380]                   }
[16:03:20.380]                   muffleCondition(cond)
[16:03:20.380]                 })
[16:03:20.380]             }))
[16:03:20.380]             future::FutureResult(value = ...future.value$value, 
[16:03:20.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.380]                   ...future.rng), globalenv = if (FALSE) 
[16:03:20.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:20.380]                     ...future.globalenv.names))
[16:03:20.380]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:20.380]         }, condition = base::local({
[16:03:20.380]             c <- base::c
[16:03:20.380]             inherits <- base::inherits
[16:03:20.380]             invokeRestart <- base::invokeRestart
[16:03:20.380]             length <- base::length
[16:03:20.380]             list <- base::list
[16:03:20.380]             seq.int <- base::seq.int
[16:03:20.380]             signalCondition <- base::signalCondition
[16:03:20.380]             sys.calls <- base::sys.calls
[16:03:20.380]             `[[` <- base::`[[`
[16:03:20.380]             `+` <- base::`+`
[16:03:20.380]             `<<-` <- base::`<<-`
[16:03:20.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:20.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:20.380]                   3L)]
[16:03:20.380]             }
[16:03:20.380]             function(cond) {
[16:03:20.380]                 is_error <- inherits(cond, "error")
[16:03:20.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:20.380]                   NULL)
[16:03:20.380]                 if (is_error) {
[16:03:20.380]                   sessionInformation <- function() {
[16:03:20.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:20.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:20.380]                       search = base::search(), system = base::Sys.info())
[16:03:20.380]                   }
[16:03:20.380]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:20.380]                     cond$call), session = sessionInformation(), 
[16:03:20.380]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:20.380]                   signalCondition(cond)
[16:03:20.380]                 }
[16:03:20.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:20.380]                 "immediateCondition"))) {
[16:03:20.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:20.380]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:20.380]                   if (TRUE && !signal) {
[16:03:20.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.380]                     {
[16:03:20.380]                       inherits <- base::inherits
[16:03:20.380]                       invokeRestart <- base::invokeRestart
[16:03:20.380]                       is.null <- base::is.null
[16:03:20.380]                       muffled <- FALSE
[16:03:20.380]                       if (inherits(cond, "message")) {
[16:03:20.380]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.380]                         if (muffled) 
[16:03:20.380]                           invokeRestart("muffleMessage")
[16:03:20.380]                       }
[16:03:20.380]                       else if (inherits(cond, "warning")) {
[16:03:20.380]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.380]                         if (muffled) 
[16:03:20.380]                           invokeRestart("muffleWarning")
[16:03:20.380]                       }
[16:03:20.380]                       else if (inherits(cond, "condition")) {
[16:03:20.380]                         if (!is.null(pattern)) {
[16:03:20.380]                           computeRestarts <- base::computeRestarts
[16:03:20.380]                           grepl <- base::grepl
[16:03:20.380]                           restarts <- computeRestarts(cond)
[16:03:20.380]                           for (restart in restarts) {
[16:03:20.380]                             name <- restart$name
[16:03:20.380]                             if (is.null(name)) 
[16:03:20.380]                               next
[16:03:20.380]                             if (!grepl(pattern, name)) 
[16:03:20.380]                               next
[16:03:20.380]                             invokeRestart(restart)
[16:03:20.380]                             muffled <- TRUE
[16:03:20.380]                             break
[16:03:20.380]                           }
[16:03:20.380]                         }
[16:03:20.380]                       }
[16:03:20.380]                       invisible(muffled)
[16:03:20.380]                     }
[16:03:20.380]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.380]                   }
[16:03:20.380]                 }
[16:03:20.380]                 else {
[16:03:20.380]                   if (TRUE) {
[16:03:20.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.380]                     {
[16:03:20.380]                       inherits <- base::inherits
[16:03:20.380]                       invokeRestart <- base::invokeRestart
[16:03:20.380]                       is.null <- base::is.null
[16:03:20.380]                       muffled <- FALSE
[16:03:20.380]                       if (inherits(cond, "message")) {
[16:03:20.380]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.380]                         if (muffled) 
[16:03:20.380]                           invokeRestart("muffleMessage")
[16:03:20.380]                       }
[16:03:20.380]                       else if (inherits(cond, "warning")) {
[16:03:20.380]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.380]                         if (muffled) 
[16:03:20.380]                           invokeRestart("muffleWarning")
[16:03:20.380]                       }
[16:03:20.380]                       else if (inherits(cond, "condition")) {
[16:03:20.380]                         if (!is.null(pattern)) {
[16:03:20.380]                           computeRestarts <- base::computeRestarts
[16:03:20.380]                           grepl <- base::grepl
[16:03:20.380]                           restarts <- computeRestarts(cond)
[16:03:20.380]                           for (restart in restarts) {
[16:03:20.380]                             name <- restart$name
[16:03:20.380]                             if (is.null(name)) 
[16:03:20.380]                               next
[16:03:20.380]                             if (!grepl(pattern, name)) 
[16:03:20.380]                               next
[16:03:20.380]                             invokeRestart(restart)
[16:03:20.380]                             muffled <- TRUE
[16:03:20.380]                             break
[16:03:20.380]                           }
[16:03:20.380]                         }
[16:03:20.380]                       }
[16:03:20.380]                       invisible(muffled)
[16:03:20.380]                     }
[16:03:20.380]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.380]                   }
[16:03:20.380]                 }
[16:03:20.380]             }
[16:03:20.380]         }))
[16:03:20.380]     }, error = function(ex) {
[16:03:20.380]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:20.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.380]                 ...future.rng), started = ...future.startTime, 
[16:03:20.380]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:20.380]             version = "1.8"), class = "FutureResult")
[16:03:20.380]     }, finally = {
[16:03:20.380]         if (!identical(...future.workdir, getwd())) 
[16:03:20.380]             setwd(...future.workdir)
[16:03:20.380]         {
[16:03:20.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:20.380]                 ...future.oldOptions$nwarnings <- NULL
[16:03:20.380]             }
[16:03:20.380]             base::options(...future.oldOptions)
[16:03:20.380]             if (.Platform$OS.type == "windows") {
[16:03:20.380]                 old_names <- names(...future.oldEnvVars)
[16:03:20.380]                 envs <- base::Sys.getenv()
[16:03:20.380]                 names <- names(envs)
[16:03:20.380]                 common <- intersect(names, old_names)
[16:03:20.380]                 added <- setdiff(names, old_names)
[16:03:20.380]                 removed <- setdiff(old_names, names)
[16:03:20.380]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:20.380]                   envs[common]]
[16:03:20.380]                 NAMES <- toupper(changed)
[16:03:20.380]                 args <- list()
[16:03:20.380]                 for (kk in seq_along(NAMES)) {
[16:03:20.380]                   name <- changed[[kk]]
[16:03:20.380]                   NAME <- NAMES[[kk]]
[16:03:20.380]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.380]                     next
[16:03:20.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.380]                 }
[16:03:20.380]                 NAMES <- toupper(added)
[16:03:20.380]                 for (kk in seq_along(NAMES)) {
[16:03:20.380]                   name <- added[[kk]]
[16:03:20.380]                   NAME <- NAMES[[kk]]
[16:03:20.380]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.380]                     next
[16:03:20.380]                   args[[name]] <- ""
[16:03:20.380]                 }
[16:03:20.380]                 NAMES <- toupper(removed)
[16:03:20.380]                 for (kk in seq_along(NAMES)) {
[16:03:20.380]                   name <- removed[[kk]]
[16:03:20.380]                   NAME <- NAMES[[kk]]
[16:03:20.380]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.380]                     next
[16:03:20.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.380]                 }
[16:03:20.380]                 if (length(args) > 0) 
[16:03:20.380]                   base::do.call(base::Sys.setenv, args = args)
[16:03:20.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:20.380]             }
[16:03:20.380]             else {
[16:03:20.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:20.380]             }
[16:03:20.380]             {
[16:03:20.380]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:20.380]                   0L) {
[16:03:20.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:20.380]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:20.380]                   base::options(opts)
[16:03:20.380]                 }
[16:03:20.380]                 {
[16:03:20.380]                   {
[16:03:20.380]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:20.380]                     NULL
[16:03:20.380]                   }
[16:03:20.380]                   options(future.plan = NULL)
[16:03:20.380]                   if (is.na(NA_character_)) 
[16:03:20.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:20.380]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:20.380]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:20.380]                     envir = parent.frame()) 
[16:03:20.380]                   {
[16:03:20.380]                     if (is.function(workers)) 
[16:03:20.380]                       workers <- workers()
[16:03:20.380]                     workers <- structure(as.integer(workers), 
[16:03:20.380]                       class = class(workers))
[16:03:20.380]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:20.380]                       workers >= 1)
[16:03:20.380]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:20.380]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:20.380]                     }
[16:03:20.380]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:20.380]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:20.380]                       envir = envir)
[16:03:20.380]                     if (!future$lazy) 
[16:03:20.380]                       future <- run(future)
[16:03:20.380]                     invisible(future)
[16:03:20.380]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:20.380]                 }
[16:03:20.380]             }
[16:03:20.380]         }
[16:03:20.380]     })
[16:03:20.380]     if (TRUE) {
[16:03:20.380]         base::sink(type = "output", split = FALSE)
[16:03:20.380]         if (TRUE) {
[16:03:20.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:20.380]         }
[16:03:20.380]         else {
[16:03:20.380]             ...future.result["stdout"] <- base::list(NULL)
[16:03:20.380]         }
[16:03:20.380]         base::close(...future.stdout)
[16:03:20.380]         ...future.stdout <- NULL
[16:03:20.380]     }
[16:03:20.380]     ...future.result$conditions <- ...future.conditions
[16:03:20.380]     ...future.result$finished <- base::Sys.time()
[16:03:20.380]     ...future.result
[16:03:20.380] }
[16:03:20.383] Exporting 11 global objects (137.93 KiB) to cluster node #2 ...
[16:03:20.383] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:20.427] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:20.427] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ...
[16:03:20.471] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ... DONE
[16:03:20.471] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:20.472] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:20.472] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:20.515] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:20.515] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:20.559] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:20.559] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:03:20.560] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:03:20.560] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:03:20.560] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:03:20.560] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:20.561] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:20.561] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[16:03:20.561] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[16:03:20.561] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:20.561] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:20.562] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:20.562] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:20.562] Exporting 11 global objects (137.93 KiB) to cluster node #2 ... DONE
[16:03:20.563] MultisessionFuture started
[16:03:20.563] - Launch lazy future ... done
[16:03:20.563] run() for ‘MultisessionFuture’ ... done
[16:03:20.563] Created future:
[16:03:20.563] MultisessionFuture:
[16:03:20.563] Label: ‘future_vapply-2’
[16:03:20.563] Expression:
[16:03:20.563] {
[16:03:20.563]     do.call(function(...) {
[16:03:20.563]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.563]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.563]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.563]             on.exit(options(oopts), add = TRUE)
[16:03:20.563]         }
[16:03:20.563]         {
[16:03:20.563]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.563]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.563]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.563]             })
[16:03:20.563]         }
[16:03:20.563]     }, args = future.call.arguments)
[16:03:20.563] }
[16:03:20.563] Lazy evaluation: FALSE
[16:03:20.563] Asynchronous evaluation: TRUE
[16:03:20.563] Local evaluation: TRUE
[16:03:20.563] Environment: R_GlobalEnv
[16:03:20.563] Capture standard output: TRUE
[16:03:20.563] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:20.563] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:20.563] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:03:20.563] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:20.563] Resolved: FALSE
[16:03:20.563] Value: <not collected>
[16:03:20.563] Conditions captured: <none>
[16:03:20.563] Early signaling: FALSE
[16:03:20.563] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:20.563] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.575] Chunk #2 of 2 ... DONE
[16:03:20.575] Launching 2 futures (chunks) ... DONE
[16:03:20.575] Resolving 2 futures (chunks) ...
[16:03:20.575] resolve() on list ...
[16:03:20.575]  recursive: 0
[16:03:20.575]  length: 2
[16:03:20.575] 
[16:03:20.576] receiveMessageFromWorker() for ClusterFuture ...
[16:03:20.576] - Validating connection of MultisessionFuture
[16:03:20.576] - received message: FutureResult
[16:03:20.576] - Received FutureResult
[16:03:20.576] - Erased future from FutureRegistry
[16:03:20.576] result() for ClusterFuture ...
[16:03:20.577] - result already collected: FutureResult
[16:03:20.577] result() for ClusterFuture ... done
[16:03:20.577] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:20.577] Future #1
[16:03:20.577] result() for ClusterFuture ...
[16:03:20.577] - result already collected: FutureResult
[16:03:20.577] result() for ClusterFuture ... done
[16:03:20.577] result() for ClusterFuture ...
[16:03:20.577] - result already collected: FutureResult
[16:03:20.577] result() for ClusterFuture ... done
[16:03:20.577] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:20.578] - nx: 2
[16:03:20.578] - relay: TRUE
[16:03:20.578] - stdout: TRUE
[16:03:20.578] - signal: TRUE
[16:03:20.578] - resignal: FALSE
[16:03:20.578] - force: TRUE
[16:03:20.578] - relayed: [n=2] FALSE, FALSE
[16:03:20.578] - queued futures: [n=2] FALSE, FALSE
[16:03:20.578]  - until=1
[16:03:20.578]  - relaying element #1
[16:03:20.578] result() for ClusterFuture ...
[16:03:20.579] - result already collected: FutureResult
[16:03:20.579] result() for ClusterFuture ... done
[16:03:20.579] result() for ClusterFuture ...
[16:03:20.579] - result already collected: FutureResult
[16:03:20.579] result() for ClusterFuture ... done
[16:03:20.579] result() for ClusterFuture ...
[16:03:20.579] - result already collected: FutureResult
[16:03:20.579] result() for ClusterFuture ... done
[16:03:20.579] result() for ClusterFuture ...
[16:03:20.579] - result already collected: FutureResult
[16:03:20.579] result() for ClusterFuture ... done
[16:03:20.580] - relayed: [n=2] TRUE, FALSE
[16:03:20.580] - queued futures: [n=2] TRUE, FALSE
[16:03:20.580] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:20.580]  length: 1 (resolved future 1)
[16:03:20.608] receiveMessageFromWorker() for ClusterFuture ...
[16:03:20.608] - Validating connection of MultisessionFuture
[16:03:20.608] - received message: FutureResult
[16:03:20.608] - Received FutureResult
[16:03:20.609] - Erased future from FutureRegistry
[16:03:20.609] result() for ClusterFuture ...
[16:03:20.609] - result already collected: FutureResult
[16:03:20.609] result() for ClusterFuture ... done
[16:03:20.609] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:20.609] Future #2
[16:03:20.609] result() for ClusterFuture ...
[16:03:20.609] - result already collected: FutureResult
[16:03:20.609] result() for ClusterFuture ... done
[16:03:20.610] result() for ClusterFuture ...
[16:03:20.610] - result already collected: FutureResult
[16:03:20.610] result() for ClusterFuture ... done
[16:03:20.610] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:20.610] - nx: 2
[16:03:20.610] - relay: TRUE
[16:03:20.610] - stdout: TRUE
[16:03:20.610] - signal: TRUE
[16:03:20.610] - resignal: FALSE
[16:03:20.610] - force: TRUE
[16:03:20.610] - relayed: [n=2] TRUE, FALSE
[16:03:20.611] - queued futures: [n=2] TRUE, FALSE
[16:03:20.611]  - until=2
[16:03:20.611]  - relaying element #2
[16:03:20.611] result() for ClusterFuture ...
[16:03:20.611] - result already collected: FutureResult
[16:03:20.611] result() for ClusterFuture ... done
[16:03:20.611] result() for ClusterFuture ...
[16:03:20.611] - result already collected: FutureResult
[16:03:20.611] result() for ClusterFuture ... done
[16:03:20.611] result() for ClusterFuture ...
[16:03:20.612] - result already collected: FutureResult
[16:03:20.612] result() for ClusterFuture ... done
[16:03:20.612] result() for ClusterFuture ...
[16:03:20.612] - result already collected: FutureResult
[16:03:20.612] result() for ClusterFuture ... done
[16:03:20.612] - relayed: [n=2] TRUE, TRUE
[16:03:20.612] - queued futures: [n=2] TRUE, TRUE
[16:03:20.612] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:20.612]  length: 0 (resolved future 2)
[16:03:20.612] Relaying remaining futures
[16:03:20.612] signalConditionsASAP(NULL, pos=0) ...
[16:03:20.613] - nx: 2
[16:03:20.613] - relay: TRUE
[16:03:20.613] - stdout: TRUE
[16:03:20.613] - signal: TRUE
[16:03:20.613] - resignal: FALSE
[16:03:20.613] - force: TRUE
[16:03:20.613] - relayed: [n=2] TRUE, TRUE
[16:03:20.613] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:20.613] - relayed: [n=2] TRUE, TRUE
[16:03:20.613] - queued futures: [n=2] TRUE, TRUE
[16:03:20.613] signalConditionsASAP(NULL, pos=0) ... done
[16:03:20.614] resolve() on list ... DONE
[16:03:20.614] result() for ClusterFuture ...
[16:03:20.614] - result already collected: FutureResult
[16:03:20.614] result() for ClusterFuture ... done
[16:03:20.614] result() for ClusterFuture ...
[16:03:20.614] - result already collected: FutureResult
[16:03:20.614] result() for ClusterFuture ... done
[16:03:20.614] result() for ClusterFuture ...
[16:03:20.614] - result already collected: FutureResult
[16:03:20.614] result() for ClusterFuture ... done
[16:03:20.614] result() for ClusterFuture ...
[16:03:20.615] - result already collected: FutureResult
[16:03:20.615] result() for ClusterFuture ... done
[16:03:20.615]  - Number of value chunks collected: 2
[16:03:20.615] Resolving 2 futures (chunks) ... DONE
[16:03:20.615] Reducing values from 2 chunks ...
[16:03:20.615]  - Number of values collected after concatenation: 7
[16:03:20.615]  - Number of values expected: 7
[16:03:20.615] Reducing values from 2 chunks ... DONE
[16:03:20.615] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[16:03:20.617] future_lapply() ...
[16:03:20.621] Number of chunks: 2
[16:03:20.621] getGlobalsAndPackagesXApply() ...
[16:03:20.621]  - future.globals: TRUE
[16:03:20.621] getGlobalsAndPackages() ...
[16:03:20.621] Searching for globals...
[16:03:20.623] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[16:03:20.623] Searching for globals ... DONE
[16:03:20.623] Resolving globals: FALSE
[16:03:20.624] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[16:03:20.624] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[16:03:20.624] - globals: [1] ‘FUN’
[16:03:20.624] 
[16:03:20.625] getGlobalsAndPackages() ... DONE
[16:03:20.625]  - globals found/used: [n=1] ‘FUN’
[16:03:20.625]  - needed namespaces: [n=0] 
[16:03:20.625] Finding globals ... DONE
[16:03:20.625]  - use_args: TRUE
[16:03:20.625]  - Getting '...' globals ...
[16:03:20.625] resolve() on list ...
[16:03:20.626]  recursive: 0
[16:03:20.626]  length: 1
[16:03:20.626]  elements: ‘...’
[16:03:20.626]  length: 0 (resolved future 1)
[16:03:20.626] resolve() on list ... DONE
[16:03:20.626]    - '...' content: [n=1] ‘y’
[16:03:20.626] List of 1
[16:03:20.626]  $ ...:List of 1
[16:03:20.626]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:20.626]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:20.626]  - attr(*, "where")=List of 1
[16:03:20.626]   ..$ ...:<environment: 0x564e432acf78> 
[16:03:20.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:20.626]  - attr(*, "resolved")= logi TRUE
[16:03:20.626]  - attr(*, "total_size")= num NA
[16:03:20.629]  - Getting '...' globals ... DONE
[16:03:20.630] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:20.630] List of 2
[16:03:20.630]  $ ...future.FUN:function (x, y)  
[16:03:20.630]  $ ...          :List of 1
[16:03:20.630]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:20.630]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:20.630]  - attr(*, "where")=List of 2
[16:03:20.630]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:20.630]   ..$ ...          :<environment: 0x564e432acf78> 
[16:03:20.630]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:20.630]  - attr(*, "resolved")= logi FALSE
[16:03:20.630]  - attr(*, "total_size")= num 4264
[16:03:20.633] Packages to be attached in all futures: [n=0] 
[16:03:20.633] getGlobalsAndPackagesXApply() ... DONE
[16:03:20.633] Number of futures (= number of chunks): 2
[16:03:20.633] Launching 2 futures (chunks) ...
[16:03:20.633] Chunk #1 of 2 ...
[16:03:20.633]  - Finding globals in 'X' for chunk #1 ...
[16:03:20.633] getGlobalsAndPackages() ...
[16:03:20.634] Searching for globals...
[16:03:20.634] 
[16:03:20.634] Searching for globals ... DONE
[16:03:20.634] - globals: [0] <none>
[16:03:20.634] getGlobalsAndPackages() ... DONE
[16:03:20.634]    + additional globals found: [n=0] 
[16:03:20.634]    + additional namespaces needed: [n=0] 
[16:03:20.634]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:20.634]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:20.634]  - seeds: <none>
[16:03:20.635]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.635] getGlobalsAndPackages() ...
[16:03:20.635] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.635] Resolving globals: FALSE
[16:03:20.635] Tweak future expression to call with '...' arguments ...
[16:03:20.635] {
[16:03:20.635]     do.call(function(...) {
[16:03:20.635]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.635]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.635]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.635]             on.exit(options(oopts), add = TRUE)
[16:03:20.635]         }
[16:03:20.635]         {
[16:03:20.635]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.635]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.635]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.635]             })
[16:03:20.635]         }
[16:03:20.635]     }, args = future.call.arguments)
[16:03:20.635] }
[16:03:20.635] Tweak future expression to call with '...' arguments ... DONE
[16:03:20.636] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.636] 
[16:03:20.636] getGlobalsAndPackages() ... DONE
[16:03:20.636] run() for ‘Future’ ...
[16:03:20.636] - state: ‘created’
[16:03:20.637] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:20.650] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.651] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:20.651]   - Field: ‘node’
[16:03:20.651]   - Field: ‘label’
[16:03:20.651]   - Field: ‘local’
[16:03:20.651]   - Field: ‘owner’
[16:03:20.651]   - Field: ‘envir’
[16:03:20.651]   - Field: ‘workers’
[16:03:20.651]   - Field: ‘packages’
[16:03:20.651]   - Field: ‘gc’
[16:03:20.651]   - Field: ‘conditions’
[16:03:20.652]   - Field: ‘persistent’
[16:03:20.652]   - Field: ‘expr’
[16:03:20.652]   - Field: ‘uuid’
[16:03:20.652]   - Field: ‘seed’
[16:03:20.652]   - Field: ‘version’
[16:03:20.652]   - Field: ‘result’
[16:03:20.652]   - Field: ‘asynchronous’
[16:03:20.652]   - Field: ‘calls’
[16:03:20.652]   - Field: ‘globals’
[16:03:20.652]   - Field: ‘stdout’
[16:03:20.652]   - Field: ‘earlySignal’
[16:03:20.653]   - Field: ‘lazy’
[16:03:20.653]   - Field: ‘state’
[16:03:20.653] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:20.653] - Launch lazy future ...
[16:03:20.653] Packages needed by the future expression (n = 0): <none>
[16:03:20.653] Packages needed by future strategies (n = 0): <none>
[16:03:20.654] {
[16:03:20.654]     {
[16:03:20.654]         {
[16:03:20.654]             ...future.startTime <- base::Sys.time()
[16:03:20.654]             {
[16:03:20.654]                 {
[16:03:20.654]                   {
[16:03:20.654]                     {
[16:03:20.654]                       base::local({
[16:03:20.654]                         has_future <- base::requireNamespace("future", 
[16:03:20.654]                           quietly = TRUE)
[16:03:20.654]                         if (has_future) {
[16:03:20.654]                           ns <- base::getNamespace("future")
[16:03:20.654]                           version <- ns[[".package"]][["version"]]
[16:03:20.654]                           if (is.null(version)) 
[16:03:20.654]                             version <- utils::packageVersion("future")
[16:03:20.654]                         }
[16:03:20.654]                         else {
[16:03:20.654]                           version <- NULL
[16:03:20.654]                         }
[16:03:20.654]                         if (!has_future || version < "1.8.0") {
[16:03:20.654]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:20.654]                             "", base::R.version$version.string), 
[16:03:20.654]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:20.654]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:20.654]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:20.654]                               "release", "version")], collapse = " "), 
[16:03:20.654]                             hostname = base::Sys.info()[["nodename"]])
[16:03:20.654]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:20.654]                             info)
[16:03:20.654]                           info <- base::paste(info, collapse = "; ")
[16:03:20.654]                           if (!has_future) {
[16:03:20.654]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:20.654]                               info)
[16:03:20.654]                           }
[16:03:20.654]                           else {
[16:03:20.654]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:20.654]                               info, version)
[16:03:20.654]                           }
[16:03:20.654]                           base::stop(msg)
[16:03:20.654]                         }
[16:03:20.654]                       })
[16:03:20.654]                     }
[16:03:20.654]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:20.654]                     base::options(mc.cores = 1L)
[16:03:20.654]                   }
[16:03:20.654]                   options(future.plan = NULL)
[16:03:20.654]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.654]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:20.654]                 }
[16:03:20.654]                 ...future.workdir <- getwd()
[16:03:20.654]             }
[16:03:20.654]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:20.654]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:20.654]         }
[16:03:20.654]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:20.654]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:20.654]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:20.654]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:20.654]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:20.654]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:20.654]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:20.654]             base::names(...future.oldOptions))
[16:03:20.654]     }
[16:03:20.654]     if (FALSE) {
[16:03:20.654]     }
[16:03:20.654]     else {
[16:03:20.654]         if (TRUE) {
[16:03:20.654]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:20.654]                 open = "w")
[16:03:20.654]         }
[16:03:20.654]         else {
[16:03:20.654]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:20.654]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:20.654]         }
[16:03:20.654]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:20.654]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:20.654]             base::sink(type = "output", split = FALSE)
[16:03:20.654]             base::close(...future.stdout)
[16:03:20.654]         }, add = TRUE)
[16:03:20.654]     }
[16:03:20.654]     ...future.frame <- base::sys.nframe()
[16:03:20.654]     ...future.conditions <- base::list()
[16:03:20.654]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:20.654]     if (FALSE) {
[16:03:20.654]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:20.654]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:20.654]     }
[16:03:20.654]     ...future.result <- base::tryCatch({
[16:03:20.654]         base::withCallingHandlers({
[16:03:20.654]             ...future.value <- base::withVisible(base::local({
[16:03:20.654]                 ...future.makeSendCondition <- base::local({
[16:03:20.654]                   sendCondition <- NULL
[16:03:20.654]                   function(frame = 1L) {
[16:03:20.654]                     if (is.function(sendCondition)) 
[16:03:20.654]                       return(sendCondition)
[16:03:20.654]                     ns <- getNamespace("parallel")
[16:03:20.654]                     if (exists("sendData", mode = "function", 
[16:03:20.654]                       envir = ns)) {
[16:03:20.654]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:20.654]                         envir = ns)
[16:03:20.654]                       envir <- sys.frame(frame)
[16:03:20.654]                       master <- NULL
[16:03:20.654]                       while (!identical(envir, .GlobalEnv) && 
[16:03:20.654]                         !identical(envir, emptyenv())) {
[16:03:20.654]                         if (exists("master", mode = "list", envir = envir, 
[16:03:20.654]                           inherits = FALSE)) {
[16:03:20.654]                           master <- get("master", mode = "list", 
[16:03:20.654]                             envir = envir, inherits = FALSE)
[16:03:20.654]                           if (inherits(master, c("SOCKnode", 
[16:03:20.654]                             "SOCK0node"))) {
[16:03:20.654]                             sendCondition <<- function(cond) {
[16:03:20.654]                               data <- list(type = "VALUE", value = cond, 
[16:03:20.654]                                 success = TRUE)
[16:03:20.654]                               parallel_sendData(master, data)
[16:03:20.654]                             }
[16:03:20.654]                             return(sendCondition)
[16:03:20.654]                           }
[16:03:20.654]                         }
[16:03:20.654]                         frame <- frame + 1L
[16:03:20.654]                         envir <- sys.frame(frame)
[16:03:20.654]                       }
[16:03:20.654]                     }
[16:03:20.654]                     sendCondition <<- function(cond) NULL
[16:03:20.654]                   }
[16:03:20.654]                 })
[16:03:20.654]                 withCallingHandlers({
[16:03:20.654]                   {
[16:03:20.654]                     do.call(function(...) {
[16:03:20.654]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.654]                       if (!identical(...future.globals.maxSize.org, 
[16:03:20.654]                         ...future.globals.maxSize)) {
[16:03:20.654]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.654]                         on.exit(options(oopts), add = TRUE)
[16:03:20.654]                       }
[16:03:20.654]                       {
[16:03:20.654]                         lapply(seq_along(...future.elements_ii), 
[16:03:20.654]                           FUN = function(jj) {
[16:03:20.654]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.654]                             ...future.FUN(...future.X_jj, ...)
[16:03:20.654]                           })
[16:03:20.654]                       }
[16:03:20.654]                     }, args = future.call.arguments)
[16:03:20.654]                   }
[16:03:20.654]                 }, immediateCondition = function(cond) {
[16:03:20.654]                   sendCondition <- ...future.makeSendCondition()
[16:03:20.654]                   sendCondition(cond)
[16:03:20.654]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.654]                   {
[16:03:20.654]                     inherits <- base::inherits
[16:03:20.654]                     invokeRestart <- base::invokeRestart
[16:03:20.654]                     is.null <- base::is.null
[16:03:20.654]                     muffled <- FALSE
[16:03:20.654]                     if (inherits(cond, "message")) {
[16:03:20.654]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:20.654]                       if (muffled) 
[16:03:20.654]                         invokeRestart("muffleMessage")
[16:03:20.654]                     }
[16:03:20.654]                     else if (inherits(cond, "warning")) {
[16:03:20.654]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:20.654]                       if (muffled) 
[16:03:20.654]                         invokeRestart("muffleWarning")
[16:03:20.654]                     }
[16:03:20.654]                     else if (inherits(cond, "condition")) {
[16:03:20.654]                       if (!is.null(pattern)) {
[16:03:20.654]                         computeRestarts <- base::computeRestarts
[16:03:20.654]                         grepl <- base::grepl
[16:03:20.654]                         restarts <- computeRestarts(cond)
[16:03:20.654]                         for (restart in restarts) {
[16:03:20.654]                           name <- restart$name
[16:03:20.654]                           if (is.null(name)) 
[16:03:20.654]                             next
[16:03:20.654]                           if (!grepl(pattern, name)) 
[16:03:20.654]                             next
[16:03:20.654]                           invokeRestart(restart)
[16:03:20.654]                           muffled <- TRUE
[16:03:20.654]                           break
[16:03:20.654]                         }
[16:03:20.654]                       }
[16:03:20.654]                     }
[16:03:20.654]                     invisible(muffled)
[16:03:20.654]                   }
[16:03:20.654]                   muffleCondition(cond)
[16:03:20.654]                 })
[16:03:20.654]             }))
[16:03:20.654]             future::FutureResult(value = ...future.value$value, 
[16:03:20.654]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.654]                   ...future.rng), globalenv = if (FALSE) 
[16:03:20.654]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:20.654]                     ...future.globalenv.names))
[16:03:20.654]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:20.654]         }, condition = base::local({
[16:03:20.654]             c <- base::c
[16:03:20.654]             inherits <- base::inherits
[16:03:20.654]             invokeRestart <- base::invokeRestart
[16:03:20.654]             length <- base::length
[16:03:20.654]             list <- base::list
[16:03:20.654]             seq.int <- base::seq.int
[16:03:20.654]             signalCondition <- base::signalCondition
[16:03:20.654]             sys.calls <- base::sys.calls
[16:03:20.654]             `[[` <- base::`[[`
[16:03:20.654]             `+` <- base::`+`
[16:03:20.654]             `<<-` <- base::`<<-`
[16:03:20.654]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:20.654]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:20.654]                   3L)]
[16:03:20.654]             }
[16:03:20.654]             function(cond) {
[16:03:20.654]                 is_error <- inherits(cond, "error")
[16:03:20.654]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:20.654]                   NULL)
[16:03:20.654]                 if (is_error) {
[16:03:20.654]                   sessionInformation <- function() {
[16:03:20.654]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:20.654]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:20.654]                       search = base::search(), system = base::Sys.info())
[16:03:20.654]                   }
[16:03:20.654]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.654]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:20.654]                     cond$call), session = sessionInformation(), 
[16:03:20.654]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:20.654]                   signalCondition(cond)
[16:03:20.654]                 }
[16:03:20.654]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:20.654]                 "immediateCondition"))) {
[16:03:20.654]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:20.654]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.654]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:20.654]                   if (TRUE && !signal) {
[16:03:20.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.654]                     {
[16:03:20.654]                       inherits <- base::inherits
[16:03:20.654]                       invokeRestart <- base::invokeRestart
[16:03:20.654]                       is.null <- base::is.null
[16:03:20.654]                       muffled <- FALSE
[16:03:20.654]                       if (inherits(cond, "message")) {
[16:03:20.654]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.654]                         if (muffled) 
[16:03:20.654]                           invokeRestart("muffleMessage")
[16:03:20.654]                       }
[16:03:20.654]                       else if (inherits(cond, "warning")) {
[16:03:20.654]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.654]                         if (muffled) 
[16:03:20.654]                           invokeRestart("muffleWarning")
[16:03:20.654]                       }
[16:03:20.654]                       else if (inherits(cond, "condition")) {
[16:03:20.654]                         if (!is.null(pattern)) {
[16:03:20.654]                           computeRestarts <- base::computeRestarts
[16:03:20.654]                           grepl <- base::grepl
[16:03:20.654]                           restarts <- computeRestarts(cond)
[16:03:20.654]                           for (restart in restarts) {
[16:03:20.654]                             name <- restart$name
[16:03:20.654]                             if (is.null(name)) 
[16:03:20.654]                               next
[16:03:20.654]                             if (!grepl(pattern, name)) 
[16:03:20.654]                               next
[16:03:20.654]                             invokeRestart(restart)
[16:03:20.654]                             muffled <- TRUE
[16:03:20.654]                             break
[16:03:20.654]                           }
[16:03:20.654]                         }
[16:03:20.654]                       }
[16:03:20.654]                       invisible(muffled)
[16:03:20.654]                     }
[16:03:20.654]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.654]                   }
[16:03:20.654]                 }
[16:03:20.654]                 else {
[16:03:20.654]                   if (TRUE) {
[16:03:20.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.654]                     {
[16:03:20.654]                       inherits <- base::inherits
[16:03:20.654]                       invokeRestart <- base::invokeRestart
[16:03:20.654]                       is.null <- base::is.null
[16:03:20.654]                       muffled <- FALSE
[16:03:20.654]                       if (inherits(cond, "message")) {
[16:03:20.654]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.654]                         if (muffled) 
[16:03:20.654]                           invokeRestart("muffleMessage")
[16:03:20.654]                       }
[16:03:20.654]                       else if (inherits(cond, "warning")) {
[16:03:20.654]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.654]                         if (muffled) 
[16:03:20.654]                           invokeRestart("muffleWarning")
[16:03:20.654]                       }
[16:03:20.654]                       else if (inherits(cond, "condition")) {
[16:03:20.654]                         if (!is.null(pattern)) {
[16:03:20.654]                           computeRestarts <- base::computeRestarts
[16:03:20.654]                           grepl <- base::grepl
[16:03:20.654]                           restarts <- computeRestarts(cond)
[16:03:20.654]                           for (restart in restarts) {
[16:03:20.654]                             name <- restart$name
[16:03:20.654]                             if (is.null(name)) 
[16:03:20.654]                               next
[16:03:20.654]                             if (!grepl(pattern, name)) 
[16:03:20.654]                               next
[16:03:20.654]                             invokeRestart(restart)
[16:03:20.654]                             muffled <- TRUE
[16:03:20.654]                             break
[16:03:20.654]                           }
[16:03:20.654]                         }
[16:03:20.654]                       }
[16:03:20.654]                       invisible(muffled)
[16:03:20.654]                     }
[16:03:20.654]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.654]                   }
[16:03:20.654]                 }
[16:03:20.654]             }
[16:03:20.654]         }))
[16:03:20.654]     }, error = function(ex) {
[16:03:20.654]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:20.654]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.654]                 ...future.rng), started = ...future.startTime, 
[16:03:20.654]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:20.654]             version = "1.8"), class = "FutureResult")
[16:03:20.654]     }, finally = {
[16:03:20.654]         if (!identical(...future.workdir, getwd())) 
[16:03:20.654]             setwd(...future.workdir)
[16:03:20.654]         {
[16:03:20.654]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:20.654]                 ...future.oldOptions$nwarnings <- NULL
[16:03:20.654]             }
[16:03:20.654]             base::options(...future.oldOptions)
[16:03:20.654]             if (.Platform$OS.type == "windows") {
[16:03:20.654]                 old_names <- names(...future.oldEnvVars)
[16:03:20.654]                 envs <- base::Sys.getenv()
[16:03:20.654]                 names <- names(envs)
[16:03:20.654]                 common <- intersect(names, old_names)
[16:03:20.654]                 added <- setdiff(names, old_names)
[16:03:20.654]                 removed <- setdiff(old_names, names)
[16:03:20.654]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:20.654]                   envs[common]]
[16:03:20.654]                 NAMES <- toupper(changed)
[16:03:20.654]                 args <- list()
[16:03:20.654]                 for (kk in seq_along(NAMES)) {
[16:03:20.654]                   name <- changed[[kk]]
[16:03:20.654]                   NAME <- NAMES[[kk]]
[16:03:20.654]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.654]                     next
[16:03:20.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.654]                 }
[16:03:20.654]                 NAMES <- toupper(added)
[16:03:20.654]                 for (kk in seq_along(NAMES)) {
[16:03:20.654]                   name <- added[[kk]]
[16:03:20.654]                   NAME <- NAMES[[kk]]
[16:03:20.654]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.654]                     next
[16:03:20.654]                   args[[name]] <- ""
[16:03:20.654]                 }
[16:03:20.654]                 NAMES <- toupper(removed)
[16:03:20.654]                 for (kk in seq_along(NAMES)) {
[16:03:20.654]                   name <- removed[[kk]]
[16:03:20.654]                   NAME <- NAMES[[kk]]
[16:03:20.654]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.654]                     next
[16:03:20.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.654]                 }
[16:03:20.654]                 if (length(args) > 0) 
[16:03:20.654]                   base::do.call(base::Sys.setenv, args = args)
[16:03:20.654]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:20.654]             }
[16:03:20.654]             else {
[16:03:20.654]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:20.654]             }
[16:03:20.654]             {
[16:03:20.654]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:20.654]                   0L) {
[16:03:20.654]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:20.654]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:20.654]                   base::options(opts)
[16:03:20.654]                 }
[16:03:20.654]                 {
[16:03:20.654]                   {
[16:03:20.654]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:20.654]                     NULL
[16:03:20.654]                   }
[16:03:20.654]                   options(future.plan = NULL)
[16:03:20.654]                   if (is.na(NA_character_)) 
[16:03:20.654]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.654]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:20.654]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:20.654]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:20.654]                     envir = parent.frame()) 
[16:03:20.654]                   {
[16:03:20.654]                     if (is.function(workers)) 
[16:03:20.654]                       workers <- workers()
[16:03:20.654]                     workers <- structure(as.integer(workers), 
[16:03:20.654]                       class = class(workers))
[16:03:20.654]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:20.654]                       workers >= 1)
[16:03:20.654]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:20.654]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:20.654]                     }
[16:03:20.654]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:20.654]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:20.654]                       envir = envir)
[16:03:20.654]                     if (!future$lazy) 
[16:03:20.654]                       future <- run(future)
[16:03:20.654]                     invisible(future)
[16:03:20.654]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:20.654]                 }
[16:03:20.654]             }
[16:03:20.654]         }
[16:03:20.654]     })
[16:03:20.654]     if (TRUE) {
[16:03:20.654]         base::sink(type = "output", split = FALSE)
[16:03:20.654]         if (TRUE) {
[16:03:20.654]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:20.654]         }
[16:03:20.654]         else {
[16:03:20.654]             ...future.result["stdout"] <- base::list(NULL)
[16:03:20.654]         }
[16:03:20.654]         base::close(...future.stdout)
[16:03:20.654]         ...future.stdout <- NULL
[16:03:20.654]     }
[16:03:20.654]     ...future.result$conditions <- ...future.conditions
[16:03:20.654]     ...future.result$finished <- base::Sys.time()
[16:03:20.654]     ...future.result
[16:03:20.654] }
[16:03:20.656] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[16:03:20.657] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[16:03:20.657] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[16:03:20.657] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[16:03:20.657] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[16:03:20.658] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:03:20.658] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:03:20.658] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:20.658] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:20.658] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:20.659] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:20.659] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[16:03:20.659] MultisessionFuture started
[16:03:20.659] - Launch lazy future ... done
[16:03:20.660] run() for ‘MultisessionFuture’ ... done
[16:03:20.660] Created future:
[16:03:20.660] MultisessionFuture:
[16:03:20.660] Label: ‘future_sapply-1’
[16:03:20.660] Expression:
[16:03:20.660] {
[16:03:20.660]     do.call(function(...) {
[16:03:20.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.660]             on.exit(options(oopts), add = TRUE)
[16:03:20.660]         }
[16:03:20.660]         {
[16:03:20.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.660]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.660]             })
[16:03:20.660]         }
[16:03:20.660]     }, args = future.call.arguments)
[16:03:20.660] }
[16:03:20.660] Lazy evaluation: FALSE
[16:03:20.660] Asynchronous evaluation: TRUE
[16:03:20.660] Local evaluation: TRUE
[16:03:20.660] Environment: R_GlobalEnv
[16:03:20.660] Capture standard output: TRUE
[16:03:20.660] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:20.660] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:20.660] Packages: <none>
[16:03:20.660] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:20.660] Resolved: FALSE
[16:03:20.660] Value: <not collected>
[16:03:20.660] Conditions captured: <none>
[16:03:20.660] Early signaling: FALSE
[16:03:20.660] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:20.660] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.671] Chunk #1 of 2 ... DONE
[16:03:20.671] Chunk #2 of 2 ...
[16:03:20.672]  - Finding globals in 'X' for chunk #2 ...
[16:03:20.672] getGlobalsAndPackages() ...
[16:03:20.672] Searching for globals...
[16:03:20.672] 
[16:03:20.672] Searching for globals ... DONE
[16:03:20.672] - globals: [0] <none>
[16:03:20.672] getGlobalsAndPackages() ... DONE
[16:03:20.672]    + additional globals found: [n=0] 
[16:03:20.672]    + additional namespaces needed: [n=0] 
[16:03:20.673]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:20.673]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:20.673]  - seeds: <none>
[16:03:20.673]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.673] getGlobalsAndPackages() ...
[16:03:20.673] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.673] Resolving globals: FALSE
[16:03:20.673] Tweak future expression to call with '...' arguments ...
[16:03:20.673] {
[16:03:20.673]     do.call(function(...) {
[16:03:20.673]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.673]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.673]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.673]             on.exit(options(oopts), add = TRUE)
[16:03:20.673]         }
[16:03:20.673]         {
[16:03:20.673]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.673]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.673]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.673]             })
[16:03:20.673]         }
[16:03:20.673]     }, args = future.call.arguments)
[16:03:20.673] }
[16:03:20.674] Tweak future expression to call with '...' arguments ... DONE
[16:03:20.674] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.674] 
[16:03:20.674] getGlobalsAndPackages() ... DONE
[16:03:20.674] run() for ‘Future’ ...
[16:03:20.674] - state: ‘created’
[16:03:20.675] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:20.688] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:20.688]   - Field: ‘node’
[16:03:20.689]   - Field: ‘label’
[16:03:20.689]   - Field: ‘local’
[16:03:20.689]   - Field: ‘owner’
[16:03:20.689]   - Field: ‘envir’
[16:03:20.689]   - Field: ‘workers’
[16:03:20.689]   - Field: ‘packages’
[16:03:20.689]   - Field: ‘gc’
[16:03:20.689]   - Field: ‘conditions’
[16:03:20.689]   - Field: ‘persistent’
[16:03:20.689]   - Field: ‘expr’
[16:03:20.690]   - Field: ‘uuid’
[16:03:20.690]   - Field: ‘seed’
[16:03:20.690]   - Field: ‘version’
[16:03:20.690]   - Field: ‘result’
[16:03:20.690]   - Field: ‘asynchronous’
[16:03:20.690]   - Field: ‘calls’
[16:03:20.690]   - Field: ‘globals’
[16:03:20.690]   - Field: ‘stdout’
[16:03:20.690]   - Field: ‘earlySignal’
[16:03:20.690]   - Field: ‘lazy’
[16:03:20.690]   - Field: ‘state’
[16:03:20.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:20.691] - Launch lazy future ...
[16:03:20.691] Packages needed by the future expression (n = 0): <none>
[16:03:20.691] Packages needed by future strategies (n = 0): <none>
[16:03:20.692] {
[16:03:20.692]     {
[16:03:20.692]         {
[16:03:20.692]             ...future.startTime <- base::Sys.time()
[16:03:20.692]             {
[16:03:20.692]                 {
[16:03:20.692]                   {
[16:03:20.692]                     {
[16:03:20.692]                       base::local({
[16:03:20.692]                         has_future <- base::requireNamespace("future", 
[16:03:20.692]                           quietly = TRUE)
[16:03:20.692]                         if (has_future) {
[16:03:20.692]                           ns <- base::getNamespace("future")
[16:03:20.692]                           version <- ns[[".package"]][["version"]]
[16:03:20.692]                           if (is.null(version)) 
[16:03:20.692]                             version <- utils::packageVersion("future")
[16:03:20.692]                         }
[16:03:20.692]                         else {
[16:03:20.692]                           version <- NULL
[16:03:20.692]                         }
[16:03:20.692]                         if (!has_future || version < "1.8.0") {
[16:03:20.692]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:20.692]                             "", base::R.version$version.string), 
[16:03:20.692]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:20.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:20.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:20.692]                               "release", "version")], collapse = " "), 
[16:03:20.692]                             hostname = base::Sys.info()[["nodename"]])
[16:03:20.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:20.692]                             info)
[16:03:20.692]                           info <- base::paste(info, collapse = "; ")
[16:03:20.692]                           if (!has_future) {
[16:03:20.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:20.692]                               info)
[16:03:20.692]                           }
[16:03:20.692]                           else {
[16:03:20.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:20.692]                               info, version)
[16:03:20.692]                           }
[16:03:20.692]                           base::stop(msg)
[16:03:20.692]                         }
[16:03:20.692]                       })
[16:03:20.692]                     }
[16:03:20.692]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:20.692]                     base::options(mc.cores = 1L)
[16:03:20.692]                   }
[16:03:20.692]                   options(future.plan = NULL)
[16:03:20.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:20.692]                 }
[16:03:20.692]                 ...future.workdir <- getwd()
[16:03:20.692]             }
[16:03:20.692]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:20.692]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:20.692]         }
[16:03:20.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:20.692]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:20.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:20.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:20.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:20.692]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:20.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:20.692]             base::names(...future.oldOptions))
[16:03:20.692]     }
[16:03:20.692]     if (FALSE) {
[16:03:20.692]     }
[16:03:20.692]     else {
[16:03:20.692]         if (TRUE) {
[16:03:20.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:20.692]                 open = "w")
[16:03:20.692]         }
[16:03:20.692]         else {
[16:03:20.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:20.692]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:20.692]         }
[16:03:20.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:20.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:20.692]             base::sink(type = "output", split = FALSE)
[16:03:20.692]             base::close(...future.stdout)
[16:03:20.692]         }, add = TRUE)
[16:03:20.692]     }
[16:03:20.692]     ...future.frame <- base::sys.nframe()
[16:03:20.692]     ...future.conditions <- base::list()
[16:03:20.692]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:20.692]     if (FALSE) {
[16:03:20.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:20.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:20.692]     }
[16:03:20.692]     ...future.result <- base::tryCatch({
[16:03:20.692]         base::withCallingHandlers({
[16:03:20.692]             ...future.value <- base::withVisible(base::local({
[16:03:20.692]                 ...future.makeSendCondition <- base::local({
[16:03:20.692]                   sendCondition <- NULL
[16:03:20.692]                   function(frame = 1L) {
[16:03:20.692]                     if (is.function(sendCondition)) 
[16:03:20.692]                       return(sendCondition)
[16:03:20.692]                     ns <- getNamespace("parallel")
[16:03:20.692]                     if (exists("sendData", mode = "function", 
[16:03:20.692]                       envir = ns)) {
[16:03:20.692]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:20.692]                         envir = ns)
[16:03:20.692]                       envir <- sys.frame(frame)
[16:03:20.692]                       master <- NULL
[16:03:20.692]                       while (!identical(envir, .GlobalEnv) && 
[16:03:20.692]                         !identical(envir, emptyenv())) {
[16:03:20.692]                         if (exists("master", mode = "list", envir = envir, 
[16:03:20.692]                           inherits = FALSE)) {
[16:03:20.692]                           master <- get("master", mode = "list", 
[16:03:20.692]                             envir = envir, inherits = FALSE)
[16:03:20.692]                           if (inherits(master, c("SOCKnode", 
[16:03:20.692]                             "SOCK0node"))) {
[16:03:20.692]                             sendCondition <<- function(cond) {
[16:03:20.692]                               data <- list(type = "VALUE", value = cond, 
[16:03:20.692]                                 success = TRUE)
[16:03:20.692]                               parallel_sendData(master, data)
[16:03:20.692]                             }
[16:03:20.692]                             return(sendCondition)
[16:03:20.692]                           }
[16:03:20.692]                         }
[16:03:20.692]                         frame <- frame + 1L
[16:03:20.692]                         envir <- sys.frame(frame)
[16:03:20.692]                       }
[16:03:20.692]                     }
[16:03:20.692]                     sendCondition <<- function(cond) NULL
[16:03:20.692]                   }
[16:03:20.692]                 })
[16:03:20.692]                 withCallingHandlers({
[16:03:20.692]                   {
[16:03:20.692]                     do.call(function(...) {
[16:03:20.692]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.692]                       if (!identical(...future.globals.maxSize.org, 
[16:03:20.692]                         ...future.globals.maxSize)) {
[16:03:20.692]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.692]                         on.exit(options(oopts), add = TRUE)
[16:03:20.692]                       }
[16:03:20.692]                       {
[16:03:20.692]                         lapply(seq_along(...future.elements_ii), 
[16:03:20.692]                           FUN = function(jj) {
[16:03:20.692]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.692]                             ...future.FUN(...future.X_jj, ...)
[16:03:20.692]                           })
[16:03:20.692]                       }
[16:03:20.692]                     }, args = future.call.arguments)
[16:03:20.692]                   }
[16:03:20.692]                 }, immediateCondition = function(cond) {
[16:03:20.692]                   sendCondition <- ...future.makeSendCondition()
[16:03:20.692]                   sendCondition(cond)
[16:03:20.692]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.692]                   {
[16:03:20.692]                     inherits <- base::inherits
[16:03:20.692]                     invokeRestart <- base::invokeRestart
[16:03:20.692]                     is.null <- base::is.null
[16:03:20.692]                     muffled <- FALSE
[16:03:20.692]                     if (inherits(cond, "message")) {
[16:03:20.692]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:20.692]                       if (muffled) 
[16:03:20.692]                         invokeRestart("muffleMessage")
[16:03:20.692]                     }
[16:03:20.692]                     else if (inherits(cond, "warning")) {
[16:03:20.692]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:20.692]                       if (muffled) 
[16:03:20.692]                         invokeRestart("muffleWarning")
[16:03:20.692]                     }
[16:03:20.692]                     else if (inherits(cond, "condition")) {
[16:03:20.692]                       if (!is.null(pattern)) {
[16:03:20.692]                         computeRestarts <- base::computeRestarts
[16:03:20.692]                         grepl <- base::grepl
[16:03:20.692]                         restarts <- computeRestarts(cond)
[16:03:20.692]                         for (restart in restarts) {
[16:03:20.692]                           name <- restart$name
[16:03:20.692]                           if (is.null(name)) 
[16:03:20.692]                             next
[16:03:20.692]                           if (!grepl(pattern, name)) 
[16:03:20.692]                             next
[16:03:20.692]                           invokeRestart(restart)
[16:03:20.692]                           muffled <- TRUE
[16:03:20.692]                           break
[16:03:20.692]                         }
[16:03:20.692]                       }
[16:03:20.692]                     }
[16:03:20.692]                     invisible(muffled)
[16:03:20.692]                   }
[16:03:20.692]                   muffleCondition(cond)
[16:03:20.692]                 })
[16:03:20.692]             }))
[16:03:20.692]             future::FutureResult(value = ...future.value$value, 
[16:03:20.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.692]                   ...future.rng), globalenv = if (FALSE) 
[16:03:20.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:20.692]                     ...future.globalenv.names))
[16:03:20.692]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:20.692]         }, condition = base::local({
[16:03:20.692]             c <- base::c
[16:03:20.692]             inherits <- base::inherits
[16:03:20.692]             invokeRestart <- base::invokeRestart
[16:03:20.692]             length <- base::length
[16:03:20.692]             list <- base::list
[16:03:20.692]             seq.int <- base::seq.int
[16:03:20.692]             signalCondition <- base::signalCondition
[16:03:20.692]             sys.calls <- base::sys.calls
[16:03:20.692]             `[[` <- base::`[[`
[16:03:20.692]             `+` <- base::`+`
[16:03:20.692]             `<<-` <- base::`<<-`
[16:03:20.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:20.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:20.692]                   3L)]
[16:03:20.692]             }
[16:03:20.692]             function(cond) {
[16:03:20.692]                 is_error <- inherits(cond, "error")
[16:03:20.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:20.692]                   NULL)
[16:03:20.692]                 if (is_error) {
[16:03:20.692]                   sessionInformation <- function() {
[16:03:20.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:20.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:20.692]                       search = base::search(), system = base::Sys.info())
[16:03:20.692]                   }
[16:03:20.692]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:20.692]                     cond$call), session = sessionInformation(), 
[16:03:20.692]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:20.692]                   signalCondition(cond)
[16:03:20.692]                 }
[16:03:20.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:20.692]                 "immediateCondition"))) {
[16:03:20.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:20.692]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:20.692]                   if (TRUE && !signal) {
[16:03:20.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.692]                     {
[16:03:20.692]                       inherits <- base::inherits
[16:03:20.692]                       invokeRestart <- base::invokeRestart
[16:03:20.692]                       is.null <- base::is.null
[16:03:20.692]                       muffled <- FALSE
[16:03:20.692]                       if (inherits(cond, "message")) {
[16:03:20.692]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.692]                         if (muffled) 
[16:03:20.692]                           invokeRestart("muffleMessage")
[16:03:20.692]                       }
[16:03:20.692]                       else if (inherits(cond, "warning")) {
[16:03:20.692]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.692]                         if (muffled) 
[16:03:20.692]                           invokeRestart("muffleWarning")
[16:03:20.692]                       }
[16:03:20.692]                       else if (inherits(cond, "condition")) {
[16:03:20.692]                         if (!is.null(pattern)) {
[16:03:20.692]                           computeRestarts <- base::computeRestarts
[16:03:20.692]                           grepl <- base::grepl
[16:03:20.692]                           restarts <- computeRestarts(cond)
[16:03:20.692]                           for (restart in restarts) {
[16:03:20.692]                             name <- restart$name
[16:03:20.692]                             if (is.null(name)) 
[16:03:20.692]                               next
[16:03:20.692]                             if (!grepl(pattern, name)) 
[16:03:20.692]                               next
[16:03:20.692]                             invokeRestart(restart)
[16:03:20.692]                             muffled <- TRUE
[16:03:20.692]                             break
[16:03:20.692]                           }
[16:03:20.692]                         }
[16:03:20.692]                       }
[16:03:20.692]                       invisible(muffled)
[16:03:20.692]                     }
[16:03:20.692]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.692]                   }
[16:03:20.692]                 }
[16:03:20.692]                 else {
[16:03:20.692]                   if (TRUE) {
[16:03:20.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.692]                     {
[16:03:20.692]                       inherits <- base::inherits
[16:03:20.692]                       invokeRestart <- base::invokeRestart
[16:03:20.692]                       is.null <- base::is.null
[16:03:20.692]                       muffled <- FALSE
[16:03:20.692]                       if (inherits(cond, "message")) {
[16:03:20.692]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.692]                         if (muffled) 
[16:03:20.692]                           invokeRestart("muffleMessage")
[16:03:20.692]                       }
[16:03:20.692]                       else if (inherits(cond, "warning")) {
[16:03:20.692]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.692]                         if (muffled) 
[16:03:20.692]                           invokeRestart("muffleWarning")
[16:03:20.692]                       }
[16:03:20.692]                       else if (inherits(cond, "condition")) {
[16:03:20.692]                         if (!is.null(pattern)) {
[16:03:20.692]                           computeRestarts <- base::computeRestarts
[16:03:20.692]                           grepl <- base::grepl
[16:03:20.692]                           restarts <- computeRestarts(cond)
[16:03:20.692]                           for (restart in restarts) {
[16:03:20.692]                             name <- restart$name
[16:03:20.692]                             if (is.null(name)) 
[16:03:20.692]                               next
[16:03:20.692]                             if (!grepl(pattern, name)) 
[16:03:20.692]                               next
[16:03:20.692]                             invokeRestart(restart)
[16:03:20.692]                             muffled <- TRUE
[16:03:20.692]                             break
[16:03:20.692]                           }
[16:03:20.692]                         }
[16:03:20.692]                       }
[16:03:20.692]                       invisible(muffled)
[16:03:20.692]                     }
[16:03:20.692]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.692]                   }
[16:03:20.692]                 }
[16:03:20.692]             }
[16:03:20.692]         }))
[16:03:20.692]     }, error = function(ex) {
[16:03:20.692]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:20.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.692]                 ...future.rng), started = ...future.startTime, 
[16:03:20.692]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:20.692]             version = "1.8"), class = "FutureResult")
[16:03:20.692]     }, finally = {
[16:03:20.692]         if (!identical(...future.workdir, getwd())) 
[16:03:20.692]             setwd(...future.workdir)
[16:03:20.692]         {
[16:03:20.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:20.692]                 ...future.oldOptions$nwarnings <- NULL
[16:03:20.692]             }
[16:03:20.692]             base::options(...future.oldOptions)
[16:03:20.692]             if (.Platform$OS.type == "windows") {
[16:03:20.692]                 old_names <- names(...future.oldEnvVars)
[16:03:20.692]                 envs <- base::Sys.getenv()
[16:03:20.692]                 names <- names(envs)
[16:03:20.692]                 common <- intersect(names, old_names)
[16:03:20.692]                 added <- setdiff(names, old_names)
[16:03:20.692]                 removed <- setdiff(old_names, names)
[16:03:20.692]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:20.692]                   envs[common]]
[16:03:20.692]                 NAMES <- toupper(changed)
[16:03:20.692]                 args <- list()
[16:03:20.692]                 for (kk in seq_along(NAMES)) {
[16:03:20.692]                   name <- changed[[kk]]
[16:03:20.692]                   NAME <- NAMES[[kk]]
[16:03:20.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.692]                     next
[16:03:20.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.692]                 }
[16:03:20.692]                 NAMES <- toupper(added)
[16:03:20.692]                 for (kk in seq_along(NAMES)) {
[16:03:20.692]                   name <- added[[kk]]
[16:03:20.692]                   NAME <- NAMES[[kk]]
[16:03:20.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.692]                     next
[16:03:20.692]                   args[[name]] <- ""
[16:03:20.692]                 }
[16:03:20.692]                 NAMES <- toupper(removed)
[16:03:20.692]                 for (kk in seq_along(NAMES)) {
[16:03:20.692]                   name <- removed[[kk]]
[16:03:20.692]                   NAME <- NAMES[[kk]]
[16:03:20.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.692]                     next
[16:03:20.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.692]                 }
[16:03:20.692]                 if (length(args) > 0) 
[16:03:20.692]                   base::do.call(base::Sys.setenv, args = args)
[16:03:20.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:20.692]             }
[16:03:20.692]             else {
[16:03:20.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:20.692]             }
[16:03:20.692]             {
[16:03:20.692]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:20.692]                   0L) {
[16:03:20.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:20.692]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:20.692]                   base::options(opts)
[16:03:20.692]                 }
[16:03:20.692]                 {
[16:03:20.692]                   {
[16:03:20.692]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:20.692]                     NULL
[16:03:20.692]                   }
[16:03:20.692]                   options(future.plan = NULL)
[16:03:20.692]                   if (is.na(NA_character_)) 
[16:03:20.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:20.692]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:20.692]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:20.692]                     envir = parent.frame()) 
[16:03:20.692]                   {
[16:03:20.692]                     if (is.function(workers)) 
[16:03:20.692]                       workers <- workers()
[16:03:20.692]                     workers <- structure(as.integer(workers), 
[16:03:20.692]                       class = class(workers))
[16:03:20.692]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:20.692]                       workers >= 1)
[16:03:20.692]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:20.692]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:20.692]                     }
[16:03:20.692]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:20.692]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:20.692]                       envir = envir)
[16:03:20.692]                     if (!future$lazy) 
[16:03:20.692]                       future <- run(future)
[16:03:20.692]                     invisible(future)
[16:03:20.692]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:20.692]                 }
[16:03:20.692]             }
[16:03:20.692]         }
[16:03:20.692]     })
[16:03:20.692]     if (TRUE) {
[16:03:20.692]         base::sink(type = "output", split = FALSE)
[16:03:20.692]         if (TRUE) {
[16:03:20.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:20.692]         }
[16:03:20.692]         else {
[16:03:20.692]             ...future.result["stdout"] <- base::list(NULL)
[16:03:20.692]         }
[16:03:20.692]         base::close(...future.stdout)
[16:03:20.692]         ...future.stdout <- NULL
[16:03:20.692]     }
[16:03:20.692]     ...future.result$conditions <- ...future.conditions
[16:03:20.692]     ...future.result$finished <- base::Sys.time()
[16:03:20.692]     ...future.result
[16:03:20.692] }
[16:03:20.694] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[16:03:20.694] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[16:03:20.695] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[16:03:20.695] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[16:03:20.696] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[16:03:20.696] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:03:20.696] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:03:20.696] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:20.697] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:20.697] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:20.697] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:20.697] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[16:03:20.698] MultisessionFuture started
[16:03:20.698] - Launch lazy future ... done
[16:03:20.698] run() for ‘MultisessionFuture’ ... done
[16:03:20.698] Created future:
[16:03:20.698] MultisessionFuture:
[16:03:20.698] Label: ‘future_sapply-2’
[16:03:20.698] Expression:
[16:03:20.698] {
[16:03:20.698]     do.call(function(...) {
[16:03:20.698]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.698]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.698]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.698]             on.exit(options(oopts), add = TRUE)
[16:03:20.698]         }
[16:03:20.698]         {
[16:03:20.698]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.698]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.698]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.698]             })
[16:03:20.698]         }
[16:03:20.698]     }, args = future.call.arguments)
[16:03:20.698] }
[16:03:20.698] Lazy evaluation: FALSE
[16:03:20.698] Asynchronous evaluation: TRUE
[16:03:20.698] Local evaluation: TRUE
[16:03:20.698] Environment: R_GlobalEnv
[16:03:20.698] Capture standard output: TRUE
[16:03:20.698] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:20.698] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:20.698] Packages: <none>
[16:03:20.698] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:20.698] Resolved: FALSE
[16:03:20.698] Value: <not collected>
[16:03:20.698] Conditions captured: <none>
[16:03:20.698] Early signaling: FALSE
[16:03:20.698] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:20.698] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.710] Chunk #2 of 2 ... DONE
[16:03:20.710] Launching 2 futures (chunks) ... DONE
[16:03:20.710] Resolving 2 futures (chunks) ...
[16:03:20.710] resolve() on list ...
[16:03:20.710]  recursive: 0
[16:03:20.710]  length: 2
[16:03:20.710] 
[16:03:20.712] receiveMessageFromWorker() for ClusterFuture ...
[16:03:20.712] - Validating connection of MultisessionFuture
[16:03:20.712] - received message: FutureResult
[16:03:20.712] - Received FutureResult
[16:03:20.712] - Erased future from FutureRegistry
[16:03:20.713] result() for ClusterFuture ...
[16:03:20.713] - result already collected: FutureResult
[16:03:20.713] result() for ClusterFuture ... done
[16:03:20.713] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:20.713] Future #1
[16:03:20.713] result() for ClusterFuture ...
[16:03:20.713] - result already collected: FutureResult
[16:03:20.713] result() for ClusterFuture ... done
[16:03:20.713] result() for ClusterFuture ...
[16:03:20.713] - result already collected: FutureResult
[16:03:20.713] result() for ClusterFuture ... done
[16:03:20.714] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:20.714] - nx: 2
[16:03:20.714] - relay: TRUE
[16:03:20.714] - stdout: TRUE
[16:03:20.714] - signal: TRUE
[16:03:20.714] - resignal: FALSE
[16:03:20.714] - force: TRUE
[16:03:20.714] - relayed: [n=2] FALSE, FALSE
[16:03:20.714] - queued futures: [n=2] FALSE, FALSE
[16:03:20.714]  - until=1
[16:03:20.714]  - relaying element #1
[16:03:20.715] result() for ClusterFuture ...
[16:03:20.715] - result already collected: FutureResult
[16:03:20.715] result() for ClusterFuture ... done
[16:03:20.715] result() for ClusterFuture ...
[16:03:20.715] - result already collected: FutureResult
[16:03:20.715] result() for ClusterFuture ... done
[16:03:20.715] result() for ClusterFuture ...
[16:03:20.715] - result already collected: FutureResult
[16:03:20.715] result() for ClusterFuture ... done
[16:03:20.715] result() for ClusterFuture ...
[16:03:20.716] - result already collected: FutureResult
[16:03:20.716] result() for ClusterFuture ... done
[16:03:20.716] - relayed: [n=2] TRUE, FALSE
[16:03:20.716] - queued futures: [n=2] TRUE, FALSE
[16:03:20.716] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:20.716]  length: 1 (resolved future 1)
[16:03:20.744] receiveMessageFromWorker() for ClusterFuture ...
[16:03:20.744] - Validating connection of MultisessionFuture
[16:03:20.744] - received message: FutureResult
[16:03:20.744] - Received FutureResult
[16:03:20.744] - Erased future from FutureRegistry
[16:03:20.745] result() for ClusterFuture ...
[16:03:20.745] - result already collected: FutureResult
[16:03:20.745] result() for ClusterFuture ... done
[16:03:20.745] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:20.745] Future #2
[16:03:20.745] result() for ClusterFuture ...
[16:03:20.745] - result already collected: FutureResult
[16:03:20.745] result() for ClusterFuture ... done
[16:03:20.745] result() for ClusterFuture ...
[16:03:20.745] - result already collected: FutureResult
[16:03:20.745] result() for ClusterFuture ... done
[16:03:20.746] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:20.746] - nx: 2
[16:03:20.746] - relay: TRUE
[16:03:20.746] - stdout: TRUE
[16:03:20.746] - signal: TRUE
[16:03:20.746] - resignal: FALSE
[16:03:20.746] - force: TRUE
[16:03:20.746] - relayed: [n=2] TRUE, FALSE
[16:03:20.746] - queued futures: [n=2] TRUE, FALSE
[16:03:20.746]  - until=2
[16:03:20.746]  - relaying element #2
[16:03:20.746] result() for ClusterFuture ...
[16:03:20.747] - result already collected: FutureResult
[16:03:20.747] result() for ClusterFuture ... done
[16:03:20.747] result() for ClusterFuture ...
[16:03:20.747] - result already collected: FutureResult
[16:03:20.747] result() for ClusterFuture ... done
[16:03:20.747] result() for ClusterFuture ...
[16:03:20.747] - result already collected: FutureResult
[16:03:20.747] result() for ClusterFuture ... done
[16:03:20.747] result() for ClusterFuture ...
[16:03:20.747] - result already collected: FutureResult
[16:03:20.747] result() for ClusterFuture ... done
[16:03:20.748] - relayed: [n=2] TRUE, TRUE
[16:03:20.748] - queued futures: [n=2] TRUE, TRUE
[16:03:20.748] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:20.748]  length: 0 (resolved future 2)
[16:03:20.748] Relaying remaining futures
[16:03:20.748] signalConditionsASAP(NULL, pos=0) ...
[16:03:20.748] - nx: 2
[16:03:20.748] - relay: TRUE
[16:03:20.748] - stdout: TRUE
[16:03:20.748] - signal: TRUE
[16:03:20.748] - resignal: FALSE
[16:03:20.749] - force: TRUE
[16:03:20.749] - relayed: [n=2] TRUE, TRUE
[16:03:20.749] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:20.749] - relayed: [n=2] TRUE, TRUE
[16:03:20.749] - queued futures: [n=2] TRUE, TRUE
[16:03:20.749] signalConditionsASAP(NULL, pos=0) ... done
[16:03:20.749] resolve() on list ... DONE
[16:03:20.749] result() for ClusterFuture ...
[16:03:20.749] - result already collected: FutureResult
[16:03:20.749] result() for ClusterFuture ... done
[16:03:20.749] result() for ClusterFuture ...
[16:03:20.750] - result already collected: FutureResult
[16:03:20.750] result() for ClusterFuture ... done
[16:03:20.750] result() for ClusterFuture ...
[16:03:20.750] - result already collected: FutureResult
[16:03:20.750] result() for ClusterFuture ... done
[16:03:20.750] result() for ClusterFuture ...
[16:03:20.750] - result already collected: FutureResult
[16:03:20.750] result() for ClusterFuture ... done
[16:03:20.750]  - Number of value chunks collected: 2
[16:03:20.750] Resolving 2 futures (chunks) ... DONE
[16:03:20.750] Reducing values from 2 chunks ...
[16:03:20.751]  - Number of values collected after concatenation: 4
[16:03:20.751]  - Number of values expected: 4
[16:03:20.751] Reducing values from 2 chunks ... DONE
[16:03:20.751] future_lapply() ... DONE
[16:03:20.751] future_lapply() ...
[16:03:20.757] Number of chunks: 2
[16:03:20.757] getGlobalsAndPackagesXApply() ...
[16:03:20.757]  - future.globals: TRUE
[16:03:20.757] getGlobalsAndPackages() ...
[16:03:20.757] Searching for globals...
[16:03:20.761] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[16:03:20.761] Searching for globals ... DONE
[16:03:20.761] Resolving globals: FALSE
[16:03:20.764] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[16:03:20.764] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:20.765] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:20.765] - packages: [1] ‘future.apply’
[16:03:20.765] getGlobalsAndPackages() ... DONE
[16:03:20.765]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:20.765]  - needed namespaces: [n=1] ‘future.apply’
[16:03:20.765] Finding globals ... DONE
[16:03:20.765]  - use_args: TRUE
[16:03:20.765]  - Getting '...' globals ...
[16:03:20.765] resolve() on list ...
[16:03:20.766]  recursive: 0
[16:03:20.766]  length: 1
[16:03:20.766]  elements: ‘...’
[16:03:20.766]  length: 0 (resolved future 1)
[16:03:20.766] resolve() on list ... DONE
[16:03:20.766]    - '...' content: [n=1] ‘y’
[16:03:20.766] List of 1
[16:03:20.766]  $ ...:List of 1
[16:03:20.766]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:20.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:20.766]  - attr(*, "where")=List of 1
[16:03:20.766]   ..$ ...:<environment: 0x564e449c3f88> 
[16:03:20.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:20.766]  - attr(*, "resolved")= logi TRUE
[16:03:20.766]  - attr(*, "total_size")= num NA
[16:03:20.769]  - Getting '...' globals ... DONE
[16:03:20.769] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:20.769] List of 8
[16:03:20.769]  $ ...future.FUN:function (x, ...)  
[16:03:20.769]  $ x_FUN        :function (x, y)  
[16:03:20.769]  $ times        : int 15
[16:03:20.769]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:20.769]  $ stop_if_not  :function (...)  
[16:03:20.769]  $ dim          : int [1:2] 3 5
[16:03:20.769]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:20.769]  $ ...          :List of 1
[16:03:20.769]   ..$ y: num [1:5] 2 4 6 8 10
[16:03:20.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:20.769]  - attr(*, "where")=List of 8
[16:03:20.769]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:20.769]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:20.769]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:20.769]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:20.769]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:20.769]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:20.769]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:20.769]   ..$ ...          :<environment: 0x564e449c3f88> 
[16:03:20.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:20.769]  - attr(*, "resolved")= logi FALSE
[16:03:20.769]  - attr(*, "total_size")= num 98600
[16:03:20.775] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:20.775] getGlobalsAndPackagesXApply() ... DONE
[16:03:20.776] Number of futures (= number of chunks): 2
[16:03:20.776] Launching 2 futures (chunks) ...
[16:03:20.776] Chunk #1 of 2 ...
[16:03:20.776]  - Finding globals in 'X' for chunk #1 ...
[16:03:20.776] getGlobalsAndPackages() ...
[16:03:20.776] Searching for globals...
[16:03:20.776] 
[16:03:20.776] Searching for globals ... DONE
[16:03:20.777] - globals: [0] <none>
[16:03:20.777] getGlobalsAndPackages() ... DONE
[16:03:20.777]    + additional globals found: [n=0] 
[16:03:20.777]    + additional namespaces needed: [n=0] 
[16:03:20.777]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:20.777]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:20.777]  - seeds: <none>
[16:03:20.777]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.778] getGlobalsAndPackages() ...
[16:03:20.778] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.778] Resolving globals: FALSE
[16:03:20.778] Tweak future expression to call with '...' arguments ...
[16:03:20.778] {
[16:03:20.778]     do.call(function(...) {
[16:03:20.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.778]             on.exit(options(oopts), add = TRUE)
[16:03:20.778]         }
[16:03:20.778]         {
[16:03:20.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.778]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.778]             })
[16:03:20.778]         }
[16:03:20.778]     }, args = future.call.arguments)
[16:03:20.778] }
[16:03:20.779] Tweak future expression to call with '...' arguments ... DONE
[16:03:20.779] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.779] - packages: [1] ‘future.apply’
[16:03:20.780] getGlobalsAndPackages() ... DONE
[16:03:20.780] run() for ‘Future’ ...
[16:03:20.780] - state: ‘created’
[16:03:20.780] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:20.794] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:20.795]   - Field: ‘node’
[16:03:20.795]   - Field: ‘label’
[16:03:20.795]   - Field: ‘local’
[16:03:20.795]   - Field: ‘owner’
[16:03:20.795]   - Field: ‘envir’
[16:03:20.795]   - Field: ‘workers’
[16:03:20.795]   - Field: ‘packages’
[16:03:20.795]   - Field: ‘gc’
[16:03:20.795]   - Field: ‘conditions’
[16:03:20.795]   - Field: ‘persistent’
[16:03:20.796]   - Field: ‘expr’
[16:03:20.796]   - Field: ‘uuid’
[16:03:20.796]   - Field: ‘seed’
[16:03:20.796]   - Field: ‘version’
[16:03:20.796]   - Field: ‘result’
[16:03:20.796]   - Field: ‘asynchronous’
[16:03:20.796]   - Field: ‘calls’
[16:03:20.796]   - Field: ‘globals’
[16:03:20.796]   - Field: ‘stdout’
[16:03:20.796]   - Field: ‘earlySignal’
[16:03:20.796]   - Field: ‘lazy’
[16:03:20.797]   - Field: ‘state’
[16:03:20.797] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:20.797] - Launch lazy future ...
[16:03:20.797] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:20.797] Packages needed by future strategies (n = 0): <none>
[16:03:20.798] {
[16:03:20.798]     {
[16:03:20.798]         {
[16:03:20.798]             ...future.startTime <- base::Sys.time()
[16:03:20.798]             {
[16:03:20.798]                 {
[16:03:20.798]                   {
[16:03:20.798]                     {
[16:03:20.798]                       {
[16:03:20.798]                         base::local({
[16:03:20.798]                           has_future <- base::requireNamespace("future", 
[16:03:20.798]                             quietly = TRUE)
[16:03:20.798]                           if (has_future) {
[16:03:20.798]                             ns <- base::getNamespace("future")
[16:03:20.798]                             version <- ns[[".package"]][["version"]]
[16:03:20.798]                             if (is.null(version)) 
[16:03:20.798]                               version <- utils::packageVersion("future")
[16:03:20.798]                           }
[16:03:20.798]                           else {
[16:03:20.798]                             version <- NULL
[16:03:20.798]                           }
[16:03:20.798]                           if (!has_future || version < "1.8.0") {
[16:03:20.798]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:20.798]                               "", base::R.version$version.string), 
[16:03:20.798]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:20.798]                                 base::R.version$platform, 8 * 
[16:03:20.798]                                   base::.Machine$sizeof.pointer), 
[16:03:20.798]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:20.798]                                 "release", "version")], collapse = " "), 
[16:03:20.798]                               hostname = base::Sys.info()[["nodename"]])
[16:03:20.798]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:20.798]                               info)
[16:03:20.798]                             info <- base::paste(info, collapse = "; ")
[16:03:20.798]                             if (!has_future) {
[16:03:20.798]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:20.798]                                 info)
[16:03:20.798]                             }
[16:03:20.798]                             else {
[16:03:20.798]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:20.798]                                 info, version)
[16:03:20.798]                             }
[16:03:20.798]                             base::stop(msg)
[16:03:20.798]                           }
[16:03:20.798]                         })
[16:03:20.798]                       }
[16:03:20.798]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:20.798]                       base::options(mc.cores = 1L)
[16:03:20.798]                     }
[16:03:20.798]                     base::local({
[16:03:20.798]                       for (pkg in "future.apply") {
[16:03:20.798]                         base::loadNamespace(pkg)
[16:03:20.798]                         base::library(pkg, character.only = TRUE)
[16:03:20.798]                       }
[16:03:20.798]                     })
[16:03:20.798]                   }
[16:03:20.798]                   options(future.plan = NULL)
[16:03:20.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:20.798]                 }
[16:03:20.798]                 ...future.workdir <- getwd()
[16:03:20.798]             }
[16:03:20.798]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:20.798]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:20.798]         }
[16:03:20.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:20.798]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:20.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:20.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:20.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:20.798]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:20.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:20.798]             base::names(...future.oldOptions))
[16:03:20.798]     }
[16:03:20.798]     if (FALSE) {
[16:03:20.798]     }
[16:03:20.798]     else {
[16:03:20.798]         if (TRUE) {
[16:03:20.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:20.798]                 open = "w")
[16:03:20.798]         }
[16:03:20.798]         else {
[16:03:20.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:20.798]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:20.798]         }
[16:03:20.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:20.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:20.798]             base::sink(type = "output", split = FALSE)
[16:03:20.798]             base::close(...future.stdout)
[16:03:20.798]         }, add = TRUE)
[16:03:20.798]     }
[16:03:20.798]     ...future.frame <- base::sys.nframe()
[16:03:20.798]     ...future.conditions <- base::list()
[16:03:20.798]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:20.798]     if (FALSE) {
[16:03:20.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:20.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:20.798]     }
[16:03:20.798]     ...future.result <- base::tryCatch({
[16:03:20.798]         base::withCallingHandlers({
[16:03:20.798]             ...future.value <- base::withVisible(base::local({
[16:03:20.798]                 ...future.makeSendCondition <- base::local({
[16:03:20.798]                   sendCondition <- NULL
[16:03:20.798]                   function(frame = 1L) {
[16:03:20.798]                     if (is.function(sendCondition)) 
[16:03:20.798]                       return(sendCondition)
[16:03:20.798]                     ns <- getNamespace("parallel")
[16:03:20.798]                     if (exists("sendData", mode = "function", 
[16:03:20.798]                       envir = ns)) {
[16:03:20.798]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:20.798]                         envir = ns)
[16:03:20.798]                       envir <- sys.frame(frame)
[16:03:20.798]                       master <- NULL
[16:03:20.798]                       while (!identical(envir, .GlobalEnv) && 
[16:03:20.798]                         !identical(envir, emptyenv())) {
[16:03:20.798]                         if (exists("master", mode = "list", envir = envir, 
[16:03:20.798]                           inherits = FALSE)) {
[16:03:20.798]                           master <- get("master", mode = "list", 
[16:03:20.798]                             envir = envir, inherits = FALSE)
[16:03:20.798]                           if (inherits(master, c("SOCKnode", 
[16:03:20.798]                             "SOCK0node"))) {
[16:03:20.798]                             sendCondition <<- function(cond) {
[16:03:20.798]                               data <- list(type = "VALUE", value = cond, 
[16:03:20.798]                                 success = TRUE)
[16:03:20.798]                               parallel_sendData(master, data)
[16:03:20.798]                             }
[16:03:20.798]                             return(sendCondition)
[16:03:20.798]                           }
[16:03:20.798]                         }
[16:03:20.798]                         frame <- frame + 1L
[16:03:20.798]                         envir <- sys.frame(frame)
[16:03:20.798]                       }
[16:03:20.798]                     }
[16:03:20.798]                     sendCondition <<- function(cond) NULL
[16:03:20.798]                   }
[16:03:20.798]                 })
[16:03:20.798]                 withCallingHandlers({
[16:03:20.798]                   {
[16:03:20.798]                     do.call(function(...) {
[16:03:20.798]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.798]                       if (!identical(...future.globals.maxSize.org, 
[16:03:20.798]                         ...future.globals.maxSize)) {
[16:03:20.798]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.798]                         on.exit(options(oopts), add = TRUE)
[16:03:20.798]                       }
[16:03:20.798]                       {
[16:03:20.798]                         lapply(seq_along(...future.elements_ii), 
[16:03:20.798]                           FUN = function(jj) {
[16:03:20.798]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.798]                             ...future.FUN(...future.X_jj, ...)
[16:03:20.798]                           })
[16:03:20.798]                       }
[16:03:20.798]                     }, args = future.call.arguments)
[16:03:20.798]                   }
[16:03:20.798]                 }, immediateCondition = function(cond) {
[16:03:20.798]                   sendCondition <- ...future.makeSendCondition()
[16:03:20.798]                   sendCondition(cond)
[16:03:20.798]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.798]                   {
[16:03:20.798]                     inherits <- base::inherits
[16:03:20.798]                     invokeRestart <- base::invokeRestart
[16:03:20.798]                     is.null <- base::is.null
[16:03:20.798]                     muffled <- FALSE
[16:03:20.798]                     if (inherits(cond, "message")) {
[16:03:20.798]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:20.798]                       if (muffled) 
[16:03:20.798]                         invokeRestart("muffleMessage")
[16:03:20.798]                     }
[16:03:20.798]                     else if (inherits(cond, "warning")) {
[16:03:20.798]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:20.798]                       if (muffled) 
[16:03:20.798]                         invokeRestart("muffleWarning")
[16:03:20.798]                     }
[16:03:20.798]                     else if (inherits(cond, "condition")) {
[16:03:20.798]                       if (!is.null(pattern)) {
[16:03:20.798]                         computeRestarts <- base::computeRestarts
[16:03:20.798]                         grepl <- base::grepl
[16:03:20.798]                         restarts <- computeRestarts(cond)
[16:03:20.798]                         for (restart in restarts) {
[16:03:20.798]                           name <- restart$name
[16:03:20.798]                           if (is.null(name)) 
[16:03:20.798]                             next
[16:03:20.798]                           if (!grepl(pattern, name)) 
[16:03:20.798]                             next
[16:03:20.798]                           invokeRestart(restart)
[16:03:20.798]                           muffled <- TRUE
[16:03:20.798]                           break
[16:03:20.798]                         }
[16:03:20.798]                       }
[16:03:20.798]                     }
[16:03:20.798]                     invisible(muffled)
[16:03:20.798]                   }
[16:03:20.798]                   muffleCondition(cond)
[16:03:20.798]                 })
[16:03:20.798]             }))
[16:03:20.798]             future::FutureResult(value = ...future.value$value, 
[16:03:20.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.798]                   ...future.rng), globalenv = if (FALSE) 
[16:03:20.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:20.798]                     ...future.globalenv.names))
[16:03:20.798]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:20.798]         }, condition = base::local({
[16:03:20.798]             c <- base::c
[16:03:20.798]             inherits <- base::inherits
[16:03:20.798]             invokeRestart <- base::invokeRestart
[16:03:20.798]             length <- base::length
[16:03:20.798]             list <- base::list
[16:03:20.798]             seq.int <- base::seq.int
[16:03:20.798]             signalCondition <- base::signalCondition
[16:03:20.798]             sys.calls <- base::sys.calls
[16:03:20.798]             `[[` <- base::`[[`
[16:03:20.798]             `+` <- base::`+`
[16:03:20.798]             `<<-` <- base::`<<-`
[16:03:20.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:20.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:20.798]                   3L)]
[16:03:20.798]             }
[16:03:20.798]             function(cond) {
[16:03:20.798]                 is_error <- inherits(cond, "error")
[16:03:20.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:20.798]                   NULL)
[16:03:20.798]                 if (is_error) {
[16:03:20.798]                   sessionInformation <- function() {
[16:03:20.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:20.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:20.798]                       search = base::search(), system = base::Sys.info())
[16:03:20.798]                   }
[16:03:20.798]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:20.798]                     cond$call), session = sessionInformation(), 
[16:03:20.798]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:20.798]                   signalCondition(cond)
[16:03:20.798]                 }
[16:03:20.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:20.798]                 "immediateCondition"))) {
[16:03:20.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:20.798]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:20.798]                   if (TRUE && !signal) {
[16:03:20.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.798]                     {
[16:03:20.798]                       inherits <- base::inherits
[16:03:20.798]                       invokeRestart <- base::invokeRestart
[16:03:20.798]                       is.null <- base::is.null
[16:03:20.798]                       muffled <- FALSE
[16:03:20.798]                       if (inherits(cond, "message")) {
[16:03:20.798]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.798]                         if (muffled) 
[16:03:20.798]                           invokeRestart("muffleMessage")
[16:03:20.798]                       }
[16:03:20.798]                       else if (inherits(cond, "warning")) {
[16:03:20.798]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.798]                         if (muffled) 
[16:03:20.798]                           invokeRestart("muffleWarning")
[16:03:20.798]                       }
[16:03:20.798]                       else if (inherits(cond, "condition")) {
[16:03:20.798]                         if (!is.null(pattern)) {
[16:03:20.798]                           computeRestarts <- base::computeRestarts
[16:03:20.798]                           grepl <- base::grepl
[16:03:20.798]                           restarts <- computeRestarts(cond)
[16:03:20.798]                           for (restart in restarts) {
[16:03:20.798]                             name <- restart$name
[16:03:20.798]                             if (is.null(name)) 
[16:03:20.798]                               next
[16:03:20.798]                             if (!grepl(pattern, name)) 
[16:03:20.798]                               next
[16:03:20.798]                             invokeRestart(restart)
[16:03:20.798]                             muffled <- TRUE
[16:03:20.798]                             break
[16:03:20.798]                           }
[16:03:20.798]                         }
[16:03:20.798]                       }
[16:03:20.798]                       invisible(muffled)
[16:03:20.798]                     }
[16:03:20.798]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.798]                   }
[16:03:20.798]                 }
[16:03:20.798]                 else {
[16:03:20.798]                   if (TRUE) {
[16:03:20.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.798]                     {
[16:03:20.798]                       inherits <- base::inherits
[16:03:20.798]                       invokeRestart <- base::invokeRestart
[16:03:20.798]                       is.null <- base::is.null
[16:03:20.798]                       muffled <- FALSE
[16:03:20.798]                       if (inherits(cond, "message")) {
[16:03:20.798]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.798]                         if (muffled) 
[16:03:20.798]                           invokeRestart("muffleMessage")
[16:03:20.798]                       }
[16:03:20.798]                       else if (inherits(cond, "warning")) {
[16:03:20.798]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.798]                         if (muffled) 
[16:03:20.798]                           invokeRestart("muffleWarning")
[16:03:20.798]                       }
[16:03:20.798]                       else if (inherits(cond, "condition")) {
[16:03:20.798]                         if (!is.null(pattern)) {
[16:03:20.798]                           computeRestarts <- base::computeRestarts
[16:03:20.798]                           grepl <- base::grepl
[16:03:20.798]                           restarts <- computeRestarts(cond)
[16:03:20.798]                           for (restart in restarts) {
[16:03:20.798]                             name <- restart$name
[16:03:20.798]                             if (is.null(name)) 
[16:03:20.798]                               next
[16:03:20.798]                             if (!grepl(pattern, name)) 
[16:03:20.798]                               next
[16:03:20.798]                             invokeRestart(restart)
[16:03:20.798]                             muffled <- TRUE
[16:03:20.798]                             break
[16:03:20.798]                           }
[16:03:20.798]                         }
[16:03:20.798]                       }
[16:03:20.798]                       invisible(muffled)
[16:03:20.798]                     }
[16:03:20.798]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.798]                   }
[16:03:20.798]                 }
[16:03:20.798]             }
[16:03:20.798]         }))
[16:03:20.798]     }, error = function(ex) {
[16:03:20.798]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:20.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.798]                 ...future.rng), started = ...future.startTime, 
[16:03:20.798]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:20.798]             version = "1.8"), class = "FutureResult")
[16:03:20.798]     }, finally = {
[16:03:20.798]         if (!identical(...future.workdir, getwd())) 
[16:03:20.798]             setwd(...future.workdir)
[16:03:20.798]         {
[16:03:20.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:20.798]                 ...future.oldOptions$nwarnings <- NULL
[16:03:20.798]             }
[16:03:20.798]             base::options(...future.oldOptions)
[16:03:20.798]             if (.Platform$OS.type == "windows") {
[16:03:20.798]                 old_names <- names(...future.oldEnvVars)
[16:03:20.798]                 envs <- base::Sys.getenv()
[16:03:20.798]                 names <- names(envs)
[16:03:20.798]                 common <- intersect(names, old_names)
[16:03:20.798]                 added <- setdiff(names, old_names)
[16:03:20.798]                 removed <- setdiff(old_names, names)
[16:03:20.798]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:20.798]                   envs[common]]
[16:03:20.798]                 NAMES <- toupper(changed)
[16:03:20.798]                 args <- list()
[16:03:20.798]                 for (kk in seq_along(NAMES)) {
[16:03:20.798]                   name <- changed[[kk]]
[16:03:20.798]                   NAME <- NAMES[[kk]]
[16:03:20.798]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.798]                     next
[16:03:20.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.798]                 }
[16:03:20.798]                 NAMES <- toupper(added)
[16:03:20.798]                 for (kk in seq_along(NAMES)) {
[16:03:20.798]                   name <- added[[kk]]
[16:03:20.798]                   NAME <- NAMES[[kk]]
[16:03:20.798]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.798]                     next
[16:03:20.798]                   args[[name]] <- ""
[16:03:20.798]                 }
[16:03:20.798]                 NAMES <- toupper(removed)
[16:03:20.798]                 for (kk in seq_along(NAMES)) {
[16:03:20.798]                   name <- removed[[kk]]
[16:03:20.798]                   NAME <- NAMES[[kk]]
[16:03:20.798]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.798]                     next
[16:03:20.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.798]                 }
[16:03:20.798]                 if (length(args) > 0) 
[16:03:20.798]                   base::do.call(base::Sys.setenv, args = args)
[16:03:20.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:20.798]             }
[16:03:20.798]             else {
[16:03:20.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:20.798]             }
[16:03:20.798]             {
[16:03:20.798]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:20.798]                   0L) {
[16:03:20.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:20.798]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:20.798]                   base::options(opts)
[16:03:20.798]                 }
[16:03:20.798]                 {
[16:03:20.798]                   {
[16:03:20.798]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:20.798]                     NULL
[16:03:20.798]                   }
[16:03:20.798]                   options(future.plan = NULL)
[16:03:20.798]                   if (is.na(NA_character_)) 
[16:03:20.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:20.798]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:20.798]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:20.798]                     envir = parent.frame()) 
[16:03:20.798]                   {
[16:03:20.798]                     if (is.function(workers)) 
[16:03:20.798]                       workers <- workers()
[16:03:20.798]                     workers <- structure(as.integer(workers), 
[16:03:20.798]                       class = class(workers))
[16:03:20.798]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:20.798]                       workers >= 1)
[16:03:20.798]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:20.798]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:20.798]                     }
[16:03:20.798]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:20.798]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:20.798]                       envir = envir)
[16:03:20.798]                     if (!future$lazy) 
[16:03:20.798]                       future <- run(future)
[16:03:20.798]                     invisible(future)
[16:03:20.798]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:20.798]                 }
[16:03:20.798]             }
[16:03:20.798]         }
[16:03:20.798]     })
[16:03:20.798]     if (TRUE) {
[16:03:20.798]         base::sink(type = "output", split = FALSE)
[16:03:20.798]         if (TRUE) {
[16:03:20.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:20.798]         }
[16:03:20.798]         else {
[16:03:20.798]             ...future.result["stdout"] <- base::list(NULL)
[16:03:20.798]         }
[16:03:20.798]         base::close(...future.stdout)
[16:03:20.798]         ...future.stdout <- NULL
[16:03:20.798]     }
[16:03:20.798]     ...future.result$conditions <- ...future.conditions
[16:03:20.798]     ...future.result$finished <- base::Sys.time()
[16:03:20.798]     ...future.result
[16:03:20.798] }
[16:03:20.801] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[16:03:20.801] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:20.843] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:20.843] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[16:03:20.844] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[16:03:20.844] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:20.844] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:20.845] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:20.887] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:20.887] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:20.931] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:20.931] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:03:20.932] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:03:20.932] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:03:20.932] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:03:20.932] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[16:03:20.933] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[16:03:20.933] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:03:20.933] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:03:20.933] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:20.934] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:20.934] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:20.934] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:20.934] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[16:03:20.935] MultisessionFuture started
[16:03:20.935] - Launch lazy future ... done
[16:03:20.935] run() for ‘MultisessionFuture’ ... done
[16:03:20.936] Created future:
[16:03:20.936] MultisessionFuture:
[16:03:20.936] Label: ‘future_vapply-1’
[16:03:20.936] Expression:
[16:03:20.936] {
[16:03:20.936]     do.call(function(...) {
[16:03:20.936]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.936]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.936]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.936]             on.exit(options(oopts), add = TRUE)
[16:03:20.936]         }
[16:03:20.936]         {
[16:03:20.936]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.936]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.936]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.936]             })
[16:03:20.936]         }
[16:03:20.936]     }, args = future.call.arguments)
[16:03:20.936] }
[16:03:20.936] Lazy evaluation: FALSE
[16:03:20.936] Asynchronous evaluation: TRUE
[16:03:20.936] Local evaluation: TRUE
[16:03:20.936] Environment: R_GlobalEnv
[16:03:20.936] Capture standard output: TRUE
[16:03:20.936] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:20.936] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:20.936] Packages: 1 packages (‘future.apply’)
[16:03:20.936] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:20.936] Resolved: FALSE
[16:03:20.936] Value: <not collected>
[16:03:20.936] Conditions captured: <none>
[16:03:20.936] Early signaling: FALSE
[16:03:20.936] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:20.936] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.947] Chunk #1 of 2 ... DONE
[16:03:20.947] Chunk #2 of 2 ...
[16:03:20.948]  - Finding globals in 'X' for chunk #2 ...
[16:03:20.948] getGlobalsAndPackages() ...
[16:03:20.948] Searching for globals...
[16:03:20.948] 
[16:03:20.948] Searching for globals ... DONE
[16:03:20.948] - globals: [0] <none>
[16:03:20.948] getGlobalsAndPackages() ... DONE
[16:03:20.949]    + additional globals found: [n=0] 
[16:03:20.949]    + additional namespaces needed: [n=0] 
[16:03:20.949]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:20.949]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:20.949]  - seeds: <none>
[16:03:20.949]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.949] getGlobalsAndPackages() ...
[16:03:20.949] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.949] Resolving globals: FALSE
[16:03:20.949] Tweak future expression to call with '...' arguments ...
[16:03:20.950] {
[16:03:20.950]     do.call(function(...) {
[16:03:20.950]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.950]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:20.950]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.950]             on.exit(options(oopts), add = TRUE)
[16:03:20.950]         }
[16:03:20.950]         {
[16:03:20.950]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:20.950]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.950]                 ...future.FUN(...future.X_jj, ...)
[16:03:20.950]             })
[16:03:20.950]         }
[16:03:20.950]     }, args = future.call.arguments)
[16:03:20.950] }
[16:03:20.950] Tweak future expression to call with '...' arguments ... DONE
[16:03:20.950] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:20.951] - packages: [1] ‘future.apply’
[16:03:20.951] getGlobalsAndPackages() ... DONE
[16:03:20.951] run() for ‘Future’ ...
[16:03:20.951] - state: ‘created’
[16:03:20.951] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:20.965] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:20.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:20.966]   - Field: ‘node’
[16:03:20.966]   - Field: ‘label’
[16:03:20.966]   - Field: ‘local’
[16:03:20.966]   - Field: ‘owner’
[16:03:20.966]   - Field: ‘envir’
[16:03:20.966]   - Field: ‘workers’
[16:03:20.966]   - Field: ‘packages’
[16:03:20.966]   - Field: ‘gc’
[16:03:20.966]   - Field: ‘conditions’
[16:03:20.967]   - Field: ‘persistent’
[16:03:20.967]   - Field: ‘expr’
[16:03:20.967]   - Field: ‘uuid’
[16:03:20.967]   - Field: ‘seed’
[16:03:20.967]   - Field: ‘version’
[16:03:20.967]   - Field: ‘result’
[16:03:20.967]   - Field: ‘asynchronous’
[16:03:20.967]   - Field: ‘calls’
[16:03:20.967]   - Field: ‘globals’
[16:03:20.967]   - Field: ‘stdout’
[16:03:20.968]   - Field: ‘earlySignal’
[16:03:20.968]   - Field: ‘lazy’
[16:03:20.968]   - Field: ‘state’
[16:03:20.968] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:20.968] - Launch lazy future ...
[16:03:20.968] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:20.968] Packages needed by future strategies (n = 0): <none>
[16:03:20.969] {
[16:03:20.969]     {
[16:03:20.969]         {
[16:03:20.969]             ...future.startTime <- base::Sys.time()
[16:03:20.969]             {
[16:03:20.969]                 {
[16:03:20.969]                   {
[16:03:20.969]                     {
[16:03:20.969]                       {
[16:03:20.969]                         base::local({
[16:03:20.969]                           has_future <- base::requireNamespace("future", 
[16:03:20.969]                             quietly = TRUE)
[16:03:20.969]                           if (has_future) {
[16:03:20.969]                             ns <- base::getNamespace("future")
[16:03:20.969]                             version <- ns[[".package"]][["version"]]
[16:03:20.969]                             if (is.null(version)) 
[16:03:20.969]                               version <- utils::packageVersion("future")
[16:03:20.969]                           }
[16:03:20.969]                           else {
[16:03:20.969]                             version <- NULL
[16:03:20.969]                           }
[16:03:20.969]                           if (!has_future || version < "1.8.0") {
[16:03:20.969]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:20.969]                               "", base::R.version$version.string), 
[16:03:20.969]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:20.969]                                 base::R.version$platform, 8 * 
[16:03:20.969]                                   base::.Machine$sizeof.pointer), 
[16:03:20.969]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:20.969]                                 "release", "version")], collapse = " "), 
[16:03:20.969]                               hostname = base::Sys.info()[["nodename"]])
[16:03:20.969]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:20.969]                               info)
[16:03:20.969]                             info <- base::paste(info, collapse = "; ")
[16:03:20.969]                             if (!has_future) {
[16:03:20.969]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:20.969]                                 info)
[16:03:20.969]                             }
[16:03:20.969]                             else {
[16:03:20.969]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:20.969]                                 info, version)
[16:03:20.969]                             }
[16:03:20.969]                             base::stop(msg)
[16:03:20.969]                           }
[16:03:20.969]                         })
[16:03:20.969]                       }
[16:03:20.969]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:20.969]                       base::options(mc.cores = 1L)
[16:03:20.969]                     }
[16:03:20.969]                     base::local({
[16:03:20.969]                       for (pkg in "future.apply") {
[16:03:20.969]                         base::loadNamespace(pkg)
[16:03:20.969]                         base::library(pkg, character.only = TRUE)
[16:03:20.969]                       }
[16:03:20.969]                     })
[16:03:20.969]                   }
[16:03:20.969]                   options(future.plan = NULL)
[16:03:20.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:20.969]                 }
[16:03:20.969]                 ...future.workdir <- getwd()
[16:03:20.969]             }
[16:03:20.969]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:20.969]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:20.969]         }
[16:03:20.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:20.969]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:20.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:20.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:20.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:20.969]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:20.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:20.969]             base::names(...future.oldOptions))
[16:03:20.969]     }
[16:03:20.969]     if (FALSE) {
[16:03:20.969]     }
[16:03:20.969]     else {
[16:03:20.969]         if (TRUE) {
[16:03:20.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:20.969]                 open = "w")
[16:03:20.969]         }
[16:03:20.969]         else {
[16:03:20.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:20.969]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:20.969]         }
[16:03:20.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:20.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:20.969]             base::sink(type = "output", split = FALSE)
[16:03:20.969]             base::close(...future.stdout)
[16:03:20.969]         }, add = TRUE)
[16:03:20.969]     }
[16:03:20.969]     ...future.frame <- base::sys.nframe()
[16:03:20.969]     ...future.conditions <- base::list()
[16:03:20.969]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:20.969]     if (FALSE) {
[16:03:20.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:20.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:20.969]     }
[16:03:20.969]     ...future.result <- base::tryCatch({
[16:03:20.969]         base::withCallingHandlers({
[16:03:20.969]             ...future.value <- base::withVisible(base::local({
[16:03:20.969]                 ...future.makeSendCondition <- base::local({
[16:03:20.969]                   sendCondition <- NULL
[16:03:20.969]                   function(frame = 1L) {
[16:03:20.969]                     if (is.function(sendCondition)) 
[16:03:20.969]                       return(sendCondition)
[16:03:20.969]                     ns <- getNamespace("parallel")
[16:03:20.969]                     if (exists("sendData", mode = "function", 
[16:03:20.969]                       envir = ns)) {
[16:03:20.969]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:20.969]                         envir = ns)
[16:03:20.969]                       envir <- sys.frame(frame)
[16:03:20.969]                       master <- NULL
[16:03:20.969]                       while (!identical(envir, .GlobalEnv) && 
[16:03:20.969]                         !identical(envir, emptyenv())) {
[16:03:20.969]                         if (exists("master", mode = "list", envir = envir, 
[16:03:20.969]                           inherits = FALSE)) {
[16:03:20.969]                           master <- get("master", mode = "list", 
[16:03:20.969]                             envir = envir, inherits = FALSE)
[16:03:20.969]                           if (inherits(master, c("SOCKnode", 
[16:03:20.969]                             "SOCK0node"))) {
[16:03:20.969]                             sendCondition <<- function(cond) {
[16:03:20.969]                               data <- list(type = "VALUE", value = cond, 
[16:03:20.969]                                 success = TRUE)
[16:03:20.969]                               parallel_sendData(master, data)
[16:03:20.969]                             }
[16:03:20.969]                             return(sendCondition)
[16:03:20.969]                           }
[16:03:20.969]                         }
[16:03:20.969]                         frame <- frame + 1L
[16:03:20.969]                         envir <- sys.frame(frame)
[16:03:20.969]                       }
[16:03:20.969]                     }
[16:03:20.969]                     sendCondition <<- function(cond) NULL
[16:03:20.969]                   }
[16:03:20.969]                 })
[16:03:20.969]                 withCallingHandlers({
[16:03:20.969]                   {
[16:03:20.969]                     do.call(function(...) {
[16:03:20.969]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:20.969]                       if (!identical(...future.globals.maxSize.org, 
[16:03:20.969]                         ...future.globals.maxSize)) {
[16:03:20.969]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:20.969]                         on.exit(options(oopts), add = TRUE)
[16:03:20.969]                       }
[16:03:20.969]                       {
[16:03:20.969]                         lapply(seq_along(...future.elements_ii), 
[16:03:20.969]                           FUN = function(jj) {
[16:03:20.969]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:20.969]                             ...future.FUN(...future.X_jj, ...)
[16:03:20.969]                           })
[16:03:20.969]                       }
[16:03:20.969]                     }, args = future.call.arguments)
[16:03:20.969]                   }
[16:03:20.969]                 }, immediateCondition = function(cond) {
[16:03:20.969]                   sendCondition <- ...future.makeSendCondition()
[16:03:20.969]                   sendCondition(cond)
[16:03:20.969]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.969]                   {
[16:03:20.969]                     inherits <- base::inherits
[16:03:20.969]                     invokeRestart <- base::invokeRestart
[16:03:20.969]                     is.null <- base::is.null
[16:03:20.969]                     muffled <- FALSE
[16:03:20.969]                     if (inherits(cond, "message")) {
[16:03:20.969]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:20.969]                       if (muffled) 
[16:03:20.969]                         invokeRestart("muffleMessage")
[16:03:20.969]                     }
[16:03:20.969]                     else if (inherits(cond, "warning")) {
[16:03:20.969]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:20.969]                       if (muffled) 
[16:03:20.969]                         invokeRestart("muffleWarning")
[16:03:20.969]                     }
[16:03:20.969]                     else if (inherits(cond, "condition")) {
[16:03:20.969]                       if (!is.null(pattern)) {
[16:03:20.969]                         computeRestarts <- base::computeRestarts
[16:03:20.969]                         grepl <- base::grepl
[16:03:20.969]                         restarts <- computeRestarts(cond)
[16:03:20.969]                         for (restart in restarts) {
[16:03:20.969]                           name <- restart$name
[16:03:20.969]                           if (is.null(name)) 
[16:03:20.969]                             next
[16:03:20.969]                           if (!grepl(pattern, name)) 
[16:03:20.969]                             next
[16:03:20.969]                           invokeRestart(restart)
[16:03:20.969]                           muffled <- TRUE
[16:03:20.969]                           break
[16:03:20.969]                         }
[16:03:20.969]                       }
[16:03:20.969]                     }
[16:03:20.969]                     invisible(muffled)
[16:03:20.969]                   }
[16:03:20.969]                   muffleCondition(cond)
[16:03:20.969]                 })
[16:03:20.969]             }))
[16:03:20.969]             future::FutureResult(value = ...future.value$value, 
[16:03:20.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.969]                   ...future.rng), globalenv = if (FALSE) 
[16:03:20.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:20.969]                     ...future.globalenv.names))
[16:03:20.969]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:20.969]         }, condition = base::local({
[16:03:20.969]             c <- base::c
[16:03:20.969]             inherits <- base::inherits
[16:03:20.969]             invokeRestart <- base::invokeRestart
[16:03:20.969]             length <- base::length
[16:03:20.969]             list <- base::list
[16:03:20.969]             seq.int <- base::seq.int
[16:03:20.969]             signalCondition <- base::signalCondition
[16:03:20.969]             sys.calls <- base::sys.calls
[16:03:20.969]             `[[` <- base::`[[`
[16:03:20.969]             `+` <- base::`+`
[16:03:20.969]             `<<-` <- base::`<<-`
[16:03:20.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:20.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:20.969]                   3L)]
[16:03:20.969]             }
[16:03:20.969]             function(cond) {
[16:03:20.969]                 is_error <- inherits(cond, "error")
[16:03:20.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:20.969]                   NULL)
[16:03:20.969]                 if (is_error) {
[16:03:20.969]                   sessionInformation <- function() {
[16:03:20.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:20.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:20.969]                       search = base::search(), system = base::Sys.info())
[16:03:20.969]                   }
[16:03:20.969]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:20.969]                     cond$call), session = sessionInformation(), 
[16:03:20.969]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:20.969]                   signalCondition(cond)
[16:03:20.969]                 }
[16:03:20.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:20.969]                 "immediateCondition"))) {
[16:03:20.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:20.969]                   ...future.conditions[[length(...future.conditions) + 
[16:03:20.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:20.969]                   if (TRUE && !signal) {
[16:03:20.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.969]                     {
[16:03:20.969]                       inherits <- base::inherits
[16:03:20.969]                       invokeRestart <- base::invokeRestart
[16:03:20.969]                       is.null <- base::is.null
[16:03:20.969]                       muffled <- FALSE
[16:03:20.969]                       if (inherits(cond, "message")) {
[16:03:20.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.969]                         if (muffled) 
[16:03:20.969]                           invokeRestart("muffleMessage")
[16:03:20.969]                       }
[16:03:20.969]                       else if (inherits(cond, "warning")) {
[16:03:20.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.969]                         if (muffled) 
[16:03:20.969]                           invokeRestart("muffleWarning")
[16:03:20.969]                       }
[16:03:20.969]                       else if (inherits(cond, "condition")) {
[16:03:20.969]                         if (!is.null(pattern)) {
[16:03:20.969]                           computeRestarts <- base::computeRestarts
[16:03:20.969]                           grepl <- base::grepl
[16:03:20.969]                           restarts <- computeRestarts(cond)
[16:03:20.969]                           for (restart in restarts) {
[16:03:20.969]                             name <- restart$name
[16:03:20.969]                             if (is.null(name)) 
[16:03:20.969]                               next
[16:03:20.969]                             if (!grepl(pattern, name)) 
[16:03:20.969]                               next
[16:03:20.969]                             invokeRestart(restart)
[16:03:20.969]                             muffled <- TRUE
[16:03:20.969]                             break
[16:03:20.969]                           }
[16:03:20.969]                         }
[16:03:20.969]                       }
[16:03:20.969]                       invisible(muffled)
[16:03:20.969]                     }
[16:03:20.969]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.969]                   }
[16:03:20.969]                 }
[16:03:20.969]                 else {
[16:03:20.969]                   if (TRUE) {
[16:03:20.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:20.969]                     {
[16:03:20.969]                       inherits <- base::inherits
[16:03:20.969]                       invokeRestart <- base::invokeRestart
[16:03:20.969]                       is.null <- base::is.null
[16:03:20.969]                       muffled <- FALSE
[16:03:20.969]                       if (inherits(cond, "message")) {
[16:03:20.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:20.969]                         if (muffled) 
[16:03:20.969]                           invokeRestart("muffleMessage")
[16:03:20.969]                       }
[16:03:20.969]                       else if (inherits(cond, "warning")) {
[16:03:20.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:20.969]                         if (muffled) 
[16:03:20.969]                           invokeRestart("muffleWarning")
[16:03:20.969]                       }
[16:03:20.969]                       else if (inherits(cond, "condition")) {
[16:03:20.969]                         if (!is.null(pattern)) {
[16:03:20.969]                           computeRestarts <- base::computeRestarts
[16:03:20.969]                           grepl <- base::grepl
[16:03:20.969]                           restarts <- computeRestarts(cond)
[16:03:20.969]                           for (restart in restarts) {
[16:03:20.969]                             name <- restart$name
[16:03:20.969]                             if (is.null(name)) 
[16:03:20.969]                               next
[16:03:20.969]                             if (!grepl(pattern, name)) 
[16:03:20.969]                               next
[16:03:20.969]                             invokeRestart(restart)
[16:03:20.969]                             muffled <- TRUE
[16:03:20.969]                             break
[16:03:20.969]                           }
[16:03:20.969]                         }
[16:03:20.969]                       }
[16:03:20.969]                       invisible(muffled)
[16:03:20.969]                     }
[16:03:20.969]                     muffleCondition(cond, pattern = "^muffle")
[16:03:20.969]                   }
[16:03:20.969]                 }
[16:03:20.969]             }
[16:03:20.969]         }))
[16:03:20.969]     }, error = function(ex) {
[16:03:20.969]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:20.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:20.969]                 ...future.rng), started = ...future.startTime, 
[16:03:20.969]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:20.969]             version = "1.8"), class = "FutureResult")
[16:03:20.969]     }, finally = {
[16:03:20.969]         if (!identical(...future.workdir, getwd())) 
[16:03:20.969]             setwd(...future.workdir)
[16:03:20.969]         {
[16:03:20.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:20.969]                 ...future.oldOptions$nwarnings <- NULL
[16:03:20.969]             }
[16:03:20.969]             base::options(...future.oldOptions)
[16:03:20.969]             if (.Platform$OS.type == "windows") {
[16:03:20.969]                 old_names <- names(...future.oldEnvVars)
[16:03:20.969]                 envs <- base::Sys.getenv()
[16:03:20.969]                 names <- names(envs)
[16:03:20.969]                 common <- intersect(names, old_names)
[16:03:20.969]                 added <- setdiff(names, old_names)
[16:03:20.969]                 removed <- setdiff(old_names, names)
[16:03:20.969]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:20.969]                   envs[common]]
[16:03:20.969]                 NAMES <- toupper(changed)
[16:03:20.969]                 args <- list()
[16:03:20.969]                 for (kk in seq_along(NAMES)) {
[16:03:20.969]                   name <- changed[[kk]]
[16:03:20.969]                   NAME <- NAMES[[kk]]
[16:03:20.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.969]                     next
[16:03:20.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.969]                 }
[16:03:20.969]                 NAMES <- toupper(added)
[16:03:20.969]                 for (kk in seq_along(NAMES)) {
[16:03:20.969]                   name <- added[[kk]]
[16:03:20.969]                   NAME <- NAMES[[kk]]
[16:03:20.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.969]                     next
[16:03:20.969]                   args[[name]] <- ""
[16:03:20.969]                 }
[16:03:20.969]                 NAMES <- toupper(removed)
[16:03:20.969]                 for (kk in seq_along(NAMES)) {
[16:03:20.969]                   name <- removed[[kk]]
[16:03:20.969]                   NAME <- NAMES[[kk]]
[16:03:20.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:20.969]                     next
[16:03:20.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:20.969]                 }
[16:03:20.969]                 if (length(args) > 0) 
[16:03:20.969]                   base::do.call(base::Sys.setenv, args = args)
[16:03:20.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:20.969]             }
[16:03:20.969]             else {
[16:03:20.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:20.969]             }
[16:03:20.969]             {
[16:03:20.969]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:20.969]                   0L) {
[16:03:20.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:20.969]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:20.969]                   base::options(opts)
[16:03:20.969]                 }
[16:03:20.969]                 {
[16:03:20.969]                   {
[16:03:20.969]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:20.969]                     NULL
[16:03:20.969]                   }
[16:03:20.969]                   options(future.plan = NULL)
[16:03:20.969]                   if (is.na(NA_character_)) 
[16:03:20.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:20.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:20.969]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:20.969]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:20.969]                     envir = parent.frame()) 
[16:03:20.969]                   {
[16:03:20.969]                     if (is.function(workers)) 
[16:03:20.969]                       workers <- workers()
[16:03:20.969]                     workers <- structure(as.integer(workers), 
[16:03:20.969]                       class = class(workers))
[16:03:20.969]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:20.969]                       workers >= 1)
[16:03:20.969]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:20.969]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:20.969]                     }
[16:03:20.969]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:20.969]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:20.969]                       envir = envir)
[16:03:20.969]                     if (!future$lazy) 
[16:03:20.969]                       future <- run(future)
[16:03:20.969]                     invisible(future)
[16:03:20.969]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:20.969]                 }
[16:03:20.969]             }
[16:03:20.969]         }
[16:03:20.969]     })
[16:03:20.969]     if (TRUE) {
[16:03:20.969]         base::sink(type = "output", split = FALSE)
[16:03:20.969]         if (TRUE) {
[16:03:20.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:20.969]         }
[16:03:20.969]         else {
[16:03:20.969]             ...future.result["stdout"] <- base::list(NULL)
[16:03:20.969]         }
[16:03:20.969]         base::close(...future.stdout)
[16:03:20.969]         ...future.stdout <- NULL
[16:03:20.969]     }
[16:03:20.969]     ...future.result$conditions <- ...future.conditions
[16:03:20.969]     ...future.result$finished <- base::Sys.time()
[16:03:20.969]     ...future.result
[16:03:20.969] }
[16:03:20.972] Exporting 11 global objects (96.29 KiB) to cluster node #2 ...
[16:03:20.972] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:21.015] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:21.015] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ...
[16:03:21.016] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ... DONE
[16:03:21.016] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:21.016] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:21.016] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:21.059] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:21.059] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:21.103] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:21.103] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[16:03:21.104] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[16:03:21.104] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:03:21.104] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:03:21.104] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[16:03:21.105] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[16:03:21.105] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:03:21.105] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:03:21.105] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:21.105] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:21.106] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:21.106] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:21.106] Exporting 11 global objects (96.29 KiB) to cluster node #2 ... DONE
[16:03:21.107] MultisessionFuture started
[16:03:21.107] - Launch lazy future ... done
[16:03:21.107] run() for ‘MultisessionFuture’ ... done
[16:03:21.107] Created future:
[16:03:21.107] MultisessionFuture:
[16:03:21.107] Label: ‘future_vapply-2’
[16:03:21.107] Expression:
[16:03:21.107] {
[16:03:21.107]     do.call(function(...) {
[16:03:21.107]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.107]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:21.107]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.107]             on.exit(options(oopts), add = TRUE)
[16:03:21.107]         }
[16:03:21.107]         {
[16:03:21.107]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:21.107]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.107]                 ...future.FUN(...future.X_jj, ...)
[16:03:21.107]             })
[16:03:21.107]         }
[16:03:21.107]     }, args = future.call.arguments)
[16:03:21.107] }
[16:03:21.107] Lazy evaluation: FALSE
[16:03:21.107] Asynchronous evaluation: TRUE
[16:03:21.107] Local evaluation: TRUE
[16:03:21.107] Environment: R_GlobalEnv
[16:03:21.107] Capture standard output: TRUE
[16:03:21.107] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:21.107] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:21.107] Packages: 1 packages (‘future.apply’)
[16:03:21.107] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:21.107] Resolved: FALSE
[16:03:21.107] Value: <not collected>
[16:03:21.107] Conditions captured: <none>
[16:03:21.107] Early signaling: FALSE
[16:03:21.107] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:21.107] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:21.119] Chunk #2 of 2 ... DONE
[16:03:21.119] Launching 2 futures (chunks) ... DONE
[16:03:21.119] Resolving 2 futures (chunks) ...
[16:03:21.119] resolve() on list ...
[16:03:21.119]  recursive: 0
[16:03:21.119]  length: 2
[16:03:21.119] 
[16:03:21.120] receiveMessageFromWorker() for ClusterFuture ...
[16:03:21.120] - Validating connection of MultisessionFuture
[16:03:21.120] - received message: FutureResult
[16:03:21.120] - Received FutureResult
[16:03:21.120] - Erased future from FutureRegistry
[16:03:21.121] result() for ClusterFuture ...
[16:03:21.121] - result already collected: FutureResult
[16:03:21.121] result() for ClusterFuture ... done
[16:03:21.121] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:21.121] Future #1
[16:03:21.121] result() for ClusterFuture ...
[16:03:21.121] - result already collected: FutureResult
[16:03:21.121] result() for ClusterFuture ... done
[16:03:21.121] result() for ClusterFuture ...
[16:03:21.121] - result already collected: FutureResult
[16:03:21.121] result() for ClusterFuture ... done
[16:03:21.122] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:21.122] - nx: 2
[16:03:21.122] - relay: TRUE
[16:03:21.122] - stdout: TRUE
[16:03:21.122] - signal: TRUE
[16:03:21.122] - resignal: FALSE
[16:03:21.122] - force: TRUE
[16:03:21.122] - relayed: [n=2] FALSE, FALSE
[16:03:21.122] - queued futures: [n=2] FALSE, FALSE
[16:03:21.122]  - until=1
[16:03:21.122]  - relaying element #1
[16:03:21.123] result() for ClusterFuture ...
[16:03:21.123] - result already collected: FutureResult
[16:03:21.123] result() for ClusterFuture ... done
[16:03:21.123] result() for ClusterFuture ...
[16:03:21.123] - result already collected: FutureResult
[16:03:21.123] result() for ClusterFuture ... done
[16:03:21.123] result() for ClusterFuture ...
[16:03:21.123] - result already collected: FutureResult
[16:03:21.123] result() for ClusterFuture ... done
[16:03:21.123] result() for ClusterFuture ...
[16:03:21.123] - result already collected: FutureResult
[16:03:21.124] result() for ClusterFuture ... done
[16:03:21.124] - relayed: [n=2] TRUE, FALSE
[16:03:21.124] - queued futures: [n=2] TRUE, FALSE
[16:03:21.124] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:21.124]  length: 1 (resolved future 1)
[16:03:21.152] receiveMessageFromWorker() for ClusterFuture ...
[16:03:21.152] - Validating connection of MultisessionFuture
[16:03:21.152] - received message: FutureResult
[16:03:21.152] - Received FutureResult
[16:03:21.152] - Erased future from FutureRegistry
[16:03:21.152] result() for ClusterFuture ...
[16:03:21.153] - result already collected: FutureResult
[16:03:21.153] result() for ClusterFuture ... done
[16:03:21.153] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:21.153] Future #2
[16:03:21.153] result() for ClusterFuture ...
[16:03:21.153] - result already collected: FutureResult
[16:03:21.153] result() for ClusterFuture ... done
[16:03:21.153] result() for ClusterFuture ...
[16:03:21.153] - result already collected: FutureResult
[16:03:21.153] result() for ClusterFuture ... done
[16:03:21.153] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:21.154] - nx: 2
[16:03:21.154] - relay: TRUE
[16:03:21.154] - stdout: TRUE
[16:03:21.154] - signal: TRUE
[16:03:21.154] - resignal: FALSE
[16:03:21.154] - force: TRUE
[16:03:21.154] - relayed: [n=2] TRUE, FALSE
[16:03:21.154] - queued futures: [n=2] TRUE, FALSE
[16:03:21.154]  - until=2
[16:03:21.154]  - relaying element #2
[16:03:21.154] result() for ClusterFuture ...
[16:03:21.154] - result already collected: FutureResult
[16:03:21.155] result() for ClusterFuture ... done
[16:03:21.155] result() for ClusterFuture ...
[16:03:21.155] - result already collected: FutureResult
[16:03:21.155] result() for ClusterFuture ... done
[16:03:21.155] result() for ClusterFuture ...
[16:03:21.155] - result already collected: FutureResult
[16:03:21.155] result() for ClusterFuture ... done
[16:03:21.155] result() for ClusterFuture ...
[16:03:21.155] - result already collected: FutureResult
[16:03:21.155] result() for ClusterFuture ... done
[16:03:21.155] - relayed: [n=2] TRUE, TRUE
[16:03:21.156] - queued futures: [n=2] TRUE, TRUE
[16:03:21.156] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:21.156]  length: 0 (resolved future 2)
[16:03:21.156] Relaying remaining futures
[16:03:21.156] signalConditionsASAP(NULL, pos=0) ...
[16:03:21.156] - nx: 2
[16:03:21.156] - relay: TRUE
[16:03:21.156] - stdout: TRUE
[16:03:21.156] - signal: TRUE
[16:03:21.156] - resignal: FALSE
[16:03:21.156] - force: TRUE
[16:03:21.157] - relayed: [n=2] TRUE, TRUE
[16:03:21.157] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:21.157] - relayed: [n=2] TRUE, TRUE
[16:03:21.157] - queued futures: [n=2] TRUE, TRUE
[16:03:21.157] signalConditionsASAP(NULL, pos=0) ... done
[16:03:21.157] resolve() on list ... DONE
[16:03:21.157] result() for ClusterFuture ...
[16:03:21.157] - result already collected: FutureResult
[16:03:21.157] result() for ClusterFuture ... done
[16:03:21.157] result() for ClusterFuture ...
[16:03:21.157] - result already collected: FutureResult
[16:03:21.158] result() for ClusterFuture ... done
[16:03:21.158] result() for ClusterFuture ...
[16:03:21.158] - result already collected: FutureResult
[16:03:21.158] result() for ClusterFuture ... done
[16:03:21.158] result() for ClusterFuture ...
[16:03:21.158] - result already collected: FutureResult
[16:03:21.158] result() for ClusterFuture ... done
[16:03:21.158]  - Number of value chunks collected: 2
[16:03:21.158] Resolving 2 futures (chunks) ... DONE
[16:03:21.158] Reducing values from 2 chunks ...
[16:03:21.158]  - Number of values collected after concatenation: 4
[16:03:21.159]  - Number of values expected: 4
[16:03:21.159] Reducing values from 2 chunks ... DONE
[16:03:21.159] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[16:03:21.160] future_lapply() ...
[16:03:21.166] Number of chunks: 2
[16:03:21.166] getGlobalsAndPackagesXApply() ...
[16:03:21.166]  - future.globals: TRUE
[16:03:21.166] getGlobalsAndPackages() ...
[16:03:21.166] Searching for globals...
[16:03:21.169] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:21.169] Searching for globals ... DONE
[16:03:21.169] Resolving globals: FALSE
[16:03:21.170] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[16:03:21.170] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:21.171] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:21.171] - packages: [1] ‘future.apply’
[16:03:21.171] getGlobalsAndPackages() ... DONE
[16:03:21.171]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:21.171]  - needed namespaces: [n=1] ‘future.apply’
[16:03:21.171] Finding globals ... DONE
[16:03:21.171]  - use_args: TRUE
[16:03:21.171]  - Getting '...' globals ...
[16:03:21.172] resolve() on list ...
[16:03:21.172]  recursive: 0
[16:03:21.172]  length: 1
[16:03:21.172]  elements: ‘...’
[16:03:21.172]  length: 0 (resolved future 1)
[16:03:21.172] resolve() on list ... DONE
[16:03:21.172]    - '...' content: [n=0] 
[16:03:21.172] List of 1
[16:03:21.172]  $ ...: list()
[16:03:21.172]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:21.172]  - attr(*, "where")=List of 1
[16:03:21.172]   ..$ ...:<environment: 0x564e454797f0> 
[16:03:21.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:21.172]  - attr(*, "resolved")= logi TRUE
[16:03:21.172]  - attr(*, "total_size")= num NA
[16:03:21.175]  - Getting '...' globals ... DONE
[16:03:21.175] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:21.175] List of 8
[16:03:21.175]  $ ...future.FUN:function (x, ...)  
[16:03:21.175]  $ x_FUN        :function (x)  
[16:03:21.175]  $ times        : int 1
[16:03:21.175]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:21.175]  $ stop_if_not  :function (...)  
[16:03:21.175]  $ dim          : NULL
[16:03:21.175]  $ valid_types  : chr "logical"
[16:03:21.175]  $ ...          : list()
[16:03:21.175]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:21.175]  - attr(*, "where")=List of 8
[16:03:21.175]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:21.175]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:21.175]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:21.175]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:21.175]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:21.175]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:21.175]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:21.175]   ..$ ...          :<environment: 0x564e454797f0> 
[16:03:21.175]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:21.175]  - attr(*, "resolved")= logi FALSE
[16:03:21.175]  - attr(*, "total_size")= num 94200
[16:03:21.180] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:21.180] getGlobalsAndPackagesXApply() ... DONE
[16:03:21.181] Number of futures (= number of chunks): 2
[16:03:21.181] Launching 2 futures (chunks) ...
[16:03:21.181] Chunk #1 of 2 ...
[16:03:21.181]  - Finding globals in 'X' for chunk #1 ...
[16:03:21.181] getGlobalsAndPackages() ...
[16:03:21.181] Searching for globals...
[16:03:21.181] 
[16:03:21.181] Searching for globals ... DONE
[16:03:21.181] - globals: [0] <none>
[16:03:21.182] getGlobalsAndPackages() ... DONE
[16:03:21.182]    + additional globals found: [n=0] 
[16:03:21.182]    + additional namespaces needed: [n=0] 
[16:03:21.182]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:21.182]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:21.182]  - seeds: <none>
[16:03:21.182]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.185] getGlobalsAndPackages() ...
[16:03:21.185] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.185] Resolving globals: FALSE
[16:03:21.185] Tweak future expression to call with '...' arguments ...
[16:03:21.185] {
[16:03:21.185]     do.call(function(...) {
[16:03:21.185]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.185]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:21.185]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.185]             on.exit(options(oopts), add = TRUE)
[16:03:21.185]         }
[16:03:21.185]         {
[16:03:21.185]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:21.185]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.185]                 ...future.FUN(...future.X_jj, ...)
[16:03:21.185]             })
[16:03:21.185]         }
[16:03:21.185]     }, args = future.call.arguments)
[16:03:21.185] }
[16:03:21.186] Tweak future expression to call with '...' arguments ... DONE
[16:03:21.186] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.186] - packages: [1] ‘future.apply’
[16:03:21.187] getGlobalsAndPackages() ... DONE
[16:03:21.187] run() for ‘Future’ ...
[16:03:21.187] - state: ‘created’
[16:03:21.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:21.201] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:21.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:21.201]   - Field: ‘node’
[16:03:21.201]   - Field: ‘label’
[16:03:21.201]   - Field: ‘local’
[16:03:21.201]   - Field: ‘owner’
[16:03:21.201]   - Field: ‘envir’
[16:03:21.202]   - Field: ‘workers’
[16:03:21.202]   - Field: ‘packages’
[16:03:21.202]   - Field: ‘gc’
[16:03:21.202]   - Field: ‘conditions’
[16:03:21.202]   - Field: ‘persistent’
[16:03:21.202]   - Field: ‘expr’
[16:03:21.202]   - Field: ‘uuid’
[16:03:21.202]   - Field: ‘seed’
[16:03:21.202]   - Field: ‘version’
[16:03:21.202]   - Field: ‘result’
[16:03:21.202]   - Field: ‘asynchronous’
[16:03:21.203]   - Field: ‘calls’
[16:03:21.203]   - Field: ‘globals’
[16:03:21.203]   - Field: ‘stdout’
[16:03:21.203]   - Field: ‘earlySignal’
[16:03:21.203]   - Field: ‘lazy’
[16:03:21.203]   - Field: ‘state’
[16:03:21.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:21.203] - Launch lazy future ...
[16:03:21.203] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:21.204] Packages needed by future strategies (n = 0): <none>
[16:03:21.204] {
[16:03:21.204]     {
[16:03:21.204]         {
[16:03:21.204]             ...future.startTime <- base::Sys.time()
[16:03:21.204]             {
[16:03:21.204]                 {
[16:03:21.204]                   {
[16:03:21.204]                     {
[16:03:21.204]                       {
[16:03:21.204]                         base::local({
[16:03:21.204]                           has_future <- base::requireNamespace("future", 
[16:03:21.204]                             quietly = TRUE)
[16:03:21.204]                           if (has_future) {
[16:03:21.204]                             ns <- base::getNamespace("future")
[16:03:21.204]                             version <- ns[[".package"]][["version"]]
[16:03:21.204]                             if (is.null(version)) 
[16:03:21.204]                               version <- utils::packageVersion("future")
[16:03:21.204]                           }
[16:03:21.204]                           else {
[16:03:21.204]                             version <- NULL
[16:03:21.204]                           }
[16:03:21.204]                           if (!has_future || version < "1.8.0") {
[16:03:21.204]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:21.204]                               "", base::R.version$version.string), 
[16:03:21.204]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:21.204]                                 base::R.version$platform, 8 * 
[16:03:21.204]                                   base::.Machine$sizeof.pointer), 
[16:03:21.204]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:21.204]                                 "release", "version")], collapse = " "), 
[16:03:21.204]                               hostname = base::Sys.info()[["nodename"]])
[16:03:21.204]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:21.204]                               info)
[16:03:21.204]                             info <- base::paste(info, collapse = "; ")
[16:03:21.204]                             if (!has_future) {
[16:03:21.204]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:21.204]                                 info)
[16:03:21.204]                             }
[16:03:21.204]                             else {
[16:03:21.204]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:21.204]                                 info, version)
[16:03:21.204]                             }
[16:03:21.204]                             base::stop(msg)
[16:03:21.204]                           }
[16:03:21.204]                         })
[16:03:21.204]                       }
[16:03:21.204]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:21.204]                       base::options(mc.cores = 1L)
[16:03:21.204]                     }
[16:03:21.204]                     base::local({
[16:03:21.204]                       for (pkg in "future.apply") {
[16:03:21.204]                         base::loadNamespace(pkg)
[16:03:21.204]                         base::library(pkg, character.only = TRUE)
[16:03:21.204]                       }
[16:03:21.204]                     })
[16:03:21.204]                   }
[16:03:21.204]                   options(future.plan = NULL)
[16:03:21.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:21.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:21.204]                 }
[16:03:21.204]                 ...future.workdir <- getwd()
[16:03:21.204]             }
[16:03:21.204]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:21.204]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:21.204]         }
[16:03:21.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:21.204]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:21.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:21.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:21.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:21.204]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:21.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:21.204]             base::names(...future.oldOptions))
[16:03:21.204]     }
[16:03:21.204]     if (FALSE) {
[16:03:21.204]     }
[16:03:21.204]     else {
[16:03:21.204]         if (TRUE) {
[16:03:21.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:21.204]                 open = "w")
[16:03:21.204]         }
[16:03:21.204]         else {
[16:03:21.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:21.204]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:21.204]         }
[16:03:21.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:21.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:21.204]             base::sink(type = "output", split = FALSE)
[16:03:21.204]             base::close(...future.stdout)
[16:03:21.204]         }, add = TRUE)
[16:03:21.204]     }
[16:03:21.204]     ...future.frame <- base::sys.nframe()
[16:03:21.204]     ...future.conditions <- base::list()
[16:03:21.204]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:21.204]     if (FALSE) {
[16:03:21.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:21.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:21.204]     }
[16:03:21.204]     ...future.result <- base::tryCatch({
[16:03:21.204]         base::withCallingHandlers({
[16:03:21.204]             ...future.value <- base::withVisible(base::local({
[16:03:21.204]                 ...future.makeSendCondition <- base::local({
[16:03:21.204]                   sendCondition <- NULL
[16:03:21.204]                   function(frame = 1L) {
[16:03:21.204]                     if (is.function(sendCondition)) 
[16:03:21.204]                       return(sendCondition)
[16:03:21.204]                     ns <- getNamespace("parallel")
[16:03:21.204]                     if (exists("sendData", mode = "function", 
[16:03:21.204]                       envir = ns)) {
[16:03:21.204]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:21.204]                         envir = ns)
[16:03:21.204]                       envir <- sys.frame(frame)
[16:03:21.204]                       master <- NULL
[16:03:21.204]                       while (!identical(envir, .GlobalEnv) && 
[16:03:21.204]                         !identical(envir, emptyenv())) {
[16:03:21.204]                         if (exists("master", mode = "list", envir = envir, 
[16:03:21.204]                           inherits = FALSE)) {
[16:03:21.204]                           master <- get("master", mode = "list", 
[16:03:21.204]                             envir = envir, inherits = FALSE)
[16:03:21.204]                           if (inherits(master, c("SOCKnode", 
[16:03:21.204]                             "SOCK0node"))) {
[16:03:21.204]                             sendCondition <<- function(cond) {
[16:03:21.204]                               data <- list(type = "VALUE", value = cond, 
[16:03:21.204]                                 success = TRUE)
[16:03:21.204]                               parallel_sendData(master, data)
[16:03:21.204]                             }
[16:03:21.204]                             return(sendCondition)
[16:03:21.204]                           }
[16:03:21.204]                         }
[16:03:21.204]                         frame <- frame + 1L
[16:03:21.204]                         envir <- sys.frame(frame)
[16:03:21.204]                       }
[16:03:21.204]                     }
[16:03:21.204]                     sendCondition <<- function(cond) NULL
[16:03:21.204]                   }
[16:03:21.204]                 })
[16:03:21.204]                 withCallingHandlers({
[16:03:21.204]                   {
[16:03:21.204]                     do.call(function(...) {
[16:03:21.204]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.204]                       if (!identical(...future.globals.maxSize.org, 
[16:03:21.204]                         ...future.globals.maxSize)) {
[16:03:21.204]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.204]                         on.exit(options(oopts), add = TRUE)
[16:03:21.204]                       }
[16:03:21.204]                       {
[16:03:21.204]                         lapply(seq_along(...future.elements_ii), 
[16:03:21.204]                           FUN = function(jj) {
[16:03:21.204]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.204]                             ...future.FUN(...future.X_jj, ...)
[16:03:21.204]                           })
[16:03:21.204]                       }
[16:03:21.204]                     }, args = future.call.arguments)
[16:03:21.204]                   }
[16:03:21.204]                 }, immediateCondition = function(cond) {
[16:03:21.204]                   sendCondition <- ...future.makeSendCondition()
[16:03:21.204]                   sendCondition(cond)
[16:03:21.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.204]                   {
[16:03:21.204]                     inherits <- base::inherits
[16:03:21.204]                     invokeRestart <- base::invokeRestart
[16:03:21.204]                     is.null <- base::is.null
[16:03:21.204]                     muffled <- FALSE
[16:03:21.204]                     if (inherits(cond, "message")) {
[16:03:21.204]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:21.204]                       if (muffled) 
[16:03:21.204]                         invokeRestart("muffleMessage")
[16:03:21.204]                     }
[16:03:21.204]                     else if (inherits(cond, "warning")) {
[16:03:21.204]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:21.204]                       if (muffled) 
[16:03:21.204]                         invokeRestart("muffleWarning")
[16:03:21.204]                     }
[16:03:21.204]                     else if (inherits(cond, "condition")) {
[16:03:21.204]                       if (!is.null(pattern)) {
[16:03:21.204]                         computeRestarts <- base::computeRestarts
[16:03:21.204]                         grepl <- base::grepl
[16:03:21.204]                         restarts <- computeRestarts(cond)
[16:03:21.204]                         for (restart in restarts) {
[16:03:21.204]                           name <- restart$name
[16:03:21.204]                           if (is.null(name)) 
[16:03:21.204]                             next
[16:03:21.204]                           if (!grepl(pattern, name)) 
[16:03:21.204]                             next
[16:03:21.204]                           invokeRestart(restart)
[16:03:21.204]                           muffled <- TRUE
[16:03:21.204]                           break
[16:03:21.204]                         }
[16:03:21.204]                       }
[16:03:21.204]                     }
[16:03:21.204]                     invisible(muffled)
[16:03:21.204]                   }
[16:03:21.204]                   muffleCondition(cond)
[16:03:21.204]                 })
[16:03:21.204]             }))
[16:03:21.204]             future::FutureResult(value = ...future.value$value, 
[16:03:21.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:21.204]                   ...future.rng), globalenv = if (FALSE) 
[16:03:21.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:21.204]                     ...future.globalenv.names))
[16:03:21.204]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:21.204]         }, condition = base::local({
[16:03:21.204]             c <- base::c
[16:03:21.204]             inherits <- base::inherits
[16:03:21.204]             invokeRestart <- base::invokeRestart
[16:03:21.204]             length <- base::length
[16:03:21.204]             list <- base::list
[16:03:21.204]             seq.int <- base::seq.int
[16:03:21.204]             signalCondition <- base::signalCondition
[16:03:21.204]             sys.calls <- base::sys.calls
[16:03:21.204]             `[[` <- base::`[[`
[16:03:21.204]             `+` <- base::`+`
[16:03:21.204]             `<<-` <- base::`<<-`
[16:03:21.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:21.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:21.204]                   3L)]
[16:03:21.204]             }
[16:03:21.204]             function(cond) {
[16:03:21.204]                 is_error <- inherits(cond, "error")
[16:03:21.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:21.204]                   NULL)
[16:03:21.204]                 if (is_error) {
[16:03:21.204]                   sessionInformation <- function() {
[16:03:21.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:21.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:21.204]                       search = base::search(), system = base::Sys.info())
[16:03:21.204]                   }
[16:03:21.204]                   ...future.conditions[[length(...future.conditions) + 
[16:03:21.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:21.204]                     cond$call), session = sessionInformation(), 
[16:03:21.204]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:21.204]                   signalCondition(cond)
[16:03:21.204]                 }
[16:03:21.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:21.204]                 "immediateCondition"))) {
[16:03:21.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:21.204]                   ...future.conditions[[length(...future.conditions) + 
[16:03:21.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:21.204]                   if (TRUE && !signal) {
[16:03:21.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.204]                     {
[16:03:21.204]                       inherits <- base::inherits
[16:03:21.204]                       invokeRestart <- base::invokeRestart
[16:03:21.204]                       is.null <- base::is.null
[16:03:21.204]                       muffled <- FALSE
[16:03:21.204]                       if (inherits(cond, "message")) {
[16:03:21.204]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:21.204]                         if (muffled) 
[16:03:21.204]                           invokeRestart("muffleMessage")
[16:03:21.204]                       }
[16:03:21.204]                       else if (inherits(cond, "warning")) {
[16:03:21.204]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:21.204]                         if (muffled) 
[16:03:21.204]                           invokeRestart("muffleWarning")
[16:03:21.204]                       }
[16:03:21.204]                       else if (inherits(cond, "condition")) {
[16:03:21.204]                         if (!is.null(pattern)) {
[16:03:21.204]                           computeRestarts <- base::computeRestarts
[16:03:21.204]                           grepl <- base::grepl
[16:03:21.204]                           restarts <- computeRestarts(cond)
[16:03:21.204]                           for (restart in restarts) {
[16:03:21.204]                             name <- restart$name
[16:03:21.204]                             if (is.null(name)) 
[16:03:21.204]                               next
[16:03:21.204]                             if (!grepl(pattern, name)) 
[16:03:21.204]                               next
[16:03:21.204]                             invokeRestart(restart)
[16:03:21.204]                             muffled <- TRUE
[16:03:21.204]                             break
[16:03:21.204]                           }
[16:03:21.204]                         }
[16:03:21.204]                       }
[16:03:21.204]                       invisible(muffled)
[16:03:21.204]                     }
[16:03:21.204]                     muffleCondition(cond, pattern = "^muffle")
[16:03:21.204]                   }
[16:03:21.204]                 }
[16:03:21.204]                 else {
[16:03:21.204]                   if (TRUE) {
[16:03:21.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.204]                     {
[16:03:21.204]                       inherits <- base::inherits
[16:03:21.204]                       invokeRestart <- base::invokeRestart
[16:03:21.204]                       is.null <- base::is.null
[16:03:21.204]                       muffled <- FALSE
[16:03:21.204]                       if (inherits(cond, "message")) {
[16:03:21.204]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:21.204]                         if (muffled) 
[16:03:21.204]                           invokeRestart("muffleMessage")
[16:03:21.204]                       }
[16:03:21.204]                       else if (inherits(cond, "warning")) {
[16:03:21.204]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:21.204]                         if (muffled) 
[16:03:21.204]                           invokeRestart("muffleWarning")
[16:03:21.204]                       }
[16:03:21.204]                       else if (inherits(cond, "condition")) {
[16:03:21.204]                         if (!is.null(pattern)) {
[16:03:21.204]                           computeRestarts <- base::computeRestarts
[16:03:21.204]                           grepl <- base::grepl
[16:03:21.204]                           restarts <- computeRestarts(cond)
[16:03:21.204]                           for (restart in restarts) {
[16:03:21.204]                             name <- restart$name
[16:03:21.204]                             if (is.null(name)) 
[16:03:21.204]                               next
[16:03:21.204]                             if (!grepl(pattern, name)) 
[16:03:21.204]                               next
[16:03:21.204]                             invokeRestart(restart)
[16:03:21.204]                             muffled <- TRUE
[16:03:21.204]                             break
[16:03:21.204]                           }
[16:03:21.204]                         }
[16:03:21.204]                       }
[16:03:21.204]                       invisible(muffled)
[16:03:21.204]                     }
[16:03:21.204]                     muffleCondition(cond, pattern = "^muffle")
[16:03:21.204]                   }
[16:03:21.204]                 }
[16:03:21.204]             }
[16:03:21.204]         }))
[16:03:21.204]     }, error = function(ex) {
[16:03:21.204]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:21.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:21.204]                 ...future.rng), started = ...future.startTime, 
[16:03:21.204]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:21.204]             version = "1.8"), class = "FutureResult")
[16:03:21.204]     }, finally = {
[16:03:21.204]         if (!identical(...future.workdir, getwd())) 
[16:03:21.204]             setwd(...future.workdir)
[16:03:21.204]         {
[16:03:21.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:21.204]                 ...future.oldOptions$nwarnings <- NULL
[16:03:21.204]             }
[16:03:21.204]             base::options(...future.oldOptions)
[16:03:21.204]             if (.Platform$OS.type == "windows") {
[16:03:21.204]                 old_names <- names(...future.oldEnvVars)
[16:03:21.204]                 envs <- base::Sys.getenv()
[16:03:21.204]                 names <- names(envs)
[16:03:21.204]                 common <- intersect(names, old_names)
[16:03:21.204]                 added <- setdiff(names, old_names)
[16:03:21.204]                 removed <- setdiff(old_names, names)
[16:03:21.204]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:21.204]                   envs[common]]
[16:03:21.204]                 NAMES <- toupper(changed)
[16:03:21.204]                 args <- list()
[16:03:21.204]                 for (kk in seq_along(NAMES)) {
[16:03:21.204]                   name <- changed[[kk]]
[16:03:21.204]                   NAME <- NAMES[[kk]]
[16:03:21.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.204]                     next
[16:03:21.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:21.204]                 }
[16:03:21.204]                 NAMES <- toupper(added)
[16:03:21.204]                 for (kk in seq_along(NAMES)) {
[16:03:21.204]                   name <- added[[kk]]
[16:03:21.204]                   NAME <- NAMES[[kk]]
[16:03:21.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.204]                     next
[16:03:21.204]                   args[[name]] <- ""
[16:03:21.204]                 }
[16:03:21.204]                 NAMES <- toupper(removed)
[16:03:21.204]                 for (kk in seq_along(NAMES)) {
[16:03:21.204]                   name <- removed[[kk]]
[16:03:21.204]                   NAME <- NAMES[[kk]]
[16:03:21.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.204]                     next
[16:03:21.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:21.204]                 }
[16:03:21.204]                 if (length(args) > 0) 
[16:03:21.204]                   base::do.call(base::Sys.setenv, args = args)
[16:03:21.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:21.204]             }
[16:03:21.204]             else {
[16:03:21.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:21.204]             }
[16:03:21.204]             {
[16:03:21.204]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:21.204]                   0L) {
[16:03:21.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:21.204]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:21.204]                   base::options(opts)
[16:03:21.204]                 }
[16:03:21.204]                 {
[16:03:21.204]                   {
[16:03:21.204]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:21.204]                     NULL
[16:03:21.204]                   }
[16:03:21.204]                   options(future.plan = NULL)
[16:03:21.204]                   if (is.na(NA_character_)) 
[16:03:21.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:21.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:21.204]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:21.204]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:21.204]                     envir = parent.frame()) 
[16:03:21.204]                   {
[16:03:21.204]                     if (is.function(workers)) 
[16:03:21.204]                       workers <- workers()
[16:03:21.204]                     workers <- structure(as.integer(workers), 
[16:03:21.204]                       class = class(workers))
[16:03:21.204]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:21.204]                       workers >= 1)
[16:03:21.204]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:21.204]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:21.204]                     }
[16:03:21.204]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:21.204]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:21.204]                       envir = envir)
[16:03:21.204]                     if (!future$lazy) 
[16:03:21.204]                       future <- run(future)
[16:03:21.204]                     invisible(future)
[16:03:21.204]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:21.204]                 }
[16:03:21.204]             }
[16:03:21.204]         }
[16:03:21.204]     })
[16:03:21.204]     if (TRUE) {
[16:03:21.204]         base::sink(type = "output", split = FALSE)
[16:03:21.204]         if (TRUE) {
[16:03:21.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:21.204]         }
[16:03:21.204]         else {
[16:03:21.204]             ...future.result["stdout"] <- base::list(NULL)
[16:03:21.204]         }
[16:03:21.204]         base::close(...future.stdout)
[16:03:21.204]         ...future.stdout <- NULL
[16:03:21.204]     }
[16:03:21.204]     ...future.result$conditions <- ...future.conditions
[16:03:21.204]     ...future.result$finished <- base::Sys.time()
[16:03:21.204]     ...future.result
[16:03:21.204] }
[16:03:21.207] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[16:03:21.207] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:21.251] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:21.251] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:03:21.252] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:03:21.252] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:21.252] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:21.252] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:21.295] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:21.295] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:21.339] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:21.339] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:03:21.340] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:03:21.340] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[16:03:21.341] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[16:03:21.341] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:21.341] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:21.342] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[16:03:21.342] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[16:03:21.342] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:21.343] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:21.343] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:21.344] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:21.344] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[16:03:21.345] MultisessionFuture started
[16:03:21.345] - Launch lazy future ... done
[16:03:21.345] run() for ‘MultisessionFuture’ ... done
[16:03:21.345] Created future:
[16:03:21.346] MultisessionFuture:
[16:03:21.346] Label: ‘future_vapply-1’
[16:03:21.346] Expression:
[16:03:21.346] {
[16:03:21.346]     do.call(function(...) {
[16:03:21.346]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.346]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:21.346]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.346]             on.exit(options(oopts), add = TRUE)
[16:03:21.346]         }
[16:03:21.346]         {
[16:03:21.346]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:21.346]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.346]                 ...future.FUN(...future.X_jj, ...)
[16:03:21.346]             })
[16:03:21.346]         }
[16:03:21.346]     }, args = future.call.arguments)
[16:03:21.346] }
[16:03:21.346] Lazy evaluation: FALSE
[16:03:21.346] Asynchronous evaluation: TRUE
[16:03:21.346] Local evaluation: TRUE
[16:03:21.346] Environment: R_GlobalEnv
[16:03:21.346] Capture standard output: TRUE
[16:03:21.346] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:21.346] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:21.346] Packages: 1 packages (‘future.apply’)
[16:03:21.346] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:21.346] Resolved: FALSE
[16:03:21.346] Value: <not collected>
[16:03:21.346] Conditions captured: <none>
[16:03:21.346] Early signaling: FALSE
[16:03:21.346] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:21.346] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:21.358] Chunk #1 of 2 ... DONE
[16:03:21.358] Chunk #2 of 2 ...
[16:03:21.358]  - Finding globals in 'X' for chunk #2 ...
[16:03:21.359] getGlobalsAndPackages() ...
[16:03:21.359] Searching for globals...
[16:03:21.359] 
[16:03:21.359] Searching for globals ... DONE
[16:03:21.359] - globals: [0] <none>
[16:03:21.360] getGlobalsAndPackages() ... DONE
[16:03:21.360]    + additional globals found: [n=0] 
[16:03:21.360]    + additional namespaces needed: [n=0] 
[16:03:21.360]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:21.360]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:21.360]  - seeds: <none>
[16:03:21.360]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.361] getGlobalsAndPackages() ...
[16:03:21.361] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.361] Resolving globals: FALSE
[16:03:21.361] Tweak future expression to call with '...' arguments ...
[16:03:21.361] {
[16:03:21.361]     do.call(function(...) {
[16:03:21.361]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.361]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:21.361]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.361]             on.exit(options(oopts), add = TRUE)
[16:03:21.361]         }
[16:03:21.361]         {
[16:03:21.361]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:21.361]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.361]                 ...future.FUN(...future.X_jj, ...)
[16:03:21.361]             })
[16:03:21.361]         }
[16:03:21.361]     }, args = future.call.arguments)
[16:03:21.361] }
[16:03:21.362] Tweak future expression to call with '...' arguments ... DONE
[16:03:21.363] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.363] - packages: [1] ‘future.apply’
[16:03:21.363] getGlobalsAndPackages() ... DONE
[16:03:21.363] run() for ‘Future’ ...
[16:03:21.364] - state: ‘created’
[16:03:21.364] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:21.380] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:21.380] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:21.380]   - Field: ‘node’
[16:03:21.381]   - Field: ‘label’
[16:03:21.381]   - Field: ‘local’
[16:03:21.381]   - Field: ‘owner’
[16:03:21.381]   - Field: ‘envir’
[16:03:21.381]   - Field: ‘workers’
[16:03:21.381]   - Field: ‘packages’
[16:03:21.381]   - Field: ‘gc’
[16:03:21.381]   - Field: ‘conditions’
[16:03:21.381]   - Field: ‘persistent’
[16:03:21.381]   - Field: ‘expr’
[16:03:21.382]   - Field: ‘uuid’
[16:03:21.382]   - Field: ‘seed’
[16:03:21.382]   - Field: ‘version’
[16:03:21.382]   - Field: ‘result’
[16:03:21.382]   - Field: ‘asynchronous’
[16:03:21.382]   - Field: ‘calls’
[16:03:21.382]   - Field: ‘globals’
[16:03:21.382]   - Field: ‘stdout’
[16:03:21.382]   - Field: ‘earlySignal’
[16:03:21.382]   - Field: ‘lazy’
[16:03:21.382]   - Field: ‘state’
[16:03:21.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:21.383] - Launch lazy future ...
[16:03:21.383] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:21.383] Packages needed by future strategies (n = 0): <none>
[16:03:21.384] {
[16:03:21.384]     {
[16:03:21.384]         {
[16:03:21.384]             ...future.startTime <- base::Sys.time()
[16:03:21.384]             {
[16:03:21.384]                 {
[16:03:21.384]                   {
[16:03:21.384]                     {
[16:03:21.384]                       {
[16:03:21.384]                         base::local({
[16:03:21.384]                           has_future <- base::requireNamespace("future", 
[16:03:21.384]                             quietly = TRUE)
[16:03:21.384]                           if (has_future) {
[16:03:21.384]                             ns <- base::getNamespace("future")
[16:03:21.384]                             version <- ns[[".package"]][["version"]]
[16:03:21.384]                             if (is.null(version)) 
[16:03:21.384]                               version <- utils::packageVersion("future")
[16:03:21.384]                           }
[16:03:21.384]                           else {
[16:03:21.384]                             version <- NULL
[16:03:21.384]                           }
[16:03:21.384]                           if (!has_future || version < "1.8.0") {
[16:03:21.384]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:21.384]                               "", base::R.version$version.string), 
[16:03:21.384]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:21.384]                                 base::R.version$platform, 8 * 
[16:03:21.384]                                   base::.Machine$sizeof.pointer), 
[16:03:21.384]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:21.384]                                 "release", "version")], collapse = " "), 
[16:03:21.384]                               hostname = base::Sys.info()[["nodename"]])
[16:03:21.384]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:21.384]                               info)
[16:03:21.384]                             info <- base::paste(info, collapse = "; ")
[16:03:21.384]                             if (!has_future) {
[16:03:21.384]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:21.384]                                 info)
[16:03:21.384]                             }
[16:03:21.384]                             else {
[16:03:21.384]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:21.384]                                 info, version)
[16:03:21.384]                             }
[16:03:21.384]                             base::stop(msg)
[16:03:21.384]                           }
[16:03:21.384]                         })
[16:03:21.384]                       }
[16:03:21.384]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:21.384]                       base::options(mc.cores = 1L)
[16:03:21.384]                     }
[16:03:21.384]                     base::local({
[16:03:21.384]                       for (pkg in "future.apply") {
[16:03:21.384]                         base::loadNamespace(pkg)
[16:03:21.384]                         base::library(pkg, character.only = TRUE)
[16:03:21.384]                       }
[16:03:21.384]                     })
[16:03:21.384]                   }
[16:03:21.384]                   options(future.plan = NULL)
[16:03:21.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:21.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:21.384]                 }
[16:03:21.384]                 ...future.workdir <- getwd()
[16:03:21.384]             }
[16:03:21.384]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:21.384]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:21.384]         }
[16:03:21.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:21.384]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:21.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:21.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:21.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:21.384]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:21.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:21.384]             base::names(...future.oldOptions))
[16:03:21.384]     }
[16:03:21.384]     if (FALSE) {
[16:03:21.384]     }
[16:03:21.384]     else {
[16:03:21.384]         if (TRUE) {
[16:03:21.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:21.384]                 open = "w")
[16:03:21.384]         }
[16:03:21.384]         else {
[16:03:21.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:21.384]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:21.384]         }
[16:03:21.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:21.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:21.384]             base::sink(type = "output", split = FALSE)
[16:03:21.384]             base::close(...future.stdout)
[16:03:21.384]         }, add = TRUE)
[16:03:21.384]     }
[16:03:21.384]     ...future.frame <- base::sys.nframe()
[16:03:21.384]     ...future.conditions <- base::list()
[16:03:21.384]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:21.384]     if (FALSE) {
[16:03:21.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:21.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:21.384]     }
[16:03:21.384]     ...future.result <- base::tryCatch({
[16:03:21.384]         base::withCallingHandlers({
[16:03:21.384]             ...future.value <- base::withVisible(base::local({
[16:03:21.384]                 ...future.makeSendCondition <- base::local({
[16:03:21.384]                   sendCondition <- NULL
[16:03:21.384]                   function(frame = 1L) {
[16:03:21.384]                     if (is.function(sendCondition)) 
[16:03:21.384]                       return(sendCondition)
[16:03:21.384]                     ns <- getNamespace("parallel")
[16:03:21.384]                     if (exists("sendData", mode = "function", 
[16:03:21.384]                       envir = ns)) {
[16:03:21.384]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:21.384]                         envir = ns)
[16:03:21.384]                       envir <- sys.frame(frame)
[16:03:21.384]                       master <- NULL
[16:03:21.384]                       while (!identical(envir, .GlobalEnv) && 
[16:03:21.384]                         !identical(envir, emptyenv())) {
[16:03:21.384]                         if (exists("master", mode = "list", envir = envir, 
[16:03:21.384]                           inherits = FALSE)) {
[16:03:21.384]                           master <- get("master", mode = "list", 
[16:03:21.384]                             envir = envir, inherits = FALSE)
[16:03:21.384]                           if (inherits(master, c("SOCKnode", 
[16:03:21.384]                             "SOCK0node"))) {
[16:03:21.384]                             sendCondition <<- function(cond) {
[16:03:21.384]                               data <- list(type = "VALUE", value = cond, 
[16:03:21.384]                                 success = TRUE)
[16:03:21.384]                               parallel_sendData(master, data)
[16:03:21.384]                             }
[16:03:21.384]                             return(sendCondition)
[16:03:21.384]                           }
[16:03:21.384]                         }
[16:03:21.384]                         frame <- frame + 1L
[16:03:21.384]                         envir <- sys.frame(frame)
[16:03:21.384]                       }
[16:03:21.384]                     }
[16:03:21.384]                     sendCondition <<- function(cond) NULL
[16:03:21.384]                   }
[16:03:21.384]                 })
[16:03:21.384]                 withCallingHandlers({
[16:03:21.384]                   {
[16:03:21.384]                     do.call(function(...) {
[16:03:21.384]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.384]                       if (!identical(...future.globals.maxSize.org, 
[16:03:21.384]                         ...future.globals.maxSize)) {
[16:03:21.384]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.384]                         on.exit(options(oopts), add = TRUE)
[16:03:21.384]                       }
[16:03:21.384]                       {
[16:03:21.384]                         lapply(seq_along(...future.elements_ii), 
[16:03:21.384]                           FUN = function(jj) {
[16:03:21.384]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.384]                             ...future.FUN(...future.X_jj, ...)
[16:03:21.384]                           })
[16:03:21.384]                       }
[16:03:21.384]                     }, args = future.call.arguments)
[16:03:21.384]                   }
[16:03:21.384]                 }, immediateCondition = function(cond) {
[16:03:21.384]                   sendCondition <- ...future.makeSendCondition()
[16:03:21.384]                   sendCondition(cond)
[16:03:21.384]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.384]                   {
[16:03:21.384]                     inherits <- base::inherits
[16:03:21.384]                     invokeRestart <- base::invokeRestart
[16:03:21.384]                     is.null <- base::is.null
[16:03:21.384]                     muffled <- FALSE
[16:03:21.384]                     if (inherits(cond, "message")) {
[16:03:21.384]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:21.384]                       if (muffled) 
[16:03:21.384]                         invokeRestart("muffleMessage")
[16:03:21.384]                     }
[16:03:21.384]                     else if (inherits(cond, "warning")) {
[16:03:21.384]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:21.384]                       if (muffled) 
[16:03:21.384]                         invokeRestart("muffleWarning")
[16:03:21.384]                     }
[16:03:21.384]                     else if (inherits(cond, "condition")) {
[16:03:21.384]                       if (!is.null(pattern)) {
[16:03:21.384]                         computeRestarts <- base::computeRestarts
[16:03:21.384]                         grepl <- base::grepl
[16:03:21.384]                         restarts <- computeRestarts(cond)
[16:03:21.384]                         for (restart in restarts) {
[16:03:21.384]                           name <- restart$name
[16:03:21.384]                           if (is.null(name)) 
[16:03:21.384]                             next
[16:03:21.384]                           if (!grepl(pattern, name)) 
[16:03:21.384]                             next
[16:03:21.384]                           invokeRestart(restart)
[16:03:21.384]                           muffled <- TRUE
[16:03:21.384]                           break
[16:03:21.384]                         }
[16:03:21.384]                       }
[16:03:21.384]                     }
[16:03:21.384]                     invisible(muffled)
[16:03:21.384]                   }
[16:03:21.384]                   muffleCondition(cond)
[16:03:21.384]                 })
[16:03:21.384]             }))
[16:03:21.384]             future::FutureResult(value = ...future.value$value, 
[16:03:21.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:21.384]                   ...future.rng), globalenv = if (FALSE) 
[16:03:21.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:21.384]                     ...future.globalenv.names))
[16:03:21.384]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:21.384]         }, condition = base::local({
[16:03:21.384]             c <- base::c
[16:03:21.384]             inherits <- base::inherits
[16:03:21.384]             invokeRestart <- base::invokeRestart
[16:03:21.384]             length <- base::length
[16:03:21.384]             list <- base::list
[16:03:21.384]             seq.int <- base::seq.int
[16:03:21.384]             signalCondition <- base::signalCondition
[16:03:21.384]             sys.calls <- base::sys.calls
[16:03:21.384]             `[[` <- base::`[[`
[16:03:21.384]             `+` <- base::`+`
[16:03:21.384]             `<<-` <- base::`<<-`
[16:03:21.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:21.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:21.384]                   3L)]
[16:03:21.384]             }
[16:03:21.384]             function(cond) {
[16:03:21.384]                 is_error <- inherits(cond, "error")
[16:03:21.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:21.384]                   NULL)
[16:03:21.384]                 if (is_error) {
[16:03:21.384]                   sessionInformation <- function() {
[16:03:21.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:21.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:21.384]                       search = base::search(), system = base::Sys.info())
[16:03:21.384]                   }
[16:03:21.384]                   ...future.conditions[[length(...future.conditions) + 
[16:03:21.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:21.384]                     cond$call), session = sessionInformation(), 
[16:03:21.384]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:21.384]                   signalCondition(cond)
[16:03:21.384]                 }
[16:03:21.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:21.384]                 "immediateCondition"))) {
[16:03:21.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:21.384]                   ...future.conditions[[length(...future.conditions) + 
[16:03:21.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:21.384]                   if (TRUE && !signal) {
[16:03:21.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.384]                     {
[16:03:21.384]                       inherits <- base::inherits
[16:03:21.384]                       invokeRestart <- base::invokeRestart
[16:03:21.384]                       is.null <- base::is.null
[16:03:21.384]                       muffled <- FALSE
[16:03:21.384]                       if (inherits(cond, "message")) {
[16:03:21.384]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:21.384]                         if (muffled) 
[16:03:21.384]                           invokeRestart("muffleMessage")
[16:03:21.384]                       }
[16:03:21.384]                       else if (inherits(cond, "warning")) {
[16:03:21.384]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:21.384]                         if (muffled) 
[16:03:21.384]                           invokeRestart("muffleWarning")
[16:03:21.384]                       }
[16:03:21.384]                       else if (inherits(cond, "condition")) {
[16:03:21.384]                         if (!is.null(pattern)) {
[16:03:21.384]                           computeRestarts <- base::computeRestarts
[16:03:21.384]                           grepl <- base::grepl
[16:03:21.384]                           restarts <- computeRestarts(cond)
[16:03:21.384]                           for (restart in restarts) {
[16:03:21.384]                             name <- restart$name
[16:03:21.384]                             if (is.null(name)) 
[16:03:21.384]                               next
[16:03:21.384]                             if (!grepl(pattern, name)) 
[16:03:21.384]                               next
[16:03:21.384]                             invokeRestart(restart)
[16:03:21.384]                             muffled <- TRUE
[16:03:21.384]                             break
[16:03:21.384]                           }
[16:03:21.384]                         }
[16:03:21.384]                       }
[16:03:21.384]                       invisible(muffled)
[16:03:21.384]                     }
[16:03:21.384]                     muffleCondition(cond, pattern = "^muffle")
[16:03:21.384]                   }
[16:03:21.384]                 }
[16:03:21.384]                 else {
[16:03:21.384]                   if (TRUE) {
[16:03:21.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.384]                     {
[16:03:21.384]                       inherits <- base::inherits
[16:03:21.384]                       invokeRestart <- base::invokeRestart
[16:03:21.384]                       is.null <- base::is.null
[16:03:21.384]                       muffled <- FALSE
[16:03:21.384]                       if (inherits(cond, "message")) {
[16:03:21.384]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:21.384]                         if (muffled) 
[16:03:21.384]                           invokeRestart("muffleMessage")
[16:03:21.384]                       }
[16:03:21.384]                       else if (inherits(cond, "warning")) {
[16:03:21.384]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:21.384]                         if (muffled) 
[16:03:21.384]                           invokeRestart("muffleWarning")
[16:03:21.384]                       }
[16:03:21.384]                       else if (inherits(cond, "condition")) {
[16:03:21.384]                         if (!is.null(pattern)) {
[16:03:21.384]                           computeRestarts <- base::computeRestarts
[16:03:21.384]                           grepl <- base::grepl
[16:03:21.384]                           restarts <- computeRestarts(cond)
[16:03:21.384]                           for (restart in restarts) {
[16:03:21.384]                             name <- restart$name
[16:03:21.384]                             if (is.null(name)) 
[16:03:21.384]                               next
[16:03:21.384]                             if (!grepl(pattern, name)) 
[16:03:21.384]                               next
[16:03:21.384]                             invokeRestart(restart)
[16:03:21.384]                             muffled <- TRUE
[16:03:21.384]                             break
[16:03:21.384]                           }
[16:03:21.384]                         }
[16:03:21.384]                       }
[16:03:21.384]                       invisible(muffled)
[16:03:21.384]                     }
[16:03:21.384]                     muffleCondition(cond, pattern = "^muffle")
[16:03:21.384]                   }
[16:03:21.384]                 }
[16:03:21.384]             }
[16:03:21.384]         }))
[16:03:21.384]     }, error = function(ex) {
[16:03:21.384]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:21.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:21.384]                 ...future.rng), started = ...future.startTime, 
[16:03:21.384]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:21.384]             version = "1.8"), class = "FutureResult")
[16:03:21.384]     }, finally = {
[16:03:21.384]         if (!identical(...future.workdir, getwd())) 
[16:03:21.384]             setwd(...future.workdir)
[16:03:21.384]         {
[16:03:21.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:21.384]                 ...future.oldOptions$nwarnings <- NULL
[16:03:21.384]             }
[16:03:21.384]             base::options(...future.oldOptions)
[16:03:21.384]             if (.Platform$OS.type == "windows") {
[16:03:21.384]                 old_names <- names(...future.oldEnvVars)
[16:03:21.384]                 envs <- base::Sys.getenv()
[16:03:21.384]                 names <- names(envs)
[16:03:21.384]                 common <- intersect(names, old_names)
[16:03:21.384]                 added <- setdiff(names, old_names)
[16:03:21.384]                 removed <- setdiff(old_names, names)
[16:03:21.384]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:21.384]                   envs[common]]
[16:03:21.384]                 NAMES <- toupper(changed)
[16:03:21.384]                 args <- list()
[16:03:21.384]                 for (kk in seq_along(NAMES)) {
[16:03:21.384]                   name <- changed[[kk]]
[16:03:21.384]                   NAME <- NAMES[[kk]]
[16:03:21.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.384]                     next
[16:03:21.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:21.384]                 }
[16:03:21.384]                 NAMES <- toupper(added)
[16:03:21.384]                 for (kk in seq_along(NAMES)) {
[16:03:21.384]                   name <- added[[kk]]
[16:03:21.384]                   NAME <- NAMES[[kk]]
[16:03:21.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.384]                     next
[16:03:21.384]                   args[[name]] <- ""
[16:03:21.384]                 }
[16:03:21.384]                 NAMES <- toupper(removed)
[16:03:21.384]                 for (kk in seq_along(NAMES)) {
[16:03:21.384]                   name <- removed[[kk]]
[16:03:21.384]                   NAME <- NAMES[[kk]]
[16:03:21.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.384]                     next
[16:03:21.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:21.384]                 }
[16:03:21.384]                 if (length(args) > 0) 
[16:03:21.384]                   base::do.call(base::Sys.setenv, args = args)
[16:03:21.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:21.384]             }
[16:03:21.384]             else {
[16:03:21.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:21.384]             }
[16:03:21.384]             {
[16:03:21.384]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:21.384]                   0L) {
[16:03:21.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:21.384]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:21.384]                   base::options(opts)
[16:03:21.384]                 }
[16:03:21.384]                 {
[16:03:21.384]                   {
[16:03:21.384]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:21.384]                     NULL
[16:03:21.384]                   }
[16:03:21.384]                   options(future.plan = NULL)
[16:03:21.384]                   if (is.na(NA_character_)) 
[16:03:21.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:21.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:21.384]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:21.384]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:21.384]                     envir = parent.frame()) 
[16:03:21.384]                   {
[16:03:21.384]                     if (is.function(workers)) 
[16:03:21.384]                       workers <- workers()
[16:03:21.384]                     workers <- structure(as.integer(workers), 
[16:03:21.384]                       class = class(workers))
[16:03:21.384]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:21.384]                       workers >= 1)
[16:03:21.384]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:21.384]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:21.384]                     }
[16:03:21.384]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:21.384]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:21.384]                       envir = envir)
[16:03:21.384]                     if (!future$lazy) 
[16:03:21.384]                       future <- run(future)
[16:03:21.384]                     invisible(future)
[16:03:21.384]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:21.384]                 }
[16:03:21.384]             }
[16:03:21.384]         }
[16:03:21.384]     })
[16:03:21.384]     if (TRUE) {
[16:03:21.384]         base::sink(type = "output", split = FALSE)
[16:03:21.384]         if (TRUE) {
[16:03:21.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:21.384]         }
[16:03:21.384]         else {
[16:03:21.384]             ...future.result["stdout"] <- base::list(NULL)
[16:03:21.384]         }
[16:03:21.384]         base::close(...future.stdout)
[16:03:21.384]         ...future.stdout <- NULL
[16:03:21.384]     }
[16:03:21.384]     ...future.result$conditions <- ...future.conditions
[16:03:21.384]     ...future.result$finished <- base::Sys.time()
[16:03:21.384]     ...future.result
[16:03:21.384] }
[16:03:21.386] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[16:03:21.387] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:21.427] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:21.427] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[16:03:21.428] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[16:03:21.428] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:21.428] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:21.429] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:21.471] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:21.471] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:21.515] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:21.515] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:03:21.516] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:03:21.516] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[16:03:21.516] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[16:03:21.516] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:21.517] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:21.517] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[16:03:21.517] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[16:03:21.517] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:21.518] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:21.518] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:21.518] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:21.518] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[16:03:21.519] MultisessionFuture started
[16:03:21.519] - Launch lazy future ... done
[16:03:21.519] run() for ‘MultisessionFuture’ ... done
[16:03:21.519] Created future:
[16:03:21.520] MultisessionFuture:
[16:03:21.520] Label: ‘future_vapply-2’
[16:03:21.520] Expression:
[16:03:21.520] {
[16:03:21.520]     do.call(function(...) {
[16:03:21.520]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.520]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:21.520]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.520]             on.exit(options(oopts), add = TRUE)
[16:03:21.520]         }
[16:03:21.520]         {
[16:03:21.520]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:21.520]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.520]                 ...future.FUN(...future.X_jj, ...)
[16:03:21.520]             })
[16:03:21.520]         }
[16:03:21.520]     }, args = future.call.arguments)
[16:03:21.520] }
[16:03:21.520] Lazy evaluation: FALSE
[16:03:21.520] Asynchronous evaluation: TRUE
[16:03:21.520] Local evaluation: TRUE
[16:03:21.520] Environment: R_GlobalEnv
[16:03:21.520] Capture standard output: TRUE
[16:03:21.520] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:21.520] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:21.520] Packages: 1 packages (‘future.apply’)
[16:03:21.520] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:21.520] Resolved: FALSE
[16:03:21.520] Value: <not collected>
[16:03:21.520] Conditions captured: <none>
[16:03:21.520] Early signaling: FALSE
[16:03:21.520] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:21.520] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:21.531] Chunk #2 of 2 ... DONE
[16:03:21.531] Launching 2 futures (chunks) ... DONE
[16:03:21.531] Resolving 2 futures (chunks) ...
[16:03:21.532] resolve() on list ...
[16:03:21.532]  recursive: 0
[16:03:21.532]  length: 2
[16:03:21.532] 
[16:03:21.532] receiveMessageFromWorker() for ClusterFuture ...
[16:03:21.533] - Validating connection of MultisessionFuture
[16:03:21.533] - received message: FutureResult
[16:03:21.533] - Received FutureResult
[16:03:21.533] - Erased future from FutureRegistry
[16:03:21.533] result() for ClusterFuture ...
[16:03:21.533] - result already collected: FutureResult
[16:03:21.533] result() for ClusterFuture ... done
[16:03:21.533] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:21.533] Future #1
[16:03:21.534] result() for ClusterFuture ...
[16:03:21.534] - result already collected: FutureResult
[16:03:21.534] result() for ClusterFuture ... done
[16:03:21.534] result() for ClusterFuture ...
[16:03:21.534] - result already collected: FutureResult
[16:03:21.534] result() for ClusterFuture ... done
[16:03:21.534] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:21.534] - nx: 2
[16:03:21.534] - relay: TRUE
[16:03:21.534] - stdout: TRUE
[16:03:21.534] - signal: TRUE
[16:03:21.534] - resignal: FALSE
[16:03:21.535] - force: TRUE
[16:03:21.535] - relayed: [n=2] FALSE, FALSE
[16:03:21.535] - queued futures: [n=2] FALSE, FALSE
[16:03:21.535]  - until=1
[16:03:21.535]  - relaying element #1
[16:03:21.535] result() for ClusterFuture ...
[16:03:21.535] - result already collected: FutureResult
[16:03:21.535] result() for ClusterFuture ... done
[16:03:21.535] result() for ClusterFuture ...
[16:03:21.535] - result already collected: FutureResult
[16:03:21.535] result() for ClusterFuture ... done
[16:03:21.536] result() for ClusterFuture ...
[16:03:21.536] - result already collected: FutureResult
[16:03:21.536] result() for ClusterFuture ... done
[16:03:21.536] result() for ClusterFuture ...
[16:03:21.536] - result already collected: FutureResult
[16:03:21.536] result() for ClusterFuture ... done
[16:03:21.536] - relayed: [n=2] TRUE, FALSE
[16:03:21.536] - queued futures: [n=2] TRUE, FALSE
[16:03:21.536] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:21.536]  length: 1 (resolved future 1)
[16:03:21.578] receiveMessageFromWorker() for ClusterFuture ...
[16:03:21.579] - Validating connection of MultisessionFuture
[16:03:21.579] - received message: FutureResult
[16:03:21.579] - Received FutureResult
[16:03:21.579] - Erased future from FutureRegistry
[16:03:21.579] result() for ClusterFuture ...
[16:03:21.579] - result already collected: FutureResult
[16:03:21.579] result() for ClusterFuture ... done
[16:03:21.579] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:21.579] Future #2
[16:03:21.580] result() for ClusterFuture ...
[16:03:21.580] - result already collected: FutureResult
[16:03:21.580] result() for ClusterFuture ... done
[16:03:21.580] result() for ClusterFuture ...
[16:03:21.580] - result already collected: FutureResult
[16:03:21.580] result() for ClusterFuture ... done
[16:03:21.580] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:21.580] - nx: 2
[16:03:21.580] - relay: TRUE
[16:03:21.580] - stdout: TRUE
[16:03:21.580] - signal: TRUE
[16:03:21.581] - resignal: FALSE
[16:03:21.581] - force: TRUE
[16:03:21.581] - relayed: [n=2] TRUE, FALSE
[16:03:21.581] - queued futures: [n=2] TRUE, FALSE
[16:03:21.581]  - until=2
[16:03:21.581]  - relaying element #2
[16:03:21.581] result() for ClusterFuture ...
[16:03:21.581] - result already collected: FutureResult
[16:03:21.581] result() for ClusterFuture ... done
[16:03:21.581] result() for ClusterFuture ...
[16:03:21.581] - result already collected: FutureResult
[16:03:21.581] result() for ClusterFuture ... done
[16:03:21.582] result() for ClusterFuture ...
[16:03:21.582] - result already collected: FutureResult
[16:03:21.582] result() for ClusterFuture ... done
[16:03:21.582] result() for ClusterFuture ...
[16:03:21.582] - result already collected: FutureResult
[16:03:21.582] result() for ClusterFuture ... done
[16:03:21.582] - relayed: [n=2] TRUE, TRUE
[16:03:21.582] - queued futures: [n=2] TRUE, TRUE
[16:03:21.582] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:21.582]  length: 0 (resolved future 2)
[16:03:21.582] Relaying remaining futures
[16:03:21.583] signalConditionsASAP(NULL, pos=0) ...
[16:03:21.583] - nx: 2
[16:03:21.583] - relay: TRUE
[16:03:21.583] - stdout: TRUE
[16:03:21.583] - signal: TRUE
[16:03:21.583] - resignal: FALSE
[16:03:21.583] - force: TRUE
[16:03:21.583] - relayed: [n=2] TRUE, TRUE
[16:03:21.583] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:21.583] - relayed: [n=2] TRUE, TRUE
[16:03:21.584] - queued futures: [n=2] TRUE, TRUE
[16:03:21.584] signalConditionsASAP(NULL, pos=0) ... done
[16:03:21.584] resolve() on list ... DONE
[16:03:21.584] result() for ClusterFuture ...
[16:03:21.584] - result already collected: FutureResult
[16:03:21.584] result() for ClusterFuture ... done
[16:03:21.584] result() for ClusterFuture ...
[16:03:21.584] - result already collected: FutureResult
[16:03:21.584] result() for ClusterFuture ... done
[16:03:21.584] result() for ClusterFuture ...
[16:03:21.585] - result already collected: FutureResult
[16:03:21.585] result() for ClusterFuture ... done
[16:03:21.585] result() for ClusterFuture ...
[16:03:21.585] - result already collected: FutureResult
[16:03:21.585] result() for ClusterFuture ... done
[16:03:21.585]  - Number of value chunks collected: 2
[16:03:21.585] Resolving 2 futures (chunks) ... DONE
[16:03:21.585] Reducing values from 2 chunks ...
[16:03:21.585]  - Number of values collected after concatenation: 11
[16:03:21.585]  - Number of values expected: 11
[16:03:21.585] Reducing values from 2 chunks ... DONE
[16:03:21.586] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[16:03:21.586] future_lapply() ...
[16:03:21.592] Number of chunks: 2
[16:03:21.592] getGlobalsAndPackagesXApply() ...
[16:03:21.592]  - future.globals: TRUE
[16:03:21.592] getGlobalsAndPackages() ...
[16:03:21.592] Searching for globals...
[16:03:21.595] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:21.595] Searching for globals ... DONE
[16:03:21.595] Resolving globals: FALSE
[16:03:21.596] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[16:03:21.597] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:21.597] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:21.597] - packages: [1] ‘future.apply’
[16:03:21.597] getGlobalsAndPackages() ... DONE
[16:03:21.597]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:21.597]  - needed namespaces: [n=1] ‘future.apply’
[16:03:21.597] Finding globals ... DONE
[16:03:21.597]  - use_args: TRUE
[16:03:21.598]  - Getting '...' globals ...
[16:03:21.598] resolve() on list ...
[16:03:21.598]  recursive: 0
[16:03:21.598]  length: 1
[16:03:21.598]  elements: ‘...’
[16:03:21.598]  length: 0 (resolved future 1)
[16:03:21.598] resolve() on list ... DONE
[16:03:21.598]    - '...' content: [n=0] 
[16:03:21.599] List of 1
[16:03:21.599]  $ ...: list()
[16:03:21.599]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:21.599]  - attr(*, "where")=List of 1
[16:03:21.599]   ..$ ...:<environment: 0x564e442e3650> 
[16:03:21.599]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:21.599]  - attr(*, "resolved")= logi TRUE
[16:03:21.599]  - attr(*, "total_size")= num NA
[16:03:21.601]  - Getting '...' globals ... DONE
[16:03:21.601] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:21.601] List of 8
[16:03:21.601]  $ ...future.FUN:function (x, ...)  
[16:03:21.601]  $ x_FUN        :function (x)  
[16:03:21.601]  $ times        : int 1
[16:03:21.601]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:21.601]  $ stop_if_not  :function (...)  
[16:03:21.601]  $ dim          : NULL
[16:03:21.601]  $ valid_types  : chr [1:2] "logical" "integer"
[16:03:21.601]  $ ...          : list()
[16:03:21.601]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:21.601]  - attr(*, "where")=List of 8
[16:03:21.601]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:21.601]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:21.601]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:21.601]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:21.601]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:21.601]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:21.601]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:21.601]   ..$ ...          :<environment: 0x564e442e3650> 
[16:03:21.601]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:21.601]  - attr(*, "resolved")= logi FALSE
[16:03:21.601]  - attr(*, "total_size")= num 94264
[16:03:21.607] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:21.607] getGlobalsAndPackagesXApply() ... DONE
[16:03:21.607] Number of futures (= number of chunks): 2
[16:03:21.607] Launching 2 futures (chunks) ...
[16:03:21.607] Chunk #1 of 2 ...
[16:03:21.607]  - Finding globals in 'X' for chunk #1 ...
[16:03:21.607] getGlobalsAndPackages() ...
[16:03:21.607] Searching for globals...
[16:03:21.608] 
[16:03:21.608] Searching for globals ... DONE
[16:03:21.608] - globals: [0] <none>
[16:03:21.608] getGlobalsAndPackages() ... DONE
[16:03:21.608]    + additional globals found: [n=0] 
[16:03:21.608]    + additional namespaces needed: [n=0] 
[16:03:21.608]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:21.608]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:21.608]  - seeds: <none>
[16:03:21.608]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.609] getGlobalsAndPackages() ...
[16:03:21.609] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.609] Resolving globals: FALSE
[16:03:21.609] Tweak future expression to call with '...' arguments ...
[16:03:21.609] {
[16:03:21.609]     do.call(function(...) {
[16:03:21.609]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.609]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:21.609]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.609]             on.exit(options(oopts), add = TRUE)
[16:03:21.609]         }
[16:03:21.609]         {
[16:03:21.609]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:21.609]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.609]                 ...future.FUN(...future.X_jj, ...)
[16:03:21.609]             })
[16:03:21.609]         }
[16:03:21.609]     }, args = future.call.arguments)
[16:03:21.609] }
[16:03:21.609] Tweak future expression to call with '...' arguments ... DONE
[16:03:21.610] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.610] - packages: [1] ‘future.apply’
[16:03:21.610] getGlobalsAndPackages() ... DONE
[16:03:21.610] run() for ‘Future’ ...
[16:03:21.610] - state: ‘created’
[16:03:21.611] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:21.628] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:21.628] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:21.628]   - Field: ‘node’
[16:03:21.628]   - Field: ‘label’
[16:03:21.629]   - Field: ‘local’
[16:03:21.629]   - Field: ‘owner’
[16:03:21.629]   - Field: ‘envir’
[16:03:21.629]   - Field: ‘workers’
[16:03:21.629]   - Field: ‘packages’
[16:03:21.630]   - Field: ‘gc’
[16:03:21.630]   - Field: ‘conditions’
[16:03:21.630]   - Field: ‘persistent’
[16:03:21.630]   - Field: ‘expr’
[16:03:21.630]   - Field: ‘uuid’
[16:03:21.630]   - Field: ‘seed’
[16:03:21.631]   - Field: ‘version’
[16:03:21.631]   - Field: ‘result’
[16:03:21.631]   - Field: ‘asynchronous’
[16:03:21.631]   - Field: ‘calls’
[16:03:21.631]   - Field: ‘globals’
[16:03:21.632]   - Field: ‘stdout’
[16:03:21.632]   - Field: ‘earlySignal’
[16:03:21.632]   - Field: ‘lazy’
[16:03:21.632]   - Field: ‘state’
[16:03:21.632] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:21.632] - Launch lazy future ...
[16:03:21.633] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:21.633] Packages needed by future strategies (n = 0): <none>
[16:03:21.634] {
[16:03:21.634]     {
[16:03:21.634]         {
[16:03:21.634]             ...future.startTime <- base::Sys.time()
[16:03:21.634]             {
[16:03:21.634]                 {
[16:03:21.634]                   {
[16:03:21.634]                     {
[16:03:21.634]                       {
[16:03:21.634]                         base::local({
[16:03:21.634]                           has_future <- base::requireNamespace("future", 
[16:03:21.634]                             quietly = TRUE)
[16:03:21.634]                           if (has_future) {
[16:03:21.634]                             ns <- base::getNamespace("future")
[16:03:21.634]                             version <- ns[[".package"]][["version"]]
[16:03:21.634]                             if (is.null(version)) 
[16:03:21.634]                               version <- utils::packageVersion("future")
[16:03:21.634]                           }
[16:03:21.634]                           else {
[16:03:21.634]                             version <- NULL
[16:03:21.634]                           }
[16:03:21.634]                           if (!has_future || version < "1.8.0") {
[16:03:21.634]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:21.634]                               "", base::R.version$version.string), 
[16:03:21.634]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:21.634]                                 base::R.version$platform, 8 * 
[16:03:21.634]                                   base::.Machine$sizeof.pointer), 
[16:03:21.634]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:21.634]                                 "release", "version")], collapse = " "), 
[16:03:21.634]                               hostname = base::Sys.info()[["nodename"]])
[16:03:21.634]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:21.634]                               info)
[16:03:21.634]                             info <- base::paste(info, collapse = "; ")
[16:03:21.634]                             if (!has_future) {
[16:03:21.634]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:21.634]                                 info)
[16:03:21.634]                             }
[16:03:21.634]                             else {
[16:03:21.634]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:21.634]                                 info, version)
[16:03:21.634]                             }
[16:03:21.634]                             base::stop(msg)
[16:03:21.634]                           }
[16:03:21.634]                         })
[16:03:21.634]                       }
[16:03:21.634]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:21.634]                       base::options(mc.cores = 1L)
[16:03:21.634]                     }
[16:03:21.634]                     base::local({
[16:03:21.634]                       for (pkg in "future.apply") {
[16:03:21.634]                         base::loadNamespace(pkg)
[16:03:21.634]                         base::library(pkg, character.only = TRUE)
[16:03:21.634]                       }
[16:03:21.634]                     })
[16:03:21.634]                   }
[16:03:21.634]                   options(future.plan = NULL)
[16:03:21.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:21.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:21.634]                 }
[16:03:21.634]                 ...future.workdir <- getwd()
[16:03:21.634]             }
[16:03:21.634]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:21.634]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:21.634]         }
[16:03:21.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:21.634]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:21.634]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:21.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:21.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:21.634]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:21.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:21.634]             base::names(...future.oldOptions))
[16:03:21.634]     }
[16:03:21.634]     if (FALSE) {
[16:03:21.634]     }
[16:03:21.634]     else {
[16:03:21.634]         if (TRUE) {
[16:03:21.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:21.634]                 open = "w")
[16:03:21.634]         }
[16:03:21.634]         else {
[16:03:21.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:21.634]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:21.634]         }
[16:03:21.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:21.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:21.634]             base::sink(type = "output", split = FALSE)
[16:03:21.634]             base::close(...future.stdout)
[16:03:21.634]         }, add = TRUE)
[16:03:21.634]     }
[16:03:21.634]     ...future.frame <- base::sys.nframe()
[16:03:21.634]     ...future.conditions <- base::list()
[16:03:21.634]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:21.634]     if (FALSE) {
[16:03:21.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:21.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:21.634]     }
[16:03:21.634]     ...future.result <- base::tryCatch({
[16:03:21.634]         base::withCallingHandlers({
[16:03:21.634]             ...future.value <- base::withVisible(base::local({
[16:03:21.634]                 ...future.makeSendCondition <- base::local({
[16:03:21.634]                   sendCondition <- NULL
[16:03:21.634]                   function(frame = 1L) {
[16:03:21.634]                     if (is.function(sendCondition)) 
[16:03:21.634]                       return(sendCondition)
[16:03:21.634]                     ns <- getNamespace("parallel")
[16:03:21.634]                     if (exists("sendData", mode = "function", 
[16:03:21.634]                       envir = ns)) {
[16:03:21.634]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:21.634]                         envir = ns)
[16:03:21.634]                       envir <- sys.frame(frame)
[16:03:21.634]                       master <- NULL
[16:03:21.634]                       while (!identical(envir, .GlobalEnv) && 
[16:03:21.634]                         !identical(envir, emptyenv())) {
[16:03:21.634]                         if (exists("master", mode = "list", envir = envir, 
[16:03:21.634]                           inherits = FALSE)) {
[16:03:21.634]                           master <- get("master", mode = "list", 
[16:03:21.634]                             envir = envir, inherits = FALSE)
[16:03:21.634]                           if (inherits(master, c("SOCKnode", 
[16:03:21.634]                             "SOCK0node"))) {
[16:03:21.634]                             sendCondition <<- function(cond) {
[16:03:21.634]                               data <- list(type = "VALUE", value = cond, 
[16:03:21.634]                                 success = TRUE)
[16:03:21.634]                               parallel_sendData(master, data)
[16:03:21.634]                             }
[16:03:21.634]                             return(sendCondition)
[16:03:21.634]                           }
[16:03:21.634]                         }
[16:03:21.634]                         frame <- frame + 1L
[16:03:21.634]                         envir <- sys.frame(frame)
[16:03:21.634]                       }
[16:03:21.634]                     }
[16:03:21.634]                     sendCondition <<- function(cond) NULL
[16:03:21.634]                   }
[16:03:21.634]                 })
[16:03:21.634]                 withCallingHandlers({
[16:03:21.634]                   {
[16:03:21.634]                     do.call(function(...) {
[16:03:21.634]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.634]                       if (!identical(...future.globals.maxSize.org, 
[16:03:21.634]                         ...future.globals.maxSize)) {
[16:03:21.634]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.634]                         on.exit(options(oopts), add = TRUE)
[16:03:21.634]                       }
[16:03:21.634]                       {
[16:03:21.634]                         lapply(seq_along(...future.elements_ii), 
[16:03:21.634]                           FUN = function(jj) {
[16:03:21.634]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.634]                             ...future.FUN(...future.X_jj, ...)
[16:03:21.634]                           })
[16:03:21.634]                       }
[16:03:21.634]                     }, args = future.call.arguments)
[16:03:21.634]                   }
[16:03:21.634]                 }, immediateCondition = function(cond) {
[16:03:21.634]                   sendCondition <- ...future.makeSendCondition()
[16:03:21.634]                   sendCondition(cond)
[16:03:21.634]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.634]                   {
[16:03:21.634]                     inherits <- base::inherits
[16:03:21.634]                     invokeRestart <- base::invokeRestart
[16:03:21.634]                     is.null <- base::is.null
[16:03:21.634]                     muffled <- FALSE
[16:03:21.634]                     if (inherits(cond, "message")) {
[16:03:21.634]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:21.634]                       if (muffled) 
[16:03:21.634]                         invokeRestart("muffleMessage")
[16:03:21.634]                     }
[16:03:21.634]                     else if (inherits(cond, "warning")) {
[16:03:21.634]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:21.634]                       if (muffled) 
[16:03:21.634]                         invokeRestart("muffleWarning")
[16:03:21.634]                     }
[16:03:21.634]                     else if (inherits(cond, "condition")) {
[16:03:21.634]                       if (!is.null(pattern)) {
[16:03:21.634]                         computeRestarts <- base::computeRestarts
[16:03:21.634]                         grepl <- base::grepl
[16:03:21.634]                         restarts <- computeRestarts(cond)
[16:03:21.634]                         for (restart in restarts) {
[16:03:21.634]                           name <- restart$name
[16:03:21.634]                           if (is.null(name)) 
[16:03:21.634]                             next
[16:03:21.634]                           if (!grepl(pattern, name)) 
[16:03:21.634]                             next
[16:03:21.634]                           invokeRestart(restart)
[16:03:21.634]                           muffled <- TRUE
[16:03:21.634]                           break
[16:03:21.634]                         }
[16:03:21.634]                       }
[16:03:21.634]                     }
[16:03:21.634]                     invisible(muffled)
[16:03:21.634]                   }
[16:03:21.634]                   muffleCondition(cond)
[16:03:21.634]                 })
[16:03:21.634]             }))
[16:03:21.634]             future::FutureResult(value = ...future.value$value, 
[16:03:21.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:21.634]                   ...future.rng), globalenv = if (FALSE) 
[16:03:21.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:21.634]                     ...future.globalenv.names))
[16:03:21.634]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:21.634]         }, condition = base::local({
[16:03:21.634]             c <- base::c
[16:03:21.634]             inherits <- base::inherits
[16:03:21.634]             invokeRestart <- base::invokeRestart
[16:03:21.634]             length <- base::length
[16:03:21.634]             list <- base::list
[16:03:21.634]             seq.int <- base::seq.int
[16:03:21.634]             signalCondition <- base::signalCondition
[16:03:21.634]             sys.calls <- base::sys.calls
[16:03:21.634]             `[[` <- base::`[[`
[16:03:21.634]             `+` <- base::`+`
[16:03:21.634]             `<<-` <- base::`<<-`
[16:03:21.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:21.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:21.634]                   3L)]
[16:03:21.634]             }
[16:03:21.634]             function(cond) {
[16:03:21.634]                 is_error <- inherits(cond, "error")
[16:03:21.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:21.634]                   NULL)
[16:03:21.634]                 if (is_error) {
[16:03:21.634]                   sessionInformation <- function() {
[16:03:21.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:21.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:21.634]                       search = base::search(), system = base::Sys.info())
[16:03:21.634]                   }
[16:03:21.634]                   ...future.conditions[[length(...future.conditions) + 
[16:03:21.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:21.634]                     cond$call), session = sessionInformation(), 
[16:03:21.634]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:21.634]                   signalCondition(cond)
[16:03:21.634]                 }
[16:03:21.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:21.634]                 "immediateCondition"))) {
[16:03:21.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:21.634]                   ...future.conditions[[length(...future.conditions) + 
[16:03:21.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:21.634]                   if (TRUE && !signal) {
[16:03:21.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.634]                     {
[16:03:21.634]                       inherits <- base::inherits
[16:03:21.634]                       invokeRestart <- base::invokeRestart
[16:03:21.634]                       is.null <- base::is.null
[16:03:21.634]                       muffled <- FALSE
[16:03:21.634]                       if (inherits(cond, "message")) {
[16:03:21.634]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:21.634]                         if (muffled) 
[16:03:21.634]                           invokeRestart("muffleMessage")
[16:03:21.634]                       }
[16:03:21.634]                       else if (inherits(cond, "warning")) {
[16:03:21.634]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:21.634]                         if (muffled) 
[16:03:21.634]                           invokeRestart("muffleWarning")
[16:03:21.634]                       }
[16:03:21.634]                       else if (inherits(cond, "condition")) {
[16:03:21.634]                         if (!is.null(pattern)) {
[16:03:21.634]                           computeRestarts <- base::computeRestarts
[16:03:21.634]                           grepl <- base::grepl
[16:03:21.634]                           restarts <- computeRestarts(cond)
[16:03:21.634]                           for (restart in restarts) {
[16:03:21.634]                             name <- restart$name
[16:03:21.634]                             if (is.null(name)) 
[16:03:21.634]                               next
[16:03:21.634]                             if (!grepl(pattern, name)) 
[16:03:21.634]                               next
[16:03:21.634]                             invokeRestart(restart)
[16:03:21.634]                             muffled <- TRUE
[16:03:21.634]                             break
[16:03:21.634]                           }
[16:03:21.634]                         }
[16:03:21.634]                       }
[16:03:21.634]                       invisible(muffled)
[16:03:21.634]                     }
[16:03:21.634]                     muffleCondition(cond, pattern = "^muffle")
[16:03:21.634]                   }
[16:03:21.634]                 }
[16:03:21.634]                 else {
[16:03:21.634]                   if (TRUE) {
[16:03:21.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.634]                     {
[16:03:21.634]                       inherits <- base::inherits
[16:03:21.634]                       invokeRestart <- base::invokeRestart
[16:03:21.634]                       is.null <- base::is.null
[16:03:21.634]                       muffled <- FALSE
[16:03:21.634]                       if (inherits(cond, "message")) {
[16:03:21.634]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:21.634]                         if (muffled) 
[16:03:21.634]                           invokeRestart("muffleMessage")
[16:03:21.634]                       }
[16:03:21.634]                       else if (inherits(cond, "warning")) {
[16:03:21.634]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:21.634]                         if (muffled) 
[16:03:21.634]                           invokeRestart("muffleWarning")
[16:03:21.634]                       }
[16:03:21.634]                       else if (inherits(cond, "condition")) {
[16:03:21.634]                         if (!is.null(pattern)) {
[16:03:21.634]                           computeRestarts <- base::computeRestarts
[16:03:21.634]                           grepl <- base::grepl
[16:03:21.634]                           restarts <- computeRestarts(cond)
[16:03:21.634]                           for (restart in restarts) {
[16:03:21.634]                             name <- restart$name
[16:03:21.634]                             if (is.null(name)) 
[16:03:21.634]                               next
[16:03:21.634]                             if (!grepl(pattern, name)) 
[16:03:21.634]                               next
[16:03:21.634]                             invokeRestart(restart)
[16:03:21.634]                             muffled <- TRUE
[16:03:21.634]                             break
[16:03:21.634]                           }
[16:03:21.634]                         }
[16:03:21.634]                       }
[16:03:21.634]                       invisible(muffled)
[16:03:21.634]                     }
[16:03:21.634]                     muffleCondition(cond, pattern = "^muffle")
[16:03:21.634]                   }
[16:03:21.634]                 }
[16:03:21.634]             }
[16:03:21.634]         }))
[16:03:21.634]     }, error = function(ex) {
[16:03:21.634]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:21.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:21.634]                 ...future.rng), started = ...future.startTime, 
[16:03:21.634]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:21.634]             version = "1.8"), class = "FutureResult")
[16:03:21.634]     }, finally = {
[16:03:21.634]         if (!identical(...future.workdir, getwd())) 
[16:03:21.634]             setwd(...future.workdir)
[16:03:21.634]         {
[16:03:21.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:21.634]                 ...future.oldOptions$nwarnings <- NULL
[16:03:21.634]             }
[16:03:21.634]             base::options(...future.oldOptions)
[16:03:21.634]             if (.Platform$OS.type == "windows") {
[16:03:21.634]                 old_names <- names(...future.oldEnvVars)
[16:03:21.634]                 envs <- base::Sys.getenv()
[16:03:21.634]                 names <- names(envs)
[16:03:21.634]                 common <- intersect(names, old_names)
[16:03:21.634]                 added <- setdiff(names, old_names)
[16:03:21.634]                 removed <- setdiff(old_names, names)
[16:03:21.634]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:21.634]                   envs[common]]
[16:03:21.634]                 NAMES <- toupper(changed)
[16:03:21.634]                 args <- list()
[16:03:21.634]                 for (kk in seq_along(NAMES)) {
[16:03:21.634]                   name <- changed[[kk]]
[16:03:21.634]                   NAME <- NAMES[[kk]]
[16:03:21.634]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.634]                     next
[16:03:21.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:21.634]                 }
[16:03:21.634]                 NAMES <- toupper(added)
[16:03:21.634]                 for (kk in seq_along(NAMES)) {
[16:03:21.634]                   name <- added[[kk]]
[16:03:21.634]                   NAME <- NAMES[[kk]]
[16:03:21.634]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.634]                     next
[16:03:21.634]                   args[[name]] <- ""
[16:03:21.634]                 }
[16:03:21.634]                 NAMES <- toupper(removed)
[16:03:21.634]                 for (kk in seq_along(NAMES)) {
[16:03:21.634]                   name <- removed[[kk]]
[16:03:21.634]                   NAME <- NAMES[[kk]]
[16:03:21.634]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.634]                     next
[16:03:21.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:21.634]                 }
[16:03:21.634]                 if (length(args) > 0) 
[16:03:21.634]                   base::do.call(base::Sys.setenv, args = args)
[16:03:21.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:21.634]             }
[16:03:21.634]             else {
[16:03:21.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:21.634]             }
[16:03:21.634]             {
[16:03:21.634]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:21.634]                   0L) {
[16:03:21.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:21.634]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:21.634]                   base::options(opts)
[16:03:21.634]                 }
[16:03:21.634]                 {
[16:03:21.634]                   {
[16:03:21.634]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:21.634]                     NULL
[16:03:21.634]                   }
[16:03:21.634]                   options(future.plan = NULL)
[16:03:21.634]                   if (is.na(NA_character_)) 
[16:03:21.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:21.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:21.634]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:21.634]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:21.634]                     envir = parent.frame()) 
[16:03:21.634]                   {
[16:03:21.634]                     if (is.function(workers)) 
[16:03:21.634]                       workers <- workers()
[16:03:21.634]                     workers <- structure(as.integer(workers), 
[16:03:21.634]                       class = class(workers))
[16:03:21.634]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:21.634]                       workers >= 1)
[16:03:21.634]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:21.634]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:21.634]                     }
[16:03:21.634]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:21.634]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:21.634]                       envir = envir)
[16:03:21.634]                     if (!future$lazy) 
[16:03:21.634]                       future <- run(future)
[16:03:21.634]                     invisible(future)
[16:03:21.634]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:21.634]                 }
[16:03:21.634]             }
[16:03:21.634]         }
[16:03:21.634]     })
[16:03:21.634]     if (TRUE) {
[16:03:21.634]         base::sink(type = "output", split = FALSE)
[16:03:21.634]         if (TRUE) {
[16:03:21.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:21.634]         }
[16:03:21.634]         else {
[16:03:21.634]             ...future.result["stdout"] <- base::list(NULL)
[16:03:21.634]         }
[16:03:21.634]         base::close(...future.stdout)
[16:03:21.634]         ...future.stdout <- NULL
[16:03:21.634]     }
[16:03:21.634]     ...future.result$conditions <- ...future.conditions
[16:03:21.634]     ...future.result$finished <- base::Sys.time()
[16:03:21.634]     ...future.result
[16:03:21.634] }
[16:03:21.639] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[16:03:21.640] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:21.683] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:21.683] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:03:21.684] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:03:21.684] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:21.684] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:21.684] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:21.727] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:21.727] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:21.771] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:21.771] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:03:21.772] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:03:21.772] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[16:03:21.772] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[16:03:21.772] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:21.773] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:21.773] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:03:21.773] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:03:21.773] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:21.774] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:21.774] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:21.774] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:21.774] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[16:03:21.775] MultisessionFuture started
[16:03:21.775] - Launch lazy future ... done
[16:03:21.775] run() for ‘MultisessionFuture’ ... done
[16:03:21.775] Created future:
[16:03:21.775] MultisessionFuture:
[16:03:21.775] Label: ‘future_vapply-1’
[16:03:21.775] Expression:
[16:03:21.775] {
[16:03:21.775]     do.call(function(...) {
[16:03:21.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:21.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.775]             on.exit(options(oopts), add = TRUE)
[16:03:21.775]         }
[16:03:21.775]         {
[16:03:21.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:21.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.775]                 ...future.FUN(...future.X_jj, ...)
[16:03:21.775]             })
[16:03:21.775]         }
[16:03:21.775]     }, args = future.call.arguments)
[16:03:21.775] }
[16:03:21.775] Lazy evaluation: FALSE
[16:03:21.775] Asynchronous evaluation: TRUE
[16:03:21.775] Local evaluation: TRUE
[16:03:21.775] Environment: R_GlobalEnv
[16:03:21.775] Capture standard output: TRUE
[16:03:21.775] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:21.775] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:21.775] Packages: 1 packages (‘future.apply’)
[16:03:21.775] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:21.775] Resolved: FALSE
[16:03:21.775] Value: <not collected>
[16:03:21.775] Conditions captured: <none>
[16:03:21.775] Early signaling: FALSE
[16:03:21.775] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:21.775] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:21.787] Chunk #1 of 2 ... DONE
[16:03:21.787] Chunk #2 of 2 ...
[16:03:21.787]  - Finding globals in 'X' for chunk #2 ...
[16:03:21.787] getGlobalsAndPackages() ...
[16:03:21.787] Searching for globals...
[16:03:21.788] 
[16:03:21.788] Searching for globals ... DONE
[16:03:21.788] - globals: [0] <none>
[16:03:21.788] getGlobalsAndPackages() ... DONE
[16:03:21.788]    + additional globals found: [n=0] 
[16:03:21.788]    + additional namespaces needed: [n=0] 
[16:03:21.788]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:21.788]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:21.789]  - seeds: <none>
[16:03:21.792]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.792] getGlobalsAndPackages() ...
[16:03:21.792] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.792] Resolving globals: FALSE
[16:03:21.792] Tweak future expression to call with '...' arguments ...
[16:03:21.792] {
[16:03:21.792]     do.call(function(...) {
[16:03:21.792]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.792]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:21.792]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.792]             on.exit(options(oopts), add = TRUE)
[16:03:21.792]         }
[16:03:21.792]         {
[16:03:21.792]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:21.792]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.792]                 ...future.FUN(...future.X_jj, ...)
[16:03:21.792]             })
[16:03:21.792]         }
[16:03:21.792]     }, args = future.call.arguments)
[16:03:21.792] }
[16:03:21.792] Tweak future expression to call with '...' arguments ... DONE
[16:03:21.793] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:21.793] - packages: [1] ‘future.apply’
[16:03:21.793] getGlobalsAndPackages() ... DONE
[16:03:21.793] run() for ‘Future’ ...
[16:03:21.794] - state: ‘created’
[16:03:21.794] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:21.808] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:21.808] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:21.808]   - Field: ‘node’
[16:03:21.808]   - Field: ‘label’
[16:03:21.808]   - Field: ‘local’
[16:03:21.808]   - Field: ‘owner’
[16:03:21.808]   - Field: ‘envir’
[16:03:21.808]   - Field: ‘workers’
[16:03:21.809]   - Field: ‘packages’
[16:03:21.809]   - Field: ‘gc’
[16:03:21.809]   - Field: ‘conditions’
[16:03:21.809]   - Field: ‘persistent’
[16:03:21.809]   - Field: ‘expr’
[16:03:21.809]   - Field: ‘uuid’
[16:03:21.809]   - Field: ‘seed’
[16:03:21.809]   - Field: ‘version’
[16:03:21.809]   - Field: ‘result’
[16:03:21.809]   - Field: ‘asynchronous’
[16:03:21.809]   - Field: ‘calls’
[16:03:21.810]   - Field: ‘globals’
[16:03:21.810]   - Field: ‘stdout’
[16:03:21.810]   - Field: ‘earlySignal’
[16:03:21.810]   - Field: ‘lazy’
[16:03:21.810]   - Field: ‘state’
[16:03:21.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:21.810] - Launch lazy future ...
[16:03:21.810] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:21.811] Packages needed by future strategies (n = 0): <none>
[16:03:21.811] {
[16:03:21.811]     {
[16:03:21.811]         {
[16:03:21.811]             ...future.startTime <- base::Sys.time()
[16:03:21.811]             {
[16:03:21.811]                 {
[16:03:21.811]                   {
[16:03:21.811]                     {
[16:03:21.811]                       {
[16:03:21.811]                         base::local({
[16:03:21.811]                           has_future <- base::requireNamespace("future", 
[16:03:21.811]                             quietly = TRUE)
[16:03:21.811]                           if (has_future) {
[16:03:21.811]                             ns <- base::getNamespace("future")
[16:03:21.811]                             version <- ns[[".package"]][["version"]]
[16:03:21.811]                             if (is.null(version)) 
[16:03:21.811]                               version <- utils::packageVersion("future")
[16:03:21.811]                           }
[16:03:21.811]                           else {
[16:03:21.811]                             version <- NULL
[16:03:21.811]                           }
[16:03:21.811]                           if (!has_future || version < "1.8.0") {
[16:03:21.811]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:21.811]                               "", base::R.version$version.string), 
[16:03:21.811]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:21.811]                                 base::R.version$platform, 8 * 
[16:03:21.811]                                   base::.Machine$sizeof.pointer), 
[16:03:21.811]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:21.811]                                 "release", "version")], collapse = " "), 
[16:03:21.811]                               hostname = base::Sys.info()[["nodename"]])
[16:03:21.811]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:21.811]                               info)
[16:03:21.811]                             info <- base::paste(info, collapse = "; ")
[16:03:21.811]                             if (!has_future) {
[16:03:21.811]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:21.811]                                 info)
[16:03:21.811]                             }
[16:03:21.811]                             else {
[16:03:21.811]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:21.811]                                 info, version)
[16:03:21.811]                             }
[16:03:21.811]                             base::stop(msg)
[16:03:21.811]                           }
[16:03:21.811]                         })
[16:03:21.811]                       }
[16:03:21.811]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:21.811]                       base::options(mc.cores = 1L)
[16:03:21.811]                     }
[16:03:21.811]                     base::local({
[16:03:21.811]                       for (pkg in "future.apply") {
[16:03:21.811]                         base::loadNamespace(pkg)
[16:03:21.811]                         base::library(pkg, character.only = TRUE)
[16:03:21.811]                       }
[16:03:21.811]                     })
[16:03:21.811]                   }
[16:03:21.811]                   options(future.plan = NULL)
[16:03:21.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:21.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:21.811]                 }
[16:03:21.811]                 ...future.workdir <- getwd()
[16:03:21.811]             }
[16:03:21.811]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:21.811]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:21.811]         }
[16:03:21.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:21.811]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:21.811]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:21.811]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:21.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:21.811]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:21.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:21.811]             base::names(...future.oldOptions))
[16:03:21.811]     }
[16:03:21.811]     if (FALSE) {
[16:03:21.811]     }
[16:03:21.811]     else {
[16:03:21.811]         if (TRUE) {
[16:03:21.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:21.811]                 open = "w")
[16:03:21.811]         }
[16:03:21.811]         else {
[16:03:21.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:21.811]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:21.811]         }
[16:03:21.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:21.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:21.811]             base::sink(type = "output", split = FALSE)
[16:03:21.811]             base::close(...future.stdout)
[16:03:21.811]         }, add = TRUE)
[16:03:21.811]     }
[16:03:21.811]     ...future.frame <- base::sys.nframe()
[16:03:21.811]     ...future.conditions <- base::list()
[16:03:21.811]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:21.811]     if (FALSE) {
[16:03:21.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:21.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:21.811]     }
[16:03:21.811]     ...future.result <- base::tryCatch({
[16:03:21.811]         base::withCallingHandlers({
[16:03:21.811]             ...future.value <- base::withVisible(base::local({
[16:03:21.811]                 ...future.makeSendCondition <- base::local({
[16:03:21.811]                   sendCondition <- NULL
[16:03:21.811]                   function(frame = 1L) {
[16:03:21.811]                     if (is.function(sendCondition)) 
[16:03:21.811]                       return(sendCondition)
[16:03:21.811]                     ns <- getNamespace("parallel")
[16:03:21.811]                     if (exists("sendData", mode = "function", 
[16:03:21.811]                       envir = ns)) {
[16:03:21.811]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:21.811]                         envir = ns)
[16:03:21.811]                       envir <- sys.frame(frame)
[16:03:21.811]                       master <- NULL
[16:03:21.811]                       while (!identical(envir, .GlobalEnv) && 
[16:03:21.811]                         !identical(envir, emptyenv())) {
[16:03:21.811]                         if (exists("master", mode = "list", envir = envir, 
[16:03:21.811]                           inherits = FALSE)) {
[16:03:21.811]                           master <- get("master", mode = "list", 
[16:03:21.811]                             envir = envir, inherits = FALSE)
[16:03:21.811]                           if (inherits(master, c("SOCKnode", 
[16:03:21.811]                             "SOCK0node"))) {
[16:03:21.811]                             sendCondition <<- function(cond) {
[16:03:21.811]                               data <- list(type = "VALUE", value = cond, 
[16:03:21.811]                                 success = TRUE)
[16:03:21.811]                               parallel_sendData(master, data)
[16:03:21.811]                             }
[16:03:21.811]                             return(sendCondition)
[16:03:21.811]                           }
[16:03:21.811]                         }
[16:03:21.811]                         frame <- frame + 1L
[16:03:21.811]                         envir <- sys.frame(frame)
[16:03:21.811]                       }
[16:03:21.811]                     }
[16:03:21.811]                     sendCondition <<- function(cond) NULL
[16:03:21.811]                   }
[16:03:21.811]                 })
[16:03:21.811]                 withCallingHandlers({
[16:03:21.811]                   {
[16:03:21.811]                     do.call(function(...) {
[16:03:21.811]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.811]                       if (!identical(...future.globals.maxSize.org, 
[16:03:21.811]                         ...future.globals.maxSize)) {
[16:03:21.811]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.811]                         on.exit(options(oopts), add = TRUE)
[16:03:21.811]                       }
[16:03:21.811]                       {
[16:03:21.811]                         lapply(seq_along(...future.elements_ii), 
[16:03:21.811]                           FUN = function(jj) {
[16:03:21.811]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.811]                             ...future.FUN(...future.X_jj, ...)
[16:03:21.811]                           })
[16:03:21.811]                       }
[16:03:21.811]                     }, args = future.call.arguments)
[16:03:21.811]                   }
[16:03:21.811]                 }, immediateCondition = function(cond) {
[16:03:21.811]                   sendCondition <- ...future.makeSendCondition()
[16:03:21.811]                   sendCondition(cond)
[16:03:21.811]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.811]                   {
[16:03:21.811]                     inherits <- base::inherits
[16:03:21.811]                     invokeRestart <- base::invokeRestart
[16:03:21.811]                     is.null <- base::is.null
[16:03:21.811]                     muffled <- FALSE
[16:03:21.811]                     if (inherits(cond, "message")) {
[16:03:21.811]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:21.811]                       if (muffled) 
[16:03:21.811]                         invokeRestart("muffleMessage")
[16:03:21.811]                     }
[16:03:21.811]                     else if (inherits(cond, "warning")) {
[16:03:21.811]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:21.811]                       if (muffled) 
[16:03:21.811]                         invokeRestart("muffleWarning")
[16:03:21.811]                     }
[16:03:21.811]                     else if (inherits(cond, "condition")) {
[16:03:21.811]                       if (!is.null(pattern)) {
[16:03:21.811]                         computeRestarts <- base::computeRestarts
[16:03:21.811]                         grepl <- base::grepl
[16:03:21.811]                         restarts <- computeRestarts(cond)
[16:03:21.811]                         for (restart in restarts) {
[16:03:21.811]                           name <- restart$name
[16:03:21.811]                           if (is.null(name)) 
[16:03:21.811]                             next
[16:03:21.811]                           if (!grepl(pattern, name)) 
[16:03:21.811]                             next
[16:03:21.811]                           invokeRestart(restart)
[16:03:21.811]                           muffled <- TRUE
[16:03:21.811]                           break
[16:03:21.811]                         }
[16:03:21.811]                       }
[16:03:21.811]                     }
[16:03:21.811]                     invisible(muffled)
[16:03:21.811]                   }
[16:03:21.811]                   muffleCondition(cond)
[16:03:21.811]                 })
[16:03:21.811]             }))
[16:03:21.811]             future::FutureResult(value = ...future.value$value, 
[16:03:21.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:21.811]                   ...future.rng), globalenv = if (FALSE) 
[16:03:21.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:21.811]                     ...future.globalenv.names))
[16:03:21.811]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:21.811]         }, condition = base::local({
[16:03:21.811]             c <- base::c
[16:03:21.811]             inherits <- base::inherits
[16:03:21.811]             invokeRestart <- base::invokeRestart
[16:03:21.811]             length <- base::length
[16:03:21.811]             list <- base::list
[16:03:21.811]             seq.int <- base::seq.int
[16:03:21.811]             signalCondition <- base::signalCondition
[16:03:21.811]             sys.calls <- base::sys.calls
[16:03:21.811]             `[[` <- base::`[[`
[16:03:21.811]             `+` <- base::`+`
[16:03:21.811]             `<<-` <- base::`<<-`
[16:03:21.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:21.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:21.811]                   3L)]
[16:03:21.811]             }
[16:03:21.811]             function(cond) {
[16:03:21.811]                 is_error <- inherits(cond, "error")
[16:03:21.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:21.811]                   NULL)
[16:03:21.811]                 if (is_error) {
[16:03:21.811]                   sessionInformation <- function() {
[16:03:21.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:21.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:21.811]                       search = base::search(), system = base::Sys.info())
[16:03:21.811]                   }
[16:03:21.811]                   ...future.conditions[[length(...future.conditions) + 
[16:03:21.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:21.811]                     cond$call), session = sessionInformation(), 
[16:03:21.811]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:21.811]                   signalCondition(cond)
[16:03:21.811]                 }
[16:03:21.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:21.811]                 "immediateCondition"))) {
[16:03:21.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:21.811]                   ...future.conditions[[length(...future.conditions) + 
[16:03:21.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:21.811]                   if (TRUE && !signal) {
[16:03:21.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.811]                     {
[16:03:21.811]                       inherits <- base::inherits
[16:03:21.811]                       invokeRestart <- base::invokeRestart
[16:03:21.811]                       is.null <- base::is.null
[16:03:21.811]                       muffled <- FALSE
[16:03:21.811]                       if (inherits(cond, "message")) {
[16:03:21.811]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:21.811]                         if (muffled) 
[16:03:21.811]                           invokeRestart("muffleMessage")
[16:03:21.811]                       }
[16:03:21.811]                       else if (inherits(cond, "warning")) {
[16:03:21.811]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:21.811]                         if (muffled) 
[16:03:21.811]                           invokeRestart("muffleWarning")
[16:03:21.811]                       }
[16:03:21.811]                       else if (inherits(cond, "condition")) {
[16:03:21.811]                         if (!is.null(pattern)) {
[16:03:21.811]                           computeRestarts <- base::computeRestarts
[16:03:21.811]                           grepl <- base::grepl
[16:03:21.811]                           restarts <- computeRestarts(cond)
[16:03:21.811]                           for (restart in restarts) {
[16:03:21.811]                             name <- restart$name
[16:03:21.811]                             if (is.null(name)) 
[16:03:21.811]                               next
[16:03:21.811]                             if (!grepl(pattern, name)) 
[16:03:21.811]                               next
[16:03:21.811]                             invokeRestart(restart)
[16:03:21.811]                             muffled <- TRUE
[16:03:21.811]                             break
[16:03:21.811]                           }
[16:03:21.811]                         }
[16:03:21.811]                       }
[16:03:21.811]                       invisible(muffled)
[16:03:21.811]                     }
[16:03:21.811]                     muffleCondition(cond, pattern = "^muffle")
[16:03:21.811]                   }
[16:03:21.811]                 }
[16:03:21.811]                 else {
[16:03:21.811]                   if (TRUE) {
[16:03:21.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:21.811]                     {
[16:03:21.811]                       inherits <- base::inherits
[16:03:21.811]                       invokeRestart <- base::invokeRestart
[16:03:21.811]                       is.null <- base::is.null
[16:03:21.811]                       muffled <- FALSE
[16:03:21.811]                       if (inherits(cond, "message")) {
[16:03:21.811]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:21.811]                         if (muffled) 
[16:03:21.811]                           invokeRestart("muffleMessage")
[16:03:21.811]                       }
[16:03:21.811]                       else if (inherits(cond, "warning")) {
[16:03:21.811]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:21.811]                         if (muffled) 
[16:03:21.811]                           invokeRestart("muffleWarning")
[16:03:21.811]                       }
[16:03:21.811]                       else if (inherits(cond, "condition")) {
[16:03:21.811]                         if (!is.null(pattern)) {
[16:03:21.811]                           computeRestarts <- base::computeRestarts
[16:03:21.811]                           grepl <- base::grepl
[16:03:21.811]                           restarts <- computeRestarts(cond)
[16:03:21.811]                           for (restart in restarts) {
[16:03:21.811]                             name <- restart$name
[16:03:21.811]                             if (is.null(name)) 
[16:03:21.811]                               next
[16:03:21.811]                             if (!grepl(pattern, name)) 
[16:03:21.811]                               next
[16:03:21.811]                             invokeRestart(restart)
[16:03:21.811]                             muffled <- TRUE
[16:03:21.811]                             break
[16:03:21.811]                           }
[16:03:21.811]                         }
[16:03:21.811]                       }
[16:03:21.811]                       invisible(muffled)
[16:03:21.811]                     }
[16:03:21.811]                     muffleCondition(cond, pattern = "^muffle")
[16:03:21.811]                   }
[16:03:21.811]                 }
[16:03:21.811]             }
[16:03:21.811]         }))
[16:03:21.811]     }, error = function(ex) {
[16:03:21.811]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:21.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:21.811]                 ...future.rng), started = ...future.startTime, 
[16:03:21.811]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:21.811]             version = "1.8"), class = "FutureResult")
[16:03:21.811]     }, finally = {
[16:03:21.811]         if (!identical(...future.workdir, getwd())) 
[16:03:21.811]             setwd(...future.workdir)
[16:03:21.811]         {
[16:03:21.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:21.811]                 ...future.oldOptions$nwarnings <- NULL
[16:03:21.811]             }
[16:03:21.811]             base::options(...future.oldOptions)
[16:03:21.811]             if (.Platform$OS.type == "windows") {
[16:03:21.811]                 old_names <- names(...future.oldEnvVars)
[16:03:21.811]                 envs <- base::Sys.getenv()
[16:03:21.811]                 names <- names(envs)
[16:03:21.811]                 common <- intersect(names, old_names)
[16:03:21.811]                 added <- setdiff(names, old_names)
[16:03:21.811]                 removed <- setdiff(old_names, names)
[16:03:21.811]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:21.811]                   envs[common]]
[16:03:21.811]                 NAMES <- toupper(changed)
[16:03:21.811]                 args <- list()
[16:03:21.811]                 for (kk in seq_along(NAMES)) {
[16:03:21.811]                   name <- changed[[kk]]
[16:03:21.811]                   NAME <- NAMES[[kk]]
[16:03:21.811]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.811]                     next
[16:03:21.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:21.811]                 }
[16:03:21.811]                 NAMES <- toupper(added)
[16:03:21.811]                 for (kk in seq_along(NAMES)) {
[16:03:21.811]                   name <- added[[kk]]
[16:03:21.811]                   NAME <- NAMES[[kk]]
[16:03:21.811]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.811]                     next
[16:03:21.811]                   args[[name]] <- ""
[16:03:21.811]                 }
[16:03:21.811]                 NAMES <- toupper(removed)
[16:03:21.811]                 for (kk in seq_along(NAMES)) {
[16:03:21.811]                   name <- removed[[kk]]
[16:03:21.811]                   NAME <- NAMES[[kk]]
[16:03:21.811]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:21.811]                     next
[16:03:21.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:21.811]                 }
[16:03:21.811]                 if (length(args) > 0) 
[16:03:21.811]                   base::do.call(base::Sys.setenv, args = args)
[16:03:21.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:21.811]             }
[16:03:21.811]             else {
[16:03:21.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:21.811]             }
[16:03:21.811]             {
[16:03:21.811]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:21.811]                   0L) {
[16:03:21.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:21.811]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:21.811]                   base::options(opts)
[16:03:21.811]                 }
[16:03:21.811]                 {
[16:03:21.811]                   {
[16:03:21.811]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:21.811]                     NULL
[16:03:21.811]                   }
[16:03:21.811]                   options(future.plan = NULL)
[16:03:21.811]                   if (is.na(NA_character_)) 
[16:03:21.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:21.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:21.811]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:21.811]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:21.811]                     envir = parent.frame()) 
[16:03:21.811]                   {
[16:03:21.811]                     if (is.function(workers)) 
[16:03:21.811]                       workers <- workers()
[16:03:21.811]                     workers <- structure(as.integer(workers), 
[16:03:21.811]                       class = class(workers))
[16:03:21.811]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:21.811]                       workers >= 1)
[16:03:21.811]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:21.811]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:21.811]                     }
[16:03:21.811]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:21.811]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:21.811]                       envir = envir)
[16:03:21.811]                     if (!future$lazy) 
[16:03:21.811]                       future <- run(future)
[16:03:21.811]                     invisible(future)
[16:03:21.811]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:21.811]                 }
[16:03:21.811]             }
[16:03:21.811]         }
[16:03:21.811]     })
[16:03:21.811]     if (TRUE) {
[16:03:21.811]         base::sink(type = "output", split = FALSE)
[16:03:21.811]         if (TRUE) {
[16:03:21.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:21.811]         }
[16:03:21.811]         else {
[16:03:21.811]             ...future.result["stdout"] <- base::list(NULL)
[16:03:21.811]         }
[16:03:21.811]         base::close(...future.stdout)
[16:03:21.811]         ...future.stdout <- NULL
[16:03:21.811]     }
[16:03:21.811]     ...future.result$conditions <- ...future.conditions
[16:03:21.811]     ...future.result$finished <- base::Sys.time()
[16:03:21.811]     ...future.result
[16:03:21.811] }
[16:03:21.814] Exporting 11 global objects (92.05 KiB) to cluster node #2 ...
[16:03:21.814] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:21.855] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:21.855] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[16:03:21.856] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[16:03:21.856] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:21.856] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:21.856] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:21.899] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:21.899] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:21.943] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:21.943] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:03:21.944] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:03:21.944] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[16:03:21.944] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[16:03:21.945] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:21.945] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:21.945] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:03:21.945] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:03:21.946] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:21.946] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:21.946] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:21.946] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:21.947] Exporting 11 global objects (92.05 KiB) to cluster node #2 ... DONE
[16:03:21.947] MultisessionFuture started
[16:03:21.947] - Launch lazy future ... done
[16:03:21.948] run() for ‘MultisessionFuture’ ... done
[16:03:21.948] Created future:
[16:03:21.948] MultisessionFuture:
[16:03:21.948] Label: ‘future_vapply-2’
[16:03:21.948] Expression:
[16:03:21.948] {
[16:03:21.948]     do.call(function(...) {
[16:03:21.948]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:21.948]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:21.948]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:21.948]             on.exit(options(oopts), add = TRUE)
[16:03:21.948]         }
[16:03:21.948]         {
[16:03:21.948]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:21.948]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:21.948]                 ...future.FUN(...future.X_jj, ...)
[16:03:21.948]             })
[16:03:21.948]         }
[16:03:21.948]     }, args = future.call.arguments)
[16:03:21.948] }
[16:03:21.948] Lazy evaluation: FALSE
[16:03:21.948] Asynchronous evaluation: TRUE
[16:03:21.948] Local evaluation: TRUE
[16:03:21.948] Environment: R_GlobalEnv
[16:03:21.948] Capture standard output: TRUE
[16:03:21.948] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:21.948] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:21.948] Packages: 1 packages (‘future.apply’)
[16:03:21.948] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:21.948] Resolved: FALSE
[16:03:21.948] Value: <not collected>
[16:03:21.948] Conditions captured: <none>
[16:03:21.948] Early signaling: FALSE
[16:03:21.948] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:21.948] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:21.960] Chunk #2 of 2 ... DONE
[16:03:21.960] Launching 2 futures (chunks) ... DONE
[16:03:21.960] Resolving 2 futures (chunks) ...
[16:03:21.960] resolve() on list ...
[16:03:21.960]  recursive: 0
[16:03:21.960]  length: 2
[16:03:21.960] 
[16:03:21.961] receiveMessageFromWorker() for ClusterFuture ...
[16:03:21.961] - Validating connection of MultisessionFuture
[16:03:21.961] - received message: FutureResult
[16:03:21.961] - Received FutureResult
[16:03:21.961] - Erased future from FutureRegistry
[16:03:21.961] result() for ClusterFuture ...
[16:03:21.961] - result already collected: FutureResult
[16:03:21.961] result() for ClusterFuture ... done
[16:03:21.962] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:21.962] Future #1
[16:03:21.962] result() for ClusterFuture ...
[16:03:21.962] - result already collected: FutureResult
[16:03:21.962] result() for ClusterFuture ... done
[16:03:21.962] result() for ClusterFuture ...
[16:03:21.962] - result already collected: FutureResult
[16:03:21.962] result() for ClusterFuture ... done
[16:03:21.962] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:21.962] - nx: 2
[16:03:21.962] - relay: TRUE
[16:03:21.963] - stdout: TRUE
[16:03:21.963] - signal: TRUE
[16:03:21.963] - resignal: FALSE
[16:03:21.963] - force: TRUE
[16:03:21.963] - relayed: [n=2] FALSE, FALSE
[16:03:21.963] - queued futures: [n=2] FALSE, FALSE
[16:03:21.963]  - until=1
[16:03:21.963]  - relaying element #1
[16:03:21.963] result() for ClusterFuture ...
[16:03:21.963] - result already collected: FutureResult
[16:03:21.964] result() for ClusterFuture ... done
[16:03:21.964] result() for ClusterFuture ...
[16:03:21.964] - result already collected: FutureResult
[16:03:21.964] result() for ClusterFuture ... done
[16:03:21.964] result() for ClusterFuture ...
[16:03:21.964] - result already collected: FutureResult
[16:03:21.964] result() for ClusterFuture ... done
[16:03:21.964] result() for ClusterFuture ...
[16:03:21.964] - result already collected: FutureResult
[16:03:21.964] result() for ClusterFuture ... done
[16:03:21.964] - relayed: [n=2] TRUE, FALSE
[16:03:21.965] - queued futures: [n=2] TRUE, FALSE
[16:03:21.965] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:21.965]  length: 1 (resolved future 1)
[16:03:22.006] receiveMessageFromWorker() for ClusterFuture ...
[16:03:22.007] - Validating connection of MultisessionFuture
[16:03:22.007] - received message: FutureResult
[16:03:22.007] - Received FutureResult
[16:03:22.007] - Erased future from FutureRegistry
[16:03:22.007] result() for ClusterFuture ...
[16:03:22.007] - result already collected: FutureResult
[16:03:22.007] result() for ClusterFuture ... done
[16:03:22.008] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:22.008] Future #2
[16:03:22.008] result() for ClusterFuture ...
[16:03:22.008] - result already collected: FutureResult
[16:03:22.008] result() for ClusterFuture ... done
[16:03:22.008] result() for ClusterFuture ...
[16:03:22.008] - result already collected: FutureResult
[16:03:22.008] result() for ClusterFuture ... done
[16:03:22.008] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:22.008] - nx: 2
[16:03:22.008] - relay: TRUE
[16:03:22.009] - stdout: TRUE
[16:03:22.009] - signal: TRUE
[16:03:22.009] - resignal: FALSE
[16:03:22.009] - force: TRUE
[16:03:22.009] - relayed: [n=2] TRUE, FALSE
[16:03:22.009] - queued futures: [n=2] TRUE, FALSE
[16:03:22.009]  - until=2
[16:03:22.009]  - relaying element #2
[16:03:22.009] result() for ClusterFuture ...
[16:03:22.009] - result already collected: FutureResult
[16:03:22.009] result() for ClusterFuture ... done
[16:03:22.010] result() for ClusterFuture ...
[16:03:22.010] - result already collected: FutureResult
[16:03:22.010] result() for ClusterFuture ... done
[16:03:22.010] result() for ClusterFuture ...
[16:03:22.010] - result already collected: FutureResult
[16:03:22.010] result() for ClusterFuture ... done
[16:03:22.010] result() for ClusterFuture ...
[16:03:22.010] - result already collected: FutureResult
[16:03:22.010] result() for ClusterFuture ... done
[16:03:22.010] - relayed: [n=2] TRUE, TRUE
[16:03:22.010] - queued futures: [n=2] TRUE, TRUE
[16:03:22.010] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:03:22.011]  length: 0 (resolved future 2)
[16:03:22.011] Relaying remaining futures
[16:03:22.011] signalConditionsASAP(NULL, pos=0) ...
[16:03:22.011] - nx: 2
[16:03:22.011] - relay: TRUE
[16:03:22.011] - stdout: TRUE
[16:03:22.011] - signal: TRUE
[16:03:22.011] - resignal: FALSE
[16:03:22.011] - force: TRUE
[16:03:22.011] - relayed: [n=2] TRUE, TRUE
[16:03:22.011] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:22.012] - relayed: [n=2] TRUE, TRUE
[16:03:22.012] - queued futures: [n=2] TRUE, TRUE
[16:03:22.012] signalConditionsASAP(NULL, pos=0) ... done
[16:03:22.012] resolve() on list ... DONE
[16:03:22.012] result() for ClusterFuture ...
[16:03:22.012] - result already collected: FutureResult
[16:03:22.012] result() for ClusterFuture ... done
[16:03:22.012] result() for ClusterFuture ...
[16:03:22.012] - result already collected: FutureResult
[16:03:22.012] result() for ClusterFuture ... done
[16:03:22.013] result() for ClusterFuture ...
[16:03:22.013] - result already collected: FutureResult
[16:03:22.013] result() for ClusterFuture ... done
[16:03:22.013] result() for ClusterFuture ...
[16:03:22.013] - result already collected: FutureResult
[16:03:22.013] result() for ClusterFuture ... done
[16:03:22.013]  - Number of value chunks collected: 2
[16:03:22.013] Resolving 2 futures (chunks) ... DONE
[16:03:22.013] Reducing values from 2 chunks ...
[16:03:22.013]  - Number of values collected after concatenation: 3
[16:03:22.013]  - Number of values expected: 3
[16:03:22.014] Reducing values from 2 chunks ... DONE
[16:03:22.014] future_lapply() ... DONE
- exceptions ...
[16:03:22.014] future_lapply() ...
[16:03:22.019] Number of chunks: 2
[16:03:22.019] getGlobalsAndPackagesXApply() ...
[16:03:22.019]  - future.globals: TRUE
[16:03:22.020] getGlobalsAndPackages() ...
[16:03:22.020] Searching for globals...
[16:03:22.023] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:03:22.023] Searching for globals ... DONE
[16:03:22.023] Resolving globals: FALSE
[16:03:22.024] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[16:03:22.025] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:03:22.025] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:22.025] - packages: [1] ‘future.apply’
[16:03:22.025] getGlobalsAndPackages() ... DONE
[16:03:22.025]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:03:22.025]  - needed namespaces: [n=1] ‘future.apply’
[16:03:22.025] Finding globals ... DONE
[16:03:22.025]  - use_args: TRUE
[16:03:22.025]  - Getting '...' globals ...
[16:03:22.026] resolve() on list ...
[16:03:22.026]  recursive: 0
[16:03:22.026]  length: 1
[16:03:22.026]  elements: ‘...’
[16:03:22.026]  length: 0 (resolved future 1)
[16:03:22.026] resolve() on list ... DONE
[16:03:22.026]    - '...' content: [n=0] 
[16:03:22.026] List of 1
[16:03:22.026]  $ ...: list()
[16:03:22.026]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:22.026]  - attr(*, "where")=List of 1
[16:03:22.026]   ..$ ...:<environment: 0x564e43465248> 
[16:03:22.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:22.026]  - attr(*, "resolved")= logi TRUE
[16:03:22.026]  - attr(*, "total_size")= num NA
[16:03:22.029]  - Getting '...' globals ... DONE
[16:03:22.029] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:03:22.029] List of 8
[16:03:22.029]  $ ...future.FUN:function (x, ...)  
[16:03:22.029]  $ x_FUN        :function (x)  
[16:03:22.029]  $ times        : int 2
[16:03:22.029]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:03:22.029]  $ stop_if_not  :function (...)  
[16:03:22.029]  $ dim          : NULL
[16:03:22.029]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:03:22.029]  $ ...          : list()
[16:03:22.029]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:22.029]  - attr(*, "where")=List of 8
[16:03:22.029]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:22.029]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:03:22.029]   ..$ times        :<environment: R_EmptyEnv> 
[16:03:22.029]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:03:22.029]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:03:22.029]   ..$ dim          :<environment: R_EmptyEnv> 
[16:03:22.029]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:03:22.029]   ..$ ...          :<environment: 0x564e43465248> 
[16:03:22.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:22.029]  - attr(*, "resolved")= logi FALSE
[16:03:22.029]  - attr(*, "total_size")= num 95128
[16:03:22.035] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:03:22.035] getGlobalsAndPackagesXApply() ... DONE
[16:03:22.035] Number of futures (= number of chunks): 2
[16:03:22.035] Launching 2 futures (chunks) ...
[16:03:22.035] Chunk #1 of 2 ...
[16:03:22.035]  - Finding globals in 'X' for chunk #1 ...
[16:03:22.035] getGlobalsAndPackages() ...
[16:03:22.036] Searching for globals...
[16:03:22.036] 
[16:03:22.036] Searching for globals ... DONE
[16:03:22.036] - globals: [0] <none>
[16:03:22.036] getGlobalsAndPackages() ... DONE
[16:03:22.036]    + additional globals found: [n=0] 
[16:03:22.036]    + additional namespaces needed: [n=0] 
[16:03:22.036]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:22.036]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:22.036]  - seeds: <none>
[16:03:22.037]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:22.037] getGlobalsAndPackages() ...
[16:03:22.037] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:22.037] Resolving globals: FALSE
[16:03:22.037] Tweak future expression to call with '...' arguments ...
[16:03:22.037] {
[16:03:22.037]     do.call(function(...) {
[16:03:22.037]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:22.037]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:22.037]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:22.037]             on.exit(options(oopts), add = TRUE)
[16:03:22.037]         }
[16:03:22.037]         {
[16:03:22.037]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:22.037]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:22.037]                 ...future.FUN(...future.X_jj, ...)
[16:03:22.037]             })
[16:03:22.037]         }
[16:03:22.037]     }, args = future.call.arguments)
[16:03:22.037] }
[16:03:22.037] Tweak future expression to call with '...' arguments ... DONE
[16:03:22.038] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:22.038] - packages: [1] ‘future.apply’
[16:03:22.038] getGlobalsAndPackages() ... DONE
[16:03:22.038] run() for ‘Future’ ...
[16:03:22.039] - state: ‘created’
[16:03:22.039] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:22.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:22.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:22.053]   - Field: ‘node’
[16:03:22.053]   - Field: ‘label’
[16:03:22.053]   - Field: ‘local’
[16:03:22.053]   - Field: ‘owner’
[16:03:22.053]   - Field: ‘envir’
[16:03:22.053]   - Field: ‘workers’
[16:03:22.053]   - Field: ‘packages’
[16:03:22.053]   - Field: ‘gc’
[16:03:22.053]   - Field: ‘conditions’
[16:03:22.053]   - Field: ‘persistent’
[16:03:22.054]   - Field: ‘expr’
[16:03:22.054]   - Field: ‘uuid’
[16:03:22.054]   - Field: ‘seed’
[16:03:22.054]   - Field: ‘version’
[16:03:22.054]   - Field: ‘result’
[16:03:22.054]   - Field: ‘asynchronous’
[16:03:22.054]   - Field: ‘calls’
[16:03:22.054]   - Field: ‘globals’
[16:03:22.054]   - Field: ‘stdout’
[16:03:22.054]   - Field: ‘earlySignal’
[16:03:22.054]   - Field: ‘lazy’
[16:03:22.055]   - Field: ‘state’
[16:03:22.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:22.055] - Launch lazy future ...
[16:03:22.055] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:22.055] Packages needed by future strategies (n = 0): <none>
[16:03:22.056] {
[16:03:22.056]     {
[16:03:22.056]         {
[16:03:22.056]             ...future.startTime <- base::Sys.time()
[16:03:22.056]             {
[16:03:22.056]                 {
[16:03:22.056]                   {
[16:03:22.056]                     {
[16:03:22.056]                       {
[16:03:22.056]                         base::local({
[16:03:22.056]                           has_future <- base::requireNamespace("future", 
[16:03:22.056]                             quietly = TRUE)
[16:03:22.056]                           if (has_future) {
[16:03:22.056]                             ns <- base::getNamespace("future")
[16:03:22.056]                             version <- ns[[".package"]][["version"]]
[16:03:22.056]                             if (is.null(version)) 
[16:03:22.056]                               version <- utils::packageVersion("future")
[16:03:22.056]                           }
[16:03:22.056]                           else {
[16:03:22.056]                             version <- NULL
[16:03:22.056]                           }
[16:03:22.056]                           if (!has_future || version < "1.8.0") {
[16:03:22.056]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:22.056]                               "", base::R.version$version.string), 
[16:03:22.056]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:22.056]                                 base::R.version$platform, 8 * 
[16:03:22.056]                                   base::.Machine$sizeof.pointer), 
[16:03:22.056]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:22.056]                                 "release", "version")], collapse = " "), 
[16:03:22.056]                               hostname = base::Sys.info()[["nodename"]])
[16:03:22.056]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:22.056]                               info)
[16:03:22.056]                             info <- base::paste(info, collapse = "; ")
[16:03:22.056]                             if (!has_future) {
[16:03:22.056]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:22.056]                                 info)
[16:03:22.056]                             }
[16:03:22.056]                             else {
[16:03:22.056]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:22.056]                                 info, version)
[16:03:22.056]                             }
[16:03:22.056]                             base::stop(msg)
[16:03:22.056]                           }
[16:03:22.056]                         })
[16:03:22.056]                       }
[16:03:22.056]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:22.056]                       base::options(mc.cores = 1L)
[16:03:22.056]                     }
[16:03:22.056]                     base::local({
[16:03:22.056]                       for (pkg in "future.apply") {
[16:03:22.056]                         base::loadNamespace(pkg)
[16:03:22.056]                         base::library(pkg, character.only = TRUE)
[16:03:22.056]                       }
[16:03:22.056]                     })
[16:03:22.056]                   }
[16:03:22.056]                   options(future.plan = NULL)
[16:03:22.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:22.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:22.056]                 }
[16:03:22.056]                 ...future.workdir <- getwd()
[16:03:22.056]             }
[16:03:22.056]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:22.056]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:22.056]         }
[16:03:22.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:22.056]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:22.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:22.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:22.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:22.056]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:22.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:22.056]             base::names(...future.oldOptions))
[16:03:22.056]     }
[16:03:22.056]     if (FALSE) {
[16:03:22.056]     }
[16:03:22.056]     else {
[16:03:22.056]         if (TRUE) {
[16:03:22.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:22.056]                 open = "w")
[16:03:22.056]         }
[16:03:22.056]         else {
[16:03:22.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:22.056]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:22.056]         }
[16:03:22.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:22.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:22.056]             base::sink(type = "output", split = FALSE)
[16:03:22.056]             base::close(...future.stdout)
[16:03:22.056]         }, add = TRUE)
[16:03:22.056]     }
[16:03:22.056]     ...future.frame <- base::sys.nframe()
[16:03:22.056]     ...future.conditions <- base::list()
[16:03:22.056]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:22.056]     if (FALSE) {
[16:03:22.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:22.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:22.056]     }
[16:03:22.056]     ...future.result <- base::tryCatch({
[16:03:22.056]         base::withCallingHandlers({
[16:03:22.056]             ...future.value <- base::withVisible(base::local({
[16:03:22.056]                 ...future.makeSendCondition <- base::local({
[16:03:22.056]                   sendCondition <- NULL
[16:03:22.056]                   function(frame = 1L) {
[16:03:22.056]                     if (is.function(sendCondition)) 
[16:03:22.056]                       return(sendCondition)
[16:03:22.056]                     ns <- getNamespace("parallel")
[16:03:22.056]                     if (exists("sendData", mode = "function", 
[16:03:22.056]                       envir = ns)) {
[16:03:22.056]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:22.056]                         envir = ns)
[16:03:22.056]                       envir <- sys.frame(frame)
[16:03:22.056]                       master <- NULL
[16:03:22.056]                       while (!identical(envir, .GlobalEnv) && 
[16:03:22.056]                         !identical(envir, emptyenv())) {
[16:03:22.056]                         if (exists("master", mode = "list", envir = envir, 
[16:03:22.056]                           inherits = FALSE)) {
[16:03:22.056]                           master <- get("master", mode = "list", 
[16:03:22.056]                             envir = envir, inherits = FALSE)
[16:03:22.056]                           if (inherits(master, c("SOCKnode", 
[16:03:22.056]                             "SOCK0node"))) {
[16:03:22.056]                             sendCondition <<- function(cond) {
[16:03:22.056]                               data <- list(type = "VALUE", value = cond, 
[16:03:22.056]                                 success = TRUE)
[16:03:22.056]                               parallel_sendData(master, data)
[16:03:22.056]                             }
[16:03:22.056]                             return(sendCondition)
[16:03:22.056]                           }
[16:03:22.056]                         }
[16:03:22.056]                         frame <- frame + 1L
[16:03:22.056]                         envir <- sys.frame(frame)
[16:03:22.056]                       }
[16:03:22.056]                     }
[16:03:22.056]                     sendCondition <<- function(cond) NULL
[16:03:22.056]                   }
[16:03:22.056]                 })
[16:03:22.056]                 withCallingHandlers({
[16:03:22.056]                   {
[16:03:22.056]                     do.call(function(...) {
[16:03:22.056]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:22.056]                       if (!identical(...future.globals.maxSize.org, 
[16:03:22.056]                         ...future.globals.maxSize)) {
[16:03:22.056]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:22.056]                         on.exit(options(oopts), add = TRUE)
[16:03:22.056]                       }
[16:03:22.056]                       {
[16:03:22.056]                         lapply(seq_along(...future.elements_ii), 
[16:03:22.056]                           FUN = function(jj) {
[16:03:22.056]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:22.056]                             ...future.FUN(...future.X_jj, ...)
[16:03:22.056]                           })
[16:03:22.056]                       }
[16:03:22.056]                     }, args = future.call.arguments)
[16:03:22.056]                   }
[16:03:22.056]                 }, immediateCondition = function(cond) {
[16:03:22.056]                   sendCondition <- ...future.makeSendCondition()
[16:03:22.056]                   sendCondition(cond)
[16:03:22.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:22.056]                   {
[16:03:22.056]                     inherits <- base::inherits
[16:03:22.056]                     invokeRestart <- base::invokeRestart
[16:03:22.056]                     is.null <- base::is.null
[16:03:22.056]                     muffled <- FALSE
[16:03:22.056]                     if (inherits(cond, "message")) {
[16:03:22.056]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:22.056]                       if (muffled) 
[16:03:22.056]                         invokeRestart("muffleMessage")
[16:03:22.056]                     }
[16:03:22.056]                     else if (inherits(cond, "warning")) {
[16:03:22.056]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:22.056]                       if (muffled) 
[16:03:22.056]                         invokeRestart("muffleWarning")
[16:03:22.056]                     }
[16:03:22.056]                     else if (inherits(cond, "condition")) {
[16:03:22.056]                       if (!is.null(pattern)) {
[16:03:22.056]                         computeRestarts <- base::computeRestarts
[16:03:22.056]                         grepl <- base::grepl
[16:03:22.056]                         restarts <- computeRestarts(cond)
[16:03:22.056]                         for (restart in restarts) {
[16:03:22.056]                           name <- restart$name
[16:03:22.056]                           if (is.null(name)) 
[16:03:22.056]                             next
[16:03:22.056]                           if (!grepl(pattern, name)) 
[16:03:22.056]                             next
[16:03:22.056]                           invokeRestart(restart)
[16:03:22.056]                           muffled <- TRUE
[16:03:22.056]                           break
[16:03:22.056]                         }
[16:03:22.056]                       }
[16:03:22.056]                     }
[16:03:22.056]                     invisible(muffled)
[16:03:22.056]                   }
[16:03:22.056]                   muffleCondition(cond)
[16:03:22.056]                 })
[16:03:22.056]             }))
[16:03:22.056]             future::FutureResult(value = ...future.value$value, 
[16:03:22.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:22.056]                   ...future.rng), globalenv = if (FALSE) 
[16:03:22.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:22.056]                     ...future.globalenv.names))
[16:03:22.056]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:22.056]         }, condition = base::local({
[16:03:22.056]             c <- base::c
[16:03:22.056]             inherits <- base::inherits
[16:03:22.056]             invokeRestart <- base::invokeRestart
[16:03:22.056]             length <- base::length
[16:03:22.056]             list <- base::list
[16:03:22.056]             seq.int <- base::seq.int
[16:03:22.056]             signalCondition <- base::signalCondition
[16:03:22.056]             sys.calls <- base::sys.calls
[16:03:22.056]             `[[` <- base::`[[`
[16:03:22.056]             `+` <- base::`+`
[16:03:22.056]             `<<-` <- base::`<<-`
[16:03:22.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:22.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:22.056]                   3L)]
[16:03:22.056]             }
[16:03:22.056]             function(cond) {
[16:03:22.056]                 is_error <- inherits(cond, "error")
[16:03:22.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:22.056]                   NULL)
[16:03:22.056]                 if (is_error) {
[16:03:22.056]                   sessionInformation <- function() {
[16:03:22.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:22.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:22.056]                       search = base::search(), system = base::Sys.info())
[16:03:22.056]                   }
[16:03:22.056]                   ...future.conditions[[length(...future.conditions) + 
[16:03:22.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:22.056]                     cond$call), session = sessionInformation(), 
[16:03:22.056]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:22.056]                   signalCondition(cond)
[16:03:22.056]                 }
[16:03:22.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:22.056]                 "immediateCondition"))) {
[16:03:22.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:22.056]                   ...future.conditions[[length(...future.conditions) + 
[16:03:22.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:22.056]                   if (TRUE && !signal) {
[16:03:22.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:22.056]                     {
[16:03:22.056]                       inherits <- base::inherits
[16:03:22.056]                       invokeRestart <- base::invokeRestart
[16:03:22.056]                       is.null <- base::is.null
[16:03:22.056]                       muffled <- FALSE
[16:03:22.056]                       if (inherits(cond, "message")) {
[16:03:22.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:22.056]                         if (muffled) 
[16:03:22.056]                           invokeRestart("muffleMessage")
[16:03:22.056]                       }
[16:03:22.056]                       else if (inherits(cond, "warning")) {
[16:03:22.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:22.056]                         if (muffled) 
[16:03:22.056]                           invokeRestart("muffleWarning")
[16:03:22.056]                       }
[16:03:22.056]                       else if (inherits(cond, "condition")) {
[16:03:22.056]                         if (!is.null(pattern)) {
[16:03:22.056]                           computeRestarts <- base::computeRestarts
[16:03:22.056]                           grepl <- base::grepl
[16:03:22.056]                           restarts <- computeRestarts(cond)
[16:03:22.056]                           for (restart in restarts) {
[16:03:22.056]                             name <- restart$name
[16:03:22.056]                             if (is.null(name)) 
[16:03:22.056]                               next
[16:03:22.056]                             if (!grepl(pattern, name)) 
[16:03:22.056]                               next
[16:03:22.056]                             invokeRestart(restart)
[16:03:22.056]                             muffled <- TRUE
[16:03:22.056]                             break
[16:03:22.056]                           }
[16:03:22.056]                         }
[16:03:22.056]                       }
[16:03:22.056]                       invisible(muffled)
[16:03:22.056]                     }
[16:03:22.056]                     muffleCondition(cond, pattern = "^muffle")
[16:03:22.056]                   }
[16:03:22.056]                 }
[16:03:22.056]                 else {
[16:03:22.056]                   if (TRUE) {
[16:03:22.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:22.056]                     {
[16:03:22.056]                       inherits <- base::inherits
[16:03:22.056]                       invokeRestart <- base::invokeRestart
[16:03:22.056]                       is.null <- base::is.null
[16:03:22.056]                       muffled <- FALSE
[16:03:22.056]                       if (inherits(cond, "message")) {
[16:03:22.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:22.056]                         if (muffled) 
[16:03:22.056]                           invokeRestart("muffleMessage")
[16:03:22.056]                       }
[16:03:22.056]                       else if (inherits(cond, "warning")) {
[16:03:22.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:22.056]                         if (muffled) 
[16:03:22.056]                           invokeRestart("muffleWarning")
[16:03:22.056]                       }
[16:03:22.056]                       else if (inherits(cond, "condition")) {
[16:03:22.056]                         if (!is.null(pattern)) {
[16:03:22.056]                           computeRestarts <- base::computeRestarts
[16:03:22.056]                           grepl <- base::grepl
[16:03:22.056]                           restarts <- computeRestarts(cond)
[16:03:22.056]                           for (restart in restarts) {
[16:03:22.056]                             name <- restart$name
[16:03:22.056]                             if (is.null(name)) 
[16:03:22.056]                               next
[16:03:22.056]                             if (!grepl(pattern, name)) 
[16:03:22.056]                               next
[16:03:22.056]                             invokeRestart(restart)
[16:03:22.056]                             muffled <- TRUE
[16:03:22.056]                             break
[16:03:22.056]                           }
[16:03:22.056]                         }
[16:03:22.056]                       }
[16:03:22.056]                       invisible(muffled)
[16:03:22.056]                     }
[16:03:22.056]                     muffleCondition(cond, pattern = "^muffle")
[16:03:22.056]                   }
[16:03:22.056]                 }
[16:03:22.056]             }
[16:03:22.056]         }))
[16:03:22.056]     }, error = function(ex) {
[16:03:22.056]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:22.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:22.056]                 ...future.rng), started = ...future.startTime, 
[16:03:22.056]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:22.056]             version = "1.8"), class = "FutureResult")
[16:03:22.056]     }, finally = {
[16:03:22.056]         if (!identical(...future.workdir, getwd())) 
[16:03:22.056]             setwd(...future.workdir)
[16:03:22.056]         {
[16:03:22.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:22.056]                 ...future.oldOptions$nwarnings <- NULL
[16:03:22.056]             }
[16:03:22.056]             base::options(...future.oldOptions)
[16:03:22.056]             if (.Platform$OS.type == "windows") {
[16:03:22.056]                 old_names <- names(...future.oldEnvVars)
[16:03:22.056]                 envs <- base::Sys.getenv()
[16:03:22.056]                 names <- names(envs)
[16:03:22.056]                 common <- intersect(names, old_names)
[16:03:22.056]                 added <- setdiff(names, old_names)
[16:03:22.056]                 removed <- setdiff(old_names, names)
[16:03:22.056]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:22.056]                   envs[common]]
[16:03:22.056]                 NAMES <- toupper(changed)
[16:03:22.056]                 args <- list()
[16:03:22.056]                 for (kk in seq_along(NAMES)) {
[16:03:22.056]                   name <- changed[[kk]]
[16:03:22.056]                   NAME <- NAMES[[kk]]
[16:03:22.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:22.056]                     next
[16:03:22.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:22.056]                 }
[16:03:22.056]                 NAMES <- toupper(added)
[16:03:22.056]                 for (kk in seq_along(NAMES)) {
[16:03:22.056]                   name <- added[[kk]]
[16:03:22.056]                   NAME <- NAMES[[kk]]
[16:03:22.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:22.056]                     next
[16:03:22.056]                   args[[name]] <- ""
[16:03:22.056]                 }
[16:03:22.056]                 NAMES <- toupper(removed)
[16:03:22.056]                 for (kk in seq_along(NAMES)) {
[16:03:22.056]                   name <- removed[[kk]]
[16:03:22.056]                   NAME <- NAMES[[kk]]
[16:03:22.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:22.056]                     next
[16:03:22.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:22.056]                 }
[16:03:22.056]                 if (length(args) > 0) 
[16:03:22.056]                   base::do.call(base::Sys.setenv, args = args)
[16:03:22.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:22.056]             }
[16:03:22.056]             else {
[16:03:22.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:22.056]             }
[16:03:22.056]             {
[16:03:22.056]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:22.056]                   0L) {
[16:03:22.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:22.056]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:22.056]                   base::options(opts)
[16:03:22.056]                 }
[16:03:22.056]                 {
[16:03:22.056]                   {
[16:03:22.056]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:22.056]                     NULL
[16:03:22.056]                   }
[16:03:22.056]                   options(future.plan = NULL)
[16:03:22.056]                   if (is.na(NA_character_)) 
[16:03:22.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:22.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:22.056]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:22.056]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:22.056]                     envir = parent.frame()) 
[16:03:22.056]                   {
[16:03:22.056]                     if (is.function(workers)) 
[16:03:22.056]                       workers <- workers()
[16:03:22.056]                     workers <- structure(as.integer(workers), 
[16:03:22.056]                       class = class(workers))
[16:03:22.056]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:22.056]                       workers >= 1)
[16:03:22.056]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:22.056]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:22.056]                     }
[16:03:22.056]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:22.056]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:22.056]                       envir = envir)
[16:03:22.056]                     if (!future$lazy) 
[16:03:22.056]                       future <- run(future)
[16:03:22.056]                     invisible(future)
[16:03:22.056]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:22.056]                 }
[16:03:22.056]             }
[16:03:22.056]         }
[16:03:22.056]     })
[16:03:22.056]     if (TRUE) {
[16:03:22.056]         base::sink(type = "output", split = FALSE)
[16:03:22.056]         if (TRUE) {
[16:03:22.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:22.056]         }
[16:03:22.056]         else {
[16:03:22.056]             ...future.result["stdout"] <- base::list(NULL)
[16:03:22.056]         }
[16:03:22.056]         base::close(...future.stdout)
[16:03:22.056]         ...future.stdout <- NULL
[16:03:22.056]     }
[16:03:22.056]     ...future.result$conditions <- ...future.conditions
[16:03:22.056]     ...future.result$finished <- base::Sys.time()
[16:03:22.056]     ...future.result
[16:03:22.056] }
[16:03:22.059] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[16:03:22.059] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:03:22.103] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:03:22.103] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[16:03:22.104] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[16:03:22.104] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:03:22.104] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:03:22.104] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:03:22.147] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:03:22.147] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:03:22.191] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:03:22.191] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:03:22.192] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:03:22.192] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:03:22.192] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:03:22.192] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:22.193] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:22.193] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:03:22.193] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:03:22.193] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:22.194] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:22.194] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:22.194] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:22.194] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[16:03:22.195] MultisessionFuture started
[16:03:22.195] - Launch lazy future ... done
[16:03:22.195] run() for ‘MultisessionFuture’ ... done
[16:03:22.195] Created future:
[16:03:22.196] MultisessionFuture:
[16:03:22.196] Label: ‘future_vapply-1’
[16:03:22.196] Expression:
[16:03:22.196] {
[16:03:22.196]     do.call(function(...) {
[16:03:22.196]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:22.196]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:22.196]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:22.196]             on.exit(options(oopts), add = TRUE)
[16:03:22.196]         }
[16:03:22.196]         {
[16:03:22.196]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:22.196]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:22.196]                 ...future.FUN(...future.X_jj, ...)
[16:03:22.196]             })
[16:03:22.196]         }
[16:03:22.196]     }, args = future.call.arguments)
[16:03:22.196] }
[16:03:22.196] Lazy evaluation: FALSE
[16:03:22.196] Asynchronous evaluation: TRUE
[16:03:22.196] Local evaluation: TRUE
[16:03:22.196] Environment: R_GlobalEnv
[16:03:22.196] Capture standard output: TRUE
[16:03:22.196] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:22.196] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:22.196] Packages: 1 packages (‘future.apply’)
[16:03:22.196] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:22.196] Resolved: FALSE
[16:03:22.196] Value: <not collected>
[16:03:22.196] Conditions captured: <none>
[16:03:22.196] Early signaling: FALSE
[16:03:22.196] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:22.196] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:22.207] Chunk #1 of 2 ... DONE
[16:03:22.207] Chunk #2 of 2 ...
[16:03:22.208]  - Finding globals in 'X' for chunk #2 ...
[16:03:22.208] getGlobalsAndPackages() ...
[16:03:22.208] Searching for globals...
[16:03:22.208] 
[16:03:22.208] Searching for globals ... DONE
[16:03:22.208] - globals: [0] <none>
[16:03:22.208] getGlobalsAndPackages() ... DONE
[16:03:22.208]    + additional globals found: [n=0] 
[16:03:22.209]    + additional namespaces needed: [n=0] 
[16:03:22.209]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:22.209]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:22.209]  - seeds: <none>
[16:03:22.209]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:22.209] getGlobalsAndPackages() ...
[16:03:22.209] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:22.209] Resolving globals: FALSE
[16:03:22.209] Tweak future expression to call with '...' arguments ...
[16:03:22.210] {
[16:03:22.210]     do.call(function(...) {
[16:03:22.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:22.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:22.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:22.210]             on.exit(options(oopts), add = TRUE)
[16:03:22.210]         }
[16:03:22.210]         {
[16:03:22.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:22.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:22.210]                 ...future.FUN(...future.X_jj, ...)
[16:03:22.210]             })
[16:03:22.210]         }
[16:03:22.210]     }, args = future.call.arguments)
[16:03:22.210] }
[16:03:22.210] Tweak future expression to call with '...' arguments ... DONE
[16:03:22.210] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:22.210] - packages: [1] ‘future.apply’
[16:03:22.211] getGlobalsAndPackages() ... DONE
[16:03:22.211] run() for ‘Future’ ...
[16:03:22.211] - state: ‘created’
[16:03:22.211] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:22.225] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:22.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:22.225]   - Field: ‘node’
[16:03:22.226]   - Field: ‘label’
[16:03:22.226]   - Field: ‘local’
[16:03:22.226]   - Field: ‘owner’
[16:03:22.226]   - Field: ‘envir’
[16:03:22.226]   - Field: ‘workers’
[16:03:22.226]   - Field: ‘packages’
[16:03:22.226]   - Field: ‘gc’
[16:03:22.226]   - Field: ‘conditions’
[16:03:22.226]   - Field: ‘persistent’
[16:03:22.226]   - Field: ‘expr’
[16:03:22.226]   - Field: ‘uuid’
[16:03:22.227]   - Field: ‘seed’
[16:03:22.227]   - Field: ‘version’
[16:03:22.227]   - Field: ‘result’
[16:03:22.227]   - Field: ‘asynchronous’
[16:03:22.227]   - Field: ‘calls’
[16:03:22.227]   - Field: ‘globals’
[16:03:22.227]   - Field: ‘stdout’
[16:03:22.227]   - Field: ‘earlySignal’
[16:03:22.227]   - Field: ‘lazy’
[16:03:22.227]   - Field: ‘state’
[16:03:22.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:22.228] - Launch lazy future ...
[16:03:22.228] Packages needed by the future expression (n = 1): ‘future.apply’
[16:03:22.228] Packages needed by future strategies (n = 0): <none>
[16:03:22.229] {
[16:03:22.229]     {
[16:03:22.229]         {
[16:03:22.229]             ...future.startTime <- base::Sys.time()
[16:03:22.229]             {
[16:03:22.229]                 {
[16:03:22.229]                   {
[16:03:22.229]                     {
[16:03:22.229]                       {
[16:03:22.229]                         base::local({
[16:03:22.229]                           has_future <- base::requireNamespace("future", 
[16:03:22.229]                             quietly = TRUE)
[16:03:22.229]                           if (has_future) {
[16:03:22.229]                             ns <- base::getNamespace("future")
[16:03:22.229]                             version <- ns[[".package"]][["version"]]
[16:03:22.229]                             if (is.null(version)) 
[16:03:22.229]                               version <- utils::packageVersion("future")
[16:03:22.229]                           }
[16:03:22.229]                           else {
[16:03:22.229]                             version <- NULL
[16:03:22.229]                           }
[16:03:22.229]                           if (!has_future || version < "1.8.0") {
[16:03:22.229]                             info <- base::c(r_version = base::gsub("R version ", 
[16:03:22.229]                               "", base::R.version$version.string), 
[16:03:22.229]                               platform = base::sprintf("%s (%s-bit)", 
[16:03:22.229]                                 base::R.version$platform, 8 * 
[16:03:22.229]                                   base::.Machine$sizeof.pointer), 
[16:03:22.229]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:22.229]                                 "release", "version")], collapse = " "), 
[16:03:22.229]                               hostname = base::Sys.info()[["nodename"]])
[16:03:22.229]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:03:22.229]                               info)
[16:03:22.229]                             info <- base::paste(info, collapse = "; ")
[16:03:22.229]                             if (!has_future) {
[16:03:22.229]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:22.229]                                 info)
[16:03:22.229]                             }
[16:03:22.229]                             else {
[16:03:22.229]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:22.229]                                 info, version)
[16:03:22.229]                             }
[16:03:22.229]                             base::stop(msg)
[16:03:22.229]                           }
[16:03:22.229]                         })
[16:03:22.229]                       }
[16:03:22.229]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:22.229]                       base::options(mc.cores = 1L)
[16:03:22.229]                     }
[16:03:22.229]                     base::local({
[16:03:22.229]                       for (pkg in "future.apply") {
[16:03:22.229]                         base::loadNamespace(pkg)
[16:03:22.229]                         base::library(pkg, character.only = TRUE)
[16:03:22.229]                       }
[16:03:22.229]                     })
[16:03:22.229]                   }
[16:03:22.229]                   options(future.plan = NULL)
[16:03:22.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:22.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:22.229]                 }
[16:03:22.229]                 ...future.workdir <- getwd()
[16:03:22.229]             }
[16:03:22.229]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:22.229]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:22.229]         }
[16:03:22.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:22.229]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:22.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:22.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:22.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:22.229]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:22.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:22.229]             base::names(...future.oldOptions))
[16:03:22.229]     }
[16:03:22.229]     if (FALSE) {
[16:03:22.229]     }
[16:03:22.229]     else {
[16:03:22.229]         if (TRUE) {
[16:03:22.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:22.229]                 open = "w")
[16:03:22.229]         }
[16:03:22.229]         else {
[16:03:22.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:22.229]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:22.229]         }
[16:03:22.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:22.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:22.229]             base::sink(type = "output", split = FALSE)
[16:03:22.229]             base::close(...future.stdout)
[16:03:22.229]         }, add = TRUE)
[16:03:22.229]     }
[16:03:22.229]     ...future.frame <- base::sys.nframe()
[16:03:22.229]     ...future.conditions <- base::list()
[16:03:22.229]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:22.229]     if (FALSE) {
[16:03:22.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:22.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:22.229]     }
[16:03:22.229]     ...future.result <- base::tryCatch({
[16:03:22.229]         base::withCallingHandlers({
[16:03:22.229]             ...future.value <- base::withVisible(base::local({
[16:03:22.229]                 ...future.makeSendCondition <- base::local({
[16:03:22.229]                   sendCondition <- NULL
[16:03:22.229]                   function(frame = 1L) {
[16:03:22.229]                     if (is.function(sendCondition)) 
[16:03:22.229]                       return(sendCondition)
[16:03:22.229]                     ns <- getNamespace("parallel")
[16:03:22.229]                     if (exists("sendData", mode = "function", 
[16:03:22.229]                       envir = ns)) {
[16:03:22.229]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:22.229]                         envir = ns)
[16:03:22.229]                       envir <- sys.frame(frame)
[16:03:22.229]                       master <- NULL
[16:03:22.229]                       while (!identical(envir, .GlobalEnv) && 
[16:03:22.229]                         !identical(envir, emptyenv())) {
[16:03:22.229]                         if (exists("master", mode = "list", envir = envir, 
[16:03:22.229]                           inherits = FALSE)) {
[16:03:22.229]                           master <- get("master", mode = "list", 
[16:03:22.229]                             envir = envir, inherits = FALSE)
[16:03:22.229]                           if (inherits(master, c("SOCKnode", 
[16:03:22.229]                             "SOCK0node"))) {
[16:03:22.229]                             sendCondition <<- function(cond) {
[16:03:22.229]                               data <- list(type = "VALUE", value = cond, 
[16:03:22.229]                                 success = TRUE)
[16:03:22.229]                               parallel_sendData(master, data)
[16:03:22.229]                             }
[16:03:22.229]                             return(sendCondition)
[16:03:22.229]                           }
[16:03:22.229]                         }
[16:03:22.229]                         frame <- frame + 1L
[16:03:22.229]                         envir <- sys.frame(frame)
[16:03:22.229]                       }
[16:03:22.229]                     }
[16:03:22.229]                     sendCondition <<- function(cond) NULL
[16:03:22.229]                   }
[16:03:22.229]                 })
[16:03:22.229]                 withCallingHandlers({
[16:03:22.229]                   {
[16:03:22.229]                     do.call(function(...) {
[16:03:22.229]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:22.229]                       if (!identical(...future.globals.maxSize.org, 
[16:03:22.229]                         ...future.globals.maxSize)) {
[16:03:22.229]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:22.229]                         on.exit(options(oopts), add = TRUE)
[16:03:22.229]                       }
[16:03:22.229]                       {
[16:03:22.229]                         lapply(seq_along(...future.elements_ii), 
[16:03:22.229]                           FUN = function(jj) {
[16:03:22.229]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:22.229]                             ...future.FUN(...future.X_jj, ...)
[16:03:22.229]                           })
[16:03:22.229]                       }
[16:03:22.229]                     }, args = future.call.arguments)
[16:03:22.229]                   }
[16:03:22.229]                 }, immediateCondition = function(cond) {
[16:03:22.229]                   sendCondition <- ...future.makeSendCondition()
[16:03:22.229]                   sendCondition(cond)
[16:03:22.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:22.229]                   {
[16:03:22.229]                     inherits <- base::inherits
[16:03:22.229]                     invokeRestart <- base::invokeRestart
[16:03:22.229]                     is.null <- base::is.null
[16:03:22.229]                     muffled <- FALSE
[16:03:22.229]                     if (inherits(cond, "message")) {
[16:03:22.229]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:22.229]                       if (muffled) 
[16:03:22.229]                         invokeRestart("muffleMessage")
[16:03:22.229]                     }
[16:03:22.229]                     else if (inherits(cond, "warning")) {
[16:03:22.229]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:22.229]                       if (muffled) 
[16:03:22.229]                         invokeRestart("muffleWarning")
[16:03:22.229]                     }
[16:03:22.229]                     else if (inherits(cond, "condition")) {
[16:03:22.229]                       if (!is.null(pattern)) {
[16:03:22.229]                         computeRestarts <- base::computeRestarts
[16:03:22.229]                         grepl <- base::grepl
[16:03:22.229]                         restarts <- computeRestarts(cond)
[16:03:22.229]                         for (restart in restarts) {
[16:03:22.229]                           name <- restart$name
[16:03:22.229]                           if (is.null(name)) 
[16:03:22.229]                             next
[16:03:22.229]                           if (!grepl(pattern, name)) 
[16:03:22.229]                             next
[16:03:22.229]                           invokeRestart(restart)
[16:03:22.229]                           muffled <- TRUE
[16:03:22.229]                           break
[16:03:22.229]                         }
[16:03:22.229]                       }
[16:03:22.229]                     }
[16:03:22.229]                     invisible(muffled)
[16:03:22.229]                   }
[16:03:22.229]                   muffleCondition(cond)
[16:03:22.229]                 })
[16:03:22.229]             }))
[16:03:22.229]             future::FutureResult(value = ...future.value$value, 
[16:03:22.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:22.229]                   ...future.rng), globalenv = if (FALSE) 
[16:03:22.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:22.229]                     ...future.globalenv.names))
[16:03:22.229]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:22.229]         }, condition = base::local({
[16:03:22.229]             c <- base::c
[16:03:22.229]             inherits <- base::inherits
[16:03:22.229]             invokeRestart <- base::invokeRestart
[16:03:22.229]             length <- base::length
[16:03:22.229]             list <- base::list
[16:03:22.229]             seq.int <- base::seq.int
[16:03:22.229]             signalCondition <- base::signalCondition
[16:03:22.229]             sys.calls <- base::sys.calls
[16:03:22.229]             `[[` <- base::`[[`
[16:03:22.229]             `+` <- base::`+`
[16:03:22.229]             `<<-` <- base::`<<-`
[16:03:22.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:22.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:22.229]                   3L)]
[16:03:22.229]             }
[16:03:22.229]             function(cond) {
[16:03:22.229]                 is_error <- inherits(cond, "error")
[16:03:22.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:22.229]                   NULL)
[16:03:22.229]                 if (is_error) {
[16:03:22.229]                   sessionInformation <- function() {
[16:03:22.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:22.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:22.229]                       search = base::search(), system = base::Sys.info())
[16:03:22.229]                   }
[16:03:22.229]                   ...future.conditions[[length(...future.conditions) + 
[16:03:22.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:22.229]                     cond$call), session = sessionInformation(), 
[16:03:22.229]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:22.229]                   signalCondition(cond)
[16:03:22.229]                 }
[16:03:22.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:22.229]                 "immediateCondition"))) {
[16:03:22.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:22.229]                   ...future.conditions[[length(...future.conditions) + 
[16:03:22.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:22.229]                   if (TRUE && !signal) {
[16:03:22.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:22.229]                     {
[16:03:22.229]                       inherits <- base::inherits
[16:03:22.229]                       invokeRestart <- base::invokeRestart
[16:03:22.229]                       is.null <- base::is.null
[16:03:22.229]                       muffled <- FALSE
[16:03:22.229]                       if (inherits(cond, "message")) {
[16:03:22.229]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:22.229]                         if (muffled) 
[16:03:22.229]                           invokeRestart("muffleMessage")
[16:03:22.229]                       }
[16:03:22.229]                       else if (inherits(cond, "warning")) {
[16:03:22.229]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:22.229]                         if (muffled) 
[16:03:22.229]                           invokeRestart("muffleWarning")
[16:03:22.229]                       }
[16:03:22.229]                       else if (inherits(cond, "condition")) {
[16:03:22.229]                         if (!is.null(pattern)) {
[16:03:22.229]                           computeRestarts <- base::computeRestarts
[16:03:22.229]                           grepl <- base::grepl
[16:03:22.229]                           restarts <- computeRestarts(cond)
[16:03:22.229]                           for (restart in restarts) {
[16:03:22.229]                             name <- restart$name
[16:03:22.229]                             if (is.null(name)) 
[16:03:22.229]                               next
[16:03:22.229]                             if (!grepl(pattern, name)) 
[16:03:22.229]                               next
[16:03:22.229]                             invokeRestart(restart)
[16:03:22.229]                             muffled <- TRUE
[16:03:22.229]                             break
[16:03:22.229]                           }
[16:03:22.229]                         }
[16:03:22.229]                       }
[16:03:22.229]                       invisible(muffled)
[16:03:22.229]                     }
[16:03:22.229]                     muffleCondition(cond, pattern = "^muffle")
[16:03:22.229]                   }
[16:03:22.229]                 }
[16:03:22.229]                 else {
[16:03:22.229]                   if (TRUE) {
[16:03:22.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:22.229]                     {
[16:03:22.229]                       inherits <- base::inherits
[16:03:22.229]                       invokeRestart <- base::invokeRestart
[16:03:22.229]                       is.null <- base::is.null
[16:03:22.229]                       muffled <- FALSE
[16:03:22.229]                       if (inherits(cond, "message")) {
[16:03:22.229]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:22.229]                         if (muffled) 
[16:03:22.229]                           invokeRestart("muffleMessage")
[16:03:22.229]                       }
[16:03:22.229]                       else if (inherits(cond, "warning")) {
[16:03:22.229]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:22.229]                         if (muffled) 
[16:03:22.229]                           invokeRestart("muffleWarning")
[16:03:22.229]                       }
[16:03:22.229]                       else if (inherits(cond, "condition")) {
[16:03:22.229]                         if (!is.null(pattern)) {
[16:03:22.229]                           computeRestarts <- base::computeRestarts
[16:03:22.229]                           grepl <- base::grepl
[16:03:22.229]                           restarts <- computeRestarts(cond)
[16:03:22.229]                           for (restart in restarts) {
[16:03:22.229]                             name <- restart$name
[16:03:22.229]                             if (is.null(name)) 
[16:03:22.229]                               next
[16:03:22.229]                             if (!grepl(pattern, name)) 
[16:03:22.229]                               next
[16:03:22.229]                             invokeRestart(restart)
[16:03:22.229]                             muffled <- TRUE
[16:03:22.229]                             break
[16:03:22.229]                           }
[16:03:22.229]                         }
[16:03:22.229]                       }
[16:03:22.229]                       invisible(muffled)
[16:03:22.229]                     }
[16:03:22.229]                     muffleCondition(cond, pattern = "^muffle")
[16:03:22.229]                   }
[16:03:22.229]                 }
[16:03:22.229]             }
[16:03:22.229]         }))
[16:03:22.229]     }, error = function(ex) {
[16:03:22.229]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:22.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:22.229]                 ...future.rng), started = ...future.startTime, 
[16:03:22.229]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:22.229]             version = "1.8"), class = "FutureResult")
[16:03:22.229]     }, finally = {
[16:03:22.229]         if (!identical(...future.workdir, getwd())) 
[16:03:22.229]             setwd(...future.workdir)
[16:03:22.229]         {
[16:03:22.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:22.229]                 ...future.oldOptions$nwarnings <- NULL
[16:03:22.229]             }
[16:03:22.229]             base::options(...future.oldOptions)
[16:03:22.229]             if (.Platform$OS.type == "windows") {
[16:03:22.229]                 old_names <- names(...future.oldEnvVars)
[16:03:22.229]                 envs <- base::Sys.getenv()
[16:03:22.229]                 names <- names(envs)
[16:03:22.229]                 common <- intersect(names, old_names)
[16:03:22.229]                 added <- setdiff(names, old_names)
[16:03:22.229]                 removed <- setdiff(old_names, names)
[16:03:22.229]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:22.229]                   envs[common]]
[16:03:22.229]                 NAMES <- toupper(changed)
[16:03:22.229]                 args <- list()
[16:03:22.229]                 for (kk in seq_along(NAMES)) {
[16:03:22.229]                   name <- changed[[kk]]
[16:03:22.229]                   NAME <- NAMES[[kk]]
[16:03:22.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:22.229]                     next
[16:03:22.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:22.229]                 }
[16:03:22.229]                 NAMES <- toupper(added)
[16:03:22.229]                 for (kk in seq_along(NAMES)) {
[16:03:22.229]                   name <- added[[kk]]
[16:03:22.229]                   NAME <- NAMES[[kk]]
[16:03:22.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:22.229]                     next
[16:03:22.229]                   args[[name]] <- ""
[16:03:22.229]                 }
[16:03:22.229]                 NAMES <- toupper(removed)
[16:03:22.229]                 for (kk in seq_along(NAMES)) {
[16:03:22.229]                   name <- removed[[kk]]
[16:03:22.229]                   NAME <- NAMES[[kk]]
[16:03:22.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:22.229]                     next
[16:03:22.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:22.229]                 }
[16:03:22.229]                 if (length(args) > 0) 
[16:03:22.229]                   base::do.call(base::Sys.setenv, args = args)
[16:03:22.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:22.229]             }
[16:03:22.229]             else {
[16:03:22.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:22.229]             }
[16:03:22.229]             {
[16:03:22.229]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:22.229]                   0L) {
[16:03:22.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:22.229]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:22.229]                   base::options(opts)
[16:03:22.229]                 }
[16:03:22.229]                 {
[16:03:22.229]                   {
[16:03:22.229]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:22.229]                     NULL
[16:03:22.229]                   }
[16:03:22.229]                   options(future.plan = NULL)
[16:03:22.229]                   if (is.na(NA_character_)) 
[16:03:22.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:22.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:22.229]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:22.229]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:22.229]                     envir = parent.frame()) 
[16:03:22.229]                   {
[16:03:22.229]                     if (is.function(workers)) 
[16:03:22.229]                       workers <- workers()
[16:03:22.229]                     workers <- structure(as.integer(workers), 
[16:03:22.229]                       class = class(workers))
[16:03:22.229]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:22.229]                       workers >= 1)
[16:03:22.229]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:22.229]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:22.229]                     }
[16:03:22.229]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:22.229]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:22.229]                       envir = envir)
[16:03:22.229]                     if (!future$lazy) 
[16:03:22.229]                       future <- run(future)
[16:03:22.229]                     invisible(future)
[16:03:22.229]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:22.229]                 }
[16:03:22.229]             }
[16:03:22.229]         }
[16:03:22.229]     })
[16:03:22.229]     if (TRUE) {
[16:03:22.229]         base::sink(type = "output", split = FALSE)
[16:03:22.229]         if (TRUE) {
[16:03:22.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:22.229]         }
[16:03:22.229]         else {
[16:03:22.229]             ...future.result["stdout"] <- base::list(NULL)
[16:03:22.229]         }
[16:03:22.229]         base::close(...future.stdout)
[16:03:22.229]         ...future.stdout <- NULL
[16:03:22.229]     }
[16:03:22.229]     ...future.result$conditions <- ...future.conditions
[16:03:22.229]     ...future.result$finished <- base::Sys.time()
[16:03:22.229]     ...future.result
[16:03:22.229] }
[16:03:22.232] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[16:03:22.232] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:03:22.275] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:03:22.275] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[16:03:22.276] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[16:03:22.276] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:03:22.276] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:03:22.276] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:03:22.319] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:03:22.319] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:03:22.363] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:03:22.363] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:03:22.364] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:03:22.364] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:03:22.364] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:03:22.365] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:22.365] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:22.365] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:03:22.365] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:03:22.366] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:22.366] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:22.366] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:22.367] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:22.367] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[16:03:22.367] MultisessionFuture started
[16:03:22.367] - Launch lazy future ... done
[16:03:22.368] run() for ‘MultisessionFuture’ ... done
[16:03:22.368] Created future:
[16:03:22.368] MultisessionFuture:
[16:03:22.368] Label: ‘future_vapply-2’
[16:03:22.368] Expression:
[16:03:22.368] {
[16:03:22.368]     do.call(function(...) {
[16:03:22.368]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:22.368]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:22.368]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:22.368]             on.exit(options(oopts), add = TRUE)
[16:03:22.368]         }
[16:03:22.368]         {
[16:03:22.368]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:22.368]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:22.368]                 ...future.FUN(...future.X_jj, ...)
[16:03:22.368]             })
[16:03:22.368]         }
[16:03:22.368]     }, args = future.call.arguments)
[16:03:22.368] }
[16:03:22.368] Lazy evaluation: FALSE
[16:03:22.368] Asynchronous evaluation: TRUE
[16:03:22.368] Local evaluation: TRUE
[16:03:22.368] Environment: R_GlobalEnv
[16:03:22.368] Capture standard output: TRUE
[16:03:22.368] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:22.368] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:03:22.368] Packages: 1 packages (‘future.apply’)
[16:03:22.368] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:22.368] Resolved: FALSE
[16:03:22.368] Value: <not collected>
[16:03:22.368] Conditions captured: <none>
[16:03:22.368] Early signaling: FALSE
[16:03:22.368] Owner process: 3c98523f-d92a-423e-a0f1-22683cb56477
[16:03:22.368] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:22.380] Chunk #2 of 2 ... DONE
[16:03:22.380] Launching 2 futures (chunks) ... DONE
[16:03:22.380] Resolving 2 futures (chunks) ...
[16:03:22.380] resolve() on list ...
[16:03:22.380]  recursive: 0
[16:03:22.380]  length: 2
[16:03:22.380] 
[16:03:22.381] receiveMessageFromWorker() for ClusterFuture ...
[16:03:22.381] - Validating connection of MultisessionFuture
[16:03:22.384] - received message: FutureResult
[16:03:22.385] - Received FutureResult
[16:03:22.385] - Erased future from FutureRegistry
[16:03:22.385] result() for ClusterFuture ...
[16:03:22.385] - result already collected: FutureResult
[16:03:22.385] result() for ClusterFuture ... done
[16:03:22.385] signalConditions() ...
[16:03:22.385]  - include = ‘immediateCondition’
[16:03:22.385]  - exclude = 
[16:03:22.385]  - resignal = FALSE
[16:03:22.385]  - Number of conditions: 1
[16:03:22.386] signalConditions() ... done
[16:03:22.386] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:22.386] Future #1
[16:03:22.386] result() for ClusterFuture ...
[16:03:22.386] - result already collected: FutureResult
[16:03:22.386] result() for ClusterFuture ... done
[16:03:22.386] result() for ClusterFuture ...
[16:03:22.386] - result already collected: FutureResult
[16:03:22.386] result() for ClusterFuture ... done
[16:03:22.386] signalConditions() ...
[16:03:22.386]  - include = ‘immediateCondition’
[16:03:22.386]  - exclude = 
[16:03:22.387]  - resignal = FALSE
[16:03:22.387]  - Number of conditions: 1
[16:03:22.387] signalConditions() ... done
[16:03:22.387] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:22.387] - nx: 2
[16:03:22.387] - relay: TRUE
[16:03:22.387] - stdout: TRUE
[16:03:22.387] - signal: TRUE
[16:03:22.387] - resignal: FALSE
[16:03:22.387] - force: TRUE
[16:03:22.387] - relayed: [n=2] FALSE, FALSE
[16:03:22.388] - queued futures: [n=2] FALSE, FALSE
[16:03:22.388]  - until=1
[16:03:22.388]  - relaying element #1
[16:03:22.388] result() for ClusterFuture ...
[16:03:22.388] - result already collected: FutureResult
[16:03:22.388] result() for ClusterFuture ... done
[16:03:22.388] result() for ClusterFuture ...
[16:03:22.388] - result already collected: FutureResult
[16:03:22.388] result() for ClusterFuture ... done
[16:03:22.388] signalConditions() ...
[16:03:22.388]  - include = ‘immediateCondition’
[16:03:22.388]  - exclude = 
[16:03:22.389]  - resignal = FALSE
[16:03:22.389]  - Number of conditions: 1
[16:03:22.389] signalConditions() ... done
[16:03:22.389] result() for ClusterFuture ...
[16:03:22.389] - result already collected: FutureResult
[16:03:22.389] result() for ClusterFuture ... done
[16:03:22.389] signalConditions() ...
[16:03:22.389]  - include = ‘immediateCondition’
[16:03:22.389]  - exclude = 
[16:03:22.389]  - resignal = FALSE
[16:03:22.389]  - Number of conditions: 1
[16:03:22.390] signalConditions() ... done
[16:03:22.390] result() for ClusterFuture ...
[16:03:22.390] - result already collected: FutureResult
[16:03:22.390] result() for ClusterFuture ... done
[16:03:22.390] signalConditions() ...
[16:03:22.390]  - include = ‘condition’
[16:03:22.390]  - exclude = ‘immediateCondition’
[16:03:22.390]  - resignal = TRUE
[16:03:22.390]  - Number of conditions: 1
[16:03:22.390]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:03:22.390] signalConditions() ... done
[16:03:22.391] - relayed: [n=2] FALSE, FALSE
[16:03:22.391] - queued futures: [n=2] TRUE, FALSE
[16:03:22.391] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:22.391] plan(): Setting new future strategy stack:
[16:03:22.391] List of future strategies:
[16:03:22.391] 1. sequential:
[16:03:22.391]    - args: function (..., envir = parent.frame())
[16:03:22.391]    - tweaked: FALSE
[16:03:22.391]    - call: plan(sequential)
[16:03:22.392] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[16:03:22.393] plan(): Setting new future strategy stack:
[16:03:22.393] List of future strategies:
[16:03:22.393] 1. FutureStrategy:
[16:03:22.393]    - args: function (..., envir = parent.frame())
[16:03:22.393]    - tweaked: FALSE
[16:03:22.393]    - call: future::plan(oplan)
[16:03:22.393] plan(): nbrOfWorkers() = 1
> 
