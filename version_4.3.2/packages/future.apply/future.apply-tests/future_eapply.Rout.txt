
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:20:05.720] plan(): Setting new future strategy stack:
[13:20:05.721] List of future strategies:
[13:20:05.721] 1. sequential:
[13:20:05.721]    - args: function (..., envir = parent.frame())
[13:20:05.721]    - tweaked: FALSE
[13:20:05.721]    - call: future::plan("sequential")
[13:20:05.735] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[13:20:05.758] plan(): Setting new future strategy stack:
[13:20:05.758] List of future strategies:
[13:20:05.758] 1. sequential:
[13:20:05.758]    - args: function (..., envir = parent.frame())
[13:20:05.758]    - tweaked: FALSE
[13:20:05.758]    - call: plan(strategy)
[13:20:05.771] plan(): nbrOfWorkers() = 1
[13:20:05.771] future_lapply() ...
[13:20:05.776] Number of chunks: 1
[13:20:05.776] getGlobalsAndPackagesXApply() ...
[13:20:05.776]  - future.globals: TRUE
[13:20:05.777] getGlobalsAndPackages() ...
[13:20:05.777] Searching for globals...
[13:20:05.780] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:05.780] Searching for globals ... DONE
[13:20:05.780] Resolving globals: FALSE
[13:20:05.781] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:05.781] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:05.782] - globals: [1] ‘FUN’
[13:20:05.782] 
[13:20:05.782] getGlobalsAndPackages() ... DONE
[13:20:05.782]  - globals found/used: [n=1] ‘FUN’
[13:20:05.782]  - needed namespaces: [n=0] 
[13:20:05.782] Finding globals ... DONE
[13:20:05.782]  - use_args: TRUE
[13:20:05.782]  - Getting '...' globals ...
[13:20:05.783] resolve() on list ...
[13:20:05.783]  recursive: 0
[13:20:05.784]  length: 1
[13:20:05.784]  elements: ‘...’
[13:20:05.784]  length: 0 (resolved future 1)
[13:20:05.784] resolve() on list ... DONE
[13:20:05.784]    - '...' content: [n=0] 
[13:20:05.784] List of 1
[13:20:05.784]  $ ...: list()
[13:20:05.784]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.784]  - attr(*, "where")=List of 1
[13:20:05.784]   ..$ ...:<environment: 0x558fd700aac0> 
[13:20:05.784]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.784]  - attr(*, "resolved")= logi TRUE
[13:20:05.784]  - attr(*, "total_size")= num NA
[13:20:05.789]  - Getting '...' globals ... DONE
[13:20:05.789] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:05.790] List of 2
[13:20:05.790]  $ ...future.FUN:function (x, ...)  
[13:20:05.790]  $ ...          : list()
[13:20:05.790]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.790]  - attr(*, "where")=List of 2
[13:20:05.790]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:05.790]   ..$ ...          :<environment: 0x558fd700aac0> 
[13:20:05.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.790]  - attr(*, "resolved")= logi FALSE
[13:20:05.790]  - attr(*, "total_size")= num 1240
[13:20:05.792] Packages to be attached in all futures: [n=0] 
[13:20:05.792] getGlobalsAndPackagesXApply() ... DONE
[13:20:05.793] Number of futures (= number of chunks): 1
[13:20:05.793] Launching 1 futures (chunks) ...
[13:20:05.793] Chunk #1 of 1 ...
[13:20:05.793]  - Finding globals in 'X' for chunk #1 ...
[13:20:05.793] getGlobalsAndPackages() ...
[13:20:05.793] Searching for globals...
[13:20:05.794] 
[13:20:05.794] Searching for globals ... DONE
[13:20:05.794] - globals: [0] <none>
[13:20:05.794] getGlobalsAndPackages() ... DONE
[13:20:05.794]    + additional globals found: [n=0] 
[13:20:05.794]    + additional namespaces needed: [n=0] 
[13:20:05.794]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:05.794]  - seeds: <none>
[13:20:05.794]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.795] getGlobalsAndPackages() ...
[13:20:05.795] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.795] Resolving globals: FALSE
[13:20:05.795] Tweak future expression to call with '...' arguments ...
[13:20:05.795] {
[13:20:05.795]     do.call(function(...) {
[13:20:05.795]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.795]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.795]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.795]             on.exit(options(oopts), add = TRUE)
[13:20:05.795]         }
[13:20:05.795]         {
[13:20:05.795]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.795]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.795]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.795]             })
[13:20:05.795]         }
[13:20:05.795]     }, args = future.call.arguments)
[13:20:05.795] }
[13:20:05.795] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.796] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.796] 
[13:20:05.796] getGlobalsAndPackages() ... DONE
[13:20:05.797] run() for ‘Future’ ...
[13:20:05.797] - state: ‘created’
[13:20:05.797] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:05.797] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:05.797] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:05.798]   - Field: ‘label’
[13:20:05.798]   - Field: ‘local’
[13:20:05.798]   - Field: ‘owner’
[13:20:05.798]   - Field: ‘envir’
[13:20:05.798]   - Field: ‘packages’
[13:20:05.798]   - Field: ‘gc’
[13:20:05.798]   - Field: ‘conditions’
[13:20:05.798]   - Field: ‘expr’
[13:20:05.798]   - Field: ‘uuid’
[13:20:05.798]   - Field: ‘seed’
[13:20:05.799]   - Field: ‘version’
[13:20:05.799]   - Field: ‘result’
[13:20:05.799]   - Field: ‘asynchronous’
[13:20:05.799]   - Field: ‘calls’
[13:20:05.799]   - Field: ‘globals’
[13:20:05.799]   - Field: ‘stdout’
[13:20:05.799]   - Field: ‘earlySignal’
[13:20:05.799]   - Field: ‘lazy’
[13:20:05.799]   - Field: ‘state’
[13:20:05.799] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:05.799] - Launch lazy future ...
[13:20:05.800] Packages needed by the future expression (n = 0): <none>
[13:20:05.800] Packages needed by future strategies (n = 0): <none>
[13:20:05.804] {
[13:20:05.804]     {
[13:20:05.804]         {
[13:20:05.804]             ...future.startTime <- base::Sys.time()
[13:20:05.804]             {
[13:20:05.804]                 {
[13:20:05.804]                   {
[13:20:05.804]                     base::local({
[13:20:05.804]                       has_future <- base::requireNamespace("future", 
[13:20:05.804]                         quietly = TRUE)
[13:20:05.804]                       if (has_future) {
[13:20:05.804]                         ns <- base::getNamespace("future")
[13:20:05.804]                         version <- ns[[".package"]][["version"]]
[13:20:05.804]                         if (is.null(version)) 
[13:20:05.804]                           version <- utils::packageVersion("future")
[13:20:05.804]                       }
[13:20:05.804]                       else {
[13:20:05.804]                         version <- NULL
[13:20:05.804]                       }
[13:20:05.804]                       if (!has_future || version < "1.8.0") {
[13:20:05.804]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:05.804]                           "", base::R.version$version.string), 
[13:20:05.804]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:05.804]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:05.804]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:05.804]                             "release", "version")], collapse = " "), 
[13:20:05.804]                           hostname = base::Sys.info()[["nodename"]])
[13:20:05.804]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:05.804]                           info)
[13:20:05.804]                         info <- base::paste(info, collapse = "; ")
[13:20:05.804]                         if (!has_future) {
[13:20:05.804]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:05.804]                             info)
[13:20:05.804]                         }
[13:20:05.804]                         else {
[13:20:05.804]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:05.804]                             info, version)
[13:20:05.804]                         }
[13:20:05.804]                         base::stop(msg)
[13:20:05.804]                       }
[13:20:05.804]                     })
[13:20:05.804]                   }
[13:20:05.804]                   options(future.plan = NULL)
[13:20:05.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:05.804]                 }
[13:20:05.804]                 ...future.workdir <- getwd()
[13:20:05.804]             }
[13:20:05.804]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:05.804]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:05.804]         }
[13:20:05.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:05.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:05.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:05.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:05.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:05.804]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:05.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:05.804]             base::names(...future.oldOptions))
[13:20:05.804]     }
[13:20:05.804]     if (FALSE) {
[13:20:05.804]     }
[13:20:05.804]     else {
[13:20:05.804]         if (TRUE) {
[13:20:05.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:05.804]                 open = "w")
[13:20:05.804]         }
[13:20:05.804]         else {
[13:20:05.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:05.804]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:05.804]         }
[13:20:05.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:05.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:05.804]             base::sink(type = "output", split = FALSE)
[13:20:05.804]             base::close(...future.stdout)
[13:20:05.804]         }, add = TRUE)
[13:20:05.804]     }
[13:20:05.804]     ...future.frame <- base::sys.nframe()
[13:20:05.804]     ...future.conditions <- base::list()
[13:20:05.804]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:05.804]     if (FALSE) {
[13:20:05.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:05.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:05.804]     }
[13:20:05.804]     ...future.result <- base::tryCatch({
[13:20:05.804]         base::withCallingHandlers({
[13:20:05.804]             ...future.value <- base::withVisible(base::local({
[13:20:05.804]                 do.call(function(...) {
[13:20:05.804]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.804]                   if (!identical(...future.globals.maxSize.org, 
[13:20:05.804]                     ...future.globals.maxSize)) {
[13:20:05.804]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.804]                     on.exit(options(oopts), add = TRUE)
[13:20:05.804]                   }
[13:20:05.804]                   {
[13:20:05.804]                     lapply(seq_along(...future.elements_ii), 
[13:20:05.804]                       FUN = function(jj) {
[13:20:05.804]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.804]                         ...future.FUN(...future.X_jj, ...)
[13:20:05.804]                       })
[13:20:05.804]                   }
[13:20:05.804]                 }, args = future.call.arguments)
[13:20:05.804]             }))
[13:20:05.804]             future::FutureResult(value = ...future.value$value, 
[13:20:05.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.804]                   ...future.rng), globalenv = if (FALSE) 
[13:20:05.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:05.804]                     ...future.globalenv.names))
[13:20:05.804]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:05.804]         }, condition = base::local({
[13:20:05.804]             c <- base::c
[13:20:05.804]             inherits <- base::inherits
[13:20:05.804]             invokeRestart <- base::invokeRestart
[13:20:05.804]             length <- base::length
[13:20:05.804]             list <- base::list
[13:20:05.804]             seq.int <- base::seq.int
[13:20:05.804]             signalCondition <- base::signalCondition
[13:20:05.804]             sys.calls <- base::sys.calls
[13:20:05.804]             `[[` <- base::`[[`
[13:20:05.804]             `+` <- base::`+`
[13:20:05.804]             `<<-` <- base::`<<-`
[13:20:05.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:05.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:05.804]                   3L)]
[13:20:05.804]             }
[13:20:05.804]             function(cond) {
[13:20:05.804]                 is_error <- inherits(cond, "error")
[13:20:05.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:05.804]                   NULL)
[13:20:05.804]                 if (is_error) {
[13:20:05.804]                   sessionInformation <- function() {
[13:20:05.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:05.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:05.804]                       search = base::search(), system = base::Sys.info())
[13:20:05.804]                   }
[13:20:05.804]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:05.804]                     cond$call), session = sessionInformation(), 
[13:20:05.804]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:05.804]                   signalCondition(cond)
[13:20:05.804]                 }
[13:20:05.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:05.804]                 "immediateCondition"))) {
[13:20:05.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:05.804]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:05.804]                   if (TRUE && !signal) {
[13:20:05.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.804]                     {
[13:20:05.804]                       inherits <- base::inherits
[13:20:05.804]                       invokeRestart <- base::invokeRestart
[13:20:05.804]                       is.null <- base::is.null
[13:20:05.804]                       muffled <- FALSE
[13:20:05.804]                       if (inherits(cond, "message")) {
[13:20:05.804]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.804]                         if (muffled) 
[13:20:05.804]                           invokeRestart("muffleMessage")
[13:20:05.804]                       }
[13:20:05.804]                       else if (inherits(cond, "warning")) {
[13:20:05.804]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.804]                         if (muffled) 
[13:20:05.804]                           invokeRestart("muffleWarning")
[13:20:05.804]                       }
[13:20:05.804]                       else if (inherits(cond, "condition")) {
[13:20:05.804]                         if (!is.null(pattern)) {
[13:20:05.804]                           computeRestarts <- base::computeRestarts
[13:20:05.804]                           grepl <- base::grepl
[13:20:05.804]                           restarts <- computeRestarts(cond)
[13:20:05.804]                           for (restart in restarts) {
[13:20:05.804]                             name <- restart$name
[13:20:05.804]                             if (is.null(name)) 
[13:20:05.804]                               next
[13:20:05.804]                             if (!grepl(pattern, name)) 
[13:20:05.804]                               next
[13:20:05.804]                             invokeRestart(restart)
[13:20:05.804]                             muffled <- TRUE
[13:20:05.804]                             break
[13:20:05.804]                           }
[13:20:05.804]                         }
[13:20:05.804]                       }
[13:20:05.804]                       invisible(muffled)
[13:20:05.804]                     }
[13:20:05.804]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.804]                   }
[13:20:05.804]                 }
[13:20:05.804]                 else {
[13:20:05.804]                   if (TRUE) {
[13:20:05.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.804]                     {
[13:20:05.804]                       inherits <- base::inherits
[13:20:05.804]                       invokeRestart <- base::invokeRestart
[13:20:05.804]                       is.null <- base::is.null
[13:20:05.804]                       muffled <- FALSE
[13:20:05.804]                       if (inherits(cond, "message")) {
[13:20:05.804]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.804]                         if (muffled) 
[13:20:05.804]                           invokeRestart("muffleMessage")
[13:20:05.804]                       }
[13:20:05.804]                       else if (inherits(cond, "warning")) {
[13:20:05.804]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.804]                         if (muffled) 
[13:20:05.804]                           invokeRestart("muffleWarning")
[13:20:05.804]                       }
[13:20:05.804]                       else if (inherits(cond, "condition")) {
[13:20:05.804]                         if (!is.null(pattern)) {
[13:20:05.804]                           computeRestarts <- base::computeRestarts
[13:20:05.804]                           grepl <- base::grepl
[13:20:05.804]                           restarts <- computeRestarts(cond)
[13:20:05.804]                           for (restart in restarts) {
[13:20:05.804]                             name <- restart$name
[13:20:05.804]                             if (is.null(name)) 
[13:20:05.804]                               next
[13:20:05.804]                             if (!grepl(pattern, name)) 
[13:20:05.804]                               next
[13:20:05.804]                             invokeRestart(restart)
[13:20:05.804]                             muffled <- TRUE
[13:20:05.804]                             break
[13:20:05.804]                           }
[13:20:05.804]                         }
[13:20:05.804]                       }
[13:20:05.804]                       invisible(muffled)
[13:20:05.804]                     }
[13:20:05.804]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.804]                   }
[13:20:05.804]                 }
[13:20:05.804]             }
[13:20:05.804]         }))
[13:20:05.804]     }, error = function(ex) {
[13:20:05.804]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:05.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.804]                 ...future.rng), started = ...future.startTime, 
[13:20:05.804]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:05.804]             version = "1.8"), class = "FutureResult")
[13:20:05.804]     }, finally = {
[13:20:05.804]         if (!identical(...future.workdir, getwd())) 
[13:20:05.804]             setwd(...future.workdir)
[13:20:05.804]         {
[13:20:05.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:05.804]                 ...future.oldOptions$nwarnings <- NULL
[13:20:05.804]             }
[13:20:05.804]             base::options(...future.oldOptions)
[13:20:05.804]             if (.Platform$OS.type == "windows") {
[13:20:05.804]                 old_names <- names(...future.oldEnvVars)
[13:20:05.804]                 envs <- base::Sys.getenv()
[13:20:05.804]                 names <- names(envs)
[13:20:05.804]                 common <- intersect(names, old_names)
[13:20:05.804]                 added <- setdiff(names, old_names)
[13:20:05.804]                 removed <- setdiff(old_names, names)
[13:20:05.804]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:05.804]                   envs[common]]
[13:20:05.804]                 NAMES <- toupper(changed)
[13:20:05.804]                 args <- list()
[13:20:05.804]                 for (kk in seq_along(NAMES)) {
[13:20:05.804]                   name <- changed[[kk]]
[13:20:05.804]                   NAME <- NAMES[[kk]]
[13:20:05.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.804]                     next
[13:20:05.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.804]                 }
[13:20:05.804]                 NAMES <- toupper(added)
[13:20:05.804]                 for (kk in seq_along(NAMES)) {
[13:20:05.804]                   name <- added[[kk]]
[13:20:05.804]                   NAME <- NAMES[[kk]]
[13:20:05.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.804]                     next
[13:20:05.804]                   args[[name]] <- ""
[13:20:05.804]                 }
[13:20:05.804]                 NAMES <- toupper(removed)
[13:20:05.804]                 for (kk in seq_along(NAMES)) {
[13:20:05.804]                   name <- removed[[kk]]
[13:20:05.804]                   NAME <- NAMES[[kk]]
[13:20:05.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.804]                     next
[13:20:05.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.804]                 }
[13:20:05.804]                 if (length(args) > 0) 
[13:20:05.804]                   base::do.call(base::Sys.setenv, args = args)
[13:20:05.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:05.804]             }
[13:20:05.804]             else {
[13:20:05.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:05.804]             }
[13:20:05.804]             {
[13:20:05.804]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:05.804]                   0L) {
[13:20:05.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:05.804]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:05.804]                   base::options(opts)
[13:20:05.804]                 }
[13:20:05.804]                 {
[13:20:05.804]                   {
[13:20:05.804]                     NULL
[13:20:05.804]                     RNGkind("Mersenne-Twister")
[13:20:05.804]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:05.804]                       inherits = FALSE)
[13:20:05.804]                   }
[13:20:05.804]                   options(future.plan = NULL)
[13:20:05.804]                   if (is.na(NA_character_)) 
[13:20:05.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:05.804]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:05.804]                   {
[13:20:05.804]                     future <- SequentialFuture(..., envir = envir)
[13:20:05.804]                     if (!future$lazy) 
[13:20:05.804]                       future <- run(future)
[13:20:05.804]                     invisible(future)
[13:20:05.804]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:05.804]                 }
[13:20:05.804]             }
[13:20:05.804]         }
[13:20:05.804]     })
[13:20:05.804]     if (TRUE) {
[13:20:05.804]         base::sink(type = "output", split = FALSE)
[13:20:05.804]         if (TRUE) {
[13:20:05.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:05.804]         }
[13:20:05.804]         else {
[13:20:05.804]             ...future.result["stdout"] <- base::list(NULL)
[13:20:05.804]         }
[13:20:05.804]         base::close(...future.stdout)
[13:20:05.804]         ...future.stdout <- NULL
[13:20:05.804]     }
[13:20:05.804]     ...future.result$conditions <- ...future.conditions
[13:20:05.804]     ...future.result$finished <- base::Sys.time()
[13:20:05.804]     ...future.result
[13:20:05.804] }
[13:20:05.806] assign_globals() ...
[13:20:05.806] List of 5
[13:20:05.806]  $ ...future.FUN            :function (x, ...)  
[13:20:05.806]  $ future.call.arguments    : list()
[13:20:05.806]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.806]  $ ...future.elements_ii    :List of 3
[13:20:05.806]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[13:20:05.806]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:20:05.806]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:20:05.806]  $ ...future.seeds_ii       : NULL
[13:20:05.806]  $ ...future.globals.maxSize: NULL
[13:20:05.806]  - attr(*, "where")=List of 5
[13:20:05.806]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:05.806]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:05.806]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:05.806]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:05.806]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:05.806]  - attr(*, "resolved")= logi FALSE
[13:20:05.806]  - attr(*, "total_size")= num 1240
[13:20:05.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.806]  - attr(*, "already-done")= logi TRUE
[13:20:05.813] - copied ‘...future.FUN’ to environment
[13:20:05.813] - copied ‘future.call.arguments’ to environment
[13:20:05.813] - copied ‘...future.elements_ii’ to environment
[13:20:05.813] - copied ‘...future.seeds_ii’ to environment
[13:20:05.813] - copied ‘...future.globals.maxSize’ to environment
[13:20:05.813] assign_globals() ... done
[13:20:05.813] plan(): Setting new future strategy stack:
[13:20:05.814] List of future strategies:
[13:20:05.814] 1. sequential:
[13:20:05.814]    - args: function (..., envir = parent.frame())
[13:20:05.814]    - tweaked: FALSE
[13:20:05.814]    - call: NULL
[13:20:05.814] plan(): nbrOfWorkers() = 1
[13:20:05.815] plan(): Setting new future strategy stack:
[13:20:05.815] List of future strategies:
[13:20:05.815] 1. sequential:
[13:20:05.815]    - args: function (..., envir = parent.frame())
[13:20:05.815]    - tweaked: FALSE
[13:20:05.815]    - call: plan(strategy)
[13:20:05.816] plan(): nbrOfWorkers() = 1
[13:20:05.816] SequentialFuture started (and completed)
[13:20:05.816] - Launch lazy future ... done
[13:20:05.816] run() for ‘SequentialFuture’ ... done
[13:20:05.817] Created future:
[13:20:05.817] SequentialFuture:
[13:20:05.817] Label: ‘future_eapply-1’
[13:20:05.817] Expression:
[13:20:05.817] {
[13:20:05.817]     do.call(function(...) {
[13:20:05.817]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.817]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.817]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.817]             on.exit(options(oopts), add = TRUE)
[13:20:05.817]         }
[13:20:05.817]         {
[13:20:05.817]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.817]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.817]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.817]             })
[13:20:05.817]         }
[13:20:05.817]     }, args = future.call.arguments)
[13:20:05.817] }
[13:20:05.817] Lazy evaluation: FALSE
[13:20:05.817] Asynchronous evaluation: FALSE
[13:20:05.817] Local evaluation: TRUE
[13:20:05.817] Environment: R_GlobalEnv
[13:20:05.817] Capture standard output: TRUE
[13:20:05.817] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:05.817] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:05.817] Packages: <none>
[13:20:05.817] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:05.817] Resolved: TRUE
[13:20:05.817] Value: 168 bytes of class ‘list’
[13:20:05.817] Early signaling: FALSE
[13:20:05.817] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:05.817] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:05.818] Chunk #1 of 1 ... DONE
[13:20:05.818] Launching 1 futures (chunks) ... DONE
[13:20:05.818] Resolving 1 futures (chunks) ...
[13:20:05.819] resolve() on list ...
[13:20:05.819]  recursive: 0
[13:20:05.819]  length: 1
[13:20:05.819] 
[13:20:05.819] resolved() for ‘SequentialFuture’ ...
[13:20:05.819] - state: ‘finished’
[13:20:05.819] - run: TRUE
[13:20:05.819] - result: ‘FutureResult’
[13:20:05.820] resolved() for ‘SequentialFuture’ ... done
[13:20:05.820] Future #1
[13:20:05.820] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:05.820] - nx: 1
[13:20:05.820] - relay: TRUE
[13:20:05.820] - stdout: TRUE
[13:20:05.821] - signal: TRUE
[13:20:05.821] - resignal: FALSE
[13:20:05.821] - force: TRUE
[13:20:05.821] - relayed: [n=1] FALSE
[13:20:05.821] - queued futures: [n=1] FALSE
[13:20:05.821]  - until=1
[13:20:05.821]  - relaying element #1
[13:20:05.821] - relayed: [n=1] TRUE
[13:20:05.821] - queued futures: [n=1] TRUE
[13:20:05.821] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:05.822]  length: 0 (resolved future 1)
[13:20:05.822] Relaying remaining futures
[13:20:05.822] signalConditionsASAP(NULL, pos=0) ...
[13:20:05.822] - nx: 1
[13:20:05.822] - relay: TRUE
[13:20:05.822] - stdout: TRUE
[13:20:05.822] - signal: TRUE
[13:20:05.822] - resignal: FALSE
[13:20:05.822] - force: TRUE
[13:20:05.822] - relayed: [n=1] TRUE
[13:20:05.822] - queued futures: [n=1] TRUE
 - flush all
[13:20:05.823] - relayed: [n=1] TRUE
[13:20:05.823] - queued futures: [n=1] TRUE
[13:20:05.823] signalConditionsASAP(NULL, pos=0) ... done
[13:20:05.823] resolve() on list ... DONE
[13:20:05.823]  - Number of value chunks collected: 1
[13:20:05.823] Resolving 1 futures (chunks) ... DONE
[13:20:05.823] Reducing values from 1 chunks ...
[13:20:05.823]  - Number of values collected after concatenation: 3
[13:20:05.823]  - Number of values expected: 3
[13:20:05.824] Reducing values from 1 chunks ... DONE
[13:20:05.824] future_lapply() ... DONE
[13:20:05.826] future_lapply() ...
[13:20:05.826] Number of chunks: 1
[13:20:05.827] getGlobalsAndPackagesXApply() ...
[13:20:05.827]  - future.globals: TRUE
[13:20:05.827] getGlobalsAndPackages() ...
[13:20:05.827] Searching for globals...
[13:20:05.828] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:05.828] Searching for globals ... DONE
[13:20:05.828] Resolving globals: FALSE
[13:20:05.828] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:20:05.829] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:20:05.829] - globals: [1] ‘FUN’
[13:20:05.829] - packages: [1] ‘stats’
[13:20:05.829] getGlobalsAndPackages() ... DONE
[13:20:05.829]  - globals found/used: [n=1] ‘FUN’
[13:20:05.829]  - needed namespaces: [n=1] ‘stats’
[13:20:05.829] Finding globals ... DONE
[13:20:05.830]  - use_args: TRUE
[13:20:05.830]  - Getting '...' globals ...
[13:20:05.830] resolve() on list ...
[13:20:05.830]  recursive: 0
[13:20:05.830]  length: 1
[13:20:05.830]  elements: ‘...’
[13:20:05.830]  length: 0 (resolved future 1)
[13:20:05.830] resolve() on list ... DONE
[13:20:05.831]    - '...' content: [n=1] ‘probs’
[13:20:05.831] List of 1
[13:20:05.831]  $ ...:List of 1
[13:20:05.831]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:20:05.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.831]  - attr(*, "where")=List of 1
[13:20:05.831]   ..$ ...:<environment: 0x558fd9438a50> 
[13:20:05.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.831]  - attr(*, "resolved")= logi TRUE
[13:20:05.831]  - attr(*, "total_size")= num NA
[13:20:05.836]  - Getting '...' globals ... DONE
[13:20:05.836] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:05.836] List of 2
[13:20:05.836]  $ ...future.FUN:function (x, ...)  
[13:20:05.836]  $ ...          :List of 1
[13:20:05.836]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:20:05.836]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.836]  - attr(*, "where")=List of 2
[13:20:05.836]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:05.836]   ..$ ...          :<environment: 0x558fd9438a50> 
[13:20:05.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.836]  - attr(*, "resolved")= logi FALSE
[13:20:05.836]  - attr(*, "total_size")= num 1328
[13:20:05.839] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:05.839] getGlobalsAndPackagesXApply() ... DONE
[13:20:05.840] Number of futures (= number of chunks): 1
[13:20:05.840] Launching 1 futures (chunks) ...
[13:20:05.840] Chunk #1 of 1 ...
[13:20:05.840]  - Finding globals in 'X' for chunk #1 ...
[13:20:05.840] getGlobalsAndPackages() ...
[13:20:05.840] Searching for globals...
[13:20:05.840] 
[13:20:05.840] Searching for globals ... DONE
[13:20:05.841] - globals: [0] <none>
[13:20:05.841] getGlobalsAndPackages() ... DONE
[13:20:05.841]    + additional globals found: [n=0] 
[13:20:05.841]    + additional namespaces needed: [n=0] 
[13:20:05.841]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:05.841]  - seeds: <none>
[13:20:05.841]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.841] getGlobalsAndPackages() ...
[13:20:05.841] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.841] Resolving globals: FALSE
[13:20:05.842] Tweak future expression to call with '...' arguments ...
[13:20:05.842] {
[13:20:05.842]     do.call(function(...) {
[13:20:05.842]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.842]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.842]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.842]             on.exit(options(oopts), add = TRUE)
[13:20:05.842]         }
[13:20:05.842]         {
[13:20:05.842]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.842]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.842]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.842]             })
[13:20:05.842]         }
[13:20:05.842]     }, args = future.call.arguments)
[13:20:05.842] }
[13:20:05.842] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.842] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.842] - packages: [1] ‘stats’
[13:20:05.843] getGlobalsAndPackages() ... DONE
[13:20:05.843] run() for ‘Future’ ...
[13:20:05.843] - state: ‘created’
[13:20:05.843] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:05.843] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:05.844] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:05.844]   - Field: ‘label’
[13:20:05.844]   - Field: ‘local’
[13:20:05.844]   - Field: ‘owner’
[13:20:05.844]   - Field: ‘envir’
[13:20:05.844]   - Field: ‘packages’
[13:20:05.844]   - Field: ‘gc’
[13:20:05.844]   - Field: ‘conditions’
[13:20:05.844]   - Field: ‘expr’
[13:20:05.844]   - Field: ‘uuid’
[13:20:05.845]   - Field: ‘seed’
[13:20:05.845]   - Field: ‘version’
[13:20:05.845]   - Field: ‘result’
[13:20:05.845]   - Field: ‘asynchronous’
[13:20:05.845]   - Field: ‘calls’
[13:20:05.845]   - Field: ‘globals’
[13:20:05.845]   - Field: ‘stdout’
[13:20:05.845]   - Field: ‘earlySignal’
[13:20:05.845]   - Field: ‘lazy’
[13:20:05.845]   - Field: ‘state’
[13:20:05.846] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:05.846] - Launch lazy future ...
[13:20:05.846] Packages needed by the future expression (n = 1): ‘stats’
[13:20:05.846] Packages needed by future strategies (n = 0): <none>
[13:20:05.846] {
[13:20:05.846]     {
[13:20:05.846]         {
[13:20:05.846]             ...future.startTime <- base::Sys.time()
[13:20:05.846]             {
[13:20:05.846]                 {
[13:20:05.846]                   {
[13:20:05.846]                     {
[13:20:05.846]                       base::local({
[13:20:05.846]                         has_future <- base::requireNamespace("future", 
[13:20:05.846]                           quietly = TRUE)
[13:20:05.846]                         if (has_future) {
[13:20:05.846]                           ns <- base::getNamespace("future")
[13:20:05.846]                           version <- ns[[".package"]][["version"]]
[13:20:05.846]                           if (is.null(version)) 
[13:20:05.846]                             version <- utils::packageVersion("future")
[13:20:05.846]                         }
[13:20:05.846]                         else {
[13:20:05.846]                           version <- NULL
[13:20:05.846]                         }
[13:20:05.846]                         if (!has_future || version < "1.8.0") {
[13:20:05.846]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:05.846]                             "", base::R.version$version.string), 
[13:20:05.846]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:05.846]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:05.846]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:05.846]                               "release", "version")], collapse = " "), 
[13:20:05.846]                             hostname = base::Sys.info()[["nodename"]])
[13:20:05.846]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:05.846]                             info)
[13:20:05.846]                           info <- base::paste(info, collapse = "; ")
[13:20:05.846]                           if (!has_future) {
[13:20:05.846]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:05.846]                               info)
[13:20:05.846]                           }
[13:20:05.846]                           else {
[13:20:05.846]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:05.846]                               info, version)
[13:20:05.846]                           }
[13:20:05.846]                           base::stop(msg)
[13:20:05.846]                         }
[13:20:05.846]                       })
[13:20:05.846]                     }
[13:20:05.846]                     base::local({
[13:20:05.846]                       for (pkg in "stats") {
[13:20:05.846]                         base::loadNamespace(pkg)
[13:20:05.846]                         base::library(pkg, character.only = TRUE)
[13:20:05.846]                       }
[13:20:05.846]                     })
[13:20:05.846]                   }
[13:20:05.846]                   options(future.plan = NULL)
[13:20:05.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:05.846]                 }
[13:20:05.846]                 ...future.workdir <- getwd()
[13:20:05.846]             }
[13:20:05.846]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:05.846]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:05.846]         }
[13:20:05.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:05.846]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:05.846]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:05.846]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:05.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:05.846]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:05.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:05.846]             base::names(...future.oldOptions))
[13:20:05.846]     }
[13:20:05.846]     if (FALSE) {
[13:20:05.846]     }
[13:20:05.846]     else {
[13:20:05.846]         if (TRUE) {
[13:20:05.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:05.846]                 open = "w")
[13:20:05.846]         }
[13:20:05.846]         else {
[13:20:05.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:05.846]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:05.846]         }
[13:20:05.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:05.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:05.846]             base::sink(type = "output", split = FALSE)
[13:20:05.846]             base::close(...future.stdout)
[13:20:05.846]         }, add = TRUE)
[13:20:05.846]     }
[13:20:05.846]     ...future.frame <- base::sys.nframe()
[13:20:05.846]     ...future.conditions <- base::list()
[13:20:05.846]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:05.846]     if (FALSE) {
[13:20:05.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:05.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:05.846]     }
[13:20:05.846]     ...future.result <- base::tryCatch({
[13:20:05.846]         base::withCallingHandlers({
[13:20:05.846]             ...future.value <- base::withVisible(base::local({
[13:20:05.846]                 do.call(function(...) {
[13:20:05.846]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.846]                   if (!identical(...future.globals.maxSize.org, 
[13:20:05.846]                     ...future.globals.maxSize)) {
[13:20:05.846]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.846]                     on.exit(options(oopts), add = TRUE)
[13:20:05.846]                   }
[13:20:05.846]                   {
[13:20:05.846]                     lapply(seq_along(...future.elements_ii), 
[13:20:05.846]                       FUN = function(jj) {
[13:20:05.846]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.846]                         ...future.FUN(...future.X_jj, ...)
[13:20:05.846]                       })
[13:20:05.846]                   }
[13:20:05.846]                 }, args = future.call.arguments)
[13:20:05.846]             }))
[13:20:05.846]             future::FutureResult(value = ...future.value$value, 
[13:20:05.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.846]                   ...future.rng), globalenv = if (FALSE) 
[13:20:05.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:05.846]                     ...future.globalenv.names))
[13:20:05.846]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:05.846]         }, condition = base::local({
[13:20:05.846]             c <- base::c
[13:20:05.846]             inherits <- base::inherits
[13:20:05.846]             invokeRestart <- base::invokeRestart
[13:20:05.846]             length <- base::length
[13:20:05.846]             list <- base::list
[13:20:05.846]             seq.int <- base::seq.int
[13:20:05.846]             signalCondition <- base::signalCondition
[13:20:05.846]             sys.calls <- base::sys.calls
[13:20:05.846]             `[[` <- base::`[[`
[13:20:05.846]             `+` <- base::`+`
[13:20:05.846]             `<<-` <- base::`<<-`
[13:20:05.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:05.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:05.846]                   3L)]
[13:20:05.846]             }
[13:20:05.846]             function(cond) {
[13:20:05.846]                 is_error <- inherits(cond, "error")
[13:20:05.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:05.846]                   NULL)
[13:20:05.846]                 if (is_error) {
[13:20:05.846]                   sessionInformation <- function() {
[13:20:05.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:05.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:05.846]                       search = base::search(), system = base::Sys.info())
[13:20:05.846]                   }
[13:20:05.846]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:05.846]                     cond$call), session = sessionInformation(), 
[13:20:05.846]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:05.846]                   signalCondition(cond)
[13:20:05.846]                 }
[13:20:05.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:05.846]                 "immediateCondition"))) {
[13:20:05.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:05.846]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:05.846]                   if (TRUE && !signal) {
[13:20:05.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.846]                     {
[13:20:05.846]                       inherits <- base::inherits
[13:20:05.846]                       invokeRestart <- base::invokeRestart
[13:20:05.846]                       is.null <- base::is.null
[13:20:05.846]                       muffled <- FALSE
[13:20:05.846]                       if (inherits(cond, "message")) {
[13:20:05.846]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.846]                         if (muffled) 
[13:20:05.846]                           invokeRestart("muffleMessage")
[13:20:05.846]                       }
[13:20:05.846]                       else if (inherits(cond, "warning")) {
[13:20:05.846]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.846]                         if (muffled) 
[13:20:05.846]                           invokeRestart("muffleWarning")
[13:20:05.846]                       }
[13:20:05.846]                       else if (inherits(cond, "condition")) {
[13:20:05.846]                         if (!is.null(pattern)) {
[13:20:05.846]                           computeRestarts <- base::computeRestarts
[13:20:05.846]                           grepl <- base::grepl
[13:20:05.846]                           restarts <- computeRestarts(cond)
[13:20:05.846]                           for (restart in restarts) {
[13:20:05.846]                             name <- restart$name
[13:20:05.846]                             if (is.null(name)) 
[13:20:05.846]                               next
[13:20:05.846]                             if (!grepl(pattern, name)) 
[13:20:05.846]                               next
[13:20:05.846]                             invokeRestart(restart)
[13:20:05.846]                             muffled <- TRUE
[13:20:05.846]                             break
[13:20:05.846]                           }
[13:20:05.846]                         }
[13:20:05.846]                       }
[13:20:05.846]                       invisible(muffled)
[13:20:05.846]                     }
[13:20:05.846]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.846]                   }
[13:20:05.846]                 }
[13:20:05.846]                 else {
[13:20:05.846]                   if (TRUE) {
[13:20:05.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.846]                     {
[13:20:05.846]                       inherits <- base::inherits
[13:20:05.846]                       invokeRestart <- base::invokeRestart
[13:20:05.846]                       is.null <- base::is.null
[13:20:05.846]                       muffled <- FALSE
[13:20:05.846]                       if (inherits(cond, "message")) {
[13:20:05.846]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.846]                         if (muffled) 
[13:20:05.846]                           invokeRestart("muffleMessage")
[13:20:05.846]                       }
[13:20:05.846]                       else if (inherits(cond, "warning")) {
[13:20:05.846]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.846]                         if (muffled) 
[13:20:05.846]                           invokeRestart("muffleWarning")
[13:20:05.846]                       }
[13:20:05.846]                       else if (inherits(cond, "condition")) {
[13:20:05.846]                         if (!is.null(pattern)) {
[13:20:05.846]                           computeRestarts <- base::computeRestarts
[13:20:05.846]                           grepl <- base::grepl
[13:20:05.846]                           restarts <- computeRestarts(cond)
[13:20:05.846]                           for (restart in restarts) {
[13:20:05.846]                             name <- restart$name
[13:20:05.846]                             if (is.null(name)) 
[13:20:05.846]                               next
[13:20:05.846]                             if (!grepl(pattern, name)) 
[13:20:05.846]                               next
[13:20:05.846]                             invokeRestart(restart)
[13:20:05.846]                             muffled <- TRUE
[13:20:05.846]                             break
[13:20:05.846]                           }
[13:20:05.846]                         }
[13:20:05.846]                       }
[13:20:05.846]                       invisible(muffled)
[13:20:05.846]                     }
[13:20:05.846]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.846]                   }
[13:20:05.846]                 }
[13:20:05.846]             }
[13:20:05.846]         }))
[13:20:05.846]     }, error = function(ex) {
[13:20:05.846]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:05.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.846]                 ...future.rng), started = ...future.startTime, 
[13:20:05.846]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:05.846]             version = "1.8"), class = "FutureResult")
[13:20:05.846]     }, finally = {
[13:20:05.846]         if (!identical(...future.workdir, getwd())) 
[13:20:05.846]             setwd(...future.workdir)
[13:20:05.846]         {
[13:20:05.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:05.846]                 ...future.oldOptions$nwarnings <- NULL
[13:20:05.846]             }
[13:20:05.846]             base::options(...future.oldOptions)
[13:20:05.846]             if (.Platform$OS.type == "windows") {
[13:20:05.846]                 old_names <- names(...future.oldEnvVars)
[13:20:05.846]                 envs <- base::Sys.getenv()
[13:20:05.846]                 names <- names(envs)
[13:20:05.846]                 common <- intersect(names, old_names)
[13:20:05.846]                 added <- setdiff(names, old_names)
[13:20:05.846]                 removed <- setdiff(old_names, names)
[13:20:05.846]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:05.846]                   envs[common]]
[13:20:05.846]                 NAMES <- toupper(changed)
[13:20:05.846]                 args <- list()
[13:20:05.846]                 for (kk in seq_along(NAMES)) {
[13:20:05.846]                   name <- changed[[kk]]
[13:20:05.846]                   NAME <- NAMES[[kk]]
[13:20:05.846]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.846]                     next
[13:20:05.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.846]                 }
[13:20:05.846]                 NAMES <- toupper(added)
[13:20:05.846]                 for (kk in seq_along(NAMES)) {
[13:20:05.846]                   name <- added[[kk]]
[13:20:05.846]                   NAME <- NAMES[[kk]]
[13:20:05.846]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.846]                     next
[13:20:05.846]                   args[[name]] <- ""
[13:20:05.846]                 }
[13:20:05.846]                 NAMES <- toupper(removed)
[13:20:05.846]                 for (kk in seq_along(NAMES)) {
[13:20:05.846]                   name <- removed[[kk]]
[13:20:05.846]                   NAME <- NAMES[[kk]]
[13:20:05.846]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.846]                     next
[13:20:05.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.846]                 }
[13:20:05.846]                 if (length(args) > 0) 
[13:20:05.846]                   base::do.call(base::Sys.setenv, args = args)
[13:20:05.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:05.846]             }
[13:20:05.846]             else {
[13:20:05.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:05.846]             }
[13:20:05.846]             {
[13:20:05.846]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:05.846]                   0L) {
[13:20:05.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:05.846]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:05.846]                   base::options(opts)
[13:20:05.846]                 }
[13:20:05.846]                 {
[13:20:05.846]                   {
[13:20:05.846]                     NULL
[13:20:05.846]                     RNGkind("Mersenne-Twister")
[13:20:05.846]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:05.846]                       inherits = FALSE)
[13:20:05.846]                   }
[13:20:05.846]                   options(future.plan = NULL)
[13:20:05.846]                   if (is.na(NA_character_)) 
[13:20:05.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:05.846]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:05.846]                   {
[13:20:05.846]                     future <- SequentialFuture(..., envir = envir)
[13:20:05.846]                     if (!future$lazy) 
[13:20:05.846]                       future <- run(future)
[13:20:05.846]                     invisible(future)
[13:20:05.846]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:05.846]                 }
[13:20:05.846]             }
[13:20:05.846]         }
[13:20:05.846]     })
[13:20:05.846]     if (TRUE) {
[13:20:05.846]         base::sink(type = "output", split = FALSE)
[13:20:05.846]         if (TRUE) {
[13:20:05.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:05.846]         }
[13:20:05.846]         else {
[13:20:05.846]             ...future.result["stdout"] <- base::list(NULL)
[13:20:05.846]         }
[13:20:05.846]         base::close(...future.stdout)
[13:20:05.846]         ...future.stdout <- NULL
[13:20:05.846]     }
[13:20:05.846]     ...future.result$conditions <- ...future.conditions
[13:20:05.846]     ...future.result$finished <- base::Sys.time()
[13:20:05.846]     ...future.result
[13:20:05.846] }
[13:20:05.848] assign_globals() ...
[13:20:05.848] List of 5
[13:20:05.848]  $ ...future.FUN            :function (x, ...)  
[13:20:05.848]  $ future.call.arguments    :List of 1
[13:20:05.848]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:20:05.848]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.848]  $ ...future.elements_ii    :List of 3
[13:20:05.848]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:20:05.848]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:20:05.848]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:20:05.848]  $ ...future.seeds_ii       : NULL
[13:20:05.848]  $ ...future.globals.maxSize: NULL
[13:20:05.848]  - attr(*, "where")=List of 5
[13:20:05.848]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:05.848]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:05.848]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:05.848]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:05.848]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:05.848]  - attr(*, "resolved")= logi FALSE
[13:20:05.848]  - attr(*, "total_size")= num 1328
[13:20:05.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.848]  - attr(*, "already-done")= logi TRUE
[13:20:05.854] - copied ‘...future.FUN’ to environment
[13:20:05.854] - copied ‘future.call.arguments’ to environment
[13:20:05.854] - copied ‘...future.elements_ii’ to environment
[13:20:05.854] - copied ‘...future.seeds_ii’ to environment
[13:20:05.855] - copied ‘...future.globals.maxSize’ to environment
[13:20:05.855] assign_globals() ... done
[13:20:05.855] plan(): Setting new future strategy stack:
[13:20:05.855] List of future strategies:
[13:20:05.855] 1. sequential:
[13:20:05.855]    - args: function (..., envir = parent.frame())
[13:20:05.855]    - tweaked: FALSE
[13:20:05.855]    - call: NULL
[13:20:05.856] plan(): nbrOfWorkers() = 1
[13:20:05.857] plan(): Setting new future strategy stack:
[13:20:05.857] List of future strategies:
[13:20:05.857] 1. sequential:
[13:20:05.857]    - args: function (..., envir = parent.frame())
[13:20:05.857]    - tweaked: FALSE
[13:20:05.857]    - call: plan(strategy)
[13:20:05.857] plan(): nbrOfWorkers() = 1
[13:20:05.857] SequentialFuture started (and completed)
[13:20:05.857] - Launch lazy future ... done
[13:20:05.858] run() for ‘SequentialFuture’ ... done
[13:20:05.858] Created future:
[13:20:05.858] SequentialFuture:
[13:20:05.858] Label: ‘future_eapply-1’
[13:20:05.858] Expression:
[13:20:05.858] {
[13:20:05.858]     do.call(function(...) {
[13:20:05.858]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.858]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.858]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.858]             on.exit(options(oopts), add = TRUE)
[13:20:05.858]         }
[13:20:05.858]         {
[13:20:05.858]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.858]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.858]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.858]             })
[13:20:05.858]         }
[13:20:05.858]     }, args = future.call.arguments)
[13:20:05.858] }
[13:20:05.858] Lazy evaluation: FALSE
[13:20:05.858] Asynchronous evaluation: FALSE
[13:20:05.858] Local evaluation: TRUE
[13:20:05.858] Environment: R_GlobalEnv
[13:20:05.858] Capture standard output: TRUE
[13:20:05.858] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:05.858] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:05.858] Packages: 1 packages (‘stats’)
[13:20:05.858] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:05.858] Resolved: TRUE
[13:20:05.858] Value: 1.29 KiB of class ‘list’
[13:20:05.858] Early signaling: FALSE
[13:20:05.858] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:05.858] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:05.859] Chunk #1 of 1 ... DONE
[13:20:05.859] Launching 1 futures (chunks) ... DONE
[13:20:05.859] Resolving 1 futures (chunks) ...
[13:20:05.859] resolve() on list ...
[13:20:05.859]  recursive: 0
[13:20:05.859]  length: 1
[13:20:05.859] 
[13:20:05.859] resolved() for ‘SequentialFuture’ ...
[13:20:05.860] - state: ‘finished’
[13:20:05.860] - run: TRUE
[13:20:05.860] - result: ‘FutureResult’
[13:20:05.860] resolved() for ‘SequentialFuture’ ... done
[13:20:05.860] Future #1
[13:20:05.860] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:05.860] - nx: 1
[13:20:05.860] - relay: TRUE
[13:20:05.860] - stdout: TRUE
[13:20:05.862] - signal: TRUE
[13:20:05.862] - resignal: FALSE
[13:20:05.862] - force: TRUE
[13:20:05.862] - relayed: [n=1] FALSE
[13:20:05.862] - queued futures: [n=1] FALSE
[13:20:05.863]  - until=1
[13:20:05.863]  - relaying element #1
[13:20:05.863] - relayed: [n=1] TRUE
[13:20:05.863] - queued futures: [n=1] TRUE
[13:20:05.863] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:05.863]  length: 0 (resolved future 1)
[13:20:05.863] Relaying remaining futures
[13:20:05.863] signalConditionsASAP(NULL, pos=0) ...
[13:20:05.863] - nx: 1
[13:20:05.863] - relay: TRUE
[13:20:05.864] - stdout: TRUE
[13:20:05.864] - signal: TRUE
[13:20:05.864] - resignal: FALSE
[13:20:05.864] - force: TRUE
[13:20:05.864] - relayed: [n=1] TRUE
[13:20:05.864] - queued futures: [n=1] TRUE
 - flush all
[13:20:05.864] - relayed: [n=1] TRUE
[13:20:05.864] - queued futures: [n=1] TRUE
[13:20:05.864] signalConditionsASAP(NULL, pos=0) ... done
[13:20:05.864] resolve() on list ... DONE
[13:20:05.865]  - Number of value chunks collected: 1
[13:20:05.865] Resolving 1 futures (chunks) ... DONE
[13:20:05.865] Reducing values from 1 chunks ...
[13:20:05.865]  - Number of values collected after concatenation: 3
[13:20:05.865]  - Number of values expected: 3
[13:20:05.865] Reducing values from 1 chunks ... DONE
[13:20:05.865] future_lapply() ... DONE
[13:20:05.866] future_lapply() ...
[13:20:05.867] Number of chunks: 1
[13:20:05.867] getGlobalsAndPackagesXApply() ...
[13:20:05.867]  - future.globals: TRUE
[13:20:05.867] getGlobalsAndPackages() ...
[13:20:05.867] Searching for globals...
[13:20:05.868] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:05.869] Searching for globals ... DONE
[13:20:05.869] Resolving globals: FALSE
[13:20:05.869] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:20:05.869] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:20:05.870] - globals: [1] ‘FUN’
[13:20:05.870] - packages: [1] ‘stats’
[13:20:05.870] getGlobalsAndPackages() ... DONE
[13:20:05.870]  - globals found/used: [n=1] ‘FUN’
[13:20:05.870]  - needed namespaces: [n=1] ‘stats’
[13:20:05.870] Finding globals ... DONE
[13:20:05.870]  - use_args: TRUE
[13:20:05.870]  - Getting '...' globals ...
[13:20:05.871] resolve() on list ...
[13:20:05.871]  recursive: 0
[13:20:05.871]  length: 1
[13:20:05.871]  elements: ‘...’
[13:20:05.871]  length: 0 (resolved future 1)
[13:20:05.871] resolve() on list ... DONE
[13:20:05.871]    - '...' content: [n=0] 
[13:20:05.871] List of 1
[13:20:05.871]  $ ...: list()
[13:20:05.871]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.871]  - attr(*, "where")=List of 1
[13:20:05.871]   ..$ ...:<environment: 0x558fd7964790> 
[13:20:05.871]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.871]  - attr(*, "resolved")= logi TRUE
[13:20:05.871]  - attr(*, "total_size")= num NA
[13:20:05.874]  - Getting '...' globals ... DONE
[13:20:05.874] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:05.874] List of 2
[13:20:05.874]  $ ...future.FUN:function (x, ...)  
[13:20:05.874]  $ ...          : list()
[13:20:05.874]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.874]  - attr(*, "where")=List of 2
[13:20:05.874]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:05.874]   ..$ ...          :<environment: 0x558fd7964790> 
[13:20:05.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.874]  - attr(*, "resolved")= logi FALSE
[13:20:05.874]  - attr(*, "total_size")= num 1248
[13:20:05.877] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:05.877] getGlobalsAndPackagesXApply() ... DONE
[13:20:05.877] Number of futures (= number of chunks): 1
[13:20:05.877] Launching 1 futures (chunks) ...
[13:20:05.877] Chunk #1 of 1 ...
[13:20:05.877]  - Finding globals in 'X' for chunk #1 ...
[13:20:05.877] getGlobalsAndPackages() ...
[13:20:05.878] Searching for globals...
[13:20:05.878] 
[13:20:05.878] Searching for globals ... DONE
[13:20:05.878] - globals: [0] <none>
[13:20:05.878] getGlobalsAndPackages() ... DONE
[13:20:05.878]    + additional globals found: [n=0] 
[13:20:05.878]    + additional namespaces needed: [n=0] 
[13:20:05.878]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:05.878]  - seeds: <none>
[13:20:05.878]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.879] getGlobalsAndPackages() ...
[13:20:05.879] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.879] Resolving globals: FALSE
[13:20:05.879] Tweak future expression to call with '...' arguments ...
[13:20:05.879] {
[13:20:05.879]     do.call(function(...) {
[13:20:05.879]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.879]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.879]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.879]             on.exit(options(oopts), add = TRUE)
[13:20:05.879]         }
[13:20:05.879]         {
[13:20:05.879]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.879]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.879]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.879]             })
[13:20:05.879]         }
[13:20:05.879]     }, args = future.call.arguments)
[13:20:05.879] }
[13:20:05.879] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.880] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.880] - packages: [1] ‘stats’
[13:20:05.880] getGlobalsAndPackages() ... DONE
[13:20:05.880] run() for ‘Future’ ...
[13:20:05.880] - state: ‘created’
[13:20:05.880] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:05.881] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:05.881] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:05.881]   - Field: ‘label’
[13:20:05.881]   - Field: ‘local’
[13:20:05.881]   - Field: ‘owner’
[13:20:05.881]   - Field: ‘envir’
[13:20:05.881]   - Field: ‘packages’
[13:20:05.881]   - Field: ‘gc’
[13:20:05.882]   - Field: ‘conditions’
[13:20:05.882]   - Field: ‘expr’
[13:20:05.882]   - Field: ‘uuid’
[13:20:05.882]   - Field: ‘seed’
[13:20:05.882]   - Field: ‘version’
[13:20:05.882]   - Field: ‘result’
[13:20:05.882]   - Field: ‘asynchronous’
[13:20:05.882]   - Field: ‘calls’
[13:20:05.882]   - Field: ‘globals’
[13:20:05.882]   - Field: ‘stdout’
[13:20:05.882]   - Field: ‘earlySignal’
[13:20:05.882]   - Field: ‘lazy’
[13:20:05.883]   - Field: ‘state’
[13:20:05.883] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:05.883] - Launch lazy future ...
[13:20:05.883] Packages needed by the future expression (n = 1): ‘stats’
[13:20:05.883] Packages needed by future strategies (n = 0): <none>
[13:20:05.884] {
[13:20:05.884]     {
[13:20:05.884]         {
[13:20:05.884]             ...future.startTime <- base::Sys.time()
[13:20:05.884]             {
[13:20:05.884]                 {
[13:20:05.884]                   {
[13:20:05.884]                     {
[13:20:05.884]                       base::local({
[13:20:05.884]                         has_future <- base::requireNamespace("future", 
[13:20:05.884]                           quietly = TRUE)
[13:20:05.884]                         if (has_future) {
[13:20:05.884]                           ns <- base::getNamespace("future")
[13:20:05.884]                           version <- ns[[".package"]][["version"]]
[13:20:05.884]                           if (is.null(version)) 
[13:20:05.884]                             version <- utils::packageVersion("future")
[13:20:05.884]                         }
[13:20:05.884]                         else {
[13:20:05.884]                           version <- NULL
[13:20:05.884]                         }
[13:20:05.884]                         if (!has_future || version < "1.8.0") {
[13:20:05.884]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:05.884]                             "", base::R.version$version.string), 
[13:20:05.884]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:05.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:05.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:05.884]                               "release", "version")], collapse = " "), 
[13:20:05.884]                             hostname = base::Sys.info()[["nodename"]])
[13:20:05.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:05.884]                             info)
[13:20:05.884]                           info <- base::paste(info, collapse = "; ")
[13:20:05.884]                           if (!has_future) {
[13:20:05.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:05.884]                               info)
[13:20:05.884]                           }
[13:20:05.884]                           else {
[13:20:05.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:05.884]                               info, version)
[13:20:05.884]                           }
[13:20:05.884]                           base::stop(msg)
[13:20:05.884]                         }
[13:20:05.884]                       })
[13:20:05.884]                     }
[13:20:05.884]                     base::local({
[13:20:05.884]                       for (pkg in "stats") {
[13:20:05.884]                         base::loadNamespace(pkg)
[13:20:05.884]                         base::library(pkg, character.only = TRUE)
[13:20:05.884]                       }
[13:20:05.884]                     })
[13:20:05.884]                   }
[13:20:05.884]                   options(future.plan = NULL)
[13:20:05.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:05.884]                 }
[13:20:05.884]                 ...future.workdir <- getwd()
[13:20:05.884]             }
[13:20:05.884]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:05.884]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:05.884]         }
[13:20:05.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:05.884]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:05.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:05.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:05.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:05.884]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:05.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:05.884]             base::names(...future.oldOptions))
[13:20:05.884]     }
[13:20:05.884]     if (FALSE) {
[13:20:05.884]     }
[13:20:05.884]     else {
[13:20:05.884]         if (TRUE) {
[13:20:05.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:05.884]                 open = "w")
[13:20:05.884]         }
[13:20:05.884]         else {
[13:20:05.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:05.884]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:05.884]         }
[13:20:05.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:05.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:05.884]             base::sink(type = "output", split = FALSE)
[13:20:05.884]             base::close(...future.stdout)
[13:20:05.884]         }, add = TRUE)
[13:20:05.884]     }
[13:20:05.884]     ...future.frame <- base::sys.nframe()
[13:20:05.884]     ...future.conditions <- base::list()
[13:20:05.884]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:05.884]     if (FALSE) {
[13:20:05.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:05.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:05.884]     }
[13:20:05.884]     ...future.result <- base::tryCatch({
[13:20:05.884]         base::withCallingHandlers({
[13:20:05.884]             ...future.value <- base::withVisible(base::local({
[13:20:05.884]                 do.call(function(...) {
[13:20:05.884]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.884]                   if (!identical(...future.globals.maxSize.org, 
[13:20:05.884]                     ...future.globals.maxSize)) {
[13:20:05.884]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.884]                     on.exit(options(oopts), add = TRUE)
[13:20:05.884]                   }
[13:20:05.884]                   {
[13:20:05.884]                     lapply(seq_along(...future.elements_ii), 
[13:20:05.884]                       FUN = function(jj) {
[13:20:05.884]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.884]                         ...future.FUN(...future.X_jj, ...)
[13:20:05.884]                       })
[13:20:05.884]                   }
[13:20:05.884]                 }, args = future.call.arguments)
[13:20:05.884]             }))
[13:20:05.884]             future::FutureResult(value = ...future.value$value, 
[13:20:05.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.884]                   ...future.rng), globalenv = if (FALSE) 
[13:20:05.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:05.884]                     ...future.globalenv.names))
[13:20:05.884]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:05.884]         }, condition = base::local({
[13:20:05.884]             c <- base::c
[13:20:05.884]             inherits <- base::inherits
[13:20:05.884]             invokeRestart <- base::invokeRestart
[13:20:05.884]             length <- base::length
[13:20:05.884]             list <- base::list
[13:20:05.884]             seq.int <- base::seq.int
[13:20:05.884]             signalCondition <- base::signalCondition
[13:20:05.884]             sys.calls <- base::sys.calls
[13:20:05.884]             `[[` <- base::`[[`
[13:20:05.884]             `+` <- base::`+`
[13:20:05.884]             `<<-` <- base::`<<-`
[13:20:05.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:05.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:05.884]                   3L)]
[13:20:05.884]             }
[13:20:05.884]             function(cond) {
[13:20:05.884]                 is_error <- inherits(cond, "error")
[13:20:05.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:05.884]                   NULL)
[13:20:05.884]                 if (is_error) {
[13:20:05.884]                   sessionInformation <- function() {
[13:20:05.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:05.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:05.884]                       search = base::search(), system = base::Sys.info())
[13:20:05.884]                   }
[13:20:05.884]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:05.884]                     cond$call), session = sessionInformation(), 
[13:20:05.884]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:05.884]                   signalCondition(cond)
[13:20:05.884]                 }
[13:20:05.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:05.884]                 "immediateCondition"))) {
[13:20:05.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:05.884]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:05.884]                   if (TRUE && !signal) {
[13:20:05.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.884]                     {
[13:20:05.884]                       inherits <- base::inherits
[13:20:05.884]                       invokeRestart <- base::invokeRestart
[13:20:05.884]                       is.null <- base::is.null
[13:20:05.884]                       muffled <- FALSE
[13:20:05.884]                       if (inherits(cond, "message")) {
[13:20:05.884]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.884]                         if (muffled) 
[13:20:05.884]                           invokeRestart("muffleMessage")
[13:20:05.884]                       }
[13:20:05.884]                       else if (inherits(cond, "warning")) {
[13:20:05.884]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.884]                         if (muffled) 
[13:20:05.884]                           invokeRestart("muffleWarning")
[13:20:05.884]                       }
[13:20:05.884]                       else if (inherits(cond, "condition")) {
[13:20:05.884]                         if (!is.null(pattern)) {
[13:20:05.884]                           computeRestarts <- base::computeRestarts
[13:20:05.884]                           grepl <- base::grepl
[13:20:05.884]                           restarts <- computeRestarts(cond)
[13:20:05.884]                           for (restart in restarts) {
[13:20:05.884]                             name <- restart$name
[13:20:05.884]                             if (is.null(name)) 
[13:20:05.884]                               next
[13:20:05.884]                             if (!grepl(pattern, name)) 
[13:20:05.884]                               next
[13:20:05.884]                             invokeRestart(restart)
[13:20:05.884]                             muffled <- TRUE
[13:20:05.884]                             break
[13:20:05.884]                           }
[13:20:05.884]                         }
[13:20:05.884]                       }
[13:20:05.884]                       invisible(muffled)
[13:20:05.884]                     }
[13:20:05.884]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.884]                   }
[13:20:05.884]                 }
[13:20:05.884]                 else {
[13:20:05.884]                   if (TRUE) {
[13:20:05.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.884]                     {
[13:20:05.884]                       inherits <- base::inherits
[13:20:05.884]                       invokeRestart <- base::invokeRestart
[13:20:05.884]                       is.null <- base::is.null
[13:20:05.884]                       muffled <- FALSE
[13:20:05.884]                       if (inherits(cond, "message")) {
[13:20:05.884]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.884]                         if (muffled) 
[13:20:05.884]                           invokeRestart("muffleMessage")
[13:20:05.884]                       }
[13:20:05.884]                       else if (inherits(cond, "warning")) {
[13:20:05.884]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.884]                         if (muffled) 
[13:20:05.884]                           invokeRestart("muffleWarning")
[13:20:05.884]                       }
[13:20:05.884]                       else if (inherits(cond, "condition")) {
[13:20:05.884]                         if (!is.null(pattern)) {
[13:20:05.884]                           computeRestarts <- base::computeRestarts
[13:20:05.884]                           grepl <- base::grepl
[13:20:05.884]                           restarts <- computeRestarts(cond)
[13:20:05.884]                           for (restart in restarts) {
[13:20:05.884]                             name <- restart$name
[13:20:05.884]                             if (is.null(name)) 
[13:20:05.884]                               next
[13:20:05.884]                             if (!grepl(pattern, name)) 
[13:20:05.884]                               next
[13:20:05.884]                             invokeRestart(restart)
[13:20:05.884]                             muffled <- TRUE
[13:20:05.884]                             break
[13:20:05.884]                           }
[13:20:05.884]                         }
[13:20:05.884]                       }
[13:20:05.884]                       invisible(muffled)
[13:20:05.884]                     }
[13:20:05.884]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.884]                   }
[13:20:05.884]                 }
[13:20:05.884]             }
[13:20:05.884]         }))
[13:20:05.884]     }, error = function(ex) {
[13:20:05.884]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:05.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.884]                 ...future.rng), started = ...future.startTime, 
[13:20:05.884]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:05.884]             version = "1.8"), class = "FutureResult")
[13:20:05.884]     }, finally = {
[13:20:05.884]         if (!identical(...future.workdir, getwd())) 
[13:20:05.884]             setwd(...future.workdir)
[13:20:05.884]         {
[13:20:05.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:05.884]                 ...future.oldOptions$nwarnings <- NULL
[13:20:05.884]             }
[13:20:05.884]             base::options(...future.oldOptions)
[13:20:05.884]             if (.Platform$OS.type == "windows") {
[13:20:05.884]                 old_names <- names(...future.oldEnvVars)
[13:20:05.884]                 envs <- base::Sys.getenv()
[13:20:05.884]                 names <- names(envs)
[13:20:05.884]                 common <- intersect(names, old_names)
[13:20:05.884]                 added <- setdiff(names, old_names)
[13:20:05.884]                 removed <- setdiff(old_names, names)
[13:20:05.884]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:05.884]                   envs[common]]
[13:20:05.884]                 NAMES <- toupper(changed)
[13:20:05.884]                 args <- list()
[13:20:05.884]                 for (kk in seq_along(NAMES)) {
[13:20:05.884]                   name <- changed[[kk]]
[13:20:05.884]                   NAME <- NAMES[[kk]]
[13:20:05.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.884]                     next
[13:20:05.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.884]                 }
[13:20:05.884]                 NAMES <- toupper(added)
[13:20:05.884]                 for (kk in seq_along(NAMES)) {
[13:20:05.884]                   name <- added[[kk]]
[13:20:05.884]                   NAME <- NAMES[[kk]]
[13:20:05.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.884]                     next
[13:20:05.884]                   args[[name]] <- ""
[13:20:05.884]                 }
[13:20:05.884]                 NAMES <- toupper(removed)
[13:20:05.884]                 for (kk in seq_along(NAMES)) {
[13:20:05.884]                   name <- removed[[kk]]
[13:20:05.884]                   NAME <- NAMES[[kk]]
[13:20:05.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.884]                     next
[13:20:05.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.884]                 }
[13:20:05.884]                 if (length(args) > 0) 
[13:20:05.884]                   base::do.call(base::Sys.setenv, args = args)
[13:20:05.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:05.884]             }
[13:20:05.884]             else {
[13:20:05.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:05.884]             }
[13:20:05.884]             {
[13:20:05.884]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:05.884]                   0L) {
[13:20:05.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:05.884]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:05.884]                   base::options(opts)
[13:20:05.884]                 }
[13:20:05.884]                 {
[13:20:05.884]                   {
[13:20:05.884]                     NULL
[13:20:05.884]                     RNGkind("Mersenne-Twister")
[13:20:05.884]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:05.884]                       inherits = FALSE)
[13:20:05.884]                   }
[13:20:05.884]                   options(future.plan = NULL)
[13:20:05.884]                   if (is.na(NA_character_)) 
[13:20:05.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:05.884]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:05.884]                   {
[13:20:05.884]                     future <- SequentialFuture(..., envir = envir)
[13:20:05.884]                     if (!future$lazy) 
[13:20:05.884]                       future <- run(future)
[13:20:05.884]                     invisible(future)
[13:20:05.884]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:05.884]                 }
[13:20:05.884]             }
[13:20:05.884]         }
[13:20:05.884]     })
[13:20:05.884]     if (TRUE) {
[13:20:05.884]         base::sink(type = "output", split = FALSE)
[13:20:05.884]         if (TRUE) {
[13:20:05.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:05.884]         }
[13:20:05.884]         else {
[13:20:05.884]             ...future.result["stdout"] <- base::list(NULL)
[13:20:05.884]         }
[13:20:05.884]         base::close(...future.stdout)
[13:20:05.884]         ...future.stdout <- NULL
[13:20:05.884]     }
[13:20:05.884]     ...future.result$conditions <- ...future.conditions
[13:20:05.884]     ...future.result$finished <- base::Sys.time()
[13:20:05.884]     ...future.result
[13:20:05.884] }
[13:20:05.885] assign_globals() ...
[13:20:05.886] List of 5
[13:20:05.886]  $ ...future.FUN            :function (x, ...)  
[13:20:05.886]  $ future.call.arguments    : list()
[13:20:05.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.886]  $ ...future.elements_ii    :List of 3
[13:20:05.886]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:20:05.886]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:20:05.886]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:20:05.886]  $ ...future.seeds_ii       : NULL
[13:20:05.886]  $ ...future.globals.maxSize: NULL
[13:20:05.886]  - attr(*, "where")=List of 5
[13:20:05.886]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:05.886]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:05.886]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:05.886]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:05.886]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:05.886]  - attr(*, "resolved")= logi FALSE
[13:20:05.886]  - attr(*, "total_size")= num 1248
[13:20:05.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.886]  - attr(*, "already-done")= logi TRUE
[13:20:05.893] - copied ‘...future.FUN’ to environment
[13:20:05.893] - copied ‘future.call.arguments’ to environment
[13:20:05.893] - copied ‘...future.elements_ii’ to environment
[13:20:05.893] - copied ‘...future.seeds_ii’ to environment
[13:20:05.893] - copied ‘...future.globals.maxSize’ to environment
[13:20:05.893] assign_globals() ... done
[13:20:05.893] plan(): Setting new future strategy stack:
[13:20:05.894] List of future strategies:
[13:20:05.894] 1. sequential:
[13:20:05.894]    - args: function (..., envir = parent.frame())
[13:20:05.894]    - tweaked: FALSE
[13:20:05.894]    - call: NULL
[13:20:05.894] plan(): nbrOfWorkers() = 1
[13:20:05.895] plan(): Setting new future strategy stack:
[13:20:05.895] List of future strategies:
[13:20:05.895] 1. sequential:
[13:20:05.895]    - args: function (..., envir = parent.frame())
[13:20:05.895]    - tweaked: FALSE
[13:20:05.895]    - call: plan(strategy)
[13:20:05.896] plan(): nbrOfWorkers() = 1
[13:20:05.896] SequentialFuture started (and completed)
[13:20:05.896] - Launch lazy future ... done
[13:20:05.896] run() for ‘SequentialFuture’ ... done
[13:20:05.896] Created future:
[13:20:05.896] SequentialFuture:
[13:20:05.896] Label: ‘future_eapply-1’
[13:20:05.896] Expression:
[13:20:05.896] {
[13:20:05.896]     do.call(function(...) {
[13:20:05.896]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.896]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.896]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.896]             on.exit(options(oopts), add = TRUE)
[13:20:05.896]         }
[13:20:05.896]         {
[13:20:05.896]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.896]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.896]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.896]             })
[13:20:05.896]         }
[13:20:05.896]     }, args = future.call.arguments)
[13:20:05.896] }
[13:20:05.896] Lazy evaluation: FALSE
[13:20:05.896] Asynchronous evaluation: FALSE
[13:20:05.896] Local evaluation: TRUE
[13:20:05.896] Environment: R_GlobalEnv
[13:20:05.896] Capture standard output: TRUE
[13:20:05.896] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:05.896] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:05.896] Packages: 1 packages (‘stats’)
[13:20:05.896] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:05.896] Resolved: TRUE
[13:20:05.896] Value: 1.71 KiB of class ‘list’
[13:20:05.896] Early signaling: FALSE
[13:20:05.896] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:05.896] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:05.897] Chunk #1 of 1 ... DONE
[13:20:05.897] Launching 1 futures (chunks) ... DONE
[13:20:05.898] Resolving 1 futures (chunks) ...
[13:20:05.898] resolve() on list ...
[13:20:05.898]  recursive: 0
[13:20:05.898]  length: 1
[13:20:05.898] 
[13:20:05.898] resolved() for ‘SequentialFuture’ ...
[13:20:05.898] - state: ‘finished’
[13:20:05.898] - run: TRUE
[13:20:05.898] - result: ‘FutureResult’
[13:20:05.898] resolved() for ‘SequentialFuture’ ... done
[13:20:05.898] Future #1
[13:20:05.899] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:05.899] - nx: 1
[13:20:05.899] - relay: TRUE
[13:20:05.899] - stdout: TRUE
[13:20:05.899] - signal: TRUE
[13:20:05.899] - resignal: FALSE
[13:20:05.899] - force: TRUE
[13:20:05.899] - relayed: [n=1] FALSE
[13:20:05.899] - queued futures: [n=1] FALSE
[13:20:05.899]  - until=1
[13:20:05.900]  - relaying element #1
[13:20:05.900] - relayed: [n=1] TRUE
[13:20:05.900] - queued futures: [n=1] TRUE
[13:20:05.900] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:05.900]  length: 0 (resolved future 1)
[13:20:05.900] Relaying remaining futures
[13:20:05.900] signalConditionsASAP(NULL, pos=0) ...
[13:20:05.900] - nx: 1
[13:20:05.900] - relay: TRUE
[13:20:05.900] - stdout: TRUE
[13:20:05.901] - signal: TRUE
[13:20:05.901] - resignal: FALSE
[13:20:05.901] - force: TRUE
[13:20:05.901] - relayed: [n=1] TRUE
[13:20:05.901] - queued futures: [n=1] TRUE
 - flush all
[13:20:05.901] - relayed: [n=1] TRUE
[13:20:05.901] - queued futures: [n=1] TRUE
[13:20:05.901] signalConditionsASAP(NULL, pos=0) ... done
[13:20:05.901] resolve() on list ... DONE
[13:20:05.901]  - Number of value chunks collected: 1
[13:20:05.901] Resolving 1 futures (chunks) ... DONE
[13:20:05.902] Reducing values from 1 chunks ...
[13:20:05.902]  - Number of values collected after concatenation: 3
[13:20:05.902]  - Number of values expected: 3
[13:20:05.902] Reducing values from 1 chunks ... DONE
[13:20:05.902] future_lapply() ... DONE
[13:20:05.902] future_lapply() ...
[13:20:05.903] Number of chunks: 1
[13:20:05.903] getGlobalsAndPackagesXApply() ...
[13:20:05.903]  - future.globals: TRUE
[13:20:05.903] getGlobalsAndPackages() ...
[13:20:05.903] Searching for globals...
[13:20:05.904] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:05.904] Searching for globals ... DONE
[13:20:05.904] Resolving globals: FALSE
[13:20:05.905] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:20:05.905] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:20:05.905] - globals: [1] ‘FUN’
[13:20:05.905] - packages: [1] ‘stats’
[13:20:05.905] getGlobalsAndPackages() ... DONE
[13:20:05.905]  - globals found/used: [n=1] ‘FUN’
[13:20:05.906]  - needed namespaces: [n=1] ‘stats’
[13:20:05.906] Finding globals ... DONE
[13:20:05.906]  - use_args: TRUE
[13:20:05.906]  - Getting '...' globals ...
[13:20:05.906] resolve() on list ...
[13:20:05.906]  recursive: 0
[13:20:05.906]  length: 1
[13:20:05.906]  elements: ‘...’
[13:20:05.907]  length: 0 (resolved future 1)
[13:20:05.907] resolve() on list ... DONE
[13:20:05.907]    - '...' content: [n=0] 
[13:20:05.907] List of 1
[13:20:05.907]  $ ...: list()
[13:20:05.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.907]  - attr(*, "where")=List of 1
[13:20:05.907]   ..$ ...:<environment: 0x558fd93878f8> 
[13:20:05.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.907]  - attr(*, "resolved")= logi TRUE
[13:20:05.907]  - attr(*, "total_size")= num NA
[13:20:05.909]  - Getting '...' globals ... DONE
[13:20:05.909] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:05.910] List of 2
[13:20:05.910]  $ ...future.FUN:function (x, ...)  
[13:20:05.910]  $ ...          : list()
[13:20:05.910]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.910]  - attr(*, "where")=List of 2
[13:20:05.910]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:05.910]   ..$ ...          :<environment: 0x558fd93878f8> 
[13:20:05.910]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.910]  - attr(*, "resolved")= logi FALSE
[13:20:05.910]  - attr(*, "total_size")= num 1248
[13:20:05.914] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:05.914] getGlobalsAndPackagesXApply() ... DONE
[13:20:05.914] Number of futures (= number of chunks): 1
[13:20:05.915] Launching 1 futures (chunks) ...
[13:20:05.915] Chunk #1 of 1 ...
[13:20:05.915]  - Finding globals in 'X' for chunk #1 ...
[13:20:05.915] getGlobalsAndPackages() ...
[13:20:05.915] Searching for globals...
[13:20:05.915] 
[13:20:05.915] Searching for globals ... DONE
[13:20:05.915] - globals: [0] <none>
[13:20:05.915] getGlobalsAndPackages() ... DONE
[13:20:05.916]    + additional globals found: [n=0] 
[13:20:05.916]    + additional namespaces needed: [n=0] 
[13:20:05.916]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:05.916]  - seeds: <none>
[13:20:05.916]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.916] getGlobalsAndPackages() ...
[13:20:05.916] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.916] Resolving globals: FALSE
[13:20:05.916] Tweak future expression to call with '...' arguments ...
[13:20:05.917] {
[13:20:05.917]     do.call(function(...) {
[13:20:05.917]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.917]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.917]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.917]             on.exit(options(oopts), add = TRUE)
[13:20:05.917]         }
[13:20:05.917]         {
[13:20:05.917]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.917]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.917]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.917]             })
[13:20:05.917]         }
[13:20:05.917]     }, args = future.call.arguments)
[13:20:05.917] }
[13:20:05.917] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.917] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.917] - packages: [1] ‘stats’
[13:20:05.917] getGlobalsAndPackages() ... DONE
[13:20:05.918] run() for ‘Future’ ...
[13:20:05.918] - state: ‘created’
[13:20:05.918] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:05.918] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:05.918] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:05.918]   - Field: ‘label’
[13:20:05.919]   - Field: ‘local’
[13:20:05.919]   - Field: ‘owner’
[13:20:05.919]   - Field: ‘envir’
[13:20:05.919]   - Field: ‘packages’
[13:20:05.919]   - Field: ‘gc’
[13:20:05.919]   - Field: ‘conditions’
[13:20:05.919]   - Field: ‘expr’
[13:20:05.919]   - Field: ‘uuid’
[13:20:05.919]   - Field: ‘seed’
[13:20:05.919]   - Field: ‘version’
[13:20:05.919]   - Field: ‘result’
[13:20:05.920]   - Field: ‘asynchronous’
[13:20:05.920]   - Field: ‘calls’
[13:20:05.920]   - Field: ‘globals’
[13:20:05.920]   - Field: ‘stdout’
[13:20:05.920]   - Field: ‘earlySignal’
[13:20:05.920]   - Field: ‘lazy’
[13:20:05.920]   - Field: ‘state’
[13:20:05.920] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:05.920] - Launch lazy future ...
[13:20:05.921] Packages needed by the future expression (n = 1): ‘stats’
[13:20:05.921] Packages needed by future strategies (n = 0): <none>
[13:20:05.921] {
[13:20:05.921]     {
[13:20:05.921]         {
[13:20:05.921]             ...future.startTime <- base::Sys.time()
[13:20:05.921]             {
[13:20:05.921]                 {
[13:20:05.921]                   {
[13:20:05.921]                     {
[13:20:05.921]                       base::local({
[13:20:05.921]                         has_future <- base::requireNamespace("future", 
[13:20:05.921]                           quietly = TRUE)
[13:20:05.921]                         if (has_future) {
[13:20:05.921]                           ns <- base::getNamespace("future")
[13:20:05.921]                           version <- ns[[".package"]][["version"]]
[13:20:05.921]                           if (is.null(version)) 
[13:20:05.921]                             version <- utils::packageVersion("future")
[13:20:05.921]                         }
[13:20:05.921]                         else {
[13:20:05.921]                           version <- NULL
[13:20:05.921]                         }
[13:20:05.921]                         if (!has_future || version < "1.8.0") {
[13:20:05.921]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:05.921]                             "", base::R.version$version.string), 
[13:20:05.921]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:05.921]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:05.921]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:05.921]                               "release", "version")], collapse = " "), 
[13:20:05.921]                             hostname = base::Sys.info()[["nodename"]])
[13:20:05.921]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:05.921]                             info)
[13:20:05.921]                           info <- base::paste(info, collapse = "; ")
[13:20:05.921]                           if (!has_future) {
[13:20:05.921]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:05.921]                               info)
[13:20:05.921]                           }
[13:20:05.921]                           else {
[13:20:05.921]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:05.921]                               info, version)
[13:20:05.921]                           }
[13:20:05.921]                           base::stop(msg)
[13:20:05.921]                         }
[13:20:05.921]                       })
[13:20:05.921]                     }
[13:20:05.921]                     base::local({
[13:20:05.921]                       for (pkg in "stats") {
[13:20:05.921]                         base::loadNamespace(pkg)
[13:20:05.921]                         base::library(pkg, character.only = TRUE)
[13:20:05.921]                       }
[13:20:05.921]                     })
[13:20:05.921]                   }
[13:20:05.921]                   options(future.plan = NULL)
[13:20:05.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:05.921]                 }
[13:20:05.921]                 ...future.workdir <- getwd()
[13:20:05.921]             }
[13:20:05.921]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:05.921]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:05.921]         }
[13:20:05.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:05.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:05.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:05.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:05.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:05.921]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:05.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:05.921]             base::names(...future.oldOptions))
[13:20:05.921]     }
[13:20:05.921]     if (FALSE) {
[13:20:05.921]     }
[13:20:05.921]     else {
[13:20:05.921]         if (TRUE) {
[13:20:05.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:05.921]                 open = "w")
[13:20:05.921]         }
[13:20:05.921]         else {
[13:20:05.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:05.921]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:05.921]         }
[13:20:05.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:05.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:05.921]             base::sink(type = "output", split = FALSE)
[13:20:05.921]             base::close(...future.stdout)
[13:20:05.921]         }, add = TRUE)
[13:20:05.921]     }
[13:20:05.921]     ...future.frame <- base::sys.nframe()
[13:20:05.921]     ...future.conditions <- base::list()
[13:20:05.921]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:05.921]     if (FALSE) {
[13:20:05.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:05.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:05.921]     }
[13:20:05.921]     ...future.result <- base::tryCatch({
[13:20:05.921]         base::withCallingHandlers({
[13:20:05.921]             ...future.value <- base::withVisible(base::local({
[13:20:05.921]                 do.call(function(...) {
[13:20:05.921]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.921]                   if (!identical(...future.globals.maxSize.org, 
[13:20:05.921]                     ...future.globals.maxSize)) {
[13:20:05.921]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.921]                     on.exit(options(oopts), add = TRUE)
[13:20:05.921]                   }
[13:20:05.921]                   {
[13:20:05.921]                     lapply(seq_along(...future.elements_ii), 
[13:20:05.921]                       FUN = function(jj) {
[13:20:05.921]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.921]                         ...future.FUN(...future.X_jj, ...)
[13:20:05.921]                       })
[13:20:05.921]                   }
[13:20:05.921]                 }, args = future.call.arguments)
[13:20:05.921]             }))
[13:20:05.921]             future::FutureResult(value = ...future.value$value, 
[13:20:05.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.921]                   ...future.rng), globalenv = if (FALSE) 
[13:20:05.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:05.921]                     ...future.globalenv.names))
[13:20:05.921]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:05.921]         }, condition = base::local({
[13:20:05.921]             c <- base::c
[13:20:05.921]             inherits <- base::inherits
[13:20:05.921]             invokeRestart <- base::invokeRestart
[13:20:05.921]             length <- base::length
[13:20:05.921]             list <- base::list
[13:20:05.921]             seq.int <- base::seq.int
[13:20:05.921]             signalCondition <- base::signalCondition
[13:20:05.921]             sys.calls <- base::sys.calls
[13:20:05.921]             `[[` <- base::`[[`
[13:20:05.921]             `+` <- base::`+`
[13:20:05.921]             `<<-` <- base::`<<-`
[13:20:05.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:05.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:05.921]                   3L)]
[13:20:05.921]             }
[13:20:05.921]             function(cond) {
[13:20:05.921]                 is_error <- inherits(cond, "error")
[13:20:05.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:05.921]                   NULL)
[13:20:05.921]                 if (is_error) {
[13:20:05.921]                   sessionInformation <- function() {
[13:20:05.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:05.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:05.921]                       search = base::search(), system = base::Sys.info())
[13:20:05.921]                   }
[13:20:05.921]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:05.921]                     cond$call), session = sessionInformation(), 
[13:20:05.921]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:05.921]                   signalCondition(cond)
[13:20:05.921]                 }
[13:20:05.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:05.921]                 "immediateCondition"))) {
[13:20:05.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:05.921]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:05.921]                   if (TRUE && !signal) {
[13:20:05.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.921]                     {
[13:20:05.921]                       inherits <- base::inherits
[13:20:05.921]                       invokeRestart <- base::invokeRestart
[13:20:05.921]                       is.null <- base::is.null
[13:20:05.921]                       muffled <- FALSE
[13:20:05.921]                       if (inherits(cond, "message")) {
[13:20:05.921]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.921]                         if (muffled) 
[13:20:05.921]                           invokeRestart("muffleMessage")
[13:20:05.921]                       }
[13:20:05.921]                       else if (inherits(cond, "warning")) {
[13:20:05.921]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.921]                         if (muffled) 
[13:20:05.921]                           invokeRestart("muffleWarning")
[13:20:05.921]                       }
[13:20:05.921]                       else if (inherits(cond, "condition")) {
[13:20:05.921]                         if (!is.null(pattern)) {
[13:20:05.921]                           computeRestarts <- base::computeRestarts
[13:20:05.921]                           grepl <- base::grepl
[13:20:05.921]                           restarts <- computeRestarts(cond)
[13:20:05.921]                           for (restart in restarts) {
[13:20:05.921]                             name <- restart$name
[13:20:05.921]                             if (is.null(name)) 
[13:20:05.921]                               next
[13:20:05.921]                             if (!grepl(pattern, name)) 
[13:20:05.921]                               next
[13:20:05.921]                             invokeRestart(restart)
[13:20:05.921]                             muffled <- TRUE
[13:20:05.921]                             break
[13:20:05.921]                           }
[13:20:05.921]                         }
[13:20:05.921]                       }
[13:20:05.921]                       invisible(muffled)
[13:20:05.921]                     }
[13:20:05.921]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.921]                   }
[13:20:05.921]                 }
[13:20:05.921]                 else {
[13:20:05.921]                   if (TRUE) {
[13:20:05.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.921]                     {
[13:20:05.921]                       inherits <- base::inherits
[13:20:05.921]                       invokeRestart <- base::invokeRestart
[13:20:05.921]                       is.null <- base::is.null
[13:20:05.921]                       muffled <- FALSE
[13:20:05.921]                       if (inherits(cond, "message")) {
[13:20:05.921]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.921]                         if (muffled) 
[13:20:05.921]                           invokeRestart("muffleMessage")
[13:20:05.921]                       }
[13:20:05.921]                       else if (inherits(cond, "warning")) {
[13:20:05.921]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.921]                         if (muffled) 
[13:20:05.921]                           invokeRestart("muffleWarning")
[13:20:05.921]                       }
[13:20:05.921]                       else if (inherits(cond, "condition")) {
[13:20:05.921]                         if (!is.null(pattern)) {
[13:20:05.921]                           computeRestarts <- base::computeRestarts
[13:20:05.921]                           grepl <- base::grepl
[13:20:05.921]                           restarts <- computeRestarts(cond)
[13:20:05.921]                           for (restart in restarts) {
[13:20:05.921]                             name <- restart$name
[13:20:05.921]                             if (is.null(name)) 
[13:20:05.921]                               next
[13:20:05.921]                             if (!grepl(pattern, name)) 
[13:20:05.921]                               next
[13:20:05.921]                             invokeRestart(restart)
[13:20:05.921]                             muffled <- TRUE
[13:20:05.921]                             break
[13:20:05.921]                           }
[13:20:05.921]                         }
[13:20:05.921]                       }
[13:20:05.921]                       invisible(muffled)
[13:20:05.921]                     }
[13:20:05.921]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.921]                   }
[13:20:05.921]                 }
[13:20:05.921]             }
[13:20:05.921]         }))
[13:20:05.921]     }, error = function(ex) {
[13:20:05.921]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:05.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.921]                 ...future.rng), started = ...future.startTime, 
[13:20:05.921]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:05.921]             version = "1.8"), class = "FutureResult")
[13:20:05.921]     }, finally = {
[13:20:05.921]         if (!identical(...future.workdir, getwd())) 
[13:20:05.921]             setwd(...future.workdir)
[13:20:05.921]         {
[13:20:05.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:05.921]                 ...future.oldOptions$nwarnings <- NULL
[13:20:05.921]             }
[13:20:05.921]             base::options(...future.oldOptions)
[13:20:05.921]             if (.Platform$OS.type == "windows") {
[13:20:05.921]                 old_names <- names(...future.oldEnvVars)
[13:20:05.921]                 envs <- base::Sys.getenv()
[13:20:05.921]                 names <- names(envs)
[13:20:05.921]                 common <- intersect(names, old_names)
[13:20:05.921]                 added <- setdiff(names, old_names)
[13:20:05.921]                 removed <- setdiff(old_names, names)
[13:20:05.921]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:05.921]                   envs[common]]
[13:20:05.921]                 NAMES <- toupper(changed)
[13:20:05.921]                 args <- list()
[13:20:05.921]                 for (kk in seq_along(NAMES)) {
[13:20:05.921]                   name <- changed[[kk]]
[13:20:05.921]                   NAME <- NAMES[[kk]]
[13:20:05.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.921]                     next
[13:20:05.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.921]                 }
[13:20:05.921]                 NAMES <- toupper(added)
[13:20:05.921]                 for (kk in seq_along(NAMES)) {
[13:20:05.921]                   name <- added[[kk]]
[13:20:05.921]                   NAME <- NAMES[[kk]]
[13:20:05.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.921]                     next
[13:20:05.921]                   args[[name]] <- ""
[13:20:05.921]                 }
[13:20:05.921]                 NAMES <- toupper(removed)
[13:20:05.921]                 for (kk in seq_along(NAMES)) {
[13:20:05.921]                   name <- removed[[kk]]
[13:20:05.921]                   NAME <- NAMES[[kk]]
[13:20:05.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.921]                     next
[13:20:05.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.921]                 }
[13:20:05.921]                 if (length(args) > 0) 
[13:20:05.921]                   base::do.call(base::Sys.setenv, args = args)
[13:20:05.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:05.921]             }
[13:20:05.921]             else {
[13:20:05.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:05.921]             }
[13:20:05.921]             {
[13:20:05.921]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:05.921]                   0L) {
[13:20:05.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:05.921]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:05.921]                   base::options(opts)
[13:20:05.921]                 }
[13:20:05.921]                 {
[13:20:05.921]                   {
[13:20:05.921]                     NULL
[13:20:05.921]                     RNGkind("Mersenne-Twister")
[13:20:05.921]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:05.921]                       inherits = FALSE)
[13:20:05.921]                   }
[13:20:05.921]                   options(future.plan = NULL)
[13:20:05.921]                   if (is.na(NA_character_)) 
[13:20:05.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:05.921]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:05.921]                   {
[13:20:05.921]                     future <- SequentialFuture(..., envir = envir)
[13:20:05.921]                     if (!future$lazy) 
[13:20:05.921]                       future <- run(future)
[13:20:05.921]                     invisible(future)
[13:20:05.921]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:05.921]                 }
[13:20:05.921]             }
[13:20:05.921]         }
[13:20:05.921]     })
[13:20:05.921]     if (TRUE) {
[13:20:05.921]         base::sink(type = "output", split = FALSE)
[13:20:05.921]         if (TRUE) {
[13:20:05.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:05.921]         }
[13:20:05.921]         else {
[13:20:05.921]             ...future.result["stdout"] <- base::list(NULL)
[13:20:05.921]         }
[13:20:05.921]         base::close(...future.stdout)
[13:20:05.921]         ...future.stdout <- NULL
[13:20:05.921]     }
[13:20:05.921]     ...future.result$conditions <- ...future.conditions
[13:20:05.921]     ...future.result$finished <- base::Sys.time()
[13:20:05.921]     ...future.result
[13:20:05.921] }
[13:20:05.923] assign_globals() ...
[13:20:05.923] List of 5
[13:20:05.923]  $ ...future.FUN            :function (x, ...)  
[13:20:05.923]  $ future.call.arguments    : list()
[13:20:05.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.923]  $ ...future.elements_ii    :List of 3
[13:20:05.923]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:20:05.923]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:20:05.923]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:20:05.923]  $ ...future.seeds_ii       : NULL
[13:20:05.923]  $ ...future.globals.maxSize: NULL
[13:20:05.923]  - attr(*, "where")=List of 5
[13:20:05.923]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:05.923]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:05.923]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:05.923]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:05.923]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:05.923]  - attr(*, "resolved")= logi FALSE
[13:20:05.923]  - attr(*, "total_size")= num 1248
[13:20:05.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.923]  - attr(*, "already-done")= logi TRUE
[13:20:05.928] - copied ‘...future.FUN’ to environment
[13:20:05.928] - copied ‘future.call.arguments’ to environment
[13:20:05.929] - copied ‘...future.elements_ii’ to environment
[13:20:05.929] - copied ‘...future.seeds_ii’ to environment
[13:20:05.929] - copied ‘...future.globals.maxSize’ to environment
[13:20:05.929] assign_globals() ... done
[13:20:05.929] plan(): Setting new future strategy stack:
[13:20:05.929] List of future strategies:
[13:20:05.929] 1. sequential:
[13:20:05.929]    - args: function (..., envir = parent.frame())
[13:20:05.929]    - tweaked: FALSE
[13:20:05.929]    - call: NULL
[13:20:05.930] plan(): nbrOfWorkers() = 1
[13:20:05.931] plan(): Setting new future strategy stack:
[13:20:05.931] List of future strategies:
[13:20:05.931] 1. sequential:
[13:20:05.931]    - args: function (..., envir = parent.frame())
[13:20:05.931]    - tweaked: FALSE
[13:20:05.931]    - call: plan(strategy)
[13:20:05.931] plan(): nbrOfWorkers() = 1
[13:20:05.932] SequentialFuture started (and completed)
[13:20:05.932] - Launch lazy future ... done
[13:20:05.932] run() for ‘SequentialFuture’ ... done
[13:20:05.932] Created future:
[13:20:05.932] SequentialFuture:
[13:20:05.932] Label: ‘future_eapply-1’
[13:20:05.932] Expression:
[13:20:05.932] {
[13:20:05.932]     do.call(function(...) {
[13:20:05.932]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.932]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.932]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.932]             on.exit(options(oopts), add = TRUE)
[13:20:05.932]         }
[13:20:05.932]         {
[13:20:05.932]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.932]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.932]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.932]             })
[13:20:05.932]         }
[13:20:05.932]     }, args = future.call.arguments)
[13:20:05.932] }
[13:20:05.932] Lazy evaluation: FALSE
[13:20:05.932] Asynchronous evaluation: FALSE
[13:20:05.932] Local evaluation: TRUE
[13:20:05.932] Environment: R_GlobalEnv
[13:20:05.932] Capture standard output: TRUE
[13:20:05.932] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:05.932] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:05.932] Packages: 1 packages (‘stats’)
[13:20:05.932] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:05.932] Resolved: TRUE
[13:20:05.932] Value: 1.71 KiB of class ‘list’
[13:20:05.932] Early signaling: FALSE
[13:20:05.932] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:05.932] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:05.933] Chunk #1 of 1 ... DONE
[13:20:05.933] Launching 1 futures (chunks) ... DONE
[13:20:05.933] Resolving 1 futures (chunks) ...
[13:20:05.933] resolve() on list ...
[13:20:05.933]  recursive: 0
[13:20:05.934]  length: 1
[13:20:05.934] 
[13:20:05.934] resolved() for ‘SequentialFuture’ ...
[13:20:05.934] - state: ‘finished’
[13:20:05.934] - run: TRUE
[13:20:05.934] - result: ‘FutureResult’
[13:20:05.934] resolved() for ‘SequentialFuture’ ... done
[13:20:05.934] Future #1
[13:20:05.934] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:05.934] - nx: 1
[13:20:05.935] - relay: TRUE
[13:20:05.935] - stdout: TRUE
[13:20:05.935] - signal: TRUE
[13:20:05.935] - resignal: FALSE
[13:20:05.935] - force: TRUE
[13:20:05.935] - relayed: [n=1] FALSE
[13:20:05.935] - queued futures: [n=1] FALSE
[13:20:05.935]  - until=1
[13:20:05.935]  - relaying element #1
[13:20:05.935] - relayed: [n=1] TRUE
[13:20:05.936] - queued futures: [n=1] TRUE
[13:20:05.936] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:05.938]  length: 0 (resolved future 1)
[13:20:05.938] Relaying remaining futures
[13:20:05.938] signalConditionsASAP(NULL, pos=0) ...
[13:20:05.938] - nx: 1
[13:20:05.938] - relay: TRUE
[13:20:05.938] - stdout: TRUE
[13:20:05.938] - signal: TRUE
[13:20:05.938] - resignal: FALSE
[13:20:05.938] - force: TRUE
[13:20:05.938] - relayed: [n=1] TRUE
[13:20:05.938] - queued futures: [n=1] TRUE
 - flush all
[13:20:05.939] - relayed: [n=1] TRUE
[13:20:05.939] - queued futures: [n=1] TRUE
[13:20:05.939] signalConditionsASAP(NULL, pos=0) ... done
[13:20:05.939] resolve() on list ... DONE
[13:20:05.939]  - Number of value chunks collected: 1
[13:20:05.939] Resolving 1 futures (chunks) ... DONE
[13:20:05.939] Reducing values from 1 chunks ...
[13:20:05.939]  - Number of values collected after concatenation: 3
[13:20:05.939]  - Number of values expected: 3
[13:20:05.940] Reducing values from 1 chunks ... DONE
[13:20:05.940] future_lapply() ... DONE
[13:20:05.940] plan(): Setting new future strategy stack:
[13:20:05.940] List of future strategies:
[13:20:05.940] 1. sequential:
[13:20:05.940]    - args: function (..., envir = parent.frame())
[13:20:05.940]    - tweaked: FALSE
[13:20:05.940]    - call: plan(sequential)
[13:20:05.941] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[13:20:05.941] plan(): Setting new future strategy stack:
[13:20:05.941] List of future strategies:
[13:20:05.941] 1. multicore:
[13:20:05.941]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:05.941]    - tweaked: FALSE
[13:20:05.941]    - call: plan(strategy)
[13:20:05.945] plan(): nbrOfWorkers() = 2
[13:20:05.945] future_lapply() ...
[13:20:05.949] Number of chunks: 2
[13:20:05.949] getGlobalsAndPackagesXApply() ...
[13:20:05.950]  - future.globals: TRUE
[13:20:05.950] getGlobalsAndPackages() ...
[13:20:05.950] Searching for globals...
[13:20:05.951] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:05.951] Searching for globals ... DONE
[13:20:05.951] Resolving globals: FALSE
[13:20:05.951] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:05.952] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:05.952] - globals: [1] ‘FUN’
[13:20:05.952] 
[13:20:05.952] getGlobalsAndPackages() ... DONE
[13:20:05.952]  - globals found/used: [n=1] ‘FUN’
[13:20:05.952]  - needed namespaces: [n=0] 
[13:20:05.952] Finding globals ... DONE
[13:20:05.953]  - use_args: TRUE
[13:20:05.953]  - Getting '...' globals ...
[13:20:05.953] resolve() on list ...
[13:20:05.953]  recursive: 0
[13:20:05.953]  length: 1
[13:20:05.953]  elements: ‘...’
[13:20:05.953]  length: 0 (resolved future 1)
[13:20:05.953] resolve() on list ... DONE
[13:20:05.953]    - '...' content: [n=0] 
[13:20:05.954] List of 1
[13:20:05.954]  $ ...: list()
[13:20:05.954]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.954]  - attr(*, "where")=List of 1
[13:20:05.954]   ..$ ...:<environment: 0x558fd71afe48> 
[13:20:05.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.954]  - attr(*, "resolved")= logi TRUE
[13:20:05.954]  - attr(*, "total_size")= num NA
[13:20:05.956]  - Getting '...' globals ... DONE
[13:20:05.956] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:05.956] List of 2
[13:20:05.956]  $ ...future.FUN:function (x, ...)  
[13:20:05.956]  $ ...          : list()
[13:20:05.956]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.956]  - attr(*, "where")=List of 2
[13:20:05.956]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:05.956]   ..$ ...          :<environment: 0x558fd71afe48> 
[13:20:05.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.956]  - attr(*, "resolved")= logi FALSE
[13:20:05.956]  - attr(*, "total_size")= num 1240
[13:20:05.959] Packages to be attached in all futures: [n=0] 
[13:20:05.959] getGlobalsAndPackagesXApply() ... DONE
[13:20:05.959] Number of futures (= number of chunks): 2
[13:20:05.959] Launching 2 futures (chunks) ...
[13:20:05.960] Chunk #1 of 2 ...
[13:20:05.960]  - Finding globals in 'X' for chunk #1 ...
[13:20:05.960] getGlobalsAndPackages() ...
[13:20:05.960] Searching for globals...
[13:20:05.960] 
[13:20:05.960] Searching for globals ... DONE
[13:20:05.960] - globals: [0] <none>
[13:20:05.960] getGlobalsAndPackages() ... DONE
[13:20:05.961]    + additional globals found: [n=0] 
[13:20:05.961]    + additional namespaces needed: [n=0] 
[13:20:05.961]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:05.961]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:05.961]  - seeds: <none>
[13:20:05.961]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.961] getGlobalsAndPackages() ...
[13:20:05.961] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.961] Resolving globals: FALSE
[13:20:05.961] Tweak future expression to call with '...' arguments ...
[13:20:05.962] {
[13:20:05.962]     do.call(function(...) {
[13:20:05.962]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.962]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.962]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.962]             on.exit(options(oopts), add = TRUE)
[13:20:05.962]         }
[13:20:05.962]         {
[13:20:05.962]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.962]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.962]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.962]             })
[13:20:05.962]         }
[13:20:05.962]     }, args = future.call.arguments)
[13:20:05.962] }
[13:20:05.962] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.962] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.962] 
[13:20:05.962] getGlobalsAndPackages() ... DONE
[13:20:05.963] run() for ‘Future’ ...
[13:20:05.963] - state: ‘created’
[13:20:05.963] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:05.967] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.967] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:05.967]   - Field: ‘label’
[13:20:05.967]   - Field: ‘local’
[13:20:05.967]   - Field: ‘owner’
[13:20:05.967]   - Field: ‘envir’
[13:20:05.967]   - Field: ‘workers’
[13:20:05.969]   - Field: ‘packages’
[13:20:05.969]   - Field: ‘gc’
[13:20:05.970]   - Field: ‘job’
[13:20:05.970]   - Field: ‘conditions’
[13:20:05.970]   - Field: ‘expr’
[13:20:05.970]   - Field: ‘uuid’
[13:20:05.970]   - Field: ‘seed’
[13:20:05.970]   - Field: ‘version’
[13:20:05.970]   - Field: ‘result’
[13:20:05.970]   - Field: ‘asynchronous’
[13:20:05.970]   - Field: ‘calls’
[13:20:05.970]   - Field: ‘globals’
[13:20:05.970]   - Field: ‘stdout’
[13:20:05.971]   - Field: ‘earlySignal’
[13:20:05.971]   - Field: ‘lazy’
[13:20:05.971]   - Field: ‘state’
[13:20:05.971] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:05.971] - Launch lazy future ...
[13:20:05.972] Packages needed by the future expression (n = 0): <none>
[13:20:05.972] Packages needed by future strategies (n = 0): <none>
[13:20:05.973] {
[13:20:05.973]     {
[13:20:05.973]         {
[13:20:05.973]             ...future.startTime <- base::Sys.time()
[13:20:05.973]             {
[13:20:05.973]                 {
[13:20:05.973]                   {
[13:20:05.973]                     {
[13:20:05.973]                       base::local({
[13:20:05.973]                         has_future <- base::requireNamespace("future", 
[13:20:05.973]                           quietly = TRUE)
[13:20:05.973]                         if (has_future) {
[13:20:05.973]                           ns <- base::getNamespace("future")
[13:20:05.973]                           version <- ns[[".package"]][["version"]]
[13:20:05.973]                           if (is.null(version)) 
[13:20:05.973]                             version <- utils::packageVersion("future")
[13:20:05.973]                         }
[13:20:05.973]                         else {
[13:20:05.973]                           version <- NULL
[13:20:05.973]                         }
[13:20:05.973]                         if (!has_future || version < "1.8.0") {
[13:20:05.973]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:05.973]                             "", base::R.version$version.string), 
[13:20:05.973]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:05.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:05.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:05.973]                               "release", "version")], collapse = " "), 
[13:20:05.973]                             hostname = base::Sys.info()[["nodename"]])
[13:20:05.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:05.973]                             info)
[13:20:05.973]                           info <- base::paste(info, collapse = "; ")
[13:20:05.973]                           if (!has_future) {
[13:20:05.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:05.973]                               info)
[13:20:05.973]                           }
[13:20:05.973]                           else {
[13:20:05.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:05.973]                               info, version)
[13:20:05.973]                           }
[13:20:05.973]                           base::stop(msg)
[13:20:05.973]                         }
[13:20:05.973]                       })
[13:20:05.973]                     }
[13:20:05.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:05.973]                     base::options(mc.cores = 1L)
[13:20:05.973]                   }
[13:20:05.973]                   options(future.plan = NULL)
[13:20:05.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:05.973]                 }
[13:20:05.973]                 ...future.workdir <- getwd()
[13:20:05.973]             }
[13:20:05.973]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:05.973]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:05.973]         }
[13:20:05.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:05.973]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:05.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:05.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:05.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:05.973]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:05.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:05.973]             base::names(...future.oldOptions))
[13:20:05.973]     }
[13:20:05.973]     if (FALSE) {
[13:20:05.973]     }
[13:20:05.973]     else {
[13:20:05.973]         if (TRUE) {
[13:20:05.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:05.973]                 open = "w")
[13:20:05.973]         }
[13:20:05.973]         else {
[13:20:05.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:05.973]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:05.973]         }
[13:20:05.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:05.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:05.973]             base::sink(type = "output", split = FALSE)
[13:20:05.973]             base::close(...future.stdout)
[13:20:05.973]         }, add = TRUE)
[13:20:05.973]     }
[13:20:05.973]     ...future.frame <- base::sys.nframe()
[13:20:05.973]     ...future.conditions <- base::list()
[13:20:05.973]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:05.973]     if (FALSE) {
[13:20:05.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:05.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:05.973]     }
[13:20:05.973]     ...future.result <- base::tryCatch({
[13:20:05.973]         base::withCallingHandlers({
[13:20:05.973]             ...future.value <- base::withVisible(base::local({
[13:20:05.973]                 withCallingHandlers({
[13:20:05.973]                   {
[13:20:05.973]                     do.call(function(...) {
[13:20:05.973]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.973]                       if (!identical(...future.globals.maxSize.org, 
[13:20:05.973]                         ...future.globals.maxSize)) {
[13:20:05.973]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.973]                         on.exit(options(oopts), add = TRUE)
[13:20:05.973]                       }
[13:20:05.973]                       {
[13:20:05.973]                         lapply(seq_along(...future.elements_ii), 
[13:20:05.973]                           FUN = function(jj) {
[13:20:05.973]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.973]                             ...future.FUN(...future.X_jj, ...)
[13:20:05.973]                           })
[13:20:05.973]                       }
[13:20:05.973]                     }, args = future.call.arguments)
[13:20:05.973]                   }
[13:20:05.973]                 }, immediateCondition = function(cond) {
[13:20:05.973]                   save_rds <- function (object, pathname, ...) 
[13:20:05.973]                   {
[13:20:05.973]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:05.973]                     if (file_test("-f", pathname_tmp)) {
[13:20:05.973]                       fi_tmp <- file.info(pathname_tmp)
[13:20:05.973]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:05.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:05.973]                         fi_tmp[["mtime"]])
[13:20:05.973]                     }
[13:20:05.973]                     tryCatch({
[13:20:05.973]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:05.973]                     }, error = function(ex) {
[13:20:05.973]                       msg <- conditionMessage(ex)
[13:20:05.973]                       fi_tmp <- file.info(pathname_tmp)
[13:20:05.973]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:05.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:05.973]                         fi_tmp[["mtime"]], msg)
[13:20:05.973]                       ex$message <- msg
[13:20:05.973]                       stop(ex)
[13:20:05.973]                     })
[13:20:05.973]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:05.973]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:05.973]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:05.973]                       fi_tmp <- file.info(pathname_tmp)
[13:20:05.973]                       fi <- file.info(pathname)
[13:20:05.973]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:05.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:05.973]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:05.973]                         fi[["size"]], fi[["mtime"]])
[13:20:05.973]                       stop(msg)
[13:20:05.973]                     }
[13:20:05.973]                     invisible(pathname)
[13:20:05.973]                   }
[13:20:05.973]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:05.973]                     rootPath = tempdir()) 
[13:20:05.973]                   {
[13:20:05.973]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:05.973]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:05.973]                       tmpdir = path, fileext = ".rds")
[13:20:05.973]                     save_rds(obj, file)
[13:20:05.973]                   }
[13:20:05.973]                   saveImmediateCondition(cond, path = "/tmp/RtmpKCdc3U/.future/immediateConditions")
[13:20:05.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.973]                   {
[13:20:05.973]                     inherits <- base::inherits
[13:20:05.973]                     invokeRestart <- base::invokeRestart
[13:20:05.973]                     is.null <- base::is.null
[13:20:05.973]                     muffled <- FALSE
[13:20:05.973]                     if (inherits(cond, "message")) {
[13:20:05.973]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:05.973]                       if (muffled) 
[13:20:05.973]                         invokeRestart("muffleMessage")
[13:20:05.973]                     }
[13:20:05.973]                     else if (inherits(cond, "warning")) {
[13:20:05.973]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:05.973]                       if (muffled) 
[13:20:05.973]                         invokeRestart("muffleWarning")
[13:20:05.973]                     }
[13:20:05.973]                     else if (inherits(cond, "condition")) {
[13:20:05.973]                       if (!is.null(pattern)) {
[13:20:05.973]                         computeRestarts <- base::computeRestarts
[13:20:05.973]                         grepl <- base::grepl
[13:20:05.973]                         restarts <- computeRestarts(cond)
[13:20:05.973]                         for (restart in restarts) {
[13:20:05.973]                           name <- restart$name
[13:20:05.973]                           if (is.null(name)) 
[13:20:05.973]                             next
[13:20:05.973]                           if (!grepl(pattern, name)) 
[13:20:05.973]                             next
[13:20:05.973]                           invokeRestart(restart)
[13:20:05.973]                           muffled <- TRUE
[13:20:05.973]                           break
[13:20:05.973]                         }
[13:20:05.973]                       }
[13:20:05.973]                     }
[13:20:05.973]                     invisible(muffled)
[13:20:05.973]                   }
[13:20:05.973]                   muffleCondition(cond)
[13:20:05.973]                 })
[13:20:05.973]             }))
[13:20:05.973]             future::FutureResult(value = ...future.value$value, 
[13:20:05.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.973]                   ...future.rng), globalenv = if (FALSE) 
[13:20:05.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:05.973]                     ...future.globalenv.names))
[13:20:05.973]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:05.973]         }, condition = base::local({
[13:20:05.973]             c <- base::c
[13:20:05.973]             inherits <- base::inherits
[13:20:05.973]             invokeRestart <- base::invokeRestart
[13:20:05.973]             length <- base::length
[13:20:05.973]             list <- base::list
[13:20:05.973]             seq.int <- base::seq.int
[13:20:05.973]             signalCondition <- base::signalCondition
[13:20:05.973]             sys.calls <- base::sys.calls
[13:20:05.973]             `[[` <- base::`[[`
[13:20:05.973]             `+` <- base::`+`
[13:20:05.973]             `<<-` <- base::`<<-`
[13:20:05.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:05.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:05.973]                   3L)]
[13:20:05.973]             }
[13:20:05.973]             function(cond) {
[13:20:05.973]                 is_error <- inherits(cond, "error")
[13:20:05.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:05.973]                   NULL)
[13:20:05.973]                 if (is_error) {
[13:20:05.973]                   sessionInformation <- function() {
[13:20:05.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:05.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:05.973]                       search = base::search(), system = base::Sys.info())
[13:20:05.973]                   }
[13:20:05.973]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:05.973]                     cond$call), session = sessionInformation(), 
[13:20:05.973]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:05.973]                   signalCondition(cond)
[13:20:05.973]                 }
[13:20:05.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:05.973]                 "immediateCondition"))) {
[13:20:05.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:05.973]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:05.973]                   if (TRUE && !signal) {
[13:20:05.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.973]                     {
[13:20:05.973]                       inherits <- base::inherits
[13:20:05.973]                       invokeRestart <- base::invokeRestart
[13:20:05.973]                       is.null <- base::is.null
[13:20:05.973]                       muffled <- FALSE
[13:20:05.973]                       if (inherits(cond, "message")) {
[13:20:05.973]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.973]                         if (muffled) 
[13:20:05.973]                           invokeRestart("muffleMessage")
[13:20:05.973]                       }
[13:20:05.973]                       else if (inherits(cond, "warning")) {
[13:20:05.973]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.973]                         if (muffled) 
[13:20:05.973]                           invokeRestart("muffleWarning")
[13:20:05.973]                       }
[13:20:05.973]                       else if (inherits(cond, "condition")) {
[13:20:05.973]                         if (!is.null(pattern)) {
[13:20:05.973]                           computeRestarts <- base::computeRestarts
[13:20:05.973]                           grepl <- base::grepl
[13:20:05.973]                           restarts <- computeRestarts(cond)
[13:20:05.973]                           for (restart in restarts) {
[13:20:05.973]                             name <- restart$name
[13:20:05.973]                             if (is.null(name)) 
[13:20:05.973]                               next
[13:20:05.973]                             if (!grepl(pattern, name)) 
[13:20:05.973]                               next
[13:20:05.973]                             invokeRestart(restart)
[13:20:05.973]                             muffled <- TRUE
[13:20:05.973]                             break
[13:20:05.973]                           }
[13:20:05.973]                         }
[13:20:05.973]                       }
[13:20:05.973]                       invisible(muffled)
[13:20:05.973]                     }
[13:20:05.973]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.973]                   }
[13:20:05.973]                 }
[13:20:05.973]                 else {
[13:20:05.973]                   if (TRUE) {
[13:20:05.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.973]                     {
[13:20:05.973]                       inherits <- base::inherits
[13:20:05.973]                       invokeRestart <- base::invokeRestart
[13:20:05.973]                       is.null <- base::is.null
[13:20:05.973]                       muffled <- FALSE
[13:20:05.973]                       if (inherits(cond, "message")) {
[13:20:05.973]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.973]                         if (muffled) 
[13:20:05.973]                           invokeRestart("muffleMessage")
[13:20:05.973]                       }
[13:20:05.973]                       else if (inherits(cond, "warning")) {
[13:20:05.973]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.973]                         if (muffled) 
[13:20:05.973]                           invokeRestart("muffleWarning")
[13:20:05.973]                       }
[13:20:05.973]                       else if (inherits(cond, "condition")) {
[13:20:05.973]                         if (!is.null(pattern)) {
[13:20:05.973]                           computeRestarts <- base::computeRestarts
[13:20:05.973]                           grepl <- base::grepl
[13:20:05.973]                           restarts <- computeRestarts(cond)
[13:20:05.973]                           for (restart in restarts) {
[13:20:05.973]                             name <- restart$name
[13:20:05.973]                             if (is.null(name)) 
[13:20:05.973]                               next
[13:20:05.973]                             if (!grepl(pattern, name)) 
[13:20:05.973]                               next
[13:20:05.973]                             invokeRestart(restart)
[13:20:05.973]                             muffled <- TRUE
[13:20:05.973]                             break
[13:20:05.973]                           }
[13:20:05.973]                         }
[13:20:05.973]                       }
[13:20:05.973]                       invisible(muffled)
[13:20:05.973]                     }
[13:20:05.973]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.973]                   }
[13:20:05.973]                 }
[13:20:05.973]             }
[13:20:05.973]         }))
[13:20:05.973]     }, error = function(ex) {
[13:20:05.973]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:05.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.973]                 ...future.rng), started = ...future.startTime, 
[13:20:05.973]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:05.973]             version = "1.8"), class = "FutureResult")
[13:20:05.973]     }, finally = {
[13:20:05.973]         if (!identical(...future.workdir, getwd())) 
[13:20:05.973]             setwd(...future.workdir)
[13:20:05.973]         {
[13:20:05.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:05.973]                 ...future.oldOptions$nwarnings <- NULL
[13:20:05.973]             }
[13:20:05.973]             base::options(...future.oldOptions)
[13:20:05.973]             if (.Platform$OS.type == "windows") {
[13:20:05.973]                 old_names <- names(...future.oldEnvVars)
[13:20:05.973]                 envs <- base::Sys.getenv()
[13:20:05.973]                 names <- names(envs)
[13:20:05.973]                 common <- intersect(names, old_names)
[13:20:05.973]                 added <- setdiff(names, old_names)
[13:20:05.973]                 removed <- setdiff(old_names, names)
[13:20:05.973]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:05.973]                   envs[common]]
[13:20:05.973]                 NAMES <- toupper(changed)
[13:20:05.973]                 args <- list()
[13:20:05.973]                 for (kk in seq_along(NAMES)) {
[13:20:05.973]                   name <- changed[[kk]]
[13:20:05.973]                   NAME <- NAMES[[kk]]
[13:20:05.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.973]                     next
[13:20:05.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.973]                 }
[13:20:05.973]                 NAMES <- toupper(added)
[13:20:05.973]                 for (kk in seq_along(NAMES)) {
[13:20:05.973]                   name <- added[[kk]]
[13:20:05.973]                   NAME <- NAMES[[kk]]
[13:20:05.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.973]                     next
[13:20:05.973]                   args[[name]] <- ""
[13:20:05.973]                 }
[13:20:05.973]                 NAMES <- toupper(removed)
[13:20:05.973]                 for (kk in seq_along(NAMES)) {
[13:20:05.973]                   name <- removed[[kk]]
[13:20:05.973]                   NAME <- NAMES[[kk]]
[13:20:05.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.973]                     next
[13:20:05.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.973]                 }
[13:20:05.973]                 if (length(args) > 0) 
[13:20:05.973]                   base::do.call(base::Sys.setenv, args = args)
[13:20:05.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:05.973]             }
[13:20:05.973]             else {
[13:20:05.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:05.973]             }
[13:20:05.973]             {
[13:20:05.973]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:05.973]                   0L) {
[13:20:05.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:05.973]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:05.973]                   base::options(opts)
[13:20:05.973]                 }
[13:20:05.973]                 {
[13:20:05.973]                   {
[13:20:05.973]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:05.973]                     NULL
[13:20:05.973]                   }
[13:20:05.973]                   options(future.plan = NULL)
[13:20:05.973]                   if (is.na(NA_character_)) 
[13:20:05.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:05.973]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:05.973]                     envir = parent.frame()) 
[13:20:05.973]                   {
[13:20:05.973]                     default_workers <- missing(workers)
[13:20:05.973]                     if (is.function(workers)) 
[13:20:05.973]                       workers <- workers()
[13:20:05.973]                     workers <- structure(as.integer(workers), 
[13:20:05.973]                       class = class(workers))
[13:20:05.973]                     stop_if_not(is.finite(workers), workers >= 
[13:20:05.973]                       1L)
[13:20:05.973]                     if ((workers == 1L && !inherits(workers, 
[13:20:05.973]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:05.973]                       if (default_workers) 
[13:20:05.973]                         supportsMulticore(warn = TRUE)
[13:20:05.973]                       return(sequential(..., envir = envir))
[13:20:05.973]                     }
[13:20:05.973]                     oopts <- options(mc.cores = workers)
[13:20:05.973]                     on.exit(options(oopts))
[13:20:05.973]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:05.973]                       envir = envir)
[13:20:05.973]                     if (!future$lazy) 
[13:20:05.973]                       future <- run(future)
[13:20:05.973]                     invisible(future)
[13:20:05.973]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:05.973]                 }
[13:20:05.973]             }
[13:20:05.973]         }
[13:20:05.973]     })
[13:20:05.973]     if (TRUE) {
[13:20:05.973]         base::sink(type = "output", split = FALSE)
[13:20:05.973]         if (TRUE) {
[13:20:05.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:05.973]         }
[13:20:05.973]         else {
[13:20:05.973]             ...future.result["stdout"] <- base::list(NULL)
[13:20:05.973]         }
[13:20:05.973]         base::close(...future.stdout)
[13:20:05.973]         ...future.stdout <- NULL
[13:20:05.973]     }
[13:20:05.973]     ...future.result$conditions <- ...future.conditions
[13:20:05.973]     ...future.result$finished <- base::Sys.time()
[13:20:05.973]     ...future.result
[13:20:05.973] }
[13:20:05.975] assign_globals() ...
[13:20:05.975] List of 5
[13:20:05.975]  $ ...future.FUN            :function (x, ...)  
[13:20:05.975]  $ future.call.arguments    : list()
[13:20:05.975]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.975]  $ ...future.elements_ii    :List of 1
[13:20:05.975]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[13:20:05.975]  $ ...future.seeds_ii       : NULL
[13:20:05.975]  $ ...future.globals.maxSize: NULL
[13:20:05.975]  - attr(*, "where")=List of 5
[13:20:05.975]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:05.975]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:05.975]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:05.975]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:05.975]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:05.975]  - attr(*, "resolved")= logi FALSE
[13:20:05.975]  - attr(*, "total_size")= num 1240
[13:20:05.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.975]  - attr(*, "already-done")= logi TRUE
[13:20:05.980] - copied ‘...future.FUN’ to environment
[13:20:05.980] - copied ‘future.call.arguments’ to environment
[13:20:05.980] - copied ‘...future.elements_ii’ to environment
[13:20:05.980] - copied ‘...future.seeds_ii’ to environment
[13:20:05.980] - copied ‘...future.globals.maxSize’ to environment
[13:20:05.981] assign_globals() ... done
[13:20:05.981] requestCore(): workers = 2
[13:20:05.984] MulticoreFuture started
[13:20:05.984] - Launch lazy future ... done
[13:20:05.984] run() for ‘MulticoreFuture’ ... done
[13:20:05.984] plan(): Setting new future strategy stack:
[13:20:05.985] Created future:
[13:20:05.985] List of future strategies:
[13:20:05.985] 1. sequential:
[13:20:05.985]    - args: function (..., envir = parent.frame())
[13:20:05.985]    - tweaked: FALSE
[13:20:05.985]    - call: NULL
[13:20:05.986] plan(): nbrOfWorkers() = 1
[13:20:05.988] plan(): Setting new future strategy stack:
[13:20:05.988] List of future strategies:
[13:20:05.988] 1. multicore:
[13:20:05.988]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:05.988]    - tweaked: FALSE
[13:20:05.988]    - call: plan(strategy)
[13:20:05.993] plan(): nbrOfWorkers() = 2
[13:20:05.985] MulticoreFuture:
[13:20:05.985] Label: ‘future_eapply-1’
[13:20:05.985] Expression:
[13:20:05.985] {
[13:20:05.985]     do.call(function(...) {
[13:20:05.985]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.985]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.985]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.985]             on.exit(options(oopts), add = TRUE)
[13:20:05.985]         }
[13:20:05.985]         {
[13:20:05.985]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.985]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.985]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.985]             })
[13:20:05.985]         }
[13:20:05.985]     }, args = future.call.arguments)
[13:20:05.985] }
[13:20:05.985] Lazy evaluation: FALSE
[13:20:05.985] Asynchronous evaluation: TRUE
[13:20:05.985] Local evaluation: TRUE
[13:20:05.985] Environment: R_GlobalEnv
[13:20:05.985] Capture standard output: TRUE
[13:20:05.985] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:05.985] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:05.985] Packages: <none>
[13:20:05.985] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:05.985] Resolved: TRUE
[13:20:05.985] Value: <not collected>
[13:20:05.985] Conditions captured: <none>
[13:20:05.985] Early signaling: FALSE
[13:20:05.985] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:05.985] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.994] Chunk #1 of 2 ... DONE
[13:20:05.994] Chunk #2 of 2 ...
[13:20:05.994]  - Finding globals in 'X' for chunk #2 ...
[13:20:05.995] getGlobalsAndPackages() ...
[13:20:05.995] Searching for globals...
[13:20:05.995] 
[13:20:05.995] Searching for globals ... DONE
[13:20:05.995] - globals: [0] <none>
[13:20:05.996] getGlobalsAndPackages() ... DONE
[13:20:05.996]    + additional globals found: [n=0] 
[13:20:05.996]    + additional namespaces needed: [n=0] 
[13:20:05.996]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:05.996]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:05.996]  - seeds: <none>
[13:20:05.996]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.997] getGlobalsAndPackages() ...
[13:20:05.997] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.997] Resolving globals: FALSE
[13:20:05.997] Tweak future expression to call with '...' arguments ...
[13:20:05.997] {
[13:20:05.997]     do.call(function(...) {
[13:20:05.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.997]             on.exit(options(oopts), add = TRUE)
[13:20:05.997]         }
[13:20:05.997]         {
[13:20:05.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.997]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.997]             })
[13:20:05.997]         }
[13:20:05.997]     }, args = future.call.arguments)
[13:20:05.997] }
[13:20:05.998] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.998] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.998] 
[13:20:05.999] getGlobalsAndPackages() ... DONE
[13:20:05.999] run() for ‘Future’ ...
[13:20:05.999] - state: ‘created’
[13:20:05.999] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:06.004] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:06.004]   - Field: ‘label’
[13:20:06.004]   - Field: ‘local’
[13:20:06.005]   - Field: ‘owner’
[13:20:06.005]   - Field: ‘envir’
[13:20:06.005]   - Field: ‘workers’
[13:20:06.005]   - Field: ‘packages’
[13:20:06.005]   - Field: ‘gc’
[13:20:06.005]   - Field: ‘job’
[13:20:06.005]   - Field: ‘conditions’
[13:20:06.005]   - Field: ‘expr’
[13:20:06.006]   - Field: ‘uuid’
[13:20:06.006]   - Field: ‘seed’
[13:20:06.006]   - Field: ‘version’
[13:20:06.006]   - Field: ‘result’
[13:20:06.006]   - Field: ‘asynchronous’
[13:20:06.006]   - Field: ‘calls’
[13:20:06.006]   - Field: ‘globals’
[13:20:06.006]   - Field: ‘stdout’
[13:20:06.007]   - Field: ‘earlySignal’
[13:20:06.007]   - Field: ‘lazy’
[13:20:06.007]   - Field: ‘state’
[13:20:06.007] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:06.007] - Launch lazy future ...
[13:20:06.008] Packages needed by the future expression (n = 0): <none>
[13:20:06.008] Packages needed by future strategies (n = 0): <none>
[13:20:06.008] {
[13:20:06.008]     {
[13:20:06.008]         {
[13:20:06.008]             ...future.startTime <- base::Sys.time()
[13:20:06.008]             {
[13:20:06.008]                 {
[13:20:06.008]                   {
[13:20:06.008]                     {
[13:20:06.008]                       base::local({
[13:20:06.008]                         has_future <- base::requireNamespace("future", 
[13:20:06.008]                           quietly = TRUE)
[13:20:06.008]                         if (has_future) {
[13:20:06.008]                           ns <- base::getNamespace("future")
[13:20:06.008]                           version <- ns[[".package"]][["version"]]
[13:20:06.008]                           if (is.null(version)) 
[13:20:06.008]                             version <- utils::packageVersion("future")
[13:20:06.008]                         }
[13:20:06.008]                         else {
[13:20:06.008]                           version <- NULL
[13:20:06.008]                         }
[13:20:06.008]                         if (!has_future || version < "1.8.0") {
[13:20:06.008]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:06.008]                             "", base::R.version$version.string), 
[13:20:06.008]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:06.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:06.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:06.008]                               "release", "version")], collapse = " "), 
[13:20:06.008]                             hostname = base::Sys.info()[["nodename"]])
[13:20:06.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:06.008]                             info)
[13:20:06.008]                           info <- base::paste(info, collapse = "; ")
[13:20:06.008]                           if (!has_future) {
[13:20:06.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:06.008]                               info)
[13:20:06.008]                           }
[13:20:06.008]                           else {
[13:20:06.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:06.008]                               info, version)
[13:20:06.008]                           }
[13:20:06.008]                           base::stop(msg)
[13:20:06.008]                         }
[13:20:06.008]                       })
[13:20:06.008]                     }
[13:20:06.008]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:06.008]                     base::options(mc.cores = 1L)
[13:20:06.008]                   }
[13:20:06.008]                   options(future.plan = NULL)
[13:20:06.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:06.008]                 }
[13:20:06.008]                 ...future.workdir <- getwd()
[13:20:06.008]             }
[13:20:06.008]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:06.008]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:06.008]         }
[13:20:06.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:06.008]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:06.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:06.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:06.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:06.008]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:06.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:06.008]             base::names(...future.oldOptions))
[13:20:06.008]     }
[13:20:06.008]     if (FALSE) {
[13:20:06.008]     }
[13:20:06.008]     else {
[13:20:06.008]         if (TRUE) {
[13:20:06.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:06.008]                 open = "w")
[13:20:06.008]         }
[13:20:06.008]         else {
[13:20:06.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:06.008]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:06.008]         }
[13:20:06.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:06.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:06.008]             base::sink(type = "output", split = FALSE)
[13:20:06.008]             base::close(...future.stdout)
[13:20:06.008]         }, add = TRUE)
[13:20:06.008]     }
[13:20:06.008]     ...future.frame <- base::sys.nframe()
[13:20:06.008]     ...future.conditions <- base::list()
[13:20:06.008]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:06.008]     if (FALSE) {
[13:20:06.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:06.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:06.008]     }
[13:20:06.008]     ...future.result <- base::tryCatch({
[13:20:06.008]         base::withCallingHandlers({
[13:20:06.008]             ...future.value <- base::withVisible(base::local({
[13:20:06.008]                 withCallingHandlers({
[13:20:06.008]                   {
[13:20:06.008]                     do.call(function(...) {
[13:20:06.008]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.008]                       if (!identical(...future.globals.maxSize.org, 
[13:20:06.008]                         ...future.globals.maxSize)) {
[13:20:06.008]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.008]                         on.exit(options(oopts), add = TRUE)
[13:20:06.008]                       }
[13:20:06.008]                       {
[13:20:06.008]                         lapply(seq_along(...future.elements_ii), 
[13:20:06.008]                           FUN = function(jj) {
[13:20:06.008]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.008]                             ...future.FUN(...future.X_jj, ...)
[13:20:06.008]                           })
[13:20:06.008]                       }
[13:20:06.008]                     }, args = future.call.arguments)
[13:20:06.008]                   }
[13:20:06.008]                 }, immediateCondition = function(cond) {
[13:20:06.008]                   save_rds <- function (object, pathname, ...) 
[13:20:06.008]                   {
[13:20:06.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:06.008]                     if (file_test("-f", pathname_tmp)) {
[13:20:06.008]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:06.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.008]                         fi_tmp[["mtime"]])
[13:20:06.008]                     }
[13:20:06.008]                     tryCatch({
[13:20:06.008]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:06.008]                     }, error = function(ex) {
[13:20:06.008]                       msg <- conditionMessage(ex)
[13:20:06.008]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:06.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.008]                         fi_tmp[["mtime"]], msg)
[13:20:06.008]                       ex$message <- msg
[13:20:06.008]                       stop(ex)
[13:20:06.008]                     })
[13:20:06.008]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:06.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:06.008]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:06.008]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.008]                       fi <- file.info(pathname)
[13:20:06.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:06.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:06.008]                         fi[["size"]], fi[["mtime"]])
[13:20:06.008]                       stop(msg)
[13:20:06.008]                     }
[13:20:06.008]                     invisible(pathname)
[13:20:06.008]                   }
[13:20:06.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:06.008]                     rootPath = tempdir()) 
[13:20:06.008]                   {
[13:20:06.008]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:06.008]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:06.008]                       tmpdir = path, fileext = ".rds")
[13:20:06.008]                     save_rds(obj, file)
[13:20:06.008]                   }
[13:20:06.008]                   saveImmediateCondition(cond, path = "/tmp/RtmpKCdc3U/.future/immediateConditions")
[13:20:06.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.008]                   {
[13:20:06.008]                     inherits <- base::inherits
[13:20:06.008]                     invokeRestart <- base::invokeRestart
[13:20:06.008]                     is.null <- base::is.null
[13:20:06.008]                     muffled <- FALSE
[13:20:06.008]                     if (inherits(cond, "message")) {
[13:20:06.008]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:06.008]                       if (muffled) 
[13:20:06.008]                         invokeRestart("muffleMessage")
[13:20:06.008]                     }
[13:20:06.008]                     else if (inherits(cond, "warning")) {
[13:20:06.008]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:06.008]                       if (muffled) 
[13:20:06.008]                         invokeRestart("muffleWarning")
[13:20:06.008]                     }
[13:20:06.008]                     else if (inherits(cond, "condition")) {
[13:20:06.008]                       if (!is.null(pattern)) {
[13:20:06.008]                         computeRestarts <- base::computeRestarts
[13:20:06.008]                         grepl <- base::grepl
[13:20:06.008]                         restarts <- computeRestarts(cond)
[13:20:06.008]                         for (restart in restarts) {
[13:20:06.008]                           name <- restart$name
[13:20:06.008]                           if (is.null(name)) 
[13:20:06.008]                             next
[13:20:06.008]                           if (!grepl(pattern, name)) 
[13:20:06.008]                             next
[13:20:06.008]                           invokeRestart(restart)
[13:20:06.008]                           muffled <- TRUE
[13:20:06.008]                           break
[13:20:06.008]                         }
[13:20:06.008]                       }
[13:20:06.008]                     }
[13:20:06.008]                     invisible(muffled)
[13:20:06.008]                   }
[13:20:06.008]                   muffleCondition(cond)
[13:20:06.008]                 })
[13:20:06.008]             }))
[13:20:06.008]             future::FutureResult(value = ...future.value$value, 
[13:20:06.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.008]                   ...future.rng), globalenv = if (FALSE) 
[13:20:06.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:06.008]                     ...future.globalenv.names))
[13:20:06.008]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:06.008]         }, condition = base::local({
[13:20:06.008]             c <- base::c
[13:20:06.008]             inherits <- base::inherits
[13:20:06.008]             invokeRestart <- base::invokeRestart
[13:20:06.008]             length <- base::length
[13:20:06.008]             list <- base::list
[13:20:06.008]             seq.int <- base::seq.int
[13:20:06.008]             signalCondition <- base::signalCondition
[13:20:06.008]             sys.calls <- base::sys.calls
[13:20:06.008]             `[[` <- base::`[[`
[13:20:06.008]             `+` <- base::`+`
[13:20:06.008]             `<<-` <- base::`<<-`
[13:20:06.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:06.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:06.008]                   3L)]
[13:20:06.008]             }
[13:20:06.008]             function(cond) {
[13:20:06.008]                 is_error <- inherits(cond, "error")
[13:20:06.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:06.008]                   NULL)
[13:20:06.008]                 if (is_error) {
[13:20:06.008]                   sessionInformation <- function() {
[13:20:06.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:06.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:06.008]                       search = base::search(), system = base::Sys.info())
[13:20:06.008]                   }
[13:20:06.008]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:06.008]                     cond$call), session = sessionInformation(), 
[13:20:06.008]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:06.008]                   signalCondition(cond)
[13:20:06.008]                 }
[13:20:06.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:06.008]                 "immediateCondition"))) {
[13:20:06.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:06.008]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:06.008]                   if (TRUE && !signal) {
[13:20:06.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.008]                     {
[13:20:06.008]                       inherits <- base::inherits
[13:20:06.008]                       invokeRestart <- base::invokeRestart
[13:20:06.008]                       is.null <- base::is.null
[13:20:06.008]                       muffled <- FALSE
[13:20:06.008]                       if (inherits(cond, "message")) {
[13:20:06.008]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.008]                         if (muffled) 
[13:20:06.008]                           invokeRestart("muffleMessage")
[13:20:06.008]                       }
[13:20:06.008]                       else if (inherits(cond, "warning")) {
[13:20:06.008]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.008]                         if (muffled) 
[13:20:06.008]                           invokeRestart("muffleWarning")
[13:20:06.008]                       }
[13:20:06.008]                       else if (inherits(cond, "condition")) {
[13:20:06.008]                         if (!is.null(pattern)) {
[13:20:06.008]                           computeRestarts <- base::computeRestarts
[13:20:06.008]                           grepl <- base::grepl
[13:20:06.008]                           restarts <- computeRestarts(cond)
[13:20:06.008]                           for (restart in restarts) {
[13:20:06.008]                             name <- restart$name
[13:20:06.008]                             if (is.null(name)) 
[13:20:06.008]                               next
[13:20:06.008]                             if (!grepl(pattern, name)) 
[13:20:06.008]                               next
[13:20:06.008]                             invokeRestart(restart)
[13:20:06.008]                             muffled <- TRUE
[13:20:06.008]                             break
[13:20:06.008]                           }
[13:20:06.008]                         }
[13:20:06.008]                       }
[13:20:06.008]                       invisible(muffled)
[13:20:06.008]                     }
[13:20:06.008]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.008]                   }
[13:20:06.008]                 }
[13:20:06.008]                 else {
[13:20:06.008]                   if (TRUE) {
[13:20:06.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.008]                     {
[13:20:06.008]                       inherits <- base::inherits
[13:20:06.008]                       invokeRestart <- base::invokeRestart
[13:20:06.008]                       is.null <- base::is.null
[13:20:06.008]                       muffled <- FALSE
[13:20:06.008]                       if (inherits(cond, "message")) {
[13:20:06.008]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.008]                         if (muffled) 
[13:20:06.008]                           invokeRestart("muffleMessage")
[13:20:06.008]                       }
[13:20:06.008]                       else if (inherits(cond, "warning")) {
[13:20:06.008]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.008]                         if (muffled) 
[13:20:06.008]                           invokeRestart("muffleWarning")
[13:20:06.008]                       }
[13:20:06.008]                       else if (inherits(cond, "condition")) {
[13:20:06.008]                         if (!is.null(pattern)) {
[13:20:06.008]                           computeRestarts <- base::computeRestarts
[13:20:06.008]                           grepl <- base::grepl
[13:20:06.008]                           restarts <- computeRestarts(cond)
[13:20:06.008]                           for (restart in restarts) {
[13:20:06.008]                             name <- restart$name
[13:20:06.008]                             if (is.null(name)) 
[13:20:06.008]                               next
[13:20:06.008]                             if (!grepl(pattern, name)) 
[13:20:06.008]                               next
[13:20:06.008]                             invokeRestart(restart)
[13:20:06.008]                             muffled <- TRUE
[13:20:06.008]                             break
[13:20:06.008]                           }
[13:20:06.008]                         }
[13:20:06.008]                       }
[13:20:06.008]                       invisible(muffled)
[13:20:06.008]                     }
[13:20:06.008]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.008]                   }
[13:20:06.008]                 }
[13:20:06.008]             }
[13:20:06.008]         }))
[13:20:06.008]     }, error = function(ex) {
[13:20:06.008]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:06.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.008]                 ...future.rng), started = ...future.startTime, 
[13:20:06.008]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:06.008]             version = "1.8"), class = "FutureResult")
[13:20:06.008]     }, finally = {
[13:20:06.008]         if (!identical(...future.workdir, getwd())) 
[13:20:06.008]             setwd(...future.workdir)
[13:20:06.008]         {
[13:20:06.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:06.008]                 ...future.oldOptions$nwarnings <- NULL
[13:20:06.008]             }
[13:20:06.008]             base::options(...future.oldOptions)
[13:20:06.008]             if (.Platform$OS.type == "windows") {
[13:20:06.008]                 old_names <- names(...future.oldEnvVars)
[13:20:06.008]                 envs <- base::Sys.getenv()
[13:20:06.008]                 names <- names(envs)
[13:20:06.008]                 common <- intersect(names, old_names)
[13:20:06.008]                 added <- setdiff(names, old_names)
[13:20:06.008]                 removed <- setdiff(old_names, names)
[13:20:06.008]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:06.008]                   envs[common]]
[13:20:06.008]                 NAMES <- toupper(changed)
[13:20:06.008]                 args <- list()
[13:20:06.008]                 for (kk in seq_along(NAMES)) {
[13:20:06.008]                   name <- changed[[kk]]
[13:20:06.008]                   NAME <- NAMES[[kk]]
[13:20:06.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.008]                     next
[13:20:06.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.008]                 }
[13:20:06.008]                 NAMES <- toupper(added)
[13:20:06.008]                 for (kk in seq_along(NAMES)) {
[13:20:06.008]                   name <- added[[kk]]
[13:20:06.008]                   NAME <- NAMES[[kk]]
[13:20:06.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.008]                     next
[13:20:06.008]                   args[[name]] <- ""
[13:20:06.008]                 }
[13:20:06.008]                 NAMES <- toupper(removed)
[13:20:06.008]                 for (kk in seq_along(NAMES)) {
[13:20:06.008]                   name <- removed[[kk]]
[13:20:06.008]                   NAME <- NAMES[[kk]]
[13:20:06.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.008]                     next
[13:20:06.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.008]                 }
[13:20:06.008]                 if (length(args) > 0) 
[13:20:06.008]                   base::do.call(base::Sys.setenv, args = args)
[13:20:06.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:06.008]             }
[13:20:06.008]             else {
[13:20:06.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:06.008]             }
[13:20:06.008]             {
[13:20:06.008]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:06.008]                   0L) {
[13:20:06.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:06.008]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:06.008]                   base::options(opts)
[13:20:06.008]                 }
[13:20:06.008]                 {
[13:20:06.008]                   {
[13:20:06.008]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:06.008]                     NULL
[13:20:06.008]                   }
[13:20:06.008]                   options(future.plan = NULL)
[13:20:06.008]                   if (is.na(NA_character_)) 
[13:20:06.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:06.008]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:06.008]                     envir = parent.frame()) 
[13:20:06.008]                   {
[13:20:06.008]                     default_workers <- missing(workers)
[13:20:06.008]                     if (is.function(workers)) 
[13:20:06.008]                       workers <- workers()
[13:20:06.008]                     workers <- structure(as.integer(workers), 
[13:20:06.008]                       class = class(workers))
[13:20:06.008]                     stop_if_not(is.finite(workers), workers >= 
[13:20:06.008]                       1L)
[13:20:06.008]                     if ((workers == 1L && !inherits(workers, 
[13:20:06.008]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:06.008]                       if (default_workers) 
[13:20:06.008]                         supportsMulticore(warn = TRUE)
[13:20:06.008]                       return(sequential(..., envir = envir))
[13:20:06.008]                     }
[13:20:06.008]                     oopts <- options(mc.cores = workers)
[13:20:06.008]                     on.exit(options(oopts))
[13:20:06.008]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:06.008]                       envir = envir)
[13:20:06.008]                     if (!future$lazy) 
[13:20:06.008]                       future <- run(future)
[13:20:06.008]                     invisible(future)
[13:20:06.008]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:06.008]                 }
[13:20:06.008]             }
[13:20:06.008]         }
[13:20:06.008]     })
[13:20:06.008]     if (TRUE) {
[13:20:06.008]         base::sink(type = "output", split = FALSE)
[13:20:06.008]         if (TRUE) {
[13:20:06.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:06.008]         }
[13:20:06.008]         else {
[13:20:06.008]             ...future.result["stdout"] <- base::list(NULL)
[13:20:06.008]         }
[13:20:06.008]         base::close(...future.stdout)
[13:20:06.008]         ...future.stdout <- NULL
[13:20:06.008]     }
[13:20:06.008]     ...future.result$conditions <- ...future.conditions
[13:20:06.008]     ...future.result$finished <- base::Sys.time()
[13:20:06.008]     ...future.result
[13:20:06.008] }
[13:20:06.012] assign_globals() ...
[13:20:06.012] List of 5
[13:20:06.012]  $ ...future.FUN            :function (x, ...)  
[13:20:06.012]  $ future.call.arguments    : list()
[13:20:06.012]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.012]  $ ...future.elements_ii    :List of 2
[13:20:06.012]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:20:06.012]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:20:06.012]  $ ...future.seeds_ii       : NULL
[13:20:06.012]  $ ...future.globals.maxSize: NULL
[13:20:06.012]  - attr(*, "where")=List of 5
[13:20:06.012]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:06.012]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:06.012]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:06.012]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:06.012]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:06.012]  - attr(*, "resolved")= logi FALSE
[13:20:06.012]  - attr(*, "total_size")= num 1240
[13:20:06.012]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.012]  - attr(*, "already-done")= logi TRUE
[13:20:06.024] - copied ‘...future.FUN’ to environment
[13:20:06.024] - copied ‘future.call.arguments’ to environment
[13:20:06.024] - copied ‘...future.elements_ii’ to environment
[13:20:06.024] - copied ‘...future.seeds_ii’ to environment
[13:20:06.025] - copied ‘...future.globals.maxSize’ to environment
[13:20:06.025] assign_globals() ... done
[13:20:06.025] requestCore(): workers = 2
[13:20:06.031] MulticoreFuture started
[13:20:06.031] - Launch lazy future ... done
[13:20:06.032] run() for ‘MulticoreFuture’ ... done
[13:20:06.032] Created future:
[13:20:06.032] plan(): Setting new future strategy stack:
[13:20:06.033] List of future strategies:
[13:20:06.033] 1. sequential:
[13:20:06.033]    - args: function (..., envir = parent.frame())
[13:20:06.033]    - tweaked: FALSE
[13:20:06.033]    - call: NULL
[13:20:06.033] plan(): nbrOfWorkers() = 1
[13:20:06.035] plan(): Setting new future strategy stack:
[13:20:06.036] List of future strategies:
[13:20:06.036] 1. multicore:
[13:20:06.036]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:06.036]    - tweaked: FALSE
[13:20:06.036]    - call: plan(strategy)
[13:20:06.041] plan(): nbrOfWorkers() = 2
[13:20:06.032] MulticoreFuture:
[13:20:06.032] Label: ‘future_eapply-2’
[13:20:06.032] Expression:
[13:20:06.032] {
[13:20:06.032]     do.call(function(...) {
[13:20:06.032]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.032]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.032]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.032]             on.exit(options(oopts), add = TRUE)
[13:20:06.032]         }
[13:20:06.032]         {
[13:20:06.032]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.032]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.032]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.032]             })
[13:20:06.032]         }
[13:20:06.032]     }, args = future.call.arguments)
[13:20:06.032] }
[13:20:06.032] Lazy evaluation: FALSE
[13:20:06.032] Asynchronous evaluation: TRUE
[13:20:06.032] Local evaluation: TRUE
[13:20:06.032] Environment: R_GlobalEnv
[13:20:06.032] Capture standard output: TRUE
[13:20:06.032] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:06.032] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:06.032] Packages: <none>
[13:20:06.032] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:06.032] Resolved: TRUE
[13:20:06.032] Value: <not collected>
[13:20:06.032] Conditions captured: <none>
[13:20:06.032] Early signaling: FALSE
[13:20:06.032] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:06.032] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.042] Chunk #2 of 2 ... DONE
[13:20:06.042] Launching 2 futures (chunks) ... DONE
[13:20:06.042] Resolving 2 futures (chunks) ...
[13:20:06.043] resolve() on list ...
[13:20:06.043]  recursive: 0
[13:20:06.043]  length: 2
[13:20:06.043] 
[13:20:06.043] Future #1
[13:20:06.044] result() for MulticoreFuture ...
[13:20:06.046] result() for MulticoreFuture ...
[13:20:06.046] result() for MulticoreFuture ... done
[13:20:06.047] result() for MulticoreFuture ... done
[13:20:06.047] result() for MulticoreFuture ...
[13:20:06.047] result() for MulticoreFuture ... done
[13:20:06.047] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:20:06.047] - nx: 2
[13:20:06.048] - relay: TRUE
[13:20:06.048] - stdout: TRUE
[13:20:06.048] - signal: TRUE
[13:20:06.048] - resignal: FALSE
[13:20:06.048] - force: TRUE
[13:20:06.048] - relayed: [n=2] FALSE, FALSE
[13:20:06.049] - queued futures: [n=2] FALSE, FALSE
[13:20:06.049]  - until=1
[13:20:06.049]  - relaying element #1
[13:20:06.049] result() for MulticoreFuture ...
[13:20:06.049] result() for MulticoreFuture ... done
[13:20:06.050] result() for MulticoreFuture ...
[13:20:06.050] result() for MulticoreFuture ... done
[13:20:06.050] result() for MulticoreFuture ...
[13:20:06.050] result() for MulticoreFuture ... done
[13:20:06.050] result() for MulticoreFuture ...
[13:20:06.050] result() for MulticoreFuture ... done
[13:20:06.051] - relayed: [n=2] TRUE, FALSE
[13:20:06.051] - queued futures: [n=2] TRUE, FALSE
[13:20:06.051] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:20:06.051]  length: 1 (resolved future 1)
[13:20:06.051] Future #2
[13:20:06.052] result() for MulticoreFuture ...
[13:20:06.052] result() for MulticoreFuture ...
[13:20:06.052] result() for MulticoreFuture ... done
[13:20:06.053] result() for MulticoreFuture ... done
[13:20:06.053] result() for MulticoreFuture ...
[13:20:06.053] result() for MulticoreFuture ... done
[13:20:06.053] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:06.053] - nx: 2
[13:20:06.053] - relay: TRUE
[13:20:06.053] - stdout: TRUE
[13:20:06.054] - signal: TRUE
[13:20:06.054] - resignal: FALSE
[13:20:06.054] - force: TRUE
[13:20:06.054] - relayed: [n=2] TRUE, FALSE
[13:20:06.054] - queued futures: [n=2] TRUE, FALSE
[13:20:06.054]  - until=2
[13:20:06.054]  - relaying element #2
[13:20:06.054] result() for MulticoreFuture ...
[13:20:06.054] result() for MulticoreFuture ... done
[13:20:06.055] result() for MulticoreFuture ...
[13:20:06.055] result() for MulticoreFuture ... done
[13:20:06.055] result() for MulticoreFuture ...
[13:20:06.055] result() for MulticoreFuture ... done
[13:20:06.055] result() for MulticoreFuture ...
[13:20:06.055] result() for MulticoreFuture ... done
[13:20:06.055] - relayed: [n=2] TRUE, TRUE
[13:20:06.055] - queued futures: [n=2] TRUE, TRUE
[13:20:06.056] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:06.056]  length: 0 (resolved future 2)
[13:20:06.056] Relaying remaining futures
[13:20:06.056] signalConditionsASAP(NULL, pos=0) ...
[13:20:06.056] - nx: 2
[13:20:06.056] - relay: TRUE
[13:20:06.056] - stdout: TRUE
[13:20:06.056] - signal: TRUE
[13:20:06.056] - resignal: FALSE
[13:20:06.057] - force: TRUE
[13:20:06.057] - relayed: [n=2] TRUE, TRUE
[13:20:06.057] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:06.057] - relayed: [n=2] TRUE, TRUE
[13:20:06.057] - queued futures: [n=2] TRUE, TRUE
[13:20:06.057] signalConditionsASAP(NULL, pos=0) ... done
[13:20:06.057] resolve() on list ... DONE
[13:20:06.057] result() for MulticoreFuture ...
[13:20:06.057] result() for MulticoreFuture ... done
[13:20:06.058] result() for MulticoreFuture ...
[13:20:06.058] result() for MulticoreFuture ... done
[13:20:06.058] result() for MulticoreFuture ...
[13:20:06.058] result() for MulticoreFuture ... done
[13:20:06.058] result() for MulticoreFuture ...
[13:20:06.058] result() for MulticoreFuture ... done
[13:20:06.058]  - Number of value chunks collected: 2
[13:20:06.058] Resolving 2 futures (chunks) ... DONE
[13:20:06.059] Reducing values from 2 chunks ...
[13:20:06.059]  - Number of values collected after concatenation: 3
[13:20:06.059]  - Number of values expected: 3
[13:20:06.059] Reducing values from 2 chunks ... DONE
[13:20:06.059] future_lapply() ... DONE
[13:20:06.060] future_lapply() ...
[13:20:06.065] Number of chunks: 2
[13:20:06.065] getGlobalsAndPackagesXApply() ...
[13:20:06.065]  - future.globals: TRUE
[13:20:06.065] getGlobalsAndPackages() ...
[13:20:06.065] Searching for globals...
[13:20:06.069] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:06.069] Searching for globals ... DONE
[13:20:06.069] Resolving globals: FALSE
[13:20:06.070] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:20:06.070] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:20:06.070] - globals: [1] ‘FUN’
[13:20:06.070] - packages: [1] ‘stats’
[13:20:06.071] getGlobalsAndPackages() ... DONE
[13:20:06.071]  - globals found/used: [n=1] ‘FUN’
[13:20:06.071]  - needed namespaces: [n=1] ‘stats’
[13:20:06.071] Finding globals ... DONE
[13:20:06.071]  - use_args: TRUE
[13:20:06.071]  - Getting '...' globals ...
[13:20:06.072] resolve() on list ...
[13:20:06.072]  recursive: 0
[13:20:06.072]  length: 1
[13:20:06.072]  elements: ‘...’
[13:20:06.072]  length: 0 (resolved future 1)
[13:20:06.072] resolve() on list ... DONE
[13:20:06.073]    - '...' content: [n=1] ‘probs’
[13:20:06.073] List of 1
[13:20:06.073]  $ ...:List of 1
[13:20:06.073]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:20:06.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.073]  - attr(*, "where")=List of 1
[13:20:06.073]   ..$ ...:<environment: 0x558fd9703140> 
[13:20:06.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.073]  - attr(*, "resolved")= logi TRUE
[13:20:06.073]  - attr(*, "total_size")= num NA
[13:20:06.076]  - Getting '...' globals ... DONE
[13:20:06.077] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:06.077] List of 2
[13:20:06.077]  $ ...future.FUN:function (x, ...)  
[13:20:06.077]  $ ...          :List of 1
[13:20:06.077]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:20:06.077]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.077]  - attr(*, "where")=List of 2
[13:20:06.077]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:06.077]   ..$ ...          :<environment: 0x558fd9703140> 
[13:20:06.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.077]  - attr(*, "resolved")= logi FALSE
[13:20:06.077]  - attr(*, "total_size")= num 1328
[13:20:06.080] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:06.080] getGlobalsAndPackagesXApply() ... DONE
[13:20:06.080] Number of futures (= number of chunks): 2
[13:20:06.080] Launching 2 futures (chunks) ...
[13:20:06.080] Chunk #1 of 2 ...
[13:20:06.081]  - Finding globals in 'X' for chunk #1 ...
[13:20:06.081] getGlobalsAndPackages() ...
[13:20:06.081] Searching for globals...
[13:20:06.081] 
[13:20:06.081] Searching for globals ... DONE
[13:20:06.081] - globals: [0] <none>
[13:20:06.081] getGlobalsAndPackages() ... DONE
[13:20:06.081]    + additional globals found: [n=0] 
[13:20:06.081]    + additional namespaces needed: [n=0] 
[13:20:06.082]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:06.082]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:06.082]  - seeds: <none>
[13:20:06.082]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.082] getGlobalsAndPackages() ...
[13:20:06.082] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.082] Resolving globals: FALSE
[13:20:06.082] Tweak future expression to call with '...' arguments ...
[13:20:06.082] {
[13:20:06.082]     do.call(function(...) {
[13:20:06.082]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.082]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.082]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.082]             on.exit(options(oopts), add = TRUE)
[13:20:06.082]         }
[13:20:06.082]         {
[13:20:06.082]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.082]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.082]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.082]             })
[13:20:06.082]         }
[13:20:06.082]     }, args = future.call.arguments)
[13:20:06.082] }
[13:20:06.083] Tweak future expression to call with '...' arguments ... DONE
[13:20:06.083] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.083] - packages: [1] ‘stats’
[13:20:06.083] getGlobalsAndPackages() ... DONE
[13:20:06.084] run() for ‘Future’ ...
[13:20:06.084] - state: ‘created’
[13:20:06.084] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:06.088] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:06.088]   - Field: ‘label’
[13:20:06.089]   - Field: ‘local’
[13:20:06.089]   - Field: ‘owner’
[13:20:06.089]   - Field: ‘envir’
[13:20:06.089]   - Field: ‘workers’
[13:20:06.089]   - Field: ‘packages’
[13:20:06.089]   - Field: ‘gc’
[13:20:06.089]   - Field: ‘job’
[13:20:06.089]   - Field: ‘conditions’
[13:20:06.089]   - Field: ‘expr’
[13:20:06.090]   - Field: ‘uuid’
[13:20:06.090]   - Field: ‘seed’
[13:20:06.090]   - Field: ‘version’
[13:20:06.090]   - Field: ‘result’
[13:20:06.090]   - Field: ‘asynchronous’
[13:20:06.090]   - Field: ‘calls’
[13:20:06.090]   - Field: ‘globals’
[13:20:06.090]   - Field: ‘stdout’
[13:20:06.090]   - Field: ‘earlySignal’
[13:20:06.090]   - Field: ‘lazy’
[13:20:06.091]   - Field: ‘state’
[13:20:06.091] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:06.091] - Launch lazy future ...
[13:20:06.091] Packages needed by the future expression (n = 1): ‘stats’
[13:20:06.091] Packages needed by future strategies (n = 0): <none>
[13:20:06.092] {
[13:20:06.092]     {
[13:20:06.092]         {
[13:20:06.092]             ...future.startTime <- base::Sys.time()
[13:20:06.092]             {
[13:20:06.092]                 {
[13:20:06.092]                   {
[13:20:06.092]                     {
[13:20:06.092]                       {
[13:20:06.092]                         base::local({
[13:20:06.092]                           has_future <- base::requireNamespace("future", 
[13:20:06.092]                             quietly = TRUE)
[13:20:06.092]                           if (has_future) {
[13:20:06.092]                             ns <- base::getNamespace("future")
[13:20:06.092]                             version <- ns[[".package"]][["version"]]
[13:20:06.092]                             if (is.null(version)) 
[13:20:06.092]                               version <- utils::packageVersion("future")
[13:20:06.092]                           }
[13:20:06.092]                           else {
[13:20:06.092]                             version <- NULL
[13:20:06.092]                           }
[13:20:06.092]                           if (!has_future || version < "1.8.0") {
[13:20:06.092]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:06.092]                               "", base::R.version$version.string), 
[13:20:06.092]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:06.092]                                 base::R.version$platform, 8 * 
[13:20:06.092]                                   base::.Machine$sizeof.pointer), 
[13:20:06.092]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:06.092]                                 "release", "version")], collapse = " "), 
[13:20:06.092]                               hostname = base::Sys.info()[["nodename"]])
[13:20:06.092]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:06.092]                               info)
[13:20:06.092]                             info <- base::paste(info, collapse = "; ")
[13:20:06.092]                             if (!has_future) {
[13:20:06.092]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:06.092]                                 info)
[13:20:06.092]                             }
[13:20:06.092]                             else {
[13:20:06.092]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:06.092]                                 info, version)
[13:20:06.092]                             }
[13:20:06.092]                             base::stop(msg)
[13:20:06.092]                           }
[13:20:06.092]                         })
[13:20:06.092]                       }
[13:20:06.092]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:06.092]                       base::options(mc.cores = 1L)
[13:20:06.092]                     }
[13:20:06.092]                     base::local({
[13:20:06.092]                       for (pkg in "stats") {
[13:20:06.092]                         base::loadNamespace(pkg)
[13:20:06.092]                         base::library(pkg, character.only = TRUE)
[13:20:06.092]                       }
[13:20:06.092]                     })
[13:20:06.092]                   }
[13:20:06.092]                   options(future.plan = NULL)
[13:20:06.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:06.092]                 }
[13:20:06.092]                 ...future.workdir <- getwd()
[13:20:06.092]             }
[13:20:06.092]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:06.092]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:06.092]         }
[13:20:06.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:06.092]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:06.092]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:06.092]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:06.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:06.092]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:06.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:06.092]             base::names(...future.oldOptions))
[13:20:06.092]     }
[13:20:06.092]     if (FALSE) {
[13:20:06.092]     }
[13:20:06.092]     else {
[13:20:06.092]         if (TRUE) {
[13:20:06.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:06.092]                 open = "w")
[13:20:06.092]         }
[13:20:06.092]         else {
[13:20:06.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:06.092]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:06.092]         }
[13:20:06.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:06.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:06.092]             base::sink(type = "output", split = FALSE)
[13:20:06.092]             base::close(...future.stdout)
[13:20:06.092]         }, add = TRUE)
[13:20:06.092]     }
[13:20:06.092]     ...future.frame <- base::sys.nframe()
[13:20:06.092]     ...future.conditions <- base::list()
[13:20:06.092]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:06.092]     if (FALSE) {
[13:20:06.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:06.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:06.092]     }
[13:20:06.092]     ...future.result <- base::tryCatch({
[13:20:06.092]         base::withCallingHandlers({
[13:20:06.092]             ...future.value <- base::withVisible(base::local({
[13:20:06.092]                 withCallingHandlers({
[13:20:06.092]                   {
[13:20:06.092]                     do.call(function(...) {
[13:20:06.092]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.092]                       if (!identical(...future.globals.maxSize.org, 
[13:20:06.092]                         ...future.globals.maxSize)) {
[13:20:06.092]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.092]                         on.exit(options(oopts), add = TRUE)
[13:20:06.092]                       }
[13:20:06.092]                       {
[13:20:06.092]                         lapply(seq_along(...future.elements_ii), 
[13:20:06.092]                           FUN = function(jj) {
[13:20:06.092]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.092]                             ...future.FUN(...future.X_jj, ...)
[13:20:06.092]                           })
[13:20:06.092]                       }
[13:20:06.092]                     }, args = future.call.arguments)
[13:20:06.092]                   }
[13:20:06.092]                 }, immediateCondition = function(cond) {
[13:20:06.092]                   save_rds <- function (object, pathname, ...) 
[13:20:06.092]                   {
[13:20:06.092]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:06.092]                     if (file_test("-f", pathname_tmp)) {
[13:20:06.092]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.092]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:06.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.092]                         fi_tmp[["mtime"]])
[13:20:06.092]                     }
[13:20:06.092]                     tryCatch({
[13:20:06.092]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:06.092]                     }, error = function(ex) {
[13:20:06.092]                       msg <- conditionMessage(ex)
[13:20:06.092]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.092]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:06.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.092]                         fi_tmp[["mtime"]], msg)
[13:20:06.092]                       ex$message <- msg
[13:20:06.092]                       stop(ex)
[13:20:06.092]                     })
[13:20:06.092]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:06.092]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:06.092]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:06.092]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.092]                       fi <- file.info(pathname)
[13:20:06.092]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:06.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.092]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:06.092]                         fi[["size"]], fi[["mtime"]])
[13:20:06.092]                       stop(msg)
[13:20:06.092]                     }
[13:20:06.092]                     invisible(pathname)
[13:20:06.092]                   }
[13:20:06.092]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:06.092]                     rootPath = tempdir()) 
[13:20:06.092]                   {
[13:20:06.092]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:06.092]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:06.092]                       tmpdir = path, fileext = ".rds")
[13:20:06.092]                     save_rds(obj, file)
[13:20:06.092]                   }
[13:20:06.092]                   saveImmediateCondition(cond, path = "/tmp/RtmpKCdc3U/.future/immediateConditions")
[13:20:06.092]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.092]                   {
[13:20:06.092]                     inherits <- base::inherits
[13:20:06.092]                     invokeRestart <- base::invokeRestart
[13:20:06.092]                     is.null <- base::is.null
[13:20:06.092]                     muffled <- FALSE
[13:20:06.092]                     if (inherits(cond, "message")) {
[13:20:06.092]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:06.092]                       if (muffled) 
[13:20:06.092]                         invokeRestart("muffleMessage")
[13:20:06.092]                     }
[13:20:06.092]                     else if (inherits(cond, "warning")) {
[13:20:06.092]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:06.092]                       if (muffled) 
[13:20:06.092]                         invokeRestart("muffleWarning")
[13:20:06.092]                     }
[13:20:06.092]                     else if (inherits(cond, "condition")) {
[13:20:06.092]                       if (!is.null(pattern)) {
[13:20:06.092]                         computeRestarts <- base::computeRestarts
[13:20:06.092]                         grepl <- base::grepl
[13:20:06.092]                         restarts <- computeRestarts(cond)
[13:20:06.092]                         for (restart in restarts) {
[13:20:06.092]                           name <- restart$name
[13:20:06.092]                           if (is.null(name)) 
[13:20:06.092]                             next
[13:20:06.092]                           if (!grepl(pattern, name)) 
[13:20:06.092]                             next
[13:20:06.092]                           invokeRestart(restart)
[13:20:06.092]                           muffled <- TRUE
[13:20:06.092]                           break
[13:20:06.092]                         }
[13:20:06.092]                       }
[13:20:06.092]                     }
[13:20:06.092]                     invisible(muffled)
[13:20:06.092]                   }
[13:20:06.092]                   muffleCondition(cond)
[13:20:06.092]                 })
[13:20:06.092]             }))
[13:20:06.092]             future::FutureResult(value = ...future.value$value, 
[13:20:06.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.092]                   ...future.rng), globalenv = if (FALSE) 
[13:20:06.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:06.092]                     ...future.globalenv.names))
[13:20:06.092]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:06.092]         }, condition = base::local({
[13:20:06.092]             c <- base::c
[13:20:06.092]             inherits <- base::inherits
[13:20:06.092]             invokeRestart <- base::invokeRestart
[13:20:06.092]             length <- base::length
[13:20:06.092]             list <- base::list
[13:20:06.092]             seq.int <- base::seq.int
[13:20:06.092]             signalCondition <- base::signalCondition
[13:20:06.092]             sys.calls <- base::sys.calls
[13:20:06.092]             `[[` <- base::`[[`
[13:20:06.092]             `+` <- base::`+`
[13:20:06.092]             `<<-` <- base::`<<-`
[13:20:06.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:06.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:06.092]                   3L)]
[13:20:06.092]             }
[13:20:06.092]             function(cond) {
[13:20:06.092]                 is_error <- inherits(cond, "error")
[13:20:06.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:06.092]                   NULL)
[13:20:06.092]                 if (is_error) {
[13:20:06.092]                   sessionInformation <- function() {
[13:20:06.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:06.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:06.092]                       search = base::search(), system = base::Sys.info())
[13:20:06.092]                   }
[13:20:06.092]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:06.092]                     cond$call), session = sessionInformation(), 
[13:20:06.092]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:06.092]                   signalCondition(cond)
[13:20:06.092]                 }
[13:20:06.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:06.092]                 "immediateCondition"))) {
[13:20:06.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:06.092]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:06.092]                   if (TRUE && !signal) {
[13:20:06.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.092]                     {
[13:20:06.092]                       inherits <- base::inherits
[13:20:06.092]                       invokeRestart <- base::invokeRestart
[13:20:06.092]                       is.null <- base::is.null
[13:20:06.092]                       muffled <- FALSE
[13:20:06.092]                       if (inherits(cond, "message")) {
[13:20:06.092]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.092]                         if (muffled) 
[13:20:06.092]                           invokeRestart("muffleMessage")
[13:20:06.092]                       }
[13:20:06.092]                       else if (inherits(cond, "warning")) {
[13:20:06.092]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.092]                         if (muffled) 
[13:20:06.092]                           invokeRestart("muffleWarning")
[13:20:06.092]                       }
[13:20:06.092]                       else if (inherits(cond, "condition")) {
[13:20:06.092]                         if (!is.null(pattern)) {
[13:20:06.092]                           computeRestarts <- base::computeRestarts
[13:20:06.092]                           grepl <- base::grepl
[13:20:06.092]                           restarts <- computeRestarts(cond)
[13:20:06.092]                           for (restart in restarts) {
[13:20:06.092]                             name <- restart$name
[13:20:06.092]                             if (is.null(name)) 
[13:20:06.092]                               next
[13:20:06.092]                             if (!grepl(pattern, name)) 
[13:20:06.092]                               next
[13:20:06.092]                             invokeRestart(restart)
[13:20:06.092]                             muffled <- TRUE
[13:20:06.092]                             break
[13:20:06.092]                           }
[13:20:06.092]                         }
[13:20:06.092]                       }
[13:20:06.092]                       invisible(muffled)
[13:20:06.092]                     }
[13:20:06.092]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.092]                   }
[13:20:06.092]                 }
[13:20:06.092]                 else {
[13:20:06.092]                   if (TRUE) {
[13:20:06.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.092]                     {
[13:20:06.092]                       inherits <- base::inherits
[13:20:06.092]                       invokeRestart <- base::invokeRestart
[13:20:06.092]                       is.null <- base::is.null
[13:20:06.092]                       muffled <- FALSE
[13:20:06.092]                       if (inherits(cond, "message")) {
[13:20:06.092]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.092]                         if (muffled) 
[13:20:06.092]                           invokeRestart("muffleMessage")
[13:20:06.092]                       }
[13:20:06.092]                       else if (inherits(cond, "warning")) {
[13:20:06.092]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.092]                         if (muffled) 
[13:20:06.092]                           invokeRestart("muffleWarning")
[13:20:06.092]                       }
[13:20:06.092]                       else if (inherits(cond, "condition")) {
[13:20:06.092]                         if (!is.null(pattern)) {
[13:20:06.092]                           computeRestarts <- base::computeRestarts
[13:20:06.092]                           grepl <- base::grepl
[13:20:06.092]                           restarts <- computeRestarts(cond)
[13:20:06.092]                           for (restart in restarts) {
[13:20:06.092]                             name <- restart$name
[13:20:06.092]                             if (is.null(name)) 
[13:20:06.092]                               next
[13:20:06.092]                             if (!grepl(pattern, name)) 
[13:20:06.092]                               next
[13:20:06.092]                             invokeRestart(restart)
[13:20:06.092]                             muffled <- TRUE
[13:20:06.092]                             break
[13:20:06.092]                           }
[13:20:06.092]                         }
[13:20:06.092]                       }
[13:20:06.092]                       invisible(muffled)
[13:20:06.092]                     }
[13:20:06.092]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.092]                   }
[13:20:06.092]                 }
[13:20:06.092]             }
[13:20:06.092]         }))
[13:20:06.092]     }, error = function(ex) {
[13:20:06.092]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:06.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.092]                 ...future.rng), started = ...future.startTime, 
[13:20:06.092]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:06.092]             version = "1.8"), class = "FutureResult")
[13:20:06.092]     }, finally = {
[13:20:06.092]         if (!identical(...future.workdir, getwd())) 
[13:20:06.092]             setwd(...future.workdir)
[13:20:06.092]         {
[13:20:06.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:06.092]                 ...future.oldOptions$nwarnings <- NULL
[13:20:06.092]             }
[13:20:06.092]             base::options(...future.oldOptions)
[13:20:06.092]             if (.Platform$OS.type == "windows") {
[13:20:06.092]                 old_names <- names(...future.oldEnvVars)
[13:20:06.092]                 envs <- base::Sys.getenv()
[13:20:06.092]                 names <- names(envs)
[13:20:06.092]                 common <- intersect(names, old_names)
[13:20:06.092]                 added <- setdiff(names, old_names)
[13:20:06.092]                 removed <- setdiff(old_names, names)
[13:20:06.092]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:06.092]                   envs[common]]
[13:20:06.092]                 NAMES <- toupper(changed)
[13:20:06.092]                 args <- list()
[13:20:06.092]                 for (kk in seq_along(NAMES)) {
[13:20:06.092]                   name <- changed[[kk]]
[13:20:06.092]                   NAME <- NAMES[[kk]]
[13:20:06.092]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.092]                     next
[13:20:06.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.092]                 }
[13:20:06.092]                 NAMES <- toupper(added)
[13:20:06.092]                 for (kk in seq_along(NAMES)) {
[13:20:06.092]                   name <- added[[kk]]
[13:20:06.092]                   NAME <- NAMES[[kk]]
[13:20:06.092]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.092]                     next
[13:20:06.092]                   args[[name]] <- ""
[13:20:06.092]                 }
[13:20:06.092]                 NAMES <- toupper(removed)
[13:20:06.092]                 for (kk in seq_along(NAMES)) {
[13:20:06.092]                   name <- removed[[kk]]
[13:20:06.092]                   NAME <- NAMES[[kk]]
[13:20:06.092]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.092]                     next
[13:20:06.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.092]                 }
[13:20:06.092]                 if (length(args) > 0) 
[13:20:06.092]                   base::do.call(base::Sys.setenv, args = args)
[13:20:06.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:06.092]             }
[13:20:06.092]             else {
[13:20:06.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:06.092]             }
[13:20:06.092]             {
[13:20:06.092]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:06.092]                   0L) {
[13:20:06.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:06.092]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:06.092]                   base::options(opts)
[13:20:06.092]                 }
[13:20:06.092]                 {
[13:20:06.092]                   {
[13:20:06.092]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:06.092]                     NULL
[13:20:06.092]                   }
[13:20:06.092]                   options(future.plan = NULL)
[13:20:06.092]                   if (is.na(NA_character_)) 
[13:20:06.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:06.092]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:06.092]                     envir = parent.frame()) 
[13:20:06.092]                   {
[13:20:06.092]                     default_workers <- missing(workers)
[13:20:06.092]                     if (is.function(workers)) 
[13:20:06.092]                       workers <- workers()
[13:20:06.092]                     workers <- structure(as.integer(workers), 
[13:20:06.092]                       class = class(workers))
[13:20:06.092]                     stop_if_not(is.finite(workers), workers >= 
[13:20:06.092]                       1L)
[13:20:06.092]                     if ((workers == 1L && !inherits(workers, 
[13:20:06.092]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:06.092]                       if (default_workers) 
[13:20:06.092]                         supportsMulticore(warn = TRUE)
[13:20:06.092]                       return(sequential(..., envir = envir))
[13:20:06.092]                     }
[13:20:06.092]                     oopts <- options(mc.cores = workers)
[13:20:06.092]                     on.exit(options(oopts))
[13:20:06.092]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:06.092]                       envir = envir)
[13:20:06.092]                     if (!future$lazy) 
[13:20:06.092]                       future <- run(future)
[13:20:06.092]                     invisible(future)
[13:20:06.092]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:06.092]                 }
[13:20:06.092]             }
[13:20:06.092]         }
[13:20:06.092]     })
[13:20:06.092]     if (TRUE) {
[13:20:06.092]         base::sink(type = "output", split = FALSE)
[13:20:06.092]         if (TRUE) {
[13:20:06.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:06.092]         }
[13:20:06.092]         else {
[13:20:06.092]             ...future.result["stdout"] <- base::list(NULL)
[13:20:06.092]         }
[13:20:06.092]         base::close(...future.stdout)
[13:20:06.092]         ...future.stdout <- NULL
[13:20:06.092]     }
[13:20:06.092]     ...future.result$conditions <- ...future.conditions
[13:20:06.092]     ...future.result$finished <- base::Sys.time()
[13:20:06.092]     ...future.result
[13:20:06.092] }
[13:20:06.095] assign_globals() ...
[13:20:06.095] List of 5
[13:20:06.095]  $ ...future.FUN            :function (x, ...)  
[13:20:06.095]  $ future.call.arguments    :List of 1
[13:20:06.095]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:20:06.095]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.095]  $ ...future.elements_ii    :List of 1
[13:20:06.095]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:20:06.095]  $ ...future.seeds_ii       : NULL
[13:20:06.095]  $ ...future.globals.maxSize: NULL
[13:20:06.095]  - attr(*, "where")=List of 5
[13:20:06.095]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:06.095]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:06.095]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:06.095]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:06.095]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:06.095]  - attr(*, "resolved")= logi FALSE
[13:20:06.095]  - attr(*, "total_size")= num 1328
[13:20:06.095]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.095]  - attr(*, "already-done")= logi TRUE
[13:20:06.102] - copied ‘...future.FUN’ to environment
[13:20:06.102] - copied ‘future.call.arguments’ to environment
[13:20:06.102] - copied ‘...future.elements_ii’ to environment
[13:20:06.102] - copied ‘...future.seeds_ii’ to environment
[13:20:06.102] - copied ‘...future.globals.maxSize’ to environment
[13:20:06.102] assign_globals() ... done
[13:20:06.103] requestCore(): workers = 2
[13:20:06.105] MulticoreFuture started
[13:20:06.105] - Launch lazy future ... done
[13:20:06.105] run() for ‘MulticoreFuture’ ... done
[13:20:06.106] Created future:
[13:20:06.106] plan(): Setting new future strategy stack:
[13:20:06.107] List of future strategies:
[13:20:06.107] 1. sequential:
[13:20:06.107]    - args: function (..., envir = parent.frame())
[13:20:06.107]    - tweaked: FALSE
[13:20:06.107]    - call: NULL
[13:20:06.107] plan(): nbrOfWorkers() = 1
[13:20:06.110] plan(): Setting new future strategy stack:
[13:20:06.110] List of future strategies:
[13:20:06.110] 1. multicore:
[13:20:06.110]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:06.110]    - tweaked: FALSE
[13:20:06.110]    - call: plan(strategy)
[13:20:06.116] plan(): nbrOfWorkers() = 2
[13:20:06.106] MulticoreFuture:
[13:20:06.106] Label: ‘future_eapply-1’
[13:20:06.106] Expression:
[13:20:06.106] {
[13:20:06.106]     do.call(function(...) {
[13:20:06.106]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.106]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.106]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.106]             on.exit(options(oopts), add = TRUE)
[13:20:06.106]         }
[13:20:06.106]         {
[13:20:06.106]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.106]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.106]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.106]             })
[13:20:06.106]         }
[13:20:06.106]     }, args = future.call.arguments)
[13:20:06.106] }
[13:20:06.106] Lazy evaluation: FALSE
[13:20:06.106] Asynchronous evaluation: TRUE
[13:20:06.106] Local evaluation: TRUE
[13:20:06.106] Environment: R_GlobalEnv
[13:20:06.106] Capture standard output: TRUE
[13:20:06.106] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:06.106] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:06.106] Packages: 1 packages (‘stats’)
[13:20:06.106] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:06.106] Resolved: TRUE
[13:20:06.106] Value: <not collected>
[13:20:06.106] Conditions captured: <none>
[13:20:06.106] Early signaling: FALSE
[13:20:06.106] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:06.106] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.117] Chunk #1 of 2 ... DONE
[13:20:06.117] Chunk #2 of 2 ...
[13:20:06.117]  - Finding globals in 'X' for chunk #2 ...
[13:20:06.118] getGlobalsAndPackages() ...
[13:20:06.118] Searching for globals...
[13:20:06.118] 
[13:20:06.118] Searching for globals ... DONE
[13:20:06.118] - globals: [0] <none>
[13:20:06.119] getGlobalsAndPackages() ... DONE
[13:20:06.119]    + additional globals found: [n=0] 
[13:20:06.119]    + additional namespaces needed: [n=0] 
[13:20:06.119]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:06.119]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:06.119]  - seeds: <none>
[13:20:06.119]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.120] getGlobalsAndPackages() ...
[13:20:06.120] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.120] Resolving globals: FALSE
[13:20:06.120] Tweak future expression to call with '...' arguments ...
[13:20:06.120] {
[13:20:06.120]     do.call(function(...) {
[13:20:06.120]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.120]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.120]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.120]             on.exit(options(oopts), add = TRUE)
[13:20:06.120]         }
[13:20:06.120]         {
[13:20:06.120]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.120]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.120]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.120]             })
[13:20:06.120]         }
[13:20:06.120]     }, args = future.call.arguments)
[13:20:06.120] }
[13:20:06.121] Tweak future expression to call with '...' arguments ... DONE
[13:20:06.121] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.122] - packages: [1] ‘stats’
[13:20:06.122] getGlobalsAndPackages() ... DONE
[13:20:06.122] run() for ‘Future’ ...
[13:20:06.123] - state: ‘created’
[13:20:06.123] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:06.128] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:06.128]   - Field: ‘label’
[13:20:06.128]   - Field: ‘local’
[13:20:06.128]   - Field: ‘owner’
[13:20:06.128]   - Field: ‘envir’
[13:20:06.129]   - Field: ‘workers’
[13:20:06.129]   - Field: ‘packages’
[13:20:06.129]   - Field: ‘gc’
[13:20:06.129]   - Field: ‘job’
[13:20:06.129]   - Field: ‘conditions’
[13:20:06.129]   - Field: ‘expr’
[13:20:06.129]   - Field: ‘uuid’
[13:20:06.130]   - Field: ‘seed’
[13:20:06.130]   - Field: ‘version’
[13:20:06.130]   - Field: ‘result’
[13:20:06.130]   - Field: ‘asynchronous’
[13:20:06.130]   - Field: ‘calls’
[13:20:06.130]   - Field: ‘globals’
[13:20:06.130]   - Field: ‘stdout’
[13:20:06.131]   - Field: ‘earlySignal’
[13:20:06.131]   - Field: ‘lazy’
[13:20:06.131]   - Field: ‘state’
[13:20:06.131] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:06.131] - Launch lazy future ...
[13:20:06.132] Packages needed by the future expression (n = 1): ‘stats’
[13:20:06.132] Packages needed by future strategies (n = 0): <none>
[13:20:06.133] {
[13:20:06.133]     {
[13:20:06.133]         {
[13:20:06.133]             ...future.startTime <- base::Sys.time()
[13:20:06.133]             {
[13:20:06.133]                 {
[13:20:06.133]                   {
[13:20:06.133]                     {
[13:20:06.133]                       {
[13:20:06.133]                         base::local({
[13:20:06.133]                           has_future <- base::requireNamespace("future", 
[13:20:06.133]                             quietly = TRUE)
[13:20:06.133]                           if (has_future) {
[13:20:06.133]                             ns <- base::getNamespace("future")
[13:20:06.133]                             version <- ns[[".package"]][["version"]]
[13:20:06.133]                             if (is.null(version)) 
[13:20:06.133]                               version <- utils::packageVersion("future")
[13:20:06.133]                           }
[13:20:06.133]                           else {
[13:20:06.133]                             version <- NULL
[13:20:06.133]                           }
[13:20:06.133]                           if (!has_future || version < "1.8.0") {
[13:20:06.133]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:06.133]                               "", base::R.version$version.string), 
[13:20:06.133]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:06.133]                                 base::R.version$platform, 8 * 
[13:20:06.133]                                   base::.Machine$sizeof.pointer), 
[13:20:06.133]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:06.133]                                 "release", "version")], collapse = " "), 
[13:20:06.133]                               hostname = base::Sys.info()[["nodename"]])
[13:20:06.133]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:06.133]                               info)
[13:20:06.133]                             info <- base::paste(info, collapse = "; ")
[13:20:06.133]                             if (!has_future) {
[13:20:06.133]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:06.133]                                 info)
[13:20:06.133]                             }
[13:20:06.133]                             else {
[13:20:06.133]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:06.133]                                 info, version)
[13:20:06.133]                             }
[13:20:06.133]                             base::stop(msg)
[13:20:06.133]                           }
[13:20:06.133]                         })
[13:20:06.133]                       }
[13:20:06.133]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:06.133]                       base::options(mc.cores = 1L)
[13:20:06.133]                     }
[13:20:06.133]                     base::local({
[13:20:06.133]                       for (pkg in "stats") {
[13:20:06.133]                         base::loadNamespace(pkg)
[13:20:06.133]                         base::library(pkg, character.only = TRUE)
[13:20:06.133]                       }
[13:20:06.133]                     })
[13:20:06.133]                   }
[13:20:06.133]                   options(future.plan = NULL)
[13:20:06.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:06.133]                 }
[13:20:06.133]                 ...future.workdir <- getwd()
[13:20:06.133]             }
[13:20:06.133]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:06.133]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:06.133]         }
[13:20:06.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:06.133]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:06.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:06.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:06.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:06.133]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:06.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:06.133]             base::names(...future.oldOptions))
[13:20:06.133]     }
[13:20:06.133]     if (FALSE) {
[13:20:06.133]     }
[13:20:06.133]     else {
[13:20:06.133]         if (TRUE) {
[13:20:06.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:06.133]                 open = "w")
[13:20:06.133]         }
[13:20:06.133]         else {
[13:20:06.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:06.133]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:06.133]         }
[13:20:06.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:06.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:06.133]             base::sink(type = "output", split = FALSE)
[13:20:06.133]             base::close(...future.stdout)
[13:20:06.133]         }, add = TRUE)
[13:20:06.133]     }
[13:20:06.133]     ...future.frame <- base::sys.nframe()
[13:20:06.133]     ...future.conditions <- base::list()
[13:20:06.133]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:06.133]     if (FALSE) {
[13:20:06.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:06.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:06.133]     }
[13:20:06.133]     ...future.result <- base::tryCatch({
[13:20:06.133]         base::withCallingHandlers({
[13:20:06.133]             ...future.value <- base::withVisible(base::local({
[13:20:06.133]                 withCallingHandlers({
[13:20:06.133]                   {
[13:20:06.133]                     do.call(function(...) {
[13:20:06.133]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.133]                       if (!identical(...future.globals.maxSize.org, 
[13:20:06.133]                         ...future.globals.maxSize)) {
[13:20:06.133]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.133]                         on.exit(options(oopts), add = TRUE)
[13:20:06.133]                       }
[13:20:06.133]                       {
[13:20:06.133]                         lapply(seq_along(...future.elements_ii), 
[13:20:06.133]                           FUN = function(jj) {
[13:20:06.133]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.133]                             ...future.FUN(...future.X_jj, ...)
[13:20:06.133]                           })
[13:20:06.133]                       }
[13:20:06.133]                     }, args = future.call.arguments)
[13:20:06.133]                   }
[13:20:06.133]                 }, immediateCondition = function(cond) {
[13:20:06.133]                   save_rds <- function (object, pathname, ...) 
[13:20:06.133]                   {
[13:20:06.133]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:06.133]                     if (file_test("-f", pathname_tmp)) {
[13:20:06.133]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.133]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:06.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.133]                         fi_tmp[["mtime"]])
[13:20:06.133]                     }
[13:20:06.133]                     tryCatch({
[13:20:06.133]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:06.133]                     }, error = function(ex) {
[13:20:06.133]                       msg <- conditionMessage(ex)
[13:20:06.133]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.133]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:06.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.133]                         fi_tmp[["mtime"]], msg)
[13:20:06.133]                       ex$message <- msg
[13:20:06.133]                       stop(ex)
[13:20:06.133]                     })
[13:20:06.133]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:06.133]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:06.133]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:06.133]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.133]                       fi <- file.info(pathname)
[13:20:06.133]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:06.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.133]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:06.133]                         fi[["size"]], fi[["mtime"]])
[13:20:06.133]                       stop(msg)
[13:20:06.133]                     }
[13:20:06.133]                     invisible(pathname)
[13:20:06.133]                   }
[13:20:06.133]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:06.133]                     rootPath = tempdir()) 
[13:20:06.133]                   {
[13:20:06.133]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:06.133]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:06.133]                       tmpdir = path, fileext = ".rds")
[13:20:06.133]                     save_rds(obj, file)
[13:20:06.133]                   }
[13:20:06.133]                   saveImmediateCondition(cond, path = "/tmp/RtmpKCdc3U/.future/immediateConditions")
[13:20:06.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.133]                   {
[13:20:06.133]                     inherits <- base::inherits
[13:20:06.133]                     invokeRestart <- base::invokeRestart
[13:20:06.133]                     is.null <- base::is.null
[13:20:06.133]                     muffled <- FALSE
[13:20:06.133]                     if (inherits(cond, "message")) {
[13:20:06.133]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:06.133]                       if (muffled) 
[13:20:06.133]                         invokeRestart("muffleMessage")
[13:20:06.133]                     }
[13:20:06.133]                     else if (inherits(cond, "warning")) {
[13:20:06.133]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:06.133]                       if (muffled) 
[13:20:06.133]                         invokeRestart("muffleWarning")
[13:20:06.133]                     }
[13:20:06.133]                     else if (inherits(cond, "condition")) {
[13:20:06.133]                       if (!is.null(pattern)) {
[13:20:06.133]                         computeRestarts <- base::computeRestarts
[13:20:06.133]                         grepl <- base::grepl
[13:20:06.133]                         restarts <- computeRestarts(cond)
[13:20:06.133]                         for (restart in restarts) {
[13:20:06.133]                           name <- restart$name
[13:20:06.133]                           if (is.null(name)) 
[13:20:06.133]                             next
[13:20:06.133]                           if (!grepl(pattern, name)) 
[13:20:06.133]                             next
[13:20:06.133]                           invokeRestart(restart)
[13:20:06.133]                           muffled <- TRUE
[13:20:06.133]                           break
[13:20:06.133]                         }
[13:20:06.133]                       }
[13:20:06.133]                     }
[13:20:06.133]                     invisible(muffled)
[13:20:06.133]                   }
[13:20:06.133]                   muffleCondition(cond)
[13:20:06.133]                 })
[13:20:06.133]             }))
[13:20:06.133]             future::FutureResult(value = ...future.value$value, 
[13:20:06.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.133]                   ...future.rng), globalenv = if (FALSE) 
[13:20:06.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:06.133]                     ...future.globalenv.names))
[13:20:06.133]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:06.133]         }, condition = base::local({
[13:20:06.133]             c <- base::c
[13:20:06.133]             inherits <- base::inherits
[13:20:06.133]             invokeRestart <- base::invokeRestart
[13:20:06.133]             length <- base::length
[13:20:06.133]             list <- base::list
[13:20:06.133]             seq.int <- base::seq.int
[13:20:06.133]             signalCondition <- base::signalCondition
[13:20:06.133]             sys.calls <- base::sys.calls
[13:20:06.133]             `[[` <- base::`[[`
[13:20:06.133]             `+` <- base::`+`
[13:20:06.133]             `<<-` <- base::`<<-`
[13:20:06.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:06.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:06.133]                   3L)]
[13:20:06.133]             }
[13:20:06.133]             function(cond) {
[13:20:06.133]                 is_error <- inherits(cond, "error")
[13:20:06.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:06.133]                   NULL)
[13:20:06.133]                 if (is_error) {
[13:20:06.133]                   sessionInformation <- function() {
[13:20:06.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:06.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:06.133]                       search = base::search(), system = base::Sys.info())
[13:20:06.133]                   }
[13:20:06.133]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:06.133]                     cond$call), session = sessionInformation(), 
[13:20:06.133]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:06.133]                   signalCondition(cond)
[13:20:06.133]                 }
[13:20:06.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:06.133]                 "immediateCondition"))) {
[13:20:06.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:06.133]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:06.133]                   if (TRUE && !signal) {
[13:20:06.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.133]                     {
[13:20:06.133]                       inherits <- base::inherits
[13:20:06.133]                       invokeRestart <- base::invokeRestart
[13:20:06.133]                       is.null <- base::is.null
[13:20:06.133]                       muffled <- FALSE
[13:20:06.133]                       if (inherits(cond, "message")) {
[13:20:06.133]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.133]                         if (muffled) 
[13:20:06.133]                           invokeRestart("muffleMessage")
[13:20:06.133]                       }
[13:20:06.133]                       else if (inherits(cond, "warning")) {
[13:20:06.133]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.133]                         if (muffled) 
[13:20:06.133]                           invokeRestart("muffleWarning")
[13:20:06.133]                       }
[13:20:06.133]                       else if (inherits(cond, "condition")) {
[13:20:06.133]                         if (!is.null(pattern)) {
[13:20:06.133]                           computeRestarts <- base::computeRestarts
[13:20:06.133]                           grepl <- base::grepl
[13:20:06.133]                           restarts <- computeRestarts(cond)
[13:20:06.133]                           for (restart in restarts) {
[13:20:06.133]                             name <- restart$name
[13:20:06.133]                             if (is.null(name)) 
[13:20:06.133]                               next
[13:20:06.133]                             if (!grepl(pattern, name)) 
[13:20:06.133]                               next
[13:20:06.133]                             invokeRestart(restart)
[13:20:06.133]                             muffled <- TRUE
[13:20:06.133]                             break
[13:20:06.133]                           }
[13:20:06.133]                         }
[13:20:06.133]                       }
[13:20:06.133]                       invisible(muffled)
[13:20:06.133]                     }
[13:20:06.133]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.133]                   }
[13:20:06.133]                 }
[13:20:06.133]                 else {
[13:20:06.133]                   if (TRUE) {
[13:20:06.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.133]                     {
[13:20:06.133]                       inherits <- base::inherits
[13:20:06.133]                       invokeRestart <- base::invokeRestart
[13:20:06.133]                       is.null <- base::is.null
[13:20:06.133]                       muffled <- FALSE
[13:20:06.133]                       if (inherits(cond, "message")) {
[13:20:06.133]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.133]                         if (muffled) 
[13:20:06.133]                           invokeRestart("muffleMessage")
[13:20:06.133]                       }
[13:20:06.133]                       else if (inherits(cond, "warning")) {
[13:20:06.133]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.133]                         if (muffled) 
[13:20:06.133]                           invokeRestart("muffleWarning")
[13:20:06.133]                       }
[13:20:06.133]                       else if (inherits(cond, "condition")) {
[13:20:06.133]                         if (!is.null(pattern)) {
[13:20:06.133]                           computeRestarts <- base::computeRestarts
[13:20:06.133]                           grepl <- base::grepl
[13:20:06.133]                           restarts <- computeRestarts(cond)
[13:20:06.133]                           for (restart in restarts) {
[13:20:06.133]                             name <- restart$name
[13:20:06.133]                             if (is.null(name)) 
[13:20:06.133]                               next
[13:20:06.133]                             if (!grepl(pattern, name)) 
[13:20:06.133]                               next
[13:20:06.133]                             invokeRestart(restart)
[13:20:06.133]                             muffled <- TRUE
[13:20:06.133]                             break
[13:20:06.133]                           }
[13:20:06.133]                         }
[13:20:06.133]                       }
[13:20:06.133]                       invisible(muffled)
[13:20:06.133]                     }
[13:20:06.133]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.133]                   }
[13:20:06.133]                 }
[13:20:06.133]             }
[13:20:06.133]         }))
[13:20:06.133]     }, error = function(ex) {
[13:20:06.133]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:06.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.133]                 ...future.rng), started = ...future.startTime, 
[13:20:06.133]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:06.133]             version = "1.8"), class = "FutureResult")
[13:20:06.133]     }, finally = {
[13:20:06.133]         if (!identical(...future.workdir, getwd())) 
[13:20:06.133]             setwd(...future.workdir)
[13:20:06.133]         {
[13:20:06.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:06.133]                 ...future.oldOptions$nwarnings <- NULL
[13:20:06.133]             }
[13:20:06.133]             base::options(...future.oldOptions)
[13:20:06.133]             if (.Platform$OS.type == "windows") {
[13:20:06.133]                 old_names <- names(...future.oldEnvVars)
[13:20:06.133]                 envs <- base::Sys.getenv()
[13:20:06.133]                 names <- names(envs)
[13:20:06.133]                 common <- intersect(names, old_names)
[13:20:06.133]                 added <- setdiff(names, old_names)
[13:20:06.133]                 removed <- setdiff(old_names, names)
[13:20:06.133]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:06.133]                   envs[common]]
[13:20:06.133]                 NAMES <- toupper(changed)
[13:20:06.133]                 args <- list()
[13:20:06.133]                 for (kk in seq_along(NAMES)) {
[13:20:06.133]                   name <- changed[[kk]]
[13:20:06.133]                   NAME <- NAMES[[kk]]
[13:20:06.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.133]                     next
[13:20:06.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.133]                 }
[13:20:06.133]                 NAMES <- toupper(added)
[13:20:06.133]                 for (kk in seq_along(NAMES)) {
[13:20:06.133]                   name <- added[[kk]]
[13:20:06.133]                   NAME <- NAMES[[kk]]
[13:20:06.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.133]                     next
[13:20:06.133]                   args[[name]] <- ""
[13:20:06.133]                 }
[13:20:06.133]                 NAMES <- toupper(removed)
[13:20:06.133]                 for (kk in seq_along(NAMES)) {
[13:20:06.133]                   name <- removed[[kk]]
[13:20:06.133]                   NAME <- NAMES[[kk]]
[13:20:06.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.133]                     next
[13:20:06.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.133]                 }
[13:20:06.133]                 if (length(args) > 0) 
[13:20:06.133]                   base::do.call(base::Sys.setenv, args = args)
[13:20:06.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:06.133]             }
[13:20:06.133]             else {
[13:20:06.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:06.133]             }
[13:20:06.133]             {
[13:20:06.133]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:06.133]                   0L) {
[13:20:06.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:06.133]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:06.133]                   base::options(opts)
[13:20:06.133]                 }
[13:20:06.133]                 {
[13:20:06.133]                   {
[13:20:06.133]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:06.133]                     NULL
[13:20:06.133]                   }
[13:20:06.133]                   options(future.plan = NULL)
[13:20:06.133]                   if (is.na(NA_character_)) 
[13:20:06.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:06.133]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:06.133]                     envir = parent.frame()) 
[13:20:06.133]                   {
[13:20:06.133]                     default_workers <- missing(workers)
[13:20:06.133]                     if (is.function(workers)) 
[13:20:06.133]                       workers <- workers()
[13:20:06.133]                     workers <- structure(as.integer(workers), 
[13:20:06.133]                       class = class(workers))
[13:20:06.133]                     stop_if_not(is.finite(workers), workers >= 
[13:20:06.133]                       1L)
[13:20:06.133]                     if ((workers == 1L && !inherits(workers, 
[13:20:06.133]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:06.133]                       if (default_workers) 
[13:20:06.133]                         supportsMulticore(warn = TRUE)
[13:20:06.133]                       return(sequential(..., envir = envir))
[13:20:06.133]                     }
[13:20:06.133]                     oopts <- options(mc.cores = workers)
[13:20:06.133]                     on.exit(options(oopts))
[13:20:06.133]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:06.133]                       envir = envir)
[13:20:06.133]                     if (!future$lazy) 
[13:20:06.133]                       future <- run(future)
[13:20:06.133]                     invisible(future)
[13:20:06.133]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:06.133]                 }
[13:20:06.133]             }
[13:20:06.133]         }
[13:20:06.133]     })
[13:20:06.133]     if (TRUE) {
[13:20:06.133]         base::sink(type = "output", split = FALSE)
[13:20:06.133]         if (TRUE) {
[13:20:06.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:06.133]         }
[13:20:06.133]         else {
[13:20:06.133]             ...future.result["stdout"] <- base::list(NULL)
[13:20:06.133]         }
[13:20:06.133]         base::close(...future.stdout)
[13:20:06.133]         ...future.stdout <- NULL
[13:20:06.133]     }
[13:20:06.133]     ...future.result$conditions <- ...future.conditions
[13:20:06.133]     ...future.result$finished <- base::Sys.time()
[13:20:06.133]     ...future.result
[13:20:06.133] }
[13:20:06.136] assign_globals() ...
[13:20:06.137] List of 5
[13:20:06.137]  $ ...future.FUN            :function (x, ...)  
[13:20:06.137]  $ future.call.arguments    :List of 1
[13:20:06.137]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:20:06.137]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.137]  $ ...future.elements_ii    :List of 2
[13:20:06.137]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:20:06.137]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:20:06.137]  $ ...future.seeds_ii       : NULL
[13:20:06.137]  $ ...future.globals.maxSize: NULL
[13:20:06.137]  - attr(*, "where")=List of 5
[13:20:06.137]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:06.137]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:06.137]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:06.137]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:06.137]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:06.137]  - attr(*, "resolved")= logi FALSE
[13:20:06.137]  - attr(*, "total_size")= num 1328
[13:20:06.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.137]  - attr(*, "already-done")= logi TRUE
[13:20:06.147] - copied ‘...future.FUN’ to environment
[13:20:06.147] - copied ‘future.call.arguments’ to environment
[13:20:06.147] - copied ‘...future.elements_ii’ to environment
[13:20:06.147] - copied ‘...future.seeds_ii’ to environment
[13:20:06.148] - copied ‘...future.globals.maxSize’ to environment
[13:20:06.148] assign_globals() ... done
[13:20:06.148] requestCore(): workers = 2
[13:20:06.151] MulticoreFuture started
[13:20:06.151] - Launch lazy future ... done
[13:20:06.151] run() for ‘MulticoreFuture’ ... done
[13:20:06.152] Created future:
[13:20:06.153] plan(): Setting new future strategy stack:
[13:20:06.153] List of future strategies:
[13:20:06.153] 1. sequential:
[13:20:06.153]    - args: function (..., envir = parent.frame())
[13:20:06.153]    - tweaked: FALSE
[13:20:06.153]    - call: NULL
[13:20:06.154] plan(): nbrOfWorkers() = 1
[13:20:06.157] plan(): Setting new future strategy stack:
[13:20:06.157] List of future strategies:
[13:20:06.157] 1. multicore:
[13:20:06.157]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:06.157]    - tweaked: FALSE
[13:20:06.157]    - call: plan(strategy)
[13:20:06.163] plan(): nbrOfWorkers() = 2
[13:20:06.152] MulticoreFuture:
[13:20:06.152] Label: ‘future_eapply-2’
[13:20:06.152] Expression:
[13:20:06.152] {
[13:20:06.152]     do.call(function(...) {
[13:20:06.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.152]             on.exit(options(oopts), add = TRUE)
[13:20:06.152]         }
[13:20:06.152]         {
[13:20:06.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.152]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.152]             })
[13:20:06.152]         }
[13:20:06.152]     }, args = future.call.arguments)
[13:20:06.152] }
[13:20:06.152] Lazy evaluation: FALSE
[13:20:06.152] Asynchronous evaluation: TRUE
[13:20:06.152] Local evaluation: TRUE
[13:20:06.152] Environment: R_GlobalEnv
[13:20:06.152] Capture standard output: TRUE
[13:20:06.152] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:06.152] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:06.152] Packages: 1 packages (‘stats’)
[13:20:06.152] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:06.152] Resolved: TRUE
[13:20:06.152] Value: <not collected>
[13:20:06.152] Conditions captured: <none>
[13:20:06.152] Early signaling: FALSE
[13:20:06.152] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:06.152] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.165] Chunk #2 of 2 ... DONE
[13:20:06.165] Launching 2 futures (chunks) ... DONE
[13:20:06.165] Resolving 2 futures (chunks) ...
[13:20:06.165] resolve() on list ...
[13:20:06.165]  recursive: 0
[13:20:06.166]  length: 2
[13:20:06.166] 
[13:20:06.166] Future #1
[13:20:06.166] result() for MulticoreFuture ...
[13:20:06.168] result() for MulticoreFuture ...
[13:20:06.168] result() for MulticoreFuture ... done
[13:20:06.168] result() for MulticoreFuture ... done
[13:20:06.168] result() for MulticoreFuture ...
[13:20:06.169] result() for MulticoreFuture ... done
[13:20:06.169] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:20:06.169] - nx: 2
[13:20:06.169] - relay: TRUE
[13:20:06.169] - stdout: TRUE
[13:20:06.170] - signal: TRUE
[13:20:06.170] - resignal: FALSE
[13:20:06.170] - force: TRUE
[13:20:06.170] - relayed: [n=2] FALSE, FALSE
[13:20:06.170] - queued futures: [n=2] FALSE, FALSE
[13:20:06.171]  - until=1
[13:20:06.171]  - relaying element #1
[13:20:06.171] result() for MulticoreFuture ...
[13:20:06.171] result() for MulticoreFuture ... done
[13:20:06.171] result() for MulticoreFuture ...
[13:20:06.172] result() for MulticoreFuture ... done
[13:20:06.172] result() for MulticoreFuture ...
[13:20:06.172] result() for MulticoreFuture ... done
[13:20:06.172] result() for MulticoreFuture ...
[13:20:06.173] result() for MulticoreFuture ... done
[13:20:06.173] - relayed: [n=2] TRUE, FALSE
[13:20:06.173] - queued futures: [n=2] TRUE, FALSE
[13:20:06.173] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:20:06.173]  length: 1 (resolved future 1)
[13:20:06.174] Future #2
[13:20:06.174] result() for MulticoreFuture ...
[13:20:06.175] result() for MulticoreFuture ...
[13:20:06.175] result() for MulticoreFuture ... done
[13:20:06.175] result() for MulticoreFuture ... done
[13:20:06.175] result() for MulticoreFuture ...
[13:20:06.175] result() for MulticoreFuture ... done
[13:20:06.175] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:06.176] - nx: 2
[13:20:06.176] - relay: TRUE
[13:20:06.176] - stdout: TRUE
[13:20:06.176] - signal: TRUE
[13:20:06.176] - resignal: FALSE
[13:20:06.176] - force: TRUE
[13:20:06.176] - relayed: [n=2] TRUE, FALSE
[13:20:06.176] - queued futures: [n=2] TRUE, FALSE
[13:20:06.177]  - until=2
[13:20:06.177]  - relaying element #2
[13:20:06.177] result() for MulticoreFuture ...
[13:20:06.177] result() for MulticoreFuture ... done
[13:20:06.177] result() for MulticoreFuture ...
[13:20:06.177] result() for MulticoreFuture ... done
[13:20:06.177] result() for MulticoreFuture ...
[13:20:06.177] result() for MulticoreFuture ... done
[13:20:06.178] result() for MulticoreFuture ...
[13:20:06.178] result() for MulticoreFuture ... done
[13:20:06.178] - relayed: [n=2] TRUE, TRUE
[13:20:06.178] - queued futures: [n=2] TRUE, TRUE
[13:20:06.178] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:06.178]  length: 0 (resolved future 2)
[13:20:06.178] Relaying remaining futures
[13:20:06.178] signalConditionsASAP(NULL, pos=0) ...
[13:20:06.178] - nx: 2
[13:20:06.179] - relay: TRUE
[13:20:06.179] - stdout: TRUE
[13:20:06.179] - signal: TRUE
[13:20:06.179] - resignal: FALSE
[13:20:06.179] - force: TRUE
[13:20:06.179] - relayed: [n=2] TRUE, TRUE
[13:20:06.179] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:06.179] - relayed: [n=2] TRUE, TRUE
[13:20:06.179] - queued futures: [n=2] TRUE, TRUE
[13:20:06.180] signalConditionsASAP(NULL, pos=0) ... done
[13:20:06.180] resolve() on list ... DONE
[13:20:06.180] result() for MulticoreFuture ...
[13:20:06.180] result() for MulticoreFuture ... done
[13:20:06.180] result() for MulticoreFuture ...
[13:20:06.180] result() for MulticoreFuture ... done
[13:20:06.180] result() for MulticoreFuture ...
[13:20:06.180] result() for MulticoreFuture ... done
[13:20:06.181] result() for MulticoreFuture ...
[13:20:06.181] result() for MulticoreFuture ... done
[13:20:06.181]  - Number of value chunks collected: 2
[13:20:06.181] Resolving 2 futures (chunks) ... DONE
[13:20:06.181] Reducing values from 2 chunks ...
[13:20:06.181]  - Number of values collected after concatenation: 3
[13:20:06.181]  - Number of values expected: 3
[13:20:06.181] Reducing values from 2 chunks ... DONE
[13:20:06.181] future_lapply() ... DONE
[13:20:06.183] future_lapply() ...
[13:20:06.187] Number of chunks: 2
[13:20:06.187] getGlobalsAndPackagesXApply() ...
[13:20:06.188]  - future.globals: TRUE
[13:20:06.188] getGlobalsAndPackages() ...
[13:20:06.188] Searching for globals...
[13:20:06.189] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:06.189] Searching for globals ... DONE
[13:20:06.189] Resolving globals: FALSE
[13:20:06.190] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:20:06.190] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:20:06.191] - globals: [1] ‘FUN’
[13:20:06.191] - packages: [1] ‘stats’
[13:20:06.191] getGlobalsAndPackages() ... DONE
[13:20:06.191]  - globals found/used: [n=1] ‘FUN’
[13:20:06.191]  - needed namespaces: [n=1] ‘stats’
[13:20:06.191] Finding globals ... DONE
[13:20:06.191]  - use_args: TRUE
[13:20:06.191]  - Getting '...' globals ...
[13:20:06.192] resolve() on list ...
[13:20:06.192]  recursive: 0
[13:20:06.192]  length: 1
[13:20:06.192]  elements: ‘...’
[13:20:06.192]  length: 0 (resolved future 1)
[13:20:06.192] resolve() on list ... DONE
[13:20:06.192]    - '...' content: [n=0] 
[13:20:06.193] List of 1
[13:20:06.193]  $ ...: list()
[13:20:06.193]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.193]  - attr(*, "where")=List of 1
[13:20:06.193]   ..$ ...:<environment: 0x558fd9386350> 
[13:20:06.193]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.193]  - attr(*, "resolved")= logi TRUE
[13:20:06.193]  - attr(*, "total_size")= num NA
[13:20:06.198]  - Getting '...' globals ... DONE
[13:20:06.198] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:06.198] List of 2
[13:20:06.198]  $ ...future.FUN:function (x, ...)  
[13:20:06.198]  $ ...          : list()
[13:20:06.198]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.198]  - attr(*, "where")=List of 2
[13:20:06.198]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:06.198]   ..$ ...          :<environment: 0x558fd9386350> 
[13:20:06.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.198]  - attr(*, "resolved")= logi FALSE
[13:20:06.198]  - attr(*, "total_size")= num 1248
[13:20:06.201] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:06.201] getGlobalsAndPackagesXApply() ... DONE
[13:20:06.201] Number of futures (= number of chunks): 2
[13:20:06.201] Launching 2 futures (chunks) ...
[13:20:06.202] Chunk #1 of 2 ...
[13:20:06.202]  - Finding globals in 'X' for chunk #1 ...
[13:20:06.202] getGlobalsAndPackages() ...
[13:20:06.202] Searching for globals...
[13:20:06.202] 
[13:20:06.202] Searching for globals ... DONE
[13:20:06.202] - globals: [0] <none>
[13:20:06.202] getGlobalsAndPackages() ... DONE
[13:20:06.203]    + additional globals found: [n=0] 
[13:20:06.203]    + additional namespaces needed: [n=0] 
[13:20:06.203]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:06.203]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:06.203]  - seeds: <none>
[13:20:06.203]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.203] getGlobalsAndPackages() ...
[13:20:06.203] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.203] Resolving globals: FALSE
[13:20:06.203] Tweak future expression to call with '...' arguments ...
[13:20:06.204] {
[13:20:06.204]     do.call(function(...) {
[13:20:06.204]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.204]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.204]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.204]             on.exit(options(oopts), add = TRUE)
[13:20:06.204]         }
[13:20:06.204]         {
[13:20:06.204]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.204]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.204]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.204]             })
[13:20:06.204]         }
[13:20:06.204]     }, args = future.call.arguments)
[13:20:06.204] }
[13:20:06.204] Tweak future expression to call with '...' arguments ... DONE
[13:20:06.204] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.205] - packages: [1] ‘stats’
[13:20:06.205] getGlobalsAndPackages() ... DONE
[13:20:06.205] run() for ‘Future’ ...
[13:20:06.205] - state: ‘created’
[13:20:06.205] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:06.209] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.209] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:06.210]   - Field: ‘label’
[13:20:06.210]   - Field: ‘local’
[13:20:06.210]   - Field: ‘owner’
[13:20:06.210]   - Field: ‘envir’
[13:20:06.210]   - Field: ‘workers’
[13:20:06.210]   - Field: ‘packages’
[13:20:06.210]   - Field: ‘gc’
[13:20:06.210]   - Field: ‘job’
[13:20:06.210]   - Field: ‘conditions’
[13:20:06.210]   - Field: ‘expr’
[13:20:06.211]   - Field: ‘uuid’
[13:20:06.211]   - Field: ‘seed’
[13:20:06.211]   - Field: ‘version’
[13:20:06.211]   - Field: ‘result’
[13:20:06.211]   - Field: ‘asynchronous’
[13:20:06.211]   - Field: ‘calls’
[13:20:06.211]   - Field: ‘globals’
[13:20:06.211]   - Field: ‘stdout’
[13:20:06.211]   - Field: ‘earlySignal’
[13:20:06.211]   - Field: ‘lazy’
[13:20:06.211]   - Field: ‘state’
[13:20:06.212] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:06.212] - Launch lazy future ...
[13:20:06.212] Packages needed by the future expression (n = 1): ‘stats’
[13:20:06.212] Packages needed by future strategies (n = 0): <none>
[13:20:06.213] {
[13:20:06.213]     {
[13:20:06.213]         {
[13:20:06.213]             ...future.startTime <- base::Sys.time()
[13:20:06.213]             {
[13:20:06.213]                 {
[13:20:06.213]                   {
[13:20:06.213]                     {
[13:20:06.213]                       {
[13:20:06.213]                         base::local({
[13:20:06.213]                           has_future <- base::requireNamespace("future", 
[13:20:06.213]                             quietly = TRUE)
[13:20:06.213]                           if (has_future) {
[13:20:06.213]                             ns <- base::getNamespace("future")
[13:20:06.213]                             version <- ns[[".package"]][["version"]]
[13:20:06.213]                             if (is.null(version)) 
[13:20:06.213]                               version <- utils::packageVersion("future")
[13:20:06.213]                           }
[13:20:06.213]                           else {
[13:20:06.213]                             version <- NULL
[13:20:06.213]                           }
[13:20:06.213]                           if (!has_future || version < "1.8.0") {
[13:20:06.213]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:06.213]                               "", base::R.version$version.string), 
[13:20:06.213]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:06.213]                                 base::R.version$platform, 8 * 
[13:20:06.213]                                   base::.Machine$sizeof.pointer), 
[13:20:06.213]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:06.213]                                 "release", "version")], collapse = " "), 
[13:20:06.213]                               hostname = base::Sys.info()[["nodename"]])
[13:20:06.213]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:06.213]                               info)
[13:20:06.213]                             info <- base::paste(info, collapse = "; ")
[13:20:06.213]                             if (!has_future) {
[13:20:06.213]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:06.213]                                 info)
[13:20:06.213]                             }
[13:20:06.213]                             else {
[13:20:06.213]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:06.213]                                 info, version)
[13:20:06.213]                             }
[13:20:06.213]                             base::stop(msg)
[13:20:06.213]                           }
[13:20:06.213]                         })
[13:20:06.213]                       }
[13:20:06.213]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:06.213]                       base::options(mc.cores = 1L)
[13:20:06.213]                     }
[13:20:06.213]                     base::local({
[13:20:06.213]                       for (pkg in "stats") {
[13:20:06.213]                         base::loadNamespace(pkg)
[13:20:06.213]                         base::library(pkg, character.only = TRUE)
[13:20:06.213]                       }
[13:20:06.213]                     })
[13:20:06.213]                   }
[13:20:06.213]                   options(future.plan = NULL)
[13:20:06.213]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.213]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:06.213]                 }
[13:20:06.213]                 ...future.workdir <- getwd()
[13:20:06.213]             }
[13:20:06.213]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:06.213]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:06.213]         }
[13:20:06.213]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:06.213]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:06.213]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:06.213]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:06.213]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:06.213]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:06.213]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:06.213]             base::names(...future.oldOptions))
[13:20:06.213]     }
[13:20:06.213]     if (FALSE) {
[13:20:06.213]     }
[13:20:06.213]     else {
[13:20:06.213]         if (TRUE) {
[13:20:06.213]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:06.213]                 open = "w")
[13:20:06.213]         }
[13:20:06.213]         else {
[13:20:06.213]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:06.213]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:06.213]         }
[13:20:06.213]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:06.213]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:06.213]             base::sink(type = "output", split = FALSE)
[13:20:06.213]             base::close(...future.stdout)
[13:20:06.213]         }, add = TRUE)
[13:20:06.213]     }
[13:20:06.213]     ...future.frame <- base::sys.nframe()
[13:20:06.213]     ...future.conditions <- base::list()
[13:20:06.213]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:06.213]     if (FALSE) {
[13:20:06.213]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:06.213]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:06.213]     }
[13:20:06.213]     ...future.result <- base::tryCatch({
[13:20:06.213]         base::withCallingHandlers({
[13:20:06.213]             ...future.value <- base::withVisible(base::local({
[13:20:06.213]                 withCallingHandlers({
[13:20:06.213]                   {
[13:20:06.213]                     do.call(function(...) {
[13:20:06.213]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.213]                       if (!identical(...future.globals.maxSize.org, 
[13:20:06.213]                         ...future.globals.maxSize)) {
[13:20:06.213]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.213]                         on.exit(options(oopts), add = TRUE)
[13:20:06.213]                       }
[13:20:06.213]                       {
[13:20:06.213]                         lapply(seq_along(...future.elements_ii), 
[13:20:06.213]                           FUN = function(jj) {
[13:20:06.213]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.213]                             ...future.FUN(...future.X_jj, ...)
[13:20:06.213]                           })
[13:20:06.213]                       }
[13:20:06.213]                     }, args = future.call.arguments)
[13:20:06.213]                   }
[13:20:06.213]                 }, immediateCondition = function(cond) {
[13:20:06.213]                   save_rds <- function (object, pathname, ...) 
[13:20:06.213]                   {
[13:20:06.213]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:06.213]                     if (file_test("-f", pathname_tmp)) {
[13:20:06.213]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.213]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:06.213]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.213]                         fi_tmp[["mtime"]])
[13:20:06.213]                     }
[13:20:06.213]                     tryCatch({
[13:20:06.213]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:06.213]                     }, error = function(ex) {
[13:20:06.213]                       msg <- conditionMessage(ex)
[13:20:06.213]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.213]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:06.213]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.213]                         fi_tmp[["mtime"]], msg)
[13:20:06.213]                       ex$message <- msg
[13:20:06.213]                       stop(ex)
[13:20:06.213]                     })
[13:20:06.213]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:06.213]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:06.213]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:06.213]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.213]                       fi <- file.info(pathname)
[13:20:06.213]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:06.213]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.213]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:06.213]                         fi[["size"]], fi[["mtime"]])
[13:20:06.213]                       stop(msg)
[13:20:06.213]                     }
[13:20:06.213]                     invisible(pathname)
[13:20:06.213]                   }
[13:20:06.213]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:06.213]                     rootPath = tempdir()) 
[13:20:06.213]                   {
[13:20:06.213]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:06.213]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:06.213]                       tmpdir = path, fileext = ".rds")
[13:20:06.213]                     save_rds(obj, file)
[13:20:06.213]                   }
[13:20:06.213]                   saveImmediateCondition(cond, path = "/tmp/RtmpKCdc3U/.future/immediateConditions")
[13:20:06.213]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.213]                   {
[13:20:06.213]                     inherits <- base::inherits
[13:20:06.213]                     invokeRestart <- base::invokeRestart
[13:20:06.213]                     is.null <- base::is.null
[13:20:06.213]                     muffled <- FALSE
[13:20:06.213]                     if (inherits(cond, "message")) {
[13:20:06.213]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:06.213]                       if (muffled) 
[13:20:06.213]                         invokeRestart("muffleMessage")
[13:20:06.213]                     }
[13:20:06.213]                     else if (inherits(cond, "warning")) {
[13:20:06.213]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:06.213]                       if (muffled) 
[13:20:06.213]                         invokeRestart("muffleWarning")
[13:20:06.213]                     }
[13:20:06.213]                     else if (inherits(cond, "condition")) {
[13:20:06.213]                       if (!is.null(pattern)) {
[13:20:06.213]                         computeRestarts <- base::computeRestarts
[13:20:06.213]                         grepl <- base::grepl
[13:20:06.213]                         restarts <- computeRestarts(cond)
[13:20:06.213]                         for (restart in restarts) {
[13:20:06.213]                           name <- restart$name
[13:20:06.213]                           if (is.null(name)) 
[13:20:06.213]                             next
[13:20:06.213]                           if (!grepl(pattern, name)) 
[13:20:06.213]                             next
[13:20:06.213]                           invokeRestart(restart)
[13:20:06.213]                           muffled <- TRUE
[13:20:06.213]                           break
[13:20:06.213]                         }
[13:20:06.213]                       }
[13:20:06.213]                     }
[13:20:06.213]                     invisible(muffled)
[13:20:06.213]                   }
[13:20:06.213]                   muffleCondition(cond)
[13:20:06.213]                 })
[13:20:06.213]             }))
[13:20:06.213]             future::FutureResult(value = ...future.value$value, 
[13:20:06.213]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.213]                   ...future.rng), globalenv = if (FALSE) 
[13:20:06.213]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:06.213]                     ...future.globalenv.names))
[13:20:06.213]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:06.213]         }, condition = base::local({
[13:20:06.213]             c <- base::c
[13:20:06.213]             inherits <- base::inherits
[13:20:06.213]             invokeRestart <- base::invokeRestart
[13:20:06.213]             length <- base::length
[13:20:06.213]             list <- base::list
[13:20:06.213]             seq.int <- base::seq.int
[13:20:06.213]             signalCondition <- base::signalCondition
[13:20:06.213]             sys.calls <- base::sys.calls
[13:20:06.213]             `[[` <- base::`[[`
[13:20:06.213]             `+` <- base::`+`
[13:20:06.213]             `<<-` <- base::`<<-`
[13:20:06.213]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:06.213]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:06.213]                   3L)]
[13:20:06.213]             }
[13:20:06.213]             function(cond) {
[13:20:06.213]                 is_error <- inherits(cond, "error")
[13:20:06.213]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:06.213]                   NULL)
[13:20:06.213]                 if (is_error) {
[13:20:06.213]                   sessionInformation <- function() {
[13:20:06.213]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:06.213]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:06.213]                       search = base::search(), system = base::Sys.info())
[13:20:06.213]                   }
[13:20:06.213]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.213]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:06.213]                     cond$call), session = sessionInformation(), 
[13:20:06.213]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:06.213]                   signalCondition(cond)
[13:20:06.213]                 }
[13:20:06.213]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:06.213]                 "immediateCondition"))) {
[13:20:06.213]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:06.213]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.213]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:06.213]                   if (TRUE && !signal) {
[13:20:06.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.213]                     {
[13:20:06.213]                       inherits <- base::inherits
[13:20:06.213]                       invokeRestart <- base::invokeRestart
[13:20:06.213]                       is.null <- base::is.null
[13:20:06.213]                       muffled <- FALSE
[13:20:06.213]                       if (inherits(cond, "message")) {
[13:20:06.213]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.213]                         if (muffled) 
[13:20:06.213]                           invokeRestart("muffleMessage")
[13:20:06.213]                       }
[13:20:06.213]                       else if (inherits(cond, "warning")) {
[13:20:06.213]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.213]                         if (muffled) 
[13:20:06.213]                           invokeRestart("muffleWarning")
[13:20:06.213]                       }
[13:20:06.213]                       else if (inherits(cond, "condition")) {
[13:20:06.213]                         if (!is.null(pattern)) {
[13:20:06.213]                           computeRestarts <- base::computeRestarts
[13:20:06.213]                           grepl <- base::grepl
[13:20:06.213]                           restarts <- computeRestarts(cond)
[13:20:06.213]                           for (restart in restarts) {
[13:20:06.213]                             name <- restart$name
[13:20:06.213]                             if (is.null(name)) 
[13:20:06.213]                               next
[13:20:06.213]                             if (!grepl(pattern, name)) 
[13:20:06.213]                               next
[13:20:06.213]                             invokeRestart(restart)
[13:20:06.213]                             muffled <- TRUE
[13:20:06.213]                             break
[13:20:06.213]                           }
[13:20:06.213]                         }
[13:20:06.213]                       }
[13:20:06.213]                       invisible(muffled)
[13:20:06.213]                     }
[13:20:06.213]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.213]                   }
[13:20:06.213]                 }
[13:20:06.213]                 else {
[13:20:06.213]                   if (TRUE) {
[13:20:06.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.213]                     {
[13:20:06.213]                       inherits <- base::inherits
[13:20:06.213]                       invokeRestart <- base::invokeRestart
[13:20:06.213]                       is.null <- base::is.null
[13:20:06.213]                       muffled <- FALSE
[13:20:06.213]                       if (inherits(cond, "message")) {
[13:20:06.213]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.213]                         if (muffled) 
[13:20:06.213]                           invokeRestart("muffleMessage")
[13:20:06.213]                       }
[13:20:06.213]                       else if (inherits(cond, "warning")) {
[13:20:06.213]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.213]                         if (muffled) 
[13:20:06.213]                           invokeRestart("muffleWarning")
[13:20:06.213]                       }
[13:20:06.213]                       else if (inherits(cond, "condition")) {
[13:20:06.213]                         if (!is.null(pattern)) {
[13:20:06.213]                           computeRestarts <- base::computeRestarts
[13:20:06.213]                           grepl <- base::grepl
[13:20:06.213]                           restarts <- computeRestarts(cond)
[13:20:06.213]                           for (restart in restarts) {
[13:20:06.213]                             name <- restart$name
[13:20:06.213]                             if (is.null(name)) 
[13:20:06.213]                               next
[13:20:06.213]                             if (!grepl(pattern, name)) 
[13:20:06.213]                               next
[13:20:06.213]                             invokeRestart(restart)
[13:20:06.213]                             muffled <- TRUE
[13:20:06.213]                             break
[13:20:06.213]                           }
[13:20:06.213]                         }
[13:20:06.213]                       }
[13:20:06.213]                       invisible(muffled)
[13:20:06.213]                     }
[13:20:06.213]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.213]                   }
[13:20:06.213]                 }
[13:20:06.213]             }
[13:20:06.213]         }))
[13:20:06.213]     }, error = function(ex) {
[13:20:06.213]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:06.213]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.213]                 ...future.rng), started = ...future.startTime, 
[13:20:06.213]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:06.213]             version = "1.8"), class = "FutureResult")
[13:20:06.213]     }, finally = {
[13:20:06.213]         if (!identical(...future.workdir, getwd())) 
[13:20:06.213]             setwd(...future.workdir)
[13:20:06.213]         {
[13:20:06.213]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:06.213]                 ...future.oldOptions$nwarnings <- NULL
[13:20:06.213]             }
[13:20:06.213]             base::options(...future.oldOptions)
[13:20:06.213]             if (.Platform$OS.type == "windows") {
[13:20:06.213]                 old_names <- names(...future.oldEnvVars)
[13:20:06.213]                 envs <- base::Sys.getenv()
[13:20:06.213]                 names <- names(envs)
[13:20:06.213]                 common <- intersect(names, old_names)
[13:20:06.213]                 added <- setdiff(names, old_names)
[13:20:06.213]                 removed <- setdiff(old_names, names)
[13:20:06.213]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:06.213]                   envs[common]]
[13:20:06.213]                 NAMES <- toupper(changed)
[13:20:06.213]                 args <- list()
[13:20:06.213]                 for (kk in seq_along(NAMES)) {
[13:20:06.213]                   name <- changed[[kk]]
[13:20:06.213]                   NAME <- NAMES[[kk]]
[13:20:06.213]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.213]                     next
[13:20:06.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.213]                 }
[13:20:06.213]                 NAMES <- toupper(added)
[13:20:06.213]                 for (kk in seq_along(NAMES)) {
[13:20:06.213]                   name <- added[[kk]]
[13:20:06.213]                   NAME <- NAMES[[kk]]
[13:20:06.213]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.213]                     next
[13:20:06.213]                   args[[name]] <- ""
[13:20:06.213]                 }
[13:20:06.213]                 NAMES <- toupper(removed)
[13:20:06.213]                 for (kk in seq_along(NAMES)) {
[13:20:06.213]                   name <- removed[[kk]]
[13:20:06.213]                   NAME <- NAMES[[kk]]
[13:20:06.213]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.213]                     next
[13:20:06.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.213]                 }
[13:20:06.213]                 if (length(args) > 0) 
[13:20:06.213]                   base::do.call(base::Sys.setenv, args = args)
[13:20:06.213]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:06.213]             }
[13:20:06.213]             else {
[13:20:06.213]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:06.213]             }
[13:20:06.213]             {
[13:20:06.213]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:06.213]                   0L) {
[13:20:06.213]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:06.213]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:06.213]                   base::options(opts)
[13:20:06.213]                 }
[13:20:06.213]                 {
[13:20:06.213]                   {
[13:20:06.213]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:06.213]                     NULL
[13:20:06.213]                   }
[13:20:06.213]                   options(future.plan = NULL)
[13:20:06.213]                   if (is.na(NA_character_)) 
[13:20:06.213]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.213]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:06.213]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:06.213]                     envir = parent.frame()) 
[13:20:06.213]                   {
[13:20:06.213]                     default_workers <- missing(workers)
[13:20:06.213]                     if (is.function(workers)) 
[13:20:06.213]                       workers <- workers()
[13:20:06.213]                     workers <- structure(as.integer(workers), 
[13:20:06.213]                       class = class(workers))
[13:20:06.213]                     stop_if_not(is.finite(workers), workers >= 
[13:20:06.213]                       1L)
[13:20:06.213]                     if ((workers == 1L && !inherits(workers, 
[13:20:06.213]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:06.213]                       if (default_workers) 
[13:20:06.213]                         supportsMulticore(warn = TRUE)
[13:20:06.213]                       return(sequential(..., envir = envir))
[13:20:06.213]                     }
[13:20:06.213]                     oopts <- options(mc.cores = workers)
[13:20:06.213]                     on.exit(options(oopts))
[13:20:06.213]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:06.213]                       envir = envir)
[13:20:06.213]                     if (!future$lazy) 
[13:20:06.213]                       future <- run(future)
[13:20:06.213]                     invisible(future)
[13:20:06.213]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:06.213]                 }
[13:20:06.213]             }
[13:20:06.213]         }
[13:20:06.213]     })
[13:20:06.213]     if (TRUE) {
[13:20:06.213]         base::sink(type = "output", split = FALSE)
[13:20:06.213]         if (TRUE) {
[13:20:06.213]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:06.213]         }
[13:20:06.213]         else {
[13:20:06.213]             ...future.result["stdout"] <- base::list(NULL)
[13:20:06.213]         }
[13:20:06.213]         base::close(...future.stdout)
[13:20:06.213]         ...future.stdout <- NULL
[13:20:06.213]     }
[13:20:06.213]     ...future.result$conditions <- ...future.conditions
[13:20:06.213]     ...future.result$finished <- base::Sys.time()
[13:20:06.213]     ...future.result
[13:20:06.213] }
[13:20:06.216] assign_globals() ...
[13:20:06.216] List of 5
[13:20:06.216]  $ ...future.FUN            :function (x, ...)  
[13:20:06.216]  $ future.call.arguments    : list()
[13:20:06.216]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.216]  $ ...future.elements_ii    :List of 1
[13:20:06.216]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:20:06.216]  $ ...future.seeds_ii       : NULL
[13:20:06.216]  $ ...future.globals.maxSize: NULL
[13:20:06.216]  - attr(*, "where")=List of 5
[13:20:06.216]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:06.216]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:06.216]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:06.216]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:06.216]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:06.216]  - attr(*, "resolved")= logi FALSE
[13:20:06.216]  - attr(*, "total_size")= num 1248
[13:20:06.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.216]  - attr(*, "already-done")= logi TRUE
[13:20:06.221] - copied ‘...future.FUN’ to environment
[13:20:06.221] - copied ‘future.call.arguments’ to environment
[13:20:06.221] - copied ‘...future.elements_ii’ to environment
[13:20:06.221] - copied ‘...future.seeds_ii’ to environment
[13:20:06.221] - copied ‘...future.globals.maxSize’ to environment
[13:20:06.221] assign_globals() ... done
[13:20:06.221] requestCore(): workers = 2
[13:20:06.223] MulticoreFuture started
[13:20:06.224] - Launch lazy future ... done
[13:20:06.224] run() for ‘MulticoreFuture’ ... done
[13:20:06.224] Created future:
[13:20:06.225] plan(): Setting new future strategy stack:
[13:20:06.228] List of future strategies:
[13:20:06.228] 1. sequential:
[13:20:06.228]    - args: function (..., envir = parent.frame())
[13:20:06.228]    - tweaked: FALSE
[13:20:06.228]    - call: NULL
[13:20:06.229] plan(): nbrOfWorkers() = 1
[13:20:06.232] plan(): Setting new future strategy stack:
[13:20:06.232] List of future strategies:
[13:20:06.232] 1. multicore:
[13:20:06.232]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:06.232]    - tweaked: FALSE
[13:20:06.232]    - call: plan(strategy)
[13:20:06.238] plan(): nbrOfWorkers() = 2
[13:20:06.228] MulticoreFuture:
[13:20:06.228] Label: ‘future_eapply-1’
[13:20:06.228] Expression:
[13:20:06.228] {
[13:20:06.228]     do.call(function(...) {
[13:20:06.228]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.228]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.228]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.228]             on.exit(options(oopts), add = TRUE)
[13:20:06.228]         }
[13:20:06.228]         {
[13:20:06.228]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.228]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.228]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.228]             })
[13:20:06.228]         }
[13:20:06.228]     }, args = future.call.arguments)
[13:20:06.228] }
[13:20:06.228] Lazy evaluation: FALSE
[13:20:06.228] Asynchronous evaluation: TRUE
[13:20:06.228] Local evaluation: TRUE
[13:20:06.228] Environment: R_GlobalEnv
[13:20:06.228] Capture standard output: TRUE
[13:20:06.228] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:06.228] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:06.228] Packages: 1 packages (‘stats’)
[13:20:06.228] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:06.228] Resolved: TRUE
[13:20:06.228] Value: <not collected>
[13:20:06.228] Conditions captured: <none>
[13:20:06.228] Early signaling: FALSE
[13:20:06.228] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:06.228] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.239] Chunk #1 of 2 ... DONE
[13:20:06.239] Chunk #2 of 2 ...
[13:20:06.240]  - Finding globals in 'X' for chunk #2 ...
[13:20:06.240] getGlobalsAndPackages() ...
[13:20:06.240] Searching for globals...
[13:20:06.241] 
[13:20:06.241] Searching for globals ... DONE
[13:20:06.241] - globals: [0] <none>
[13:20:06.241] getGlobalsAndPackages() ... DONE
[13:20:06.241]    + additional globals found: [n=0] 
[13:20:06.242]    + additional namespaces needed: [n=0] 
[13:20:06.242]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:06.242]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:06.242]  - seeds: <none>
[13:20:06.242]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.242] getGlobalsAndPackages() ...
[13:20:06.242] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.243] Resolving globals: FALSE
[13:20:06.243] Tweak future expression to call with '...' arguments ...
[13:20:06.243] {
[13:20:06.243]     do.call(function(...) {
[13:20:06.243]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.243]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.243]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.243]             on.exit(options(oopts), add = TRUE)
[13:20:06.243]         }
[13:20:06.243]         {
[13:20:06.243]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.243]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.243]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.243]             })
[13:20:06.243]         }
[13:20:06.243]     }, args = future.call.arguments)
[13:20:06.243] }
[13:20:06.244] Tweak future expression to call with '...' arguments ... DONE
[13:20:06.244] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.245] - packages: [1] ‘stats’
[13:20:06.245] getGlobalsAndPackages() ... DONE
[13:20:06.245] run() for ‘Future’ ...
[13:20:06.245] - state: ‘created’
[13:20:06.246] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:06.251] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.251] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:06.251]   - Field: ‘label’
[13:20:06.251]   - Field: ‘local’
[13:20:06.251]   - Field: ‘owner’
[13:20:06.251]   - Field: ‘envir’
[13:20:06.252]   - Field: ‘workers’
[13:20:06.252]   - Field: ‘packages’
[13:20:06.252]   - Field: ‘gc’
[13:20:06.252]   - Field: ‘job’
[13:20:06.252]   - Field: ‘conditions’
[13:20:06.252]   - Field: ‘expr’
[13:20:06.253]   - Field: ‘uuid’
[13:20:06.253]   - Field: ‘seed’
[13:20:06.253]   - Field: ‘version’
[13:20:06.253]   - Field: ‘result’
[13:20:06.253]   - Field: ‘asynchronous’
[13:20:06.253]   - Field: ‘calls’
[13:20:06.254]   - Field: ‘globals’
[13:20:06.254]   - Field: ‘stdout’
[13:20:06.254]   - Field: ‘earlySignal’
[13:20:06.254]   - Field: ‘lazy’
[13:20:06.254]   - Field: ‘state’
[13:20:06.254] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:06.254] - Launch lazy future ...
[13:20:06.255] Packages needed by the future expression (n = 1): ‘stats’
[13:20:06.255] Packages needed by future strategies (n = 0): <none>
[13:20:06.256] {
[13:20:06.256]     {
[13:20:06.256]         {
[13:20:06.256]             ...future.startTime <- base::Sys.time()
[13:20:06.256]             {
[13:20:06.256]                 {
[13:20:06.256]                   {
[13:20:06.256]                     {
[13:20:06.256]                       {
[13:20:06.256]                         base::local({
[13:20:06.256]                           has_future <- base::requireNamespace("future", 
[13:20:06.256]                             quietly = TRUE)
[13:20:06.256]                           if (has_future) {
[13:20:06.256]                             ns <- base::getNamespace("future")
[13:20:06.256]                             version <- ns[[".package"]][["version"]]
[13:20:06.256]                             if (is.null(version)) 
[13:20:06.256]                               version <- utils::packageVersion("future")
[13:20:06.256]                           }
[13:20:06.256]                           else {
[13:20:06.256]                             version <- NULL
[13:20:06.256]                           }
[13:20:06.256]                           if (!has_future || version < "1.8.0") {
[13:20:06.256]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:06.256]                               "", base::R.version$version.string), 
[13:20:06.256]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:06.256]                                 base::R.version$platform, 8 * 
[13:20:06.256]                                   base::.Machine$sizeof.pointer), 
[13:20:06.256]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:06.256]                                 "release", "version")], collapse = " "), 
[13:20:06.256]                               hostname = base::Sys.info()[["nodename"]])
[13:20:06.256]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:06.256]                               info)
[13:20:06.256]                             info <- base::paste(info, collapse = "; ")
[13:20:06.256]                             if (!has_future) {
[13:20:06.256]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:06.256]                                 info)
[13:20:06.256]                             }
[13:20:06.256]                             else {
[13:20:06.256]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:06.256]                                 info, version)
[13:20:06.256]                             }
[13:20:06.256]                             base::stop(msg)
[13:20:06.256]                           }
[13:20:06.256]                         })
[13:20:06.256]                       }
[13:20:06.256]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:06.256]                       base::options(mc.cores = 1L)
[13:20:06.256]                     }
[13:20:06.256]                     base::local({
[13:20:06.256]                       for (pkg in "stats") {
[13:20:06.256]                         base::loadNamespace(pkg)
[13:20:06.256]                         base::library(pkg, character.only = TRUE)
[13:20:06.256]                       }
[13:20:06.256]                     })
[13:20:06.256]                   }
[13:20:06.256]                   options(future.plan = NULL)
[13:20:06.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:06.256]                 }
[13:20:06.256]                 ...future.workdir <- getwd()
[13:20:06.256]             }
[13:20:06.256]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:06.256]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:06.256]         }
[13:20:06.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:06.256]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:06.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:06.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:06.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:06.256]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:06.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:06.256]             base::names(...future.oldOptions))
[13:20:06.256]     }
[13:20:06.256]     if (FALSE) {
[13:20:06.256]     }
[13:20:06.256]     else {
[13:20:06.256]         if (TRUE) {
[13:20:06.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:06.256]                 open = "w")
[13:20:06.256]         }
[13:20:06.256]         else {
[13:20:06.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:06.256]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:06.256]         }
[13:20:06.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:06.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:06.256]             base::sink(type = "output", split = FALSE)
[13:20:06.256]             base::close(...future.stdout)
[13:20:06.256]         }, add = TRUE)
[13:20:06.256]     }
[13:20:06.256]     ...future.frame <- base::sys.nframe()
[13:20:06.256]     ...future.conditions <- base::list()
[13:20:06.256]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:06.256]     if (FALSE) {
[13:20:06.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:06.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:06.256]     }
[13:20:06.256]     ...future.result <- base::tryCatch({
[13:20:06.256]         base::withCallingHandlers({
[13:20:06.256]             ...future.value <- base::withVisible(base::local({
[13:20:06.256]                 withCallingHandlers({
[13:20:06.256]                   {
[13:20:06.256]                     do.call(function(...) {
[13:20:06.256]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.256]                       if (!identical(...future.globals.maxSize.org, 
[13:20:06.256]                         ...future.globals.maxSize)) {
[13:20:06.256]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.256]                         on.exit(options(oopts), add = TRUE)
[13:20:06.256]                       }
[13:20:06.256]                       {
[13:20:06.256]                         lapply(seq_along(...future.elements_ii), 
[13:20:06.256]                           FUN = function(jj) {
[13:20:06.256]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.256]                             ...future.FUN(...future.X_jj, ...)
[13:20:06.256]                           })
[13:20:06.256]                       }
[13:20:06.256]                     }, args = future.call.arguments)
[13:20:06.256]                   }
[13:20:06.256]                 }, immediateCondition = function(cond) {
[13:20:06.256]                   save_rds <- function (object, pathname, ...) 
[13:20:06.256]                   {
[13:20:06.256]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:06.256]                     if (file_test("-f", pathname_tmp)) {
[13:20:06.256]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.256]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:06.256]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.256]                         fi_tmp[["mtime"]])
[13:20:06.256]                     }
[13:20:06.256]                     tryCatch({
[13:20:06.256]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:06.256]                     }, error = function(ex) {
[13:20:06.256]                       msg <- conditionMessage(ex)
[13:20:06.256]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.256]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:06.256]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.256]                         fi_tmp[["mtime"]], msg)
[13:20:06.256]                       ex$message <- msg
[13:20:06.256]                       stop(ex)
[13:20:06.256]                     })
[13:20:06.256]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:06.256]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:06.256]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:06.256]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.256]                       fi <- file.info(pathname)
[13:20:06.256]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:06.256]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.256]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:06.256]                         fi[["size"]], fi[["mtime"]])
[13:20:06.256]                       stop(msg)
[13:20:06.256]                     }
[13:20:06.256]                     invisible(pathname)
[13:20:06.256]                   }
[13:20:06.256]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:06.256]                     rootPath = tempdir()) 
[13:20:06.256]                   {
[13:20:06.256]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:06.256]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:06.256]                       tmpdir = path, fileext = ".rds")
[13:20:06.256]                     save_rds(obj, file)
[13:20:06.256]                   }
[13:20:06.256]                   saveImmediateCondition(cond, path = "/tmp/RtmpKCdc3U/.future/immediateConditions")
[13:20:06.256]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.256]                   {
[13:20:06.256]                     inherits <- base::inherits
[13:20:06.256]                     invokeRestart <- base::invokeRestart
[13:20:06.256]                     is.null <- base::is.null
[13:20:06.256]                     muffled <- FALSE
[13:20:06.256]                     if (inherits(cond, "message")) {
[13:20:06.256]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:06.256]                       if (muffled) 
[13:20:06.256]                         invokeRestart("muffleMessage")
[13:20:06.256]                     }
[13:20:06.256]                     else if (inherits(cond, "warning")) {
[13:20:06.256]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:06.256]                       if (muffled) 
[13:20:06.256]                         invokeRestart("muffleWarning")
[13:20:06.256]                     }
[13:20:06.256]                     else if (inherits(cond, "condition")) {
[13:20:06.256]                       if (!is.null(pattern)) {
[13:20:06.256]                         computeRestarts <- base::computeRestarts
[13:20:06.256]                         grepl <- base::grepl
[13:20:06.256]                         restarts <- computeRestarts(cond)
[13:20:06.256]                         for (restart in restarts) {
[13:20:06.256]                           name <- restart$name
[13:20:06.256]                           if (is.null(name)) 
[13:20:06.256]                             next
[13:20:06.256]                           if (!grepl(pattern, name)) 
[13:20:06.256]                             next
[13:20:06.256]                           invokeRestart(restart)
[13:20:06.256]                           muffled <- TRUE
[13:20:06.256]                           break
[13:20:06.256]                         }
[13:20:06.256]                       }
[13:20:06.256]                     }
[13:20:06.256]                     invisible(muffled)
[13:20:06.256]                   }
[13:20:06.256]                   muffleCondition(cond)
[13:20:06.256]                 })
[13:20:06.256]             }))
[13:20:06.256]             future::FutureResult(value = ...future.value$value, 
[13:20:06.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.256]                   ...future.rng), globalenv = if (FALSE) 
[13:20:06.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:06.256]                     ...future.globalenv.names))
[13:20:06.256]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:06.256]         }, condition = base::local({
[13:20:06.256]             c <- base::c
[13:20:06.256]             inherits <- base::inherits
[13:20:06.256]             invokeRestart <- base::invokeRestart
[13:20:06.256]             length <- base::length
[13:20:06.256]             list <- base::list
[13:20:06.256]             seq.int <- base::seq.int
[13:20:06.256]             signalCondition <- base::signalCondition
[13:20:06.256]             sys.calls <- base::sys.calls
[13:20:06.256]             `[[` <- base::`[[`
[13:20:06.256]             `+` <- base::`+`
[13:20:06.256]             `<<-` <- base::`<<-`
[13:20:06.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:06.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:06.256]                   3L)]
[13:20:06.256]             }
[13:20:06.256]             function(cond) {
[13:20:06.256]                 is_error <- inherits(cond, "error")
[13:20:06.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:06.256]                   NULL)
[13:20:06.256]                 if (is_error) {
[13:20:06.256]                   sessionInformation <- function() {
[13:20:06.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:06.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:06.256]                       search = base::search(), system = base::Sys.info())
[13:20:06.256]                   }
[13:20:06.256]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:06.256]                     cond$call), session = sessionInformation(), 
[13:20:06.256]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:06.256]                   signalCondition(cond)
[13:20:06.256]                 }
[13:20:06.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:06.256]                 "immediateCondition"))) {
[13:20:06.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:06.256]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:06.256]                   if (TRUE && !signal) {
[13:20:06.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.256]                     {
[13:20:06.256]                       inherits <- base::inherits
[13:20:06.256]                       invokeRestart <- base::invokeRestart
[13:20:06.256]                       is.null <- base::is.null
[13:20:06.256]                       muffled <- FALSE
[13:20:06.256]                       if (inherits(cond, "message")) {
[13:20:06.256]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.256]                         if (muffled) 
[13:20:06.256]                           invokeRestart("muffleMessage")
[13:20:06.256]                       }
[13:20:06.256]                       else if (inherits(cond, "warning")) {
[13:20:06.256]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.256]                         if (muffled) 
[13:20:06.256]                           invokeRestart("muffleWarning")
[13:20:06.256]                       }
[13:20:06.256]                       else if (inherits(cond, "condition")) {
[13:20:06.256]                         if (!is.null(pattern)) {
[13:20:06.256]                           computeRestarts <- base::computeRestarts
[13:20:06.256]                           grepl <- base::grepl
[13:20:06.256]                           restarts <- computeRestarts(cond)
[13:20:06.256]                           for (restart in restarts) {
[13:20:06.256]                             name <- restart$name
[13:20:06.256]                             if (is.null(name)) 
[13:20:06.256]                               next
[13:20:06.256]                             if (!grepl(pattern, name)) 
[13:20:06.256]                               next
[13:20:06.256]                             invokeRestart(restart)
[13:20:06.256]                             muffled <- TRUE
[13:20:06.256]                             break
[13:20:06.256]                           }
[13:20:06.256]                         }
[13:20:06.256]                       }
[13:20:06.256]                       invisible(muffled)
[13:20:06.256]                     }
[13:20:06.256]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.256]                   }
[13:20:06.256]                 }
[13:20:06.256]                 else {
[13:20:06.256]                   if (TRUE) {
[13:20:06.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.256]                     {
[13:20:06.256]                       inherits <- base::inherits
[13:20:06.256]                       invokeRestart <- base::invokeRestart
[13:20:06.256]                       is.null <- base::is.null
[13:20:06.256]                       muffled <- FALSE
[13:20:06.256]                       if (inherits(cond, "message")) {
[13:20:06.256]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.256]                         if (muffled) 
[13:20:06.256]                           invokeRestart("muffleMessage")
[13:20:06.256]                       }
[13:20:06.256]                       else if (inherits(cond, "warning")) {
[13:20:06.256]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.256]                         if (muffled) 
[13:20:06.256]                           invokeRestart("muffleWarning")
[13:20:06.256]                       }
[13:20:06.256]                       else if (inherits(cond, "condition")) {
[13:20:06.256]                         if (!is.null(pattern)) {
[13:20:06.256]                           computeRestarts <- base::computeRestarts
[13:20:06.256]                           grepl <- base::grepl
[13:20:06.256]                           restarts <- computeRestarts(cond)
[13:20:06.256]                           for (restart in restarts) {
[13:20:06.256]                             name <- restart$name
[13:20:06.256]                             if (is.null(name)) 
[13:20:06.256]                               next
[13:20:06.256]                             if (!grepl(pattern, name)) 
[13:20:06.256]                               next
[13:20:06.256]                             invokeRestart(restart)
[13:20:06.256]                             muffled <- TRUE
[13:20:06.256]                             break
[13:20:06.256]                           }
[13:20:06.256]                         }
[13:20:06.256]                       }
[13:20:06.256]                       invisible(muffled)
[13:20:06.256]                     }
[13:20:06.256]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.256]                   }
[13:20:06.256]                 }
[13:20:06.256]             }
[13:20:06.256]         }))
[13:20:06.256]     }, error = function(ex) {
[13:20:06.256]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:06.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.256]                 ...future.rng), started = ...future.startTime, 
[13:20:06.256]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:06.256]             version = "1.8"), class = "FutureResult")
[13:20:06.256]     }, finally = {
[13:20:06.256]         if (!identical(...future.workdir, getwd())) 
[13:20:06.256]             setwd(...future.workdir)
[13:20:06.256]         {
[13:20:06.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:06.256]                 ...future.oldOptions$nwarnings <- NULL
[13:20:06.256]             }
[13:20:06.256]             base::options(...future.oldOptions)
[13:20:06.256]             if (.Platform$OS.type == "windows") {
[13:20:06.256]                 old_names <- names(...future.oldEnvVars)
[13:20:06.256]                 envs <- base::Sys.getenv()
[13:20:06.256]                 names <- names(envs)
[13:20:06.256]                 common <- intersect(names, old_names)
[13:20:06.256]                 added <- setdiff(names, old_names)
[13:20:06.256]                 removed <- setdiff(old_names, names)
[13:20:06.256]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:06.256]                   envs[common]]
[13:20:06.256]                 NAMES <- toupper(changed)
[13:20:06.256]                 args <- list()
[13:20:06.256]                 for (kk in seq_along(NAMES)) {
[13:20:06.256]                   name <- changed[[kk]]
[13:20:06.256]                   NAME <- NAMES[[kk]]
[13:20:06.256]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.256]                     next
[13:20:06.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.256]                 }
[13:20:06.256]                 NAMES <- toupper(added)
[13:20:06.256]                 for (kk in seq_along(NAMES)) {
[13:20:06.256]                   name <- added[[kk]]
[13:20:06.256]                   NAME <- NAMES[[kk]]
[13:20:06.256]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.256]                     next
[13:20:06.256]                   args[[name]] <- ""
[13:20:06.256]                 }
[13:20:06.256]                 NAMES <- toupper(removed)
[13:20:06.256]                 for (kk in seq_along(NAMES)) {
[13:20:06.256]                   name <- removed[[kk]]
[13:20:06.256]                   NAME <- NAMES[[kk]]
[13:20:06.256]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.256]                     next
[13:20:06.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.256]                 }
[13:20:06.256]                 if (length(args) > 0) 
[13:20:06.256]                   base::do.call(base::Sys.setenv, args = args)
[13:20:06.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:06.256]             }
[13:20:06.256]             else {
[13:20:06.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:06.256]             }
[13:20:06.256]             {
[13:20:06.256]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:06.256]                   0L) {
[13:20:06.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:06.256]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:06.256]                   base::options(opts)
[13:20:06.256]                 }
[13:20:06.256]                 {
[13:20:06.256]                   {
[13:20:06.256]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:06.256]                     NULL
[13:20:06.256]                   }
[13:20:06.256]                   options(future.plan = NULL)
[13:20:06.256]                   if (is.na(NA_character_)) 
[13:20:06.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:06.256]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:06.256]                     envir = parent.frame()) 
[13:20:06.256]                   {
[13:20:06.256]                     default_workers <- missing(workers)
[13:20:06.256]                     if (is.function(workers)) 
[13:20:06.256]                       workers <- workers()
[13:20:06.256]                     workers <- structure(as.integer(workers), 
[13:20:06.256]                       class = class(workers))
[13:20:06.256]                     stop_if_not(is.finite(workers), workers >= 
[13:20:06.256]                       1L)
[13:20:06.256]                     if ((workers == 1L && !inherits(workers, 
[13:20:06.256]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:06.256]                       if (default_workers) 
[13:20:06.256]                         supportsMulticore(warn = TRUE)
[13:20:06.256]                       return(sequential(..., envir = envir))
[13:20:06.256]                     }
[13:20:06.256]                     oopts <- options(mc.cores = workers)
[13:20:06.256]                     on.exit(options(oopts))
[13:20:06.256]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:06.256]                       envir = envir)
[13:20:06.256]                     if (!future$lazy) 
[13:20:06.256]                       future <- run(future)
[13:20:06.256]                     invisible(future)
[13:20:06.256]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:06.256]                 }
[13:20:06.256]             }
[13:20:06.256]         }
[13:20:06.256]     })
[13:20:06.256]     if (TRUE) {
[13:20:06.256]         base::sink(type = "output", split = FALSE)
[13:20:06.256]         if (TRUE) {
[13:20:06.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:06.256]         }
[13:20:06.256]         else {
[13:20:06.256]             ...future.result["stdout"] <- base::list(NULL)
[13:20:06.256]         }
[13:20:06.256]         base::close(...future.stdout)
[13:20:06.256]         ...future.stdout <- NULL
[13:20:06.256]     }
[13:20:06.256]     ...future.result$conditions <- ...future.conditions
[13:20:06.256]     ...future.result$finished <- base::Sys.time()
[13:20:06.256]     ...future.result
[13:20:06.256] }
[13:20:06.259] assign_globals() ...
[13:20:06.259] List of 5
[13:20:06.259]  $ ...future.FUN            :function (x, ...)  
[13:20:06.259]  $ future.call.arguments    : list()
[13:20:06.259]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.259]  $ ...future.elements_ii    :List of 2
[13:20:06.259]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:20:06.259]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:20:06.259]  $ ...future.seeds_ii       : NULL
[13:20:06.259]  $ ...future.globals.maxSize: NULL
[13:20:06.259]  - attr(*, "where")=List of 5
[13:20:06.259]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:06.259]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:06.259]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:06.259]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:06.259]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:06.259]  - attr(*, "resolved")= logi FALSE
[13:20:06.259]  - attr(*, "total_size")= num 1248
[13:20:06.259]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.259]  - attr(*, "already-done")= logi TRUE
[13:20:06.267] - copied ‘...future.FUN’ to environment
[13:20:06.267] - copied ‘future.call.arguments’ to environment
[13:20:06.267] - copied ‘...future.elements_ii’ to environment
[13:20:06.267] - copied ‘...future.seeds_ii’ to environment
[13:20:06.267] - copied ‘...future.globals.maxSize’ to environment
[13:20:06.267] assign_globals() ... done
[13:20:06.268] requestCore(): workers = 2
[13:20:06.270] MulticoreFuture started
[13:20:06.270] - Launch lazy future ... done
[13:20:06.271] run() for ‘MulticoreFuture’ ... done
[13:20:06.271] Created future:
[13:20:06.272] plan(): Setting new future strategy stack:
[13:20:06.272] List of future strategies:
[13:20:06.272] 1. sequential:
[13:20:06.272]    - args: function (..., envir = parent.frame())
[13:20:06.272]    - tweaked: FALSE
[13:20:06.272]    - call: NULL
[13:20:06.273] plan(): nbrOfWorkers() = 1
[13:20:06.275] plan(): Setting new future strategy stack:
[13:20:06.275] List of future strategies:
[13:20:06.275] 1. multicore:
[13:20:06.275]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:06.275]    - tweaked: FALSE
[13:20:06.275]    - call: plan(strategy)
[13:20:06.281] plan(): nbrOfWorkers() = 2
[13:20:06.271] MulticoreFuture:
[13:20:06.271] Label: ‘future_eapply-2’
[13:20:06.271] Expression:
[13:20:06.271] {
[13:20:06.271]     do.call(function(...) {
[13:20:06.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.271]             on.exit(options(oopts), add = TRUE)
[13:20:06.271]         }
[13:20:06.271]         {
[13:20:06.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.271]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.271]             })
[13:20:06.271]         }
[13:20:06.271]     }, args = future.call.arguments)
[13:20:06.271] }
[13:20:06.271] Lazy evaluation: FALSE
[13:20:06.271] Asynchronous evaluation: TRUE
[13:20:06.271] Local evaluation: TRUE
[13:20:06.271] Environment: R_GlobalEnv
[13:20:06.271] Capture standard output: TRUE
[13:20:06.271] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:06.271] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:06.271] Packages: 1 packages (‘stats’)
[13:20:06.271] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:06.271] Resolved: TRUE
[13:20:06.271] Value: <not collected>
[13:20:06.271] Conditions captured: <none>
[13:20:06.271] Early signaling: FALSE
[13:20:06.271] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:06.271] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.282] Chunk #2 of 2 ... DONE
[13:20:06.283] Launching 2 futures (chunks) ... DONE
[13:20:06.283] Resolving 2 futures (chunks) ...
[13:20:06.283] resolve() on list ...
[13:20:06.283]  recursive: 0
[13:20:06.283]  length: 2
[13:20:06.283] 
[13:20:06.284] Future #1
[13:20:06.284] result() for MulticoreFuture ...
[13:20:06.285] result() for MulticoreFuture ...
[13:20:06.285] result() for MulticoreFuture ... done
[13:20:06.285] result() for MulticoreFuture ... done
[13:20:06.285] result() for MulticoreFuture ...
[13:20:06.285] result() for MulticoreFuture ... done
[13:20:06.286] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:20:06.286] - nx: 2
[13:20:06.286] - relay: TRUE
[13:20:06.286] - stdout: TRUE
[13:20:06.286] - signal: TRUE
[13:20:06.286] - resignal: FALSE
[13:20:06.286] - force: TRUE
[13:20:06.286] - relayed: [n=2] FALSE, FALSE
[13:20:06.287] - queued futures: [n=2] FALSE, FALSE
[13:20:06.287]  - until=1
[13:20:06.287]  - relaying element #1
[13:20:06.287] result() for MulticoreFuture ...
[13:20:06.287] result() for MulticoreFuture ... done
[13:20:06.287] result() for MulticoreFuture ...
[13:20:06.291] result() for MulticoreFuture ... done
[13:20:06.291] result() for MulticoreFuture ...
[13:20:06.291] result() for MulticoreFuture ... done
[13:20:06.292] result() for MulticoreFuture ...
[13:20:06.292] result() for MulticoreFuture ... done
[13:20:06.292] - relayed: [n=2] TRUE, FALSE
[13:20:06.292] - queued futures: [n=2] TRUE, FALSE
[13:20:06.292] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:20:06.292]  length: 1 (resolved future 1)
[13:20:06.293] Future #2
[13:20:06.293] result() for MulticoreFuture ...
[13:20:06.295] result() for MulticoreFuture ...
[13:20:06.295] result() for MulticoreFuture ... done
[13:20:06.295] result() for MulticoreFuture ... done
[13:20:06.295] result() for MulticoreFuture ...
[13:20:06.295] result() for MulticoreFuture ... done
[13:20:06.296] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:06.296] - nx: 2
[13:20:06.296] - relay: TRUE
[13:20:06.296] - stdout: TRUE
[13:20:06.296] - signal: TRUE
[13:20:06.296] - resignal: FALSE
[13:20:06.296] - force: TRUE
[13:20:06.297] - relayed: [n=2] TRUE, FALSE
[13:20:06.297] - queued futures: [n=2] TRUE, FALSE
[13:20:06.297]  - until=2
[13:20:06.297]  - relaying element #2
[13:20:06.297] result() for MulticoreFuture ...
[13:20:06.297] result() for MulticoreFuture ... done
[13:20:06.297] result() for MulticoreFuture ...
[13:20:06.298] result() for MulticoreFuture ... done
[13:20:06.298] result() for MulticoreFuture ...
[13:20:06.298] result() for MulticoreFuture ... done
[13:20:06.298] result() for MulticoreFuture ...
[13:20:06.298] result() for MulticoreFuture ... done
[13:20:06.298] - relayed: [n=2] TRUE, TRUE
[13:20:06.298] - queued futures: [n=2] TRUE, TRUE
[13:20:06.298] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:06.299]  length: 0 (resolved future 2)
[13:20:06.299] Relaying remaining futures
[13:20:06.299] signalConditionsASAP(NULL, pos=0) ...
[13:20:06.299] - nx: 2
[13:20:06.299] - relay: TRUE
[13:20:06.299] - stdout: TRUE
[13:20:06.299] - signal: TRUE
[13:20:06.299] - resignal: FALSE
[13:20:06.299] - force: TRUE
[13:20:06.300] - relayed: [n=2] TRUE, TRUE
[13:20:06.300] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:06.300] - relayed: [n=2] TRUE, TRUE
[13:20:06.300] - queued futures: [n=2] TRUE, TRUE
[13:20:06.300] signalConditionsASAP(NULL, pos=0) ... done
[13:20:06.300] resolve() on list ... DONE
[13:20:06.300] result() for MulticoreFuture ...
[13:20:06.301] result() for MulticoreFuture ... done
[13:20:06.301] result() for MulticoreFuture ...
[13:20:06.301] result() for MulticoreFuture ... done
[13:20:06.301] result() for MulticoreFuture ...
[13:20:06.301] result() for MulticoreFuture ... done
[13:20:06.301] result() for MulticoreFuture ...
[13:20:06.301] result() for MulticoreFuture ... done
[13:20:06.301]  - Number of value chunks collected: 2
[13:20:06.302] Resolving 2 futures (chunks) ... DONE
[13:20:06.302] Reducing values from 2 chunks ...
[13:20:06.302]  - Number of values collected after concatenation: 3
[13:20:06.302]  - Number of values expected: 3
[13:20:06.302] Reducing values from 2 chunks ... DONE
[13:20:06.302] future_lapply() ... DONE
[13:20:06.303] future_lapply() ...
[13:20:06.308] Number of chunks: 2
[13:20:06.308] getGlobalsAndPackagesXApply() ...
[13:20:06.308]  - future.globals: TRUE
[13:20:06.308] getGlobalsAndPackages() ...
[13:20:06.308] Searching for globals...
[13:20:06.310] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:06.310] Searching for globals ... DONE
[13:20:06.310] Resolving globals: FALSE
[13:20:06.311] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:20:06.311] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:20:06.311] - globals: [1] ‘FUN’
[13:20:06.312] - packages: [1] ‘stats’
[13:20:06.312] getGlobalsAndPackages() ... DONE
[13:20:06.312]  - globals found/used: [n=1] ‘FUN’
[13:20:06.312]  - needed namespaces: [n=1] ‘stats’
[13:20:06.312] Finding globals ... DONE
[13:20:06.312]  - use_args: TRUE
[13:20:06.312]  - Getting '...' globals ...
[13:20:06.313] resolve() on list ...
[13:20:06.313]  recursive: 0
[13:20:06.313]  length: 1
[13:20:06.313]  elements: ‘...’
[13:20:06.313]  length: 0 (resolved future 1)
[13:20:06.313] resolve() on list ... DONE
[13:20:06.313]    - '...' content: [n=0] 
[13:20:06.314] List of 1
[13:20:06.314]  $ ...: list()
[13:20:06.314]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.314]  - attr(*, "where")=List of 1
[13:20:06.314]   ..$ ...:<environment: 0x558fd7a6f170> 
[13:20:06.314]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.314]  - attr(*, "resolved")= logi TRUE
[13:20:06.314]  - attr(*, "total_size")= num NA
[13:20:06.317]  - Getting '...' globals ... DONE
[13:20:06.317] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:06.317] List of 2
[13:20:06.317]  $ ...future.FUN:function (x, ...)  
[13:20:06.317]  $ ...          : list()
[13:20:06.317]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.317]  - attr(*, "where")=List of 2
[13:20:06.317]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:06.317]   ..$ ...          :<environment: 0x558fd7a6f170> 
[13:20:06.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.317]  - attr(*, "resolved")= logi FALSE
[13:20:06.317]  - attr(*, "total_size")= num 1248
[13:20:06.320] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:06.320] getGlobalsAndPackagesXApply() ... DONE
[13:20:06.320] Number of futures (= number of chunks): 2
[13:20:06.320] Launching 2 futures (chunks) ...
[13:20:06.320] Chunk #1 of 2 ...
[13:20:06.320]  - Finding globals in 'X' for chunk #1 ...
[13:20:06.321] getGlobalsAndPackages() ...
[13:20:06.323] Searching for globals...
[13:20:06.323] 
[13:20:06.323] Searching for globals ... DONE
[13:20:06.323] - globals: [0] <none>
[13:20:06.323] getGlobalsAndPackages() ... DONE
[13:20:06.323]    + additional globals found: [n=0] 
[13:20:06.323]    + additional namespaces needed: [n=0] 
[13:20:06.323]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:06.323]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:06.324]  - seeds: <none>
[13:20:06.324]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.324] getGlobalsAndPackages() ...
[13:20:06.324] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.324] Resolving globals: FALSE
[13:20:06.324] Tweak future expression to call with '...' arguments ...
[13:20:06.324] {
[13:20:06.324]     do.call(function(...) {
[13:20:06.324]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.324]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.324]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.324]             on.exit(options(oopts), add = TRUE)
[13:20:06.324]         }
[13:20:06.324]         {
[13:20:06.324]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.324]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.324]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.324]             })
[13:20:06.324]         }
[13:20:06.324]     }, args = future.call.arguments)
[13:20:06.324] }
[13:20:06.325] Tweak future expression to call with '...' arguments ... DONE
[13:20:06.325] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.325] - packages: [1] ‘stats’
[13:20:06.325] getGlobalsAndPackages() ... DONE
[13:20:06.326] run() for ‘Future’ ...
[13:20:06.326] - state: ‘created’
[13:20:06.326] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:06.330] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:06.330]   - Field: ‘label’
[13:20:06.330]   - Field: ‘local’
[13:20:06.330]   - Field: ‘owner’
[13:20:06.330]   - Field: ‘envir’
[13:20:06.330]   - Field: ‘workers’
[13:20:06.331]   - Field: ‘packages’
[13:20:06.331]   - Field: ‘gc’
[13:20:06.331]   - Field: ‘job’
[13:20:06.331]   - Field: ‘conditions’
[13:20:06.331]   - Field: ‘expr’
[13:20:06.331]   - Field: ‘uuid’
[13:20:06.331]   - Field: ‘seed’
[13:20:06.331]   - Field: ‘version’
[13:20:06.331]   - Field: ‘result’
[13:20:06.331]   - Field: ‘asynchronous’
[13:20:06.332]   - Field: ‘calls’
[13:20:06.332]   - Field: ‘globals’
[13:20:06.332]   - Field: ‘stdout’
[13:20:06.332]   - Field: ‘earlySignal’
[13:20:06.332]   - Field: ‘lazy’
[13:20:06.332]   - Field: ‘state’
[13:20:06.332] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:06.332] - Launch lazy future ...
[13:20:06.333] Packages needed by the future expression (n = 1): ‘stats’
[13:20:06.333] Packages needed by future strategies (n = 0): <none>
[13:20:06.333] {
[13:20:06.333]     {
[13:20:06.333]         {
[13:20:06.333]             ...future.startTime <- base::Sys.time()
[13:20:06.333]             {
[13:20:06.333]                 {
[13:20:06.333]                   {
[13:20:06.333]                     {
[13:20:06.333]                       {
[13:20:06.333]                         base::local({
[13:20:06.333]                           has_future <- base::requireNamespace("future", 
[13:20:06.333]                             quietly = TRUE)
[13:20:06.333]                           if (has_future) {
[13:20:06.333]                             ns <- base::getNamespace("future")
[13:20:06.333]                             version <- ns[[".package"]][["version"]]
[13:20:06.333]                             if (is.null(version)) 
[13:20:06.333]                               version <- utils::packageVersion("future")
[13:20:06.333]                           }
[13:20:06.333]                           else {
[13:20:06.333]                             version <- NULL
[13:20:06.333]                           }
[13:20:06.333]                           if (!has_future || version < "1.8.0") {
[13:20:06.333]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:06.333]                               "", base::R.version$version.string), 
[13:20:06.333]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:06.333]                                 base::R.version$platform, 8 * 
[13:20:06.333]                                   base::.Machine$sizeof.pointer), 
[13:20:06.333]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:06.333]                                 "release", "version")], collapse = " "), 
[13:20:06.333]                               hostname = base::Sys.info()[["nodename"]])
[13:20:06.333]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:06.333]                               info)
[13:20:06.333]                             info <- base::paste(info, collapse = "; ")
[13:20:06.333]                             if (!has_future) {
[13:20:06.333]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:06.333]                                 info)
[13:20:06.333]                             }
[13:20:06.333]                             else {
[13:20:06.333]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:06.333]                                 info, version)
[13:20:06.333]                             }
[13:20:06.333]                             base::stop(msg)
[13:20:06.333]                           }
[13:20:06.333]                         })
[13:20:06.333]                       }
[13:20:06.333]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:06.333]                       base::options(mc.cores = 1L)
[13:20:06.333]                     }
[13:20:06.333]                     base::local({
[13:20:06.333]                       for (pkg in "stats") {
[13:20:06.333]                         base::loadNamespace(pkg)
[13:20:06.333]                         base::library(pkg, character.only = TRUE)
[13:20:06.333]                       }
[13:20:06.333]                     })
[13:20:06.333]                   }
[13:20:06.333]                   options(future.plan = NULL)
[13:20:06.333]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.333]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:06.333]                 }
[13:20:06.333]                 ...future.workdir <- getwd()
[13:20:06.333]             }
[13:20:06.333]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:06.333]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:06.333]         }
[13:20:06.333]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:06.333]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:06.333]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:06.333]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:06.333]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:06.333]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:06.333]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:06.333]             base::names(...future.oldOptions))
[13:20:06.333]     }
[13:20:06.333]     if (FALSE) {
[13:20:06.333]     }
[13:20:06.333]     else {
[13:20:06.333]         if (TRUE) {
[13:20:06.333]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:06.333]                 open = "w")
[13:20:06.333]         }
[13:20:06.333]         else {
[13:20:06.333]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:06.333]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:06.333]         }
[13:20:06.333]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:06.333]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:06.333]             base::sink(type = "output", split = FALSE)
[13:20:06.333]             base::close(...future.stdout)
[13:20:06.333]         }, add = TRUE)
[13:20:06.333]     }
[13:20:06.333]     ...future.frame <- base::sys.nframe()
[13:20:06.333]     ...future.conditions <- base::list()
[13:20:06.333]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:06.333]     if (FALSE) {
[13:20:06.333]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:06.333]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:06.333]     }
[13:20:06.333]     ...future.result <- base::tryCatch({
[13:20:06.333]         base::withCallingHandlers({
[13:20:06.333]             ...future.value <- base::withVisible(base::local({
[13:20:06.333]                 withCallingHandlers({
[13:20:06.333]                   {
[13:20:06.333]                     do.call(function(...) {
[13:20:06.333]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.333]                       if (!identical(...future.globals.maxSize.org, 
[13:20:06.333]                         ...future.globals.maxSize)) {
[13:20:06.333]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.333]                         on.exit(options(oopts), add = TRUE)
[13:20:06.333]                       }
[13:20:06.333]                       {
[13:20:06.333]                         lapply(seq_along(...future.elements_ii), 
[13:20:06.333]                           FUN = function(jj) {
[13:20:06.333]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.333]                             ...future.FUN(...future.X_jj, ...)
[13:20:06.333]                           })
[13:20:06.333]                       }
[13:20:06.333]                     }, args = future.call.arguments)
[13:20:06.333]                   }
[13:20:06.333]                 }, immediateCondition = function(cond) {
[13:20:06.333]                   save_rds <- function (object, pathname, ...) 
[13:20:06.333]                   {
[13:20:06.333]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:06.333]                     if (file_test("-f", pathname_tmp)) {
[13:20:06.333]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.333]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:06.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.333]                         fi_tmp[["mtime"]])
[13:20:06.333]                     }
[13:20:06.333]                     tryCatch({
[13:20:06.333]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:06.333]                     }, error = function(ex) {
[13:20:06.333]                       msg <- conditionMessage(ex)
[13:20:06.333]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.333]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:06.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.333]                         fi_tmp[["mtime"]], msg)
[13:20:06.333]                       ex$message <- msg
[13:20:06.333]                       stop(ex)
[13:20:06.333]                     })
[13:20:06.333]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:06.333]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:06.333]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:06.333]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.333]                       fi <- file.info(pathname)
[13:20:06.333]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:06.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.333]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:06.333]                         fi[["size"]], fi[["mtime"]])
[13:20:06.333]                       stop(msg)
[13:20:06.333]                     }
[13:20:06.333]                     invisible(pathname)
[13:20:06.333]                   }
[13:20:06.333]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:06.333]                     rootPath = tempdir()) 
[13:20:06.333]                   {
[13:20:06.333]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:06.333]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:06.333]                       tmpdir = path, fileext = ".rds")
[13:20:06.333]                     save_rds(obj, file)
[13:20:06.333]                   }
[13:20:06.333]                   saveImmediateCondition(cond, path = "/tmp/RtmpKCdc3U/.future/immediateConditions")
[13:20:06.333]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.333]                   {
[13:20:06.333]                     inherits <- base::inherits
[13:20:06.333]                     invokeRestart <- base::invokeRestart
[13:20:06.333]                     is.null <- base::is.null
[13:20:06.333]                     muffled <- FALSE
[13:20:06.333]                     if (inherits(cond, "message")) {
[13:20:06.333]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:06.333]                       if (muffled) 
[13:20:06.333]                         invokeRestart("muffleMessage")
[13:20:06.333]                     }
[13:20:06.333]                     else if (inherits(cond, "warning")) {
[13:20:06.333]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:06.333]                       if (muffled) 
[13:20:06.333]                         invokeRestart("muffleWarning")
[13:20:06.333]                     }
[13:20:06.333]                     else if (inherits(cond, "condition")) {
[13:20:06.333]                       if (!is.null(pattern)) {
[13:20:06.333]                         computeRestarts <- base::computeRestarts
[13:20:06.333]                         grepl <- base::grepl
[13:20:06.333]                         restarts <- computeRestarts(cond)
[13:20:06.333]                         for (restart in restarts) {
[13:20:06.333]                           name <- restart$name
[13:20:06.333]                           if (is.null(name)) 
[13:20:06.333]                             next
[13:20:06.333]                           if (!grepl(pattern, name)) 
[13:20:06.333]                             next
[13:20:06.333]                           invokeRestart(restart)
[13:20:06.333]                           muffled <- TRUE
[13:20:06.333]                           break
[13:20:06.333]                         }
[13:20:06.333]                       }
[13:20:06.333]                     }
[13:20:06.333]                     invisible(muffled)
[13:20:06.333]                   }
[13:20:06.333]                   muffleCondition(cond)
[13:20:06.333]                 })
[13:20:06.333]             }))
[13:20:06.333]             future::FutureResult(value = ...future.value$value, 
[13:20:06.333]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.333]                   ...future.rng), globalenv = if (FALSE) 
[13:20:06.333]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:06.333]                     ...future.globalenv.names))
[13:20:06.333]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:06.333]         }, condition = base::local({
[13:20:06.333]             c <- base::c
[13:20:06.333]             inherits <- base::inherits
[13:20:06.333]             invokeRestart <- base::invokeRestart
[13:20:06.333]             length <- base::length
[13:20:06.333]             list <- base::list
[13:20:06.333]             seq.int <- base::seq.int
[13:20:06.333]             signalCondition <- base::signalCondition
[13:20:06.333]             sys.calls <- base::sys.calls
[13:20:06.333]             `[[` <- base::`[[`
[13:20:06.333]             `+` <- base::`+`
[13:20:06.333]             `<<-` <- base::`<<-`
[13:20:06.333]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:06.333]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:06.333]                   3L)]
[13:20:06.333]             }
[13:20:06.333]             function(cond) {
[13:20:06.333]                 is_error <- inherits(cond, "error")
[13:20:06.333]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:06.333]                   NULL)
[13:20:06.333]                 if (is_error) {
[13:20:06.333]                   sessionInformation <- function() {
[13:20:06.333]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:06.333]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:06.333]                       search = base::search(), system = base::Sys.info())
[13:20:06.333]                   }
[13:20:06.333]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.333]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:06.333]                     cond$call), session = sessionInformation(), 
[13:20:06.333]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:06.333]                   signalCondition(cond)
[13:20:06.333]                 }
[13:20:06.333]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:06.333]                 "immediateCondition"))) {
[13:20:06.333]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:06.333]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.333]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:06.333]                   if (TRUE && !signal) {
[13:20:06.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.333]                     {
[13:20:06.333]                       inherits <- base::inherits
[13:20:06.333]                       invokeRestart <- base::invokeRestart
[13:20:06.333]                       is.null <- base::is.null
[13:20:06.333]                       muffled <- FALSE
[13:20:06.333]                       if (inherits(cond, "message")) {
[13:20:06.333]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.333]                         if (muffled) 
[13:20:06.333]                           invokeRestart("muffleMessage")
[13:20:06.333]                       }
[13:20:06.333]                       else if (inherits(cond, "warning")) {
[13:20:06.333]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.333]                         if (muffled) 
[13:20:06.333]                           invokeRestart("muffleWarning")
[13:20:06.333]                       }
[13:20:06.333]                       else if (inherits(cond, "condition")) {
[13:20:06.333]                         if (!is.null(pattern)) {
[13:20:06.333]                           computeRestarts <- base::computeRestarts
[13:20:06.333]                           grepl <- base::grepl
[13:20:06.333]                           restarts <- computeRestarts(cond)
[13:20:06.333]                           for (restart in restarts) {
[13:20:06.333]                             name <- restart$name
[13:20:06.333]                             if (is.null(name)) 
[13:20:06.333]                               next
[13:20:06.333]                             if (!grepl(pattern, name)) 
[13:20:06.333]                               next
[13:20:06.333]                             invokeRestart(restart)
[13:20:06.333]                             muffled <- TRUE
[13:20:06.333]                             break
[13:20:06.333]                           }
[13:20:06.333]                         }
[13:20:06.333]                       }
[13:20:06.333]                       invisible(muffled)
[13:20:06.333]                     }
[13:20:06.333]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.333]                   }
[13:20:06.333]                 }
[13:20:06.333]                 else {
[13:20:06.333]                   if (TRUE) {
[13:20:06.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.333]                     {
[13:20:06.333]                       inherits <- base::inherits
[13:20:06.333]                       invokeRestart <- base::invokeRestart
[13:20:06.333]                       is.null <- base::is.null
[13:20:06.333]                       muffled <- FALSE
[13:20:06.333]                       if (inherits(cond, "message")) {
[13:20:06.333]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.333]                         if (muffled) 
[13:20:06.333]                           invokeRestart("muffleMessage")
[13:20:06.333]                       }
[13:20:06.333]                       else if (inherits(cond, "warning")) {
[13:20:06.333]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.333]                         if (muffled) 
[13:20:06.333]                           invokeRestart("muffleWarning")
[13:20:06.333]                       }
[13:20:06.333]                       else if (inherits(cond, "condition")) {
[13:20:06.333]                         if (!is.null(pattern)) {
[13:20:06.333]                           computeRestarts <- base::computeRestarts
[13:20:06.333]                           grepl <- base::grepl
[13:20:06.333]                           restarts <- computeRestarts(cond)
[13:20:06.333]                           for (restart in restarts) {
[13:20:06.333]                             name <- restart$name
[13:20:06.333]                             if (is.null(name)) 
[13:20:06.333]                               next
[13:20:06.333]                             if (!grepl(pattern, name)) 
[13:20:06.333]                               next
[13:20:06.333]                             invokeRestart(restart)
[13:20:06.333]                             muffled <- TRUE
[13:20:06.333]                             break
[13:20:06.333]                           }
[13:20:06.333]                         }
[13:20:06.333]                       }
[13:20:06.333]                       invisible(muffled)
[13:20:06.333]                     }
[13:20:06.333]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.333]                   }
[13:20:06.333]                 }
[13:20:06.333]             }
[13:20:06.333]         }))
[13:20:06.333]     }, error = function(ex) {
[13:20:06.333]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:06.333]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.333]                 ...future.rng), started = ...future.startTime, 
[13:20:06.333]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:06.333]             version = "1.8"), class = "FutureResult")
[13:20:06.333]     }, finally = {
[13:20:06.333]         if (!identical(...future.workdir, getwd())) 
[13:20:06.333]             setwd(...future.workdir)
[13:20:06.333]         {
[13:20:06.333]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:06.333]                 ...future.oldOptions$nwarnings <- NULL
[13:20:06.333]             }
[13:20:06.333]             base::options(...future.oldOptions)
[13:20:06.333]             if (.Platform$OS.type == "windows") {
[13:20:06.333]                 old_names <- names(...future.oldEnvVars)
[13:20:06.333]                 envs <- base::Sys.getenv()
[13:20:06.333]                 names <- names(envs)
[13:20:06.333]                 common <- intersect(names, old_names)
[13:20:06.333]                 added <- setdiff(names, old_names)
[13:20:06.333]                 removed <- setdiff(old_names, names)
[13:20:06.333]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:06.333]                   envs[common]]
[13:20:06.333]                 NAMES <- toupper(changed)
[13:20:06.333]                 args <- list()
[13:20:06.333]                 for (kk in seq_along(NAMES)) {
[13:20:06.333]                   name <- changed[[kk]]
[13:20:06.333]                   NAME <- NAMES[[kk]]
[13:20:06.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.333]                     next
[13:20:06.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.333]                 }
[13:20:06.333]                 NAMES <- toupper(added)
[13:20:06.333]                 for (kk in seq_along(NAMES)) {
[13:20:06.333]                   name <- added[[kk]]
[13:20:06.333]                   NAME <- NAMES[[kk]]
[13:20:06.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.333]                     next
[13:20:06.333]                   args[[name]] <- ""
[13:20:06.333]                 }
[13:20:06.333]                 NAMES <- toupper(removed)
[13:20:06.333]                 for (kk in seq_along(NAMES)) {
[13:20:06.333]                   name <- removed[[kk]]
[13:20:06.333]                   NAME <- NAMES[[kk]]
[13:20:06.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.333]                     next
[13:20:06.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.333]                 }
[13:20:06.333]                 if (length(args) > 0) 
[13:20:06.333]                   base::do.call(base::Sys.setenv, args = args)
[13:20:06.333]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:06.333]             }
[13:20:06.333]             else {
[13:20:06.333]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:06.333]             }
[13:20:06.333]             {
[13:20:06.333]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:06.333]                   0L) {
[13:20:06.333]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:06.333]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:06.333]                   base::options(opts)
[13:20:06.333]                 }
[13:20:06.333]                 {
[13:20:06.333]                   {
[13:20:06.333]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:06.333]                     NULL
[13:20:06.333]                   }
[13:20:06.333]                   options(future.plan = NULL)
[13:20:06.333]                   if (is.na(NA_character_)) 
[13:20:06.333]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.333]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:06.333]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:06.333]                     envir = parent.frame()) 
[13:20:06.333]                   {
[13:20:06.333]                     default_workers <- missing(workers)
[13:20:06.333]                     if (is.function(workers)) 
[13:20:06.333]                       workers <- workers()
[13:20:06.333]                     workers <- structure(as.integer(workers), 
[13:20:06.333]                       class = class(workers))
[13:20:06.333]                     stop_if_not(is.finite(workers), workers >= 
[13:20:06.333]                       1L)
[13:20:06.333]                     if ((workers == 1L && !inherits(workers, 
[13:20:06.333]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:06.333]                       if (default_workers) 
[13:20:06.333]                         supportsMulticore(warn = TRUE)
[13:20:06.333]                       return(sequential(..., envir = envir))
[13:20:06.333]                     }
[13:20:06.333]                     oopts <- options(mc.cores = workers)
[13:20:06.333]                     on.exit(options(oopts))
[13:20:06.333]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:06.333]                       envir = envir)
[13:20:06.333]                     if (!future$lazy) 
[13:20:06.333]                       future <- run(future)
[13:20:06.333]                     invisible(future)
[13:20:06.333]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:06.333]                 }
[13:20:06.333]             }
[13:20:06.333]         }
[13:20:06.333]     })
[13:20:06.333]     if (TRUE) {
[13:20:06.333]         base::sink(type = "output", split = FALSE)
[13:20:06.333]         if (TRUE) {
[13:20:06.333]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:06.333]         }
[13:20:06.333]         else {
[13:20:06.333]             ...future.result["stdout"] <- base::list(NULL)
[13:20:06.333]         }
[13:20:06.333]         base::close(...future.stdout)
[13:20:06.333]         ...future.stdout <- NULL
[13:20:06.333]     }
[13:20:06.333]     ...future.result$conditions <- ...future.conditions
[13:20:06.333]     ...future.result$finished <- base::Sys.time()
[13:20:06.333]     ...future.result
[13:20:06.333] }
[13:20:06.336] assign_globals() ...
[13:20:06.336] List of 5
[13:20:06.336]  $ ...future.FUN            :function (x, ...)  
[13:20:06.336]  $ future.call.arguments    : list()
[13:20:06.336]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.336]  $ ...future.elements_ii    :List of 1
[13:20:06.336]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:20:06.336]  $ ...future.seeds_ii       : NULL
[13:20:06.336]  $ ...future.globals.maxSize: NULL
[13:20:06.336]  - attr(*, "where")=List of 5
[13:20:06.336]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:06.336]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:06.336]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:06.336]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:06.336]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:06.336]  - attr(*, "resolved")= logi FALSE
[13:20:06.336]  - attr(*, "total_size")= num 1248
[13:20:06.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.336]  - attr(*, "already-done")= logi TRUE
[13:20:06.341] - copied ‘...future.FUN’ to environment
[13:20:06.341] - copied ‘future.call.arguments’ to environment
[13:20:06.341] - copied ‘...future.elements_ii’ to environment
[13:20:06.341] - copied ‘...future.seeds_ii’ to environment
[13:20:06.341] - copied ‘...future.globals.maxSize’ to environment
[13:20:06.341] assign_globals() ... done
[13:20:06.341] requestCore(): workers = 2
[13:20:06.344] MulticoreFuture started
[13:20:06.344] - Launch lazy future ... done
[13:20:06.344] run() for ‘MulticoreFuture’ ... done
[13:20:06.345] Created future:
[13:20:06.345] plan(): Setting new future strategy stack:
[13:20:06.345] List of future strategies:
[13:20:06.345] 1. sequential:
[13:20:06.345]    - args: function (..., envir = parent.frame())
[13:20:06.345]    - tweaked: FALSE
[13:20:06.345]    - call: NULL
[13:20:06.346] plan(): nbrOfWorkers() = 1
[13:20:06.349] plan(): Setting new future strategy stack:
[13:20:06.349] List of future strategies:
[13:20:06.349] 1. multicore:
[13:20:06.349]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:06.349]    - tweaked: FALSE
[13:20:06.349]    - call: plan(strategy)
[13:20:06.354] plan(): nbrOfWorkers() = 2
[13:20:06.345] MulticoreFuture:
[13:20:06.345] Label: ‘future_eapply-1’
[13:20:06.345] Expression:
[13:20:06.345] {
[13:20:06.345]     do.call(function(...) {
[13:20:06.345]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.345]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.345]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.345]             on.exit(options(oopts), add = TRUE)
[13:20:06.345]         }
[13:20:06.345]         {
[13:20:06.345]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.345]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.345]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.345]             })
[13:20:06.345]         }
[13:20:06.345]     }, args = future.call.arguments)
[13:20:06.345] }
[13:20:06.345] Lazy evaluation: FALSE
[13:20:06.345] Asynchronous evaluation: TRUE
[13:20:06.345] Local evaluation: TRUE
[13:20:06.345] Environment: R_GlobalEnv
[13:20:06.345] Capture standard output: TRUE
[13:20:06.345] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:06.345] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:06.345] Packages: 1 packages (‘stats’)
[13:20:06.345] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:06.345] Resolved: TRUE
[13:20:06.345] Value: <not collected>
[13:20:06.345] Conditions captured: <none>
[13:20:06.345] Early signaling: FALSE
[13:20:06.345] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:06.345] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.355] Chunk #1 of 2 ... DONE
[13:20:06.356] Chunk #2 of 2 ...
[13:20:06.356]  - Finding globals in 'X' for chunk #2 ...
[13:20:06.356] getGlobalsAndPackages() ...
[13:20:06.356] Searching for globals...
[13:20:06.357] 
[13:20:06.357] Searching for globals ... DONE
[13:20:06.357] - globals: [0] <none>
[13:20:06.357] getGlobalsAndPackages() ... DONE
[13:20:06.357]    + additional globals found: [n=0] 
[13:20:06.357]    + additional namespaces needed: [n=0] 
[13:20:06.357]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:06.357]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:06.358]  - seeds: <none>
[13:20:06.358]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.358] getGlobalsAndPackages() ...
[13:20:06.358] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.358] Resolving globals: FALSE
[13:20:06.358] Tweak future expression to call with '...' arguments ...
[13:20:06.359] {
[13:20:06.359]     do.call(function(...) {
[13:20:06.359]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.359]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.359]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.359]             on.exit(options(oopts), add = TRUE)
[13:20:06.359]         }
[13:20:06.359]         {
[13:20:06.359]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.359]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.359]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.359]             })
[13:20:06.359]         }
[13:20:06.359]     }, args = future.call.arguments)
[13:20:06.359] }
[13:20:06.359] Tweak future expression to call with '...' arguments ... DONE
[13:20:06.360] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:06.360] - packages: [1] ‘stats’
[13:20:06.360] getGlobalsAndPackages() ... DONE
[13:20:06.361] run() for ‘Future’ ...
[13:20:06.361] - state: ‘created’
[13:20:06.361] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:06.369] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:06.369]   - Field: ‘label’
[13:20:06.369]   - Field: ‘local’
[13:20:06.369]   - Field: ‘owner’
[13:20:06.370]   - Field: ‘envir’
[13:20:06.370]   - Field: ‘workers’
[13:20:06.370]   - Field: ‘packages’
[13:20:06.370]   - Field: ‘gc’
[13:20:06.370]   - Field: ‘job’
[13:20:06.371]   - Field: ‘conditions’
[13:20:06.371]   - Field: ‘expr’
[13:20:06.371]   - Field: ‘uuid’
[13:20:06.372]   - Field: ‘seed’
[13:20:06.372]   - Field: ‘version’
[13:20:06.372]   - Field: ‘result’
[13:20:06.372]   - Field: ‘asynchronous’
[13:20:06.372]   - Field: ‘calls’
[13:20:06.373]   - Field: ‘globals’
[13:20:06.373]   - Field: ‘stdout’
[13:20:06.373]   - Field: ‘earlySignal’
[13:20:06.373]   - Field: ‘lazy’
[13:20:06.373]   - Field: ‘state’
[13:20:06.373] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:06.374] - Launch lazy future ...
[13:20:06.374] Packages needed by the future expression (n = 1): ‘stats’
[13:20:06.374] Packages needed by future strategies (n = 0): <none>
[13:20:06.375] {
[13:20:06.375]     {
[13:20:06.375]         {
[13:20:06.375]             ...future.startTime <- base::Sys.time()
[13:20:06.375]             {
[13:20:06.375]                 {
[13:20:06.375]                   {
[13:20:06.375]                     {
[13:20:06.375]                       {
[13:20:06.375]                         base::local({
[13:20:06.375]                           has_future <- base::requireNamespace("future", 
[13:20:06.375]                             quietly = TRUE)
[13:20:06.375]                           if (has_future) {
[13:20:06.375]                             ns <- base::getNamespace("future")
[13:20:06.375]                             version <- ns[[".package"]][["version"]]
[13:20:06.375]                             if (is.null(version)) 
[13:20:06.375]                               version <- utils::packageVersion("future")
[13:20:06.375]                           }
[13:20:06.375]                           else {
[13:20:06.375]                             version <- NULL
[13:20:06.375]                           }
[13:20:06.375]                           if (!has_future || version < "1.8.0") {
[13:20:06.375]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:06.375]                               "", base::R.version$version.string), 
[13:20:06.375]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:06.375]                                 base::R.version$platform, 8 * 
[13:20:06.375]                                   base::.Machine$sizeof.pointer), 
[13:20:06.375]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:06.375]                                 "release", "version")], collapse = " "), 
[13:20:06.375]                               hostname = base::Sys.info()[["nodename"]])
[13:20:06.375]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:06.375]                               info)
[13:20:06.375]                             info <- base::paste(info, collapse = "; ")
[13:20:06.375]                             if (!has_future) {
[13:20:06.375]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:06.375]                                 info)
[13:20:06.375]                             }
[13:20:06.375]                             else {
[13:20:06.375]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:06.375]                                 info, version)
[13:20:06.375]                             }
[13:20:06.375]                             base::stop(msg)
[13:20:06.375]                           }
[13:20:06.375]                         })
[13:20:06.375]                       }
[13:20:06.375]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:06.375]                       base::options(mc.cores = 1L)
[13:20:06.375]                     }
[13:20:06.375]                     base::local({
[13:20:06.375]                       for (pkg in "stats") {
[13:20:06.375]                         base::loadNamespace(pkg)
[13:20:06.375]                         base::library(pkg, character.only = TRUE)
[13:20:06.375]                       }
[13:20:06.375]                     })
[13:20:06.375]                   }
[13:20:06.375]                   options(future.plan = NULL)
[13:20:06.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:06.375]                 }
[13:20:06.375]                 ...future.workdir <- getwd()
[13:20:06.375]             }
[13:20:06.375]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:06.375]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:06.375]         }
[13:20:06.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:06.375]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:06.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:06.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:06.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:06.375]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:06.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:06.375]             base::names(...future.oldOptions))
[13:20:06.375]     }
[13:20:06.375]     if (FALSE) {
[13:20:06.375]     }
[13:20:06.375]     else {
[13:20:06.375]         if (TRUE) {
[13:20:06.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:06.375]                 open = "w")
[13:20:06.375]         }
[13:20:06.375]         else {
[13:20:06.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:06.375]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:06.375]         }
[13:20:06.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:06.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:06.375]             base::sink(type = "output", split = FALSE)
[13:20:06.375]             base::close(...future.stdout)
[13:20:06.375]         }, add = TRUE)
[13:20:06.375]     }
[13:20:06.375]     ...future.frame <- base::sys.nframe()
[13:20:06.375]     ...future.conditions <- base::list()
[13:20:06.375]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:06.375]     if (FALSE) {
[13:20:06.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:06.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:06.375]     }
[13:20:06.375]     ...future.result <- base::tryCatch({
[13:20:06.375]         base::withCallingHandlers({
[13:20:06.375]             ...future.value <- base::withVisible(base::local({
[13:20:06.375]                 withCallingHandlers({
[13:20:06.375]                   {
[13:20:06.375]                     do.call(function(...) {
[13:20:06.375]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.375]                       if (!identical(...future.globals.maxSize.org, 
[13:20:06.375]                         ...future.globals.maxSize)) {
[13:20:06.375]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.375]                         on.exit(options(oopts), add = TRUE)
[13:20:06.375]                       }
[13:20:06.375]                       {
[13:20:06.375]                         lapply(seq_along(...future.elements_ii), 
[13:20:06.375]                           FUN = function(jj) {
[13:20:06.375]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.375]                             ...future.FUN(...future.X_jj, ...)
[13:20:06.375]                           })
[13:20:06.375]                       }
[13:20:06.375]                     }, args = future.call.arguments)
[13:20:06.375]                   }
[13:20:06.375]                 }, immediateCondition = function(cond) {
[13:20:06.375]                   save_rds <- function (object, pathname, ...) 
[13:20:06.375]                   {
[13:20:06.375]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:06.375]                     if (file_test("-f", pathname_tmp)) {
[13:20:06.375]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.375]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:06.375]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.375]                         fi_tmp[["mtime"]])
[13:20:06.375]                     }
[13:20:06.375]                     tryCatch({
[13:20:06.375]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:06.375]                     }, error = function(ex) {
[13:20:06.375]                       msg <- conditionMessage(ex)
[13:20:06.375]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.375]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:06.375]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.375]                         fi_tmp[["mtime"]], msg)
[13:20:06.375]                       ex$message <- msg
[13:20:06.375]                       stop(ex)
[13:20:06.375]                     })
[13:20:06.375]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:06.375]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:06.375]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:06.375]                       fi_tmp <- file.info(pathname_tmp)
[13:20:06.375]                       fi <- file.info(pathname)
[13:20:06.375]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:06.375]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:06.375]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:06.375]                         fi[["size"]], fi[["mtime"]])
[13:20:06.375]                       stop(msg)
[13:20:06.375]                     }
[13:20:06.375]                     invisible(pathname)
[13:20:06.375]                   }
[13:20:06.375]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:06.375]                     rootPath = tempdir()) 
[13:20:06.375]                   {
[13:20:06.375]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:06.375]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:06.375]                       tmpdir = path, fileext = ".rds")
[13:20:06.375]                     save_rds(obj, file)
[13:20:06.375]                   }
[13:20:06.375]                   saveImmediateCondition(cond, path = "/tmp/RtmpKCdc3U/.future/immediateConditions")
[13:20:06.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.375]                   {
[13:20:06.375]                     inherits <- base::inherits
[13:20:06.375]                     invokeRestart <- base::invokeRestart
[13:20:06.375]                     is.null <- base::is.null
[13:20:06.375]                     muffled <- FALSE
[13:20:06.375]                     if (inherits(cond, "message")) {
[13:20:06.375]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:06.375]                       if (muffled) 
[13:20:06.375]                         invokeRestart("muffleMessage")
[13:20:06.375]                     }
[13:20:06.375]                     else if (inherits(cond, "warning")) {
[13:20:06.375]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:06.375]                       if (muffled) 
[13:20:06.375]                         invokeRestart("muffleWarning")
[13:20:06.375]                     }
[13:20:06.375]                     else if (inherits(cond, "condition")) {
[13:20:06.375]                       if (!is.null(pattern)) {
[13:20:06.375]                         computeRestarts <- base::computeRestarts
[13:20:06.375]                         grepl <- base::grepl
[13:20:06.375]                         restarts <- computeRestarts(cond)
[13:20:06.375]                         for (restart in restarts) {
[13:20:06.375]                           name <- restart$name
[13:20:06.375]                           if (is.null(name)) 
[13:20:06.375]                             next
[13:20:06.375]                           if (!grepl(pattern, name)) 
[13:20:06.375]                             next
[13:20:06.375]                           invokeRestart(restart)
[13:20:06.375]                           muffled <- TRUE
[13:20:06.375]                           break
[13:20:06.375]                         }
[13:20:06.375]                       }
[13:20:06.375]                     }
[13:20:06.375]                     invisible(muffled)
[13:20:06.375]                   }
[13:20:06.375]                   muffleCondition(cond)
[13:20:06.375]                 })
[13:20:06.375]             }))
[13:20:06.375]             future::FutureResult(value = ...future.value$value, 
[13:20:06.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.375]                   ...future.rng), globalenv = if (FALSE) 
[13:20:06.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:06.375]                     ...future.globalenv.names))
[13:20:06.375]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:06.375]         }, condition = base::local({
[13:20:06.375]             c <- base::c
[13:20:06.375]             inherits <- base::inherits
[13:20:06.375]             invokeRestart <- base::invokeRestart
[13:20:06.375]             length <- base::length
[13:20:06.375]             list <- base::list
[13:20:06.375]             seq.int <- base::seq.int
[13:20:06.375]             signalCondition <- base::signalCondition
[13:20:06.375]             sys.calls <- base::sys.calls
[13:20:06.375]             `[[` <- base::`[[`
[13:20:06.375]             `+` <- base::`+`
[13:20:06.375]             `<<-` <- base::`<<-`
[13:20:06.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:06.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:06.375]                   3L)]
[13:20:06.375]             }
[13:20:06.375]             function(cond) {
[13:20:06.375]                 is_error <- inherits(cond, "error")
[13:20:06.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:06.375]                   NULL)
[13:20:06.375]                 if (is_error) {
[13:20:06.375]                   sessionInformation <- function() {
[13:20:06.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:06.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:06.375]                       search = base::search(), system = base::Sys.info())
[13:20:06.375]                   }
[13:20:06.375]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:06.375]                     cond$call), session = sessionInformation(), 
[13:20:06.375]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:06.375]                   signalCondition(cond)
[13:20:06.375]                 }
[13:20:06.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:06.375]                 "immediateCondition"))) {
[13:20:06.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:06.375]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:06.375]                   if (TRUE && !signal) {
[13:20:06.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.375]                     {
[13:20:06.375]                       inherits <- base::inherits
[13:20:06.375]                       invokeRestart <- base::invokeRestart
[13:20:06.375]                       is.null <- base::is.null
[13:20:06.375]                       muffled <- FALSE
[13:20:06.375]                       if (inherits(cond, "message")) {
[13:20:06.375]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.375]                         if (muffled) 
[13:20:06.375]                           invokeRestart("muffleMessage")
[13:20:06.375]                       }
[13:20:06.375]                       else if (inherits(cond, "warning")) {
[13:20:06.375]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.375]                         if (muffled) 
[13:20:06.375]                           invokeRestart("muffleWarning")
[13:20:06.375]                       }
[13:20:06.375]                       else if (inherits(cond, "condition")) {
[13:20:06.375]                         if (!is.null(pattern)) {
[13:20:06.375]                           computeRestarts <- base::computeRestarts
[13:20:06.375]                           grepl <- base::grepl
[13:20:06.375]                           restarts <- computeRestarts(cond)
[13:20:06.375]                           for (restart in restarts) {
[13:20:06.375]                             name <- restart$name
[13:20:06.375]                             if (is.null(name)) 
[13:20:06.375]                               next
[13:20:06.375]                             if (!grepl(pattern, name)) 
[13:20:06.375]                               next
[13:20:06.375]                             invokeRestart(restart)
[13:20:06.375]                             muffled <- TRUE
[13:20:06.375]                             break
[13:20:06.375]                           }
[13:20:06.375]                         }
[13:20:06.375]                       }
[13:20:06.375]                       invisible(muffled)
[13:20:06.375]                     }
[13:20:06.375]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.375]                   }
[13:20:06.375]                 }
[13:20:06.375]                 else {
[13:20:06.375]                   if (TRUE) {
[13:20:06.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.375]                     {
[13:20:06.375]                       inherits <- base::inherits
[13:20:06.375]                       invokeRestart <- base::invokeRestart
[13:20:06.375]                       is.null <- base::is.null
[13:20:06.375]                       muffled <- FALSE
[13:20:06.375]                       if (inherits(cond, "message")) {
[13:20:06.375]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.375]                         if (muffled) 
[13:20:06.375]                           invokeRestart("muffleMessage")
[13:20:06.375]                       }
[13:20:06.375]                       else if (inherits(cond, "warning")) {
[13:20:06.375]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.375]                         if (muffled) 
[13:20:06.375]                           invokeRestart("muffleWarning")
[13:20:06.375]                       }
[13:20:06.375]                       else if (inherits(cond, "condition")) {
[13:20:06.375]                         if (!is.null(pattern)) {
[13:20:06.375]                           computeRestarts <- base::computeRestarts
[13:20:06.375]                           grepl <- base::grepl
[13:20:06.375]                           restarts <- computeRestarts(cond)
[13:20:06.375]                           for (restart in restarts) {
[13:20:06.375]                             name <- restart$name
[13:20:06.375]                             if (is.null(name)) 
[13:20:06.375]                               next
[13:20:06.375]                             if (!grepl(pattern, name)) 
[13:20:06.375]                               next
[13:20:06.375]                             invokeRestart(restart)
[13:20:06.375]                             muffled <- TRUE
[13:20:06.375]                             break
[13:20:06.375]                           }
[13:20:06.375]                         }
[13:20:06.375]                       }
[13:20:06.375]                       invisible(muffled)
[13:20:06.375]                     }
[13:20:06.375]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.375]                   }
[13:20:06.375]                 }
[13:20:06.375]             }
[13:20:06.375]         }))
[13:20:06.375]     }, error = function(ex) {
[13:20:06.375]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:06.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.375]                 ...future.rng), started = ...future.startTime, 
[13:20:06.375]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:06.375]             version = "1.8"), class = "FutureResult")
[13:20:06.375]     }, finally = {
[13:20:06.375]         if (!identical(...future.workdir, getwd())) 
[13:20:06.375]             setwd(...future.workdir)
[13:20:06.375]         {
[13:20:06.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:06.375]                 ...future.oldOptions$nwarnings <- NULL
[13:20:06.375]             }
[13:20:06.375]             base::options(...future.oldOptions)
[13:20:06.375]             if (.Platform$OS.type == "windows") {
[13:20:06.375]                 old_names <- names(...future.oldEnvVars)
[13:20:06.375]                 envs <- base::Sys.getenv()
[13:20:06.375]                 names <- names(envs)
[13:20:06.375]                 common <- intersect(names, old_names)
[13:20:06.375]                 added <- setdiff(names, old_names)
[13:20:06.375]                 removed <- setdiff(old_names, names)
[13:20:06.375]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:06.375]                   envs[common]]
[13:20:06.375]                 NAMES <- toupper(changed)
[13:20:06.375]                 args <- list()
[13:20:06.375]                 for (kk in seq_along(NAMES)) {
[13:20:06.375]                   name <- changed[[kk]]
[13:20:06.375]                   NAME <- NAMES[[kk]]
[13:20:06.375]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.375]                     next
[13:20:06.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.375]                 }
[13:20:06.375]                 NAMES <- toupper(added)
[13:20:06.375]                 for (kk in seq_along(NAMES)) {
[13:20:06.375]                   name <- added[[kk]]
[13:20:06.375]                   NAME <- NAMES[[kk]]
[13:20:06.375]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.375]                     next
[13:20:06.375]                   args[[name]] <- ""
[13:20:06.375]                 }
[13:20:06.375]                 NAMES <- toupper(removed)
[13:20:06.375]                 for (kk in seq_along(NAMES)) {
[13:20:06.375]                   name <- removed[[kk]]
[13:20:06.375]                   NAME <- NAMES[[kk]]
[13:20:06.375]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.375]                     next
[13:20:06.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.375]                 }
[13:20:06.375]                 if (length(args) > 0) 
[13:20:06.375]                   base::do.call(base::Sys.setenv, args = args)
[13:20:06.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:06.375]             }
[13:20:06.375]             else {
[13:20:06.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:06.375]             }
[13:20:06.375]             {
[13:20:06.375]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:06.375]                   0L) {
[13:20:06.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:06.375]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:06.375]                   base::options(opts)
[13:20:06.375]                 }
[13:20:06.375]                 {
[13:20:06.375]                   {
[13:20:06.375]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:06.375]                     NULL
[13:20:06.375]                   }
[13:20:06.375]                   options(future.plan = NULL)
[13:20:06.375]                   if (is.na(NA_character_)) 
[13:20:06.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:06.375]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:06.375]                     envir = parent.frame()) 
[13:20:06.375]                   {
[13:20:06.375]                     default_workers <- missing(workers)
[13:20:06.375]                     if (is.function(workers)) 
[13:20:06.375]                       workers <- workers()
[13:20:06.375]                     workers <- structure(as.integer(workers), 
[13:20:06.375]                       class = class(workers))
[13:20:06.375]                     stop_if_not(is.finite(workers), workers >= 
[13:20:06.375]                       1L)
[13:20:06.375]                     if ((workers == 1L && !inherits(workers, 
[13:20:06.375]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:06.375]                       if (default_workers) 
[13:20:06.375]                         supportsMulticore(warn = TRUE)
[13:20:06.375]                       return(sequential(..., envir = envir))
[13:20:06.375]                     }
[13:20:06.375]                     oopts <- options(mc.cores = workers)
[13:20:06.375]                     on.exit(options(oopts))
[13:20:06.375]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:06.375]                       envir = envir)
[13:20:06.375]                     if (!future$lazy) 
[13:20:06.375]                       future <- run(future)
[13:20:06.375]                     invisible(future)
[13:20:06.375]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:06.375]                 }
[13:20:06.375]             }
[13:20:06.375]         }
[13:20:06.375]     })
[13:20:06.375]     if (TRUE) {
[13:20:06.375]         base::sink(type = "output", split = FALSE)
[13:20:06.375]         if (TRUE) {
[13:20:06.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:06.375]         }
[13:20:06.375]         else {
[13:20:06.375]             ...future.result["stdout"] <- base::list(NULL)
[13:20:06.375]         }
[13:20:06.375]         base::close(...future.stdout)
[13:20:06.375]         ...future.stdout <- NULL
[13:20:06.375]     }
[13:20:06.375]     ...future.result$conditions <- ...future.conditions
[13:20:06.375]     ...future.result$finished <- base::Sys.time()
[13:20:06.375]     ...future.result
[13:20:06.375] }
[13:20:06.378] assign_globals() ...
[13:20:06.379] List of 5
[13:20:06.379]  $ ...future.FUN            :function (x, ...)  
[13:20:06.379]  $ future.call.arguments    : list()
[13:20:06.379]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:06.379]  $ ...future.elements_ii    :List of 2
[13:20:06.379]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:20:06.379]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:20:06.379]  $ ...future.seeds_ii       : NULL
[13:20:06.379]  $ ...future.globals.maxSize: NULL
[13:20:06.379]  - attr(*, "where")=List of 5
[13:20:06.379]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:06.379]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:06.379]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:06.379]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:06.379]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:06.379]  - attr(*, "resolved")= logi FALSE
[13:20:06.379]  - attr(*, "total_size")= num 1248
[13:20:06.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:06.379]  - attr(*, "already-done")= logi TRUE
[13:20:06.387] - copied ‘...future.FUN’ to environment
[13:20:06.387] - copied ‘future.call.arguments’ to environment
[13:20:06.387] - copied ‘...future.elements_ii’ to environment
[13:20:06.387] - copied ‘...future.seeds_ii’ to environment
[13:20:06.387] - copied ‘...future.globals.maxSize’ to environment
[13:20:06.387] assign_globals() ... done
[13:20:06.388] requestCore(): workers = 2
[13:20:06.390] MulticoreFuture started
[13:20:06.390] - Launch lazy future ... done
[13:20:06.390] run() for ‘MulticoreFuture’ ... done
[13:20:06.391] Created future:
[13:20:06.392] plan(): Setting new future strategy stack:
[13:20:06.392] List of future strategies:
[13:20:06.392] 1. sequential:
[13:20:06.392]    - args: function (..., envir = parent.frame())
[13:20:06.392]    - tweaked: FALSE
[13:20:06.392]    - call: NULL
[13:20:06.393] plan(): nbrOfWorkers() = 1
[13:20:06.395] plan(): Setting new future strategy stack:
[13:20:06.395] List of future strategies:
[13:20:06.395] 1. multicore:
[13:20:06.395]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:06.395]    - tweaked: FALSE
[13:20:06.395]    - call: plan(strategy)
[13:20:06.400] plan(): nbrOfWorkers() = 2
[13:20:06.391] MulticoreFuture:
[13:20:06.391] Label: ‘future_eapply-2’
[13:20:06.391] Expression:
[13:20:06.391] {
[13:20:06.391]     do.call(function(...) {
[13:20:06.391]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:06.391]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:06.391]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:06.391]             on.exit(options(oopts), add = TRUE)
[13:20:06.391]         }
[13:20:06.391]         {
[13:20:06.391]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:06.391]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:06.391]                 ...future.FUN(...future.X_jj, ...)
[13:20:06.391]             })
[13:20:06.391]         }
[13:20:06.391]     }, args = future.call.arguments)
[13:20:06.391] }
[13:20:06.391] Lazy evaluation: FALSE
[13:20:06.391] Asynchronous evaluation: TRUE
[13:20:06.391] Local evaluation: TRUE
[13:20:06.391] Environment: R_GlobalEnv
[13:20:06.391] Capture standard output: TRUE
[13:20:06.391] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:06.391] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:06.391] Packages: 1 packages (‘stats’)
[13:20:06.391] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:06.391] Resolved: TRUE
[13:20:06.391] Value: <not collected>
[13:20:06.391] Conditions captured: <none>
[13:20:06.391] Early signaling: FALSE
[13:20:06.391] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:06.391] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:06.401] Chunk #2 of 2 ... DONE
[13:20:06.402] Launching 2 futures (chunks) ... DONE
[13:20:06.402] Resolving 2 futures (chunks) ...
[13:20:06.402] resolve() on list ...
[13:20:06.402]  recursive: 0
[13:20:06.402]  length: 2
[13:20:06.402] 
[13:20:06.403] Future #1
[13:20:06.403] result() for MulticoreFuture ...
[13:20:06.404] result() for MulticoreFuture ...
[13:20:06.404] result() for MulticoreFuture ... done
[13:20:06.404] result() for MulticoreFuture ... done
[13:20:06.404] result() for MulticoreFuture ...
[13:20:06.405] result() for MulticoreFuture ... done
[13:20:06.405] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:20:06.405] - nx: 2
[13:20:06.405] - relay: TRUE
[13:20:06.405] - stdout: TRUE
[13:20:06.405] - signal: TRUE
[13:20:06.405] - resignal: FALSE
[13:20:06.406] - force: TRUE
[13:20:06.406] - relayed: [n=2] FALSE, FALSE
[13:20:06.406] - queued futures: [n=2] FALSE, FALSE
[13:20:06.406]  - until=1
[13:20:06.406]  - relaying element #1
[13:20:06.406] result() for MulticoreFuture ...
[13:20:06.406] result() for MulticoreFuture ... done
[13:20:06.407] result() for MulticoreFuture ...
[13:20:06.407] result() for MulticoreFuture ... done
[13:20:06.407] result() for MulticoreFuture ...
[13:20:06.407] result() for MulticoreFuture ... done
[13:20:06.407] result() for MulticoreFuture ...
[13:20:06.407] result() for MulticoreFuture ... done
[13:20:06.407] - relayed: [n=2] TRUE, FALSE
[13:20:06.408] - queued futures: [n=2] TRUE, FALSE
[13:20:06.408] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:20:06.408]  length: 1 (resolved future 1)
[13:20:06.408] Future #2
[13:20:06.408] result() for MulticoreFuture ...
[13:20:06.409] result() for MulticoreFuture ...
[13:20:06.409] result() for MulticoreFuture ... done
[13:20:06.409] result() for MulticoreFuture ... done
[13:20:06.409] result() for MulticoreFuture ...
[13:20:06.410] result() for MulticoreFuture ... done
[13:20:06.410] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:06.410] - nx: 2
[13:20:06.410] - relay: TRUE
[13:20:06.410] - stdout: TRUE
[13:20:06.410] - signal: TRUE
[13:20:06.410] - resignal: FALSE
[13:20:06.410] - force: TRUE
[13:20:06.411] - relayed: [n=2] TRUE, FALSE
[13:20:06.411] - queued futures: [n=2] TRUE, FALSE
[13:20:06.411]  - until=2
[13:20:06.411]  - relaying element #2
[13:20:06.411] result() for MulticoreFuture ...
[13:20:06.411] result() for MulticoreFuture ... done
[13:20:06.411] result() for MulticoreFuture ...
[13:20:06.411] result() for MulticoreFuture ... done
[13:20:06.412] result() for MulticoreFuture ...
[13:20:06.412] result() for MulticoreFuture ... done
[13:20:06.412] result() for MulticoreFuture ...
[13:20:06.412] result() for MulticoreFuture ... done
[13:20:06.412] - relayed: [n=2] TRUE, TRUE
[13:20:06.412] - queued futures: [n=2] TRUE, TRUE
[13:20:06.412] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:06.412]  length: 0 (resolved future 2)
[13:20:06.413] Relaying remaining futures
[13:20:06.413] signalConditionsASAP(NULL, pos=0) ...
[13:20:06.413] - nx: 2
[13:20:06.413] - relay: TRUE
[13:20:06.413] - stdout: TRUE
[13:20:06.413] - signal: TRUE
[13:20:06.413] - resignal: FALSE
[13:20:06.416] - force: TRUE
[13:20:06.416] - relayed: [n=2] TRUE, TRUE
[13:20:06.416] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:06.416] - relayed: [n=2] TRUE, TRUE
[13:20:06.416] - queued futures: [n=2] TRUE, TRUE
[13:20:06.417] signalConditionsASAP(NULL, pos=0) ... done
[13:20:06.417] resolve() on list ... DONE
[13:20:06.417] result() for MulticoreFuture ...
[13:20:06.417] result() for MulticoreFuture ... done
[13:20:06.417] result() for MulticoreFuture ...
[13:20:06.417] result() for MulticoreFuture ... done
[13:20:06.417] result() for MulticoreFuture ...
[13:20:06.418] result() for MulticoreFuture ... done
[13:20:06.418] result() for MulticoreFuture ...
[13:20:06.418] result() for MulticoreFuture ... done
[13:20:06.418]  - Number of value chunks collected: 2
[13:20:06.418] Resolving 2 futures (chunks) ... DONE
[13:20:06.418] Reducing values from 2 chunks ...
[13:20:06.419]  - Number of values collected after concatenation: 3
[13:20:06.419]  - Number of values expected: 3
[13:20:06.419] Reducing values from 2 chunks ... DONE
[13:20:06.419] future_lapply() ... DONE
[13:20:06.420] plan(): Setting new future strategy stack:
[13:20:06.420] List of future strategies:
[13:20:06.420] 1. sequential:
[13:20:06.420]    - args: function (..., envir = parent.frame())
[13:20:06.420]    - tweaked: FALSE
[13:20:06.420]    - call: plan(sequential)
[13:20:06.420] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[13:20:06.421] plan(): Setting new future strategy stack:
[13:20:06.421] List of future strategies:
[13:20:06.421] 1. multisession:
[13:20:06.421]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:06.421]    - tweaked: FALSE
[13:20:06.421]    - call: plan(strategy)
[13:20:06.421] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:20:06.422] multisession:
[13:20:06.422] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:06.422] - tweaked: FALSE
[13:20:06.422] - call: plan(strategy)
[13:20:06.429] getGlobalsAndPackages() ...
[13:20:06.429] Not searching for globals
[13:20:06.429] - globals: [0] <none>
[13:20:06.429] getGlobalsAndPackages() ... DONE
[13:20:06.430] [local output] makeClusterPSOCK() ...
[13:20:06.475] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:20:06.476] [local output] Base port: 11483
[13:20:06.476] [local output] Getting setup options for 2 cluster nodes ...
[13:20:06.476] [local output]  - Node 1 of 2 ...
[13:20:06.477] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:06.478] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKCdc3U/worker.rank=1.parallelly.parent=70080.111c02d12d6c3.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpKCdc3U/worker.rank=1.parallelly.parent=70080.111c02d12d6c3.pid")'’
[13:20:06.670] - Possible to infer worker's PID: TRUE
[13:20:06.670] [local output] Rscript port: 11483

[13:20:06.671] [local output]  - Node 2 of 2 ...
[13:20:06.671] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:06.672] [local output] Rscript port: 11483

[13:20:06.672] [local output] Getting setup options for 2 cluster nodes ... done
[13:20:06.672] [local output]  - Parallel setup requested for some PSOCK nodes
[13:20:06.673] [local output] Setting up PSOCK nodes in parallel
[13:20:06.673] List of 36
[13:20:06.673]  $ worker          : chr "localhost"
[13:20:06.673]   ..- attr(*, "localhost")= logi TRUE
[13:20:06.673]  $ master          : chr "localhost"
[13:20:06.673]  $ port            : int 11483
[13:20:06.673]  $ connectTimeout  : num 120
[13:20:06.673]  $ timeout         : num 2592000
[13:20:06.673]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:20:06.673]  $ homogeneous     : logi TRUE
[13:20:06.673]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:20:06.673]  $ rscript_envs    : NULL
[13:20:06.673]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:06.673]  $ rscript_startup : NULL
[13:20:06.673]  $ rscript_sh      : chr "sh"
[13:20:06.673]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:06.673]  $ methods         : logi TRUE
[13:20:06.673]  $ socketOptions   : chr "no-delay"
[13:20:06.673]  $ useXDR          : logi FALSE
[13:20:06.673]  $ outfile         : chr "/dev/null"
[13:20:06.673]  $ renice          : int NA
[13:20:06.673]  $ rshcmd          : NULL
[13:20:06.673]  $ user            : chr(0) 
[13:20:06.673]  $ revtunnel       : logi FALSE
[13:20:06.673]  $ rshlogfile      : NULL
[13:20:06.673]  $ rshopts         : chr(0) 
[13:20:06.673]  $ rank            : int 1
[13:20:06.673]  $ manual          : logi FALSE
[13:20:06.673]  $ dryrun          : logi FALSE
[13:20:06.673]  $ quiet           : logi FALSE
[13:20:06.673]  $ setup_strategy  : chr "parallel"
[13:20:06.673]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:06.673]  $ pidfile         : chr "/tmp/RtmpKCdc3U/worker.rank=1.parallelly.parent=70080.111c02d12d6c3.pid"
[13:20:06.673]  $ rshcmd_label    : NULL
[13:20:06.673]  $ rsh_call        : NULL
[13:20:06.673]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:06.673]  $ localMachine    : logi TRUE
[13:20:06.673]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:20:06.673]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:20:06.673]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:20:06.673]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:20:06.673]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:20:06.673]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:20:06.673]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:20:06.673]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:20:06.673]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:20:06.673]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:20:06.673]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:20:06.673]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:20:06.673]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:20:06.673]  $ arguments       :List of 28
[13:20:06.673]   ..$ worker          : chr "localhost"
[13:20:06.673]   ..$ master          : NULL
[13:20:06.673]   ..$ port            : int 11483
[13:20:06.673]   ..$ connectTimeout  : num 120
[13:20:06.673]   ..$ timeout         : num 2592000
[13:20:06.673]   ..$ rscript         : NULL
[13:20:06.673]   ..$ homogeneous     : NULL
[13:20:06.673]   ..$ rscript_args    : NULL
[13:20:06.673]   ..$ rscript_envs    : NULL
[13:20:06.673]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:06.673]   ..$ rscript_startup : NULL
[13:20:06.673]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:20:06.673]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:06.673]   ..$ methods         : logi TRUE
[13:20:06.673]   ..$ socketOptions   : chr "no-delay"
[13:20:06.673]   ..$ useXDR          : logi FALSE
[13:20:06.673]   ..$ outfile         : chr "/dev/null"
[13:20:06.673]   ..$ renice          : int NA
[13:20:06.673]   ..$ rshcmd          : NULL
[13:20:06.673]   ..$ user            : NULL
[13:20:06.673]   ..$ revtunnel       : logi NA
[13:20:06.673]   ..$ rshlogfile      : NULL
[13:20:06.673]   ..$ rshopts         : NULL
[13:20:06.673]   ..$ rank            : int 1
[13:20:06.673]   ..$ manual          : logi FALSE
[13:20:06.673]   ..$ dryrun          : logi FALSE
[13:20:06.673]   ..$ quiet           : logi FALSE
[13:20:06.673]   ..$ setup_strategy  : chr "parallel"
[13:20:06.673]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:20:06.690] [local output] System call to launch all workers:
[13:20:06.690] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKCdc3U/worker.rank=1.parallelly.parent=70080.111c02d12d6c3.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11483 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:20:06.690] [local output] Starting PSOCK main server
[13:20:06.696] [local output] Workers launched
[13:20:06.696] [local output] Waiting for workers to connect back
[13:20:06.697]  - [local output] 0 workers out of 2 ready
[13:20:06.943]  - [local output] 0 workers out of 2 ready
[13:20:06.944]  - [local output] 1 workers out of 2 ready
[13:20:06.952]  - [local output] 1 workers out of 2 ready
[13:20:06.953]  - [local output] 2 workers out of 2 ready
[13:20:06.953] [local output] Launching of workers completed
[13:20:06.953] [local output] Collecting session information from workers
[13:20:06.954] [local output]  - Worker #1 of 2
[13:20:06.954] [local output]  - Worker #2 of 2
[13:20:06.955] [local output] makeClusterPSOCK() ... done
[13:20:06.966] Packages needed by the future expression (n = 0): <none>
[13:20:06.966] Packages needed by future strategies (n = 0): <none>
[13:20:06.967] {
[13:20:06.967]     {
[13:20:06.967]         {
[13:20:06.967]             ...future.startTime <- base::Sys.time()
[13:20:06.967]             {
[13:20:06.967]                 {
[13:20:06.967]                   {
[13:20:06.967]                     {
[13:20:06.967]                       base::local({
[13:20:06.967]                         has_future <- base::requireNamespace("future", 
[13:20:06.967]                           quietly = TRUE)
[13:20:06.967]                         if (has_future) {
[13:20:06.967]                           ns <- base::getNamespace("future")
[13:20:06.967]                           version <- ns[[".package"]][["version"]]
[13:20:06.967]                           if (is.null(version)) 
[13:20:06.967]                             version <- utils::packageVersion("future")
[13:20:06.967]                         }
[13:20:06.967]                         else {
[13:20:06.967]                           version <- NULL
[13:20:06.967]                         }
[13:20:06.967]                         if (!has_future || version < "1.8.0") {
[13:20:06.967]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:06.967]                             "", base::R.version$version.string), 
[13:20:06.967]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:06.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:06.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:06.967]                               "release", "version")], collapse = " "), 
[13:20:06.967]                             hostname = base::Sys.info()[["nodename"]])
[13:20:06.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:06.967]                             info)
[13:20:06.967]                           info <- base::paste(info, collapse = "; ")
[13:20:06.967]                           if (!has_future) {
[13:20:06.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:06.967]                               info)
[13:20:06.967]                           }
[13:20:06.967]                           else {
[13:20:06.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:06.967]                               info, version)
[13:20:06.967]                           }
[13:20:06.967]                           base::stop(msg)
[13:20:06.967]                         }
[13:20:06.967]                       })
[13:20:06.967]                     }
[13:20:06.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:06.967]                     base::options(mc.cores = 1L)
[13:20:06.967]                   }
[13:20:06.967]                   options(future.plan = NULL)
[13:20:06.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:06.967]                 }
[13:20:06.967]                 ...future.workdir <- getwd()
[13:20:06.967]             }
[13:20:06.967]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:06.967]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:06.967]         }
[13:20:06.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:06.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:06.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:06.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:06.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:06.967]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:06.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:06.967]             base::names(...future.oldOptions))
[13:20:06.967]     }
[13:20:06.967]     if (FALSE) {
[13:20:06.967]     }
[13:20:06.967]     else {
[13:20:06.967]         if (TRUE) {
[13:20:06.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:06.967]                 open = "w")
[13:20:06.967]         }
[13:20:06.967]         else {
[13:20:06.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:06.967]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:06.967]         }
[13:20:06.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:06.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:06.967]             base::sink(type = "output", split = FALSE)
[13:20:06.967]             base::close(...future.stdout)
[13:20:06.967]         }, add = TRUE)
[13:20:06.967]     }
[13:20:06.967]     ...future.frame <- base::sys.nframe()
[13:20:06.967]     ...future.conditions <- base::list()
[13:20:06.967]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:06.967]     if (FALSE) {
[13:20:06.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:06.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:06.967]     }
[13:20:06.967]     ...future.result <- base::tryCatch({
[13:20:06.967]         base::withCallingHandlers({
[13:20:06.967]             ...future.value <- base::withVisible(base::local({
[13:20:06.967]                 ...future.makeSendCondition <- base::local({
[13:20:06.967]                   sendCondition <- NULL
[13:20:06.967]                   function(frame = 1L) {
[13:20:06.967]                     if (is.function(sendCondition)) 
[13:20:06.967]                       return(sendCondition)
[13:20:06.967]                     ns <- getNamespace("parallel")
[13:20:06.967]                     if (exists("sendData", mode = "function", 
[13:20:06.967]                       envir = ns)) {
[13:20:06.967]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:06.967]                         envir = ns)
[13:20:06.967]                       envir <- sys.frame(frame)
[13:20:06.967]                       master <- NULL
[13:20:06.967]                       while (!identical(envir, .GlobalEnv) && 
[13:20:06.967]                         !identical(envir, emptyenv())) {
[13:20:06.967]                         if (exists("master", mode = "list", envir = envir, 
[13:20:06.967]                           inherits = FALSE)) {
[13:20:06.967]                           master <- get("master", mode = "list", 
[13:20:06.967]                             envir = envir, inherits = FALSE)
[13:20:06.967]                           if (inherits(master, c("SOCKnode", 
[13:20:06.967]                             "SOCK0node"))) {
[13:20:06.967]                             sendCondition <<- function(cond) {
[13:20:06.967]                               data <- list(type = "VALUE", value = cond, 
[13:20:06.967]                                 success = TRUE)
[13:20:06.967]                               parallel_sendData(master, data)
[13:20:06.967]                             }
[13:20:06.967]                             return(sendCondition)
[13:20:06.967]                           }
[13:20:06.967]                         }
[13:20:06.967]                         frame <- frame + 1L
[13:20:06.967]                         envir <- sys.frame(frame)
[13:20:06.967]                       }
[13:20:06.967]                     }
[13:20:06.967]                     sendCondition <<- function(cond) NULL
[13:20:06.967]                   }
[13:20:06.967]                 })
[13:20:06.967]                 withCallingHandlers({
[13:20:06.967]                   NA
[13:20:06.967]                 }, immediateCondition = function(cond) {
[13:20:06.967]                   sendCondition <- ...future.makeSendCondition()
[13:20:06.967]                   sendCondition(cond)
[13:20:06.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.967]                   {
[13:20:06.967]                     inherits <- base::inherits
[13:20:06.967]                     invokeRestart <- base::invokeRestart
[13:20:06.967]                     is.null <- base::is.null
[13:20:06.967]                     muffled <- FALSE
[13:20:06.967]                     if (inherits(cond, "message")) {
[13:20:06.967]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:06.967]                       if (muffled) 
[13:20:06.967]                         invokeRestart("muffleMessage")
[13:20:06.967]                     }
[13:20:06.967]                     else if (inherits(cond, "warning")) {
[13:20:06.967]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:06.967]                       if (muffled) 
[13:20:06.967]                         invokeRestart("muffleWarning")
[13:20:06.967]                     }
[13:20:06.967]                     else if (inherits(cond, "condition")) {
[13:20:06.967]                       if (!is.null(pattern)) {
[13:20:06.967]                         computeRestarts <- base::computeRestarts
[13:20:06.967]                         grepl <- base::grepl
[13:20:06.967]                         restarts <- computeRestarts(cond)
[13:20:06.967]                         for (restart in restarts) {
[13:20:06.967]                           name <- restart$name
[13:20:06.967]                           if (is.null(name)) 
[13:20:06.967]                             next
[13:20:06.967]                           if (!grepl(pattern, name)) 
[13:20:06.967]                             next
[13:20:06.967]                           invokeRestart(restart)
[13:20:06.967]                           muffled <- TRUE
[13:20:06.967]                           break
[13:20:06.967]                         }
[13:20:06.967]                       }
[13:20:06.967]                     }
[13:20:06.967]                     invisible(muffled)
[13:20:06.967]                   }
[13:20:06.967]                   muffleCondition(cond)
[13:20:06.967]                 })
[13:20:06.967]             }))
[13:20:06.967]             future::FutureResult(value = ...future.value$value, 
[13:20:06.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.967]                   ...future.rng), globalenv = if (FALSE) 
[13:20:06.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:06.967]                     ...future.globalenv.names))
[13:20:06.967]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:06.967]         }, condition = base::local({
[13:20:06.967]             c <- base::c
[13:20:06.967]             inherits <- base::inherits
[13:20:06.967]             invokeRestart <- base::invokeRestart
[13:20:06.967]             length <- base::length
[13:20:06.967]             list <- base::list
[13:20:06.967]             seq.int <- base::seq.int
[13:20:06.967]             signalCondition <- base::signalCondition
[13:20:06.967]             sys.calls <- base::sys.calls
[13:20:06.967]             `[[` <- base::`[[`
[13:20:06.967]             `+` <- base::`+`
[13:20:06.967]             `<<-` <- base::`<<-`
[13:20:06.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:06.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:06.967]                   3L)]
[13:20:06.967]             }
[13:20:06.967]             function(cond) {
[13:20:06.967]                 is_error <- inherits(cond, "error")
[13:20:06.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:06.967]                   NULL)
[13:20:06.967]                 if (is_error) {
[13:20:06.967]                   sessionInformation <- function() {
[13:20:06.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:06.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:06.967]                       search = base::search(), system = base::Sys.info())
[13:20:06.967]                   }
[13:20:06.967]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:06.967]                     cond$call), session = sessionInformation(), 
[13:20:06.967]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:06.967]                   signalCondition(cond)
[13:20:06.967]                 }
[13:20:06.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:06.967]                 "immediateCondition"))) {
[13:20:06.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:06.967]                   ...future.conditions[[length(...future.conditions) + 
[13:20:06.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:06.967]                   if (TRUE && !signal) {
[13:20:06.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.967]                     {
[13:20:06.967]                       inherits <- base::inherits
[13:20:06.967]                       invokeRestart <- base::invokeRestart
[13:20:06.967]                       is.null <- base::is.null
[13:20:06.967]                       muffled <- FALSE
[13:20:06.967]                       if (inherits(cond, "message")) {
[13:20:06.967]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.967]                         if (muffled) 
[13:20:06.967]                           invokeRestart("muffleMessage")
[13:20:06.967]                       }
[13:20:06.967]                       else if (inherits(cond, "warning")) {
[13:20:06.967]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.967]                         if (muffled) 
[13:20:06.967]                           invokeRestart("muffleWarning")
[13:20:06.967]                       }
[13:20:06.967]                       else if (inherits(cond, "condition")) {
[13:20:06.967]                         if (!is.null(pattern)) {
[13:20:06.967]                           computeRestarts <- base::computeRestarts
[13:20:06.967]                           grepl <- base::grepl
[13:20:06.967]                           restarts <- computeRestarts(cond)
[13:20:06.967]                           for (restart in restarts) {
[13:20:06.967]                             name <- restart$name
[13:20:06.967]                             if (is.null(name)) 
[13:20:06.967]                               next
[13:20:06.967]                             if (!grepl(pattern, name)) 
[13:20:06.967]                               next
[13:20:06.967]                             invokeRestart(restart)
[13:20:06.967]                             muffled <- TRUE
[13:20:06.967]                             break
[13:20:06.967]                           }
[13:20:06.967]                         }
[13:20:06.967]                       }
[13:20:06.967]                       invisible(muffled)
[13:20:06.967]                     }
[13:20:06.967]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.967]                   }
[13:20:06.967]                 }
[13:20:06.967]                 else {
[13:20:06.967]                   if (TRUE) {
[13:20:06.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:06.967]                     {
[13:20:06.967]                       inherits <- base::inherits
[13:20:06.967]                       invokeRestart <- base::invokeRestart
[13:20:06.967]                       is.null <- base::is.null
[13:20:06.967]                       muffled <- FALSE
[13:20:06.967]                       if (inherits(cond, "message")) {
[13:20:06.967]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:06.967]                         if (muffled) 
[13:20:06.967]                           invokeRestart("muffleMessage")
[13:20:06.967]                       }
[13:20:06.967]                       else if (inherits(cond, "warning")) {
[13:20:06.967]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:06.967]                         if (muffled) 
[13:20:06.967]                           invokeRestart("muffleWarning")
[13:20:06.967]                       }
[13:20:06.967]                       else if (inherits(cond, "condition")) {
[13:20:06.967]                         if (!is.null(pattern)) {
[13:20:06.967]                           computeRestarts <- base::computeRestarts
[13:20:06.967]                           grepl <- base::grepl
[13:20:06.967]                           restarts <- computeRestarts(cond)
[13:20:06.967]                           for (restart in restarts) {
[13:20:06.967]                             name <- restart$name
[13:20:06.967]                             if (is.null(name)) 
[13:20:06.967]                               next
[13:20:06.967]                             if (!grepl(pattern, name)) 
[13:20:06.967]                               next
[13:20:06.967]                             invokeRestart(restart)
[13:20:06.967]                             muffled <- TRUE
[13:20:06.967]                             break
[13:20:06.967]                           }
[13:20:06.967]                         }
[13:20:06.967]                       }
[13:20:06.967]                       invisible(muffled)
[13:20:06.967]                     }
[13:20:06.967]                     muffleCondition(cond, pattern = "^muffle")
[13:20:06.967]                   }
[13:20:06.967]                 }
[13:20:06.967]             }
[13:20:06.967]         }))
[13:20:06.967]     }, error = function(ex) {
[13:20:06.967]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:06.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:06.967]                 ...future.rng), started = ...future.startTime, 
[13:20:06.967]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:06.967]             version = "1.8"), class = "FutureResult")
[13:20:06.967]     }, finally = {
[13:20:06.967]         if (!identical(...future.workdir, getwd())) 
[13:20:06.967]             setwd(...future.workdir)
[13:20:06.967]         {
[13:20:06.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:06.967]                 ...future.oldOptions$nwarnings <- NULL
[13:20:06.967]             }
[13:20:06.967]             base::options(...future.oldOptions)
[13:20:06.967]             if (.Platform$OS.type == "windows") {
[13:20:06.967]                 old_names <- names(...future.oldEnvVars)
[13:20:06.967]                 envs <- base::Sys.getenv()
[13:20:06.967]                 names <- names(envs)
[13:20:06.967]                 common <- intersect(names, old_names)
[13:20:06.967]                 added <- setdiff(names, old_names)
[13:20:06.967]                 removed <- setdiff(old_names, names)
[13:20:06.967]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:06.967]                   envs[common]]
[13:20:06.967]                 NAMES <- toupper(changed)
[13:20:06.967]                 args <- list()
[13:20:06.967]                 for (kk in seq_along(NAMES)) {
[13:20:06.967]                   name <- changed[[kk]]
[13:20:06.967]                   NAME <- NAMES[[kk]]
[13:20:06.967]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.967]                     next
[13:20:06.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.967]                 }
[13:20:06.967]                 NAMES <- toupper(added)
[13:20:06.967]                 for (kk in seq_along(NAMES)) {
[13:20:06.967]                   name <- added[[kk]]
[13:20:06.967]                   NAME <- NAMES[[kk]]
[13:20:06.967]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.967]                     next
[13:20:06.967]                   args[[name]] <- ""
[13:20:06.967]                 }
[13:20:06.967]                 NAMES <- toupper(removed)
[13:20:06.967]                 for (kk in seq_along(NAMES)) {
[13:20:06.967]                   name <- removed[[kk]]
[13:20:06.967]                   NAME <- NAMES[[kk]]
[13:20:06.967]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:06.967]                     next
[13:20:06.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:06.967]                 }
[13:20:06.967]                 if (length(args) > 0) 
[13:20:06.967]                   base::do.call(base::Sys.setenv, args = args)
[13:20:06.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:06.967]             }
[13:20:06.967]             else {
[13:20:06.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:06.967]             }
[13:20:06.967]             {
[13:20:06.967]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:06.967]                   0L) {
[13:20:06.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:06.967]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:06.967]                   base::options(opts)
[13:20:06.967]                 }
[13:20:06.967]                 {
[13:20:06.967]                   {
[13:20:06.967]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:06.967]                     NULL
[13:20:06.967]                   }
[13:20:06.967]                   options(future.plan = NULL)
[13:20:06.967]                   if (is.na(NA_character_)) 
[13:20:06.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:06.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:06.967]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:06.967]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:06.967]                     envir = parent.frame()) 
[13:20:06.967]                   {
[13:20:06.967]                     if (is.function(workers)) 
[13:20:06.967]                       workers <- workers()
[13:20:06.967]                     workers <- structure(as.integer(workers), 
[13:20:06.967]                       class = class(workers))
[13:20:06.967]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:06.967]                       workers >= 1)
[13:20:06.967]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:06.967]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:06.967]                     }
[13:20:06.967]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:06.967]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:06.967]                       envir = envir)
[13:20:06.967]                     if (!future$lazy) 
[13:20:06.967]                       future <- run(future)
[13:20:06.967]                     invisible(future)
[13:20:06.967]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:06.967]                 }
[13:20:06.967]             }
[13:20:06.967]         }
[13:20:06.967]     })
[13:20:06.967]     if (TRUE) {
[13:20:06.967]         base::sink(type = "output", split = FALSE)
[13:20:06.967]         if (TRUE) {
[13:20:06.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:06.967]         }
[13:20:06.967]         else {
[13:20:06.967]             ...future.result["stdout"] <- base::list(NULL)
[13:20:06.967]         }
[13:20:06.967]         base::close(...future.stdout)
[13:20:06.967]         ...future.stdout <- NULL
[13:20:06.967]     }
[13:20:06.967]     ...future.result$conditions <- ...future.conditions
[13:20:06.967]     ...future.result$finished <- base::Sys.time()
[13:20:06.967]     ...future.result
[13:20:06.967] }
[13:20:07.021] MultisessionFuture started
[13:20:07.022] result() for ClusterFuture ...
[13:20:07.022] receiveMessageFromWorker() for ClusterFuture ...
[13:20:07.023] - Validating connection of MultisessionFuture
[13:20:07.069] - received message: FutureResult
[13:20:07.069] - Received FutureResult
[13:20:07.069] - Erased future from FutureRegistry
[13:20:07.069] result() for ClusterFuture ...
[13:20:07.069] - result already collected: FutureResult
[13:20:07.069] result() for ClusterFuture ... done
[13:20:07.070] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:07.070] result() for ClusterFuture ... done
[13:20:07.070] result() for ClusterFuture ...
[13:20:07.070] - result already collected: FutureResult
[13:20:07.070] result() for ClusterFuture ... done
[13:20:07.070] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:20:07.074] plan(): nbrOfWorkers() = 2
[13:20:07.074] future_lapply() ...
[13:20:07.078] Number of chunks: 2
[13:20:07.078] getGlobalsAndPackagesXApply() ...
[13:20:07.078]  - future.globals: TRUE
[13:20:07.079] getGlobalsAndPackages() ...
[13:20:07.079] Searching for globals...
[13:20:07.080] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:07.080] Searching for globals ... DONE
[13:20:07.080] Resolving globals: FALSE
[13:20:07.081] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:07.081] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:07.081] - globals: [1] ‘FUN’
[13:20:07.081] 
[13:20:07.082] getGlobalsAndPackages() ... DONE
[13:20:07.082]  - globals found/used: [n=1] ‘FUN’
[13:20:07.082]  - needed namespaces: [n=0] 
[13:20:07.082] Finding globals ... DONE
[13:20:07.082]  - use_args: TRUE
[13:20:07.082]  - Getting '...' globals ...
[13:20:07.083] resolve() on list ...
[13:20:07.083]  recursive: 0
[13:20:07.083]  length: 1
[13:20:07.083]  elements: ‘...’
[13:20:07.083]  length: 0 (resolved future 1)
[13:20:07.083] resolve() on list ... DONE
[13:20:07.083]    - '...' content: [n=0] 
[13:20:07.083] List of 1
[13:20:07.083]  $ ...: list()
[13:20:07.083]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:07.083]  - attr(*, "where")=List of 1
[13:20:07.083]   ..$ ...:<environment: 0x558fda45d820> 
[13:20:07.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:07.083]  - attr(*, "resolved")= logi TRUE
[13:20:07.083]  - attr(*, "total_size")= num NA
[13:20:07.087]  - Getting '...' globals ... DONE
[13:20:07.087] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:07.087] List of 2
[13:20:07.087]  $ ...future.FUN:function (x, ...)  
[13:20:07.087]  $ ...          : list()
[13:20:07.087]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:07.087]  - attr(*, "where")=List of 2
[13:20:07.087]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:07.087]   ..$ ...          :<environment: 0x558fda45d820> 
[13:20:07.087]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:07.087]  - attr(*, "resolved")= logi FALSE
[13:20:07.087]  - attr(*, "total_size")= num 1240
[13:20:07.090] Packages to be attached in all futures: [n=0] 
[13:20:07.090] getGlobalsAndPackagesXApply() ... DONE
[13:20:07.091] Number of futures (= number of chunks): 2
[13:20:07.091] Launching 2 futures (chunks) ...
[13:20:07.091] Chunk #1 of 2 ...
[13:20:07.091]  - Finding globals in 'X' for chunk #1 ...
[13:20:07.091] getGlobalsAndPackages() ...
[13:20:07.091] Searching for globals...
[13:20:07.092] 
[13:20:07.092] Searching for globals ... DONE
[13:20:07.092] - globals: [0] <none>
[13:20:07.092] getGlobalsAndPackages() ... DONE
[13:20:07.092]    + additional globals found: [n=0] 
[13:20:07.092]    + additional namespaces needed: [n=0] 
[13:20:07.092]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:07.092]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:07.093]  - seeds: <none>
[13:20:07.093]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.093] getGlobalsAndPackages() ...
[13:20:07.093] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.093] Resolving globals: FALSE
[13:20:07.093] Tweak future expression to call with '...' arguments ...
[13:20:07.093] {
[13:20:07.093]     do.call(function(...) {
[13:20:07.093]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.093]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.093]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.093]             on.exit(options(oopts), add = TRUE)
[13:20:07.093]         }
[13:20:07.093]         {
[13:20:07.093]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.093]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.093]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.093]             })
[13:20:07.093]         }
[13:20:07.093]     }, args = future.call.arguments)
[13:20:07.093] }
[13:20:07.094] Tweak future expression to call with '...' arguments ... DONE
[13:20:07.094] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.094] 
[13:20:07.094] getGlobalsAndPackages() ... DONE
[13:20:07.095] run() for ‘Future’ ...
[13:20:07.095] - state: ‘created’
[13:20:07.095] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:07.110] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:07.110]   - Field: ‘node’
[13:20:07.110]   - Field: ‘label’
[13:20:07.110]   - Field: ‘local’
[13:20:07.110]   - Field: ‘owner’
[13:20:07.110]   - Field: ‘envir’
[13:20:07.111]   - Field: ‘workers’
[13:20:07.111]   - Field: ‘packages’
[13:20:07.111]   - Field: ‘gc’
[13:20:07.111]   - Field: ‘conditions’
[13:20:07.111]   - Field: ‘persistent’
[13:20:07.111]   - Field: ‘expr’
[13:20:07.111]   - Field: ‘uuid’
[13:20:07.111]   - Field: ‘seed’
[13:20:07.111]   - Field: ‘version’
[13:20:07.112]   - Field: ‘result’
[13:20:07.112]   - Field: ‘asynchronous’
[13:20:07.112]   - Field: ‘calls’
[13:20:07.112]   - Field: ‘globals’
[13:20:07.112]   - Field: ‘stdout’
[13:20:07.112]   - Field: ‘earlySignal’
[13:20:07.112]   - Field: ‘lazy’
[13:20:07.112]   - Field: ‘state’
[13:20:07.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:07.113] - Launch lazy future ...
[13:20:07.113] Packages needed by the future expression (n = 0): <none>
[13:20:07.113] Packages needed by future strategies (n = 0): <none>
[13:20:07.114] {
[13:20:07.114]     {
[13:20:07.114]         {
[13:20:07.114]             ...future.startTime <- base::Sys.time()
[13:20:07.114]             {
[13:20:07.114]                 {
[13:20:07.114]                   {
[13:20:07.114]                     {
[13:20:07.114]                       base::local({
[13:20:07.114]                         has_future <- base::requireNamespace("future", 
[13:20:07.114]                           quietly = TRUE)
[13:20:07.114]                         if (has_future) {
[13:20:07.114]                           ns <- base::getNamespace("future")
[13:20:07.114]                           version <- ns[[".package"]][["version"]]
[13:20:07.114]                           if (is.null(version)) 
[13:20:07.114]                             version <- utils::packageVersion("future")
[13:20:07.114]                         }
[13:20:07.114]                         else {
[13:20:07.114]                           version <- NULL
[13:20:07.114]                         }
[13:20:07.114]                         if (!has_future || version < "1.8.0") {
[13:20:07.114]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:07.114]                             "", base::R.version$version.string), 
[13:20:07.114]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:07.114]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:07.114]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:07.114]                               "release", "version")], collapse = " "), 
[13:20:07.114]                             hostname = base::Sys.info()[["nodename"]])
[13:20:07.114]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:07.114]                             info)
[13:20:07.114]                           info <- base::paste(info, collapse = "; ")
[13:20:07.114]                           if (!has_future) {
[13:20:07.114]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:07.114]                               info)
[13:20:07.114]                           }
[13:20:07.114]                           else {
[13:20:07.114]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:07.114]                               info, version)
[13:20:07.114]                           }
[13:20:07.114]                           base::stop(msg)
[13:20:07.114]                         }
[13:20:07.114]                       })
[13:20:07.114]                     }
[13:20:07.114]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:07.114]                     base::options(mc.cores = 1L)
[13:20:07.114]                   }
[13:20:07.114]                   options(future.plan = NULL)
[13:20:07.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:07.114]                 }
[13:20:07.114]                 ...future.workdir <- getwd()
[13:20:07.114]             }
[13:20:07.114]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:07.114]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:07.114]         }
[13:20:07.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:07.114]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:07.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:07.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:07.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:07.114]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:07.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:07.114]             base::names(...future.oldOptions))
[13:20:07.114]     }
[13:20:07.114]     if (FALSE) {
[13:20:07.114]     }
[13:20:07.114]     else {
[13:20:07.114]         if (TRUE) {
[13:20:07.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:07.114]                 open = "w")
[13:20:07.114]         }
[13:20:07.114]         else {
[13:20:07.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:07.114]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:07.114]         }
[13:20:07.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:07.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:07.114]             base::sink(type = "output", split = FALSE)
[13:20:07.114]             base::close(...future.stdout)
[13:20:07.114]         }, add = TRUE)
[13:20:07.114]     }
[13:20:07.114]     ...future.frame <- base::sys.nframe()
[13:20:07.114]     ...future.conditions <- base::list()
[13:20:07.114]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:07.114]     if (FALSE) {
[13:20:07.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:07.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:07.114]     }
[13:20:07.114]     ...future.result <- base::tryCatch({
[13:20:07.114]         base::withCallingHandlers({
[13:20:07.114]             ...future.value <- base::withVisible(base::local({
[13:20:07.114]                 ...future.makeSendCondition <- base::local({
[13:20:07.114]                   sendCondition <- NULL
[13:20:07.114]                   function(frame = 1L) {
[13:20:07.114]                     if (is.function(sendCondition)) 
[13:20:07.114]                       return(sendCondition)
[13:20:07.114]                     ns <- getNamespace("parallel")
[13:20:07.114]                     if (exists("sendData", mode = "function", 
[13:20:07.114]                       envir = ns)) {
[13:20:07.114]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:07.114]                         envir = ns)
[13:20:07.114]                       envir <- sys.frame(frame)
[13:20:07.114]                       master <- NULL
[13:20:07.114]                       while (!identical(envir, .GlobalEnv) && 
[13:20:07.114]                         !identical(envir, emptyenv())) {
[13:20:07.114]                         if (exists("master", mode = "list", envir = envir, 
[13:20:07.114]                           inherits = FALSE)) {
[13:20:07.114]                           master <- get("master", mode = "list", 
[13:20:07.114]                             envir = envir, inherits = FALSE)
[13:20:07.114]                           if (inherits(master, c("SOCKnode", 
[13:20:07.114]                             "SOCK0node"))) {
[13:20:07.114]                             sendCondition <<- function(cond) {
[13:20:07.114]                               data <- list(type = "VALUE", value = cond, 
[13:20:07.114]                                 success = TRUE)
[13:20:07.114]                               parallel_sendData(master, data)
[13:20:07.114]                             }
[13:20:07.114]                             return(sendCondition)
[13:20:07.114]                           }
[13:20:07.114]                         }
[13:20:07.114]                         frame <- frame + 1L
[13:20:07.114]                         envir <- sys.frame(frame)
[13:20:07.114]                       }
[13:20:07.114]                     }
[13:20:07.114]                     sendCondition <<- function(cond) NULL
[13:20:07.114]                   }
[13:20:07.114]                 })
[13:20:07.114]                 withCallingHandlers({
[13:20:07.114]                   {
[13:20:07.114]                     do.call(function(...) {
[13:20:07.114]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.114]                       if (!identical(...future.globals.maxSize.org, 
[13:20:07.114]                         ...future.globals.maxSize)) {
[13:20:07.114]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.114]                         on.exit(options(oopts), add = TRUE)
[13:20:07.114]                       }
[13:20:07.114]                       {
[13:20:07.114]                         lapply(seq_along(...future.elements_ii), 
[13:20:07.114]                           FUN = function(jj) {
[13:20:07.114]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.114]                             ...future.FUN(...future.X_jj, ...)
[13:20:07.114]                           })
[13:20:07.114]                       }
[13:20:07.114]                     }, args = future.call.arguments)
[13:20:07.114]                   }
[13:20:07.114]                 }, immediateCondition = function(cond) {
[13:20:07.114]                   sendCondition <- ...future.makeSendCondition()
[13:20:07.114]                   sendCondition(cond)
[13:20:07.114]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.114]                   {
[13:20:07.114]                     inherits <- base::inherits
[13:20:07.114]                     invokeRestart <- base::invokeRestart
[13:20:07.114]                     is.null <- base::is.null
[13:20:07.114]                     muffled <- FALSE
[13:20:07.114]                     if (inherits(cond, "message")) {
[13:20:07.114]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:07.114]                       if (muffled) 
[13:20:07.114]                         invokeRestart("muffleMessage")
[13:20:07.114]                     }
[13:20:07.114]                     else if (inherits(cond, "warning")) {
[13:20:07.114]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:07.114]                       if (muffled) 
[13:20:07.114]                         invokeRestart("muffleWarning")
[13:20:07.114]                     }
[13:20:07.114]                     else if (inherits(cond, "condition")) {
[13:20:07.114]                       if (!is.null(pattern)) {
[13:20:07.114]                         computeRestarts <- base::computeRestarts
[13:20:07.114]                         grepl <- base::grepl
[13:20:07.114]                         restarts <- computeRestarts(cond)
[13:20:07.114]                         for (restart in restarts) {
[13:20:07.114]                           name <- restart$name
[13:20:07.114]                           if (is.null(name)) 
[13:20:07.114]                             next
[13:20:07.114]                           if (!grepl(pattern, name)) 
[13:20:07.114]                             next
[13:20:07.114]                           invokeRestart(restart)
[13:20:07.114]                           muffled <- TRUE
[13:20:07.114]                           break
[13:20:07.114]                         }
[13:20:07.114]                       }
[13:20:07.114]                     }
[13:20:07.114]                     invisible(muffled)
[13:20:07.114]                   }
[13:20:07.114]                   muffleCondition(cond)
[13:20:07.114]                 })
[13:20:07.114]             }))
[13:20:07.114]             future::FutureResult(value = ...future.value$value, 
[13:20:07.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.114]                   ...future.rng), globalenv = if (FALSE) 
[13:20:07.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:07.114]                     ...future.globalenv.names))
[13:20:07.114]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:07.114]         }, condition = base::local({
[13:20:07.114]             c <- base::c
[13:20:07.114]             inherits <- base::inherits
[13:20:07.114]             invokeRestart <- base::invokeRestart
[13:20:07.114]             length <- base::length
[13:20:07.114]             list <- base::list
[13:20:07.114]             seq.int <- base::seq.int
[13:20:07.114]             signalCondition <- base::signalCondition
[13:20:07.114]             sys.calls <- base::sys.calls
[13:20:07.114]             `[[` <- base::`[[`
[13:20:07.114]             `+` <- base::`+`
[13:20:07.114]             `<<-` <- base::`<<-`
[13:20:07.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:07.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:07.114]                   3L)]
[13:20:07.114]             }
[13:20:07.114]             function(cond) {
[13:20:07.114]                 is_error <- inherits(cond, "error")
[13:20:07.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:07.114]                   NULL)
[13:20:07.114]                 if (is_error) {
[13:20:07.114]                   sessionInformation <- function() {
[13:20:07.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:07.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:07.114]                       search = base::search(), system = base::Sys.info())
[13:20:07.114]                   }
[13:20:07.114]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:07.114]                     cond$call), session = sessionInformation(), 
[13:20:07.114]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:07.114]                   signalCondition(cond)
[13:20:07.114]                 }
[13:20:07.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:07.114]                 "immediateCondition"))) {
[13:20:07.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:07.114]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:07.114]                   if (TRUE && !signal) {
[13:20:07.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.114]                     {
[13:20:07.114]                       inherits <- base::inherits
[13:20:07.114]                       invokeRestart <- base::invokeRestart
[13:20:07.114]                       is.null <- base::is.null
[13:20:07.114]                       muffled <- FALSE
[13:20:07.114]                       if (inherits(cond, "message")) {
[13:20:07.114]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.114]                         if (muffled) 
[13:20:07.114]                           invokeRestart("muffleMessage")
[13:20:07.114]                       }
[13:20:07.114]                       else if (inherits(cond, "warning")) {
[13:20:07.114]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.114]                         if (muffled) 
[13:20:07.114]                           invokeRestart("muffleWarning")
[13:20:07.114]                       }
[13:20:07.114]                       else if (inherits(cond, "condition")) {
[13:20:07.114]                         if (!is.null(pattern)) {
[13:20:07.114]                           computeRestarts <- base::computeRestarts
[13:20:07.114]                           grepl <- base::grepl
[13:20:07.114]                           restarts <- computeRestarts(cond)
[13:20:07.114]                           for (restart in restarts) {
[13:20:07.114]                             name <- restart$name
[13:20:07.114]                             if (is.null(name)) 
[13:20:07.114]                               next
[13:20:07.114]                             if (!grepl(pattern, name)) 
[13:20:07.114]                               next
[13:20:07.114]                             invokeRestart(restart)
[13:20:07.114]                             muffled <- TRUE
[13:20:07.114]                             break
[13:20:07.114]                           }
[13:20:07.114]                         }
[13:20:07.114]                       }
[13:20:07.114]                       invisible(muffled)
[13:20:07.114]                     }
[13:20:07.114]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.114]                   }
[13:20:07.114]                 }
[13:20:07.114]                 else {
[13:20:07.114]                   if (TRUE) {
[13:20:07.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.114]                     {
[13:20:07.114]                       inherits <- base::inherits
[13:20:07.114]                       invokeRestart <- base::invokeRestart
[13:20:07.114]                       is.null <- base::is.null
[13:20:07.114]                       muffled <- FALSE
[13:20:07.114]                       if (inherits(cond, "message")) {
[13:20:07.114]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.114]                         if (muffled) 
[13:20:07.114]                           invokeRestart("muffleMessage")
[13:20:07.114]                       }
[13:20:07.114]                       else if (inherits(cond, "warning")) {
[13:20:07.114]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.114]                         if (muffled) 
[13:20:07.114]                           invokeRestart("muffleWarning")
[13:20:07.114]                       }
[13:20:07.114]                       else if (inherits(cond, "condition")) {
[13:20:07.114]                         if (!is.null(pattern)) {
[13:20:07.114]                           computeRestarts <- base::computeRestarts
[13:20:07.114]                           grepl <- base::grepl
[13:20:07.114]                           restarts <- computeRestarts(cond)
[13:20:07.114]                           for (restart in restarts) {
[13:20:07.114]                             name <- restart$name
[13:20:07.114]                             if (is.null(name)) 
[13:20:07.114]                               next
[13:20:07.114]                             if (!grepl(pattern, name)) 
[13:20:07.114]                               next
[13:20:07.114]                             invokeRestart(restart)
[13:20:07.114]                             muffled <- TRUE
[13:20:07.114]                             break
[13:20:07.114]                           }
[13:20:07.114]                         }
[13:20:07.114]                       }
[13:20:07.114]                       invisible(muffled)
[13:20:07.114]                     }
[13:20:07.114]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.114]                   }
[13:20:07.114]                 }
[13:20:07.114]             }
[13:20:07.114]         }))
[13:20:07.114]     }, error = function(ex) {
[13:20:07.114]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:07.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.114]                 ...future.rng), started = ...future.startTime, 
[13:20:07.114]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:07.114]             version = "1.8"), class = "FutureResult")
[13:20:07.114]     }, finally = {
[13:20:07.114]         if (!identical(...future.workdir, getwd())) 
[13:20:07.114]             setwd(...future.workdir)
[13:20:07.114]         {
[13:20:07.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:07.114]                 ...future.oldOptions$nwarnings <- NULL
[13:20:07.114]             }
[13:20:07.114]             base::options(...future.oldOptions)
[13:20:07.114]             if (.Platform$OS.type == "windows") {
[13:20:07.114]                 old_names <- names(...future.oldEnvVars)
[13:20:07.114]                 envs <- base::Sys.getenv()
[13:20:07.114]                 names <- names(envs)
[13:20:07.114]                 common <- intersect(names, old_names)
[13:20:07.114]                 added <- setdiff(names, old_names)
[13:20:07.114]                 removed <- setdiff(old_names, names)
[13:20:07.114]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:07.114]                   envs[common]]
[13:20:07.114]                 NAMES <- toupper(changed)
[13:20:07.114]                 args <- list()
[13:20:07.114]                 for (kk in seq_along(NAMES)) {
[13:20:07.114]                   name <- changed[[kk]]
[13:20:07.114]                   NAME <- NAMES[[kk]]
[13:20:07.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.114]                     next
[13:20:07.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.114]                 }
[13:20:07.114]                 NAMES <- toupper(added)
[13:20:07.114]                 for (kk in seq_along(NAMES)) {
[13:20:07.114]                   name <- added[[kk]]
[13:20:07.114]                   NAME <- NAMES[[kk]]
[13:20:07.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.114]                     next
[13:20:07.114]                   args[[name]] <- ""
[13:20:07.114]                 }
[13:20:07.114]                 NAMES <- toupper(removed)
[13:20:07.114]                 for (kk in seq_along(NAMES)) {
[13:20:07.114]                   name <- removed[[kk]]
[13:20:07.114]                   NAME <- NAMES[[kk]]
[13:20:07.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.114]                     next
[13:20:07.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.114]                 }
[13:20:07.114]                 if (length(args) > 0) 
[13:20:07.114]                   base::do.call(base::Sys.setenv, args = args)
[13:20:07.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:07.114]             }
[13:20:07.114]             else {
[13:20:07.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:07.114]             }
[13:20:07.114]             {
[13:20:07.114]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:07.114]                   0L) {
[13:20:07.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:07.114]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:07.114]                   base::options(opts)
[13:20:07.114]                 }
[13:20:07.114]                 {
[13:20:07.114]                   {
[13:20:07.114]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:07.114]                     NULL
[13:20:07.114]                   }
[13:20:07.114]                   options(future.plan = NULL)
[13:20:07.114]                   if (is.na(NA_character_)) 
[13:20:07.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:07.114]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:07.114]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:07.114]                     envir = parent.frame()) 
[13:20:07.114]                   {
[13:20:07.114]                     if (is.function(workers)) 
[13:20:07.114]                       workers <- workers()
[13:20:07.114]                     workers <- structure(as.integer(workers), 
[13:20:07.114]                       class = class(workers))
[13:20:07.114]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:07.114]                       workers >= 1)
[13:20:07.114]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:07.114]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:07.114]                     }
[13:20:07.114]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:07.114]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:07.114]                       envir = envir)
[13:20:07.114]                     if (!future$lazy) 
[13:20:07.114]                       future <- run(future)
[13:20:07.114]                     invisible(future)
[13:20:07.114]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:07.114]                 }
[13:20:07.114]             }
[13:20:07.114]         }
[13:20:07.114]     })
[13:20:07.114]     if (TRUE) {
[13:20:07.114]         base::sink(type = "output", split = FALSE)
[13:20:07.114]         if (TRUE) {
[13:20:07.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:07.114]         }
[13:20:07.114]         else {
[13:20:07.114]             ...future.result["stdout"] <- base::list(NULL)
[13:20:07.114]         }
[13:20:07.114]         base::close(...future.stdout)
[13:20:07.114]         ...future.stdout <- NULL
[13:20:07.114]     }
[13:20:07.114]     ...future.result$conditions <- ...future.conditions
[13:20:07.114]     ...future.result$finished <- base::Sys.time()
[13:20:07.114]     ...future.result
[13:20:07.114] }
[13:20:07.117] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:20:07.117] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:20:07.118] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:20:07.118] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:07.119] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:07.119] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:20:07.119] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:20:07.119] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:07.120] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:07.120] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:20:07.120] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:20:07.120] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:20:07.121] MultisessionFuture started
[13:20:07.121] - Launch lazy future ... done
[13:20:07.122] run() for ‘MultisessionFuture’ ... done
[13:20:07.122] Created future:
[13:20:07.122] MultisessionFuture:
[13:20:07.122] Label: ‘future_eapply-1’
[13:20:07.122] Expression:
[13:20:07.122] {
[13:20:07.122]     do.call(function(...) {
[13:20:07.122]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.122]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.122]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.122]             on.exit(options(oopts), add = TRUE)
[13:20:07.122]         }
[13:20:07.122]         {
[13:20:07.122]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.122]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.122]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.122]             })
[13:20:07.122]         }
[13:20:07.122]     }, args = future.call.arguments)
[13:20:07.122] }
[13:20:07.122] Lazy evaluation: FALSE
[13:20:07.122] Asynchronous evaluation: TRUE
[13:20:07.122] Local evaluation: TRUE
[13:20:07.122] Environment: R_GlobalEnv
[13:20:07.122] Capture standard output: TRUE
[13:20:07.122] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:07.122] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:07.122] Packages: <none>
[13:20:07.122] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:07.122] Resolved: FALSE
[13:20:07.122] Value: <not collected>
[13:20:07.122] Conditions captured: <none>
[13:20:07.122] Early signaling: FALSE
[13:20:07.122] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:07.122] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.134] Chunk #1 of 2 ... DONE
[13:20:07.134] Chunk #2 of 2 ...
[13:20:07.134]  - Finding globals in 'X' for chunk #2 ...
[13:20:07.134] getGlobalsAndPackages() ...
[13:20:07.135] Searching for globals...
[13:20:07.135] 
[13:20:07.135] Searching for globals ... DONE
[13:20:07.135] - globals: [0] <none>
[13:20:07.135] getGlobalsAndPackages() ... DONE
[13:20:07.135]    + additional globals found: [n=0] 
[13:20:07.135]    + additional namespaces needed: [n=0] 
[13:20:07.136]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:07.136]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:07.136]  - seeds: <none>
[13:20:07.136]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.136] getGlobalsAndPackages() ...
[13:20:07.136] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.136] Resolving globals: FALSE
[13:20:07.136] Tweak future expression to call with '...' arguments ...
[13:20:07.137] {
[13:20:07.137]     do.call(function(...) {
[13:20:07.137]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.137]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.137]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.137]             on.exit(options(oopts), add = TRUE)
[13:20:07.137]         }
[13:20:07.137]         {
[13:20:07.137]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.137]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.137]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.137]             })
[13:20:07.137]         }
[13:20:07.137]     }, args = future.call.arguments)
[13:20:07.137] }
[13:20:07.137] Tweak future expression to call with '...' arguments ... DONE
[13:20:07.137] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.137] 
[13:20:07.138] getGlobalsAndPackages() ... DONE
[13:20:07.138] run() for ‘Future’ ...
[13:20:07.138] - state: ‘created’
[13:20:07.138] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:07.153] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.153] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:07.153]   - Field: ‘node’
[13:20:07.154]   - Field: ‘label’
[13:20:07.154]   - Field: ‘local’
[13:20:07.154]   - Field: ‘owner’
[13:20:07.154]   - Field: ‘envir’
[13:20:07.154]   - Field: ‘workers’
[13:20:07.154]   - Field: ‘packages’
[13:20:07.154]   - Field: ‘gc’
[13:20:07.154]   - Field: ‘conditions’
[13:20:07.155]   - Field: ‘persistent’
[13:20:07.155]   - Field: ‘expr’
[13:20:07.155]   - Field: ‘uuid’
[13:20:07.155]   - Field: ‘seed’
[13:20:07.155]   - Field: ‘version’
[13:20:07.155]   - Field: ‘result’
[13:20:07.155]   - Field: ‘asynchronous’
[13:20:07.156]   - Field: ‘calls’
[13:20:07.156]   - Field: ‘globals’
[13:20:07.156]   - Field: ‘stdout’
[13:20:07.156]   - Field: ‘earlySignal’
[13:20:07.156]   - Field: ‘lazy’
[13:20:07.156]   - Field: ‘state’
[13:20:07.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:07.157] - Launch lazy future ...
[13:20:07.157] Packages needed by the future expression (n = 0): <none>
[13:20:07.157] Packages needed by future strategies (n = 0): <none>
[13:20:07.158] {
[13:20:07.158]     {
[13:20:07.158]         {
[13:20:07.158]             ...future.startTime <- base::Sys.time()
[13:20:07.158]             {
[13:20:07.158]                 {
[13:20:07.158]                   {
[13:20:07.158]                     {
[13:20:07.158]                       base::local({
[13:20:07.158]                         has_future <- base::requireNamespace("future", 
[13:20:07.158]                           quietly = TRUE)
[13:20:07.158]                         if (has_future) {
[13:20:07.158]                           ns <- base::getNamespace("future")
[13:20:07.158]                           version <- ns[[".package"]][["version"]]
[13:20:07.158]                           if (is.null(version)) 
[13:20:07.158]                             version <- utils::packageVersion("future")
[13:20:07.158]                         }
[13:20:07.158]                         else {
[13:20:07.158]                           version <- NULL
[13:20:07.158]                         }
[13:20:07.158]                         if (!has_future || version < "1.8.0") {
[13:20:07.158]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:07.158]                             "", base::R.version$version.string), 
[13:20:07.158]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:07.158]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:07.158]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:07.158]                               "release", "version")], collapse = " "), 
[13:20:07.158]                             hostname = base::Sys.info()[["nodename"]])
[13:20:07.158]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:07.158]                             info)
[13:20:07.158]                           info <- base::paste(info, collapse = "; ")
[13:20:07.158]                           if (!has_future) {
[13:20:07.158]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:07.158]                               info)
[13:20:07.158]                           }
[13:20:07.158]                           else {
[13:20:07.158]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:07.158]                               info, version)
[13:20:07.158]                           }
[13:20:07.158]                           base::stop(msg)
[13:20:07.158]                         }
[13:20:07.158]                       })
[13:20:07.158]                     }
[13:20:07.158]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:07.158]                     base::options(mc.cores = 1L)
[13:20:07.158]                   }
[13:20:07.158]                   options(future.plan = NULL)
[13:20:07.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:07.158]                 }
[13:20:07.158]                 ...future.workdir <- getwd()
[13:20:07.158]             }
[13:20:07.158]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:07.158]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:07.158]         }
[13:20:07.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:07.158]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:07.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:07.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:07.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:07.158]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:07.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:07.158]             base::names(...future.oldOptions))
[13:20:07.158]     }
[13:20:07.158]     if (FALSE) {
[13:20:07.158]     }
[13:20:07.158]     else {
[13:20:07.158]         if (TRUE) {
[13:20:07.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:07.158]                 open = "w")
[13:20:07.158]         }
[13:20:07.158]         else {
[13:20:07.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:07.158]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:07.158]         }
[13:20:07.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:07.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:07.158]             base::sink(type = "output", split = FALSE)
[13:20:07.158]             base::close(...future.stdout)
[13:20:07.158]         }, add = TRUE)
[13:20:07.158]     }
[13:20:07.158]     ...future.frame <- base::sys.nframe()
[13:20:07.158]     ...future.conditions <- base::list()
[13:20:07.158]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:07.158]     if (FALSE) {
[13:20:07.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:07.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:07.158]     }
[13:20:07.158]     ...future.result <- base::tryCatch({
[13:20:07.158]         base::withCallingHandlers({
[13:20:07.158]             ...future.value <- base::withVisible(base::local({
[13:20:07.158]                 ...future.makeSendCondition <- base::local({
[13:20:07.158]                   sendCondition <- NULL
[13:20:07.158]                   function(frame = 1L) {
[13:20:07.158]                     if (is.function(sendCondition)) 
[13:20:07.158]                       return(sendCondition)
[13:20:07.158]                     ns <- getNamespace("parallel")
[13:20:07.158]                     if (exists("sendData", mode = "function", 
[13:20:07.158]                       envir = ns)) {
[13:20:07.158]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:07.158]                         envir = ns)
[13:20:07.158]                       envir <- sys.frame(frame)
[13:20:07.158]                       master <- NULL
[13:20:07.158]                       while (!identical(envir, .GlobalEnv) && 
[13:20:07.158]                         !identical(envir, emptyenv())) {
[13:20:07.158]                         if (exists("master", mode = "list", envir = envir, 
[13:20:07.158]                           inherits = FALSE)) {
[13:20:07.158]                           master <- get("master", mode = "list", 
[13:20:07.158]                             envir = envir, inherits = FALSE)
[13:20:07.158]                           if (inherits(master, c("SOCKnode", 
[13:20:07.158]                             "SOCK0node"))) {
[13:20:07.158]                             sendCondition <<- function(cond) {
[13:20:07.158]                               data <- list(type = "VALUE", value = cond, 
[13:20:07.158]                                 success = TRUE)
[13:20:07.158]                               parallel_sendData(master, data)
[13:20:07.158]                             }
[13:20:07.158]                             return(sendCondition)
[13:20:07.158]                           }
[13:20:07.158]                         }
[13:20:07.158]                         frame <- frame + 1L
[13:20:07.158]                         envir <- sys.frame(frame)
[13:20:07.158]                       }
[13:20:07.158]                     }
[13:20:07.158]                     sendCondition <<- function(cond) NULL
[13:20:07.158]                   }
[13:20:07.158]                 })
[13:20:07.158]                 withCallingHandlers({
[13:20:07.158]                   {
[13:20:07.158]                     do.call(function(...) {
[13:20:07.158]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.158]                       if (!identical(...future.globals.maxSize.org, 
[13:20:07.158]                         ...future.globals.maxSize)) {
[13:20:07.158]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.158]                         on.exit(options(oopts), add = TRUE)
[13:20:07.158]                       }
[13:20:07.158]                       {
[13:20:07.158]                         lapply(seq_along(...future.elements_ii), 
[13:20:07.158]                           FUN = function(jj) {
[13:20:07.158]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.158]                             ...future.FUN(...future.X_jj, ...)
[13:20:07.158]                           })
[13:20:07.158]                       }
[13:20:07.158]                     }, args = future.call.arguments)
[13:20:07.158]                   }
[13:20:07.158]                 }, immediateCondition = function(cond) {
[13:20:07.158]                   sendCondition <- ...future.makeSendCondition()
[13:20:07.158]                   sendCondition(cond)
[13:20:07.158]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.158]                   {
[13:20:07.158]                     inherits <- base::inherits
[13:20:07.158]                     invokeRestart <- base::invokeRestart
[13:20:07.158]                     is.null <- base::is.null
[13:20:07.158]                     muffled <- FALSE
[13:20:07.158]                     if (inherits(cond, "message")) {
[13:20:07.158]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:07.158]                       if (muffled) 
[13:20:07.158]                         invokeRestart("muffleMessage")
[13:20:07.158]                     }
[13:20:07.158]                     else if (inherits(cond, "warning")) {
[13:20:07.158]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:07.158]                       if (muffled) 
[13:20:07.158]                         invokeRestart("muffleWarning")
[13:20:07.158]                     }
[13:20:07.158]                     else if (inherits(cond, "condition")) {
[13:20:07.158]                       if (!is.null(pattern)) {
[13:20:07.158]                         computeRestarts <- base::computeRestarts
[13:20:07.158]                         grepl <- base::grepl
[13:20:07.158]                         restarts <- computeRestarts(cond)
[13:20:07.158]                         for (restart in restarts) {
[13:20:07.158]                           name <- restart$name
[13:20:07.158]                           if (is.null(name)) 
[13:20:07.158]                             next
[13:20:07.158]                           if (!grepl(pattern, name)) 
[13:20:07.158]                             next
[13:20:07.158]                           invokeRestart(restart)
[13:20:07.158]                           muffled <- TRUE
[13:20:07.158]                           break
[13:20:07.158]                         }
[13:20:07.158]                       }
[13:20:07.158]                     }
[13:20:07.158]                     invisible(muffled)
[13:20:07.158]                   }
[13:20:07.158]                   muffleCondition(cond)
[13:20:07.158]                 })
[13:20:07.158]             }))
[13:20:07.158]             future::FutureResult(value = ...future.value$value, 
[13:20:07.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.158]                   ...future.rng), globalenv = if (FALSE) 
[13:20:07.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:07.158]                     ...future.globalenv.names))
[13:20:07.158]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:07.158]         }, condition = base::local({
[13:20:07.158]             c <- base::c
[13:20:07.158]             inherits <- base::inherits
[13:20:07.158]             invokeRestart <- base::invokeRestart
[13:20:07.158]             length <- base::length
[13:20:07.158]             list <- base::list
[13:20:07.158]             seq.int <- base::seq.int
[13:20:07.158]             signalCondition <- base::signalCondition
[13:20:07.158]             sys.calls <- base::sys.calls
[13:20:07.158]             `[[` <- base::`[[`
[13:20:07.158]             `+` <- base::`+`
[13:20:07.158]             `<<-` <- base::`<<-`
[13:20:07.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:07.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:07.158]                   3L)]
[13:20:07.158]             }
[13:20:07.158]             function(cond) {
[13:20:07.158]                 is_error <- inherits(cond, "error")
[13:20:07.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:07.158]                   NULL)
[13:20:07.158]                 if (is_error) {
[13:20:07.158]                   sessionInformation <- function() {
[13:20:07.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:07.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:07.158]                       search = base::search(), system = base::Sys.info())
[13:20:07.158]                   }
[13:20:07.158]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:07.158]                     cond$call), session = sessionInformation(), 
[13:20:07.158]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:07.158]                   signalCondition(cond)
[13:20:07.158]                 }
[13:20:07.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:07.158]                 "immediateCondition"))) {
[13:20:07.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:07.158]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:07.158]                   if (TRUE && !signal) {
[13:20:07.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.158]                     {
[13:20:07.158]                       inherits <- base::inherits
[13:20:07.158]                       invokeRestart <- base::invokeRestart
[13:20:07.158]                       is.null <- base::is.null
[13:20:07.158]                       muffled <- FALSE
[13:20:07.158]                       if (inherits(cond, "message")) {
[13:20:07.158]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.158]                         if (muffled) 
[13:20:07.158]                           invokeRestart("muffleMessage")
[13:20:07.158]                       }
[13:20:07.158]                       else if (inherits(cond, "warning")) {
[13:20:07.158]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.158]                         if (muffled) 
[13:20:07.158]                           invokeRestart("muffleWarning")
[13:20:07.158]                       }
[13:20:07.158]                       else if (inherits(cond, "condition")) {
[13:20:07.158]                         if (!is.null(pattern)) {
[13:20:07.158]                           computeRestarts <- base::computeRestarts
[13:20:07.158]                           grepl <- base::grepl
[13:20:07.158]                           restarts <- computeRestarts(cond)
[13:20:07.158]                           for (restart in restarts) {
[13:20:07.158]                             name <- restart$name
[13:20:07.158]                             if (is.null(name)) 
[13:20:07.158]                               next
[13:20:07.158]                             if (!grepl(pattern, name)) 
[13:20:07.158]                               next
[13:20:07.158]                             invokeRestart(restart)
[13:20:07.158]                             muffled <- TRUE
[13:20:07.158]                             break
[13:20:07.158]                           }
[13:20:07.158]                         }
[13:20:07.158]                       }
[13:20:07.158]                       invisible(muffled)
[13:20:07.158]                     }
[13:20:07.158]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.158]                   }
[13:20:07.158]                 }
[13:20:07.158]                 else {
[13:20:07.158]                   if (TRUE) {
[13:20:07.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.158]                     {
[13:20:07.158]                       inherits <- base::inherits
[13:20:07.158]                       invokeRestart <- base::invokeRestart
[13:20:07.158]                       is.null <- base::is.null
[13:20:07.158]                       muffled <- FALSE
[13:20:07.158]                       if (inherits(cond, "message")) {
[13:20:07.158]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.158]                         if (muffled) 
[13:20:07.158]                           invokeRestart("muffleMessage")
[13:20:07.158]                       }
[13:20:07.158]                       else if (inherits(cond, "warning")) {
[13:20:07.158]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.158]                         if (muffled) 
[13:20:07.158]                           invokeRestart("muffleWarning")
[13:20:07.158]                       }
[13:20:07.158]                       else if (inherits(cond, "condition")) {
[13:20:07.158]                         if (!is.null(pattern)) {
[13:20:07.158]                           computeRestarts <- base::computeRestarts
[13:20:07.158]                           grepl <- base::grepl
[13:20:07.158]                           restarts <- computeRestarts(cond)
[13:20:07.158]                           for (restart in restarts) {
[13:20:07.158]                             name <- restart$name
[13:20:07.158]                             if (is.null(name)) 
[13:20:07.158]                               next
[13:20:07.158]                             if (!grepl(pattern, name)) 
[13:20:07.158]                               next
[13:20:07.158]                             invokeRestart(restart)
[13:20:07.158]                             muffled <- TRUE
[13:20:07.158]                             break
[13:20:07.158]                           }
[13:20:07.158]                         }
[13:20:07.158]                       }
[13:20:07.158]                       invisible(muffled)
[13:20:07.158]                     }
[13:20:07.158]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.158]                   }
[13:20:07.158]                 }
[13:20:07.158]             }
[13:20:07.158]         }))
[13:20:07.158]     }, error = function(ex) {
[13:20:07.158]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:07.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.158]                 ...future.rng), started = ...future.startTime, 
[13:20:07.158]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:07.158]             version = "1.8"), class = "FutureResult")
[13:20:07.158]     }, finally = {
[13:20:07.158]         if (!identical(...future.workdir, getwd())) 
[13:20:07.158]             setwd(...future.workdir)
[13:20:07.158]         {
[13:20:07.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:07.158]                 ...future.oldOptions$nwarnings <- NULL
[13:20:07.158]             }
[13:20:07.158]             base::options(...future.oldOptions)
[13:20:07.158]             if (.Platform$OS.type == "windows") {
[13:20:07.158]                 old_names <- names(...future.oldEnvVars)
[13:20:07.158]                 envs <- base::Sys.getenv()
[13:20:07.158]                 names <- names(envs)
[13:20:07.158]                 common <- intersect(names, old_names)
[13:20:07.158]                 added <- setdiff(names, old_names)
[13:20:07.158]                 removed <- setdiff(old_names, names)
[13:20:07.158]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:07.158]                   envs[common]]
[13:20:07.158]                 NAMES <- toupper(changed)
[13:20:07.158]                 args <- list()
[13:20:07.158]                 for (kk in seq_along(NAMES)) {
[13:20:07.158]                   name <- changed[[kk]]
[13:20:07.158]                   NAME <- NAMES[[kk]]
[13:20:07.158]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.158]                     next
[13:20:07.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.158]                 }
[13:20:07.158]                 NAMES <- toupper(added)
[13:20:07.158]                 for (kk in seq_along(NAMES)) {
[13:20:07.158]                   name <- added[[kk]]
[13:20:07.158]                   NAME <- NAMES[[kk]]
[13:20:07.158]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.158]                     next
[13:20:07.158]                   args[[name]] <- ""
[13:20:07.158]                 }
[13:20:07.158]                 NAMES <- toupper(removed)
[13:20:07.158]                 for (kk in seq_along(NAMES)) {
[13:20:07.158]                   name <- removed[[kk]]
[13:20:07.158]                   NAME <- NAMES[[kk]]
[13:20:07.158]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.158]                     next
[13:20:07.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.158]                 }
[13:20:07.158]                 if (length(args) > 0) 
[13:20:07.158]                   base::do.call(base::Sys.setenv, args = args)
[13:20:07.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:07.158]             }
[13:20:07.158]             else {
[13:20:07.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:07.158]             }
[13:20:07.158]             {
[13:20:07.158]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:07.158]                   0L) {
[13:20:07.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:07.158]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:07.158]                   base::options(opts)
[13:20:07.158]                 }
[13:20:07.158]                 {
[13:20:07.158]                   {
[13:20:07.158]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:07.158]                     NULL
[13:20:07.158]                   }
[13:20:07.158]                   options(future.plan = NULL)
[13:20:07.158]                   if (is.na(NA_character_)) 
[13:20:07.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:07.158]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:07.158]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:07.158]                     envir = parent.frame()) 
[13:20:07.158]                   {
[13:20:07.158]                     if (is.function(workers)) 
[13:20:07.158]                       workers <- workers()
[13:20:07.158]                     workers <- structure(as.integer(workers), 
[13:20:07.158]                       class = class(workers))
[13:20:07.158]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:07.158]                       workers >= 1)
[13:20:07.158]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:07.158]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:07.158]                     }
[13:20:07.158]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:07.158]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:07.158]                       envir = envir)
[13:20:07.158]                     if (!future$lazy) 
[13:20:07.158]                       future <- run(future)
[13:20:07.158]                     invisible(future)
[13:20:07.158]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:07.158]                 }
[13:20:07.158]             }
[13:20:07.158]         }
[13:20:07.158]     })
[13:20:07.158]     if (TRUE) {
[13:20:07.158]         base::sink(type = "output", split = FALSE)
[13:20:07.158]         if (TRUE) {
[13:20:07.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:07.158]         }
[13:20:07.158]         else {
[13:20:07.158]             ...future.result["stdout"] <- base::list(NULL)
[13:20:07.158]         }
[13:20:07.158]         base::close(...future.stdout)
[13:20:07.158]         ...future.stdout <- NULL
[13:20:07.158]     }
[13:20:07.158]     ...future.result$conditions <- ...future.conditions
[13:20:07.158]     ...future.result$finished <- base::Sys.time()
[13:20:07.158]     ...future.result
[13:20:07.158] }
[13:20:07.236] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:20:07.237] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:20:07.237] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:20:07.238] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:07.238] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:07.238] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:20:07.238] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:20:07.239] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:07.239] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:07.239] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:20:07.239] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:20:07.240] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:20:07.240] MultisessionFuture started
[13:20:07.240] - Launch lazy future ... done
[13:20:07.241] run() for ‘MultisessionFuture’ ... done
[13:20:07.241] Created future:
[13:20:07.241] MultisessionFuture:
[13:20:07.241] Label: ‘future_eapply-2’
[13:20:07.241] Expression:
[13:20:07.241] {
[13:20:07.241]     do.call(function(...) {
[13:20:07.241]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.241]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.241]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.241]             on.exit(options(oopts), add = TRUE)
[13:20:07.241]         }
[13:20:07.241]         {
[13:20:07.241]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.241]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.241]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.241]             })
[13:20:07.241]         }
[13:20:07.241]     }, args = future.call.arguments)
[13:20:07.241] }
[13:20:07.241] Lazy evaluation: FALSE
[13:20:07.241] Asynchronous evaluation: TRUE
[13:20:07.241] Local evaluation: TRUE
[13:20:07.241] Environment: R_GlobalEnv
[13:20:07.241] Capture standard output: TRUE
[13:20:07.241] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:07.241] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:07.241] Packages: <none>
[13:20:07.241] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:07.241] Resolved: FALSE
[13:20:07.241] Value: <not collected>
[13:20:07.241] Conditions captured: <none>
[13:20:07.241] Early signaling: FALSE
[13:20:07.241] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:07.241] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.253] Chunk #2 of 2 ... DONE
[13:20:07.253] Launching 2 futures (chunks) ... DONE
[13:20:07.253] Resolving 2 futures (chunks) ...
[13:20:07.253] resolve() on list ...
[13:20:07.253]  recursive: 0
[13:20:07.253]  length: 2
[13:20:07.253] 
[13:20:07.254] receiveMessageFromWorker() for ClusterFuture ...
[13:20:07.254] - Validating connection of MultisessionFuture
[13:20:07.254] - received message: FutureResult
[13:20:07.255] - Received FutureResult
[13:20:07.255] - Erased future from FutureRegistry
[13:20:07.255] result() for ClusterFuture ...
[13:20:07.255] - result already collected: FutureResult
[13:20:07.255] result() for ClusterFuture ... done
[13:20:07.255] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:07.255] Future #1
[13:20:07.260] result() for ClusterFuture ...
[13:20:07.260] - result already collected: FutureResult
[13:20:07.260] result() for ClusterFuture ... done
[13:20:07.260] result() for ClusterFuture ...
[13:20:07.260] - result already collected: FutureResult
[13:20:07.260] result() for ClusterFuture ... done
[13:20:07.260] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:07.260] - nx: 2
[13:20:07.260] - relay: TRUE
[13:20:07.261] - stdout: TRUE
[13:20:07.261] - signal: TRUE
[13:20:07.261] - resignal: FALSE
[13:20:07.261] - force: TRUE
[13:20:07.261] - relayed: [n=2] FALSE, FALSE
[13:20:07.261] - queued futures: [n=2] FALSE, FALSE
[13:20:07.261]  - until=1
[13:20:07.261]  - relaying element #1
[13:20:07.261] result() for ClusterFuture ...
[13:20:07.261] - result already collected: FutureResult
[13:20:07.261] result() for ClusterFuture ... done
[13:20:07.261] result() for ClusterFuture ...
[13:20:07.262] - result already collected: FutureResult
[13:20:07.262] result() for ClusterFuture ... done
[13:20:07.262] result() for ClusterFuture ...
[13:20:07.262] - result already collected: FutureResult
[13:20:07.262] result() for ClusterFuture ... done
[13:20:07.262] result() for ClusterFuture ...
[13:20:07.262] - result already collected: FutureResult
[13:20:07.262] result() for ClusterFuture ... done
[13:20:07.262] - relayed: [n=2] TRUE, FALSE
[13:20:07.262] - queued futures: [n=2] TRUE, FALSE
[13:20:07.262] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:07.263]  length: 1 (resolved future 1)
[13:20:07.331] receiveMessageFromWorker() for ClusterFuture ...
[13:20:07.331] - Validating connection of MultisessionFuture
[13:20:07.331] - received message: FutureResult
[13:20:07.331] - Received FutureResult
[13:20:07.331] - Erased future from FutureRegistry
[13:20:07.332] result() for ClusterFuture ...
[13:20:07.332] - result already collected: FutureResult
[13:20:07.332] result() for ClusterFuture ... done
[13:20:07.332] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:07.332] Future #2
[13:20:07.332] result() for ClusterFuture ...
[13:20:07.332] - result already collected: FutureResult
[13:20:07.332] result() for ClusterFuture ... done
[13:20:07.332] result() for ClusterFuture ...
[13:20:07.332] - result already collected: FutureResult
[13:20:07.333] result() for ClusterFuture ... done
[13:20:07.333] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:07.333] - nx: 2
[13:20:07.333] - relay: TRUE
[13:20:07.333] - stdout: TRUE
[13:20:07.333] - signal: TRUE
[13:20:07.333] - resignal: FALSE
[13:20:07.333] - force: TRUE
[13:20:07.333] - relayed: [n=2] TRUE, FALSE
[13:20:07.333] - queued futures: [n=2] TRUE, FALSE
[13:20:07.333]  - until=2
[13:20:07.334]  - relaying element #2
[13:20:07.334] result() for ClusterFuture ...
[13:20:07.334] - result already collected: FutureResult
[13:20:07.334] result() for ClusterFuture ... done
[13:20:07.334] result() for ClusterFuture ...
[13:20:07.334] - result already collected: FutureResult
[13:20:07.334] result() for ClusterFuture ... done
[13:20:07.334] result() for ClusterFuture ...
[13:20:07.334] - result already collected: FutureResult
[13:20:07.334] result() for ClusterFuture ... done
[13:20:07.334] result() for ClusterFuture ...
[13:20:07.335] - result already collected: FutureResult
[13:20:07.335] result() for ClusterFuture ... done
[13:20:07.335] - relayed: [n=2] TRUE, TRUE
[13:20:07.335] - queued futures: [n=2] TRUE, TRUE
[13:20:07.335] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:07.335]  length: 0 (resolved future 2)
[13:20:07.335] Relaying remaining futures
[13:20:07.335] signalConditionsASAP(NULL, pos=0) ...
[13:20:07.335] - nx: 2
[13:20:07.335] - relay: TRUE
[13:20:07.335] - stdout: TRUE
[13:20:07.335] - signal: TRUE
[13:20:07.336] - resignal: FALSE
[13:20:07.336] - force: TRUE
[13:20:07.336] - relayed: [n=2] TRUE, TRUE
[13:20:07.336] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:07.336] - relayed: [n=2] TRUE, TRUE
[13:20:07.336] - queued futures: [n=2] TRUE, TRUE
[13:20:07.336] signalConditionsASAP(NULL, pos=0) ... done
[13:20:07.336] resolve() on list ... DONE
[13:20:07.336] result() for ClusterFuture ...
[13:20:07.336] - result already collected: FutureResult
[13:20:07.337] result() for ClusterFuture ... done
[13:20:07.337] result() for ClusterFuture ...
[13:20:07.337] - result already collected: FutureResult
[13:20:07.337] result() for ClusterFuture ... done
[13:20:07.337] result() for ClusterFuture ...
[13:20:07.337] - result already collected: FutureResult
[13:20:07.337] result() for ClusterFuture ... done
[13:20:07.337] result() for ClusterFuture ...
[13:20:07.337] - result already collected: FutureResult
[13:20:07.337] result() for ClusterFuture ... done
[13:20:07.337]  - Number of value chunks collected: 2
[13:20:07.338] Resolving 2 futures (chunks) ... DONE
[13:20:07.338] Reducing values from 2 chunks ...
[13:20:07.338]  - Number of values collected after concatenation: 3
[13:20:07.338]  - Number of values expected: 3
[13:20:07.338] Reducing values from 2 chunks ... DONE
[13:20:07.338] future_lapply() ... DONE
[13:20:07.339] future_lapply() ...
[13:20:07.343] Number of chunks: 2
[13:20:07.343] getGlobalsAndPackagesXApply() ...
[13:20:07.343]  - future.globals: TRUE
[13:20:07.343] getGlobalsAndPackages() ...
[13:20:07.343] Searching for globals...
[13:20:07.344] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:07.344] Searching for globals ... DONE
[13:20:07.344] Resolving globals: FALSE
[13:20:07.345] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:20:07.345] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:20:07.345] - globals: [1] ‘FUN’
[13:20:07.345] - packages: [1] ‘stats’
[13:20:07.345] getGlobalsAndPackages() ... DONE
[13:20:07.346]  - globals found/used: [n=1] ‘FUN’
[13:20:07.346]  - needed namespaces: [n=1] ‘stats’
[13:20:07.346] Finding globals ... DONE
[13:20:07.346]  - use_args: TRUE
[13:20:07.346]  - Getting '...' globals ...
[13:20:07.346] resolve() on list ...
[13:20:07.346]  recursive: 0
[13:20:07.346]  length: 1
[13:20:07.347]  elements: ‘...’
[13:20:07.347]  length: 0 (resolved future 1)
[13:20:07.347] resolve() on list ... DONE
[13:20:07.347]    - '...' content: [n=1] ‘probs’
[13:20:07.347] List of 1
[13:20:07.347]  $ ...:List of 1
[13:20:07.347]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:20:07.347]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:07.347]  - attr(*, "where")=List of 1
[13:20:07.347]   ..$ ...:<environment: 0x558fd9342380> 
[13:20:07.347]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:07.347]  - attr(*, "resolved")= logi TRUE
[13:20:07.347]  - attr(*, "total_size")= num NA
[13:20:07.350]  - Getting '...' globals ... DONE
[13:20:07.350] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:07.351] List of 2
[13:20:07.351]  $ ...future.FUN:function (x, ...)  
[13:20:07.351]  $ ...          :List of 1
[13:20:07.351]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:20:07.351]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:07.351]  - attr(*, "where")=List of 2
[13:20:07.351]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:07.351]   ..$ ...          :<environment: 0x558fd9342380> 
[13:20:07.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:07.351]  - attr(*, "resolved")= logi FALSE
[13:20:07.351]  - attr(*, "total_size")= num 1328
[13:20:07.354] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:07.354] getGlobalsAndPackagesXApply() ... DONE
[13:20:07.354] Number of futures (= number of chunks): 2
[13:20:07.354] Launching 2 futures (chunks) ...
[13:20:07.354] Chunk #1 of 2 ...
[13:20:07.355]  - Finding globals in 'X' for chunk #1 ...
[13:20:07.355] getGlobalsAndPackages() ...
[13:20:07.355] Searching for globals...
[13:20:07.355] 
[13:20:07.355] Searching for globals ... DONE
[13:20:07.355] - globals: [0] <none>
[13:20:07.355] getGlobalsAndPackages() ... DONE
[13:20:07.355]    + additional globals found: [n=0] 
[13:20:07.355]    + additional namespaces needed: [n=0] 
[13:20:07.355]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:07.356]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:07.356]  - seeds: <none>
[13:20:07.356]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.356] getGlobalsAndPackages() ...
[13:20:07.356] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.356] Resolving globals: FALSE
[13:20:07.356] Tweak future expression to call with '...' arguments ...
[13:20:07.356] {
[13:20:07.356]     do.call(function(...) {
[13:20:07.356]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.356]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.356]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.356]             on.exit(options(oopts), add = TRUE)
[13:20:07.356]         }
[13:20:07.356]         {
[13:20:07.356]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.356]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.356]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.356]             })
[13:20:07.356]         }
[13:20:07.356]     }, args = future.call.arguments)
[13:20:07.356] }
[13:20:07.357] Tweak future expression to call with '...' arguments ... DONE
[13:20:07.357] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.357] - packages: [1] ‘stats’
[13:20:07.357] getGlobalsAndPackages() ... DONE
[13:20:07.358] run() for ‘Future’ ...
[13:20:07.358] - state: ‘created’
[13:20:07.358] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:07.372] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:07.372]   - Field: ‘node’
[13:20:07.372]   - Field: ‘label’
[13:20:07.373]   - Field: ‘local’
[13:20:07.373]   - Field: ‘owner’
[13:20:07.373]   - Field: ‘envir’
[13:20:07.373]   - Field: ‘workers’
[13:20:07.373]   - Field: ‘packages’
[13:20:07.373]   - Field: ‘gc’
[13:20:07.373]   - Field: ‘conditions’
[13:20:07.373]   - Field: ‘persistent’
[13:20:07.373]   - Field: ‘expr’
[13:20:07.373]   - Field: ‘uuid’
[13:20:07.374]   - Field: ‘seed’
[13:20:07.374]   - Field: ‘version’
[13:20:07.374]   - Field: ‘result’
[13:20:07.374]   - Field: ‘asynchronous’
[13:20:07.374]   - Field: ‘calls’
[13:20:07.374]   - Field: ‘globals’
[13:20:07.374]   - Field: ‘stdout’
[13:20:07.374]   - Field: ‘earlySignal’
[13:20:07.374]   - Field: ‘lazy’
[13:20:07.374]   - Field: ‘state’
[13:20:07.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:07.375] - Launch lazy future ...
[13:20:07.375] Packages needed by the future expression (n = 1): ‘stats’
[13:20:07.375] Packages needed by future strategies (n = 0): <none>
[13:20:07.376] {
[13:20:07.376]     {
[13:20:07.376]         {
[13:20:07.376]             ...future.startTime <- base::Sys.time()
[13:20:07.376]             {
[13:20:07.376]                 {
[13:20:07.376]                   {
[13:20:07.376]                     {
[13:20:07.376]                       {
[13:20:07.376]                         base::local({
[13:20:07.376]                           has_future <- base::requireNamespace("future", 
[13:20:07.376]                             quietly = TRUE)
[13:20:07.376]                           if (has_future) {
[13:20:07.376]                             ns <- base::getNamespace("future")
[13:20:07.376]                             version <- ns[[".package"]][["version"]]
[13:20:07.376]                             if (is.null(version)) 
[13:20:07.376]                               version <- utils::packageVersion("future")
[13:20:07.376]                           }
[13:20:07.376]                           else {
[13:20:07.376]                             version <- NULL
[13:20:07.376]                           }
[13:20:07.376]                           if (!has_future || version < "1.8.0") {
[13:20:07.376]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:07.376]                               "", base::R.version$version.string), 
[13:20:07.376]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:07.376]                                 base::R.version$platform, 8 * 
[13:20:07.376]                                   base::.Machine$sizeof.pointer), 
[13:20:07.376]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:07.376]                                 "release", "version")], collapse = " "), 
[13:20:07.376]                               hostname = base::Sys.info()[["nodename"]])
[13:20:07.376]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:07.376]                               info)
[13:20:07.376]                             info <- base::paste(info, collapse = "; ")
[13:20:07.376]                             if (!has_future) {
[13:20:07.376]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:07.376]                                 info)
[13:20:07.376]                             }
[13:20:07.376]                             else {
[13:20:07.376]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:07.376]                                 info, version)
[13:20:07.376]                             }
[13:20:07.376]                             base::stop(msg)
[13:20:07.376]                           }
[13:20:07.376]                         })
[13:20:07.376]                       }
[13:20:07.376]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:07.376]                       base::options(mc.cores = 1L)
[13:20:07.376]                     }
[13:20:07.376]                     base::local({
[13:20:07.376]                       for (pkg in "stats") {
[13:20:07.376]                         base::loadNamespace(pkg)
[13:20:07.376]                         base::library(pkg, character.only = TRUE)
[13:20:07.376]                       }
[13:20:07.376]                     })
[13:20:07.376]                   }
[13:20:07.376]                   options(future.plan = NULL)
[13:20:07.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:07.376]                 }
[13:20:07.376]                 ...future.workdir <- getwd()
[13:20:07.376]             }
[13:20:07.376]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:07.376]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:07.376]         }
[13:20:07.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:07.376]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:07.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:07.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:07.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:07.376]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:07.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:07.376]             base::names(...future.oldOptions))
[13:20:07.376]     }
[13:20:07.376]     if (FALSE) {
[13:20:07.376]     }
[13:20:07.376]     else {
[13:20:07.376]         if (TRUE) {
[13:20:07.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:07.376]                 open = "w")
[13:20:07.376]         }
[13:20:07.376]         else {
[13:20:07.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:07.376]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:07.376]         }
[13:20:07.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:07.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:07.376]             base::sink(type = "output", split = FALSE)
[13:20:07.376]             base::close(...future.stdout)
[13:20:07.376]         }, add = TRUE)
[13:20:07.376]     }
[13:20:07.376]     ...future.frame <- base::sys.nframe()
[13:20:07.376]     ...future.conditions <- base::list()
[13:20:07.376]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:07.376]     if (FALSE) {
[13:20:07.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:07.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:07.376]     }
[13:20:07.376]     ...future.result <- base::tryCatch({
[13:20:07.376]         base::withCallingHandlers({
[13:20:07.376]             ...future.value <- base::withVisible(base::local({
[13:20:07.376]                 ...future.makeSendCondition <- base::local({
[13:20:07.376]                   sendCondition <- NULL
[13:20:07.376]                   function(frame = 1L) {
[13:20:07.376]                     if (is.function(sendCondition)) 
[13:20:07.376]                       return(sendCondition)
[13:20:07.376]                     ns <- getNamespace("parallel")
[13:20:07.376]                     if (exists("sendData", mode = "function", 
[13:20:07.376]                       envir = ns)) {
[13:20:07.376]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:07.376]                         envir = ns)
[13:20:07.376]                       envir <- sys.frame(frame)
[13:20:07.376]                       master <- NULL
[13:20:07.376]                       while (!identical(envir, .GlobalEnv) && 
[13:20:07.376]                         !identical(envir, emptyenv())) {
[13:20:07.376]                         if (exists("master", mode = "list", envir = envir, 
[13:20:07.376]                           inherits = FALSE)) {
[13:20:07.376]                           master <- get("master", mode = "list", 
[13:20:07.376]                             envir = envir, inherits = FALSE)
[13:20:07.376]                           if (inherits(master, c("SOCKnode", 
[13:20:07.376]                             "SOCK0node"))) {
[13:20:07.376]                             sendCondition <<- function(cond) {
[13:20:07.376]                               data <- list(type = "VALUE", value = cond, 
[13:20:07.376]                                 success = TRUE)
[13:20:07.376]                               parallel_sendData(master, data)
[13:20:07.376]                             }
[13:20:07.376]                             return(sendCondition)
[13:20:07.376]                           }
[13:20:07.376]                         }
[13:20:07.376]                         frame <- frame + 1L
[13:20:07.376]                         envir <- sys.frame(frame)
[13:20:07.376]                       }
[13:20:07.376]                     }
[13:20:07.376]                     sendCondition <<- function(cond) NULL
[13:20:07.376]                   }
[13:20:07.376]                 })
[13:20:07.376]                 withCallingHandlers({
[13:20:07.376]                   {
[13:20:07.376]                     do.call(function(...) {
[13:20:07.376]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.376]                       if (!identical(...future.globals.maxSize.org, 
[13:20:07.376]                         ...future.globals.maxSize)) {
[13:20:07.376]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.376]                         on.exit(options(oopts), add = TRUE)
[13:20:07.376]                       }
[13:20:07.376]                       {
[13:20:07.376]                         lapply(seq_along(...future.elements_ii), 
[13:20:07.376]                           FUN = function(jj) {
[13:20:07.376]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.376]                             ...future.FUN(...future.X_jj, ...)
[13:20:07.376]                           })
[13:20:07.376]                       }
[13:20:07.376]                     }, args = future.call.arguments)
[13:20:07.376]                   }
[13:20:07.376]                 }, immediateCondition = function(cond) {
[13:20:07.376]                   sendCondition <- ...future.makeSendCondition()
[13:20:07.376]                   sendCondition(cond)
[13:20:07.376]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.376]                   {
[13:20:07.376]                     inherits <- base::inherits
[13:20:07.376]                     invokeRestart <- base::invokeRestart
[13:20:07.376]                     is.null <- base::is.null
[13:20:07.376]                     muffled <- FALSE
[13:20:07.376]                     if (inherits(cond, "message")) {
[13:20:07.376]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:07.376]                       if (muffled) 
[13:20:07.376]                         invokeRestart("muffleMessage")
[13:20:07.376]                     }
[13:20:07.376]                     else if (inherits(cond, "warning")) {
[13:20:07.376]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:07.376]                       if (muffled) 
[13:20:07.376]                         invokeRestart("muffleWarning")
[13:20:07.376]                     }
[13:20:07.376]                     else if (inherits(cond, "condition")) {
[13:20:07.376]                       if (!is.null(pattern)) {
[13:20:07.376]                         computeRestarts <- base::computeRestarts
[13:20:07.376]                         grepl <- base::grepl
[13:20:07.376]                         restarts <- computeRestarts(cond)
[13:20:07.376]                         for (restart in restarts) {
[13:20:07.376]                           name <- restart$name
[13:20:07.376]                           if (is.null(name)) 
[13:20:07.376]                             next
[13:20:07.376]                           if (!grepl(pattern, name)) 
[13:20:07.376]                             next
[13:20:07.376]                           invokeRestart(restart)
[13:20:07.376]                           muffled <- TRUE
[13:20:07.376]                           break
[13:20:07.376]                         }
[13:20:07.376]                       }
[13:20:07.376]                     }
[13:20:07.376]                     invisible(muffled)
[13:20:07.376]                   }
[13:20:07.376]                   muffleCondition(cond)
[13:20:07.376]                 })
[13:20:07.376]             }))
[13:20:07.376]             future::FutureResult(value = ...future.value$value, 
[13:20:07.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.376]                   ...future.rng), globalenv = if (FALSE) 
[13:20:07.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:07.376]                     ...future.globalenv.names))
[13:20:07.376]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:07.376]         }, condition = base::local({
[13:20:07.376]             c <- base::c
[13:20:07.376]             inherits <- base::inherits
[13:20:07.376]             invokeRestart <- base::invokeRestart
[13:20:07.376]             length <- base::length
[13:20:07.376]             list <- base::list
[13:20:07.376]             seq.int <- base::seq.int
[13:20:07.376]             signalCondition <- base::signalCondition
[13:20:07.376]             sys.calls <- base::sys.calls
[13:20:07.376]             `[[` <- base::`[[`
[13:20:07.376]             `+` <- base::`+`
[13:20:07.376]             `<<-` <- base::`<<-`
[13:20:07.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:07.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:07.376]                   3L)]
[13:20:07.376]             }
[13:20:07.376]             function(cond) {
[13:20:07.376]                 is_error <- inherits(cond, "error")
[13:20:07.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:07.376]                   NULL)
[13:20:07.376]                 if (is_error) {
[13:20:07.376]                   sessionInformation <- function() {
[13:20:07.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:07.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:07.376]                       search = base::search(), system = base::Sys.info())
[13:20:07.376]                   }
[13:20:07.376]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:07.376]                     cond$call), session = sessionInformation(), 
[13:20:07.376]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:07.376]                   signalCondition(cond)
[13:20:07.376]                 }
[13:20:07.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:07.376]                 "immediateCondition"))) {
[13:20:07.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:07.376]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:07.376]                   if (TRUE && !signal) {
[13:20:07.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.376]                     {
[13:20:07.376]                       inherits <- base::inherits
[13:20:07.376]                       invokeRestart <- base::invokeRestart
[13:20:07.376]                       is.null <- base::is.null
[13:20:07.376]                       muffled <- FALSE
[13:20:07.376]                       if (inherits(cond, "message")) {
[13:20:07.376]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.376]                         if (muffled) 
[13:20:07.376]                           invokeRestart("muffleMessage")
[13:20:07.376]                       }
[13:20:07.376]                       else if (inherits(cond, "warning")) {
[13:20:07.376]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.376]                         if (muffled) 
[13:20:07.376]                           invokeRestart("muffleWarning")
[13:20:07.376]                       }
[13:20:07.376]                       else if (inherits(cond, "condition")) {
[13:20:07.376]                         if (!is.null(pattern)) {
[13:20:07.376]                           computeRestarts <- base::computeRestarts
[13:20:07.376]                           grepl <- base::grepl
[13:20:07.376]                           restarts <- computeRestarts(cond)
[13:20:07.376]                           for (restart in restarts) {
[13:20:07.376]                             name <- restart$name
[13:20:07.376]                             if (is.null(name)) 
[13:20:07.376]                               next
[13:20:07.376]                             if (!grepl(pattern, name)) 
[13:20:07.376]                               next
[13:20:07.376]                             invokeRestart(restart)
[13:20:07.376]                             muffled <- TRUE
[13:20:07.376]                             break
[13:20:07.376]                           }
[13:20:07.376]                         }
[13:20:07.376]                       }
[13:20:07.376]                       invisible(muffled)
[13:20:07.376]                     }
[13:20:07.376]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.376]                   }
[13:20:07.376]                 }
[13:20:07.376]                 else {
[13:20:07.376]                   if (TRUE) {
[13:20:07.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.376]                     {
[13:20:07.376]                       inherits <- base::inherits
[13:20:07.376]                       invokeRestart <- base::invokeRestart
[13:20:07.376]                       is.null <- base::is.null
[13:20:07.376]                       muffled <- FALSE
[13:20:07.376]                       if (inherits(cond, "message")) {
[13:20:07.376]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.376]                         if (muffled) 
[13:20:07.376]                           invokeRestart("muffleMessage")
[13:20:07.376]                       }
[13:20:07.376]                       else if (inherits(cond, "warning")) {
[13:20:07.376]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.376]                         if (muffled) 
[13:20:07.376]                           invokeRestart("muffleWarning")
[13:20:07.376]                       }
[13:20:07.376]                       else if (inherits(cond, "condition")) {
[13:20:07.376]                         if (!is.null(pattern)) {
[13:20:07.376]                           computeRestarts <- base::computeRestarts
[13:20:07.376]                           grepl <- base::grepl
[13:20:07.376]                           restarts <- computeRestarts(cond)
[13:20:07.376]                           for (restart in restarts) {
[13:20:07.376]                             name <- restart$name
[13:20:07.376]                             if (is.null(name)) 
[13:20:07.376]                               next
[13:20:07.376]                             if (!grepl(pattern, name)) 
[13:20:07.376]                               next
[13:20:07.376]                             invokeRestart(restart)
[13:20:07.376]                             muffled <- TRUE
[13:20:07.376]                             break
[13:20:07.376]                           }
[13:20:07.376]                         }
[13:20:07.376]                       }
[13:20:07.376]                       invisible(muffled)
[13:20:07.376]                     }
[13:20:07.376]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.376]                   }
[13:20:07.376]                 }
[13:20:07.376]             }
[13:20:07.376]         }))
[13:20:07.376]     }, error = function(ex) {
[13:20:07.376]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:07.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.376]                 ...future.rng), started = ...future.startTime, 
[13:20:07.376]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:07.376]             version = "1.8"), class = "FutureResult")
[13:20:07.376]     }, finally = {
[13:20:07.376]         if (!identical(...future.workdir, getwd())) 
[13:20:07.376]             setwd(...future.workdir)
[13:20:07.376]         {
[13:20:07.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:07.376]                 ...future.oldOptions$nwarnings <- NULL
[13:20:07.376]             }
[13:20:07.376]             base::options(...future.oldOptions)
[13:20:07.376]             if (.Platform$OS.type == "windows") {
[13:20:07.376]                 old_names <- names(...future.oldEnvVars)
[13:20:07.376]                 envs <- base::Sys.getenv()
[13:20:07.376]                 names <- names(envs)
[13:20:07.376]                 common <- intersect(names, old_names)
[13:20:07.376]                 added <- setdiff(names, old_names)
[13:20:07.376]                 removed <- setdiff(old_names, names)
[13:20:07.376]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:07.376]                   envs[common]]
[13:20:07.376]                 NAMES <- toupper(changed)
[13:20:07.376]                 args <- list()
[13:20:07.376]                 for (kk in seq_along(NAMES)) {
[13:20:07.376]                   name <- changed[[kk]]
[13:20:07.376]                   NAME <- NAMES[[kk]]
[13:20:07.376]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.376]                     next
[13:20:07.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.376]                 }
[13:20:07.376]                 NAMES <- toupper(added)
[13:20:07.376]                 for (kk in seq_along(NAMES)) {
[13:20:07.376]                   name <- added[[kk]]
[13:20:07.376]                   NAME <- NAMES[[kk]]
[13:20:07.376]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.376]                     next
[13:20:07.376]                   args[[name]] <- ""
[13:20:07.376]                 }
[13:20:07.376]                 NAMES <- toupper(removed)
[13:20:07.376]                 for (kk in seq_along(NAMES)) {
[13:20:07.376]                   name <- removed[[kk]]
[13:20:07.376]                   NAME <- NAMES[[kk]]
[13:20:07.376]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.376]                     next
[13:20:07.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.376]                 }
[13:20:07.376]                 if (length(args) > 0) 
[13:20:07.376]                   base::do.call(base::Sys.setenv, args = args)
[13:20:07.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:07.376]             }
[13:20:07.376]             else {
[13:20:07.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:07.376]             }
[13:20:07.376]             {
[13:20:07.376]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:07.376]                   0L) {
[13:20:07.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:07.376]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:07.376]                   base::options(opts)
[13:20:07.376]                 }
[13:20:07.376]                 {
[13:20:07.376]                   {
[13:20:07.376]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:07.376]                     NULL
[13:20:07.376]                   }
[13:20:07.376]                   options(future.plan = NULL)
[13:20:07.376]                   if (is.na(NA_character_)) 
[13:20:07.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:07.376]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:07.376]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:07.376]                     envir = parent.frame()) 
[13:20:07.376]                   {
[13:20:07.376]                     if (is.function(workers)) 
[13:20:07.376]                       workers <- workers()
[13:20:07.376]                     workers <- structure(as.integer(workers), 
[13:20:07.376]                       class = class(workers))
[13:20:07.376]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:07.376]                       workers >= 1)
[13:20:07.376]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:07.376]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:07.376]                     }
[13:20:07.376]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:07.376]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:07.376]                       envir = envir)
[13:20:07.376]                     if (!future$lazy) 
[13:20:07.376]                       future <- run(future)
[13:20:07.376]                     invisible(future)
[13:20:07.376]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:07.376]                 }
[13:20:07.376]             }
[13:20:07.376]         }
[13:20:07.376]     })
[13:20:07.376]     if (TRUE) {
[13:20:07.376]         base::sink(type = "output", split = FALSE)
[13:20:07.376]         if (TRUE) {
[13:20:07.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:07.376]         }
[13:20:07.376]         else {
[13:20:07.376]             ...future.result["stdout"] <- base::list(NULL)
[13:20:07.376]         }
[13:20:07.376]         base::close(...future.stdout)
[13:20:07.376]         ...future.stdout <- NULL
[13:20:07.376]     }
[13:20:07.376]     ...future.result$conditions <- ...future.conditions
[13:20:07.376]     ...future.result$finished <- base::Sys.time()
[13:20:07.376]     ...future.result
[13:20:07.376] }
[13:20:07.379] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[13:20:07.379] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:20:07.379] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:20:07.379] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[13:20:07.380] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[13:20:07.380] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:20:07.380] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:20:07.380] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:07.381] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:07.381] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:20:07.381] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:20:07.381] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[13:20:07.382] MultisessionFuture started
[13:20:07.382] - Launch lazy future ... done
[13:20:07.382] run() for ‘MultisessionFuture’ ... done
[13:20:07.382] Created future:
[13:20:07.382] MultisessionFuture:
[13:20:07.382] Label: ‘future_eapply-1’
[13:20:07.382] Expression:
[13:20:07.382] {
[13:20:07.382]     do.call(function(...) {
[13:20:07.382]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.382]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.382]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.382]             on.exit(options(oopts), add = TRUE)
[13:20:07.382]         }
[13:20:07.382]         {
[13:20:07.382]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.382]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.382]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.382]             })
[13:20:07.382]         }
[13:20:07.382]     }, args = future.call.arguments)
[13:20:07.382] }
[13:20:07.382] Lazy evaluation: FALSE
[13:20:07.382] Asynchronous evaluation: TRUE
[13:20:07.382] Local evaluation: TRUE
[13:20:07.382] Environment: R_GlobalEnv
[13:20:07.382] Capture standard output: TRUE
[13:20:07.382] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:07.382] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:07.382] Packages: 1 packages (‘stats’)
[13:20:07.382] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:07.382] Resolved: FALSE
[13:20:07.382] Value: <not collected>
[13:20:07.382] Conditions captured: <none>
[13:20:07.382] Early signaling: FALSE
[13:20:07.382] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:07.382] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.394] Chunk #1 of 2 ... DONE
[13:20:07.394] Chunk #2 of 2 ...
[13:20:07.394]  - Finding globals in 'X' for chunk #2 ...
[13:20:07.394] getGlobalsAndPackages() ...
[13:20:07.394] Searching for globals...
[13:20:07.395] 
[13:20:07.395] Searching for globals ... DONE
[13:20:07.395] - globals: [0] <none>
[13:20:07.395] getGlobalsAndPackages() ... DONE
[13:20:07.395]    + additional globals found: [n=0] 
[13:20:07.395]    + additional namespaces needed: [n=0] 
[13:20:07.395]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:07.395]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:07.395]  - seeds: <none>
[13:20:07.396]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.396] getGlobalsAndPackages() ...
[13:20:07.396] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.396] Resolving globals: FALSE
[13:20:07.396] Tweak future expression to call with '...' arguments ...
[13:20:07.396] {
[13:20:07.396]     do.call(function(...) {
[13:20:07.396]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.396]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.396]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.396]             on.exit(options(oopts), add = TRUE)
[13:20:07.396]         }
[13:20:07.396]         {
[13:20:07.396]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.396]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.396]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.396]             })
[13:20:07.396]         }
[13:20:07.396]     }, args = future.call.arguments)
[13:20:07.396] }
[13:20:07.396] Tweak future expression to call with '...' arguments ... DONE
[13:20:07.397] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.397] - packages: [1] ‘stats’
[13:20:07.397] getGlobalsAndPackages() ... DONE
[13:20:07.397] run() for ‘Future’ ...
[13:20:07.397] - state: ‘created’
[13:20:07.398] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:07.412] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:07.412]   - Field: ‘node’
[13:20:07.412]   - Field: ‘label’
[13:20:07.413]   - Field: ‘local’
[13:20:07.413]   - Field: ‘owner’
[13:20:07.413]   - Field: ‘envir’
[13:20:07.413]   - Field: ‘workers’
[13:20:07.413]   - Field: ‘packages’
[13:20:07.413]   - Field: ‘gc’
[13:20:07.413]   - Field: ‘conditions’
[13:20:07.413]   - Field: ‘persistent’
[13:20:07.413]   - Field: ‘expr’
[13:20:07.413]   - Field: ‘uuid’
[13:20:07.413]   - Field: ‘seed’
[13:20:07.414]   - Field: ‘version’
[13:20:07.414]   - Field: ‘result’
[13:20:07.414]   - Field: ‘asynchronous’
[13:20:07.414]   - Field: ‘calls’
[13:20:07.414]   - Field: ‘globals’
[13:20:07.414]   - Field: ‘stdout’
[13:20:07.414]   - Field: ‘earlySignal’
[13:20:07.414]   - Field: ‘lazy’
[13:20:07.414]   - Field: ‘state’
[13:20:07.414] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:07.415] - Launch lazy future ...
[13:20:07.415] Packages needed by the future expression (n = 1): ‘stats’
[13:20:07.415] Packages needed by future strategies (n = 0): <none>
[13:20:07.416] {
[13:20:07.416]     {
[13:20:07.416]         {
[13:20:07.416]             ...future.startTime <- base::Sys.time()
[13:20:07.416]             {
[13:20:07.416]                 {
[13:20:07.416]                   {
[13:20:07.416]                     {
[13:20:07.416]                       {
[13:20:07.416]                         base::local({
[13:20:07.416]                           has_future <- base::requireNamespace("future", 
[13:20:07.416]                             quietly = TRUE)
[13:20:07.416]                           if (has_future) {
[13:20:07.416]                             ns <- base::getNamespace("future")
[13:20:07.416]                             version <- ns[[".package"]][["version"]]
[13:20:07.416]                             if (is.null(version)) 
[13:20:07.416]                               version <- utils::packageVersion("future")
[13:20:07.416]                           }
[13:20:07.416]                           else {
[13:20:07.416]                             version <- NULL
[13:20:07.416]                           }
[13:20:07.416]                           if (!has_future || version < "1.8.0") {
[13:20:07.416]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:07.416]                               "", base::R.version$version.string), 
[13:20:07.416]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:07.416]                                 base::R.version$platform, 8 * 
[13:20:07.416]                                   base::.Machine$sizeof.pointer), 
[13:20:07.416]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:07.416]                                 "release", "version")], collapse = " "), 
[13:20:07.416]                               hostname = base::Sys.info()[["nodename"]])
[13:20:07.416]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:07.416]                               info)
[13:20:07.416]                             info <- base::paste(info, collapse = "; ")
[13:20:07.416]                             if (!has_future) {
[13:20:07.416]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:07.416]                                 info)
[13:20:07.416]                             }
[13:20:07.416]                             else {
[13:20:07.416]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:07.416]                                 info, version)
[13:20:07.416]                             }
[13:20:07.416]                             base::stop(msg)
[13:20:07.416]                           }
[13:20:07.416]                         })
[13:20:07.416]                       }
[13:20:07.416]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:07.416]                       base::options(mc.cores = 1L)
[13:20:07.416]                     }
[13:20:07.416]                     base::local({
[13:20:07.416]                       for (pkg in "stats") {
[13:20:07.416]                         base::loadNamespace(pkg)
[13:20:07.416]                         base::library(pkg, character.only = TRUE)
[13:20:07.416]                       }
[13:20:07.416]                     })
[13:20:07.416]                   }
[13:20:07.416]                   options(future.plan = NULL)
[13:20:07.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:07.416]                 }
[13:20:07.416]                 ...future.workdir <- getwd()
[13:20:07.416]             }
[13:20:07.416]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:07.416]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:07.416]         }
[13:20:07.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:07.416]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:07.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:07.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:07.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:07.416]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:07.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:07.416]             base::names(...future.oldOptions))
[13:20:07.416]     }
[13:20:07.416]     if (FALSE) {
[13:20:07.416]     }
[13:20:07.416]     else {
[13:20:07.416]         if (TRUE) {
[13:20:07.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:07.416]                 open = "w")
[13:20:07.416]         }
[13:20:07.416]         else {
[13:20:07.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:07.416]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:07.416]         }
[13:20:07.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:07.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:07.416]             base::sink(type = "output", split = FALSE)
[13:20:07.416]             base::close(...future.stdout)
[13:20:07.416]         }, add = TRUE)
[13:20:07.416]     }
[13:20:07.416]     ...future.frame <- base::sys.nframe()
[13:20:07.416]     ...future.conditions <- base::list()
[13:20:07.416]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:07.416]     if (FALSE) {
[13:20:07.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:07.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:07.416]     }
[13:20:07.416]     ...future.result <- base::tryCatch({
[13:20:07.416]         base::withCallingHandlers({
[13:20:07.416]             ...future.value <- base::withVisible(base::local({
[13:20:07.416]                 ...future.makeSendCondition <- base::local({
[13:20:07.416]                   sendCondition <- NULL
[13:20:07.416]                   function(frame = 1L) {
[13:20:07.416]                     if (is.function(sendCondition)) 
[13:20:07.416]                       return(sendCondition)
[13:20:07.416]                     ns <- getNamespace("parallel")
[13:20:07.416]                     if (exists("sendData", mode = "function", 
[13:20:07.416]                       envir = ns)) {
[13:20:07.416]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:07.416]                         envir = ns)
[13:20:07.416]                       envir <- sys.frame(frame)
[13:20:07.416]                       master <- NULL
[13:20:07.416]                       while (!identical(envir, .GlobalEnv) && 
[13:20:07.416]                         !identical(envir, emptyenv())) {
[13:20:07.416]                         if (exists("master", mode = "list", envir = envir, 
[13:20:07.416]                           inherits = FALSE)) {
[13:20:07.416]                           master <- get("master", mode = "list", 
[13:20:07.416]                             envir = envir, inherits = FALSE)
[13:20:07.416]                           if (inherits(master, c("SOCKnode", 
[13:20:07.416]                             "SOCK0node"))) {
[13:20:07.416]                             sendCondition <<- function(cond) {
[13:20:07.416]                               data <- list(type = "VALUE", value = cond, 
[13:20:07.416]                                 success = TRUE)
[13:20:07.416]                               parallel_sendData(master, data)
[13:20:07.416]                             }
[13:20:07.416]                             return(sendCondition)
[13:20:07.416]                           }
[13:20:07.416]                         }
[13:20:07.416]                         frame <- frame + 1L
[13:20:07.416]                         envir <- sys.frame(frame)
[13:20:07.416]                       }
[13:20:07.416]                     }
[13:20:07.416]                     sendCondition <<- function(cond) NULL
[13:20:07.416]                   }
[13:20:07.416]                 })
[13:20:07.416]                 withCallingHandlers({
[13:20:07.416]                   {
[13:20:07.416]                     do.call(function(...) {
[13:20:07.416]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.416]                       if (!identical(...future.globals.maxSize.org, 
[13:20:07.416]                         ...future.globals.maxSize)) {
[13:20:07.416]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.416]                         on.exit(options(oopts), add = TRUE)
[13:20:07.416]                       }
[13:20:07.416]                       {
[13:20:07.416]                         lapply(seq_along(...future.elements_ii), 
[13:20:07.416]                           FUN = function(jj) {
[13:20:07.416]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.416]                             ...future.FUN(...future.X_jj, ...)
[13:20:07.416]                           })
[13:20:07.416]                       }
[13:20:07.416]                     }, args = future.call.arguments)
[13:20:07.416]                   }
[13:20:07.416]                 }, immediateCondition = function(cond) {
[13:20:07.416]                   sendCondition <- ...future.makeSendCondition()
[13:20:07.416]                   sendCondition(cond)
[13:20:07.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.416]                   {
[13:20:07.416]                     inherits <- base::inherits
[13:20:07.416]                     invokeRestart <- base::invokeRestart
[13:20:07.416]                     is.null <- base::is.null
[13:20:07.416]                     muffled <- FALSE
[13:20:07.416]                     if (inherits(cond, "message")) {
[13:20:07.416]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:07.416]                       if (muffled) 
[13:20:07.416]                         invokeRestart("muffleMessage")
[13:20:07.416]                     }
[13:20:07.416]                     else if (inherits(cond, "warning")) {
[13:20:07.416]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:07.416]                       if (muffled) 
[13:20:07.416]                         invokeRestart("muffleWarning")
[13:20:07.416]                     }
[13:20:07.416]                     else if (inherits(cond, "condition")) {
[13:20:07.416]                       if (!is.null(pattern)) {
[13:20:07.416]                         computeRestarts <- base::computeRestarts
[13:20:07.416]                         grepl <- base::grepl
[13:20:07.416]                         restarts <- computeRestarts(cond)
[13:20:07.416]                         for (restart in restarts) {
[13:20:07.416]                           name <- restart$name
[13:20:07.416]                           if (is.null(name)) 
[13:20:07.416]                             next
[13:20:07.416]                           if (!grepl(pattern, name)) 
[13:20:07.416]                             next
[13:20:07.416]                           invokeRestart(restart)
[13:20:07.416]                           muffled <- TRUE
[13:20:07.416]                           break
[13:20:07.416]                         }
[13:20:07.416]                       }
[13:20:07.416]                     }
[13:20:07.416]                     invisible(muffled)
[13:20:07.416]                   }
[13:20:07.416]                   muffleCondition(cond)
[13:20:07.416]                 })
[13:20:07.416]             }))
[13:20:07.416]             future::FutureResult(value = ...future.value$value, 
[13:20:07.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.416]                   ...future.rng), globalenv = if (FALSE) 
[13:20:07.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:07.416]                     ...future.globalenv.names))
[13:20:07.416]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:07.416]         }, condition = base::local({
[13:20:07.416]             c <- base::c
[13:20:07.416]             inherits <- base::inherits
[13:20:07.416]             invokeRestart <- base::invokeRestart
[13:20:07.416]             length <- base::length
[13:20:07.416]             list <- base::list
[13:20:07.416]             seq.int <- base::seq.int
[13:20:07.416]             signalCondition <- base::signalCondition
[13:20:07.416]             sys.calls <- base::sys.calls
[13:20:07.416]             `[[` <- base::`[[`
[13:20:07.416]             `+` <- base::`+`
[13:20:07.416]             `<<-` <- base::`<<-`
[13:20:07.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:07.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:07.416]                   3L)]
[13:20:07.416]             }
[13:20:07.416]             function(cond) {
[13:20:07.416]                 is_error <- inherits(cond, "error")
[13:20:07.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:07.416]                   NULL)
[13:20:07.416]                 if (is_error) {
[13:20:07.416]                   sessionInformation <- function() {
[13:20:07.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:07.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:07.416]                       search = base::search(), system = base::Sys.info())
[13:20:07.416]                   }
[13:20:07.416]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:07.416]                     cond$call), session = sessionInformation(), 
[13:20:07.416]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:07.416]                   signalCondition(cond)
[13:20:07.416]                 }
[13:20:07.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:07.416]                 "immediateCondition"))) {
[13:20:07.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:07.416]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:07.416]                   if (TRUE && !signal) {
[13:20:07.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.416]                     {
[13:20:07.416]                       inherits <- base::inherits
[13:20:07.416]                       invokeRestart <- base::invokeRestart
[13:20:07.416]                       is.null <- base::is.null
[13:20:07.416]                       muffled <- FALSE
[13:20:07.416]                       if (inherits(cond, "message")) {
[13:20:07.416]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.416]                         if (muffled) 
[13:20:07.416]                           invokeRestart("muffleMessage")
[13:20:07.416]                       }
[13:20:07.416]                       else if (inherits(cond, "warning")) {
[13:20:07.416]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.416]                         if (muffled) 
[13:20:07.416]                           invokeRestart("muffleWarning")
[13:20:07.416]                       }
[13:20:07.416]                       else if (inherits(cond, "condition")) {
[13:20:07.416]                         if (!is.null(pattern)) {
[13:20:07.416]                           computeRestarts <- base::computeRestarts
[13:20:07.416]                           grepl <- base::grepl
[13:20:07.416]                           restarts <- computeRestarts(cond)
[13:20:07.416]                           for (restart in restarts) {
[13:20:07.416]                             name <- restart$name
[13:20:07.416]                             if (is.null(name)) 
[13:20:07.416]                               next
[13:20:07.416]                             if (!grepl(pattern, name)) 
[13:20:07.416]                               next
[13:20:07.416]                             invokeRestart(restart)
[13:20:07.416]                             muffled <- TRUE
[13:20:07.416]                             break
[13:20:07.416]                           }
[13:20:07.416]                         }
[13:20:07.416]                       }
[13:20:07.416]                       invisible(muffled)
[13:20:07.416]                     }
[13:20:07.416]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.416]                   }
[13:20:07.416]                 }
[13:20:07.416]                 else {
[13:20:07.416]                   if (TRUE) {
[13:20:07.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.416]                     {
[13:20:07.416]                       inherits <- base::inherits
[13:20:07.416]                       invokeRestart <- base::invokeRestart
[13:20:07.416]                       is.null <- base::is.null
[13:20:07.416]                       muffled <- FALSE
[13:20:07.416]                       if (inherits(cond, "message")) {
[13:20:07.416]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.416]                         if (muffled) 
[13:20:07.416]                           invokeRestart("muffleMessage")
[13:20:07.416]                       }
[13:20:07.416]                       else if (inherits(cond, "warning")) {
[13:20:07.416]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.416]                         if (muffled) 
[13:20:07.416]                           invokeRestart("muffleWarning")
[13:20:07.416]                       }
[13:20:07.416]                       else if (inherits(cond, "condition")) {
[13:20:07.416]                         if (!is.null(pattern)) {
[13:20:07.416]                           computeRestarts <- base::computeRestarts
[13:20:07.416]                           grepl <- base::grepl
[13:20:07.416]                           restarts <- computeRestarts(cond)
[13:20:07.416]                           for (restart in restarts) {
[13:20:07.416]                             name <- restart$name
[13:20:07.416]                             if (is.null(name)) 
[13:20:07.416]                               next
[13:20:07.416]                             if (!grepl(pattern, name)) 
[13:20:07.416]                               next
[13:20:07.416]                             invokeRestart(restart)
[13:20:07.416]                             muffled <- TRUE
[13:20:07.416]                             break
[13:20:07.416]                           }
[13:20:07.416]                         }
[13:20:07.416]                       }
[13:20:07.416]                       invisible(muffled)
[13:20:07.416]                     }
[13:20:07.416]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.416]                   }
[13:20:07.416]                 }
[13:20:07.416]             }
[13:20:07.416]         }))
[13:20:07.416]     }, error = function(ex) {
[13:20:07.416]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:07.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.416]                 ...future.rng), started = ...future.startTime, 
[13:20:07.416]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:07.416]             version = "1.8"), class = "FutureResult")
[13:20:07.416]     }, finally = {
[13:20:07.416]         if (!identical(...future.workdir, getwd())) 
[13:20:07.416]             setwd(...future.workdir)
[13:20:07.416]         {
[13:20:07.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:07.416]                 ...future.oldOptions$nwarnings <- NULL
[13:20:07.416]             }
[13:20:07.416]             base::options(...future.oldOptions)
[13:20:07.416]             if (.Platform$OS.type == "windows") {
[13:20:07.416]                 old_names <- names(...future.oldEnvVars)
[13:20:07.416]                 envs <- base::Sys.getenv()
[13:20:07.416]                 names <- names(envs)
[13:20:07.416]                 common <- intersect(names, old_names)
[13:20:07.416]                 added <- setdiff(names, old_names)
[13:20:07.416]                 removed <- setdiff(old_names, names)
[13:20:07.416]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:07.416]                   envs[common]]
[13:20:07.416]                 NAMES <- toupper(changed)
[13:20:07.416]                 args <- list()
[13:20:07.416]                 for (kk in seq_along(NAMES)) {
[13:20:07.416]                   name <- changed[[kk]]
[13:20:07.416]                   NAME <- NAMES[[kk]]
[13:20:07.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.416]                     next
[13:20:07.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.416]                 }
[13:20:07.416]                 NAMES <- toupper(added)
[13:20:07.416]                 for (kk in seq_along(NAMES)) {
[13:20:07.416]                   name <- added[[kk]]
[13:20:07.416]                   NAME <- NAMES[[kk]]
[13:20:07.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.416]                     next
[13:20:07.416]                   args[[name]] <- ""
[13:20:07.416]                 }
[13:20:07.416]                 NAMES <- toupper(removed)
[13:20:07.416]                 for (kk in seq_along(NAMES)) {
[13:20:07.416]                   name <- removed[[kk]]
[13:20:07.416]                   NAME <- NAMES[[kk]]
[13:20:07.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.416]                     next
[13:20:07.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.416]                 }
[13:20:07.416]                 if (length(args) > 0) 
[13:20:07.416]                   base::do.call(base::Sys.setenv, args = args)
[13:20:07.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:07.416]             }
[13:20:07.416]             else {
[13:20:07.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:07.416]             }
[13:20:07.416]             {
[13:20:07.416]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:07.416]                   0L) {
[13:20:07.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:07.416]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:07.416]                   base::options(opts)
[13:20:07.416]                 }
[13:20:07.416]                 {
[13:20:07.416]                   {
[13:20:07.416]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:07.416]                     NULL
[13:20:07.416]                   }
[13:20:07.416]                   options(future.plan = NULL)
[13:20:07.416]                   if (is.na(NA_character_)) 
[13:20:07.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:07.416]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:07.416]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:07.416]                     envir = parent.frame()) 
[13:20:07.416]                   {
[13:20:07.416]                     if (is.function(workers)) 
[13:20:07.416]                       workers <- workers()
[13:20:07.416]                     workers <- structure(as.integer(workers), 
[13:20:07.416]                       class = class(workers))
[13:20:07.416]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:07.416]                       workers >= 1)
[13:20:07.416]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:07.416]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:07.416]                     }
[13:20:07.416]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:07.416]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:07.416]                       envir = envir)
[13:20:07.416]                     if (!future$lazy) 
[13:20:07.416]                       future <- run(future)
[13:20:07.416]                     invisible(future)
[13:20:07.416]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:07.416]                 }
[13:20:07.416]             }
[13:20:07.416]         }
[13:20:07.416]     })
[13:20:07.416]     if (TRUE) {
[13:20:07.416]         base::sink(type = "output", split = FALSE)
[13:20:07.416]         if (TRUE) {
[13:20:07.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:07.416]         }
[13:20:07.416]         else {
[13:20:07.416]             ...future.result["stdout"] <- base::list(NULL)
[13:20:07.416]         }
[13:20:07.416]         base::close(...future.stdout)
[13:20:07.416]         ...future.stdout <- NULL
[13:20:07.416]     }
[13:20:07.416]     ...future.result$conditions <- ...future.conditions
[13:20:07.416]     ...future.result$finished <- base::Sys.time()
[13:20:07.416]     ...future.result
[13:20:07.416] }
[13:20:07.419] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[13:20:07.419] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:20:07.419] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:20:07.419] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[13:20:07.420] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[13:20:07.420] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:20:07.420] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:20:07.421] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:07.421] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:07.421] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:20:07.421] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:20:07.422] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[13:20:07.422] MultisessionFuture started
[13:20:07.422] - Launch lazy future ... done
[13:20:07.422] run() for ‘MultisessionFuture’ ... done
[13:20:07.423] Created future:
[13:20:07.423] MultisessionFuture:
[13:20:07.423] Label: ‘future_eapply-2’
[13:20:07.423] Expression:
[13:20:07.423] {
[13:20:07.423]     do.call(function(...) {
[13:20:07.423]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.423]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.423]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.423]             on.exit(options(oopts), add = TRUE)
[13:20:07.423]         }
[13:20:07.423]         {
[13:20:07.423]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.423]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.423]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.423]             })
[13:20:07.423]         }
[13:20:07.423]     }, args = future.call.arguments)
[13:20:07.423] }
[13:20:07.423] Lazy evaluation: FALSE
[13:20:07.423] Asynchronous evaluation: TRUE
[13:20:07.423] Local evaluation: TRUE
[13:20:07.423] Environment: R_GlobalEnv
[13:20:07.423] Capture standard output: TRUE
[13:20:07.423] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:07.423] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:07.423] Packages: 1 packages (‘stats’)
[13:20:07.423] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:07.423] Resolved: FALSE
[13:20:07.423] Value: <not collected>
[13:20:07.423] Conditions captured: <none>
[13:20:07.423] Early signaling: FALSE
[13:20:07.423] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:07.423] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.435] Chunk #2 of 2 ... DONE
[13:20:07.435] Launching 2 futures (chunks) ... DONE
[13:20:07.435] Resolving 2 futures (chunks) ...
[13:20:07.435] resolve() on list ...
[13:20:07.435]  recursive: 0
[13:20:07.435]  length: 2
[13:20:07.435] 
[13:20:07.436] receiveMessageFromWorker() for ClusterFuture ...
[13:20:07.436] - Validating connection of MultisessionFuture
[13:20:07.436] - received message: FutureResult
[13:20:07.436] - Received FutureResult
[13:20:07.437] - Erased future from FutureRegistry
[13:20:07.437] result() for ClusterFuture ...
[13:20:07.437] - result already collected: FutureResult
[13:20:07.437] result() for ClusterFuture ... done
[13:20:07.437] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:07.437] Future #1
[13:20:07.437] result() for ClusterFuture ...
[13:20:07.437] - result already collected: FutureResult
[13:20:07.437] result() for ClusterFuture ... done
[13:20:07.437] result() for ClusterFuture ...
[13:20:07.438] - result already collected: FutureResult
[13:20:07.438] result() for ClusterFuture ... done
[13:20:07.438] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:07.438] - nx: 2
[13:20:07.438] - relay: TRUE
[13:20:07.438] - stdout: TRUE
[13:20:07.438] - signal: TRUE
[13:20:07.438] - resignal: FALSE
[13:20:07.438] - force: TRUE
[13:20:07.438] - relayed: [n=2] FALSE, FALSE
[13:20:07.438] - queued futures: [n=2] FALSE, FALSE
[13:20:07.439]  - until=1
[13:20:07.439]  - relaying element #1
[13:20:07.439] result() for ClusterFuture ...
[13:20:07.439] - result already collected: FutureResult
[13:20:07.439] result() for ClusterFuture ... done
[13:20:07.439] result() for ClusterFuture ...
[13:20:07.439] - result already collected: FutureResult
[13:20:07.439] result() for ClusterFuture ... done
[13:20:07.439] result() for ClusterFuture ...
[13:20:07.439] - result already collected: FutureResult
[13:20:07.439] result() for ClusterFuture ... done
[13:20:07.440] result() for ClusterFuture ...
[13:20:07.440] - result already collected: FutureResult
[13:20:07.440] result() for ClusterFuture ... done
[13:20:07.440] - relayed: [n=2] TRUE, FALSE
[13:20:07.440] - queued futures: [n=2] TRUE, FALSE
[13:20:07.440] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:07.440]  length: 1 (resolved future 1)
[13:20:07.471] receiveMessageFromWorker() for ClusterFuture ...
[13:20:07.471] - Validating connection of MultisessionFuture
[13:20:07.471] - received message: FutureResult
[13:20:07.472] - Received FutureResult
[13:20:07.472] - Erased future from FutureRegistry
[13:20:07.472] result() for ClusterFuture ...
[13:20:07.472] - result already collected: FutureResult
[13:20:07.472] result() for ClusterFuture ... done
[13:20:07.472] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:07.472] Future #2
[13:20:07.472] result() for ClusterFuture ...
[13:20:07.473] - result already collected: FutureResult
[13:20:07.473] result() for ClusterFuture ... done
[13:20:07.473] result() for ClusterFuture ...
[13:20:07.473] - result already collected: FutureResult
[13:20:07.473] result() for ClusterFuture ... done
[13:20:07.473] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:07.473] - nx: 2
[13:20:07.473] - relay: TRUE
[13:20:07.473] - stdout: TRUE
[13:20:07.473] - signal: TRUE
[13:20:07.473] - resignal: FALSE
[13:20:07.474] - force: TRUE
[13:20:07.474] - relayed: [n=2] TRUE, FALSE
[13:20:07.474] - queued futures: [n=2] TRUE, FALSE
[13:20:07.474]  - until=2
[13:20:07.474]  - relaying element #2
[13:20:07.474] result() for ClusterFuture ...
[13:20:07.474] - result already collected: FutureResult
[13:20:07.474] result() for ClusterFuture ... done
[13:20:07.474] result() for ClusterFuture ...
[13:20:07.474] - result already collected: FutureResult
[13:20:07.474] result() for ClusterFuture ... done
[13:20:07.475] result() for ClusterFuture ...
[13:20:07.475] - result already collected: FutureResult
[13:20:07.475] result() for ClusterFuture ... done
[13:20:07.475] result() for ClusterFuture ...
[13:20:07.475] - result already collected: FutureResult
[13:20:07.475] result() for ClusterFuture ... done
[13:20:07.475] - relayed: [n=2] TRUE, TRUE
[13:20:07.475] - queued futures: [n=2] TRUE, TRUE
[13:20:07.475] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:07.475]  length: 0 (resolved future 2)
[13:20:07.475] Relaying remaining futures
[13:20:07.476] signalConditionsASAP(NULL, pos=0) ...
[13:20:07.476] - nx: 2
[13:20:07.476] - relay: TRUE
[13:20:07.476] - stdout: TRUE
[13:20:07.476] - signal: TRUE
[13:20:07.476] - resignal: FALSE
[13:20:07.476] - force: TRUE
[13:20:07.476] - relayed: [n=2] TRUE, TRUE
[13:20:07.476] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:07.476] - relayed: [n=2] TRUE, TRUE
[13:20:07.477] - queued futures: [n=2] TRUE, TRUE
[13:20:07.477] signalConditionsASAP(NULL, pos=0) ... done
[13:20:07.477] resolve() on list ... DONE
[13:20:07.477] result() for ClusterFuture ...
[13:20:07.477] - result already collected: FutureResult
[13:20:07.477] result() for ClusterFuture ... done
[13:20:07.477] result() for ClusterFuture ...
[13:20:07.477] - result already collected: FutureResult
[13:20:07.477] result() for ClusterFuture ... done
[13:20:07.477] result() for ClusterFuture ...
[13:20:07.477] - result already collected: FutureResult
[13:20:07.477] result() for ClusterFuture ... done
[13:20:07.478] result() for ClusterFuture ...
[13:20:07.478] - result already collected: FutureResult
[13:20:07.478] result() for ClusterFuture ... done
[13:20:07.478]  - Number of value chunks collected: 2
[13:20:07.478] Resolving 2 futures (chunks) ... DONE
[13:20:07.478] Reducing values from 2 chunks ...
[13:20:07.478]  - Number of values collected after concatenation: 3
[13:20:07.478]  - Number of values expected: 3
[13:20:07.478] Reducing values from 2 chunks ... DONE
[13:20:07.478] future_lapply() ... DONE
[13:20:07.479] future_lapply() ...
[13:20:07.483] Number of chunks: 2
[13:20:07.484] getGlobalsAndPackagesXApply() ...
[13:20:07.484]  - future.globals: TRUE
[13:20:07.484] getGlobalsAndPackages() ...
[13:20:07.484] Searching for globals...
[13:20:07.485] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:07.485] Searching for globals ... DONE
[13:20:07.485] Resolving globals: FALSE
[13:20:07.486] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:20:07.486] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:20:07.486] - globals: [1] ‘FUN’
[13:20:07.486] - packages: [1] ‘stats’
[13:20:07.486] getGlobalsAndPackages() ... DONE
[13:20:07.486]  - globals found/used: [n=1] ‘FUN’
[13:20:07.486]  - needed namespaces: [n=1] ‘stats’
[13:20:07.487] Finding globals ... DONE
[13:20:07.487]  - use_args: TRUE
[13:20:07.487]  - Getting '...' globals ...
[13:20:07.487] resolve() on list ...
[13:20:07.487]  recursive: 0
[13:20:07.487]  length: 1
[13:20:07.487]  elements: ‘...’
[13:20:07.487]  length: 0 (resolved future 1)
[13:20:07.488] resolve() on list ... DONE
[13:20:07.488]    - '...' content: [n=0] 
[13:20:07.488] List of 1
[13:20:07.488]  $ ...: list()
[13:20:07.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:07.488]  - attr(*, "where")=List of 1
[13:20:07.488]   ..$ ...:<environment: 0x558fdab68df8> 
[13:20:07.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:07.488]  - attr(*, "resolved")= logi TRUE
[13:20:07.488]  - attr(*, "total_size")= num NA
[13:20:07.492]  - Getting '...' globals ... DONE
[13:20:07.493] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:07.493] List of 2
[13:20:07.493]  $ ...future.FUN:function (x, ...)  
[13:20:07.493]  $ ...          : list()
[13:20:07.493]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:07.493]  - attr(*, "where")=List of 2
[13:20:07.493]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:07.493]   ..$ ...          :<environment: 0x558fdab68df8> 
[13:20:07.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:07.493]  - attr(*, "resolved")= logi FALSE
[13:20:07.493]  - attr(*, "total_size")= num 1248
[13:20:07.495] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:07.495] getGlobalsAndPackagesXApply() ... DONE
[13:20:07.496] Number of futures (= number of chunks): 2
[13:20:07.496] Launching 2 futures (chunks) ...
[13:20:07.496] Chunk #1 of 2 ...
[13:20:07.496]  - Finding globals in 'X' for chunk #1 ...
[13:20:07.496] getGlobalsAndPackages() ...
[13:20:07.496] Searching for globals...
[13:20:07.496] 
[13:20:07.496] Searching for globals ... DONE
[13:20:07.497] - globals: [0] <none>
[13:20:07.497] getGlobalsAndPackages() ... DONE
[13:20:07.497]    + additional globals found: [n=0] 
[13:20:07.497]    + additional namespaces needed: [n=0] 
[13:20:07.497]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:07.497]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:07.497]  - seeds: <none>
[13:20:07.497]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.497] getGlobalsAndPackages() ...
[13:20:07.497] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.497] Resolving globals: FALSE
[13:20:07.498] Tweak future expression to call with '...' arguments ...
[13:20:07.498] {
[13:20:07.498]     do.call(function(...) {
[13:20:07.498]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.498]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.498]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.498]             on.exit(options(oopts), add = TRUE)
[13:20:07.498]         }
[13:20:07.498]         {
[13:20:07.498]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.498]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.498]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.498]             })
[13:20:07.498]         }
[13:20:07.498]     }, args = future.call.arguments)
[13:20:07.498] }
[13:20:07.498] Tweak future expression to call with '...' arguments ... DONE
[13:20:07.498] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.498] - packages: [1] ‘stats’
[13:20:07.499] getGlobalsAndPackages() ... DONE
[13:20:07.499] run() for ‘Future’ ...
[13:20:07.499] - state: ‘created’
[13:20:07.499] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:07.513] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:07.513]   - Field: ‘node’
[13:20:07.514]   - Field: ‘label’
[13:20:07.514]   - Field: ‘local’
[13:20:07.514]   - Field: ‘owner’
[13:20:07.514]   - Field: ‘envir’
[13:20:07.514]   - Field: ‘workers’
[13:20:07.514]   - Field: ‘packages’
[13:20:07.514]   - Field: ‘gc’
[13:20:07.514]   - Field: ‘conditions’
[13:20:07.514]   - Field: ‘persistent’
[13:20:07.514]   - Field: ‘expr’
[13:20:07.515]   - Field: ‘uuid’
[13:20:07.515]   - Field: ‘seed’
[13:20:07.515]   - Field: ‘version’
[13:20:07.515]   - Field: ‘result’
[13:20:07.515]   - Field: ‘asynchronous’
[13:20:07.515]   - Field: ‘calls’
[13:20:07.515]   - Field: ‘globals’
[13:20:07.515]   - Field: ‘stdout’
[13:20:07.515]   - Field: ‘earlySignal’
[13:20:07.515]   - Field: ‘lazy’
[13:20:07.515]   - Field: ‘state’
[13:20:07.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:07.516] - Launch lazy future ...
[13:20:07.516] Packages needed by the future expression (n = 1): ‘stats’
[13:20:07.516] Packages needed by future strategies (n = 0): <none>
[13:20:07.517] {
[13:20:07.517]     {
[13:20:07.517]         {
[13:20:07.517]             ...future.startTime <- base::Sys.time()
[13:20:07.517]             {
[13:20:07.517]                 {
[13:20:07.517]                   {
[13:20:07.517]                     {
[13:20:07.517]                       {
[13:20:07.517]                         base::local({
[13:20:07.517]                           has_future <- base::requireNamespace("future", 
[13:20:07.517]                             quietly = TRUE)
[13:20:07.517]                           if (has_future) {
[13:20:07.517]                             ns <- base::getNamespace("future")
[13:20:07.517]                             version <- ns[[".package"]][["version"]]
[13:20:07.517]                             if (is.null(version)) 
[13:20:07.517]                               version <- utils::packageVersion("future")
[13:20:07.517]                           }
[13:20:07.517]                           else {
[13:20:07.517]                             version <- NULL
[13:20:07.517]                           }
[13:20:07.517]                           if (!has_future || version < "1.8.0") {
[13:20:07.517]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:07.517]                               "", base::R.version$version.string), 
[13:20:07.517]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:07.517]                                 base::R.version$platform, 8 * 
[13:20:07.517]                                   base::.Machine$sizeof.pointer), 
[13:20:07.517]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:07.517]                                 "release", "version")], collapse = " "), 
[13:20:07.517]                               hostname = base::Sys.info()[["nodename"]])
[13:20:07.517]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:07.517]                               info)
[13:20:07.517]                             info <- base::paste(info, collapse = "; ")
[13:20:07.517]                             if (!has_future) {
[13:20:07.517]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:07.517]                                 info)
[13:20:07.517]                             }
[13:20:07.517]                             else {
[13:20:07.517]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:07.517]                                 info, version)
[13:20:07.517]                             }
[13:20:07.517]                             base::stop(msg)
[13:20:07.517]                           }
[13:20:07.517]                         })
[13:20:07.517]                       }
[13:20:07.517]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:07.517]                       base::options(mc.cores = 1L)
[13:20:07.517]                     }
[13:20:07.517]                     base::local({
[13:20:07.517]                       for (pkg in "stats") {
[13:20:07.517]                         base::loadNamespace(pkg)
[13:20:07.517]                         base::library(pkg, character.only = TRUE)
[13:20:07.517]                       }
[13:20:07.517]                     })
[13:20:07.517]                   }
[13:20:07.517]                   options(future.plan = NULL)
[13:20:07.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:07.517]                 }
[13:20:07.517]                 ...future.workdir <- getwd()
[13:20:07.517]             }
[13:20:07.517]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:07.517]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:07.517]         }
[13:20:07.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:07.517]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:07.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:07.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:07.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:07.517]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:07.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:07.517]             base::names(...future.oldOptions))
[13:20:07.517]     }
[13:20:07.517]     if (FALSE) {
[13:20:07.517]     }
[13:20:07.517]     else {
[13:20:07.517]         if (TRUE) {
[13:20:07.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:07.517]                 open = "w")
[13:20:07.517]         }
[13:20:07.517]         else {
[13:20:07.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:07.517]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:07.517]         }
[13:20:07.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:07.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:07.517]             base::sink(type = "output", split = FALSE)
[13:20:07.517]             base::close(...future.stdout)
[13:20:07.517]         }, add = TRUE)
[13:20:07.517]     }
[13:20:07.517]     ...future.frame <- base::sys.nframe()
[13:20:07.517]     ...future.conditions <- base::list()
[13:20:07.517]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:07.517]     if (FALSE) {
[13:20:07.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:07.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:07.517]     }
[13:20:07.517]     ...future.result <- base::tryCatch({
[13:20:07.517]         base::withCallingHandlers({
[13:20:07.517]             ...future.value <- base::withVisible(base::local({
[13:20:07.517]                 ...future.makeSendCondition <- base::local({
[13:20:07.517]                   sendCondition <- NULL
[13:20:07.517]                   function(frame = 1L) {
[13:20:07.517]                     if (is.function(sendCondition)) 
[13:20:07.517]                       return(sendCondition)
[13:20:07.517]                     ns <- getNamespace("parallel")
[13:20:07.517]                     if (exists("sendData", mode = "function", 
[13:20:07.517]                       envir = ns)) {
[13:20:07.517]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:07.517]                         envir = ns)
[13:20:07.517]                       envir <- sys.frame(frame)
[13:20:07.517]                       master <- NULL
[13:20:07.517]                       while (!identical(envir, .GlobalEnv) && 
[13:20:07.517]                         !identical(envir, emptyenv())) {
[13:20:07.517]                         if (exists("master", mode = "list", envir = envir, 
[13:20:07.517]                           inherits = FALSE)) {
[13:20:07.517]                           master <- get("master", mode = "list", 
[13:20:07.517]                             envir = envir, inherits = FALSE)
[13:20:07.517]                           if (inherits(master, c("SOCKnode", 
[13:20:07.517]                             "SOCK0node"))) {
[13:20:07.517]                             sendCondition <<- function(cond) {
[13:20:07.517]                               data <- list(type = "VALUE", value = cond, 
[13:20:07.517]                                 success = TRUE)
[13:20:07.517]                               parallel_sendData(master, data)
[13:20:07.517]                             }
[13:20:07.517]                             return(sendCondition)
[13:20:07.517]                           }
[13:20:07.517]                         }
[13:20:07.517]                         frame <- frame + 1L
[13:20:07.517]                         envir <- sys.frame(frame)
[13:20:07.517]                       }
[13:20:07.517]                     }
[13:20:07.517]                     sendCondition <<- function(cond) NULL
[13:20:07.517]                   }
[13:20:07.517]                 })
[13:20:07.517]                 withCallingHandlers({
[13:20:07.517]                   {
[13:20:07.517]                     do.call(function(...) {
[13:20:07.517]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.517]                       if (!identical(...future.globals.maxSize.org, 
[13:20:07.517]                         ...future.globals.maxSize)) {
[13:20:07.517]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.517]                         on.exit(options(oopts), add = TRUE)
[13:20:07.517]                       }
[13:20:07.517]                       {
[13:20:07.517]                         lapply(seq_along(...future.elements_ii), 
[13:20:07.517]                           FUN = function(jj) {
[13:20:07.517]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.517]                             ...future.FUN(...future.X_jj, ...)
[13:20:07.517]                           })
[13:20:07.517]                       }
[13:20:07.517]                     }, args = future.call.arguments)
[13:20:07.517]                   }
[13:20:07.517]                 }, immediateCondition = function(cond) {
[13:20:07.517]                   sendCondition <- ...future.makeSendCondition()
[13:20:07.517]                   sendCondition(cond)
[13:20:07.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.517]                   {
[13:20:07.517]                     inherits <- base::inherits
[13:20:07.517]                     invokeRestart <- base::invokeRestart
[13:20:07.517]                     is.null <- base::is.null
[13:20:07.517]                     muffled <- FALSE
[13:20:07.517]                     if (inherits(cond, "message")) {
[13:20:07.517]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:07.517]                       if (muffled) 
[13:20:07.517]                         invokeRestart("muffleMessage")
[13:20:07.517]                     }
[13:20:07.517]                     else if (inherits(cond, "warning")) {
[13:20:07.517]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:07.517]                       if (muffled) 
[13:20:07.517]                         invokeRestart("muffleWarning")
[13:20:07.517]                     }
[13:20:07.517]                     else if (inherits(cond, "condition")) {
[13:20:07.517]                       if (!is.null(pattern)) {
[13:20:07.517]                         computeRestarts <- base::computeRestarts
[13:20:07.517]                         grepl <- base::grepl
[13:20:07.517]                         restarts <- computeRestarts(cond)
[13:20:07.517]                         for (restart in restarts) {
[13:20:07.517]                           name <- restart$name
[13:20:07.517]                           if (is.null(name)) 
[13:20:07.517]                             next
[13:20:07.517]                           if (!grepl(pattern, name)) 
[13:20:07.517]                             next
[13:20:07.517]                           invokeRestart(restart)
[13:20:07.517]                           muffled <- TRUE
[13:20:07.517]                           break
[13:20:07.517]                         }
[13:20:07.517]                       }
[13:20:07.517]                     }
[13:20:07.517]                     invisible(muffled)
[13:20:07.517]                   }
[13:20:07.517]                   muffleCondition(cond)
[13:20:07.517]                 })
[13:20:07.517]             }))
[13:20:07.517]             future::FutureResult(value = ...future.value$value, 
[13:20:07.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.517]                   ...future.rng), globalenv = if (FALSE) 
[13:20:07.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:07.517]                     ...future.globalenv.names))
[13:20:07.517]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:07.517]         }, condition = base::local({
[13:20:07.517]             c <- base::c
[13:20:07.517]             inherits <- base::inherits
[13:20:07.517]             invokeRestart <- base::invokeRestart
[13:20:07.517]             length <- base::length
[13:20:07.517]             list <- base::list
[13:20:07.517]             seq.int <- base::seq.int
[13:20:07.517]             signalCondition <- base::signalCondition
[13:20:07.517]             sys.calls <- base::sys.calls
[13:20:07.517]             `[[` <- base::`[[`
[13:20:07.517]             `+` <- base::`+`
[13:20:07.517]             `<<-` <- base::`<<-`
[13:20:07.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:07.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:07.517]                   3L)]
[13:20:07.517]             }
[13:20:07.517]             function(cond) {
[13:20:07.517]                 is_error <- inherits(cond, "error")
[13:20:07.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:07.517]                   NULL)
[13:20:07.517]                 if (is_error) {
[13:20:07.517]                   sessionInformation <- function() {
[13:20:07.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:07.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:07.517]                       search = base::search(), system = base::Sys.info())
[13:20:07.517]                   }
[13:20:07.517]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:07.517]                     cond$call), session = sessionInformation(), 
[13:20:07.517]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:07.517]                   signalCondition(cond)
[13:20:07.517]                 }
[13:20:07.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:07.517]                 "immediateCondition"))) {
[13:20:07.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:07.517]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:07.517]                   if (TRUE && !signal) {
[13:20:07.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.517]                     {
[13:20:07.517]                       inherits <- base::inherits
[13:20:07.517]                       invokeRestart <- base::invokeRestart
[13:20:07.517]                       is.null <- base::is.null
[13:20:07.517]                       muffled <- FALSE
[13:20:07.517]                       if (inherits(cond, "message")) {
[13:20:07.517]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.517]                         if (muffled) 
[13:20:07.517]                           invokeRestart("muffleMessage")
[13:20:07.517]                       }
[13:20:07.517]                       else if (inherits(cond, "warning")) {
[13:20:07.517]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.517]                         if (muffled) 
[13:20:07.517]                           invokeRestart("muffleWarning")
[13:20:07.517]                       }
[13:20:07.517]                       else if (inherits(cond, "condition")) {
[13:20:07.517]                         if (!is.null(pattern)) {
[13:20:07.517]                           computeRestarts <- base::computeRestarts
[13:20:07.517]                           grepl <- base::grepl
[13:20:07.517]                           restarts <- computeRestarts(cond)
[13:20:07.517]                           for (restart in restarts) {
[13:20:07.517]                             name <- restart$name
[13:20:07.517]                             if (is.null(name)) 
[13:20:07.517]                               next
[13:20:07.517]                             if (!grepl(pattern, name)) 
[13:20:07.517]                               next
[13:20:07.517]                             invokeRestart(restart)
[13:20:07.517]                             muffled <- TRUE
[13:20:07.517]                             break
[13:20:07.517]                           }
[13:20:07.517]                         }
[13:20:07.517]                       }
[13:20:07.517]                       invisible(muffled)
[13:20:07.517]                     }
[13:20:07.517]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.517]                   }
[13:20:07.517]                 }
[13:20:07.517]                 else {
[13:20:07.517]                   if (TRUE) {
[13:20:07.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.517]                     {
[13:20:07.517]                       inherits <- base::inherits
[13:20:07.517]                       invokeRestart <- base::invokeRestart
[13:20:07.517]                       is.null <- base::is.null
[13:20:07.517]                       muffled <- FALSE
[13:20:07.517]                       if (inherits(cond, "message")) {
[13:20:07.517]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.517]                         if (muffled) 
[13:20:07.517]                           invokeRestart("muffleMessage")
[13:20:07.517]                       }
[13:20:07.517]                       else if (inherits(cond, "warning")) {
[13:20:07.517]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.517]                         if (muffled) 
[13:20:07.517]                           invokeRestart("muffleWarning")
[13:20:07.517]                       }
[13:20:07.517]                       else if (inherits(cond, "condition")) {
[13:20:07.517]                         if (!is.null(pattern)) {
[13:20:07.517]                           computeRestarts <- base::computeRestarts
[13:20:07.517]                           grepl <- base::grepl
[13:20:07.517]                           restarts <- computeRestarts(cond)
[13:20:07.517]                           for (restart in restarts) {
[13:20:07.517]                             name <- restart$name
[13:20:07.517]                             if (is.null(name)) 
[13:20:07.517]                               next
[13:20:07.517]                             if (!grepl(pattern, name)) 
[13:20:07.517]                               next
[13:20:07.517]                             invokeRestart(restart)
[13:20:07.517]                             muffled <- TRUE
[13:20:07.517]                             break
[13:20:07.517]                           }
[13:20:07.517]                         }
[13:20:07.517]                       }
[13:20:07.517]                       invisible(muffled)
[13:20:07.517]                     }
[13:20:07.517]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.517]                   }
[13:20:07.517]                 }
[13:20:07.517]             }
[13:20:07.517]         }))
[13:20:07.517]     }, error = function(ex) {
[13:20:07.517]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:07.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.517]                 ...future.rng), started = ...future.startTime, 
[13:20:07.517]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:07.517]             version = "1.8"), class = "FutureResult")
[13:20:07.517]     }, finally = {
[13:20:07.517]         if (!identical(...future.workdir, getwd())) 
[13:20:07.517]             setwd(...future.workdir)
[13:20:07.517]         {
[13:20:07.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:07.517]                 ...future.oldOptions$nwarnings <- NULL
[13:20:07.517]             }
[13:20:07.517]             base::options(...future.oldOptions)
[13:20:07.517]             if (.Platform$OS.type == "windows") {
[13:20:07.517]                 old_names <- names(...future.oldEnvVars)
[13:20:07.517]                 envs <- base::Sys.getenv()
[13:20:07.517]                 names <- names(envs)
[13:20:07.517]                 common <- intersect(names, old_names)
[13:20:07.517]                 added <- setdiff(names, old_names)
[13:20:07.517]                 removed <- setdiff(old_names, names)
[13:20:07.517]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:07.517]                   envs[common]]
[13:20:07.517]                 NAMES <- toupper(changed)
[13:20:07.517]                 args <- list()
[13:20:07.517]                 for (kk in seq_along(NAMES)) {
[13:20:07.517]                   name <- changed[[kk]]
[13:20:07.517]                   NAME <- NAMES[[kk]]
[13:20:07.517]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.517]                     next
[13:20:07.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.517]                 }
[13:20:07.517]                 NAMES <- toupper(added)
[13:20:07.517]                 for (kk in seq_along(NAMES)) {
[13:20:07.517]                   name <- added[[kk]]
[13:20:07.517]                   NAME <- NAMES[[kk]]
[13:20:07.517]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.517]                     next
[13:20:07.517]                   args[[name]] <- ""
[13:20:07.517]                 }
[13:20:07.517]                 NAMES <- toupper(removed)
[13:20:07.517]                 for (kk in seq_along(NAMES)) {
[13:20:07.517]                   name <- removed[[kk]]
[13:20:07.517]                   NAME <- NAMES[[kk]]
[13:20:07.517]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.517]                     next
[13:20:07.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.517]                 }
[13:20:07.517]                 if (length(args) > 0) 
[13:20:07.517]                   base::do.call(base::Sys.setenv, args = args)
[13:20:07.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:07.517]             }
[13:20:07.517]             else {
[13:20:07.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:07.517]             }
[13:20:07.517]             {
[13:20:07.517]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:07.517]                   0L) {
[13:20:07.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:07.517]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:07.517]                   base::options(opts)
[13:20:07.517]                 }
[13:20:07.517]                 {
[13:20:07.517]                   {
[13:20:07.517]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:07.517]                     NULL
[13:20:07.517]                   }
[13:20:07.517]                   options(future.plan = NULL)
[13:20:07.517]                   if (is.na(NA_character_)) 
[13:20:07.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:07.517]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:07.517]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:07.517]                     envir = parent.frame()) 
[13:20:07.517]                   {
[13:20:07.517]                     if (is.function(workers)) 
[13:20:07.517]                       workers <- workers()
[13:20:07.517]                     workers <- structure(as.integer(workers), 
[13:20:07.517]                       class = class(workers))
[13:20:07.517]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:07.517]                       workers >= 1)
[13:20:07.517]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:07.517]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:07.517]                     }
[13:20:07.517]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:07.517]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:07.517]                       envir = envir)
[13:20:07.517]                     if (!future$lazy) 
[13:20:07.517]                       future <- run(future)
[13:20:07.517]                     invisible(future)
[13:20:07.517]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:07.517]                 }
[13:20:07.517]             }
[13:20:07.517]         }
[13:20:07.517]     })
[13:20:07.517]     if (TRUE) {
[13:20:07.517]         base::sink(type = "output", split = FALSE)
[13:20:07.517]         if (TRUE) {
[13:20:07.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:07.517]         }
[13:20:07.517]         else {
[13:20:07.517]             ...future.result["stdout"] <- base::list(NULL)
[13:20:07.517]         }
[13:20:07.517]         base::close(...future.stdout)
[13:20:07.517]         ...future.stdout <- NULL
[13:20:07.517]     }
[13:20:07.517]     ...future.result$conditions <- ...future.conditions
[13:20:07.517]     ...future.result$finished <- base::Sys.time()
[13:20:07.517]     ...future.result
[13:20:07.517] }
[13:20:07.520] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[13:20:07.520] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:20:07.520] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:20:07.520] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:07.521] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:07.521] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:20:07.521] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:20:07.521] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:07.522] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:07.522] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:20:07.522] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:20:07.522] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[13:20:07.523] MultisessionFuture started
[13:20:07.523] - Launch lazy future ... done
[13:20:07.523] run() for ‘MultisessionFuture’ ... done
[13:20:07.523] Created future:
[13:20:07.523] MultisessionFuture:
[13:20:07.523] Label: ‘future_eapply-1’
[13:20:07.523] Expression:
[13:20:07.523] {
[13:20:07.523]     do.call(function(...) {
[13:20:07.523]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.523]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.523]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.523]             on.exit(options(oopts), add = TRUE)
[13:20:07.523]         }
[13:20:07.523]         {
[13:20:07.523]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.523]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.523]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.523]             })
[13:20:07.523]         }
[13:20:07.523]     }, args = future.call.arguments)
[13:20:07.523] }
[13:20:07.523] Lazy evaluation: FALSE
[13:20:07.523] Asynchronous evaluation: TRUE
[13:20:07.523] Local evaluation: TRUE
[13:20:07.523] Environment: R_GlobalEnv
[13:20:07.523] Capture standard output: TRUE
[13:20:07.523] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:07.523] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:07.523] Packages: 1 packages (‘stats’)
[13:20:07.523] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:07.523] Resolved: FALSE
[13:20:07.523] Value: <not collected>
[13:20:07.523] Conditions captured: <none>
[13:20:07.523] Early signaling: FALSE
[13:20:07.523] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:07.523] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.535] Chunk #1 of 2 ... DONE
[13:20:07.535] Chunk #2 of 2 ...
[13:20:07.535]  - Finding globals in 'X' for chunk #2 ...
[13:20:07.535] getGlobalsAndPackages() ...
[13:20:07.535] Searching for globals...
[13:20:07.536] 
[13:20:07.536] Searching for globals ... DONE
[13:20:07.536] - globals: [0] <none>
[13:20:07.536] getGlobalsAndPackages() ... DONE
[13:20:07.536]    + additional globals found: [n=0] 
[13:20:07.536]    + additional namespaces needed: [n=0] 
[13:20:07.536]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:07.536]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:07.537]  - seeds: <none>
[13:20:07.537]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.537] getGlobalsAndPackages() ...
[13:20:07.537] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.537] Resolving globals: FALSE
[13:20:07.537] Tweak future expression to call with '...' arguments ...
[13:20:07.537] {
[13:20:07.537]     do.call(function(...) {
[13:20:07.537]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.537]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.537]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.537]             on.exit(options(oopts), add = TRUE)
[13:20:07.537]         }
[13:20:07.537]         {
[13:20:07.537]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.537]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.537]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.537]             })
[13:20:07.537]         }
[13:20:07.537]     }, args = future.call.arguments)
[13:20:07.537] }
[13:20:07.537] Tweak future expression to call with '...' arguments ... DONE
[13:20:07.538] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.538] - packages: [1] ‘stats’
[13:20:07.538] getGlobalsAndPackages() ... DONE
[13:20:07.538] run() for ‘Future’ ...
[13:20:07.539] - state: ‘created’
[13:20:07.539] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:07.554] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:07.555]   - Field: ‘node’
[13:20:07.555]   - Field: ‘label’
[13:20:07.555]   - Field: ‘local’
[13:20:07.555]   - Field: ‘owner’
[13:20:07.555]   - Field: ‘envir’
[13:20:07.555]   - Field: ‘workers’
[13:20:07.555]   - Field: ‘packages’
[13:20:07.555]   - Field: ‘gc’
[13:20:07.556]   - Field: ‘conditions’
[13:20:07.556]   - Field: ‘persistent’
[13:20:07.556]   - Field: ‘expr’
[13:20:07.556]   - Field: ‘uuid’
[13:20:07.556]   - Field: ‘seed’
[13:20:07.556]   - Field: ‘version’
[13:20:07.556]   - Field: ‘result’
[13:20:07.556]   - Field: ‘asynchronous’
[13:20:07.556]   - Field: ‘calls’
[13:20:07.556]   - Field: ‘globals’
[13:20:07.557]   - Field: ‘stdout’
[13:20:07.557]   - Field: ‘earlySignal’
[13:20:07.557]   - Field: ‘lazy’
[13:20:07.557]   - Field: ‘state’
[13:20:07.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:07.557] - Launch lazy future ...
[13:20:07.557] Packages needed by the future expression (n = 1): ‘stats’
[13:20:07.557] Packages needed by future strategies (n = 0): <none>
[13:20:07.558] {
[13:20:07.558]     {
[13:20:07.558]         {
[13:20:07.558]             ...future.startTime <- base::Sys.time()
[13:20:07.558]             {
[13:20:07.558]                 {
[13:20:07.558]                   {
[13:20:07.558]                     {
[13:20:07.558]                       {
[13:20:07.558]                         base::local({
[13:20:07.558]                           has_future <- base::requireNamespace("future", 
[13:20:07.558]                             quietly = TRUE)
[13:20:07.558]                           if (has_future) {
[13:20:07.558]                             ns <- base::getNamespace("future")
[13:20:07.558]                             version <- ns[[".package"]][["version"]]
[13:20:07.558]                             if (is.null(version)) 
[13:20:07.558]                               version <- utils::packageVersion("future")
[13:20:07.558]                           }
[13:20:07.558]                           else {
[13:20:07.558]                             version <- NULL
[13:20:07.558]                           }
[13:20:07.558]                           if (!has_future || version < "1.8.0") {
[13:20:07.558]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:07.558]                               "", base::R.version$version.string), 
[13:20:07.558]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:07.558]                                 base::R.version$platform, 8 * 
[13:20:07.558]                                   base::.Machine$sizeof.pointer), 
[13:20:07.558]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:07.558]                                 "release", "version")], collapse = " "), 
[13:20:07.558]                               hostname = base::Sys.info()[["nodename"]])
[13:20:07.558]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:07.558]                               info)
[13:20:07.558]                             info <- base::paste(info, collapse = "; ")
[13:20:07.558]                             if (!has_future) {
[13:20:07.558]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:07.558]                                 info)
[13:20:07.558]                             }
[13:20:07.558]                             else {
[13:20:07.558]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:07.558]                                 info, version)
[13:20:07.558]                             }
[13:20:07.558]                             base::stop(msg)
[13:20:07.558]                           }
[13:20:07.558]                         })
[13:20:07.558]                       }
[13:20:07.558]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:07.558]                       base::options(mc.cores = 1L)
[13:20:07.558]                     }
[13:20:07.558]                     base::local({
[13:20:07.558]                       for (pkg in "stats") {
[13:20:07.558]                         base::loadNamespace(pkg)
[13:20:07.558]                         base::library(pkg, character.only = TRUE)
[13:20:07.558]                       }
[13:20:07.558]                     })
[13:20:07.558]                   }
[13:20:07.558]                   options(future.plan = NULL)
[13:20:07.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:07.558]                 }
[13:20:07.558]                 ...future.workdir <- getwd()
[13:20:07.558]             }
[13:20:07.558]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:07.558]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:07.558]         }
[13:20:07.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:07.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:07.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:07.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:07.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:07.558]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:07.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:07.558]             base::names(...future.oldOptions))
[13:20:07.558]     }
[13:20:07.558]     if (FALSE) {
[13:20:07.558]     }
[13:20:07.558]     else {
[13:20:07.558]         if (TRUE) {
[13:20:07.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:07.558]                 open = "w")
[13:20:07.558]         }
[13:20:07.558]         else {
[13:20:07.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:07.558]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:07.558]         }
[13:20:07.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:07.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:07.558]             base::sink(type = "output", split = FALSE)
[13:20:07.558]             base::close(...future.stdout)
[13:20:07.558]         }, add = TRUE)
[13:20:07.558]     }
[13:20:07.558]     ...future.frame <- base::sys.nframe()
[13:20:07.558]     ...future.conditions <- base::list()
[13:20:07.558]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:07.558]     if (FALSE) {
[13:20:07.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:07.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:07.558]     }
[13:20:07.558]     ...future.result <- base::tryCatch({
[13:20:07.558]         base::withCallingHandlers({
[13:20:07.558]             ...future.value <- base::withVisible(base::local({
[13:20:07.558]                 ...future.makeSendCondition <- base::local({
[13:20:07.558]                   sendCondition <- NULL
[13:20:07.558]                   function(frame = 1L) {
[13:20:07.558]                     if (is.function(sendCondition)) 
[13:20:07.558]                       return(sendCondition)
[13:20:07.558]                     ns <- getNamespace("parallel")
[13:20:07.558]                     if (exists("sendData", mode = "function", 
[13:20:07.558]                       envir = ns)) {
[13:20:07.558]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:07.558]                         envir = ns)
[13:20:07.558]                       envir <- sys.frame(frame)
[13:20:07.558]                       master <- NULL
[13:20:07.558]                       while (!identical(envir, .GlobalEnv) && 
[13:20:07.558]                         !identical(envir, emptyenv())) {
[13:20:07.558]                         if (exists("master", mode = "list", envir = envir, 
[13:20:07.558]                           inherits = FALSE)) {
[13:20:07.558]                           master <- get("master", mode = "list", 
[13:20:07.558]                             envir = envir, inherits = FALSE)
[13:20:07.558]                           if (inherits(master, c("SOCKnode", 
[13:20:07.558]                             "SOCK0node"))) {
[13:20:07.558]                             sendCondition <<- function(cond) {
[13:20:07.558]                               data <- list(type = "VALUE", value = cond, 
[13:20:07.558]                                 success = TRUE)
[13:20:07.558]                               parallel_sendData(master, data)
[13:20:07.558]                             }
[13:20:07.558]                             return(sendCondition)
[13:20:07.558]                           }
[13:20:07.558]                         }
[13:20:07.558]                         frame <- frame + 1L
[13:20:07.558]                         envir <- sys.frame(frame)
[13:20:07.558]                       }
[13:20:07.558]                     }
[13:20:07.558]                     sendCondition <<- function(cond) NULL
[13:20:07.558]                   }
[13:20:07.558]                 })
[13:20:07.558]                 withCallingHandlers({
[13:20:07.558]                   {
[13:20:07.558]                     do.call(function(...) {
[13:20:07.558]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.558]                       if (!identical(...future.globals.maxSize.org, 
[13:20:07.558]                         ...future.globals.maxSize)) {
[13:20:07.558]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.558]                         on.exit(options(oopts), add = TRUE)
[13:20:07.558]                       }
[13:20:07.558]                       {
[13:20:07.558]                         lapply(seq_along(...future.elements_ii), 
[13:20:07.558]                           FUN = function(jj) {
[13:20:07.558]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.558]                             ...future.FUN(...future.X_jj, ...)
[13:20:07.558]                           })
[13:20:07.558]                       }
[13:20:07.558]                     }, args = future.call.arguments)
[13:20:07.558]                   }
[13:20:07.558]                 }, immediateCondition = function(cond) {
[13:20:07.558]                   sendCondition <- ...future.makeSendCondition()
[13:20:07.558]                   sendCondition(cond)
[13:20:07.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.558]                   {
[13:20:07.558]                     inherits <- base::inherits
[13:20:07.558]                     invokeRestart <- base::invokeRestart
[13:20:07.558]                     is.null <- base::is.null
[13:20:07.558]                     muffled <- FALSE
[13:20:07.558]                     if (inherits(cond, "message")) {
[13:20:07.558]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:07.558]                       if (muffled) 
[13:20:07.558]                         invokeRestart("muffleMessage")
[13:20:07.558]                     }
[13:20:07.558]                     else if (inherits(cond, "warning")) {
[13:20:07.558]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:07.558]                       if (muffled) 
[13:20:07.558]                         invokeRestart("muffleWarning")
[13:20:07.558]                     }
[13:20:07.558]                     else if (inherits(cond, "condition")) {
[13:20:07.558]                       if (!is.null(pattern)) {
[13:20:07.558]                         computeRestarts <- base::computeRestarts
[13:20:07.558]                         grepl <- base::grepl
[13:20:07.558]                         restarts <- computeRestarts(cond)
[13:20:07.558]                         for (restart in restarts) {
[13:20:07.558]                           name <- restart$name
[13:20:07.558]                           if (is.null(name)) 
[13:20:07.558]                             next
[13:20:07.558]                           if (!grepl(pattern, name)) 
[13:20:07.558]                             next
[13:20:07.558]                           invokeRestart(restart)
[13:20:07.558]                           muffled <- TRUE
[13:20:07.558]                           break
[13:20:07.558]                         }
[13:20:07.558]                       }
[13:20:07.558]                     }
[13:20:07.558]                     invisible(muffled)
[13:20:07.558]                   }
[13:20:07.558]                   muffleCondition(cond)
[13:20:07.558]                 })
[13:20:07.558]             }))
[13:20:07.558]             future::FutureResult(value = ...future.value$value, 
[13:20:07.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.558]                   ...future.rng), globalenv = if (FALSE) 
[13:20:07.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:07.558]                     ...future.globalenv.names))
[13:20:07.558]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:07.558]         }, condition = base::local({
[13:20:07.558]             c <- base::c
[13:20:07.558]             inherits <- base::inherits
[13:20:07.558]             invokeRestart <- base::invokeRestart
[13:20:07.558]             length <- base::length
[13:20:07.558]             list <- base::list
[13:20:07.558]             seq.int <- base::seq.int
[13:20:07.558]             signalCondition <- base::signalCondition
[13:20:07.558]             sys.calls <- base::sys.calls
[13:20:07.558]             `[[` <- base::`[[`
[13:20:07.558]             `+` <- base::`+`
[13:20:07.558]             `<<-` <- base::`<<-`
[13:20:07.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:07.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:07.558]                   3L)]
[13:20:07.558]             }
[13:20:07.558]             function(cond) {
[13:20:07.558]                 is_error <- inherits(cond, "error")
[13:20:07.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:07.558]                   NULL)
[13:20:07.558]                 if (is_error) {
[13:20:07.558]                   sessionInformation <- function() {
[13:20:07.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:07.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:07.558]                       search = base::search(), system = base::Sys.info())
[13:20:07.558]                   }
[13:20:07.558]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:07.558]                     cond$call), session = sessionInformation(), 
[13:20:07.558]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:07.558]                   signalCondition(cond)
[13:20:07.558]                 }
[13:20:07.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:07.558]                 "immediateCondition"))) {
[13:20:07.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:07.558]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:07.558]                   if (TRUE && !signal) {
[13:20:07.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.558]                     {
[13:20:07.558]                       inherits <- base::inherits
[13:20:07.558]                       invokeRestart <- base::invokeRestart
[13:20:07.558]                       is.null <- base::is.null
[13:20:07.558]                       muffled <- FALSE
[13:20:07.558]                       if (inherits(cond, "message")) {
[13:20:07.558]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.558]                         if (muffled) 
[13:20:07.558]                           invokeRestart("muffleMessage")
[13:20:07.558]                       }
[13:20:07.558]                       else if (inherits(cond, "warning")) {
[13:20:07.558]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.558]                         if (muffled) 
[13:20:07.558]                           invokeRestart("muffleWarning")
[13:20:07.558]                       }
[13:20:07.558]                       else if (inherits(cond, "condition")) {
[13:20:07.558]                         if (!is.null(pattern)) {
[13:20:07.558]                           computeRestarts <- base::computeRestarts
[13:20:07.558]                           grepl <- base::grepl
[13:20:07.558]                           restarts <- computeRestarts(cond)
[13:20:07.558]                           for (restart in restarts) {
[13:20:07.558]                             name <- restart$name
[13:20:07.558]                             if (is.null(name)) 
[13:20:07.558]                               next
[13:20:07.558]                             if (!grepl(pattern, name)) 
[13:20:07.558]                               next
[13:20:07.558]                             invokeRestart(restart)
[13:20:07.558]                             muffled <- TRUE
[13:20:07.558]                             break
[13:20:07.558]                           }
[13:20:07.558]                         }
[13:20:07.558]                       }
[13:20:07.558]                       invisible(muffled)
[13:20:07.558]                     }
[13:20:07.558]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.558]                   }
[13:20:07.558]                 }
[13:20:07.558]                 else {
[13:20:07.558]                   if (TRUE) {
[13:20:07.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.558]                     {
[13:20:07.558]                       inherits <- base::inherits
[13:20:07.558]                       invokeRestart <- base::invokeRestart
[13:20:07.558]                       is.null <- base::is.null
[13:20:07.558]                       muffled <- FALSE
[13:20:07.558]                       if (inherits(cond, "message")) {
[13:20:07.558]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.558]                         if (muffled) 
[13:20:07.558]                           invokeRestart("muffleMessage")
[13:20:07.558]                       }
[13:20:07.558]                       else if (inherits(cond, "warning")) {
[13:20:07.558]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.558]                         if (muffled) 
[13:20:07.558]                           invokeRestart("muffleWarning")
[13:20:07.558]                       }
[13:20:07.558]                       else if (inherits(cond, "condition")) {
[13:20:07.558]                         if (!is.null(pattern)) {
[13:20:07.558]                           computeRestarts <- base::computeRestarts
[13:20:07.558]                           grepl <- base::grepl
[13:20:07.558]                           restarts <- computeRestarts(cond)
[13:20:07.558]                           for (restart in restarts) {
[13:20:07.558]                             name <- restart$name
[13:20:07.558]                             if (is.null(name)) 
[13:20:07.558]                               next
[13:20:07.558]                             if (!grepl(pattern, name)) 
[13:20:07.558]                               next
[13:20:07.558]                             invokeRestart(restart)
[13:20:07.558]                             muffled <- TRUE
[13:20:07.558]                             break
[13:20:07.558]                           }
[13:20:07.558]                         }
[13:20:07.558]                       }
[13:20:07.558]                       invisible(muffled)
[13:20:07.558]                     }
[13:20:07.558]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.558]                   }
[13:20:07.558]                 }
[13:20:07.558]             }
[13:20:07.558]         }))
[13:20:07.558]     }, error = function(ex) {
[13:20:07.558]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:07.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.558]                 ...future.rng), started = ...future.startTime, 
[13:20:07.558]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:07.558]             version = "1.8"), class = "FutureResult")
[13:20:07.558]     }, finally = {
[13:20:07.558]         if (!identical(...future.workdir, getwd())) 
[13:20:07.558]             setwd(...future.workdir)
[13:20:07.558]         {
[13:20:07.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:07.558]                 ...future.oldOptions$nwarnings <- NULL
[13:20:07.558]             }
[13:20:07.558]             base::options(...future.oldOptions)
[13:20:07.558]             if (.Platform$OS.type == "windows") {
[13:20:07.558]                 old_names <- names(...future.oldEnvVars)
[13:20:07.558]                 envs <- base::Sys.getenv()
[13:20:07.558]                 names <- names(envs)
[13:20:07.558]                 common <- intersect(names, old_names)
[13:20:07.558]                 added <- setdiff(names, old_names)
[13:20:07.558]                 removed <- setdiff(old_names, names)
[13:20:07.558]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:07.558]                   envs[common]]
[13:20:07.558]                 NAMES <- toupper(changed)
[13:20:07.558]                 args <- list()
[13:20:07.558]                 for (kk in seq_along(NAMES)) {
[13:20:07.558]                   name <- changed[[kk]]
[13:20:07.558]                   NAME <- NAMES[[kk]]
[13:20:07.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.558]                     next
[13:20:07.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.558]                 }
[13:20:07.558]                 NAMES <- toupper(added)
[13:20:07.558]                 for (kk in seq_along(NAMES)) {
[13:20:07.558]                   name <- added[[kk]]
[13:20:07.558]                   NAME <- NAMES[[kk]]
[13:20:07.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.558]                     next
[13:20:07.558]                   args[[name]] <- ""
[13:20:07.558]                 }
[13:20:07.558]                 NAMES <- toupper(removed)
[13:20:07.558]                 for (kk in seq_along(NAMES)) {
[13:20:07.558]                   name <- removed[[kk]]
[13:20:07.558]                   NAME <- NAMES[[kk]]
[13:20:07.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.558]                     next
[13:20:07.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.558]                 }
[13:20:07.558]                 if (length(args) > 0) 
[13:20:07.558]                   base::do.call(base::Sys.setenv, args = args)
[13:20:07.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:07.558]             }
[13:20:07.558]             else {
[13:20:07.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:07.558]             }
[13:20:07.558]             {
[13:20:07.558]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:07.558]                   0L) {
[13:20:07.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:07.558]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:07.558]                   base::options(opts)
[13:20:07.558]                 }
[13:20:07.558]                 {
[13:20:07.558]                   {
[13:20:07.558]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:07.558]                     NULL
[13:20:07.558]                   }
[13:20:07.558]                   options(future.plan = NULL)
[13:20:07.558]                   if (is.na(NA_character_)) 
[13:20:07.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:07.558]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:07.558]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:07.558]                     envir = parent.frame()) 
[13:20:07.558]                   {
[13:20:07.558]                     if (is.function(workers)) 
[13:20:07.558]                       workers <- workers()
[13:20:07.558]                     workers <- structure(as.integer(workers), 
[13:20:07.558]                       class = class(workers))
[13:20:07.558]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:07.558]                       workers >= 1)
[13:20:07.558]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:07.558]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:07.558]                     }
[13:20:07.558]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:07.558]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:07.558]                       envir = envir)
[13:20:07.558]                     if (!future$lazy) 
[13:20:07.558]                       future <- run(future)
[13:20:07.558]                     invisible(future)
[13:20:07.558]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:07.558]                 }
[13:20:07.558]             }
[13:20:07.558]         }
[13:20:07.558]     })
[13:20:07.558]     if (TRUE) {
[13:20:07.558]         base::sink(type = "output", split = FALSE)
[13:20:07.558]         if (TRUE) {
[13:20:07.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:07.558]         }
[13:20:07.558]         else {
[13:20:07.558]             ...future.result["stdout"] <- base::list(NULL)
[13:20:07.558]         }
[13:20:07.558]         base::close(...future.stdout)
[13:20:07.558]         ...future.stdout <- NULL
[13:20:07.558]     }
[13:20:07.558]     ...future.result$conditions <- ...future.conditions
[13:20:07.558]     ...future.result$finished <- base::Sys.time()
[13:20:07.558]     ...future.result
[13:20:07.558] }
[13:20:07.561] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[13:20:07.561] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:20:07.562] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:20:07.562] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:07.562] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:07.563] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:20:07.563] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:20:07.563] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:07.563] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:07.564] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:20:07.564] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:20:07.564] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[13:20:07.565] MultisessionFuture started
[13:20:07.565] - Launch lazy future ... done
[13:20:07.565] run() for ‘MultisessionFuture’ ... done
[13:20:07.565] Created future:
[13:20:07.565] MultisessionFuture:
[13:20:07.565] Label: ‘future_eapply-2’
[13:20:07.565] Expression:
[13:20:07.565] {
[13:20:07.565]     do.call(function(...) {
[13:20:07.565]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.565]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.565]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.565]             on.exit(options(oopts), add = TRUE)
[13:20:07.565]         }
[13:20:07.565]         {
[13:20:07.565]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.565]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.565]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.565]             })
[13:20:07.565]         }
[13:20:07.565]     }, args = future.call.arguments)
[13:20:07.565] }
[13:20:07.565] Lazy evaluation: FALSE
[13:20:07.565] Asynchronous evaluation: TRUE
[13:20:07.565] Local evaluation: TRUE
[13:20:07.565] Environment: R_GlobalEnv
[13:20:07.565] Capture standard output: TRUE
[13:20:07.565] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:07.565] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:07.565] Packages: 1 packages (‘stats’)
[13:20:07.565] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:07.565] Resolved: FALSE
[13:20:07.565] Value: <not collected>
[13:20:07.565] Conditions captured: <none>
[13:20:07.565] Early signaling: FALSE
[13:20:07.565] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:07.565] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.577] Chunk #2 of 2 ... DONE
[13:20:07.577] Launching 2 futures (chunks) ... DONE
[13:20:07.577] Resolving 2 futures (chunks) ...
[13:20:07.577] resolve() on list ...
[13:20:07.577]  recursive: 0
[13:20:07.578]  length: 2
[13:20:07.578] 
[13:20:07.578] receiveMessageFromWorker() for ClusterFuture ...
[13:20:07.578] - Validating connection of MultisessionFuture
[13:20:07.578] - received message: FutureResult
[13:20:07.579] - Received FutureResult
[13:20:07.579] - Erased future from FutureRegistry
[13:20:07.579] result() for ClusterFuture ...
[13:20:07.579] - result already collected: FutureResult
[13:20:07.579] result() for ClusterFuture ... done
[13:20:07.579] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:07.579] Future #1
[13:20:07.579] result() for ClusterFuture ...
[13:20:07.579] - result already collected: FutureResult
[13:20:07.579] result() for ClusterFuture ... done
[13:20:07.579] result() for ClusterFuture ...
[13:20:07.580] - result already collected: FutureResult
[13:20:07.580] result() for ClusterFuture ... done
[13:20:07.580] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:07.580] - nx: 2
[13:20:07.580] - relay: TRUE
[13:20:07.580] - stdout: TRUE
[13:20:07.580] - signal: TRUE
[13:20:07.580] - resignal: FALSE
[13:20:07.580] - force: TRUE
[13:20:07.580] - relayed: [n=2] FALSE, FALSE
[13:20:07.580] - queued futures: [n=2] FALSE, FALSE
[13:20:07.581]  - until=1
[13:20:07.581]  - relaying element #1
[13:20:07.581] result() for ClusterFuture ...
[13:20:07.581] - result already collected: FutureResult
[13:20:07.581] result() for ClusterFuture ... done
[13:20:07.581] result() for ClusterFuture ...
[13:20:07.581] - result already collected: FutureResult
[13:20:07.581] result() for ClusterFuture ... done
[13:20:07.581] result() for ClusterFuture ...
[13:20:07.581] - result already collected: FutureResult
[13:20:07.582] result() for ClusterFuture ... done
[13:20:07.582] result() for ClusterFuture ...
[13:20:07.582] - result already collected: FutureResult
[13:20:07.582] result() for ClusterFuture ... done
[13:20:07.582] - relayed: [n=2] TRUE, FALSE
[13:20:07.582] - queued futures: [n=2] TRUE, FALSE
[13:20:07.582] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:07.582]  length: 1 (resolved future 1)
[13:20:07.624] receiveMessageFromWorker() for ClusterFuture ...
[13:20:07.625] - Validating connection of MultisessionFuture
[13:20:07.625] - received message: FutureResult
[13:20:07.625] - Received FutureResult
[13:20:07.625] - Erased future from FutureRegistry
[13:20:07.625] result() for ClusterFuture ...
[13:20:07.625] - result already collected: FutureResult
[13:20:07.626] result() for ClusterFuture ... done
[13:20:07.626] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:07.626] Future #2
[13:20:07.626] result() for ClusterFuture ...
[13:20:07.626] - result already collected: FutureResult
[13:20:07.626] result() for ClusterFuture ... done
[13:20:07.626] result() for ClusterFuture ...
[13:20:07.626] - result already collected: FutureResult
[13:20:07.626] result() for ClusterFuture ... done
[13:20:07.626] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:07.626] - nx: 2
[13:20:07.627] - relay: TRUE
[13:20:07.627] - stdout: TRUE
[13:20:07.627] - signal: TRUE
[13:20:07.627] - resignal: FALSE
[13:20:07.627] - force: TRUE
[13:20:07.627] - relayed: [n=2] TRUE, FALSE
[13:20:07.627] - queued futures: [n=2] TRUE, FALSE
[13:20:07.627]  - until=2
[13:20:07.627]  - relaying element #2
[13:20:07.627] result() for ClusterFuture ...
[13:20:07.627] - result already collected: FutureResult
[13:20:07.628] result() for ClusterFuture ... done
[13:20:07.628] result() for ClusterFuture ...
[13:20:07.628] - result already collected: FutureResult
[13:20:07.628] result() for ClusterFuture ... done
[13:20:07.628] result() for ClusterFuture ...
[13:20:07.628] - result already collected: FutureResult
[13:20:07.628] result() for ClusterFuture ... done
[13:20:07.628] result() for ClusterFuture ...
[13:20:07.628] - result already collected: FutureResult
[13:20:07.628] result() for ClusterFuture ... done
[13:20:07.629] - relayed: [n=2] TRUE, TRUE
[13:20:07.629] - queued futures: [n=2] TRUE, TRUE
[13:20:07.629] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:07.629]  length: 0 (resolved future 2)
[13:20:07.629] Relaying remaining futures
[13:20:07.629] signalConditionsASAP(NULL, pos=0) ...
[13:20:07.629] - nx: 2
[13:20:07.629] - relay: TRUE
[13:20:07.629] - stdout: TRUE
[13:20:07.629] - signal: TRUE
[13:20:07.629] - resignal: FALSE
[13:20:07.629] - force: TRUE
[13:20:07.630] - relayed: [n=2] TRUE, TRUE
[13:20:07.630] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:07.630] - relayed: [n=2] TRUE, TRUE
[13:20:07.630] - queued futures: [n=2] TRUE, TRUE
[13:20:07.630] signalConditionsASAP(NULL, pos=0) ... done
[13:20:07.630] resolve() on list ... DONE
[13:20:07.630] result() for ClusterFuture ...
[13:20:07.630] - result already collected: FutureResult
[13:20:07.630] result() for ClusterFuture ... done
[13:20:07.630] result() for ClusterFuture ...
[13:20:07.631] - result already collected: FutureResult
[13:20:07.631] result() for ClusterFuture ... done
[13:20:07.631] result() for ClusterFuture ...
[13:20:07.631] - result already collected: FutureResult
[13:20:07.631] result() for ClusterFuture ... done
[13:20:07.631] result() for ClusterFuture ...
[13:20:07.631] - result already collected: FutureResult
[13:20:07.631] result() for ClusterFuture ... done
[13:20:07.631]  - Number of value chunks collected: 2
[13:20:07.631] Resolving 2 futures (chunks) ... DONE
[13:20:07.631] Reducing values from 2 chunks ...
[13:20:07.632]  - Number of values collected after concatenation: 3
[13:20:07.632]  - Number of values expected: 3
[13:20:07.632] Reducing values from 2 chunks ... DONE
[13:20:07.632] future_lapply() ... DONE
[13:20:07.632] future_lapply() ...
[13:20:07.636] Number of chunks: 2
[13:20:07.637] getGlobalsAndPackagesXApply() ...
[13:20:07.637]  - future.globals: TRUE
[13:20:07.637] getGlobalsAndPackages() ...
[13:20:07.637] Searching for globals...
[13:20:07.638] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:07.638] Searching for globals ... DONE
[13:20:07.638] Resolving globals: FALSE
[13:20:07.639] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:20:07.639] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:20:07.639] - globals: [1] ‘FUN’
[13:20:07.639] - packages: [1] ‘stats’
[13:20:07.639] getGlobalsAndPackages() ... DONE
[13:20:07.640]  - globals found/used: [n=1] ‘FUN’
[13:20:07.640]  - needed namespaces: [n=1] ‘stats’
[13:20:07.640] Finding globals ... DONE
[13:20:07.640]  - use_args: TRUE
[13:20:07.640]  - Getting '...' globals ...
[13:20:07.640] resolve() on list ...
[13:20:07.640]  recursive: 0
[13:20:07.640]  length: 1
[13:20:07.641]  elements: ‘...’
[13:20:07.641]  length: 0 (resolved future 1)
[13:20:07.641] resolve() on list ... DONE
[13:20:07.641]    - '...' content: [n=0] 
[13:20:07.641] List of 1
[13:20:07.641]  $ ...: list()
[13:20:07.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:07.641]  - attr(*, "where")=List of 1
[13:20:07.641]   ..$ ...:<environment: 0x558fdb2b9700> 
[13:20:07.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:07.641]  - attr(*, "resolved")= logi TRUE
[13:20:07.641]  - attr(*, "total_size")= num NA
[13:20:07.644]  - Getting '...' globals ... DONE
[13:20:07.644] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:07.644] List of 2
[13:20:07.644]  $ ...future.FUN:function (x, ...)  
[13:20:07.644]  $ ...          : list()
[13:20:07.644]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:07.644]  - attr(*, "where")=List of 2
[13:20:07.644]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:07.644]   ..$ ...          :<environment: 0x558fdb2b9700> 
[13:20:07.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:07.644]  - attr(*, "resolved")= logi FALSE
[13:20:07.644]  - attr(*, "total_size")= num 1248
[13:20:07.647] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:07.647] getGlobalsAndPackagesXApply() ... DONE
[13:20:07.647] Number of futures (= number of chunks): 2
[13:20:07.647] Launching 2 futures (chunks) ...
[13:20:07.647] Chunk #1 of 2 ...
[13:20:07.647]  - Finding globals in 'X' for chunk #1 ...
[13:20:07.647] getGlobalsAndPackages() ...
[13:20:07.648] Searching for globals...
[13:20:07.648] 
[13:20:07.648] Searching for globals ... DONE
[13:20:07.648] - globals: [0] <none>
[13:20:07.648] getGlobalsAndPackages() ... DONE
[13:20:07.648]    + additional globals found: [n=0] 
[13:20:07.648]    + additional namespaces needed: [n=0] 
[13:20:07.648]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:07.648]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:07.649]  - seeds: <none>
[13:20:07.649]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.649] getGlobalsAndPackages() ...
[13:20:07.649] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.649] Resolving globals: FALSE
[13:20:07.649] Tweak future expression to call with '...' arguments ...
[13:20:07.649] {
[13:20:07.649]     do.call(function(...) {
[13:20:07.649]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.649]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.649]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.649]             on.exit(options(oopts), add = TRUE)
[13:20:07.649]         }
[13:20:07.649]         {
[13:20:07.649]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.649]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.649]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.649]             })
[13:20:07.649]         }
[13:20:07.649]     }, args = future.call.arguments)
[13:20:07.649] }
[13:20:07.649] Tweak future expression to call with '...' arguments ... DONE
[13:20:07.650] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.650] - packages: [1] ‘stats’
[13:20:07.650] getGlobalsAndPackages() ... DONE
[13:20:07.650] run() for ‘Future’ ...
[13:20:07.650] - state: ‘created’
[13:20:07.651] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:07.665] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.665] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:07.665]   - Field: ‘node’
[13:20:07.665]   - Field: ‘label’
[13:20:07.665]   - Field: ‘local’
[13:20:07.666]   - Field: ‘owner’
[13:20:07.666]   - Field: ‘envir’
[13:20:07.666]   - Field: ‘workers’
[13:20:07.666]   - Field: ‘packages’
[13:20:07.666]   - Field: ‘gc’
[13:20:07.666]   - Field: ‘conditions’
[13:20:07.666]   - Field: ‘persistent’
[13:20:07.666]   - Field: ‘expr’
[13:20:07.666]   - Field: ‘uuid’
[13:20:07.666]   - Field: ‘seed’
[13:20:07.666]   - Field: ‘version’
[13:20:07.667]   - Field: ‘result’
[13:20:07.667]   - Field: ‘asynchronous’
[13:20:07.667]   - Field: ‘calls’
[13:20:07.667]   - Field: ‘globals’
[13:20:07.667]   - Field: ‘stdout’
[13:20:07.667]   - Field: ‘earlySignal’
[13:20:07.667]   - Field: ‘lazy’
[13:20:07.667]   - Field: ‘state’
[13:20:07.667] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:07.667] - Launch lazy future ...
[13:20:07.668] Packages needed by the future expression (n = 1): ‘stats’
[13:20:07.668] Packages needed by future strategies (n = 0): <none>
[13:20:07.668] {
[13:20:07.668]     {
[13:20:07.668]         {
[13:20:07.668]             ...future.startTime <- base::Sys.time()
[13:20:07.668]             {
[13:20:07.668]                 {
[13:20:07.668]                   {
[13:20:07.668]                     {
[13:20:07.668]                       {
[13:20:07.668]                         base::local({
[13:20:07.668]                           has_future <- base::requireNamespace("future", 
[13:20:07.668]                             quietly = TRUE)
[13:20:07.668]                           if (has_future) {
[13:20:07.668]                             ns <- base::getNamespace("future")
[13:20:07.668]                             version <- ns[[".package"]][["version"]]
[13:20:07.668]                             if (is.null(version)) 
[13:20:07.668]                               version <- utils::packageVersion("future")
[13:20:07.668]                           }
[13:20:07.668]                           else {
[13:20:07.668]                             version <- NULL
[13:20:07.668]                           }
[13:20:07.668]                           if (!has_future || version < "1.8.0") {
[13:20:07.668]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:07.668]                               "", base::R.version$version.string), 
[13:20:07.668]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:07.668]                                 base::R.version$platform, 8 * 
[13:20:07.668]                                   base::.Machine$sizeof.pointer), 
[13:20:07.668]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:07.668]                                 "release", "version")], collapse = " "), 
[13:20:07.668]                               hostname = base::Sys.info()[["nodename"]])
[13:20:07.668]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:07.668]                               info)
[13:20:07.668]                             info <- base::paste(info, collapse = "; ")
[13:20:07.668]                             if (!has_future) {
[13:20:07.668]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:07.668]                                 info)
[13:20:07.668]                             }
[13:20:07.668]                             else {
[13:20:07.668]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:07.668]                                 info, version)
[13:20:07.668]                             }
[13:20:07.668]                             base::stop(msg)
[13:20:07.668]                           }
[13:20:07.668]                         })
[13:20:07.668]                       }
[13:20:07.668]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:07.668]                       base::options(mc.cores = 1L)
[13:20:07.668]                     }
[13:20:07.668]                     base::local({
[13:20:07.668]                       for (pkg in "stats") {
[13:20:07.668]                         base::loadNamespace(pkg)
[13:20:07.668]                         base::library(pkg, character.only = TRUE)
[13:20:07.668]                       }
[13:20:07.668]                     })
[13:20:07.668]                   }
[13:20:07.668]                   options(future.plan = NULL)
[13:20:07.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:07.668]                 }
[13:20:07.668]                 ...future.workdir <- getwd()
[13:20:07.668]             }
[13:20:07.668]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:07.668]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:07.668]         }
[13:20:07.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:07.668]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:07.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:07.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:07.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:07.668]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:07.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:07.668]             base::names(...future.oldOptions))
[13:20:07.668]     }
[13:20:07.668]     if (FALSE) {
[13:20:07.668]     }
[13:20:07.668]     else {
[13:20:07.668]         if (TRUE) {
[13:20:07.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:07.668]                 open = "w")
[13:20:07.668]         }
[13:20:07.668]         else {
[13:20:07.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:07.668]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:07.668]         }
[13:20:07.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:07.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:07.668]             base::sink(type = "output", split = FALSE)
[13:20:07.668]             base::close(...future.stdout)
[13:20:07.668]         }, add = TRUE)
[13:20:07.668]     }
[13:20:07.668]     ...future.frame <- base::sys.nframe()
[13:20:07.668]     ...future.conditions <- base::list()
[13:20:07.668]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:07.668]     if (FALSE) {
[13:20:07.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:07.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:07.668]     }
[13:20:07.668]     ...future.result <- base::tryCatch({
[13:20:07.668]         base::withCallingHandlers({
[13:20:07.668]             ...future.value <- base::withVisible(base::local({
[13:20:07.668]                 ...future.makeSendCondition <- base::local({
[13:20:07.668]                   sendCondition <- NULL
[13:20:07.668]                   function(frame = 1L) {
[13:20:07.668]                     if (is.function(sendCondition)) 
[13:20:07.668]                       return(sendCondition)
[13:20:07.668]                     ns <- getNamespace("parallel")
[13:20:07.668]                     if (exists("sendData", mode = "function", 
[13:20:07.668]                       envir = ns)) {
[13:20:07.668]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:07.668]                         envir = ns)
[13:20:07.668]                       envir <- sys.frame(frame)
[13:20:07.668]                       master <- NULL
[13:20:07.668]                       while (!identical(envir, .GlobalEnv) && 
[13:20:07.668]                         !identical(envir, emptyenv())) {
[13:20:07.668]                         if (exists("master", mode = "list", envir = envir, 
[13:20:07.668]                           inherits = FALSE)) {
[13:20:07.668]                           master <- get("master", mode = "list", 
[13:20:07.668]                             envir = envir, inherits = FALSE)
[13:20:07.668]                           if (inherits(master, c("SOCKnode", 
[13:20:07.668]                             "SOCK0node"))) {
[13:20:07.668]                             sendCondition <<- function(cond) {
[13:20:07.668]                               data <- list(type = "VALUE", value = cond, 
[13:20:07.668]                                 success = TRUE)
[13:20:07.668]                               parallel_sendData(master, data)
[13:20:07.668]                             }
[13:20:07.668]                             return(sendCondition)
[13:20:07.668]                           }
[13:20:07.668]                         }
[13:20:07.668]                         frame <- frame + 1L
[13:20:07.668]                         envir <- sys.frame(frame)
[13:20:07.668]                       }
[13:20:07.668]                     }
[13:20:07.668]                     sendCondition <<- function(cond) NULL
[13:20:07.668]                   }
[13:20:07.668]                 })
[13:20:07.668]                 withCallingHandlers({
[13:20:07.668]                   {
[13:20:07.668]                     do.call(function(...) {
[13:20:07.668]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.668]                       if (!identical(...future.globals.maxSize.org, 
[13:20:07.668]                         ...future.globals.maxSize)) {
[13:20:07.668]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.668]                         on.exit(options(oopts), add = TRUE)
[13:20:07.668]                       }
[13:20:07.668]                       {
[13:20:07.668]                         lapply(seq_along(...future.elements_ii), 
[13:20:07.668]                           FUN = function(jj) {
[13:20:07.668]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.668]                             ...future.FUN(...future.X_jj, ...)
[13:20:07.668]                           })
[13:20:07.668]                       }
[13:20:07.668]                     }, args = future.call.arguments)
[13:20:07.668]                   }
[13:20:07.668]                 }, immediateCondition = function(cond) {
[13:20:07.668]                   sendCondition <- ...future.makeSendCondition()
[13:20:07.668]                   sendCondition(cond)
[13:20:07.668]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.668]                   {
[13:20:07.668]                     inherits <- base::inherits
[13:20:07.668]                     invokeRestart <- base::invokeRestart
[13:20:07.668]                     is.null <- base::is.null
[13:20:07.668]                     muffled <- FALSE
[13:20:07.668]                     if (inherits(cond, "message")) {
[13:20:07.668]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:07.668]                       if (muffled) 
[13:20:07.668]                         invokeRestart("muffleMessage")
[13:20:07.668]                     }
[13:20:07.668]                     else if (inherits(cond, "warning")) {
[13:20:07.668]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:07.668]                       if (muffled) 
[13:20:07.668]                         invokeRestart("muffleWarning")
[13:20:07.668]                     }
[13:20:07.668]                     else if (inherits(cond, "condition")) {
[13:20:07.668]                       if (!is.null(pattern)) {
[13:20:07.668]                         computeRestarts <- base::computeRestarts
[13:20:07.668]                         grepl <- base::grepl
[13:20:07.668]                         restarts <- computeRestarts(cond)
[13:20:07.668]                         for (restart in restarts) {
[13:20:07.668]                           name <- restart$name
[13:20:07.668]                           if (is.null(name)) 
[13:20:07.668]                             next
[13:20:07.668]                           if (!grepl(pattern, name)) 
[13:20:07.668]                             next
[13:20:07.668]                           invokeRestart(restart)
[13:20:07.668]                           muffled <- TRUE
[13:20:07.668]                           break
[13:20:07.668]                         }
[13:20:07.668]                       }
[13:20:07.668]                     }
[13:20:07.668]                     invisible(muffled)
[13:20:07.668]                   }
[13:20:07.668]                   muffleCondition(cond)
[13:20:07.668]                 })
[13:20:07.668]             }))
[13:20:07.668]             future::FutureResult(value = ...future.value$value, 
[13:20:07.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.668]                   ...future.rng), globalenv = if (FALSE) 
[13:20:07.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:07.668]                     ...future.globalenv.names))
[13:20:07.668]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:07.668]         }, condition = base::local({
[13:20:07.668]             c <- base::c
[13:20:07.668]             inherits <- base::inherits
[13:20:07.668]             invokeRestart <- base::invokeRestart
[13:20:07.668]             length <- base::length
[13:20:07.668]             list <- base::list
[13:20:07.668]             seq.int <- base::seq.int
[13:20:07.668]             signalCondition <- base::signalCondition
[13:20:07.668]             sys.calls <- base::sys.calls
[13:20:07.668]             `[[` <- base::`[[`
[13:20:07.668]             `+` <- base::`+`
[13:20:07.668]             `<<-` <- base::`<<-`
[13:20:07.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:07.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:07.668]                   3L)]
[13:20:07.668]             }
[13:20:07.668]             function(cond) {
[13:20:07.668]                 is_error <- inherits(cond, "error")
[13:20:07.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:07.668]                   NULL)
[13:20:07.668]                 if (is_error) {
[13:20:07.668]                   sessionInformation <- function() {
[13:20:07.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:07.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:07.668]                       search = base::search(), system = base::Sys.info())
[13:20:07.668]                   }
[13:20:07.668]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:07.668]                     cond$call), session = sessionInformation(), 
[13:20:07.668]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:07.668]                   signalCondition(cond)
[13:20:07.668]                 }
[13:20:07.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:07.668]                 "immediateCondition"))) {
[13:20:07.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:07.668]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:07.668]                   if (TRUE && !signal) {
[13:20:07.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.668]                     {
[13:20:07.668]                       inherits <- base::inherits
[13:20:07.668]                       invokeRestart <- base::invokeRestart
[13:20:07.668]                       is.null <- base::is.null
[13:20:07.668]                       muffled <- FALSE
[13:20:07.668]                       if (inherits(cond, "message")) {
[13:20:07.668]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.668]                         if (muffled) 
[13:20:07.668]                           invokeRestart("muffleMessage")
[13:20:07.668]                       }
[13:20:07.668]                       else if (inherits(cond, "warning")) {
[13:20:07.668]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.668]                         if (muffled) 
[13:20:07.668]                           invokeRestart("muffleWarning")
[13:20:07.668]                       }
[13:20:07.668]                       else if (inherits(cond, "condition")) {
[13:20:07.668]                         if (!is.null(pattern)) {
[13:20:07.668]                           computeRestarts <- base::computeRestarts
[13:20:07.668]                           grepl <- base::grepl
[13:20:07.668]                           restarts <- computeRestarts(cond)
[13:20:07.668]                           for (restart in restarts) {
[13:20:07.668]                             name <- restart$name
[13:20:07.668]                             if (is.null(name)) 
[13:20:07.668]                               next
[13:20:07.668]                             if (!grepl(pattern, name)) 
[13:20:07.668]                               next
[13:20:07.668]                             invokeRestart(restart)
[13:20:07.668]                             muffled <- TRUE
[13:20:07.668]                             break
[13:20:07.668]                           }
[13:20:07.668]                         }
[13:20:07.668]                       }
[13:20:07.668]                       invisible(muffled)
[13:20:07.668]                     }
[13:20:07.668]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.668]                   }
[13:20:07.668]                 }
[13:20:07.668]                 else {
[13:20:07.668]                   if (TRUE) {
[13:20:07.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.668]                     {
[13:20:07.668]                       inherits <- base::inherits
[13:20:07.668]                       invokeRestart <- base::invokeRestart
[13:20:07.668]                       is.null <- base::is.null
[13:20:07.668]                       muffled <- FALSE
[13:20:07.668]                       if (inherits(cond, "message")) {
[13:20:07.668]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.668]                         if (muffled) 
[13:20:07.668]                           invokeRestart("muffleMessage")
[13:20:07.668]                       }
[13:20:07.668]                       else if (inherits(cond, "warning")) {
[13:20:07.668]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.668]                         if (muffled) 
[13:20:07.668]                           invokeRestart("muffleWarning")
[13:20:07.668]                       }
[13:20:07.668]                       else if (inherits(cond, "condition")) {
[13:20:07.668]                         if (!is.null(pattern)) {
[13:20:07.668]                           computeRestarts <- base::computeRestarts
[13:20:07.668]                           grepl <- base::grepl
[13:20:07.668]                           restarts <- computeRestarts(cond)
[13:20:07.668]                           for (restart in restarts) {
[13:20:07.668]                             name <- restart$name
[13:20:07.668]                             if (is.null(name)) 
[13:20:07.668]                               next
[13:20:07.668]                             if (!grepl(pattern, name)) 
[13:20:07.668]                               next
[13:20:07.668]                             invokeRestart(restart)
[13:20:07.668]                             muffled <- TRUE
[13:20:07.668]                             break
[13:20:07.668]                           }
[13:20:07.668]                         }
[13:20:07.668]                       }
[13:20:07.668]                       invisible(muffled)
[13:20:07.668]                     }
[13:20:07.668]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.668]                   }
[13:20:07.668]                 }
[13:20:07.668]             }
[13:20:07.668]         }))
[13:20:07.668]     }, error = function(ex) {
[13:20:07.668]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:07.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.668]                 ...future.rng), started = ...future.startTime, 
[13:20:07.668]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:07.668]             version = "1.8"), class = "FutureResult")
[13:20:07.668]     }, finally = {
[13:20:07.668]         if (!identical(...future.workdir, getwd())) 
[13:20:07.668]             setwd(...future.workdir)
[13:20:07.668]         {
[13:20:07.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:07.668]                 ...future.oldOptions$nwarnings <- NULL
[13:20:07.668]             }
[13:20:07.668]             base::options(...future.oldOptions)
[13:20:07.668]             if (.Platform$OS.type == "windows") {
[13:20:07.668]                 old_names <- names(...future.oldEnvVars)
[13:20:07.668]                 envs <- base::Sys.getenv()
[13:20:07.668]                 names <- names(envs)
[13:20:07.668]                 common <- intersect(names, old_names)
[13:20:07.668]                 added <- setdiff(names, old_names)
[13:20:07.668]                 removed <- setdiff(old_names, names)
[13:20:07.668]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:07.668]                   envs[common]]
[13:20:07.668]                 NAMES <- toupper(changed)
[13:20:07.668]                 args <- list()
[13:20:07.668]                 for (kk in seq_along(NAMES)) {
[13:20:07.668]                   name <- changed[[kk]]
[13:20:07.668]                   NAME <- NAMES[[kk]]
[13:20:07.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.668]                     next
[13:20:07.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.668]                 }
[13:20:07.668]                 NAMES <- toupper(added)
[13:20:07.668]                 for (kk in seq_along(NAMES)) {
[13:20:07.668]                   name <- added[[kk]]
[13:20:07.668]                   NAME <- NAMES[[kk]]
[13:20:07.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.668]                     next
[13:20:07.668]                   args[[name]] <- ""
[13:20:07.668]                 }
[13:20:07.668]                 NAMES <- toupper(removed)
[13:20:07.668]                 for (kk in seq_along(NAMES)) {
[13:20:07.668]                   name <- removed[[kk]]
[13:20:07.668]                   NAME <- NAMES[[kk]]
[13:20:07.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.668]                     next
[13:20:07.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.668]                 }
[13:20:07.668]                 if (length(args) > 0) 
[13:20:07.668]                   base::do.call(base::Sys.setenv, args = args)
[13:20:07.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:07.668]             }
[13:20:07.668]             else {
[13:20:07.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:07.668]             }
[13:20:07.668]             {
[13:20:07.668]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:07.668]                   0L) {
[13:20:07.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:07.668]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:07.668]                   base::options(opts)
[13:20:07.668]                 }
[13:20:07.668]                 {
[13:20:07.668]                   {
[13:20:07.668]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:07.668]                     NULL
[13:20:07.668]                   }
[13:20:07.668]                   options(future.plan = NULL)
[13:20:07.668]                   if (is.na(NA_character_)) 
[13:20:07.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:07.668]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:07.668]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:07.668]                     envir = parent.frame()) 
[13:20:07.668]                   {
[13:20:07.668]                     if (is.function(workers)) 
[13:20:07.668]                       workers <- workers()
[13:20:07.668]                     workers <- structure(as.integer(workers), 
[13:20:07.668]                       class = class(workers))
[13:20:07.668]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:07.668]                       workers >= 1)
[13:20:07.668]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:07.668]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:07.668]                     }
[13:20:07.668]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:07.668]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:07.668]                       envir = envir)
[13:20:07.668]                     if (!future$lazy) 
[13:20:07.668]                       future <- run(future)
[13:20:07.668]                     invisible(future)
[13:20:07.668]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:07.668]                 }
[13:20:07.668]             }
[13:20:07.668]         }
[13:20:07.668]     })
[13:20:07.668]     if (TRUE) {
[13:20:07.668]         base::sink(type = "output", split = FALSE)
[13:20:07.668]         if (TRUE) {
[13:20:07.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:07.668]         }
[13:20:07.668]         else {
[13:20:07.668]             ...future.result["stdout"] <- base::list(NULL)
[13:20:07.668]         }
[13:20:07.668]         base::close(...future.stdout)
[13:20:07.668]         ...future.stdout <- NULL
[13:20:07.668]     }
[13:20:07.668]     ...future.result$conditions <- ...future.conditions
[13:20:07.668]     ...future.result$finished <- base::Sys.time()
[13:20:07.668]     ...future.result
[13:20:07.668] }
[13:20:07.671] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[13:20:07.672] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:20:07.672] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:20:07.672] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:07.673] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:07.673] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:20:07.673] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:20:07.673] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:07.674] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:07.674] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:20:07.674] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:20:07.674] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[13:20:07.675] MultisessionFuture started
[13:20:07.675] - Launch lazy future ... done
[13:20:07.675] run() for ‘MultisessionFuture’ ... done
[13:20:07.675] Created future:
[13:20:07.675] MultisessionFuture:
[13:20:07.675] Label: ‘future_eapply-1’
[13:20:07.675] Expression:
[13:20:07.675] {
[13:20:07.675]     do.call(function(...) {
[13:20:07.675]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.675]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.675]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.675]             on.exit(options(oopts), add = TRUE)
[13:20:07.675]         }
[13:20:07.675]         {
[13:20:07.675]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.675]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.675]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.675]             })
[13:20:07.675]         }
[13:20:07.675]     }, args = future.call.arguments)
[13:20:07.675] }
[13:20:07.675] Lazy evaluation: FALSE
[13:20:07.675] Asynchronous evaluation: TRUE
[13:20:07.675] Local evaluation: TRUE
[13:20:07.675] Environment: R_GlobalEnv
[13:20:07.675] Capture standard output: TRUE
[13:20:07.675] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:07.675] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:07.675] Packages: 1 packages (‘stats’)
[13:20:07.675] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:07.675] Resolved: FALSE
[13:20:07.675] Value: <not collected>
[13:20:07.675] Conditions captured: <none>
[13:20:07.675] Early signaling: FALSE
[13:20:07.675] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:07.675] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.687] Chunk #1 of 2 ... DONE
[13:20:07.687] Chunk #2 of 2 ...
[13:20:07.687]  - Finding globals in 'X' for chunk #2 ...
[13:20:07.687] getGlobalsAndPackages() ...
[13:20:07.688] Searching for globals...
[13:20:07.688] 
[13:20:07.688] Searching for globals ... DONE
[13:20:07.688] - globals: [0] <none>
[13:20:07.688] getGlobalsAndPackages() ... DONE
[13:20:07.688]    + additional globals found: [n=0] 
[13:20:07.688]    + additional namespaces needed: [n=0] 
[13:20:07.688]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:07.689]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:07.689]  - seeds: <none>
[13:20:07.689]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.689] getGlobalsAndPackages() ...
[13:20:07.689] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.689] Resolving globals: FALSE
[13:20:07.689] Tweak future expression to call with '...' arguments ...
[13:20:07.689] {
[13:20:07.689]     do.call(function(...) {
[13:20:07.689]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.689]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.689]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.689]             on.exit(options(oopts), add = TRUE)
[13:20:07.689]         }
[13:20:07.689]         {
[13:20:07.689]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.689]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.689]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.689]             })
[13:20:07.689]         }
[13:20:07.689]     }, args = future.call.arguments)
[13:20:07.689] }
[13:20:07.690] Tweak future expression to call with '...' arguments ... DONE
[13:20:07.690] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:07.693] - packages: [1] ‘stats’
[13:20:07.693] getGlobalsAndPackages() ... DONE
[13:20:07.693] run() for ‘Future’ ...
[13:20:07.693] - state: ‘created’
[13:20:07.693] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:07.708] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.708] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:07.708]   - Field: ‘node’
[13:20:07.709]   - Field: ‘label’
[13:20:07.709]   - Field: ‘local’
[13:20:07.709]   - Field: ‘owner’
[13:20:07.709]   - Field: ‘envir’
[13:20:07.709]   - Field: ‘workers’
[13:20:07.709]   - Field: ‘packages’
[13:20:07.709]   - Field: ‘gc’
[13:20:07.709]   - Field: ‘conditions’
[13:20:07.709]   - Field: ‘persistent’
[13:20:07.709]   - Field: ‘expr’
[13:20:07.710]   - Field: ‘uuid’
[13:20:07.710]   - Field: ‘seed’
[13:20:07.710]   - Field: ‘version’
[13:20:07.710]   - Field: ‘result’
[13:20:07.710]   - Field: ‘asynchronous’
[13:20:07.710]   - Field: ‘calls’
[13:20:07.710]   - Field: ‘globals’
[13:20:07.710]   - Field: ‘stdout’
[13:20:07.710]   - Field: ‘earlySignal’
[13:20:07.710]   - Field: ‘lazy’
[13:20:07.710]   - Field: ‘state’
[13:20:07.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:07.711] - Launch lazy future ...
[13:20:07.711] Packages needed by the future expression (n = 1): ‘stats’
[13:20:07.711] Packages needed by future strategies (n = 0): <none>
[13:20:07.712] {
[13:20:07.712]     {
[13:20:07.712]         {
[13:20:07.712]             ...future.startTime <- base::Sys.time()
[13:20:07.712]             {
[13:20:07.712]                 {
[13:20:07.712]                   {
[13:20:07.712]                     {
[13:20:07.712]                       {
[13:20:07.712]                         base::local({
[13:20:07.712]                           has_future <- base::requireNamespace("future", 
[13:20:07.712]                             quietly = TRUE)
[13:20:07.712]                           if (has_future) {
[13:20:07.712]                             ns <- base::getNamespace("future")
[13:20:07.712]                             version <- ns[[".package"]][["version"]]
[13:20:07.712]                             if (is.null(version)) 
[13:20:07.712]                               version <- utils::packageVersion("future")
[13:20:07.712]                           }
[13:20:07.712]                           else {
[13:20:07.712]                             version <- NULL
[13:20:07.712]                           }
[13:20:07.712]                           if (!has_future || version < "1.8.0") {
[13:20:07.712]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:07.712]                               "", base::R.version$version.string), 
[13:20:07.712]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:07.712]                                 base::R.version$platform, 8 * 
[13:20:07.712]                                   base::.Machine$sizeof.pointer), 
[13:20:07.712]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:07.712]                                 "release", "version")], collapse = " "), 
[13:20:07.712]                               hostname = base::Sys.info()[["nodename"]])
[13:20:07.712]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:07.712]                               info)
[13:20:07.712]                             info <- base::paste(info, collapse = "; ")
[13:20:07.712]                             if (!has_future) {
[13:20:07.712]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:07.712]                                 info)
[13:20:07.712]                             }
[13:20:07.712]                             else {
[13:20:07.712]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:07.712]                                 info, version)
[13:20:07.712]                             }
[13:20:07.712]                             base::stop(msg)
[13:20:07.712]                           }
[13:20:07.712]                         })
[13:20:07.712]                       }
[13:20:07.712]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:07.712]                       base::options(mc.cores = 1L)
[13:20:07.712]                     }
[13:20:07.712]                     base::local({
[13:20:07.712]                       for (pkg in "stats") {
[13:20:07.712]                         base::loadNamespace(pkg)
[13:20:07.712]                         base::library(pkg, character.only = TRUE)
[13:20:07.712]                       }
[13:20:07.712]                     })
[13:20:07.712]                   }
[13:20:07.712]                   options(future.plan = NULL)
[13:20:07.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:07.712]                 }
[13:20:07.712]                 ...future.workdir <- getwd()
[13:20:07.712]             }
[13:20:07.712]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:07.712]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:07.712]         }
[13:20:07.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:07.712]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:07.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:07.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:07.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:07.712]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:07.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:07.712]             base::names(...future.oldOptions))
[13:20:07.712]     }
[13:20:07.712]     if (FALSE) {
[13:20:07.712]     }
[13:20:07.712]     else {
[13:20:07.712]         if (TRUE) {
[13:20:07.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:07.712]                 open = "w")
[13:20:07.712]         }
[13:20:07.712]         else {
[13:20:07.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:07.712]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:07.712]         }
[13:20:07.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:07.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:07.712]             base::sink(type = "output", split = FALSE)
[13:20:07.712]             base::close(...future.stdout)
[13:20:07.712]         }, add = TRUE)
[13:20:07.712]     }
[13:20:07.712]     ...future.frame <- base::sys.nframe()
[13:20:07.712]     ...future.conditions <- base::list()
[13:20:07.712]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:07.712]     if (FALSE) {
[13:20:07.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:07.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:07.712]     }
[13:20:07.712]     ...future.result <- base::tryCatch({
[13:20:07.712]         base::withCallingHandlers({
[13:20:07.712]             ...future.value <- base::withVisible(base::local({
[13:20:07.712]                 ...future.makeSendCondition <- base::local({
[13:20:07.712]                   sendCondition <- NULL
[13:20:07.712]                   function(frame = 1L) {
[13:20:07.712]                     if (is.function(sendCondition)) 
[13:20:07.712]                       return(sendCondition)
[13:20:07.712]                     ns <- getNamespace("parallel")
[13:20:07.712]                     if (exists("sendData", mode = "function", 
[13:20:07.712]                       envir = ns)) {
[13:20:07.712]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:07.712]                         envir = ns)
[13:20:07.712]                       envir <- sys.frame(frame)
[13:20:07.712]                       master <- NULL
[13:20:07.712]                       while (!identical(envir, .GlobalEnv) && 
[13:20:07.712]                         !identical(envir, emptyenv())) {
[13:20:07.712]                         if (exists("master", mode = "list", envir = envir, 
[13:20:07.712]                           inherits = FALSE)) {
[13:20:07.712]                           master <- get("master", mode = "list", 
[13:20:07.712]                             envir = envir, inherits = FALSE)
[13:20:07.712]                           if (inherits(master, c("SOCKnode", 
[13:20:07.712]                             "SOCK0node"))) {
[13:20:07.712]                             sendCondition <<- function(cond) {
[13:20:07.712]                               data <- list(type = "VALUE", value = cond, 
[13:20:07.712]                                 success = TRUE)
[13:20:07.712]                               parallel_sendData(master, data)
[13:20:07.712]                             }
[13:20:07.712]                             return(sendCondition)
[13:20:07.712]                           }
[13:20:07.712]                         }
[13:20:07.712]                         frame <- frame + 1L
[13:20:07.712]                         envir <- sys.frame(frame)
[13:20:07.712]                       }
[13:20:07.712]                     }
[13:20:07.712]                     sendCondition <<- function(cond) NULL
[13:20:07.712]                   }
[13:20:07.712]                 })
[13:20:07.712]                 withCallingHandlers({
[13:20:07.712]                   {
[13:20:07.712]                     do.call(function(...) {
[13:20:07.712]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.712]                       if (!identical(...future.globals.maxSize.org, 
[13:20:07.712]                         ...future.globals.maxSize)) {
[13:20:07.712]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.712]                         on.exit(options(oopts), add = TRUE)
[13:20:07.712]                       }
[13:20:07.712]                       {
[13:20:07.712]                         lapply(seq_along(...future.elements_ii), 
[13:20:07.712]                           FUN = function(jj) {
[13:20:07.712]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.712]                             ...future.FUN(...future.X_jj, ...)
[13:20:07.712]                           })
[13:20:07.712]                       }
[13:20:07.712]                     }, args = future.call.arguments)
[13:20:07.712]                   }
[13:20:07.712]                 }, immediateCondition = function(cond) {
[13:20:07.712]                   sendCondition <- ...future.makeSendCondition()
[13:20:07.712]                   sendCondition(cond)
[13:20:07.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.712]                   {
[13:20:07.712]                     inherits <- base::inherits
[13:20:07.712]                     invokeRestart <- base::invokeRestart
[13:20:07.712]                     is.null <- base::is.null
[13:20:07.712]                     muffled <- FALSE
[13:20:07.712]                     if (inherits(cond, "message")) {
[13:20:07.712]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:07.712]                       if (muffled) 
[13:20:07.712]                         invokeRestart("muffleMessage")
[13:20:07.712]                     }
[13:20:07.712]                     else if (inherits(cond, "warning")) {
[13:20:07.712]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:07.712]                       if (muffled) 
[13:20:07.712]                         invokeRestart("muffleWarning")
[13:20:07.712]                     }
[13:20:07.712]                     else if (inherits(cond, "condition")) {
[13:20:07.712]                       if (!is.null(pattern)) {
[13:20:07.712]                         computeRestarts <- base::computeRestarts
[13:20:07.712]                         grepl <- base::grepl
[13:20:07.712]                         restarts <- computeRestarts(cond)
[13:20:07.712]                         for (restart in restarts) {
[13:20:07.712]                           name <- restart$name
[13:20:07.712]                           if (is.null(name)) 
[13:20:07.712]                             next
[13:20:07.712]                           if (!grepl(pattern, name)) 
[13:20:07.712]                             next
[13:20:07.712]                           invokeRestart(restart)
[13:20:07.712]                           muffled <- TRUE
[13:20:07.712]                           break
[13:20:07.712]                         }
[13:20:07.712]                       }
[13:20:07.712]                     }
[13:20:07.712]                     invisible(muffled)
[13:20:07.712]                   }
[13:20:07.712]                   muffleCondition(cond)
[13:20:07.712]                 })
[13:20:07.712]             }))
[13:20:07.712]             future::FutureResult(value = ...future.value$value, 
[13:20:07.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.712]                   ...future.rng), globalenv = if (FALSE) 
[13:20:07.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:07.712]                     ...future.globalenv.names))
[13:20:07.712]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:07.712]         }, condition = base::local({
[13:20:07.712]             c <- base::c
[13:20:07.712]             inherits <- base::inherits
[13:20:07.712]             invokeRestart <- base::invokeRestart
[13:20:07.712]             length <- base::length
[13:20:07.712]             list <- base::list
[13:20:07.712]             seq.int <- base::seq.int
[13:20:07.712]             signalCondition <- base::signalCondition
[13:20:07.712]             sys.calls <- base::sys.calls
[13:20:07.712]             `[[` <- base::`[[`
[13:20:07.712]             `+` <- base::`+`
[13:20:07.712]             `<<-` <- base::`<<-`
[13:20:07.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:07.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:07.712]                   3L)]
[13:20:07.712]             }
[13:20:07.712]             function(cond) {
[13:20:07.712]                 is_error <- inherits(cond, "error")
[13:20:07.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:07.712]                   NULL)
[13:20:07.712]                 if (is_error) {
[13:20:07.712]                   sessionInformation <- function() {
[13:20:07.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:07.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:07.712]                       search = base::search(), system = base::Sys.info())
[13:20:07.712]                   }
[13:20:07.712]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:07.712]                     cond$call), session = sessionInformation(), 
[13:20:07.712]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:07.712]                   signalCondition(cond)
[13:20:07.712]                 }
[13:20:07.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:07.712]                 "immediateCondition"))) {
[13:20:07.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:07.712]                   ...future.conditions[[length(...future.conditions) + 
[13:20:07.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:07.712]                   if (TRUE && !signal) {
[13:20:07.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.712]                     {
[13:20:07.712]                       inherits <- base::inherits
[13:20:07.712]                       invokeRestart <- base::invokeRestart
[13:20:07.712]                       is.null <- base::is.null
[13:20:07.712]                       muffled <- FALSE
[13:20:07.712]                       if (inherits(cond, "message")) {
[13:20:07.712]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.712]                         if (muffled) 
[13:20:07.712]                           invokeRestart("muffleMessage")
[13:20:07.712]                       }
[13:20:07.712]                       else if (inherits(cond, "warning")) {
[13:20:07.712]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.712]                         if (muffled) 
[13:20:07.712]                           invokeRestart("muffleWarning")
[13:20:07.712]                       }
[13:20:07.712]                       else if (inherits(cond, "condition")) {
[13:20:07.712]                         if (!is.null(pattern)) {
[13:20:07.712]                           computeRestarts <- base::computeRestarts
[13:20:07.712]                           grepl <- base::grepl
[13:20:07.712]                           restarts <- computeRestarts(cond)
[13:20:07.712]                           for (restart in restarts) {
[13:20:07.712]                             name <- restart$name
[13:20:07.712]                             if (is.null(name)) 
[13:20:07.712]                               next
[13:20:07.712]                             if (!grepl(pattern, name)) 
[13:20:07.712]                               next
[13:20:07.712]                             invokeRestart(restart)
[13:20:07.712]                             muffled <- TRUE
[13:20:07.712]                             break
[13:20:07.712]                           }
[13:20:07.712]                         }
[13:20:07.712]                       }
[13:20:07.712]                       invisible(muffled)
[13:20:07.712]                     }
[13:20:07.712]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.712]                   }
[13:20:07.712]                 }
[13:20:07.712]                 else {
[13:20:07.712]                   if (TRUE) {
[13:20:07.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:07.712]                     {
[13:20:07.712]                       inherits <- base::inherits
[13:20:07.712]                       invokeRestart <- base::invokeRestart
[13:20:07.712]                       is.null <- base::is.null
[13:20:07.712]                       muffled <- FALSE
[13:20:07.712]                       if (inherits(cond, "message")) {
[13:20:07.712]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:07.712]                         if (muffled) 
[13:20:07.712]                           invokeRestart("muffleMessage")
[13:20:07.712]                       }
[13:20:07.712]                       else if (inherits(cond, "warning")) {
[13:20:07.712]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:07.712]                         if (muffled) 
[13:20:07.712]                           invokeRestart("muffleWarning")
[13:20:07.712]                       }
[13:20:07.712]                       else if (inherits(cond, "condition")) {
[13:20:07.712]                         if (!is.null(pattern)) {
[13:20:07.712]                           computeRestarts <- base::computeRestarts
[13:20:07.712]                           grepl <- base::grepl
[13:20:07.712]                           restarts <- computeRestarts(cond)
[13:20:07.712]                           for (restart in restarts) {
[13:20:07.712]                             name <- restart$name
[13:20:07.712]                             if (is.null(name)) 
[13:20:07.712]                               next
[13:20:07.712]                             if (!grepl(pattern, name)) 
[13:20:07.712]                               next
[13:20:07.712]                             invokeRestart(restart)
[13:20:07.712]                             muffled <- TRUE
[13:20:07.712]                             break
[13:20:07.712]                           }
[13:20:07.712]                         }
[13:20:07.712]                       }
[13:20:07.712]                       invisible(muffled)
[13:20:07.712]                     }
[13:20:07.712]                     muffleCondition(cond, pattern = "^muffle")
[13:20:07.712]                   }
[13:20:07.712]                 }
[13:20:07.712]             }
[13:20:07.712]         }))
[13:20:07.712]     }, error = function(ex) {
[13:20:07.712]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:07.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:07.712]                 ...future.rng), started = ...future.startTime, 
[13:20:07.712]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:07.712]             version = "1.8"), class = "FutureResult")
[13:20:07.712]     }, finally = {
[13:20:07.712]         if (!identical(...future.workdir, getwd())) 
[13:20:07.712]             setwd(...future.workdir)
[13:20:07.712]         {
[13:20:07.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:07.712]                 ...future.oldOptions$nwarnings <- NULL
[13:20:07.712]             }
[13:20:07.712]             base::options(...future.oldOptions)
[13:20:07.712]             if (.Platform$OS.type == "windows") {
[13:20:07.712]                 old_names <- names(...future.oldEnvVars)
[13:20:07.712]                 envs <- base::Sys.getenv()
[13:20:07.712]                 names <- names(envs)
[13:20:07.712]                 common <- intersect(names, old_names)
[13:20:07.712]                 added <- setdiff(names, old_names)
[13:20:07.712]                 removed <- setdiff(old_names, names)
[13:20:07.712]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:07.712]                   envs[common]]
[13:20:07.712]                 NAMES <- toupper(changed)
[13:20:07.712]                 args <- list()
[13:20:07.712]                 for (kk in seq_along(NAMES)) {
[13:20:07.712]                   name <- changed[[kk]]
[13:20:07.712]                   NAME <- NAMES[[kk]]
[13:20:07.712]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.712]                     next
[13:20:07.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.712]                 }
[13:20:07.712]                 NAMES <- toupper(added)
[13:20:07.712]                 for (kk in seq_along(NAMES)) {
[13:20:07.712]                   name <- added[[kk]]
[13:20:07.712]                   NAME <- NAMES[[kk]]
[13:20:07.712]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.712]                     next
[13:20:07.712]                   args[[name]] <- ""
[13:20:07.712]                 }
[13:20:07.712]                 NAMES <- toupper(removed)
[13:20:07.712]                 for (kk in seq_along(NAMES)) {
[13:20:07.712]                   name <- removed[[kk]]
[13:20:07.712]                   NAME <- NAMES[[kk]]
[13:20:07.712]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:07.712]                     next
[13:20:07.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:07.712]                 }
[13:20:07.712]                 if (length(args) > 0) 
[13:20:07.712]                   base::do.call(base::Sys.setenv, args = args)
[13:20:07.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:07.712]             }
[13:20:07.712]             else {
[13:20:07.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:07.712]             }
[13:20:07.712]             {
[13:20:07.712]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:07.712]                   0L) {
[13:20:07.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:07.712]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:07.712]                   base::options(opts)
[13:20:07.712]                 }
[13:20:07.712]                 {
[13:20:07.712]                   {
[13:20:07.712]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:07.712]                     NULL
[13:20:07.712]                   }
[13:20:07.712]                   options(future.plan = NULL)
[13:20:07.712]                   if (is.na(NA_character_)) 
[13:20:07.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:07.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:07.712]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:07.712]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:07.712]                     envir = parent.frame()) 
[13:20:07.712]                   {
[13:20:07.712]                     if (is.function(workers)) 
[13:20:07.712]                       workers <- workers()
[13:20:07.712]                     workers <- structure(as.integer(workers), 
[13:20:07.712]                       class = class(workers))
[13:20:07.712]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:07.712]                       workers >= 1)
[13:20:07.712]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:07.712]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:07.712]                     }
[13:20:07.712]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:07.712]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:07.712]                       envir = envir)
[13:20:07.712]                     if (!future$lazy) 
[13:20:07.712]                       future <- run(future)
[13:20:07.712]                     invisible(future)
[13:20:07.712]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:07.712]                 }
[13:20:07.712]             }
[13:20:07.712]         }
[13:20:07.712]     })
[13:20:07.712]     if (TRUE) {
[13:20:07.712]         base::sink(type = "output", split = FALSE)
[13:20:07.712]         if (TRUE) {
[13:20:07.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:07.712]         }
[13:20:07.712]         else {
[13:20:07.712]             ...future.result["stdout"] <- base::list(NULL)
[13:20:07.712]         }
[13:20:07.712]         base::close(...future.stdout)
[13:20:07.712]         ...future.stdout <- NULL
[13:20:07.712]     }
[13:20:07.712]     ...future.result$conditions <- ...future.conditions
[13:20:07.712]     ...future.result$finished <- base::Sys.time()
[13:20:07.712]     ...future.result
[13:20:07.712] }
[13:20:07.715] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[13:20:07.715] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:20:07.715] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:20:07.716] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:07.716] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:07.716] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:20:07.717] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:20:07.717] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:07.717] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:07.717] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:20:07.718] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:20:07.718] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[13:20:07.719] MultisessionFuture started
[13:20:07.719] - Launch lazy future ... done
[13:20:07.719] run() for ‘MultisessionFuture’ ... done
[13:20:07.719] Created future:
[13:20:07.719] MultisessionFuture:
[13:20:07.719] Label: ‘future_eapply-2’
[13:20:07.719] Expression:
[13:20:07.719] {
[13:20:07.719]     do.call(function(...) {
[13:20:07.719]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:07.719]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:07.719]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:07.719]             on.exit(options(oopts), add = TRUE)
[13:20:07.719]         }
[13:20:07.719]         {
[13:20:07.719]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:07.719]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:07.719]                 ...future.FUN(...future.X_jj, ...)
[13:20:07.719]             })
[13:20:07.719]         }
[13:20:07.719]     }, args = future.call.arguments)
[13:20:07.719] }
[13:20:07.719] Lazy evaluation: FALSE
[13:20:07.719] Asynchronous evaluation: TRUE
[13:20:07.719] Local evaluation: TRUE
[13:20:07.719] Environment: R_GlobalEnv
[13:20:07.719] Capture standard output: TRUE
[13:20:07.719] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:07.719] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:07.719] Packages: 1 packages (‘stats’)
[13:20:07.719] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:07.719] Resolved: FALSE
[13:20:07.719] Value: <not collected>
[13:20:07.719] Conditions captured: <none>
[13:20:07.719] Early signaling: FALSE
[13:20:07.719] Owner process: 0893d5a3-996e-67fb-9d07-ca0744e0a85f
[13:20:07.719] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:07.731] Chunk #2 of 2 ... DONE
[13:20:07.731] Launching 2 futures (chunks) ... DONE
[13:20:07.731] Resolving 2 futures (chunks) ...
[13:20:07.731] resolve() on list ...
[13:20:07.731]  recursive: 0
[13:20:07.732]  length: 2
[13:20:07.732] 
[13:20:07.732] receiveMessageFromWorker() for ClusterFuture ...
[13:20:07.732] - Validating connection of MultisessionFuture
[13:20:07.733] - received message: FutureResult
[13:20:07.733] - Received FutureResult
[13:20:07.733] - Erased future from FutureRegistry
[13:20:07.733] result() for ClusterFuture ...
[13:20:07.733] - result already collected: FutureResult
[13:20:07.733] result() for ClusterFuture ... done
[13:20:07.733] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:07.733] Future #1
[13:20:07.733] result() for ClusterFuture ...
[13:20:07.733] - result already collected: FutureResult
[13:20:07.734] result() for ClusterFuture ... done
[13:20:07.734] result() for ClusterFuture ...
[13:20:07.734] - result already collected: FutureResult
[13:20:07.734] result() for ClusterFuture ... done
[13:20:07.734] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:07.734] - nx: 2
[13:20:07.734] - relay: TRUE
[13:20:07.734] - stdout: TRUE
[13:20:07.734] - signal: TRUE
[13:20:07.734] - resignal: FALSE
[13:20:07.734] - force: TRUE
[13:20:07.735] - relayed: [n=2] FALSE, FALSE
[13:20:07.735] - queued futures: [n=2] FALSE, FALSE
[13:20:07.735]  - until=1
[13:20:07.735]  - relaying element #1
[13:20:07.735] result() for ClusterFuture ...
[13:20:07.735] - result already collected: FutureResult
[13:20:07.735] result() for ClusterFuture ... done
[13:20:07.735] result() for ClusterFuture ...
[13:20:07.735] - result already collected: FutureResult
[13:20:07.735] result() for ClusterFuture ... done
[13:20:07.735] result() for ClusterFuture ...
[13:20:07.736] - result already collected: FutureResult
[13:20:07.736] result() for ClusterFuture ... done
[13:20:07.736] result() for ClusterFuture ...
[13:20:07.736] - result already collected: FutureResult
[13:20:07.736] result() for ClusterFuture ... done
[13:20:07.736] - relayed: [n=2] TRUE, FALSE
[13:20:07.736] - queued futures: [n=2] TRUE, FALSE
[13:20:07.736] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:07.736]  length: 1 (resolved future 1)
[13:20:07.766] receiveMessageFromWorker() for ClusterFuture ...
[13:20:07.766] - Validating connection of MultisessionFuture
[13:20:07.766] - received message: FutureResult
[13:20:07.766] - Received FutureResult
[13:20:07.767] - Erased future from FutureRegistry
[13:20:07.767] result() for ClusterFuture ...
[13:20:07.767] - result already collected: FutureResult
[13:20:07.767] result() for ClusterFuture ... done
[13:20:07.767] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:07.767] Future #2
[13:20:07.767] result() for ClusterFuture ...
[13:20:07.767] - result already collected: FutureResult
[13:20:07.767] result() for ClusterFuture ... done
[13:20:07.768] result() for ClusterFuture ...
[13:20:07.768] - result already collected: FutureResult
[13:20:07.768] result() for ClusterFuture ... done
[13:20:07.768] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:07.768] - nx: 2
[13:20:07.768] - relay: TRUE
[13:20:07.768] - stdout: TRUE
[13:20:07.768] - signal: TRUE
[13:20:07.768] - resignal: FALSE
[13:20:07.768] - force: TRUE
[13:20:07.769] - relayed: [n=2] TRUE, FALSE
[13:20:07.769] - queued futures: [n=2] TRUE, FALSE
[13:20:07.769]  - until=2
[13:20:07.769]  - relaying element #2
[13:20:07.769] result() for ClusterFuture ...
[13:20:07.769] - result already collected: FutureResult
[13:20:07.769] result() for ClusterFuture ... done
[13:20:07.769] result() for ClusterFuture ...
[13:20:07.769] - result already collected: FutureResult
[13:20:07.769] result() for ClusterFuture ... done
[13:20:07.770] result() for ClusterFuture ...
[13:20:07.770] - result already collected: FutureResult
[13:20:07.770] result() for ClusterFuture ... done
[13:20:07.770] result() for ClusterFuture ...
[13:20:07.770] - result already collected: FutureResult
[13:20:07.770] result() for ClusterFuture ... done
[13:20:07.770] - relayed: [n=2] TRUE, TRUE
[13:20:07.770] - queued futures: [n=2] TRUE, TRUE
[13:20:07.770] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:07.770]  length: 0 (resolved future 2)
[13:20:07.770] Relaying remaining futures
[13:20:07.771] signalConditionsASAP(NULL, pos=0) ...
[13:20:07.771] - nx: 2
[13:20:07.771] - relay: TRUE
[13:20:07.771] - stdout: TRUE
[13:20:07.771] - signal: TRUE
[13:20:07.771] - resignal: FALSE
[13:20:07.771] - force: TRUE
[13:20:07.771] - relayed: [n=2] TRUE, TRUE
[13:20:07.771] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:07.771] - relayed: [n=2] TRUE, TRUE
[13:20:07.772] - queued futures: [n=2] TRUE, TRUE
[13:20:07.772] signalConditionsASAP(NULL, pos=0) ... done
[13:20:07.772] resolve() on list ... DONE
[13:20:07.772] result() for ClusterFuture ...
[13:20:07.772] - result already collected: FutureResult
[13:20:07.772] result() for ClusterFuture ... done
[13:20:07.772] result() for ClusterFuture ...
[13:20:07.772] - result already collected: FutureResult
[13:20:07.772] result() for ClusterFuture ... done
[13:20:07.772] result() for ClusterFuture ...
[13:20:07.772] - result already collected: FutureResult
[13:20:07.773] result() for ClusterFuture ... done
[13:20:07.773] result() for ClusterFuture ...
[13:20:07.773] - result already collected: FutureResult
[13:20:07.773] result() for ClusterFuture ... done
[13:20:07.773]  - Number of value chunks collected: 2
[13:20:07.773] Resolving 2 futures (chunks) ... DONE
[13:20:07.773] Reducing values from 2 chunks ...
[13:20:07.773]  - Number of values collected after concatenation: 3
[13:20:07.773]  - Number of values expected: 3
[13:20:07.773] Reducing values from 2 chunks ... DONE
[13:20:07.774] future_lapply() ... DONE
[13:20:07.774] plan(): Setting new future strategy stack:
[13:20:07.774] List of future strategies:
[13:20:07.774] 1. sequential:
[13:20:07.774]    - args: function (..., envir = parent.frame())
[13:20:07.774]    - tweaked: FALSE
[13:20:07.774]    - call: plan(sequential)
[13:20:07.775] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[13:20:07.776] plan(): Setting new future strategy stack:
[13:20:07.776] List of future strategies:
[13:20:07.776] 1. FutureStrategy:
[13:20:07.776]    - args: function (..., envir = parent.frame())
[13:20:07.776]    - tweaked: FALSE
[13:20:07.776]    - call: future::plan(oplan)
[13:20:07.777] plan(): nbrOfWorkers() = 1
> 
