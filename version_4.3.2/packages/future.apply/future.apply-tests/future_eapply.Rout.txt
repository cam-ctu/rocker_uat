
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:01:48.778] plan(): Setting new future strategy stack:
[16:01:48.778] List of future strategies:
[16:01:48.778] 1. sequential:
[16:01:48.778]    - args: function (..., envir = parent.frame())
[16:01:48.778]    - tweaked: FALSE
[16:01:48.778]    - call: future::plan("sequential")
[16:01:48.792] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:01:48.814] plan(): Setting new future strategy stack:
[16:01:48.814] List of future strategies:
[16:01:48.814] 1. sequential:
[16:01:48.814]    - args: function (..., envir = parent.frame())
[16:01:48.814]    - tweaked: FALSE
[16:01:48.814]    - call: plan(strategy)
[16:01:48.827] plan(): nbrOfWorkers() = 1
[16:01:48.827] future_lapply() ...
[16:01:48.832] Number of chunks: 1
[16:01:48.832] getGlobalsAndPackagesXApply() ...
[16:01:48.832]  - future.globals: TRUE
[16:01:48.833] getGlobalsAndPackages() ...
[16:01:48.833] Searching for globals...
[16:01:48.835] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:48.835] Searching for globals ... DONE
[16:01:48.836] Resolving globals: FALSE
[16:01:48.837] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:48.837] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:48.837] - globals: [1] ‘FUN’
[16:01:48.837] 
[16:01:48.837] getGlobalsAndPackages() ... DONE
[16:01:48.837]  - globals found/used: [n=1] ‘FUN’
[16:01:48.837]  - needed namespaces: [n=0] 
[16:01:48.838] Finding globals ... DONE
[16:01:48.838]  - use_args: TRUE
[16:01:48.838]  - Getting '...' globals ...
[16:01:48.839] resolve() on list ...
[16:01:48.839]  recursive: 0
[16:01:48.839]  length: 1
[16:01:48.839]  elements: ‘...’
[16:01:48.839]  length: 0 (resolved future 1)
[16:01:48.839] resolve() on list ... DONE
[16:01:48.839]    - '...' content: [n=0] 
[16:01:48.840] List of 1
[16:01:48.840]  $ ...: list()
[16:01:48.840]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.840]  - attr(*, "where")=List of 1
[16:01:48.840]   ..$ ...:<environment: 0x56209f60ab30> 
[16:01:48.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.840]  - attr(*, "resolved")= logi TRUE
[16:01:48.840]  - attr(*, "total_size")= num NA
[16:01:48.844]  - Getting '...' globals ... DONE
[16:01:48.845] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:48.845] List of 2
[16:01:48.845]  $ ...future.FUN:function (x, ...)  
[16:01:48.845]  $ ...          : list()
[16:01:48.845]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.845]  - attr(*, "where")=List of 2
[16:01:48.845]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:48.845]   ..$ ...          :<environment: 0x56209f60ab30> 
[16:01:48.845]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.845]  - attr(*, "resolved")= logi FALSE
[16:01:48.845]  - attr(*, "total_size")= num 1240
[16:01:48.847] Packages to be attached in all futures: [n=0] 
[16:01:48.847] getGlobalsAndPackagesXApply() ... DONE
[16:01:48.848] Number of futures (= number of chunks): 1
[16:01:48.848] Launching 1 futures (chunks) ...
[16:01:48.848] Chunk #1 of 1 ...
[16:01:48.848]  - Finding globals in 'X' for chunk #1 ...
[16:01:48.848] getGlobalsAndPackages() ...
[16:01:48.848] Searching for globals...
[16:01:48.849] 
[16:01:48.849] Searching for globals ... DONE
[16:01:48.849] - globals: [0] <none>
[16:01:48.849] getGlobalsAndPackages() ... DONE
[16:01:48.849]    + additional globals found: [n=0] 
[16:01:48.849]    + additional namespaces needed: [n=0] 
[16:01:48.849]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:48.849]  - seeds: <none>
[16:01:48.849]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.850] getGlobalsAndPackages() ...
[16:01:48.850] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.850] Resolving globals: FALSE
[16:01:48.850] Tweak future expression to call with '...' arguments ...
[16:01:48.850] {
[16:01:48.850]     do.call(function(...) {
[16:01:48.850]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.850]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.850]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.850]             on.exit(options(oopts), add = TRUE)
[16:01:48.850]         }
[16:01:48.850]         {
[16:01:48.850]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.850]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.850]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.850]             })
[16:01:48.850]         }
[16:01:48.850]     }, args = future.call.arguments)
[16:01:48.850] }
[16:01:48.850] Tweak future expression to call with '...' arguments ... DONE
[16:01:48.851] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.851] 
[16:01:48.851] getGlobalsAndPackages() ... DONE
[16:01:48.852] run() for ‘Future’ ...
[16:01:48.852] - state: ‘created’
[16:01:48.852] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:48.852] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:48.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:48.853]   - Field: ‘label’
[16:01:48.853]   - Field: ‘local’
[16:01:48.853]   - Field: ‘owner’
[16:01:48.853]   - Field: ‘envir’
[16:01:48.853]   - Field: ‘packages’
[16:01:48.853]   - Field: ‘gc’
[16:01:48.853]   - Field: ‘conditions’
[16:01:48.853]   - Field: ‘expr’
[16:01:48.853]   - Field: ‘uuid’
[16:01:48.853]   - Field: ‘seed’
[16:01:48.853]   - Field: ‘version’
[16:01:48.854]   - Field: ‘result’
[16:01:48.854]   - Field: ‘asynchronous’
[16:01:48.854]   - Field: ‘calls’
[16:01:48.854]   - Field: ‘globals’
[16:01:48.854]   - Field: ‘stdout’
[16:01:48.854]   - Field: ‘earlySignal’
[16:01:48.854]   - Field: ‘lazy’
[16:01:48.854]   - Field: ‘state’
[16:01:48.854] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:48.854] - Launch lazy future ...
[16:01:48.855] Packages needed by the future expression (n = 0): <none>
[16:01:48.855] Packages needed by future strategies (n = 0): <none>
[16:01:48.859] {
[16:01:48.859]     {
[16:01:48.859]         {
[16:01:48.859]             ...future.startTime <- base::Sys.time()
[16:01:48.859]             {
[16:01:48.859]                 {
[16:01:48.859]                   {
[16:01:48.859]                     base::local({
[16:01:48.859]                       has_future <- base::requireNamespace("future", 
[16:01:48.859]                         quietly = TRUE)
[16:01:48.859]                       if (has_future) {
[16:01:48.859]                         ns <- base::getNamespace("future")
[16:01:48.859]                         version <- ns[[".package"]][["version"]]
[16:01:48.859]                         if (is.null(version)) 
[16:01:48.859]                           version <- utils::packageVersion("future")
[16:01:48.859]                       }
[16:01:48.859]                       else {
[16:01:48.859]                         version <- NULL
[16:01:48.859]                       }
[16:01:48.859]                       if (!has_future || version < "1.8.0") {
[16:01:48.859]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:48.859]                           "", base::R.version$version.string), 
[16:01:48.859]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:48.859]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:48.859]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:48.859]                             "release", "version")], collapse = " "), 
[16:01:48.859]                           hostname = base::Sys.info()[["nodename"]])
[16:01:48.859]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:48.859]                           info)
[16:01:48.859]                         info <- base::paste(info, collapse = "; ")
[16:01:48.859]                         if (!has_future) {
[16:01:48.859]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:48.859]                             info)
[16:01:48.859]                         }
[16:01:48.859]                         else {
[16:01:48.859]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:48.859]                             info, version)
[16:01:48.859]                         }
[16:01:48.859]                         base::stop(msg)
[16:01:48.859]                       }
[16:01:48.859]                     })
[16:01:48.859]                   }
[16:01:48.859]                   options(future.plan = NULL)
[16:01:48.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:48.859]                 }
[16:01:48.859]                 ...future.workdir <- getwd()
[16:01:48.859]             }
[16:01:48.859]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:48.859]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:48.859]         }
[16:01:48.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:48.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:48.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:48.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:48.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:48.859]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:48.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:48.859]             base::names(...future.oldOptions))
[16:01:48.859]     }
[16:01:48.859]     if (FALSE) {
[16:01:48.859]     }
[16:01:48.859]     else {
[16:01:48.859]         if (TRUE) {
[16:01:48.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:48.859]                 open = "w")
[16:01:48.859]         }
[16:01:48.859]         else {
[16:01:48.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:48.859]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:48.859]         }
[16:01:48.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:48.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:48.859]             base::sink(type = "output", split = FALSE)
[16:01:48.859]             base::close(...future.stdout)
[16:01:48.859]         }, add = TRUE)
[16:01:48.859]     }
[16:01:48.859]     ...future.frame <- base::sys.nframe()
[16:01:48.859]     ...future.conditions <- base::list()
[16:01:48.859]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:48.859]     if (FALSE) {
[16:01:48.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:48.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:48.859]     }
[16:01:48.859]     ...future.result <- base::tryCatch({
[16:01:48.859]         base::withCallingHandlers({
[16:01:48.859]             ...future.value <- base::withVisible(base::local({
[16:01:48.859]                 do.call(function(...) {
[16:01:48.859]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.859]                   if (!identical(...future.globals.maxSize.org, 
[16:01:48.859]                     ...future.globals.maxSize)) {
[16:01:48.859]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.859]                     on.exit(options(oopts), add = TRUE)
[16:01:48.859]                   }
[16:01:48.859]                   {
[16:01:48.859]                     lapply(seq_along(...future.elements_ii), 
[16:01:48.859]                       FUN = function(jj) {
[16:01:48.859]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.859]                         ...future.FUN(...future.X_jj, ...)
[16:01:48.859]                       })
[16:01:48.859]                   }
[16:01:48.859]                 }, args = future.call.arguments)
[16:01:48.859]             }))
[16:01:48.859]             future::FutureResult(value = ...future.value$value, 
[16:01:48.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.859]                   ...future.rng), globalenv = if (FALSE) 
[16:01:48.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:48.859]                     ...future.globalenv.names))
[16:01:48.859]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:48.859]         }, condition = base::local({
[16:01:48.859]             c <- base::c
[16:01:48.859]             inherits <- base::inherits
[16:01:48.859]             invokeRestart <- base::invokeRestart
[16:01:48.859]             length <- base::length
[16:01:48.859]             list <- base::list
[16:01:48.859]             seq.int <- base::seq.int
[16:01:48.859]             signalCondition <- base::signalCondition
[16:01:48.859]             sys.calls <- base::sys.calls
[16:01:48.859]             `[[` <- base::`[[`
[16:01:48.859]             `+` <- base::`+`
[16:01:48.859]             `<<-` <- base::`<<-`
[16:01:48.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:48.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:48.859]                   3L)]
[16:01:48.859]             }
[16:01:48.859]             function(cond) {
[16:01:48.859]                 is_error <- inherits(cond, "error")
[16:01:48.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:48.859]                   NULL)
[16:01:48.859]                 if (is_error) {
[16:01:48.859]                   sessionInformation <- function() {
[16:01:48.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:48.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:48.859]                       search = base::search(), system = base::Sys.info())
[16:01:48.859]                   }
[16:01:48.859]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:48.859]                     cond$call), session = sessionInformation(), 
[16:01:48.859]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:48.859]                   signalCondition(cond)
[16:01:48.859]                 }
[16:01:48.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:48.859]                 "immediateCondition"))) {
[16:01:48.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:48.859]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:48.859]                   if (TRUE && !signal) {
[16:01:48.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.859]                     {
[16:01:48.859]                       inherits <- base::inherits
[16:01:48.859]                       invokeRestart <- base::invokeRestart
[16:01:48.859]                       is.null <- base::is.null
[16:01:48.859]                       muffled <- FALSE
[16:01:48.859]                       if (inherits(cond, "message")) {
[16:01:48.859]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.859]                         if (muffled) 
[16:01:48.859]                           invokeRestart("muffleMessage")
[16:01:48.859]                       }
[16:01:48.859]                       else if (inherits(cond, "warning")) {
[16:01:48.859]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.859]                         if (muffled) 
[16:01:48.859]                           invokeRestart("muffleWarning")
[16:01:48.859]                       }
[16:01:48.859]                       else if (inherits(cond, "condition")) {
[16:01:48.859]                         if (!is.null(pattern)) {
[16:01:48.859]                           computeRestarts <- base::computeRestarts
[16:01:48.859]                           grepl <- base::grepl
[16:01:48.859]                           restarts <- computeRestarts(cond)
[16:01:48.859]                           for (restart in restarts) {
[16:01:48.859]                             name <- restart$name
[16:01:48.859]                             if (is.null(name)) 
[16:01:48.859]                               next
[16:01:48.859]                             if (!grepl(pattern, name)) 
[16:01:48.859]                               next
[16:01:48.859]                             invokeRestart(restart)
[16:01:48.859]                             muffled <- TRUE
[16:01:48.859]                             break
[16:01:48.859]                           }
[16:01:48.859]                         }
[16:01:48.859]                       }
[16:01:48.859]                       invisible(muffled)
[16:01:48.859]                     }
[16:01:48.859]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.859]                   }
[16:01:48.859]                 }
[16:01:48.859]                 else {
[16:01:48.859]                   if (TRUE) {
[16:01:48.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.859]                     {
[16:01:48.859]                       inherits <- base::inherits
[16:01:48.859]                       invokeRestart <- base::invokeRestart
[16:01:48.859]                       is.null <- base::is.null
[16:01:48.859]                       muffled <- FALSE
[16:01:48.859]                       if (inherits(cond, "message")) {
[16:01:48.859]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.859]                         if (muffled) 
[16:01:48.859]                           invokeRestart("muffleMessage")
[16:01:48.859]                       }
[16:01:48.859]                       else if (inherits(cond, "warning")) {
[16:01:48.859]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.859]                         if (muffled) 
[16:01:48.859]                           invokeRestart("muffleWarning")
[16:01:48.859]                       }
[16:01:48.859]                       else if (inherits(cond, "condition")) {
[16:01:48.859]                         if (!is.null(pattern)) {
[16:01:48.859]                           computeRestarts <- base::computeRestarts
[16:01:48.859]                           grepl <- base::grepl
[16:01:48.859]                           restarts <- computeRestarts(cond)
[16:01:48.859]                           for (restart in restarts) {
[16:01:48.859]                             name <- restart$name
[16:01:48.859]                             if (is.null(name)) 
[16:01:48.859]                               next
[16:01:48.859]                             if (!grepl(pattern, name)) 
[16:01:48.859]                               next
[16:01:48.859]                             invokeRestart(restart)
[16:01:48.859]                             muffled <- TRUE
[16:01:48.859]                             break
[16:01:48.859]                           }
[16:01:48.859]                         }
[16:01:48.859]                       }
[16:01:48.859]                       invisible(muffled)
[16:01:48.859]                     }
[16:01:48.859]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.859]                   }
[16:01:48.859]                 }
[16:01:48.859]             }
[16:01:48.859]         }))
[16:01:48.859]     }, error = function(ex) {
[16:01:48.859]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:48.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.859]                 ...future.rng), started = ...future.startTime, 
[16:01:48.859]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:48.859]             version = "1.8"), class = "FutureResult")
[16:01:48.859]     }, finally = {
[16:01:48.859]         if (!identical(...future.workdir, getwd())) 
[16:01:48.859]             setwd(...future.workdir)
[16:01:48.859]         {
[16:01:48.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:48.859]                 ...future.oldOptions$nwarnings <- NULL
[16:01:48.859]             }
[16:01:48.859]             base::options(...future.oldOptions)
[16:01:48.859]             if (.Platform$OS.type == "windows") {
[16:01:48.859]                 old_names <- names(...future.oldEnvVars)
[16:01:48.859]                 envs <- base::Sys.getenv()
[16:01:48.859]                 names <- names(envs)
[16:01:48.859]                 common <- intersect(names, old_names)
[16:01:48.859]                 added <- setdiff(names, old_names)
[16:01:48.859]                 removed <- setdiff(old_names, names)
[16:01:48.859]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:48.859]                   envs[common]]
[16:01:48.859]                 NAMES <- toupper(changed)
[16:01:48.859]                 args <- list()
[16:01:48.859]                 for (kk in seq_along(NAMES)) {
[16:01:48.859]                   name <- changed[[kk]]
[16:01:48.859]                   NAME <- NAMES[[kk]]
[16:01:48.859]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.859]                     next
[16:01:48.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.859]                 }
[16:01:48.859]                 NAMES <- toupper(added)
[16:01:48.859]                 for (kk in seq_along(NAMES)) {
[16:01:48.859]                   name <- added[[kk]]
[16:01:48.859]                   NAME <- NAMES[[kk]]
[16:01:48.859]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.859]                     next
[16:01:48.859]                   args[[name]] <- ""
[16:01:48.859]                 }
[16:01:48.859]                 NAMES <- toupper(removed)
[16:01:48.859]                 for (kk in seq_along(NAMES)) {
[16:01:48.859]                   name <- removed[[kk]]
[16:01:48.859]                   NAME <- NAMES[[kk]]
[16:01:48.859]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.859]                     next
[16:01:48.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.859]                 }
[16:01:48.859]                 if (length(args) > 0) 
[16:01:48.859]                   base::do.call(base::Sys.setenv, args = args)
[16:01:48.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:48.859]             }
[16:01:48.859]             else {
[16:01:48.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:48.859]             }
[16:01:48.859]             {
[16:01:48.859]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:48.859]                   0L) {
[16:01:48.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:48.859]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:48.859]                   base::options(opts)
[16:01:48.859]                 }
[16:01:48.859]                 {
[16:01:48.859]                   {
[16:01:48.859]                     NULL
[16:01:48.859]                     RNGkind("Mersenne-Twister")
[16:01:48.859]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:48.859]                       inherits = FALSE)
[16:01:48.859]                   }
[16:01:48.859]                   options(future.plan = NULL)
[16:01:48.859]                   if (is.na(NA_character_)) 
[16:01:48.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:48.859]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:48.859]                   {
[16:01:48.859]                     future <- SequentialFuture(..., envir = envir)
[16:01:48.859]                     if (!future$lazy) 
[16:01:48.859]                       future <- run(future)
[16:01:48.859]                     invisible(future)
[16:01:48.859]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:48.859]                 }
[16:01:48.859]             }
[16:01:48.859]         }
[16:01:48.859]     })
[16:01:48.859]     if (TRUE) {
[16:01:48.859]         base::sink(type = "output", split = FALSE)
[16:01:48.859]         if (TRUE) {
[16:01:48.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:48.859]         }
[16:01:48.859]         else {
[16:01:48.859]             ...future.result["stdout"] <- base::list(NULL)
[16:01:48.859]         }
[16:01:48.859]         base::close(...future.stdout)
[16:01:48.859]         ...future.stdout <- NULL
[16:01:48.859]     }
[16:01:48.859]     ...future.result$conditions <- ...future.conditions
[16:01:48.859]     ...future.result$finished <- base::Sys.time()
[16:01:48.859]     ...future.result
[16:01:48.859] }
[16:01:48.860] assign_globals() ...
[16:01:48.861] List of 5
[16:01:48.861]  $ ...future.FUN            :function (x, ...)  
[16:01:48.861]  $ future.call.arguments    : list()
[16:01:48.861]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.861]  $ ...future.elements_ii    :List of 3
[16:01:48.861]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[16:01:48.861]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:01:48.861]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:01:48.861]  $ ...future.seeds_ii       : NULL
[16:01:48.861]  $ ...future.globals.maxSize: NULL
[16:01:48.861]  - attr(*, "where")=List of 5
[16:01:48.861]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:48.861]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:48.861]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:48.861]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:48.861]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:48.861]  - attr(*, "resolved")= logi FALSE
[16:01:48.861]  - attr(*, "total_size")= num 1240
[16:01:48.861]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.861]  - attr(*, "already-done")= logi TRUE
[16:01:48.866] - copied ‘...future.FUN’ to environment
[16:01:48.866] - copied ‘future.call.arguments’ to environment
[16:01:48.866] - copied ‘...future.elements_ii’ to environment
[16:01:48.866] - copied ‘...future.seeds_ii’ to environment
[16:01:48.866] - copied ‘...future.globals.maxSize’ to environment
[16:01:48.866] assign_globals() ... done
[16:01:48.867] plan(): Setting new future strategy stack:
[16:01:48.867] List of future strategies:
[16:01:48.867] 1. sequential:
[16:01:48.867]    - args: function (..., envir = parent.frame())
[16:01:48.867]    - tweaked: FALSE
[16:01:48.867]    - call: NULL
[16:01:48.867] plan(): nbrOfWorkers() = 1
[16:01:48.868] plan(): Setting new future strategy stack:
[16:01:48.868] List of future strategies:
[16:01:48.868] 1. sequential:
[16:01:48.868]    - args: function (..., envir = parent.frame())
[16:01:48.868]    - tweaked: FALSE
[16:01:48.868]    - call: plan(strategy)
[16:01:48.869] plan(): nbrOfWorkers() = 1
[16:01:48.869] SequentialFuture started (and completed)
[16:01:48.869] - Launch lazy future ... done
[16:01:48.869] run() for ‘SequentialFuture’ ... done
[16:01:48.870] Created future:
[16:01:48.870] SequentialFuture:
[16:01:48.870] Label: ‘future_eapply-1’
[16:01:48.870] Expression:
[16:01:48.870] {
[16:01:48.870]     do.call(function(...) {
[16:01:48.870]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.870]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.870]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.870]             on.exit(options(oopts), add = TRUE)
[16:01:48.870]         }
[16:01:48.870]         {
[16:01:48.870]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.870]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.870]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.870]             })
[16:01:48.870]         }
[16:01:48.870]     }, args = future.call.arguments)
[16:01:48.870] }
[16:01:48.870] Lazy evaluation: FALSE
[16:01:48.870] Asynchronous evaluation: FALSE
[16:01:48.870] Local evaluation: TRUE
[16:01:48.870] Environment: R_GlobalEnv
[16:01:48.870] Capture standard output: TRUE
[16:01:48.870] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:48.870] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:48.870] Packages: <none>
[16:01:48.870] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:48.870] Resolved: TRUE
[16:01:48.870] Value: 168 bytes of class ‘list’
[16:01:48.870] Early signaling: FALSE
[16:01:48.870] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:48.870] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:48.871] Chunk #1 of 1 ... DONE
[16:01:48.871] Launching 1 futures (chunks) ... DONE
[16:01:48.871] Resolving 1 futures (chunks) ...
[16:01:48.871] resolve() on list ...
[16:01:48.872]  recursive: 0
[16:01:48.872]  length: 1
[16:01:48.872] 
[16:01:48.872] resolved() for ‘SequentialFuture’ ...
[16:01:48.872] - state: ‘finished’
[16:01:48.872] - run: TRUE
[16:01:48.872] - result: ‘FutureResult’
[16:01:48.872] resolved() for ‘SequentialFuture’ ... done
[16:01:48.872] Future #1
[16:01:48.873] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:48.873] - nx: 1
[16:01:48.873] - relay: TRUE
[16:01:48.873] - stdout: TRUE
[16:01:48.873] - signal: TRUE
[16:01:48.873] - resignal: FALSE
[16:01:48.873] - force: TRUE
[16:01:48.873] - relayed: [n=1] FALSE
[16:01:48.873] - queued futures: [n=1] FALSE
[16:01:48.874]  - until=1
[16:01:48.874]  - relaying element #1
[16:01:48.874] - relayed: [n=1] TRUE
[16:01:48.874] - queued futures: [n=1] TRUE
[16:01:48.874] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:48.874]  length: 0 (resolved future 1)
[16:01:48.874] Relaying remaining futures
[16:01:48.874] signalConditionsASAP(NULL, pos=0) ...
[16:01:48.875] - nx: 1
[16:01:48.875] - relay: TRUE
[16:01:48.875] - stdout: TRUE
[16:01:48.875] - signal: TRUE
[16:01:48.875] - resignal: FALSE
[16:01:48.875] - force: TRUE
[16:01:48.875] - relayed: [n=1] TRUE
[16:01:48.875] - queued futures: [n=1] TRUE
 - flush all
[16:01:48.875] - relayed: [n=1] TRUE
[16:01:48.875] - queued futures: [n=1] TRUE
[16:01:48.875] signalConditionsASAP(NULL, pos=0) ... done
[16:01:48.875] resolve() on list ... DONE
[16:01:48.876]  - Number of value chunks collected: 1
[16:01:48.876] Resolving 1 futures (chunks) ... DONE
[16:01:48.876] Reducing values from 1 chunks ...
[16:01:48.876]  - Number of values collected after concatenation: 3
[16:01:48.876]  - Number of values expected: 3
[16:01:48.876] Reducing values from 1 chunks ... DONE
[16:01:48.876] future_lapply() ... DONE
[16:01:48.878] future_lapply() ...
[16:01:48.879] Number of chunks: 1
[16:01:48.879] getGlobalsAndPackagesXApply() ...
[16:01:48.879]  - future.globals: TRUE
[16:01:48.879] getGlobalsAndPackages() ...
[16:01:48.879] Searching for globals...
[16:01:48.880] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:48.880] Searching for globals ... DONE
[16:01:48.880] Resolving globals: FALSE
[16:01:48.881] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:48.881] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:48.881] - globals: [1] ‘FUN’
[16:01:48.881] - packages: [1] ‘stats’
[16:01:48.881] getGlobalsAndPackages() ... DONE
[16:01:48.881]  - globals found/used: [n=1] ‘FUN’
[16:01:48.882]  - needed namespaces: [n=1] ‘stats’
[16:01:48.882] Finding globals ... DONE
[16:01:48.882]  - use_args: TRUE
[16:01:48.882]  - Getting '...' globals ...
[16:01:48.882] resolve() on list ...
[16:01:48.882]  recursive: 0
[16:01:48.882]  length: 1
[16:01:48.882]  elements: ‘...’
[16:01:48.883]  length: 0 (resolved future 1)
[16:01:48.883] resolve() on list ... DONE
[16:01:48.883]    - '...' content: [n=1] ‘probs’
[16:01:48.883] List of 1
[16:01:48.883]  $ ...:List of 1
[16:01:48.883]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:01:48.883]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.883]  - attr(*, "where")=List of 1
[16:01:48.883]   ..$ ...:<environment: 0x5620a1a389a8> 
[16:01:48.883]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.883]  - attr(*, "resolved")= logi TRUE
[16:01:48.883]  - attr(*, "total_size")= num NA
[16:01:48.887]  - Getting '...' globals ... DONE
[16:01:48.888] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:48.888] List of 2
[16:01:48.888]  $ ...future.FUN:function (x, ...)  
[16:01:48.888]  $ ...          :List of 1
[16:01:48.888]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:01:48.888]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.888]  - attr(*, "where")=List of 2
[16:01:48.888]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:48.888]   ..$ ...          :<environment: 0x5620a1a389a8> 
[16:01:48.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.888]  - attr(*, "resolved")= logi FALSE
[16:01:48.888]  - attr(*, "total_size")= num 1328
[16:01:48.891] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:48.891] getGlobalsAndPackagesXApply() ... DONE
[16:01:48.891] Number of futures (= number of chunks): 1
[16:01:48.891] Launching 1 futures (chunks) ...
[16:01:48.891] Chunk #1 of 1 ...
[16:01:48.892]  - Finding globals in 'X' for chunk #1 ...
[16:01:48.892] getGlobalsAndPackages() ...
[16:01:48.892] Searching for globals...
[16:01:48.892] 
[16:01:48.892] Searching for globals ... DONE
[16:01:48.892] - globals: [0] <none>
[16:01:48.892] getGlobalsAndPackages() ... DONE
[16:01:48.892]    + additional globals found: [n=0] 
[16:01:48.892]    + additional namespaces needed: [n=0] 
[16:01:48.892]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:48.893]  - seeds: <none>
[16:01:48.893]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.893] getGlobalsAndPackages() ...
[16:01:48.893] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.893] Resolving globals: FALSE
[16:01:48.893] Tweak future expression to call with '...' arguments ...
[16:01:48.893] {
[16:01:48.893]     do.call(function(...) {
[16:01:48.893]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.893]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.893]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.893]             on.exit(options(oopts), add = TRUE)
[16:01:48.893]         }
[16:01:48.893]         {
[16:01:48.893]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.893]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.893]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.893]             })
[16:01:48.893]         }
[16:01:48.893]     }, args = future.call.arguments)
[16:01:48.893] }
[16:01:48.893] Tweak future expression to call with '...' arguments ... DONE
[16:01:48.894] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.894] - packages: [1] ‘stats’
[16:01:48.894] getGlobalsAndPackages() ... DONE
[16:01:48.894] run() for ‘Future’ ...
[16:01:48.894] - state: ‘created’
[16:01:48.895] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:48.895] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:48.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:48.895]   - Field: ‘label’
[16:01:48.895]   - Field: ‘local’
[16:01:48.895]   - Field: ‘owner’
[16:01:48.895]   - Field: ‘envir’
[16:01:48.895]   - Field: ‘packages’
[16:01:48.896]   - Field: ‘gc’
[16:01:48.896]   - Field: ‘conditions’
[16:01:48.896]   - Field: ‘expr’
[16:01:48.896]   - Field: ‘uuid’
[16:01:48.896]   - Field: ‘seed’
[16:01:48.896]   - Field: ‘version’
[16:01:48.896]   - Field: ‘result’
[16:01:48.896]   - Field: ‘asynchronous’
[16:01:48.896]   - Field: ‘calls’
[16:01:48.896]   - Field: ‘globals’
[16:01:48.896]   - Field: ‘stdout’
[16:01:48.897]   - Field: ‘earlySignal’
[16:01:48.897]   - Field: ‘lazy’
[16:01:48.897]   - Field: ‘state’
[16:01:48.897] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:48.897] - Launch lazy future ...
[16:01:48.897] Packages needed by the future expression (n = 1): ‘stats’
[16:01:48.897] Packages needed by future strategies (n = 0): <none>
[16:01:48.898] {
[16:01:48.898]     {
[16:01:48.898]         {
[16:01:48.898]             ...future.startTime <- base::Sys.time()
[16:01:48.898]             {
[16:01:48.898]                 {
[16:01:48.898]                   {
[16:01:48.898]                     {
[16:01:48.898]                       base::local({
[16:01:48.898]                         has_future <- base::requireNamespace("future", 
[16:01:48.898]                           quietly = TRUE)
[16:01:48.898]                         if (has_future) {
[16:01:48.898]                           ns <- base::getNamespace("future")
[16:01:48.898]                           version <- ns[[".package"]][["version"]]
[16:01:48.898]                           if (is.null(version)) 
[16:01:48.898]                             version <- utils::packageVersion("future")
[16:01:48.898]                         }
[16:01:48.898]                         else {
[16:01:48.898]                           version <- NULL
[16:01:48.898]                         }
[16:01:48.898]                         if (!has_future || version < "1.8.0") {
[16:01:48.898]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:48.898]                             "", base::R.version$version.string), 
[16:01:48.898]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:48.898]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:48.898]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:48.898]                               "release", "version")], collapse = " "), 
[16:01:48.898]                             hostname = base::Sys.info()[["nodename"]])
[16:01:48.898]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:48.898]                             info)
[16:01:48.898]                           info <- base::paste(info, collapse = "; ")
[16:01:48.898]                           if (!has_future) {
[16:01:48.898]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:48.898]                               info)
[16:01:48.898]                           }
[16:01:48.898]                           else {
[16:01:48.898]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:48.898]                               info, version)
[16:01:48.898]                           }
[16:01:48.898]                           base::stop(msg)
[16:01:48.898]                         }
[16:01:48.898]                       })
[16:01:48.898]                     }
[16:01:48.898]                     base::local({
[16:01:48.898]                       for (pkg in "stats") {
[16:01:48.898]                         base::loadNamespace(pkg)
[16:01:48.898]                         base::library(pkg, character.only = TRUE)
[16:01:48.898]                       }
[16:01:48.898]                     })
[16:01:48.898]                   }
[16:01:48.898]                   options(future.plan = NULL)
[16:01:48.898]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.898]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:48.898]                 }
[16:01:48.898]                 ...future.workdir <- getwd()
[16:01:48.898]             }
[16:01:48.898]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:48.898]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:48.898]         }
[16:01:48.898]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:48.898]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:48.898]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:48.898]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:48.898]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:48.898]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:48.898]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:48.898]             base::names(...future.oldOptions))
[16:01:48.898]     }
[16:01:48.898]     if (FALSE) {
[16:01:48.898]     }
[16:01:48.898]     else {
[16:01:48.898]         if (TRUE) {
[16:01:48.898]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:48.898]                 open = "w")
[16:01:48.898]         }
[16:01:48.898]         else {
[16:01:48.898]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:48.898]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:48.898]         }
[16:01:48.898]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:48.898]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:48.898]             base::sink(type = "output", split = FALSE)
[16:01:48.898]             base::close(...future.stdout)
[16:01:48.898]         }, add = TRUE)
[16:01:48.898]     }
[16:01:48.898]     ...future.frame <- base::sys.nframe()
[16:01:48.898]     ...future.conditions <- base::list()
[16:01:48.898]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:48.898]     if (FALSE) {
[16:01:48.898]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:48.898]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:48.898]     }
[16:01:48.898]     ...future.result <- base::tryCatch({
[16:01:48.898]         base::withCallingHandlers({
[16:01:48.898]             ...future.value <- base::withVisible(base::local({
[16:01:48.898]                 do.call(function(...) {
[16:01:48.898]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.898]                   if (!identical(...future.globals.maxSize.org, 
[16:01:48.898]                     ...future.globals.maxSize)) {
[16:01:48.898]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.898]                     on.exit(options(oopts), add = TRUE)
[16:01:48.898]                   }
[16:01:48.898]                   {
[16:01:48.898]                     lapply(seq_along(...future.elements_ii), 
[16:01:48.898]                       FUN = function(jj) {
[16:01:48.898]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.898]                         ...future.FUN(...future.X_jj, ...)
[16:01:48.898]                       })
[16:01:48.898]                   }
[16:01:48.898]                 }, args = future.call.arguments)
[16:01:48.898]             }))
[16:01:48.898]             future::FutureResult(value = ...future.value$value, 
[16:01:48.898]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.898]                   ...future.rng), globalenv = if (FALSE) 
[16:01:48.898]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:48.898]                     ...future.globalenv.names))
[16:01:48.898]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:48.898]         }, condition = base::local({
[16:01:48.898]             c <- base::c
[16:01:48.898]             inherits <- base::inherits
[16:01:48.898]             invokeRestart <- base::invokeRestart
[16:01:48.898]             length <- base::length
[16:01:48.898]             list <- base::list
[16:01:48.898]             seq.int <- base::seq.int
[16:01:48.898]             signalCondition <- base::signalCondition
[16:01:48.898]             sys.calls <- base::sys.calls
[16:01:48.898]             `[[` <- base::`[[`
[16:01:48.898]             `+` <- base::`+`
[16:01:48.898]             `<<-` <- base::`<<-`
[16:01:48.898]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:48.898]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:48.898]                   3L)]
[16:01:48.898]             }
[16:01:48.898]             function(cond) {
[16:01:48.898]                 is_error <- inherits(cond, "error")
[16:01:48.898]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:48.898]                   NULL)
[16:01:48.898]                 if (is_error) {
[16:01:48.898]                   sessionInformation <- function() {
[16:01:48.898]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:48.898]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:48.898]                       search = base::search(), system = base::Sys.info())
[16:01:48.898]                   }
[16:01:48.898]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.898]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:48.898]                     cond$call), session = sessionInformation(), 
[16:01:48.898]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:48.898]                   signalCondition(cond)
[16:01:48.898]                 }
[16:01:48.898]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:48.898]                 "immediateCondition"))) {
[16:01:48.898]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:48.898]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.898]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:48.898]                   if (TRUE && !signal) {
[16:01:48.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.898]                     {
[16:01:48.898]                       inherits <- base::inherits
[16:01:48.898]                       invokeRestart <- base::invokeRestart
[16:01:48.898]                       is.null <- base::is.null
[16:01:48.898]                       muffled <- FALSE
[16:01:48.898]                       if (inherits(cond, "message")) {
[16:01:48.898]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.898]                         if (muffled) 
[16:01:48.898]                           invokeRestart("muffleMessage")
[16:01:48.898]                       }
[16:01:48.898]                       else if (inherits(cond, "warning")) {
[16:01:48.898]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.898]                         if (muffled) 
[16:01:48.898]                           invokeRestart("muffleWarning")
[16:01:48.898]                       }
[16:01:48.898]                       else if (inherits(cond, "condition")) {
[16:01:48.898]                         if (!is.null(pattern)) {
[16:01:48.898]                           computeRestarts <- base::computeRestarts
[16:01:48.898]                           grepl <- base::grepl
[16:01:48.898]                           restarts <- computeRestarts(cond)
[16:01:48.898]                           for (restart in restarts) {
[16:01:48.898]                             name <- restart$name
[16:01:48.898]                             if (is.null(name)) 
[16:01:48.898]                               next
[16:01:48.898]                             if (!grepl(pattern, name)) 
[16:01:48.898]                               next
[16:01:48.898]                             invokeRestart(restart)
[16:01:48.898]                             muffled <- TRUE
[16:01:48.898]                             break
[16:01:48.898]                           }
[16:01:48.898]                         }
[16:01:48.898]                       }
[16:01:48.898]                       invisible(muffled)
[16:01:48.898]                     }
[16:01:48.898]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.898]                   }
[16:01:48.898]                 }
[16:01:48.898]                 else {
[16:01:48.898]                   if (TRUE) {
[16:01:48.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.898]                     {
[16:01:48.898]                       inherits <- base::inherits
[16:01:48.898]                       invokeRestart <- base::invokeRestart
[16:01:48.898]                       is.null <- base::is.null
[16:01:48.898]                       muffled <- FALSE
[16:01:48.898]                       if (inherits(cond, "message")) {
[16:01:48.898]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.898]                         if (muffled) 
[16:01:48.898]                           invokeRestart("muffleMessage")
[16:01:48.898]                       }
[16:01:48.898]                       else if (inherits(cond, "warning")) {
[16:01:48.898]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.898]                         if (muffled) 
[16:01:48.898]                           invokeRestart("muffleWarning")
[16:01:48.898]                       }
[16:01:48.898]                       else if (inherits(cond, "condition")) {
[16:01:48.898]                         if (!is.null(pattern)) {
[16:01:48.898]                           computeRestarts <- base::computeRestarts
[16:01:48.898]                           grepl <- base::grepl
[16:01:48.898]                           restarts <- computeRestarts(cond)
[16:01:48.898]                           for (restart in restarts) {
[16:01:48.898]                             name <- restart$name
[16:01:48.898]                             if (is.null(name)) 
[16:01:48.898]                               next
[16:01:48.898]                             if (!grepl(pattern, name)) 
[16:01:48.898]                               next
[16:01:48.898]                             invokeRestart(restart)
[16:01:48.898]                             muffled <- TRUE
[16:01:48.898]                             break
[16:01:48.898]                           }
[16:01:48.898]                         }
[16:01:48.898]                       }
[16:01:48.898]                       invisible(muffled)
[16:01:48.898]                     }
[16:01:48.898]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.898]                   }
[16:01:48.898]                 }
[16:01:48.898]             }
[16:01:48.898]         }))
[16:01:48.898]     }, error = function(ex) {
[16:01:48.898]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:48.898]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.898]                 ...future.rng), started = ...future.startTime, 
[16:01:48.898]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:48.898]             version = "1.8"), class = "FutureResult")
[16:01:48.898]     }, finally = {
[16:01:48.898]         if (!identical(...future.workdir, getwd())) 
[16:01:48.898]             setwd(...future.workdir)
[16:01:48.898]         {
[16:01:48.898]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:48.898]                 ...future.oldOptions$nwarnings <- NULL
[16:01:48.898]             }
[16:01:48.898]             base::options(...future.oldOptions)
[16:01:48.898]             if (.Platform$OS.type == "windows") {
[16:01:48.898]                 old_names <- names(...future.oldEnvVars)
[16:01:48.898]                 envs <- base::Sys.getenv()
[16:01:48.898]                 names <- names(envs)
[16:01:48.898]                 common <- intersect(names, old_names)
[16:01:48.898]                 added <- setdiff(names, old_names)
[16:01:48.898]                 removed <- setdiff(old_names, names)
[16:01:48.898]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:48.898]                   envs[common]]
[16:01:48.898]                 NAMES <- toupper(changed)
[16:01:48.898]                 args <- list()
[16:01:48.898]                 for (kk in seq_along(NAMES)) {
[16:01:48.898]                   name <- changed[[kk]]
[16:01:48.898]                   NAME <- NAMES[[kk]]
[16:01:48.898]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.898]                     next
[16:01:48.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.898]                 }
[16:01:48.898]                 NAMES <- toupper(added)
[16:01:48.898]                 for (kk in seq_along(NAMES)) {
[16:01:48.898]                   name <- added[[kk]]
[16:01:48.898]                   NAME <- NAMES[[kk]]
[16:01:48.898]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.898]                     next
[16:01:48.898]                   args[[name]] <- ""
[16:01:48.898]                 }
[16:01:48.898]                 NAMES <- toupper(removed)
[16:01:48.898]                 for (kk in seq_along(NAMES)) {
[16:01:48.898]                   name <- removed[[kk]]
[16:01:48.898]                   NAME <- NAMES[[kk]]
[16:01:48.898]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.898]                     next
[16:01:48.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.898]                 }
[16:01:48.898]                 if (length(args) > 0) 
[16:01:48.898]                   base::do.call(base::Sys.setenv, args = args)
[16:01:48.898]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:48.898]             }
[16:01:48.898]             else {
[16:01:48.898]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:48.898]             }
[16:01:48.898]             {
[16:01:48.898]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:48.898]                   0L) {
[16:01:48.898]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:48.898]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:48.898]                   base::options(opts)
[16:01:48.898]                 }
[16:01:48.898]                 {
[16:01:48.898]                   {
[16:01:48.898]                     NULL
[16:01:48.898]                     RNGkind("Mersenne-Twister")
[16:01:48.898]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:48.898]                       inherits = FALSE)
[16:01:48.898]                   }
[16:01:48.898]                   options(future.plan = NULL)
[16:01:48.898]                   if (is.na(NA_character_)) 
[16:01:48.898]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.898]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:48.898]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:48.898]                   {
[16:01:48.898]                     future <- SequentialFuture(..., envir = envir)
[16:01:48.898]                     if (!future$lazy) 
[16:01:48.898]                       future <- run(future)
[16:01:48.898]                     invisible(future)
[16:01:48.898]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:48.898]                 }
[16:01:48.898]             }
[16:01:48.898]         }
[16:01:48.898]     })
[16:01:48.898]     if (TRUE) {
[16:01:48.898]         base::sink(type = "output", split = FALSE)
[16:01:48.898]         if (TRUE) {
[16:01:48.898]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:48.898]         }
[16:01:48.898]         else {
[16:01:48.898]             ...future.result["stdout"] <- base::list(NULL)
[16:01:48.898]         }
[16:01:48.898]         base::close(...future.stdout)
[16:01:48.898]         ...future.stdout <- NULL
[16:01:48.898]     }
[16:01:48.898]     ...future.result$conditions <- ...future.conditions
[16:01:48.898]     ...future.result$finished <- base::Sys.time()
[16:01:48.898]     ...future.result
[16:01:48.898] }
[16:01:48.899] assign_globals() ...
[16:01:48.899] List of 5
[16:01:48.899]  $ ...future.FUN            :function (x, ...)  
[16:01:48.899]  $ future.call.arguments    :List of 1
[16:01:48.899]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:01:48.899]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.899]  $ ...future.elements_ii    :List of 3
[16:01:48.899]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:01:48.899]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:01:48.899]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:01:48.899]  $ ...future.seeds_ii       : NULL
[16:01:48.899]  $ ...future.globals.maxSize: NULL
[16:01:48.899]  - attr(*, "where")=List of 5
[16:01:48.899]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:48.899]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:48.899]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:48.899]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:48.899]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:48.899]  - attr(*, "resolved")= logi FALSE
[16:01:48.899]  - attr(*, "total_size")= num 1328
[16:01:48.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.899]  - attr(*, "already-done")= logi TRUE
[16:01:48.905] - copied ‘...future.FUN’ to environment
[16:01:48.905] - copied ‘future.call.arguments’ to environment
[16:01:48.905] - copied ‘...future.elements_ii’ to environment
[16:01:48.905] - copied ‘...future.seeds_ii’ to environment
[16:01:48.905] - copied ‘...future.globals.maxSize’ to environment
[16:01:48.905] assign_globals() ... done
[16:01:48.906] plan(): Setting new future strategy stack:
[16:01:48.906] List of future strategies:
[16:01:48.906] 1. sequential:
[16:01:48.906]    - args: function (..., envir = parent.frame())
[16:01:48.906]    - tweaked: FALSE
[16:01:48.906]    - call: NULL
[16:01:48.906] plan(): nbrOfWorkers() = 1
[16:01:48.907] plan(): Setting new future strategy stack:
[16:01:48.908] List of future strategies:
[16:01:48.908] 1. sequential:
[16:01:48.908]    - args: function (..., envir = parent.frame())
[16:01:48.908]    - tweaked: FALSE
[16:01:48.908]    - call: plan(strategy)
[16:01:48.908] plan(): nbrOfWorkers() = 1
[16:01:48.908] SequentialFuture started (and completed)
[16:01:48.908] - Launch lazy future ... done
[16:01:48.908] run() for ‘SequentialFuture’ ... done
[16:01:48.908] Created future:
[16:01:48.908] SequentialFuture:
[16:01:48.908] Label: ‘future_eapply-1’
[16:01:48.908] Expression:
[16:01:48.908] {
[16:01:48.908]     do.call(function(...) {
[16:01:48.908]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.908]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.908]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.908]             on.exit(options(oopts), add = TRUE)
[16:01:48.908]         }
[16:01:48.908]         {
[16:01:48.908]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.908]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.908]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.908]             })
[16:01:48.908]         }
[16:01:48.908]     }, args = future.call.arguments)
[16:01:48.908] }
[16:01:48.908] Lazy evaluation: FALSE
[16:01:48.908] Asynchronous evaluation: FALSE
[16:01:48.908] Local evaluation: TRUE
[16:01:48.908] Environment: R_GlobalEnv
[16:01:48.908] Capture standard output: TRUE
[16:01:48.908] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:48.908] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:48.908] Packages: 1 packages (‘stats’)
[16:01:48.908] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:48.908] Resolved: TRUE
[16:01:48.908] Value: 1.29 KiB of class ‘list’
[16:01:48.908] Early signaling: FALSE
[16:01:48.908] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:48.908] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:48.909] Chunk #1 of 1 ... DONE
[16:01:48.910] Launching 1 futures (chunks) ... DONE
[16:01:48.910] Resolving 1 futures (chunks) ...
[16:01:48.910] resolve() on list ...
[16:01:48.910]  recursive: 0
[16:01:48.910]  length: 1
[16:01:48.910] 
[16:01:48.910] resolved() for ‘SequentialFuture’ ...
[16:01:48.910] - state: ‘finished’
[16:01:48.910] - run: TRUE
[16:01:48.910] - result: ‘FutureResult’
[16:01:48.911] resolved() for ‘SequentialFuture’ ... done
[16:01:48.911] Future #1
[16:01:48.911] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:48.911] - nx: 1
[16:01:48.911] - relay: TRUE
[16:01:48.911] - stdout: TRUE
[16:01:48.913] - signal: TRUE
[16:01:48.913] - resignal: FALSE
[16:01:48.913] - force: TRUE
[16:01:48.913] - relayed: [n=1] FALSE
[16:01:48.913] - queued futures: [n=1] FALSE
[16:01:48.913]  - until=1
[16:01:48.913]  - relaying element #1
[16:01:48.913] - relayed: [n=1] TRUE
[16:01:48.913] - queued futures: [n=1] TRUE
[16:01:48.913] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:48.914]  length: 0 (resolved future 1)
[16:01:48.914] Relaying remaining futures
[16:01:48.914] signalConditionsASAP(NULL, pos=0) ...
[16:01:48.914] - nx: 1
[16:01:48.914] - relay: TRUE
[16:01:48.914] - stdout: TRUE
[16:01:48.914] - signal: TRUE
[16:01:48.914] - resignal: FALSE
[16:01:48.914] - force: TRUE
[16:01:48.914] - relayed: [n=1] TRUE
[16:01:48.914] - queued futures: [n=1] TRUE
 - flush all
[16:01:48.915] - relayed: [n=1] TRUE
[16:01:48.915] - queued futures: [n=1] TRUE
[16:01:48.915] signalConditionsASAP(NULL, pos=0) ... done
[16:01:48.915] resolve() on list ... DONE
[16:01:48.915]  - Number of value chunks collected: 1
[16:01:48.915] Resolving 1 futures (chunks) ... DONE
[16:01:48.915] Reducing values from 1 chunks ...
[16:01:48.915]  - Number of values collected after concatenation: 3
[16:01:48.915]  - Number of values expected: 3
[16:01:48.915] Reducing values from 1 chunks ... DONE
[16:01:48.916] future_lapply() ... DONE
[16:01:48.917] future_lapply() ...
[16:01:48.917] Number of chunks: 1
[16:01:48.918] getGlobalsAndPackagesXApply() ...
[16:01:48.918]  - future.globals: TRUE
[16:01:48.918] getGlobalsAndPackages() ...
[16:01:48.918] Searching for globals...
[16:01:48.919] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:48.919] Searching for globals ... DONE
[16:01:48.919] Resolving globals: FALSE
[16:01:48.919] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:48.920] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:48.920] - globals: [1] ‘FUN’
[16:01:48.920] - packages: [1] ‘stats’
[16:01:48.920] getGlobalsAndPackages() ... DONE
[16:01:48.920]  - globals found/used: [n=1] ‘FUN’
[16:01:48.920]  - needed namespaces: [n=1] ‘stats’
[16:01:48.920] Finding globals ... DONE
[16:01:48.920]  - use_args: TRUE
[16:01:48.921]  - Getting '...' globals ...
[16:01:48.921] resolve() on list ...
[16:01:48.921]  recursive: 0
[16:01:48.921]  length: 1
[16:01:48.921]  elements: ‘...’
[16:01:48.921]  length: 0 (resolved future 1)
[16:01:48.921] resolve() on list ... DONE
[16:01:48.921]    - '...' content: [n=0] 
[16:01:48.921] List of 1
[16:01:48.921]  $ ...: list()
[16:01:48.921]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.921]  - attr(*, "where")=List of 1
[16:01:48.921]   ..$ ...:<environment: 0x56209ff64950> 
[16:01:48.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.921]  - attr(*, "resolved")= logi TRUE
[16:01:48.921]  - attr(*, "total_size")= num NA
[16:01:48.924]  - Getting '...' globals ... DONE
[16:01:48.924] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:48.924] List of 2
[16:01:48.924]  $ ...future.FUN:function (x, ...)  
[16:01:48.924]  $ ...          : list()
[16:01:48.924]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.924]  - attr(*, "where")=List of 2
[16:01:48.924]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:48.924]   ..$ ...          :<environment: 0x56209ff64950> 
[16:01:48.924]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.924]  - attr(*, "resolved")= logi FALSE
[16:01:48.924]  - attr(*, "total_size")= num 1248
[16:01:48.927] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:48.927] getGlobalsAndPackagesXApply() ... DONE
[16:01:48.927] Number of futures (= number of chunks): 1
[16:01:48.927] Launching 1 futures (chunks) ...
[16:01:48.927] Chunk #1 of 1 ...
[16:01:48.927]  - Finding globals in 'X' for chunk #1 ...
[16:01:48.927] getGlobalsAndPackages() ...
[16:01:48.928] Searching for globals...
[16:01:48.928] 
[16:01:48.928] Searching for globals ... DONE
[16:01:48.928] - globals: [0] <none>
[16:01:48.928] getGlobalsAndPackages() ... DONE
[16:01:48.928]    + additional globals found: [n=0] 
[16:01:48.928]    + additional namespaces needed: [n=0] 
[16:01:48.928]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:48.928]  - seeds: <none>
[16:01:48.928]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.929] getGlobalsAndPackages() ...
[16:01:48.929] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.929] Resolving globals: FALSE
[16:01:48.929] Tweak future expression to call with '...' arguments ...
[16:01:48.929] {
[16:01:48.929]     do.call(function(...) {
[16:01:48.929]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.929]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.929]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.929]             on.exit(options(oopts), add = TRUE)
[16:01:48.929]         }
[16:01:48.929]         {
[16:01:48.929]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.929]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.929]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.929]             })
[16:01:48.929]         }
[16:01:48.929]     }, args = future.call.arguments)
[16:01:48.929] }
[16:01:48.929] Tweak future expression to call with '...' arguments ... DONE
[16:01:48.930] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.930] - packages: [1] ‘stats’
[16:01:48.930] getGlobalsAndPackages() ... DONE
[16:01:48.930] run() for ‘Future’ ...
[16:01:48.930] - state: ‘created’
[16:01:48.930] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:48.931] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:48.931] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:48.931]   - Field: ‘label’
[16:01:48.931]   - Field: ‘local’
[16:01:48.931]   - Field: ‘owner’
[16:01:48.931]   - Field: ‘envir’
[16:01:48.931]   - Field: ‘packages’
[16:01:48.931]   - Field: ‘gc’
[16:01:48.931]   - Field: ‘conditions’
[16:01:48.931]   - Field: ‘expr’
[16:01:48.932]   - Field: ‘uuid’
[16:01:48.932]   - Field: ‘seed’
[16:01:48.932]   - Field: ‘version’
[16:01:48.932]   - Field: ‘result’
[16:01:48.932]   - Field: ‘asynchronous’
[16:01:48.932]   - Field: ‘calls’
[16:01:48.932]   - Field: ‘globals’
[16:01:48.932]   - Field: ‘stdout’
[16:01:48.932]   - Field: ‘earlySignal’
[16:01:48.932]   - Field: ‘lazy’
[16:01:48.932]   - Field: ‘state’
[16:01:48.933] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:48.933] - Launch lazy future ...
[16:01:48.933] Packages needed by the future expression (n = 1): ‘stats’
[16:01:48.933] Packages needed by future strategies (n = 0): <none>
[16:01:48.933] {
[16:01:48.933]     {
[16:01:48.933]         {
[16:01:48.933]             ...future.startTime <- base::Sys.time()
[16:01:48.933]             {
[16:01:48.933]                 {
[16:01:48.933]                   {
[16:01:48.933]                     {
[16:01:48.933]                       base::local({
[16:01:48.933]                         has_future <- base::requireNamespace("future", 
[16:01:48.933]                           quietly = TRUE)
[16:01:48.933]                         if (has_future) {
[16:01:48.933]                           ns <- base::getNamespace("future")
[16:01:48.933]                           version <- ns[[".package"]][["version"]]
[16:01:48.933]                           if (is.null(version)) 
[16:01:48.933]                             version <- utils::packageVersion("future")
[16:01:48.933]                         }
[16:01:48.933]                         else {
[16:01:48.933]                           version <- NULL
[16:01:48.933]                         }
[16:01:48.933]                         if (!has_future || version < "1.8.0") {
[16:01:48.933]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:48.933]                             "", base::R.version$version.string), 
[16:01:48.933]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:48.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:48.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:48.933]                               "release", "version")], collapse = " "), 
[16:01:48.933]                             hostname = base::Sys.info()[["nodename"]])
[16:01:48.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:48.933]                             info)
[16:01:48.933]                           info <- base::paste(info, collapse = "; ")
[16:01:48.933]                           if (!has_future) {
[16:01:48.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:48.933]                               info)
[16:01:48.933]                           }
[16:01:48.933]                           else {
[16:01:48.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:48.933]                               info, version)
[16:01:48.933]                           }
[16:01:48.933]                           base::stop(msg)
[16:01:48.933]                         }
[16:01:48.933]                       })
[16:01:48.933]                     }
[16:01:48.933]                     base::local({
[16:01:48.933]                       for (pkg in "stats") {
[16:01:48.933]                         base::loadNamespace(pkg)
[16:01:48.933]                         base::library(pkg, character.only = TRUE)
[16:01:48.933]                       }
[16:01:48.933]                     })
[16:01:48.933]                   }
[16:01:48.933]                   options(future.plan = NULL)
[16:01:48.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:48.933]                 }
[16:01:48.933]                 ...future.workdir <- getwd()
[16:01:48.933]             }
[16:01:48.933]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:48.933]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:48.933]         }
[16:01:48.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:48.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:48.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:48.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:48.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:48.933]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:48.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:48.933]             base::names(...future.oldOptions))
[16:01:48.933]     }
[16:01:48.933]     if (FALSE) {
[16:01:48.933]     }
[16:01:48.933]     else {
[16:01:48.933]         if (TRUE) {
[16:01:48.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:48.933]                 open = "w")
[16:01:48.933]         }
[16:01:48.933]         else {
[16:01:48.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:48.933]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:48.933]         }
[16:01:48.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:48.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:48.933]             base::sink(type = "output", split = FALSE)
[16:01:48.933]             base::close(...future.stdout)
[16:01:48.933]         }, add = TRUE)
[16:01:48.933]     }
[16:01:48.933]     ...future.frame <- base::sys.nframe()
[16:01:48.933]     ...future.conditions <- base::list()
[16:01:48.933]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:48.933]     if (FALSE) {
[16:01:48.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:48.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:48.933]     }
[16:01:48.933]     ...future.result <- base::tryCatch({
[16:01:48.933]         base::withCallingHandlers({
[16:01:48.933]             ...future.value <- base::withVisible(base::local({
[16:01:48.933]                 do.call(function(...) {
[16:01:48.933]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.933]                   if (!identical(...future.globals.maxSize.org, 
[16:01:48.933]                     ...future.globals.maxSize)) {
[16:01:48.933]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.933]                     on.exit(options(oopts), add = TRUE)
[16:01:48.933]                   }
[16:01:48.933]                   {
[16:01:48.933]                     lapply(seq_along(...future.elements_ii), 
[16:01:48.933]                       FUN = function(jj) {
[16:01:48.933]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.933]                         ...future.FUN(...future.X_jj, ...)
[16:01:48.933]                       })
[16:01:48.933]                   }
[16:01:48.933]                 }, args = future.call.arguments)
[16:01:48.933]             }))
[16:01:48.933]             future::FutureResult(value = ...future.value$value, 
[16:01:48.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.933]                   ...future.rng), globalenv = if (FALSE) 
[16:01:48.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:48.933]                     ...future.globalenv.names))
[16:01:48.933]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:48.933]         }, condition = base::local({
[16:01:48.933]             c <- base::c
[16:01:48.933]             inherits <- base::inherits
[16:01:48.933]             invokeRestart <- base::invokeRestart
[16:01:48.933]             length <- base::length
[16:01:48.933]             list <- base::list
[16:01:48.933]             seq.int <- base::seq.int
[16:01:48.933]             signalCondition <- base::signalCondition
[16:01:48.933]             sys.calls <- base::sys.calls
[16:01:48.933]             `[[` <- base::`[[`
[16:01:48.933]             `+` <- base::`+`
[16:01:48.933]             `<<-` <- base::`<<-`
[16:01:48.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:48.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:48.933]                   3L)]
[16:01:48.933]             }
[16:01:48.933]             function(cond) {
[16:01:48.933]                 is_error <- inherits(cond, "error")
[16:01:48.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:48.933]                   NULL)
[16:01:48.933]                 if (is_error) {
[16:01:48.933]                   sessionInformation <- function() {
[16:01:48.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:48.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:48.933]                       search = base::search(), system = base::Sys.info())
[16:01:48.933]                   }
[16:01:48.933]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:48.933]                     cond$call), session = sessionInformation(), 
[16:01:48.933]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:48.933]                   signalCondition(cond)
[16:01:48.933]                 }
[16:01:48.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:48.933]                 "immediateCondition"))) {
[16:01:48.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:48.933]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:48.933]                   if (TRUE && !signal) {
[16:01:48.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.933]                     {
[16:01:48.933]                       inherits <- base::inherits
[16:01:48.933]                       invokeRestart <- base::invokeRestart
[16:01:48.933]                       is.null <- base::is.null
[16:01:48.933]                       muffled <- FALSE
[16:01:48.933]                       if (inherits(cond, "message")) {
[16:01:48.933]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.933]                         if (muffled) 
[16:01:48.933]                           invokeRestart("muffleMessage")
[16:01:48.933]                       }
[16:01:48.933]                       else if (inherits(cond, "warning")) {
[16:01:48.933]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.933]                         if (muffled) 
[16:01:48.933]                           invokeRestart("muffleWarning")
[16:01:48.933]                       }
[16:01:48.933]                       else if (inherits(cond, "condition")) {
[16:01:48.933]                         if (!is.null(pattern)) {
[16:01:48.933]                           computeRestarts <- base::computeRestarts
[16:01:48.933]                           grepl <- base::grepl
[16:01:48.933]                           restarts <- computeRestarts(cond)
[16:01:48.933]                           for (restart in restarts) {
[16:01:48.933]                             name <- restart$name
[16:01:48.933]                             if (is.null(name)) 
[16:01:48.933]                               next
[16:01:48.933]                             if (!grepl(pattern, name)) 
[16:01:48.933]                               next
[16:01:48.933]                             invokeRestart(restart)
[16:01:48.933]                             muffled <- TRUE
[16:01:48.933]                             break
[16:01:48.933]                           }
[16:01:48.933]                         }
[16:01:48.933]                       }
[16:01:48.933]                       invisible(muffled)
[16:01:48.933]                     }
[16:01:48.933]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.933]                   }
[16:01:48.933]                 }
[16:01:48.933]                 else {
[16:01:48.933]                   if (TRUE) {
[16:01:48.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.933]                     {
[16:01:48.933]                       inherits <- base::inherits
[16:01:48.933]                       invokeRestart <- base::invokeRestart
[16:01:48.933]                       is.null <- base::is.null
[16:01:48.933]                       muffled <- FALSE
[16:01:48.933]                       if (inherits(cond, "message")) {
[16:01:48.933]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.933]                         if (muffled) 
[16:01:48.933]                           invokeRestart("muffleMessage")
[16:01:48.933]                       }
[16:01:48.933]                       else if (inherits(cond, "warning")) {
[16:01:48.933]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.933]                         if (muffled) 
[16:01:48.933]                           invokeRestart("muffleWarning")
[16:01:48.933]                       }
[16:01:48.933]                       else if (inherits(cond, "condition")) {
[16:01:48.933]                         if (!is.null(pattern)) {
[16:01:48.933]                           computeRestarts <- base::computeRestarts
[16:01:48.933]                           grepl <- base::grepl
[16:01:48.933]                           restarts <- computeRestarts(cond)
[16:01:48.933]                           for (restart in restarts) {
[16:01:48.933]                             name <- restart$name
[16:01:48.933]                             if (is.null(name)) 
[16:01:48.933]                               next
[16:01:48.933]                             if (!grepl(pattern, name)) 
[16:01:48.933]                               next
[16:01:48.933]                             invokeRestart(restart)
[16:01:48.933]                             muffled <- TRUE
[16:01:48.933]                             break
[16:01:48.933]                           }
[16:01:48.933]                         }
[16:01:48.933]                       }
[16:01:48.933]                       invisible(muffled)
[16:01:48.933]                     }
[16:01:48.933]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.933]                   }
[16:01:48.933]                 }
[16:01:48.933]             }
[16:01:48.933]         }))
[16:01:48.933]     }, error = function(ex) {
[16:01:48.933]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:48.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.933]                 ...future.rng), started = ...future.startTime, 
[16:01:48.933]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:48.933]             version = "1.8"), class = "FutureResult")
[16:01:48.933]     }, finally = {
[16:01:48.933]         if (!identical(...future.workdir, getwd())) 
[16:01:48.933]             setwd(...future.workdir)
[16:01:48.933]         {
[16:01:48.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:48.933]                 ...future.oldOptions$nwarnings <- NULL
[16:01:48.933]             }
[16:01:48.933]             base::options(...future.oldOptions)
[16:01:48.933]             if (.Platform$OS.type == "windows") {
[16:01:48.933]                 old_names <- names(...future.oldEnvVars)
[16:01:48.933]                 envs <- base::Sys.getenv()
[16:01:48.933]                 names <- names(envs)
[16:01:48.933]                 common <- intersect(names, old_names)
[16:01:48.933]                 added <- setdiff(names, old_names)
[16:01:48.933]                 removed <- setdiff(old_names, names)
[16:01:48.933]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:48.933]                   envs[common]]
[16:01:48.933]                 NAMES <- toupper(changed)
[16:01:48.933]                 args <- list()
[16:01:48.933]                 for (kk in seq_along(NAMES)) {
[16:01:48.933]                   name <- changed[[kk]]
[16:01:48.933]                   NAME <- NAMES[[kk]]
[16:01:48.933]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.933]                     next
[16:01:48.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.933]                 }
[16:01:48.933]                 NAMES <- toupper(added)
[16:01:48.933]                 for (kk in seq_along(NAMES)) {
[16:01:48.933]                   name <- added[[kk]]
[16:01:48.933]                   NAME <- NAMES[[kk]]
[16:01:48.933]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.933]                     next
[16:01:48.933]                   args[[name]] <- ""
[16:01:48.933]                 }
[16:01:48.933]                 NAMES <- toupper(removed)
[16:01:48.933]                 for (kk in seq_along(NAMES)) {
[16:01:48.933]                   name <- removed[[kk]]
[16:01:48.933]                   NAME <- NAMES[[kk]]
[16:01:48.933]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.933]                     next
[16:01:48.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.933]                 }
[16:01:48.933]                 if (length(args) > 0) 
[16:01:48.933]                   base::do.call(base::Sys.setenv, args = args)
[16:01:48.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:48.933]             }
[16:01:48.933]             else {
[16:01:48.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:48.933]             }
[16:01:48.933]             {
[16:01:48.933]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:48.933]                   0L) {
[16:01:48.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:48.933]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:48.933]                   base::options(opts)
[16:01:48.933]                 }
[16:01:48.933]                 {
[16:01:48.933]                   {
[16:01:48.933]                     NULL
[16:01:48.933]                     RNGkind("Mersenne-Twister")
[16:01:48.933]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:48.933]                       inherits = FALSE)
[16:01:48.933]                   }
[16:01:48.933]                   options(future.plan = NULL)
[16:01:48.933]                   if (is.na(NA_character_)) 
[16:01:48.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:48.933]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:48.933]                   {
[16:01:48.933]                     future <- SequentialFuture(..., envir = envir)
[16:01:48.933]                     if (!future$lazy) 
[16:01:48.933]                       future <- run(future)
[16:01:48.933]                     invisible(future)
[16:01:48.933]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:48.933]                 }
[16:01:48.933]             }
[16:01:48.933]         }
[16:01:48.933]     })
[16:01:48.933]     if (TRUE) {
[16:01:48.933]         base::sink(type = "output", split = FALSE)
[16:01:48.933]         if (TRUE) {
[16:01:48.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:48.933]         }
[16:01:48.933]         else {
[16:01:48.933]             ...future.result["stdout"] <- base::list(NULL)
[16:01:48.933]         }
[16:01:48.933]         base::close(...future.stdout)
[16:01:48.933]         ...future.stdout <- NULL
[16:01:48.933]     }
[16:01:48.933]     ...future.result$conditions <- ...future.conditions
[16:01:48.933]     ...future.result$finished <- base::Sys.time()
[16:01:48.933]     ...future.result
[16:01:48.933] }
[16:01:48.935] assign_globals() ...
[16:01:48.935] List of 5
[16:01:48.935]  $ ...future.FUN            :function (x, ...)  
[16:01:48.935]  $ future.call.arguments    : list()
[16:01:48.935]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.935]  $ ...future.elements_ii    :List of 3
[16:01:48.935]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:01:48.935]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:01:48.935]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:01:48.935]  $ ...future.seeds_ii       : NULL
[16:01:48.935]  $ ...future.globals.maxSize: NULL
[16:01:48.935]  - attr(*, "where")=List of 5
[16:01:48.935]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:48.935]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:48.935]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:48.935]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:48.935]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:48.935]  - attr(*, "resolved")= logi FALSE
[16:01:48.935]  - attr(*, "total_size")= num 1248
[16:01:48.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.935]  - attr(*, "already-done")= logi TRUE
[16:01:48.942] - copied ‘...future.FUN’ to environment
[16:01:48.942] - copied ‘future.call.arguments’ to environment
[16:01:48.942] - copied ‘...future.elements_ii’ to environment
[16:01:48.942] - copied ‘...future.seeds_ii’ to environment
[16:01:48.942] - copied ‘...future.globals.maxSize’ to environment
[16:01:48.943] assign_globals() ... done
[16:01:48.943] plan(): Setting new future strategy stack:
[16:01:48.943] List of future strategies:
[16:01:48.943] 1. sequential:
[16:01:48.943]    - args: function (..., envir = parent.frame())
[16:01:48.943]    - tweaked: FALSE
[16:01:48.943]    - call: NULL
[16:01:48.943] plan(): nbrOfWorkers() = 1
[16:01:48.945] plan(): Setting new future strategy stack:
[16:01:48.945] List of future strategies:
[16:01:48.945] 1. sequential:
[16:01:48.945]    - args: function (..., envir = parent.frame())
[16:01:48.945]    - tweaked: FALSE
[16:01:48.945]    - call: plan(strategy)
[16:01:48.945] plan(): nbrOfWorkers() = 1
[16:01:48.945] SequentialFuture started (and completed)
[16:01:48.945] - Launch lazy future ... done
[16:01:48.945] run() for ‘SequentialFuture’ ... done
[16:01:48.945] Created future:
[16:01:48.946] SequentialFuture:
[16:01:48.946] Label: ‘future_eapply-1’
[16:01:48.946] Expression:
[16:01:48.946] {
[16:01:48.946]     do.call(function(...) {
[16:01:48.946]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.946]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.946]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.946]             on.exit(options(oopts), add = TRUE)
[16:01:48.946]         }
[16:01:48.946]         {
[16:01:48.946]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.946]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.946]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.946]             })
[16:01:48.946]         }
[16:01:48.946]     }, args = future.call.arguments)
[16:01:48.946] }
[16:01:48.946] Lazy evaluation: FALSE
[16:01:48.946] Asynchronous evaluation: FALSE
[16:01:48.946] Local evaluation: TRUE
[16:01:48.946] Environment: R_GlobalEnv
[16:01:48.946] Capture standard output: TRUE
[16:01:48.946] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:48.946] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:48.946] Packages: 1 packages (‘stats’)
[16:01:48.946] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:48.946] Resolved: TRUE
[16:01:48.946] Value: 1.71 KiB of class ‘list’
[16:01:48.946] Early signaling: FALSE
[16:01:48.946] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:48.946] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:48.947] Chunk #1 of 1 ... DONE
[16:01:48.947] Launching 1 futures (chunks) ... DONE
[16:01:48.947] Resolving 1 futures (chunks) ...
[16:01:48.947] resolve() on list ...
[16:01:48.947]  recursive: 0
[16:01:48.947]  length: 1
[16:01:48.947] 
[16:01:48.947] resolved() for ‘SequentialFuture’ ...
[16:01:48.947] - state: ‘finished’
[16:01:48.947] - run: TRUE
[16:01:48.947] - result: ‘FutureResult’
[16:01:48.948] resolved() for ‘SequentialFuture’ ... done
[16:01:48.948] Future #1
[16:01:48.948] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:48.948] - nx: 1
[16:01:48.948] - relay: TRUE
[16:01:48.948] - stdout: TRUE
[16:01:48.948] - signal: TRUE
[16:01:48.948] - resignal: FALSE
[16:01:48.948] - force: TRUE
[16:01:48.948] - relayed: [n=1] FALSE
[16:01:48.948] - queued futures: [n=1] FALSE
[16:01:48.949]  - until=1
[16:01:48.949]  - relaying element #1
[16:01:48.949] - relayed: [n=1] TRUE
[16:01:48.949] - queued futures: [n=1] TRUE
[16:01:48.949] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:48.949]  length: 0 (resolved future 1)
[16:01:48.949] Relaying remaining futures
[16:01:48.949] signalConditionsASAP(NULL, pos=0) ...
[16:01:48.949] - nx: 1
[16:01:48.949] - relay: TRUE
[16:01:48.950] - stdout: TRUE
[16:01:48.950] - signal: TRUE
[16:01:48.950] - resignal: FALSE
[16:01:48.950] - force: TRUE
[16:01:48.950] - relayed: [n=1] TRUE
[16:01:48.950] - queued futures: [n=1] TRUE
 - flush all
[16:01:48.950] - relayed: [n=1] TRUE
[16:01:48.950] - queued futures: [n=1] TRUE
[16:01:48.950] signalConditionsASAP(NULL, pos=0) ... done
[16:01:48.950] resolve() on list ... DONE
[16:01:48.950]  - Number of value chunks collected: 1
[16:01:48.951] Resolving 1 futures (chunks) ... DONE
[16:01:48.951] Reducing values from 1 chunks ...
[16:01:48.951]  - Number of values collected after concatenation: 3
[16:01:48.951]  - Number of values expected: 3
[16:01:48.951] Reducing values from 1 chunks ... DONE
[16:01:48.951] future_lapply() ... DONE
[16:01:48.951] future_lapply() ...
[16:01:48.952] Number of chunks: 1
[16:01:48.952] getGlobalsAndPackagesXApply() ...
[16:01:48.952]  - future.globals: TRUE
[16:01:48.952] getGlobalsAndPackages() ...
[16:01:48.952] Searching for globals...
[16:01:48.953] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:48.953] Searching for globals ... DONE
[16:01:48.953] Resolving globals: FALSE
[16:01:48.954] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:48.954] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:48.954] - globals: [1] ‘FUN’
[16:01:48.954] - packages: [1] ‘stats’
[16:01:48.954] getGlobalsAndPackages() ... DONE
[16:01:48.954]  - globals found/used: [n=1] ‘FUN’
[16:01:48.954]  - needed namespaces: [n=1] ‘stats’
[16:01:48.955] Finding globals ... DONE
[16:01:48.955]  - use_args: TRUE
[16:01:48.955]  - Getting '...' globals ...
[16:01:48.955] resolve() on list ...
[16:01:48.955]  recursive: 0
[16:01:48.955]  length: 1
[16:01:48.955]  elements: ‘...’
[16:01:48.955]  length: 0 (resolved future 1)
[16:01:48.955] resolve() on list ... DONE
[16:01:48.956]    - '...' content: [n=0] 
[16:01:48.956] List of 1
[16:01:48.956]  $ ...: list()
[16:01:48.956]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.956]  - attr(*, "where")=List of 1
[16:01:48.956]   ..$ ...:<environment: 0x5620a19871f8> 
[16:01:48.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.956]  - attr(*, "resolved")= logi TRUE
[16:01:48.956]  - attr(*, "total_size")= num NA
[16:01:48.958]  - Getting '...' globals ... DONE
[16:01:48.958] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:48.958] List of 2
[16:01:48.958]  $ ...future.FUN:function (x, ...)  
[16:01:48.958]  $ ...          : list()
[16:01:48.958]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.958]  - attr(*, "where")=List of 2
[16:01:48.958]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:48.958]   ..$ ...          :<environment: 0x5620a19871f8> 
[16:01:48.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.958]  - attr(*, "resolved")= logi FALSE
[16:01:48.958]  - attr(*, "total_size")= num 1248
[16:01:48.962] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:48.962] getGlobalsAndPackagesXApply() ... DONE
[16:01:48.963] Number of futures (= number of chunks): 1
[16:01:48.963] Launching 1 futures (chunks) ...
[16:01:48.963] Chunk #1 of 1 ...
[16:01:48.963]  - Finding globals in 'X' for chunk #1 ...
[16:01:48.963] getGlobalsAndPackages() ...
[16:01:48.963] Searching for globals...
[16:01:48.963] 
[16:01:48.963] Searching for globals ... DONE
[16:01:48.964] - globals: [0] <none>
[16:01:48.964] getGlobalsAndPackages() ... DONE
[16:01:48.964]    + additional globals found: [n=0] 
[16:01:48.964]    + additional namespaces needed: [n=0] 
[16:01:48.964]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:48.964]  - seeds: <none>
[16:01:48.964]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.964] getGlobalsAndPackages() ...
[16:01:48.964] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.964] Resolving globals: FALSE
[16:01:48.964] Tweak future expression to call with '...' arguments ...
[16:01:48.965] {
[16:01:48.965]     do.call(function(...) {
[16:01:48.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.965]             on.exit(options(oopts), add = TRUE)
[16:01:48.965]         }
[16:01:48.965]         {
[16:01:48.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.965]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.965]             })
[16:01:48.965]         }
[16:01:48.965]     }, args = future.call.arguments)
[16:01:48.965] }
[16:01:48.965] Tweak future expression to call with '...' arguments ... DONE
[16:01:48.965] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.965] - packages: [1] ‘stats’
[16:01:48.965] getGlobalsAndPackages() ... DONE
[16:01:48.966] run() for ‘Future’ ...
[16:01:48.966] - state: ‘created’
[16:01:48.966] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:48.966] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:48.966] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:48.966]   - Field: ‘label’
[16:01:48.966]   - Field: ‘local’
[16:01:48.967]   - Field: ‘owner’
[16:01:48.967]   - Field: ‘envir’
[16:01:48.967]   - Field: ‘packages’
[16:01:48.967]   - Field: ‘gc’
[16:01:48.967]   - Field: ‘conditions’
[16:01:48.967]   - Field: ‘expr’
[16:01:48.967]   - Field: ‘uuid’
[16:01:48.967]   - Field: ‘seed’
[16:01:48.967]   - Field: ‘version’
[16:01:48.967]   - Field: ‘result’
[16:01:48.968]   - Field: ‘asynchronous’
[16:01:48.968]   - Field: ‘calls’
[16:01:48.968]   - Field: ‘globals’
[16:01:48.968]   - Field: ‘stdout’
[16:01:48.968]   - Field: ‘earlySignal’
[16:01:48.968]   - Field: ‘lazy’
[16:01:48.968]   - Field: ‘state’
[16:01:48.968] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:48.968] - Launch lazy future ...
[16:01:48.968] Packages needed by the future expression (n = 1): ‘stats’
[16:01:48.969] Packages needed by future strategies (n = 0): <none>
[16:01:48.969] {
[16:01:48.969]     {
[16:01:48.969]         {
[16:01:48.969]             ...future.startTime <- base::Sys.time()
[16:01:48.969]             {
[16:01:48.969]                 {
[16:01:48.969]                   {
[16:01:48.969]                     {
[16:01:48.969]                       base::local({
[16:01:48.969]                         has_future <- base::requireNamespace("future", 
[16:01:48.969]                           quietly = TRUE)
[16:01:48.969]                         if (has_future) {
[16:01:48.969]                           ns <- base::getNamespace("future")
[16:01:48.969]                           version <- ns[[".package"]][["version"]]
[16:01:48.969]                           if (is.null(version)) 
[16:01:48.969]                             version <- utils::packageVersion("future")
[16:01:48.969]                         }
[16:01:48.969]                         else {
[16:01:48.969]                           version <- NULL
[16:01:48.969]                         }
[16:01:48.969]                         if (!has_future || version < "1.8.0") {
[16:01:48.969]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:48.969]                             "", base::R.version$version.string), 
[16:01:48.969]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:48.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:48.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:48.969]                               "release", "version")], collapse = " "), 
[16:01:48.969]                             hostname = base::Sys.info()[["nodename"]])
[16:01:48.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:48.969]                             info)
[16:01:48.969]                           info <- base::paste(info, collapse = "; ")
[16:01:48.969]                           if (!has_future) {
[16:01:48.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:48.969]                               info)
[16:01:48.969]                           }
[16:01:48.969]                           else {
[16:01:48.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:48.969]                               info, version)
[16:01:48.969]                           }
[16:01:48.969]                           base::stop(msg)
[16:01:48.969]                         }
[16:01:48.969]                       })
[16:01:48.969]                     }
[16:01:48.969]                     base::local({
[16:01:48.969]                       for (pkg in "stats") {
[16:01:48.969]                         base::loadNamespace(pkg)
[16:01:48.969]                         base::library(pkg, character.only = TRUE)
[16:01:48.969]                       }
[16:01:48.969]                     })
[16:01:48.969]                   }
[16:01:48.969]                   options(future.plan = NULL)
[16:01:48.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:48.969]                 }
[16:01:48.969]                 ...future.workdir <- getwd()
[16:01:48.969]             }
[16:01:48.969]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:48.969]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:48.969]         }
[16:01:48.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:48.969]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:48.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:48.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:48.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:48.969]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:48.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:48.969]             base::names(...future.oldOptions))
[16:01:48.969]     }
[16:01:48.969]     if (FALSE) {
[16:01:48.969]     }
[16:01:48.969]     else {
[16:01:48.969]         if (TRUE) {
[16:01:48.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:48.969]                 open = "w")
[16:01:48.969]         }
[16:01:48.969]         else {
[16:01:48.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:48.969]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:48.969]         }
[16:01:48.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:48.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:48.969]             base::sink(type = "output", split = FALSE)
[16:01:48.969]             base::close(...future.stdout)
[16:01:48.969]         }, add = TRUE)
[16:01:48.969]     }
[16:01:48.969]     ...future.frame <- base::sys.nframe()
[16:01:48.969]     ...future.conditions <- base::list()
[16:01:48.969]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:48.969]     if (FALSE) {
[16:01:48.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:48.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:48.969]     }
[16:01:48.969]     ...future.result <- base::tryCatch({
[16:01:48.969]         base::withCallingHandlers({
[16:01:48.969]             ...future.value <- base::withVisible(base::local({
[16:01:48.969]                 do.call(function(...) {
[16:01:48.969]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.969]                   if (!identical(...future.globals.maxSize.org, 
[16:01:48.969]                     ...future.globals.maxSize)) {
[16:01:48.969]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.969]                     on.exit(options(oopts), add = TRUE)
[16:01:48.969]                   }
[16:01:48.969]                   {
[16:01:48.969]                     lapply(seq_along(...future.elements_ii), 
[16:01:48.969]                       FUN = function(jj) {
[16:01:48.969]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.969]                         ...future.FUN(...future.X_jj, ...)
[16:01:48.969]                       })
[16:01:48.969]                   }
[16:01:48.969]                 }, args = future.call.arguments)
[16:01:48.969]             }))
[16:01:48.969]             future::FutureResult(value = ...future.value$value, 
[16:01:48.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.969]                   ...future.rng), globalenv = if (FALSE) 
[16:01:48.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:48.969]                     ...future.globalenv.names))
[16:01:48.969]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:48.969]         }, condition = base::local({
[16:01:48.969]             c <- base::c
[16:01:48.969]             inherits <- base::inherits
[16:01:48.969]             invokeRestart <- base::invokeRestart
[16:01:48.969]             length <- base::length
[16:01:48.969]             list <- base::list
[16:01:48.969]             seq.int <- base::seq.int
[16:01:48.969]             signalCondition <- base::signalCondition
[16:01:48.969]             sys.calls <- base::sys.calls
[16:01:48.969]             `[[` <- base::`[[`
[16:01:48.969]             `+` <- base::`+`
[16:01:48.969]             `<<-` <- base::`<<-`
[16:01:48.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:48.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:48.969]                   3L)]
[16:01:48.969]             }
[16:01:48.969]             function(cond) {
[16:01:48.969]                 is_error <- inherits(cond, "error")
[16:01:48.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:48.969]                   NULL)
[16:01:48.969]                 if (is_error) {
[16:01:48.969]                   sessionInformation <- function() {
[16:01:48.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:48.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:48.969]                       search = base::search(), system = base::Sys.info())
[16:01:48.969]                   }
[16:01:48.969]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:48.969]                     cond$call), session = sessionInformation(), 
[16:01:48.969]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:48.969]                   signalCondition(cond)
[16:01:48.969]                 }
[16:01:48.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:48.969]                 "immediateCondition"))) {
[16:01:48.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:48.969]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:48.969]                   if (TRUE && !signal) {
[16:01:48.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.969]                     {
[16:01:48.969]                       inherits <- base::inherits
[16:01:48.969]                       invokeRestart <- base::invokeRestart
[16:01:48.969]                       is.null <- base::is.null
[16:01:48.969]                       muffled <- FALSE
[16:01:48.969]                       if (inherits(cond, "message")) {
[16:01:48.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.969]                         if (muffled) 
[16:01:48.969]                           invokeRestart("muffleMessage")
[16:01:48.969]                       }
[16:01:48.969]                       else if (inherits(cond, "warning")) {
[16:01:48.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.969]                         if (muffled) 
[16:01:48.969]                           invokeRestart("muffleWarning")
[16:01:48.969]                       }
[16:01:48.969]                       else if (inherits(cond, "condition")) {
[16:01:48.969]                         if (!is.null(pattern)) {
[16:01:48.969]                           computeRestarts <- base::computeRestarts
[16:01:48.969]                           grepl <- base::grepl
[16:01:48.969]                           restarts <- computeRestarts(cond)
[16:01:48.969]                           for (restart in restarts) {
[16:01:48.969]                             name <- restart$name
[16:01:48.969]                             if (is.null(name)) 
[16:01:48.969]                               next
[16:01:48.969]                             if (!grepl(pattern, name)) 
[16:01:48.969]                               next
[16:01:48.969]                             invokeRestart(restart)
[16:01:48.969]                             muffled <- TRUE
[16:01:48.969]                             break
[16:01:48.969]                           }
[16:01:48.969]                         }
[16:01:48.969]                       }
[16:01:48.969]                       invisible(muffled)
[16:01:48.969]                     }
[16:01:48.969]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.969]                   }
[16:01:48.969]                 }
[16:01:48.969]                 else {
[16:01:48.969]                   if (TRUE) {
[16:01:48.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.969]                     {
[16:01:48.969]                       inherits <- base::inherits
[16:01:48.969]                       invokeRestart <- base::invokeRestart
[16:01:48.969]                       is.null <- base::is.null
[16:01:48.969]                       muffled <- FALSE
[16:01:48.969]                       if (inherits(cond, "message")) {
[16:01:48.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.969]                         if (muffled) 
[16:01:48.969]                           invokeRestart("muffleMessage")
[16:01:48.969]                       }
[16:01:48.969]                       else if (inherits(cond, "warning")) {
[16:01:48.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.969]                         if (muffled) 
[16:01:48.969]                           invokeRestart("muffleWarning")
[16:01:48.969]                       }
[16:01:48.969]                       else if (inherits(cond, "condition")) {
[16:01:48.969]                         if (!is.null(pattern)) {
[16:01:48.969]                           computeRestarts <- base::computeRestarts
[16:01:48.969]                           grepl <- base::grepl
[16:01:48.969]                           restarts <- computeRestarts(cond)
[16:01:48.969]                           for (restart in restarts) {
[16:01:48.969]                             name <- restart$name
[16:01:48.969]                             if (is.null(name)) 
[16:01:48.969]                               next
[16:01:48.969]                             if (!grepl(pattern, name)) 
[16:01:48.969]                               next
[16:01:48.969]                             invokeRestart(restart)
[16:01:48.969]                             muffled <- TRUE
[16:01:48.969]                             break
[16:01:48.969]                           }
[16:01:48.969]                         }
[16:01:48.969]                       }
[16:01:48.969]                       invisible(muffled)
[16:01:48.969]                     }
[16:01:48.969]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.969]                   }
[16:01:48.969]                 }
[16:01:48.969]             }
[16:01:48.969]         }))
[16:01:48.969]     }, error = function(ex) {
[16:01:48.969]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:48.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.969]                 ...future.rng), started = ...future.startTime, 
[16:01:48.969]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:48.969]             version = "1.8"), class = "FutureResult")
[16:01:48.969]     }, finally = {
[16:01:48.969]         if (!identical(...future.workdir, getwd())) 
[16:01:48.969]             setwd(...future.workdir)
[16:01:48.969]         {
[16:01:48.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:48.969]                 ...future.oldOptions$nwarnings <- NULL
[16:01:48.969]             }
[16:01:48.969]             base::options(...future.oldOptions)
[16:01:48.969]             if (.Platform$OS.type == "windows") {
[16:01:48.969]                 old_names <- names(...future.oldEnvVars)
[16:01:48.969]                 envs <- base::Sys.getenv()
[16:01:48.969]                 names <- names(envs)
[16:01:48.969]                 common <- intersect(names, old_names)
[16:01:48.969]                 added <- setdiff(names, old_names)
[16:01:48.969]                 removed <- setdiff(old_names, names)
[16:01:48.969]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:48.969]                   envs[common]]
[16:01:48.969]                 NAMES <- toupper(changed)
[16:01:48.969]                 args <- list()
[16:01:48.969]                 for (kk in seq_along(NAMES)) {
[16:01:48.969]                   name <- changed[[kk]]
[16:01:48.969]                   NAME <- NAMES[[kk]]
[16:01:48.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.969]                     next
[16:01:48.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.969]                 }
[16:01:48.969]                 NAMES <- toupper(added)
[16:01:48.969]                 for (kk in seq_along(NAMES)) {
[16:01:48.969]                   name <- added[[kk]]
[16:01:48.969]                   NAME <- NAMES[[kk]]
[16:01:48.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.969]                     next
[16:01:48.969]                   args[[name]] <- ""
[16:01:48.969]                 }
[16:01:48.969]                 NAMES <- toupper(removed)
[16:01:48.969]                 for (kk in seq_along(NAMES)) {
[16:01:48.969]                   name <- removed[[kk]]
[16:01:48.969]                   NAME <- NAMES[[kk]]
[16:01:48.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.969]                     next
[16:01:48.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.969]                 }
[16:01:48.969]                 if (length(args) > 0) 
[16:01:48.969]                   base::do.call(base::Sys.setenv, args = args)
[16:01:48.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:48.969]             }
[16:01:48.969]             else {
[16:01:48.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:48.969]             }
[16:01:48.969]             {
[16:01:48.969]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:48.969]                   0L) {
[16:01:48.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:48.969]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:48.969]                   base::options(opts)
[16:01:48.969]                 }
[16:01:48.969]                 {
[16:01:48.969]                   {
[16:01:48.969]                     NULL
[16:01:48.969]                     RNGkind("Mersenne-Twister")
[16:01:48.969]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:48.969]                       inherits = FALSE)
[16:01:48.969]                   }
[16:01:48.969]                   options(future.plan = NULL)
[16:01:48.969]                   if (is.na(NA_character_)) 
[16:01:48.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:48.969]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:48.969]                   {
[16:01:48.969]                     future <- SequentialFuture(..., envir = envir)
[16:01:48.969]                     if (!future$lazy) 
[16:01:48.969]                       future <- run(future)
[16:01:48.969]                     invisible(future)
[16:01:48.969]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:48.969]                 }
[16:01:48.969]             }
[16:01:48.969]         }
[16:01:48.969]     })
[16:01:48.969]     if (TRUE) {
[16:01:48.969]         base::sink(type = "output", split = FALSE)
[16:01:48.969]         if (TRUE) {
[16:01:48.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:48.969]         }
[16:01:48.969]         else {
[16:01:48.969]             ...future.result["stdout"] <- base::list(NULL)
[16:01:48.969]         }
[16:01:48.969]         base::close(...future.stdout)
[16:01:48.969]         ...future.stdout <- NULL
[16:01:48.969]     }
[16:01:48.969]     ...future.result$conditions <- ...future.conditions
[16:01:48.969]     ...future.result$finished <- base::Sys.time()
[16:01:48.969]     ...future.result
[16:01:48.969] }
[16:01:48.971] assign_globals() ...
[16:01:48.971] List of 5
[16:01:48.971]  $ ...future.FUN            :function (x, ...)  
[16:01:48.971]  $ future.call.arguments    : list()
[16:01:48.971]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.971]  $ ...future.elements_ii    :List of 3
[16:01:48.971]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:01:48.971]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:01:48.971]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:01:48.971]  $ ...future.seeds_ii       : NULL
[16:01:48.971]  $ ...future.globals.maxSize: NULL
[16:01:48.971]  - attr(*, "where")=List of 5
[16:01:48.971]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:48.971]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:48.971]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:48.971]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:48.971]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:48.971]  - attr(*, "resolved")= logi FALSE
[16:01:48.971]  - attr(*, "total_size")= num 1248
[16:01:48.971]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.971]  - attr(*, "already-done")= logi TRUE
[16:01:48.976] - copied ‘...future.FUN’ to environment
[16:01:48.976] - copied ‘future.call.arguments’ to environment
[16:01:48.976] - copied ‘...future.elements_ii’ to environment
[16:01:48.976] - copied ‘...future.seeds_ii’ to environment
[16:01:48.976] - copied ‘...future.globals.maxSize’ to environment
[16:01:48.976] assign_globals() ... done
[16:01:48.977] plan(): Setting new future strategy stack:
[16:01:48.977] List of future strategies:
[16:01:48.977] 1. sequential:
[16:01:48.977]    - args: function (..., envir = parent.frame())
[16:01:48.977]    - tweaked: FALSE
[16:01:48.977]    - call: NULL
[16:01:48.977] plan(): nbrOfWorkers() = 1
[16:01:48.978] plan(): Setting new future strategy stack:
[16:01:48.979] List of future strategies:
[16:01:48.979] 1. sequential:
[16:01:48.979]    - args: function (..., envir = parent.frame())
[16:01:48.979]    - tweaked: FALSE
[16:01:48.979]    - call: plan(strategy)
[16:01:48.979] plan(): nbrOfWorkers() = 1
[16:01:48.979] SequentialFuture started (and completed)
[16:01:48.979] - Launch lazy future ... done
[16:01:48.979] run() for ‘SequentialFuture’ ... done
[16:01:48.980] Created future:
[16:01:48.980] SequentialFuture:
[16:01:48.980] Label: ‘future_eapply-1’
[16:01:48.980] Expression:
[16:01:48.980] {
[16:01:48.980]     do.call(function(...) {
[16:01:48.980]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.980]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.980]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.980]             on.exit(options(oopts), add = TRUE)
[16:01:48.980]         }
[16:01:48.980]         {
[16:01:48.980]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.980]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.980]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.980]             })
[16:01:48.980]         }
[16:01:48.980]     }, args = future.call.arguments)
[16:01:48.980] }
[16:01:48.980] Lazy evaluation: FALSE
[16:01:48.980] Asynchronous evaluation: FALSE
[16:01:48.980] Local evaluation: TRUE
[16:01:48.980] Environment: R_GlobalEnv
[16:01:48.980] Capture standard output: TRUE
[16:01:48.980] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:48.980] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:48.980] Packages: 1 packages (‘stats’)
[16:01:48.980] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:48.980] Resolved: TRUE
[16:01:48.980] Value: 1.71 KiB of class ‘list’
[16:01:48.980] Early signaling: FALSE
[16:01:48.980] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:48.980] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:48.981] Chunk #1 of 1 ... DONE
[16:01:48.981] Launching 1 futures (chunks) ... DONE
[16:01:48.981] Resolving 1 futures (chunks) ...
[16:01:48.981] resolve() on list ...
[16:01:48.981]  recursive: 0
[16:01:48.981]  length: 1
[16:01:48.981] 
[16:01:48.981] resolved() for ‘SequentialFuture’ ...
[16:01:48.981] - state: ‘finished’
[16:01:48.981] - run: TRUE
[16:01:48.982] - result: ‘FutureResult’
[16:01:48.982] resolved() for ‘SequentialFuture’ ... done
[16:01:48.982] Future #1
[16:01:48.982] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:48.982] - nx: 1
[16:01:48.982] - relay: TRUE
[16:01:48.982] - stdout: TRUE
[16:01:48.982] - signal: TRUE
[16:01:48.982] - resignal: FALSE
[16:01:48.982] - force: TRUE
[16:01:48.982] - relayed: [n=1] FALSE
[16:01:48.983] - queued futures: [n=1] FALSE
[16:01:48.983]  - until=1
[16:01:48.983]  - relaying element #1
[16:01:48.983] - relayed: [n=1] TRUE
[16:01:48.983] - queued futures: [n=1] TRUE
[16:01:48.983] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:48.985]  length: 0 (resolved future 1)
[16:01:48.985] Relaying remaining futures
[16:01:48.985] signalConditionsASAP(NULL, pos=0) ...
[16:01:48.985] - nx: 1
[16:01:48.985] - relay: TRUE
[16:01:48.985] - stdout: TRUE
[16:01:48.985] - signal: TRUE
[16:01:48.985] - resignal: FALSE
[16:01:48.986] - force: TRUE
[16:01:48.986] - relayed: [n=1] TRUE
[16:01:48.986] - queued futures: [n=1] TRUE
 - flush all
[16:01:48.986] - relayed: [n=1] TRUE
[16:01:48.986] - queued futures: [n=1] TRUE
[16:01:48.986] signalConditionsASAP(NULL, pos=0) ... done
[16:01:48.986] resolve() on list ... DONE
[16:01:48.986]  - Number of value chunks collected: 1
[16:01:48.986] Resolving 1 futures (chunks) ... DONE
[16:01:48.986] Reducing values from 1 chunks ...
[16:01:48.987]  - Number of values collected after concatenation: 3
[16:01:48.987]  - Number of values expected: 3
[16:01:48.987] Reducing values from 1 chunks ... DONE
[16:01:48.987] future_lapply() ... DONE
[16:01:48.987] plan(): Setting new future strategy stack:
[16:01:48.987] List of future strategies:
[16:01:48.987] 1. sequential:
[16:01:48.987]    - args: function (..., envir = parent.frame())
[16:01:48.987]    - tweaked: FALSE
[16:01:48.987]    - call: plan(sequential)
[16:01:48.988] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:01:48.988] plan(): Setting new future strategy stack:
[16:01:48.988] List of future strategies:
[16:01:48.988] 1. multicore:
[16:01:48.988]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:48.988]    - tweaked: FALSE
[16:01:48.988]    - call: plan(strategy)
[16:01:48.992] plan(): nbrOfWorkers() = 2
[16:01:48.993] future_lapply() ...
[16:01:48.997] Number of chunks: 2
[16:01:48.997] getGlobalsAndPackagesXApply() ...
[16:01:48.997]  - future.globals: TRUE
[16:01:48.997] getGlobalsAndPackages() ...
[16:01:48.997] Searching for globals...
[16:01:48.998] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:48.999] Searching for globals ... DONE
[16:01:48.999] Resolving globals: FALSE
[16:01:48.999] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:48.999] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:49.000] - globals: [1] ‘FUN’
[16:01:49.000] 
[16:01:49.000] getGlobalsAndPackages() ... DONE
[16:01:49.000]  - globals found/used: [n=1] ‘FUN’
[16:01:49.000]  - needed namespaces: [n=0] 
[16:01:49.000] Finding globals ... DONE
[16:01:49.000]  - use_args: TRUE
[16:01:49.000]  - Getting '...' globals ...
[16:01:49.001] resolve() on list ...
[16:01:49.001]  recursive: 0
[16:01:49.001]  length: 1
[16:01:49.001]  elements: ‘...’
[16:01:49.001]  length: 0 (resolved future 1)
[16:01:49.001] resolve() on list ... DONE
[16:01:49.001]    - '...' content: [n=0] 
[16:01:49.001] List of 1
[16:01:49.001]  $ ...: list()
[16:01:49.001]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.001]  - attr(*, "where")=List of 1
[16:01:49.001]   ..$ ...:<environment: 0x56209f7afc18> 
[16:01:49.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.001]  - attr(*, "resolved")= logi TRUE
[16:01:49.001]  - attr(*, "total_size")= num NA
[16:01:49.004]  - Getting '...' globals ... DONE
[16:01:49.004] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:49.004] List of 2
[16:01:49.004]  $ ...future.FUN:function (x, ...)  
[16:01:49.004]  $ ...          : list()
[16:01:49.004]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.004]  - attr(*, "where")=List of 2
[16:01:49.004]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:49.004]   ..$ ...          :<environment: 0x56209f7afc18> 
[16:01:49.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.004]  - attr(*, "resolved")= logi FALSE
[16:01:49.004]  - attr(*, "total_size")= num 1240
[16:01:49.007] Packages to be attached in all futures: [n=0] 
[16:01:49.007] getGlobalsAndPackagesXApply() ... DONE
[16:01:49.007] Number of futures (= number of chunks): 2
[16:01:49.007] Launching 2 futures (chunks) ...
[16:01:49.007] Chunk #1 of 2 ...
[16:01:49.007]  - Finding globals in 'X' for chunk #1 ...
[16:01:49.007] getGlobalsAndPackages() ...
[16:01:49.008] Searching for globals...
[16:01:49.008] 
[16:01:49.008] Searching for globals ... DONE
[16:01:49.008] - globals: [0] <none>
[16:01:49.008] getGlobalsAndPackages() ... DONE
[16:01:49.008]    + additional globals found: [n=0] 
[16:01:49.008]    + additional namespaces needed: [n=0] 
[16:01:49.008]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:49.008]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:49.008]  - seeds: <none>
[16:01:49.009]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.009] getGlobalsAndPackages() ...
[16:01:49.009] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.009] Resolving globals: FALSE
[16:01:49.009] Tweak future expression to call with '...' arguments ...
[16:01:49.009] {
[16:01:49.009]     do.call(function(...) {
[16:01:49.009]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.009]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.009]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.009]             on.exit(options(oopts), add = TRUE)
[16:01:49.009]         }
[16:01:49.009]         {
[16:01:49.009]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.009]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.009]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.009]             })
[16:01:49.009]         }
[16:01:49.009]     }, args = future.call.arguments)
[16:01:49.009] }
[16:01:49.009] Tweak future expression to call with '...' arguments ... DONE
[16:01:49.010] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.010] 
[16:01:49.010] getGlobalsAndPackages() ... DONE
[16:01:49.010] run() for ‘Future’ ...
[16:01:49.010] - state: ‘created’
[16:01:49.010] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:49.014] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.014] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:49.014]   - Field: ‘label’
[16:01:49.015]   - Field: ‘local’
[16:01:49.015]   - Field: ‘owner’
[16:01:49.015]   - Field: ‘envir’
[16:01:49.015]   - Field: ‘workers’
[16:01:49.017]   - Field: ‘packages’
[16:01:49.017]   - Field: ‘gc’
[16:01:49.017]   - Field: ‘job’
[16:01:49.017]   - Field: ‘conditions’
[16:01:49.017]   - Field: ‘expr’
[16:01:49.017]   - Field: ‘uuid’
[16:01:49.017]   - Field: ‘seed’
[16:01:49.017]   - Field: ‘version’
[16:01:49.018]   - Field: ‘result’
[16:01:49.018]   - Field: ‘asynchronous’
[16:01:49.018]   - Field: ‘calls’
[16:01:49.018]   - Field: ‘globals’
[16:01:49.018]   - Field: ‘stdout’
[16:01:49.018]   - Field: ‘earlySignal’
[16:01:49.018]   - Field: ‘lazy’
[16:01:49.018]   - Field: ‘state’
[16:01:49.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:49.018] - Launch lazy future ...
[16:01:49.020] Packages needed by the future expression (n = 0): <none>
[16:01:49.020] Packages needed by future strategies (n = 0): <none>
[16:01:49.020] {
[16:01:49.020]     {
[16:01:49.020]         {
[16:01:49.020]             ...future.startTime <- base::Sys.time()
[16:01:49.020]             {
[16:01:49.020]                 {
[16:01:49.020]                   {
[16:01:49.020]                     {
[16:01:49.020]                       base::local({
[16:01:49.020]                         has_future <- base::requireNamespace("future", 
[16:01:49.020]                           quietly = TRUE)
[16:01:49.020]                         if (has_future) {
[16:01:49.020]                           ns <- base::getNamespace("future")
[16:01:49.020]                           version <- ns[[".package"]][["version"]]
[16:01:49.020]                           if (is.null(version)) 
[16:01:49.020]                             version <- utils::packageVersion("future")
[16:01:49.020]                         }
[16:01:49.020]                         else {
[16:01:49.020]                           version <- NULL
[16:01:49.020]                         }
[16:01:49.020]                         if (!has_future || version < "1.8.0") {
[16:01:49.020]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:49.020]                             "", base::R.version$version.string), 
[16:01:49.020]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:49.020]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:49.020]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:49.020]                               "release", "version")], collapse = " "), 
[16:01:49.020]                             hostname = base::Sys.info()[["nodename"]])
[16:01:49.020]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:49.020]                             info)
[16:01:49.020]                           info <- base::paste(info, collapse = "; ")
[16:01:49.020]                           if (!has_future) {
[16:01:49.020]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:49.020]                               info)
[16:01:49.020]                           }
[16:01:49.020]                           else {
[16:01:49.020]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:49.020]                               info, version)
[16:01:49.020]                           }
[16:01:49.020]                           base::stop(msg)
[16:01:49.020]                         }
[16:01:49.020]                       })
[16:01:49.020]                     }
[16:01:49.020]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:49.020]                     base::options(mc.cores = 1L)
[16:01:49.020]                   }
[16:01:49.020]                   options(future.plan = NULL)
[16:01:49.020]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.020]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:49.020]                 }
[16:01:49.020]                 ...future.workdir <- getwd()
[16:01:49.020]             }
[16:01:49.020]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:49.020]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:49.020]         }
[16:01:49.020]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:49.020]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:49.020]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:49.020]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:49.020]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:49.020]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:49.020]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:49.020]             base::names(...future.oldOptions))
[16:01:49.020]     }
[16:01:49.020]     if (FALSE) {
[16:01:49.020]     }
[16:01:49.020]     else {
[16:01:49.020]         if (TRUE) {
[16:01:49.020]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:49.020]                 open = "w")
[16:01:49.020]         }
[16:01:49.020]         else {
[16:01:49.020]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:49.020]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:49.020]         }
[16:01:49.020]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:49.020]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:49.020]             base::sink(type = "output", split = FALSE)
[16:01:49.020]             base::close(...future.stdout)
[16:01:49.020]         }, add = TRUE)
[16:01:49.020]     }
[16:01:49.020]     ...future.frame <- base::sys.nframe()
[16:01:49.020]     ...future.conditions <- base::list()
[16:01:49.020]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:49.020]     if (FALSE) {
[16:01:49.020]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:49.020]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:49.020]     }
[16:01:49.020]     ...future.result <- base::tryCatch({
[16:01:49.020]         base::withCallingHandlers({
[16:01:49.020]             ...future.value <- base::withVisible(base::local({
[16:01:49.020]                 withCallingHandlers({
[16:01:49.020]                   {
[16:01:49.020]                     do.call(function(...) {
[16:01:49.020]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.020]                       if (!identical(...future.globals.maxSize.org, 
[16:01:49.020]                         ...future.globals.maxSize)) {
[16:01:49.020]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.020]                         on.exit(options(oopts), add = TRUE)
[16:01:49.020]                       }
[16:01:49.020]                       {
[16:01:49.020]                         lapply(seq_along(...future.elements_ii), 
[16:01:49.020]                           FUN = function(jj) {
[16:01:49.020]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.020]                             ...future.FUN(...future.X_jj, ...)
[16:01:49.020]                           })
[16:01:49.020]                       }
[16:01:49.020]                     }, args = future.call.arguments)
[16:01:49.020]                   }
[16:01:49.020]                 }, immediateCondition = function(cond) {
[16:01:49.020]                   save_rds <- function (object, pathname, ...) 
[16:01:49.020]                   {
[16:01:49.020]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:49.020]                     if (file_test("-f", pathname_tmp)) {
[16:01:49.020]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.020]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:49.020]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.020]                         fi_tmp[["mtime"]])
[16:01:49.020]                     }
[16:01:49.020]                     tryCatch({
[16:01:49.020]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:49.020]                     }, error = function(ex) {
[16:01:49.020]                       msg <- conditionMessage(ex)
[16:01:49.020]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.020]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:49.020]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.020]                         fi_tmp[["mtime"]], msg)
[16:01:49.020]                       ex$message <- msg
[16:01:49.020]                       stop(ex)
[16:01:49.020]                     })
[16:01:49.020]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:49.020]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:49.020]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:49.020]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.020]                       fi <- file.info(pathname)
[16:01:49.020]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:49.020]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.020]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:49.020]                         fi[["size"]], fi[["mtime"]])
[16:01:49.020]                       stop(msg)
[16:01:49.020]                     }
[16:01:49.020]                     invisible(pathname)
[16:01:49.020]                   }
[16:01:49.020]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:49.020]                     rootPath = tempdir()) 
[16:01:49.020]                   {
[16:01:49.020]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:49.020]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:49.020]                       tmpdir = path, fileext = ".rds")
[16:01:49.020]                     save_rds(obj, file)
[16:01:49.020]                   }
[16:01:49.020]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4bFpDe/.future/immediateConditions")
[16:01:49.020]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.020]                   {
[16:01:49.020]                     inherits <- base::inherits
[16:01:49.020]                     invokeRestart <- base::invokeRestart
[16:01:49.020]                     is.null <- base::is.null
[16:01:49.020]                     muffled <- FALSE
[16:01:49.020]                     if (inherits(cond, "message")) {
[16:01:49.020]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:49.020]                       if (muffled) 
[16:01:49.020]                         invokeRestart("muffleMessage")
[16:01:49.020]                     }
[16:01:49.020]                     else if (inherits(cond, "warning")) {
[16:01:49.020]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:49.020]                       if (muffled) 
[16:01:49.020]                         invokeRestart("muffleWarning")
[16:01:49.020]                     }
[16:01:49.020]                     else if (inherits(cond, "condition")) {
[16:01:49.020]                       if (!is.null(pattern)) {
[16:01:49.020]                         computeRestarts <- base::computeRestarts
[16:01:49.020]                         grepl <- base::grepl
[16:01:49.020]                         restarts <- computeRestarts(cond)
[16:01:49.020]                         for (restart in restarts) {
[16:01:49.020]                           name <- restart$name
[16:01:49.020]                           if (is.null(name)) 
[16:01:49.020]                             next
[16:01:49.020]                           if (!grepl(pattern, name)) 
[16:01:49.020]                             next
[16:01:49.020]                           invokeRestart(restart)
[16:01:49.020]                           muffled <- TRUE
[16:01:49.020]                           break
[16:01:49.020]                         }
[16:01:49.020]                       }
[16:01:49.020]                     }
[16:01:49.020]                     invisible(muffled)
[16:01:49.020]                   }
[16:01:49.020]                   muffleCondition(cond)
[16:01:49.020]                 })
[16:01:49.020]             }))
[16:01:49.020]             future::FutureResult(value = ...future.value$value, 
[16:01:49.020]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.020]                   ...future.rng), globalenv = if (FALSE) 
[16:01:49.020]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:49.020]                     ...future.globalenv.names))
[16:01:49.020]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:49.020]         }, condition = base::local({
[16:01:49.020]             c <- base::c
[16:01:49.020]             inherits <- base::inherits
[16:01:49.020]             invokeRestart <- base::invokeRestart
[16:01:49.020]             length <- base::length
[16:01:49.020]             list <- base::list
[16:01:49.020]             seq.int <- base::seq.int
[16:01:49.020]             signalCondition <- base::signalCondition
[16:01:49.020]             sys.calls <- base::sys.calls
[16:01:49.020]             `[[` <- base::`[[`
[16:01:49.020]             `+` <- base::`+`
[16:01:49.020]             `<<-` <- base::`<<-`
[16:01:49.020]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:49.020]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:49.020]                   3L)]
[16:01:49.020]             }
[16:01:49.020]             function(cond) {
[16:01:49.020]                 is_error <- inherits(cond, "error")
[16:01:49.020]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:49.020]                   NULL)
[16:01:49.020]                 if (is_error) {
[16:01:49.020]                   sessionInformation <- function() {
[16:01:49.020]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:49.020]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:49.020]                       search = base::search(), system = base::Sys.info())
[16:01:49.020]                   }
[16:01:49.020]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.020]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:49.020]                     cond$call), session = sessionInformation(), 
[16:01:49.020]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:49.020]                   signalCondition(cond)
[16:01:49.020]                 }
[16:01:49.020]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:49.020]                 "immediateCondition"))) {
[16:01:49.020]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:49.020]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.020]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:49.020]                   if (TRUE && !signal) {
[16:01:49.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.020]                     {
[16:01:49.020]                       inherits <- base::inherits
[16:01:49.020]                       invokeRestart <- base::invokeRestart
[16:01:49.020]                       is.null <- base::is.null
[16:01:49.020]                       muffled <- FALSE
[16:01:49.020]                       if (inherits(cond, "message")) {
[16:01:49.020]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.020]                         if (muffled) 
[16:01:49.020]                           invokeRestart("muffleMessage")
[16:01:49.020]                       }
[16:01:49.020]                       else if (inherits(cond, "warning")) {
[16:01:49.020]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.020]                         if (muffled) 
[16:01:49.020]                           invokeRestart("muffleWarning")
[16:01:49.020]                       }
[16:01:49.020]                       else if (inherits(cond, "condition")) {
[16:01:49.020]                         if (!is.null(pattern)) {
[16:01:49.020]                           computeRestarts <- base::computeRestarts
[16:01:49.020]                           grepl <- base::grepl
[16:01:49.020]                           restarts <- computeRestarts(cond)
[16:01:49.020]                           for (restart in restarts) {
[16:01:49.020]                             name <- restart$name
[16:01:49.020]                             if (is.null(name)) 
[16:01:49.020]                               next
[16:01:49.020]                             if (!grepl(pattern, name)) 
[16:01:49.020]                               next
[16:01:49.020]                             invokeRestart(restart)
[16:01:49.020]                             muffled <- TRUE
[16:01:49.020]                             break
[16:01:49.020]                           }
[16:01:49.020]                         }
[16:01:49.020]                       }
[16:01:49.020]                       invisible(muffled)
[16:01:49.020]                     }
[16:01:49.020]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.020]                   }
[16:01:49.020]                 }
[16:01:49.020]                 else {
[16:01:49.020]                   if (TRUE) {
[16:01:49.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.020]                     {
[16:01:49.020]                       inherits <- base::inherits
[16:01:49.020]                       invokeRestart <- base::invokeRestart
[16:01:49.020]                       is.null <- base::is.null
[16:01:49.020]                       muffled <- FALSE
[16:01:49.020]                       if (inherits(cond, "message")) {
[16:01:49.020]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.020]                         if (muffled) 
[16:01:49.020]                           invokeRestart("muffleMessage")
[16:01:49.020]                       }
[16:01:49.020]                       else if (inherits(cond, "warning")) {
[16:01:49.020]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.020]                         if (muffled) 
[16:01:49.020]                           invokeRestart("muffleWarning")
[16:01:49.020]                       }
[16:01:49.020]                       else if (inherits(cond, "condition")) {
[16:01:49.020]                         if (!is.null(pattern)) {
[16:01:49.020]                           computeRestarts <- base::computeRestarts
[16:01:49.020]                           grepl <- base::grepl
[16:01:49.020]                           restarts <- computeRestarts(cond)
[16:01:49.020]                           for (restart in restarts) {
[16:01:49.020]                             name <- restart$name
[16:01:49.020]                             if (is.null(name)) 
[16:01:49.020]                               next
[16:01:49.020]                             if (!grepl(pattern, name)) 
[16:01:49.020]                               next
[16:01:49.020]                             invokeRestart(restart)
[16:01:49.020]                             muffled <- TRUE
[16:01:49.020]                             break
[16:01:49.020]                           }
[16:01:49.020]                         }
[16:01:49.020]                       }
[16:01:49.020]                       invisible(muffled)
[16:01:49.020]                     }
[16:01:49.020]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.020]                   }
[16:01:49.020]                 }
[16:01:49.020]             }
[16:01:49.020]         }))
[16:01:49.020]     }, error = function(ex) {
[16:01:49.020]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:49.020]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.020]                 ...future.rng), started = ...future.startTime, 
[16:01:49.020]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:49.020]             version = "1.8"), class = "FutureResult")
[16:01:49.020]     }, finally = {
[16:01:49.020]         if (!identical(...future.workdir, getwd())) 
[16:01:49.020]             setwd(...future.workdir)
[16:01:49.020]         {
[16:01:49.020]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:49.020]                 ...future.oldOptions$nwarnings <- NULL
[16:01:49.020]             }
[16:01:49.020]             base::options(...future.oldOptions)
[16:01:49.020]             if (.Platform$OS.type == "windows") {
[16:01:49.020]                 old_names <- names(...future.oldEnvVars)
[16:01:49.020]                 envs <- base::Sys.getenv()
[16:01:49.020]                 names <- names(envs)
[16:01:49.020]                 common <- intersect(names, old_names)
[16:01:49.020]                 added <- setdiff(names, old_names)
[16:01:49.020]                 removed <- setdiff(old_names, names)
[16:01:49.020]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:49.020]                   envs[common]]
[16:01:49.020]                 NAMES <- toupper(changed)
[16:01:49.020]                 args <- list()
[16:01:49.020]                 for (kk in seq_along(NAMES)) {
[16:01:49.020]                   name <- changed[[kk]]
[16:01:49.020]                   NAME <- NAMES[[kk]]
[16:01:49.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.020]                     next
[16:01:49.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.020]                 }
[16:01:49.020]                 NAMES <- toupper(added)
[16:01:49.020]                 for (kk in seq_along(NAMES)) {
[16:01:49.020]                   name <- added[[kk]]
[16:01:49.020]                   NAME <- NAMES[[kk]]
[16:01:49.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.020]                     next
[16:01:49.020]                   args[[name]] <- ""
[16:01:49.020]                 }
[16:01:49.020]                 NAMES <- toupper(removed)
[16:01:49.020]                 for (kk in seq_along(NAMES)) {
[16:01:49.020]                   name <- removed[[kk]]
[16:01:49.020]                   NAME <- NAMES[[kk]]
[16:01:49.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.020]                     next
[16:01:49.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.020]                 }
[16:01:49.020]                 if (length(args) > 0) 
[16:01:49.020]                   base::do.call(base::Sys.setenv, args = args)
[16:01:49.020]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:49.020]             }
[16:01:49.020]             else {
[16:01:49.020]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:49.020]             }
[16:01:49.020]             {
[16:01:49.020]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:49.020]                   0L) {
[16:01:49.020]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:49.020]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:49.020]                   base::options(opts)
[16:01:49.020]                 }
[16:01:49.020]                 {
[16:01:49.020]                   {
[16:01:49.020]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:49.020]                     NULL
[16:01:49.020]                   }
[16:01:49.020]                   options(future.plan = NULL)
[16:01:49.020]                   if (is.na(NA_character_)) 
[16:01:49.020]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.020]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:49.020]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:49.020]                     envir = parent.frame()) 
[16:01:49.020]                   {
[16:01:49.020]                     default_workers <- missing(workers)
[16:01:49.020]                     if (is.function(workers)) 
[16:01:49.020]                       workers <- workers()
[16:01:49.020]                     workers <- structure(as.integer(workers), 
[16:01:49.020]                       class = class(workers))
[16:01:49.020]                     stop_if_not(is.finite(workers), workers >= 
[16:01:49.020]                       1L)
[16:01:49.020]                     if ((workers == 1L && !inherits(workers, 
[16:01:49.020]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:49.020]                       if (default_workers) 
[16:01:49.020]                         supportsMulticore(warn = TRUE)
[16:01:49.020]                       return(sequential(..., envir = envir))
[16:01:49.020]                     }
[16:01:49.020]                     oopts <- options(mc.cores = workers)
[16:01:49.020]                     on.exit(options(oopts))
[16:01:49.020]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:49.020]                       envir = envir)
[16:01:49.020]                     if (!future$lazy) 
[16:01:49.020]                       future <- run(future)
[16:01:49.020]                     invisible(future)
[16:01:49.020]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:49.020]                 }
[16:01:49.020]             }
[16:01:49.020]         }
[16:01:49.020]     })
[16:01:49.020]     if (TRUE) {
[16:01:49.020]         base::sink(type = "output", split = FALSE)
[16:01:49.020]         if (TRUE) {
[16:01:49.020]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:49.020]         }
[16:01:49.020]         else {
[16:01:49.020]             ...future.result["stdout"] <- base::list(NULL)
[16:01:49.020]         }
[16:01:49.020]         base::close(...future.stdout)
[16:01:49.020]         ...future.stdout <- NULL
[16:01:49.020]     }
[16:01:49.020]     ...future.result$conditions <- ...future.conditions
[16:01:49.020]     ...future.result$finished <- base::Sys.time()
[16:01:49.020]     ...future.result
[16:01:49.020] }
[16:01:49.023] assign_globals() ...
[16:01:49.023] List of 5
[16:01:49.023]  $ ...future.FUN            :function (x, ...)  
[16:01:49.023]  $ future.call.arguments    : list()
[16:01:49.023]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.023]  $ ...future.elements_ii    :List of 1
[16:01:49.023]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[16:01:49.023]  $ ...future.seeds_ii       : NULL
[16:01:49.023]  $ ...future.globals.maxSize: NULL
[16:01:49.023]  - attr(*, "where")=List of 5
[16:01:49.023]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:49.023]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:49.023]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:49.023]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:49.023]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:49.023]  - attr(*, "resolved")= logi FALSE
[16:01:49.023]  - attr(*, "total_size")= num 1240
[16:01:49.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.023]  - attr(*, "already-done")= logi TRUE
[16:01:49.027] - copied ‘...future.FUN’ to environment
[16:01:49.028] - copied ‘future.call.arguments’ to environment
[16:01:49.028] - copied ‘...future.elements_ii’ to environment
[16:01:49.028] - copied ‘...future.seeds_ii’ to environment
[16:01:49.028] - copied ‘...future.globals.maxSize’ to environment
[16:01:49.028] assign_globals() ... done
[16:01:49.028] requestCore(): workers = 2
[16:01:49.031] MulticoreFuture started
[16:01:49.032] - Launch lazy future ... done
[16:01:49.032] run() for ‘MulticoreFuture’ ... done
[16:01:49.032] plan(): Setting new future strategy stack:
[16:01:49.032] Created future:
[16:01:49.032] List of future strategies:
[16:01:49.032] 1. sequential:
[16:01:49.032]    - args: function (..., envir = parent.frame())
[16:01:49.032]    - tweaked: FALSE
[16:01:49.032]    - call: NULL
[16:01:49.033] plan(): nbrOfWorkers() = 1
[16:01:49.035] plan(): Setting new future strategy stack:
[16:01:49.035] List of future strategies:
[16:01:49.035] 1. multicore:
[16:01:49.035]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:49.035]    - tweaked: FALSE
[16:01:49.035]    - call: plan(strategy)
[16:01:49.040] plan(): nbrOfWorkers() = 2
[16:01:49.032] MulticoreFuture:
[16:01:49.032] Label: ‘future_eapply-1’
[16:01:49.032] Expression:
[16:01:49.032] {
[16:01:49.032]     do.call(function(...) {
[16:01:49.032]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.032]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.032]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.032]             on.exit(options(oopts), add = TRUE)
[16:01:49.032]         }
[16:01:49.032]         {
[16:01:49.032]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.032]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.032]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.032]             })
[16:01:49.032]         }
[16:01:49.032]     }, args = future.call.arguments)
[16:01:49.032] }
[16:01:49.032] Lazy evaluation: FALSE
[16:01:49.032] Asynchronous evaluation: TRUE
[16:01:49.032] Local evaluation: TRUE
[16:01:49.032] Environment: R_GlobalEnv
[16:01:49.032] Capture standard output: TRUE
[16:01:49.032] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:49.032] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:49.032] Packages: <none>
[16:01:49.032] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:49.032] Resolved: TRUE
[16:01:49.032] Value: <not collected>
[16:01:49.032] Conditions captured: <none>
[16:01:49.032] Early signaling: FALSE
[16:01:49.032] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:49.032] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.041] Chunk #1 of 2 ... DONE
[16:01:49.042] Chunk #2 of 2 ...
[16:01:49.042]  - Finding globals in 'X' for chunk #2 ...
[16:01:49.042] getGlobalsAndPackages() ...
[16:01:49.042] Searching for globals...
[16:01:49.042] 
[16:01:49.043] Searching for globals ... DONE
[16:01:49.043] - globals: [0] <none>
[16:01:49.043] getGlobalsAndPackages() ... DONE
[16:01:49.043]    + additional globals found: [n=0] 
[16:01:49.043]    + additional namespaces needed: [n=0] 
[16:01:49.043]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:49.043]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:49.044]  - seeds: <none>
[16:01:49.044]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.044] getGlobalsAndPackages() ...
[16:01:49.044] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.044] Resolving globals: FALSE
[16:01:49.044] Tweak future expression to call with '...' arguments ...
[16:01:49.045] {
[16:01:49.045]     do.call(function(...) {
[16:01:49.045]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.045]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.045]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.045]             on.exit(options(oopts), add = TRUE)
[16:01:49.045]         }
[16:01:49.045]         {
[16:01:49.045]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.045]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.045]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.045]             })
[16:01:49.045]         }
[16:01:49.045]     }, args = future.call.arguments)
[16:01:49.045] }
[16:01:49.045] Tweak future expression to call with '...' arguments ... DONE
[16:01:49.046] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.046] 
[16:01:49.046] getGlobalsAndPackages() ... DONE
[16:01:49.046] run() for ‘Future’ ...
[16:01:49.047] - state: ‘created’
[16:01:49.047] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:49.051] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.051] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:49.052]   - Field: ‘label’
[16:01:49.052]   - Field: ‘local’
[16:01:49.052]   - Field: ‘owner’
[16:01:49.052]   - Field: ‘envir’
[16:01:49.052]   - Field: ‘workers’
[16:01:49.052]   - Field: ‘packages’
[16:01:49.052]   - Field: ‘gc’
[16:01:49.053]   - Field: ‘job’
[16:01:49.053]   - Field: ‘conditions’
[16:01:49.053]   - Field: ‘expr’
[16:01:49.053]   - Field: ‘uuid’
[16:01:49.053]   - Field: ‘seed’
[16:01:49.053]   - Field: ‘version’
[16:01:49.053]   - Field: ‘result’
[16:01:49.053]   - Field: ‘asynchronous’
[16:01:49.054]   - Field: ‘calls’
[16:01:49.054]   - Field: ‘globals’
[16:01:49.054]   - Field: ‘stdout’
[16:01:49.054]   - Field: ‘earlySignal’
[16:01:49.054]   - Field: ‘lazy’
[16:01:49.054]   - Field: ‘state’
[16:01:49.054] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:49.054] - Launch lazy future ...
[16:01:49.055] Packages needed by the future expression (n = 0): <none>
[16:01:49.055] Packages needed by future strategies (n = 0): <none>
[16:01:49.056] {
[16:01:49.056]     {
[16:01:49.056]         {
[16:01:49.056]             ...future.startTime <- base::Sys.time()
[16:01:49.056]             {
[16:01:49.056]                 {
[16:01:49.056]                   {
[16:01:49.056]                     {
[16:01:49.056]                       base::local({
[16:01:49.056]                         has_future <- base::requireNamespace("future", 
[16:01:49.056]                           quietly = TRUE)
[16:01:49.056]                         if (has_future) {
[16:01:49.056]                           ns <- base::getNamespace("future")
[16:01:49.056]                           version <- ns[[".package"]][["version"]]
[16:01:49.056]                           if (is.null(version)) 
[16:01:49.056]                             version <- utils::packageVersion("future")
[16:01:49.056]                         }
[16:01:49.056]                         else {
[16:01:49.056]                           version <- NULL
[16:01:49.056]                         }
[16:01:49.056]                         if (!has_future || version < "1.8.0") {
[16:01:49.056]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:49.056]                             "", base::R.version$version.string), 
[16:01:49.056]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:49.056]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:49.056]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:49.056]                               "release", "version")], collapse = " "), 
[16:01:49.056]                             hostname = base::Sys.info()[["nodename"]])
[16:01:49.056]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:49.056]                             info)
[16:01:49.056]                           info <- base::paste(info, collapse = "; ")
[16:01:49.056]                           if (!has_future) {
[16:01:49.056]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:49.056]                               info)
[16:01:49.056]                           }
[16:01:49.056]                           else {
[16:01:49.056]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:49.056]                               info, version)
[16:01:49.056]                           }
[16:01:49.056]                           base::stop(msg)
[16:01:49.056]                         }
[16:01:49.056]                       })
[16:01:49.056]                     }
[16:01:49.056]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:49.056]                     base::options(mc.cores = 1L)
[16:01:49.056]                   }
[16:01:49.056]                   options(future.plan = NULL)
[16:01:49.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:49.056]                 }
[16:01:49.056]                 ...future.workdir <- getwd()
[16:01:49.056]             }
[16:01:49.056]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:49.056]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:49.056]         }
[16:01:49.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:49.056]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:49.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:49.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:49.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:49.056]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:49.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:49.056]             base::names(...future.oldOptions))
[16:01:49.056]     }
[16:01:49.056]     if (FALSE) {
[16:01:49.056]     }
[16:01:49.056]     else {
[16:01:49.056]         if (TRUE) {
[16:01:49.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:49.056]                 open = "w")
[16:01:49.056]         }
[16:01:49.056]         else {
[16:01:49.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:49.056]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:49.056]         }
[16:01:49.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:49.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:49.056]             base::sink(type = "output", split = FALSE)
[16:01:49.056]             base::close(...future.stdout)
[16:01:49.056]         }, add = TRUE)
[16:01:49.056]     }
[16:01:49.056]     ...future.frame <- base::sys.nframe()
[16:01:49.056]     ...future.conditions <- base::list()
[16:01:49.056]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:49.056]     if (FALSE) {
[16:01:49.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:49.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:49.056]     }
[16:01:49.056]     ...future.result <- base::tryCatch({
[16:01:49.056]         base::withCallingHandlers({
[16:01:49.056]             ...future.value <- base::withVisible(base::local({
[16:01:49.056]                 withCallingHandlers({
[16:01:49.056]                   {
[16:01:49.056]                     do.call(function(...) {
[16:01:49.056]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.056]                       if (!identical(...future.globals.maxSize.org, 
[16:01:49.056]                         ...future.globals.maxSize)) {
[16:01:49.056]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.056]                         on.exit(options(oopts), add = TRUE)
[16:01:49.056]                       }
[16:01:49.056]                       {
[16:01:49.056]                         lapply(seq_along(...future.elements_ii), 
[16:01:49.056]                           FUN = function(jj) {
[16:01:49.056]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.056]                             ...future.FUN(...future.X_jj, ...)
[16:01:49.056]                           })
[16:01:49.056]                       }
[16:01:49.056]                     }, args = future.call.arguments)
[16:01:49.056]                   }
[16:01:49.056]                 }, immediateCondition = function(cond) {
[16:01:49.056]                   save_rds <- function (object, pathname, ...) 
[16:01:49.056]                   {
[16:01:49.056]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:49.056]                     if (file_test("-f", pathname_tmp)) {
[16:01:49.056]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.056]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:49.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.056]                         fi_tmp[["mtime"]])
[16:01:49.056]                     }
[16:01:49.056]                     tryCatch({
[16:01:49.056]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:49.056]                     }, error = function(ex) {
[16:01:49.056]                       msg <- conditionMessage(ex)
[16:01:49.056]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.056]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:49.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.056]                         fi_tmp[["mtime"]], msg)
[16:01:49.056]                       ex$message <- msg
[16:01:49.056]                       stop(ex)
[16:01:49.056]                     })
[16:01:49.056]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:49.056]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:49.056]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:49.056]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.056]                       fi <- file.info(pathname)
[16:01:49.056]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:49.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.056]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:49.056]                         fi[["size"]], fi[["mtime"]])
[16:01:49.056]                       stop(msg)
[16:01:49.056]                     }
[16:01:49.056]                     invisible(pathname)
[16:01:49.056]                   }
[16:01:49.056]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:49.056]                     rootPath = tempdir()) 
[16:01:49.056]                   {
[16:01:49.056]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:49.056]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:49.056]                       tmpdir = path, fileext = ".rds")
[16:01:49.056]                     save_rds(obj, file)
[16:01:49.056]                   }
[16:01:49.056]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4bFpDe/.future/immediateConditions")
[16:01:49.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.056]                   {
[16:01:49.056]                     inherits <- base::inherits
[16:01:49.056]                     invokeRestart <- base::invokeRestart
[16:01:49.056]                     is.null <- base::is.null
[16:01:49.056]                     muffled <- FALSE
[16:01:49.056]                     if (inherits(cond, "message")) {
[16:01:49.056]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:49.056]                       if (muffled) 
[16:01:49.056]                         invokeRestart("muffleMessage")
[16:01:49.056]                     }
[16:01:49.056]                     else if (inherits(cond, "warning")) {
[16:01:49.056]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:49.056]                       if (muffled) 
[16:01:49.056]                         invokeRestart("muffleWarning")
[16:01:49.056]                     }
[16:01:49.056]                     else if (inherits(cond, "condition")) {
[16:01:49.056]                       if (!is.null(pattern)) {
[16:01:49.056]                         computeRestarts <- base::computeRestarts
[16:01:49.056]                         grepl <- base::grepl
[16:01:49.056]                         restarts <- computeRestarts(cond)
[16:01:49.056]                         for (restart in restarts) {
[16:01:49.056]                           name <- restart$name
[16:01:49.056]                           if (is.null(name)) 
[16:01:49.056]                             next
[16:01:49.056]                           if (!grepl(pattern, name)) 
[16:01:49.056]                             next
[16:01:49.056]                           invokeRestart(restart)
[16:01:49.056]                           muffled <- TRUE
[16:01:49.056]                           break
[16:01:49.056]                         }
[16:01:49.056]                       }
[16:01:49.056]                     }
[16:01:49.056]                     invisible(muffled)
[16:01:49.056]                   }
[16:01:49.056]                   muffleCondition(cond)
[16:01:49.056]                 })
[16:01:49.056]             }))
[16:01:49.056]             future::FutureResult(value = ...future.value$value, 
[16:01:49.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.056]                   ...future.rng), globalenv = if (FALSE) 
[16:01:49.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:49.056]                     ...future.globalenv.names))
[16:01:49.056]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:49.056]         }, condition = base::local({
[16:01:49.056]             c <- base::c
[16:01:49.056]             inherits <- base::inherits
[16:01:49.056]             invokeRestart <- base::invokeRestart
[16:01:49.056]             length <- base::length
[16:01:49.056]             list <- base::list
[16:01:49.056]             seq.int <- base::seq.int
[16:01:49.056]             signalCondition <- base::signalCondition
[16:01:49.056]             sys.calls <- base::sys.calls
[16:01:49.056]             `[[` <- base::`[[`
[16:01:49.056]             `+` <- base::`+`
[16:01:49.056]             `<<-` <- base::`<<-`
[16:01:49.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:49.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:49.056]                   3L)]
[16:01:49.056]             }
[16:01:49.056]             function(cond) {
[16:01:49.056]                 is_error <- inherits(cond, "error")
[16:01:49.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:49.056]                   NULL)
[16:01:49.056]                 if (is_error) {
[16:01:49.056]                   sessionInformation <- function() {
[16:01:49.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:49.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:49.056]                       search = base::search(), system = base::Sys.info())
[16:01:49.056]                   }
[16:01:49.056]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:49.056]                     cond$call), session = sessionInformation(), 
[16:01:49.056]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:49.056]                   signalCondition(cond)
[16:01:49.056]                 }
[16:01:49.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:49.056]                 "immediateCondition"))) {
[16:01:49.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:49.056]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:49.056]                   if (TRUE && !signal) {
[16:01:49.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.056]                     {
[16:01:49.056]                       inherits <- base::inherits
[16:01:49.056]                       invokeRestart <- base::invokeRestart
[16:01:49.056]                       is.null <- base::is.null
[16:01:49.056]                       muffled <- FALSE
[16:01:49.056]                       if (inherits(cond, "message")) {
[16:01:49.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.056]                         if (muffled) 
[16:01:49.056]                           invokeRestart("muffleMessage")
[16:01:49.056]                       }
[16:01:49.056]                       else if (inherits(cond, "warning")) {
[16:01:49.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.056]                         if (muffled) 
[16:01:49.056]                           invokeRestart("muffleWarning")
[16:01:49.056]                       }
[16:01:49.056]                       else if (inherits(cond, "condition")) {
[16:01:49.056]                         if (!is.null(pattern)) {
[16:01:49.056]                           computeRestarts <- base::computeRestarts
[16:01:49.056]                           grepl <- base::grepl
[16:01:49.056]                           restarts <- computeRestarts(cond)
[16:01:49.056]                           for (restart in restarts) {
[16:01:49.056]                             name <- restart$name
[16:01:49.056]                             if (is.null(name)) 
[16:01:49.056]                               next
[16:01:49.056]                             if (!grepl(pattern, name)) 
[16:01:49.056]                               next
[16:01:49.056]                             invokeRestart(restart)
[16:01:49.056]                             muffled <- TRUE
[16:01:49.056]                             break
[16:01:49.056]                           }
[16:01:49.056]                         }
[16:01:49.056]                       }
[16:01:49.056]                       invisible(muffled)
[16:01:49.056]                     }
[16:01:49.056]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.056]                   }
[16:01:49.056]                 }
[16:01:49.056]                 else {
[16:01:49.056]                   if (TRUE) {
[16:01:49.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.056]                     {
[16:01:49.056]                       inherits <- base::inherits
[16:01:49.056]                       invokeRestart <- base::invokeRestart
[16:01:49.056]                       is.null <- base::is.null
[16:01:49.056]                       muffled <- FALSE
[16:01:49.056]                       if (inherits(cond, "message")) {
[16:01:49.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.056]                         if (muffled) 
[16:01:49.056]                           invokeRestart("muffleMessage")
[16:01:49.056]                       }
[16:01:49.056]                       else if (inherits(cond, "warning")) {
[16:01:49.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.056]                         if (muffled) 
[16:01:49.056]                           invokeRestart("muffleWarning")
[16:01:49.056]                       }
[16:01:49.056]                       else if (inherits(cond, "condition")) {
[16:01:49.056]                         if (!is.null(pattern)) {
[16:01:49.056]                           computeRestarts <- base::computeRestarts
[16:01:49.056]                           grepl <- base::grepl
[16:01:49.056]                           restarts <- computeRestarts(cond)
[16:01:49.056]                           for (restart in restarts) {
[16:01:49.056]                             name <- restart$name
[16:01:49.056]                             if (is.null(name)) 
[16:01:49.056]                               next
[16:01:49.056]                             if (!grepl(pattern, name)) 
[16:01:49.056]                               next
[16:01:49.056]                             invokeRestart(restart)
[16:01:49.056]                             muffled <- TRUE
[16:01:49.056]                             break
[16:01:49.056]                           }
[16:01:49.056]                         }
[16:01:49.056]                       }
[16:01:49.056]                       invisible(muffled)
[16:01:49.056]                     }
[16:01:49.056]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.056]                   }
[16:01:49.056]                 }
[16:01:49.056]             }
[16:01:49.056]         }))
[16:01:49.056]     }, error = function(ex) {
[16:01:49.056]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:49.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.056]                 ...future.rng), started = ...future.startTime, 
[16:01:49.056]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:49.056]             version = "1.8"), class = "FutureResult")
[16:01:49.056]     }, finally = {
[16:01:49.056]         if (!identical(...future.workdir, getwd())) 
[16:01:49.056]             setwd(...future.workdir)
[16:01:49.056]         {
[16:01:49.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:49.056]                 ...future.oldOptions$nwarnings <- NULL
[16:01:49.056]             }
[16:01:49.056]             base::options(...future.oldOptions)
[16:01:49.056]             if (.Platform$OS.type == "windows") {
[16:01:49.056]                 old_names <- names(...future.oldEnvVars)
[16:01:49.056]                 envs <- base::Sys.getenv()
[16:01:49.056]                 names <- names(envs)
[16:01:49.056]                 common <- intersect(names, old_names)
[16:01:49.056]                 added <- setdiff(names, old_names)
[16:01:49.056]                 removed <- setdiff(old_names, names)
[16:01:49.056]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:49.056]                   envs[common]]
[16:01:49.056]                 NAMES <- toupper(changed)
[16:01:49.056]                 args <- list()
[16:01:49.056]                 for (kk in seq_along(NAMES)) {
[16:01:49.056]                   name <- changed[[kk]]
[16:01:49.056]                   NAME <- NAMES[[kk]]
[16:01:49.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.056]                     next
[16:01:49.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.056]                 }
[16:01:49.056]                 NAMES <- toupper(added)
[16:01:49.056]                 for (kk in seq_along(NAMES)) {
[16:01:49.056]                   name <- added[[kk]]
[16:01:49.056]                   NAME <- NAMES[[kk]]
[16:01:49.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.056]                     next
[16:01:49.056]                   args[[name]] <- ""
[16:01:49.056]                 }
[16:01:49.056]                 NAMES <- toupper(removed)
[16:01:49.056]                 for (kk in seq_along(NAMES)) {
[16:01:49.056]                   name <- removed[[kk]]
[16:01:49.056]                   NAME <- NAMES[[kk]]
[16:01:49.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.056]                     next
[16:01:49.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.056]                 }
[16:01:49.056]                 if (length(args) > 0) 
[16:01:49.056]                   base::do.call(base::Sys.setenv, args = args)
[16:01:49.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:49.056]             }
[16:01:49.056]             else {
[16:01:49.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:49.056]             }
[16:01:49.056]             {
[16:01:49.056]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:49.056]                   0L) {
[16:01:49.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:49.056]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:49.056]                   base::options(opts)
[16:01:49.056]                 }
[16:01:49.056]                 {
[16:01:49.056]                   {
[16:01:49.056]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:49.056]                     NULL
[16:01:49.056]                   }
[16:01:49.056]                   options(future.plan = NULL)
[16:01:49.056]                   if (is.na(NA_character_)) 
[16:01:49.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:49.056]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:49.056]                     envir = parent.frame()) 
[16:01:49.056]                   {
[16:01:49.056]                     default_workers <- missing(workers)
[16:01:49.056]                     if (is.function(workers)) 
[16:01:49.056]                       workers <- workers()
[16:01:49.056]                     workers <- structure(as.integer(workers), 
[16:01:49.056]                       class = class(workers))
[16:01:49.056]                     stop_if_not(is.finite(workers), workers >= 
[16:01:49.056]                       1L)
[16:01:49.056]                     if ((workers == 1L && !inherits(workers, 
[16:01:49.056]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:49.056]                       if (default_workers) 
[16:01:49.056]                         supportsMulticore(warn = TRUE)
[16:01:49.056]                       return(sequential(..., envir = envir))
[16:01:49.056]                     }
[16:01:49.056]                     oopts <- options(mc.cores = workers)
[16:01:49.056]                     on.exit(options(oopts))
[16:01:49.056]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:49.056]                       envir = envir)
[16:01:49.056]                     if (!future$lazy) 
[16:01:49.056]                       future <- run(future)
[16:01:49.056]                     invisible(future)
[16:01:49.056]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:49.056]                 }
[16:01:49.056]             }
[16:01:49.056]         }
[16:01:49.056]     })
[16:01:49.056]     if (TRUE) {
[16:01:49.056]         base::sink(type = "output", split = FALSE)
[16:01:49.056]         if (TRUE) {
[16:01:49.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:49.056]         }
[16:01:49.056]         else {
[16:01:49.056]             ...future.result["stdout"] <- base::list(NULL)
[16:01:49.056]         }
[16:01:49.056]         base::close(...future.stdout)
[16:01:49.056]         ...future.stdout <- NULL
[16:01:49.056]     }
[16:01:49.056]     ...future.result$conditions <- ...future.conditions
[16:01:49.056]     ...future.result$finished <- base::Sys.time()
[16:01:49.056]     ...future.result
[16:01:49.056] }
[16:01:49.059] assign_globals() ...
[16:01:49.059] List of 5
[16:01:49.059]  $ ...future.FUN            :function (x, ...)  
[16:01:49.059]  $ future.call.arguments    : list()
[16:01:49.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.059]  $ ...future.elements_ii    :List of 2
[16:01:49.059]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:01:49.059]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:01:49.059]  $ ...future.seeds_ii       : NULL
[16:01:49.059]  $ ...future.globals.maxSize: NULL
[16:01:49.059]  - attr(*, "where")=List of 5
[16:01:49.059]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:49.059]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:49.059]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:49.059]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:49.059]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:49.059]  - attr(*, "resolved")= logi FALSE
[16:01:49.059]  - attr(*, "total_size")= num 1240
[16:01:49.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.059]  - attr(*, "already-done")= logi TRUE
[16:01:49.072] - copied ‘...future.FUN’ to environment
[16:01:49.072] - copied ‘future.call.arguments’ to environment
[16:01:49.073] - copied ‘...future.elements_ii’ to environment
[16:01:49.073] - copied ‘...future.seeds_ii’ to environment
[16:01:49.073] - copied ‘...future.globals.maxSize’ to environment
[16:01:49.073] assign_globals() ... done
[16:01:49.073] requestCore(): workers = 2
[16:01:49.079] MulticoreFuture started
[16:01:49.080] - Launch lazy future ... done
[16:01:49.080] run() for ‘MulticoreFuture’ ... done
[16:01:49.080] Created future:
[16:01:49.081] plan(): Setting new future strategy stack:
[16:01:49.081] List of future strategies:
[16:01:49.081] 1. sequential:
[16:01:49.081]    - args: function (..., envir = parent.frame())
[16:01:49.081]    - tweaked: FALSE
[16:01:49.081]    - call: NULL
[16:01:49.082] plan(): nbrOfWorkers() = 1
[16:01:49.084] plan(): Setting new future strategy stack:
[16:01:49.084] List of future strategies:
[16:01:49.084] 1. multicore:
[16:01:49.084]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:49.084]    - tweaked: FALSE
[16:01:49.084]    - call: plan(strategy)
[16:01:49.089] plan(): nbrOfWorkers() = 2
[16:01:49.080] MulticoreFuture:
[16:01:49.080] Label: ‘future_eapply-2’
[16:01:49.080] Expression:
[16:01:49.080] {
[16:01:49.080]     do.call(function(...) {
[16:01:49.080]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.080]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.080]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.080]             on.exit(options(oopts), add = TRUE)
[16:01:49.080]         }
[16:01:49.080]         {
[16:01:49.080]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.080]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.080]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.080]             })
[16:01:49.080]         }
[16:01:49.080]     }, args = future.call.arguments)
[16:01:49.080] }
[16:01:49.080] Lazy evaluation: FALSE
[16:01:49.080] Asynchronous evaluation: TRUE
[16:01:49.080] Local evaluation: TRUE
[16:01:49.080] Environment: R_GlobalEnv
[16:01:49.080] Capture standard output: TRUE
[16:01:49.080] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:49.080] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:49.080] Packages: <none>
[16:01:49.080] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:49.080] Resolved: TRUE
[16:01:49.080] Value: <not collected>
[16:01:49.080] Conditions captured: <none>
[16:01:49.080] Early signaling: FALSE
[16:01:49.080] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:49.080] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.090] Chunk #2 of 2 ... DONE
[16:01:49.091] Launching 2 futures (chunks) ... DONE
[16:01:49.091] Resolving 2 futures (chunks) ...
[16:01:49.091] resolve() on list ...
[16:01:49.091]  recursive: 0
[16:01:49.091]  length: 2
[16:01:49.091] 
[16:01:49.092] Future #1
[16:01:49.092] result() for MulticoreFuture ...
[16:01:49.094] result() for MulticoreFuture ...
[16:01:49.094] result() for MulticoreFuture ... done
[16:01:49.095] result() for MulticoreFuture ... done
[16:01:49.095] result() for MulticoreFuture ...
[16:01:49.095] result() for MulticoreFuture ... done
[16:01:49.095] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:49.095] - nx: 2
[16:01:49.095] - relay: TRUE
[16:01:49.095] - stdout: TRUE
[16:01:49.096] - signal: TRUE
[16:01:49.096] - resignal: FALSE
[16:01:49.096] - force: TRUE
[16:01:49.096] - relayed: [n=2] FALSE, FALSE
[16:01:49.096] - queued futures: [n=2] FALSE, FALSE
[16:01:49.096]  - until=1
[16:01:49.096]  - relaying element #1
[16:01:49.097] result() for MulticoreFuture ...
[16:01:49.097] result() for MulticoreFuture ... done
[16:01:49.097] result() for MulticoreFuture ...
[16:01:49.097] result() for MulticoreFuture ... done
[16:01:49.097] result() for MulticoreFuture ...
[16:01:49.097] result() for MulticoreFuture ... done
[16:01:49.098] result() for MulticoreFuture ...
[16:01:49.098] result() for MulticoreFuture ... done
[16:01:49.098] - relayed: [n=2] TRUE, FALSE
[16:01:49.098] - queued futures: [n=2] TRUE, FALSE
[16:01:49.098] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:49.098]  length: 1 (resolved future 1)
[16:01:49.099] Future #2
[16:01:49.099] result() for MulticoreFuture ...
[16:01:49.099] result() for MulticoreFuture ...
[16:01:49.100] result() for MulticoreFuture ... done
[16:01:49.100] result() for MulticoreFuture ... done
[16:01:49.100] result() for MulticoreFuture ...
[16:01:49.100] result() for MulticoreFuture ... done
[16:01:49.100] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:49.101] - nx: 2
[16:01:49.101] - relay: TRUE
[16:01:49.101] - stdout: TRUE
[16:01:49.101] - signal: TRUE
[16:01:49.101] - resignal: FALSE
[16:01:49.101] - force: TRUE
[16:01:49.101] - relayed: [n=2] TRUE, FALSE
[16:01:49.102] - queued futures: [n=2] TRUE, FALSE
[16:01:49.102]  - until=2
[16:01:49.102]  - relaying element #2
[16:01:49.102] result() for MulticoreFuture ...
[16:01:49.102] result() for MulticoreFuture ... done
[16:01:49.102] result() for MulticoreFuture ...
[16:01:49.102] result() for MulticoreFuture ... done
[16:01:49.103] result() for MulticoreFuture ...
[16:01:49.103] result() for MulticoreFuture ... done
[16:01:49.103] result() for MulticoreFuture ...
[16:01:49.103] result() for MulticoreFuture ... done
[16:01:49.103] - relayed: [n=2] TRUE, TRUE
[16:01:49.103] - queued futures: [n=2] TRUE, TRUE
[16:01:49.103] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:49.104]  length: 0 (resolved future 2)
[16:01:49.104] Relaying remaining futures
[16:01:49.104] signalConditionsASAP(NULL, pos=0) ...
[16:01:49.104] - nx: 2
[16:01:49.104] - relay: TRUE
[16:01:49.104] - stdout: TRUE
[16:01:49.104] - signal: TRUE
[16:01:49.104] - resignal: FALSE
[16:01:49.104] - force: TRUE
[16:01:49.104] - relayed: [n=2] TRUE, TRUE
[16:01:49.104] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:49.105] - relayed: [n=2] TRUE, TRUE
[16:01:49.105] - queued futures: [n=2] TRUE, TRUE
[16:01:49.105] signalConditionsASAP(NULL, pos=0) ... done
[16:01:49.105] resolve() on list ... DONE
[16:01:49.105] result() for MulticoreFuture ...
[16:01:49.105] result() for MulticoreFuture ... done
[16:01:49.105] result() for MulticoreFuture ...
[16:01:49.105] result() for MulticoreFuture ... done
[16:01:49.106] result() for MulticoreFuture ...
[16:01:49.106] result() for MulticoreFuture ... done
[16:01:49.106] result() for MulticoreFuture ...
[16:01:49.106] result() for MulticoreFuture ... done
[16:01:49.106]  - Number of value chunks collected: 2
[16:01:49.106] Resolving 2 futures (chunks) ... DONE
[16:01:49.106] Reducing values from 2 chunks ...
[16:01:49.106]  - Number of values collected after concatenation: 3
[16:01:49.106]  - Number of values expected: 3
[16:01:49.107] Reducing values from 2 chunks ... DONE
[16:01:49.107] future_lapply() ... DONE
[16:01:49.108] future_lapply() ...
[16:01:49.113] Number of chunks: 2
[16:01:49.113] getGlobalsAndPackagesXApply() ...
[16:01:49.113]  - future.globals: TRUE
[16:01:49.113] getGlobalsAndPackages() ...
[16:01:49.113] Searching for globals...
[16:01:49.117] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:49.117] Searching for globals ... DONE
[16:01:49.117] Resolving globals: FALSE
[16:01:49.118] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:49.118] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:49.119] - globals: [1] ‘FUN’
[16:01:49.119] - packages: [1] ‘stats’
[16:01:49.119] getGlobalsAndPackages() ... DONE
[16:01:49.119]  - globals found/used: [n=1] ‘FUN’
[16:01:49.119]  - needed namespaces: [n=1] ‘stats’
[16:01:49.119] Finding globals ... DONE
[16:01:49.120]  - use_args: TRUE
[16:01:49.120]  - Getting '...' globals ...
[16:01:49.120] resolve() on list ...
[16:01:49.120]  recursive: 0
[16:01:49.120]  length: 1
[16:01:49.120]  elements: ‘...’
[16:01:49.121]  length: 0 (resolved future 1)
[16:01:49.121] resolve() on list ... DONE
[16:01:49.121]    - '...' content: [n=1] ‘probs’
[16:01:49.121] List of 1
[16:01:49.121]  $ ...:List of 1
[16:01:49.121]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:01:49.121]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.121]  - attr(*, "where")=List of 1
[16:01:49.121]   ..$ ...:<environment: 0x5620a1d013a8> 
[16:01:49.121]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.121]  - attr(*, "resolved")= logi TRUE
[16:01:49.121]  - attr(*, "total_size")= num NA
[16:01:49.125]  - Getting '...' globals ... DONE
[16:01:49.125] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:49.125] List of 2
[16:01:49.125]  $ ...future.FUN:function (x, ...)  
[16:01:49.125]  $ ...          :List of 1
[16:01:49.125]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:01:49.125]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.125]  - attr(*, "where")=List of 2
[16:01:49.125]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:49.125]   ..$ ...          :<environment: 0x5620a1d013a8> 
[16:01:49.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.125]  - attr(*, "resolved")= logi FALSE
[16:01:49.125]  - attr(*, "total_size")= num 1328
[16:01:49.129] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:49.129] getGlobalsAndPackagesXApply() ... DONE
[16:01:49.129] Number of futures (= number of chunks): 2
[16:01:49.129] Launching 2 futures (chunks) ...
[16:01:49.129] Chunk #1 of 2 ...
[16:01:49.129]  - Finding globals in 'X' for chunk #1 ...
[16:01:49.129] getGlobalsAndPackages() ...
[16:01:49.130] Searching for globals...
[16:01:49.130] 
[16:01:49.130] Searching for globals ... DONE
[16:01:49.130] - globals: [0] <none>
[16:01:49.130] getGlobalsAndPackages() ... DONE
[16:01:49.130]    + additional globals found: [n=0] 
[16:01:49.130]    + additional namespaces needed: [n=0] 
[16:01:49.130]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:49.130]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:49.131]  - seeds: <none>
[16:01:49.131]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.131] getGlobalsAndPackages() ...
[16:01:49.131] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.131] Resolving globals: FALSE
[16:01:49.131] Tweak future expression to call with '...' arguments ...
[16:01:49.131] {
[16:01:49.131]     do.call(function(...) {
[16:01:49.131]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.131]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.131]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.131]             on.exit(options(oopts), add = TRUE)
[16:01:49.131]         }
[16:01:49.131]         {
[16:01:49.131]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.131]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.131]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.131]             })
[16:01:49.131]         }
[16:01:49.131]     }, args = future.call.arguments)
[16:01:49.131] }
[16:01:49.132] Tweak future expression to call with '...' arguments ... DONE
[16:01:49.132] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.132] - packages: [1] ‘stats’
[16:01:49.132] getGlobalsAndPackages() ... DONE
[16:01:49.132] run() for ‘Future’ ...
[16:01:49.133] - state: ‘created’
[16:01:49.133] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:49.137] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.137] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:49.137]   - Field: ‘label’
[16:01:49.137]   - Field: ‘local’
[16:01:49.137]   - Field: ‘owner’
[16:01:49.138]   - Field: ‘envir’
[16:01:49.138]   - Field: ‘workers’
[16:01:49.138]   - Field: ‘packages’
[16:01:49.138]   - Field: ‘gc’
[16:01:49.138]   - Field: ‘job’
[16:01:49.138]   - Field: ‘conditions’
[16:01:49.138]   - Field: ‘expr’
[16:01:49.138]   - Field: ‘uuid’
[16:01:49.138]   - Field: ‘seed’
[16:01:49.138]   - Field: ‘version’
[16:01:49.139]   - Field: ‘result’
[16:01:49.139]   - Field: ‘asynchronous’
[16:01:49.139]   - Field: ‘calls’
[16:01:49.139]   - Field: ‘globals’
[16:01:49.139]   - Field: ‘stdout’
[16:01:49.139]   - Field: ‘earlySignal’
[16:01:49.139]   - Field: ‘lazy’
[16:01:49.139]   - Field: ‘state’
[16:01:49.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:49.140] - Launch lazy future ...
[16:01:49.140] Packages needed by the future expression (n = 1): ‘stats’
[16:01:49.140] Packages needed by future strategies (n = 0): <none>
[16:01:49.140] {
[16:01:49.140]     {
[16:01:49.140]         {
[16:01:49.140]             ...future.startTime <- base::Sys.time()
[16:01:49.140]             {
[16:01:49.140]                 {
[16:01:49.140]                   {
[16:01:49.140]                     {
[16:01:49.140]                       {
[16:01:49.140]                         base::local({
[16:01:49.140]                           has_future <- base::requireNamespace("future", 
[16:01:49.140]                             quietly = TRUE)
[16:01:49.140]                           if (has_future) {
[16:01:49.140]                             ns <- base::getNamespace("future")
[16:01:49.140]                             version <- ns[[".package"]][["version"]]
[16:01:49.140]                             if (is.null(version)) 
[16:01:49.140]                               version <- utils::packageVersion("future")
[16:01:49.140]                           }
[16:01:49.140]                           else {
[16:01:49.140]                             version <- NULL
[16:01:49.140]                           }
[16:01:49.140]                           if (!has_future || version < "1.8.0") {
[16:01:49.140]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:49.140]                               "", base::R.version$version.string), 
[16:01:49.140]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:49.140]                                 base::R.version$platform, 8 * 
[16:01:49.140]                                   base::.Machine$sizeof.pointer), 
[16:01:49.140]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:49.140]                                 "release", "version")], collapse = " "), 
[16:01:49.140]                               hostname = base::Sys.info()[["nodename"]])
[16:01:49.140]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:49.140]                               info)
[16:01:49.140]                             info <- base::paste(info, collapse = "; ")
[16:01:49.140]                             if (!has_future) {
[16:01:49.140]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:49.140]                                 info)
[16:01:49.140]                             }
[16:01:49.140]                             else {
[16:01:49.140]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:49.140]                                 info, version)
[16:01:49.140]                             }
[16:01:49.140]                             base::stop(msg)
[16:01:49.140]                           }
[16:01:49.140]                         })
[16:01:49.140]                       }
[16:01:49.140]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:49.140]                       base::options(mc.cores = 1L)
[16:01:49.140]                     }
[16:01:49.140]                     base::local({
[16:01:49.140]                       for (pkg in "stats") {
[16:01:49.140]                         base::loadNamespace(pkg)
[16:01:49.140]                         base::library(pkg, character.only = TRUE)
[16:01:49.140]                       }
[16:01:49.140]                     })
[16:01:49.140]                   }
[16:01:49.140]                   options(future.plan = NULL)
[16:01:49.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:49.140]                 }
[16:01:49.140]                 ...future.workdir <- getwd()
[16:01:49.140]             }
[16:01:49.140]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:49.140]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:49.140]         }
[16:01:49.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:49.140]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:49.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:49.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:49.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:49.140]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:49.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:49.140]             base::names(...future.oldOptions))
[16:01:49.140]     }
[16:01:49.140]     if (FALSE) {
[16:01:49.140]     }
[16:01:49.140]     else {
[16:01:49.140]         if (TRUE) {
[16:01:49.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:49.140]                 open = "w")
[16:01:49.140]         }
[16:01:49.140]         else {
[16:01:49.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:49.140]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:49.140]         }
[16:01:49.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:49.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:49.140]             base::sink(type = "output", split = FALSE)
[16:01:49.140]             base::close(...future.stdout)
[16:01:49.140]         }, add = TRUE)
[16:01:49.140]     }
[16:01:49.140]     ...future.frame <- base::sys.nframe()
[16:01:49.140]     ...future.conditions <- base::list()
[16:01:49.140]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:49.140]     if (FALSE) {
[16:01:49.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:49.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:49.140]     }
[16:01:49.140]     ...future.result <- base::tryCatch({
[16:01:49.140]         base::withCallingHandlers({
[16:01:49.140]             ...future.value <- base::withVisible(base::local({
[16:01:49.140]                 withCallingHandlers({
[16:01:49.140]                   {
[16:01:49.140]                     do.call(function(...) {
[16:01:49.140]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.140]                       if (!identical(...future.globals.maxSize.org, 
[16:01:49.140]                         ...future.globals.maxSize)) {
[16:01:49.140]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.140]                         on.exit(options(oopts), add = TRUE)
[16:01:49.140]                       }
[16:01:49.140]                       {
[16:01:49.140]                         lapply(seq_along(...future.elements_ii), 
[16:01:49.140]                           FUN = function(jj) {
[16:01:49.140]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.140]                             ...future.FUN(...future.X_jj, ...)
[16:01:49.140]                           })
[16:01:49.140]                       }
[16:01:49.140]                     }, args = future.call.arguments)
[16:01:49.140]                   }
[16:01:49.140]                 }, immediateCondition = function(cond) {
[16:01:49.140]                   save_rds <- function (object, pathname, ...) 
[16:01:49.140]                   {
[16:01:49.140]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:49.140]                     if (file_test("-f", pathname_tmp)) {
[16:01:49.140]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.140]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:49.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.140]                         fi_tmp[["mtime"]])
[16:01:49.140]                     }
[16:01:49.140]                     tryCatch({
[16:01:49.140]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:49.140]                     }, error = function(ex) {
[16:01:49.140]                       msg <- conditionMessage(ex)
[16:01:49.140]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.140]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:49.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.140]                         fi_tmp[["mtime"]], msg)
[16:01:49.140]                       ex$message <- msg
[16:01:49.140]                       stop(ex)
[16:01:49.140]                     })
[16:01:49.140]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:49.140]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:49.140]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:49.140]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.140]                       fi <- file.info(pathname)
[16:01:49.140]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:49.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.140]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:49.140]                         fi[["size"]], fi[["mtime"]])
[16:01:49.140]                       stop(msg)
[16:01:49.140]                     }
[16:01:49.140]                     invisible(pathname)
[16:01:49.140]                   }
[16:01:49.140]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:49.140]                     rootPath = tempdir()) 
[16:01:49.140]                   {
[16:01:49.140]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:49.140]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:49.140]                       tmpdir = path, fileext = ".rds")
[16:01:49.140]                     save_rds(obj, file)
[16:01:49.140]                   }
[16:01:49.140]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4bFpDe/.future/immediateConditions")
[16:01:49.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.140]                   {
[16:01:49.140]                     inherits <- base::inherits
[16:01:49.140]                     invokeRestart <- base::invokeRestart
[16:01:49.140]                     is.null <- base::is.null
[16:01:49.140]                     muffled <- FALSE
[16:01:49.140]                     if (inherits(cond, "message")) {
[16:01:49.140]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:49.140]                       if (muffled) 
[16:01:49.140]                         invokeRestart("muffleMessage")
[16:01:49.140]                     }
[16:01:49.140]                     else if (inherits(cond, "warning")) {
[16:01:49.140]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:49.140]                       if (muffled) 
[16:01:49.140]                         invokeRestart("muffleWarning")
[16:01:49.140]                     }
[16:01:49.140]                     else if (inherits(cond, "condition")) {
[16:01:49.140]                       if (!is.null(pattern)) {
[16:01:49.140]                         computeRestarts <- base::computeRestarts
[16:01:49.140]                         grepl <- base::grepl
[16:01:49.140]                         restarts <- computeRestarts(cond)
[16:01:49.140]                         for (restart in restarts) {
[16:01:49.140]                           name <- restart$name
[16:01:49.140]                           if (is.null(name)) 
[16:01:49.140]                             next
[16:01:49.140]                           if (!grepl(pattern, name)) 
[16:01:49.140]                             next
[16:01:49.140]                           invokeRestart(restart)
[16:01:49.140]                           muffled <- TRUE
[16:01:49.140]                           break
[16:01:49.140]                         }
[16:01:49.140]                       }
[16:01:49.140]                     }
[16:01:49.140]                     invisible(muffled)
[16:01:49.140]                   }
[16:01:49.140]                   muffleCondition(cond)
[16:01:49.140]                 })
[16:01:49.140]             }))
[16:01:49.140]             future::FutureResult(value = ...future.value$value, 
[16:01:49.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.140]                   ...future.rng), globalenv = if (FALSE) 
[16:01:49.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:49.140]                     ...future.globalenv.names))
[16:01:49.140]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:49.140]         }, condition = base::local({
[16:01:49.140]             c <- base::c
[16:01:49.140]             inherits <- base::inherits
[16:01:49.140]             invokeRestart <- base::invokeRestart
[16:01:49.140]             length <- base::length
[16:01:49.140]             list <- base::list
[16:01:49.140]             seq.int <- base::seq.int
[16:01:49.140]             signalCondition <- base::signalCondition
[16:01:49.140]             sys.calls <- base::sys.calls
[16:01:49.140]             `[[` <- base::`[[`
[16:01:49.140]             `+` <- base::`+`
[16:01:49.140]             `<<-` <- base::`<<-`
[16:01:49.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:49.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:49.140]                   3L)]
[16:01:49.140]             }
[16:01:49.140]             function(cond) {
[16:01:49.140]                 is_error <- inherits(cond, "error")
[16:01:49.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:49.140]                   NULL)
[16:01:49.140]                 if (is_error) {
[16:01:49.140]                   sessionInformation <- function() {
[16:01:49.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:49.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:49.140]                       search = base::search(), system = base::Sys.info())
[16:01:49.140]                   }
[16:01:49.140]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:49.140]                     cond$call), session = sessionInformation(), 
[16:01:49.140]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:49.140]                   signalCondition(cond)
[16:01:49.140]                 }
[16:01:49.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:49.140]                 "immediateCondition"))) {
[16:01:49.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:49.140]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:49.140]                   if (TRUE && !signal) {
[16:01:49.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.140]                     {
[16:01:49.140]                       inherits <- base::inherits
[16:01:49.140]                       invokeRestart <- base::invokeRestart
[16:01:49.140]                       is.null <- base::is.null
[16:01:49.140]                       muffled <- FALSE
[16:01:49.140]                       if (inherits(cond, "message")) {
[16:01:49.140]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.140]                         if (muffled) 
[16:01:49.140]                           invokeRestart("muffleMessage")
[16:01:49.140]                       }
[16:01:49.140]                       else if (inherits(cond, "warning")) {
[16:01:49.140]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.140]                         if (muffled) 
[16:01:49.140]                           invokeRestart("muffleWarning")
[16:01:49.140]                       }
[16:01:49.140]                       else if (inherits(cond, "condition")) {
[16:01:49.140]                         if (!is.null(pattern)) {
[16:01:49.140]                           computeRestarts <- base::computeRestarts
[16:01:49.140]                           grepl <- base::grepl
[16:01:49.140]                           restarts <- computeRestarts(cond)
[16:01:49.140]                           for (restart in restarts) {
[16:01:49.140]                             name <- restart$name
[16:01:49.140]                             if (is.null(name)) 
[16:01:49.140]                               next
[16:01:49.140]                             if (!grepl(pattern, name)) 
[16:01:49.140]                               next
[16:01:49.140]                             invokeRestart(restart)
[16:01:49.140]                             muffled <- TRUE
[16:01:49.140]                             break
[16:01:49.140]                           }
[16:01:49.140]                         }
[16:01:49.140]                       }
[16:01:49.140]                       invisible(muffled)
[16:01:49.140]                     }
[16:01:49.140]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.140]                   }
[16:01:49.140]                 }
[16:01:49.140]                 else {
[16:01:49.140]                   if (TRUE) {
[16:01:49.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.140]                     {
[16:01:49.140]                       inherits <- base::inherits
[16:01:49.140]                       invokeRestart <- base::invokeRestart
[16:01:49.140]                       is.null <- base::is.null
[16:01:49.140]                       muffled <- FALSE
[16:01:49.140]                       if (inherits(cond, "message")) {
[16:01:49.140]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.140]                         if (muffled) 
[16:01:49.140]                           invokeRestart("muffleMessage")
[16:01:49.140]                       }
[16:01:49.140]                       else if (inherits(cond, "warning")) {
[16:01:49.140]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.140]                         if (muffled) 
[16:01:49.140]                           invokeRestart("muffleWarning")
[16:01:49.140]                       }
[16:01:49.140]                       else if (inherits(cond, "condition")) {
[16:01:49.140]                         if (!is.null(pattern)) {
[16:01:49.140]                           computeRestarts <- base::computeRestarts
[16:01:49.140]                           grepl <- base::grepl
[16:01:49.140]                           restarts <- computeRestarts(cond)
[16:01:49.140]                           for (restart in restarts) {
[16:01:49.140]                             name <- restart$name
[16:01:49.140]                             if (is.null(name)) 
[16:01:49.140]                               next
[16:01:49.140]                             if (!grepl(pattern, name)) 
[16:01:49.140]                               next
[16:01:49.140]                             invokeRestart(restart)
[16:01:49.140]                             muffled <- TRUE
[16:01:49.140]                             break
[16:01:49.140]                           }
[16:01:49.140]                         }
[16:01:49.140]                       }
[16:01:49.140]                       invisible(muffled)
[16:01:49.140]                     }
[16:01:49.140]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.140]                   }
[16:01:49.140]                 }
[16:01:49.140]             }
[16:01:49.140]         }))
[16:01:49.140]     }, error = function(ex) {
[16:01:49.140]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:49.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.140]                 ...future.rng), started = ...future.startTime, 
[16:01:49.140]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:49.140]             version = "1.8"), class = "FutureResult")
[16:01:49.140]     }, finally = {
[16:01:49.140]         if (!identical(...future.workdir, getwd())) 
[16:01:49.140]             setwd(...future.workdir)
[16:01:49.140]         {
[16:01:49.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:49.140]                 ...future.oldOptions$nwarnings <- NULL
[16:01:49.140]             }
[16:01:49.140]             base::options(...future.oldOptions)
[16:01:49.140]             if (.Platform$OS.type == "windows") {
[16:01:49.140]                 old_names <- names(...future.oldEnvVars)
[16:01:49.140]                 envs <- base::Sys.getenv()
[16:01:49.140]                 names <- names(envs)
[16:01:49.140]                 common <- intersect(names, old_names)
[16:01:49.140]                 added <- setdiff(names, old_names)
[16:01:49.140]                 removed <- setdiff(old_names, names)
[16:01:49.140]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:49.140]                   envs[common]]
[16:01:49.140]                 NAMES <- toupper(changed)
[16:01:49.140]                 args <- list()
[16:01:49.140]                 for (kk in seq_along(NAMES)) {
[16:01:49.140]                   name <- changed[[kk]]
[16:01:49.140]                   NAME <- NAMES[[kk]]
[16:01:49.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.140]                     next
[16:01:49.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.140]                 }
[16:01:49.140]                 NAMES <- toupper(added)
[16:01:49.140]                 for (kk in seq_along(NAMES)) {
[16:01:49.140]                   name <- added[[kk]]
[16:01:49.140]                   NAME <- NAMES[[kk]]
[16:01:49.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.140]                     next
[16:01:49.140]                   args[[name]] <- ""
[16:01:49.140]                 }
[16:01:49.140]                 NAMES <- toupper(removed)
[16:01:49.140]                 for (kk in seq_along(NAMES)) {
[16:01:49.140]                   name <- removed[[kk]]
[16:01:49.140]                   NAME <- NAMES[[kk]]
[16:01:49.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.140]                     next
[16:01:49.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.140]                 }
[16:01:49.140]                 if (length(args) > 0) 
[16:01:49.140]                   base::do.call(base::Sys.setenv, args = args)
[16:01:49.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:49.140]             }
[16:01:49.140]             else {
[16:01:49.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:49.140]             }
[16:01:49.140]             {
[16:01:49.140]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:49.140]                   0L) {
[16:01:49.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:49.140]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:49.140]                   base::options(opts)
[16:01:49.140]                 }
[16:01:49.140]                 {
[16:01:49.140]                   {
[16:01:49.140]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:49.140]                     NULL
[16:01:49.140]                   }
[16:01:49.140]                   options(future.plan = NULL)
[16:01:49.140]                   if (is.na(NA_character_)) 
[16:01:49.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:49.140]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:49.140]                     envir = parent.frame()) 
[16:01:49.140]                   {
[16:01:49.140]                     default_workers <- missing(workers)
[16:01:49.140]                     if (is.function(workers)) 
[16:01:49.140]                       workers <- workers()
[16:01:49.140]                     workers <- structure(as.integer(workers), 
[16:01:49.140]                       class = class(workers))
[16:01:49.140]                     stop_if_not(is.finite(workers), workers >= 
[16:01:49.140]                       1L)
[16:01:49.140]                     if ((workers == 1L && !inherits(workers, 
[16:01:49.140]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:49.140]                       if (default_workers) 
[16:01:49.140]                         supportsMulticore(warn = TRUE)
[16:01:49.140]                       return(sequential(..., envir = envir))
[16:01:49.140]                     }
[16:01:49.140]                     oopts <- options(mc.cores = workers)
[16:01:49.140]                     on.exit(options(oopts))
[16:01:49.140]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:49.140]                       envir = envir)
[16:01:49.140]                     if (!future$lazy) 
[16:01:49.140]                       future <- run(future)
[16:01:49.140]                     invisible(future)
[16:01:49.140]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:49.140]                 }
[16:01:49.140]             }
[16:01:49.140]         }
[16:01:49.140]     })
[16:01:49.140]     if (TRUE) {
[16:01:49.140]         base::sink(type = "output", split = FALSE)
[16:01:49.140]         if (TRUE) {
[16:01:49.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:49.140]         }
[16:01:49.140]         else {
[16:01:49.140]             ...future.result["stdout"] <- base::list(NULL)
[16:01:49.140]         }
[16:01:49.140]         base::close(...future.stdout)
[16:01:49.140]         ...future.stdout <- NULL
[16:01:49.140]     }
[16:01:49.140]     ...future.result$conditions <- ...future.conditions
[16:01:49.140]     ...future.result$finished <- base::Sys.time()
[16:01:49.140]     ...future.result
[16:01:49.140] }
[16:01:49.143] assign_globals() ...
[16:01:49.143] List of 5
[16:01:49.143]  $ ...future.FUN            :function (x, ...)  
[16:01:49.143]  $ future.call.arguments    :List of 1
[16:01:49.143]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:01:49.143]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.143]  $ ...future.elements_ii    :List of 1
[16:01:49.143]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:01:49.143]  $ ...future.seeds_ii       : NULL
[16:01:49.143]  $ ...future.globals.maxSize: NULL
[16:01:49.143]  - attr(*, "where")=List of 5
[16:01:49.143]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:49.143]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:49.143]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:49.143]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:49.143]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:49.143]  - attr(*, "resolved")= logi FALSE
[16:01:49.143]  - attr(*, "total_size")= num 1328
[16:01:49.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.143]  - attr(*, "already-done")= logi TRUE
[16:01:49.150] - copied ‘...future.FUN’ to environment
[16:01:49.151] - copied ‘future.call.arguments’ to environment
[16:01:49.151] - copied ‘...future.elements_ii’ to environment
[16:01:49.151] - copied ‘...future.seeds_ii’ to environment
[16:01:49.151] - copied ‘...future.globals.maxSize’ to environment
[16:01:49.151] assign_globals() ... done
[16:01:49.151] requestCore(): workers = 2
[16:01:49.153] MulticoreFuture started
[16:01:49.154] - Launch lazy future ... done
[16:01:49.154] run() for ‘MulticoreFuture’ ... done
[16:01:49.154] Created future:
[16:01:49.155] plan(): Setting new future strategy stack:
[16:01:49.155] List of future strategies:
[16:01:49.155] 1. sequential:
[16:01:49.155]    - args: function (..., envir = parent.frame())
[16:01:49.155]    - tweaked: FALSE
[16:01:49.155]    - call: NULL
[16:01:49.156] plan(): nbrOfWorkers() = 1
[16:01:49.158] plan(): Setting new future strategy stack:
[16:01:49.159] List of future strategies:
[16:01:49.159] 1. multicore:
[16:01:49.159]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:49.159]    - tweaked: FALSE
[16:01:49.159]    - call: plan(strategy)
[16:01:49.164] plan(): nbrOfWorkers() = 2
[16:01:49.155] MulticoreFuture:
[16:01:49.155] Label: ‘future_eapply-1’
[16:01:49.155] Expression:
[16:01:49.155] {
[16:01:49.155]     do.call(function(...) {
[16:01:49.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.155]             on.exit(options(oopts), add = TRUE)
[16:01:49.155]         }
[16:01:49.155]         {
[16:01:49.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.155]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.155]             })
[16:01:49.155]         }
[16:01:49.155]     }, args = future.call.arguments)
[16:01:49.155] }
[16:01:49.155] Lazy evaluation: FALSE
[16:01:49.155] Asynchronous evaluation: TRUE
[16:01:49.155] Local evaluation: TRUE
[16:01:49.155] Environment: R_GlobalEnv
[16:01:49.155] Capture standard output: TRUE
[16:01:49.155] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:49.155] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:49.155] Packages: 1 packages (‘stats’)
[16:01:49.155] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:49.155] Resolved: TRUE
[16:01:49.155] Value: <not collected>
[16:01:49.155] Conditions captured: <none>
[16:01:49.155] Early signaling: FALSE
[16:01:49.155] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:49.155] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.165] Chunk #1 of 2 ... DONE
[16:01:49.165] Chunk #2 of 2 ...
[16:01:49.165]  - Finding globals in 'X' for chunk #2 ...
[16:01:49.166] getGlobalsAndPackages() ...
[16:01:49.166] Searching for globals...
[16:01:49.166] 
[16:01:49.166] Searching for globals ... DONE
[16:01:49.166] - globals: [0] <none>
[16:01:49.167] getGlobalsAndPackages() ... DONE
[16:01:49.167]    + additional globals found: [n=0] 
[16:01:49.167]    + additional namespaces needed: [n=0] 
[16:01:49.167]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:49.167]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:49.167]  - seeds: <none>
[16:01:49.167]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.168] getGlobalsAndPackages() ...
[16:01:49.168] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.168] Resolving globals: FALSE
[16:01:49.168] Tweak future expression to call with '...' arguments ...
[16:01:49.168] {
[16:01:49.168]     do.call(function(...) {
[16:01:49.168]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.168]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.168]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.168]             on.exit(options(oopts), add = TRUE)
[16:01:49.168]         }
[16:01:49.168]         {
[16:01:49.168]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.168]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.168]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.168]             })
[16:01:49.168]         }
[16:01:49.168]     }, args = future.call.arguments)
[16:01:49.168] }
[16:01:49.169] Tweak future expression to call with '...' arguments ... DONE
[16:01:49.169] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.170] - packages: [1] ‘stats’
[16:01:49.170] getGlobalsAndPackages() ... DONE
[16:01:49.170] run() for ‘Future’ ...
[16:01:49.171] - state: ‘created’
[16:01:49.171] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:49.175] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.175] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:49.176]   - Field: ‘label’
[16:01:49.176]   - Field: ‘local’
[16:01:49.176]   - Field: ‘owner’
[16:01:49.176]   - Field: ‘envir’
[16:01:49.176]   - Field: ‘workers’
[16:01:49.176]   - Field: ‘packages’
[16:01:49.176]   - Field: ‘gc’
[16:01:49.177]   - Field: ‘job’
[16:01:49.177]   - Field: ‘conditions’
[16:01:49.177]   - Field: ‘expr’
[16:01:49.177]   - Field: ‘uuid’
[16:01:49.177]   - Field: ‘seed’
[16:01:49.177]   - Field: ‘version’
[16:01:49.177]   - Field: ‘result’
[16:01:49.178]   - Field: ‘asynchronous’
[16:01:49.178]   - Field: ‘calls’
[16:01:49.178]   - Field: ‘globals’
[16:01:49.178]   - Field: ‘stdout’
[16:01:49.178]   - Field: ‘earlySignal’
[16:01:49.178]   - Field: ‘lazy’
[16:01:49.178]   - Field: ‘state’
[16:01:49.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:49.179] - Launch lazy future ...
[16:01:49.179] Packages needed by the future expression (n = 1): ‘stats’
[16:01:49.179] Packages needed by future strategies (n = 0): <none>
[16:01:49.180] {
[16:01:49.180]     {
[16:01:49.180]         {
[16:01:49.180]             ...future.startTime <- base::Sys.time()
[16:01:49.180]             {
[16:01:49.180]                 {
[16:01:49.180]                   {
[16:01:49.180]                     {
[16:01:49.180]                       {
[16:01:49.180]                         base::local({
[16:01:49.180]                           has_future <- base::requireNamespace("future", 
[16:01:49.180]                             quietly = TRUE)
[16:01:49.180]                           if (has_future) {
[16:01:49.180]                             ns <- base::getNamespace("future")
[16:01:49.180]                             version <- ns[[".package"]][["version"]]
[16:01:49.180]                             if (is.null(version)) 
[16:01:49.180]                               version <- utils::packageVersion("future")
[16:01:49.180]                           }
[16:01:49.180]                           else {
[16:01:49.180]                             version <- NULL
[16:01:49.180]                           }
[16:01:49.180]                           if (!has_future || version < "1.8.0") {
[16:01:49.180]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:49.180]                               "", base::R.version$version.string), 
[16:01:49.180]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:49.180]                                 base::R.version$platform, 8 * 
[16:01:49.180]                                   base::.Machine$sizeof.pointer), 
[16:01:49.180]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:49.180]                                 "release", "version")], collapse = " "), 
[16:01:49.180]                               hostname = base::Sys.info()[["nodename"]])
[16:01:49.180]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:49.180]                               info)
[16:01:49.180]                             info <- base::paste(info, collapse = "; ")
[16:01:49.180]                             if (!has_future) {
[16:01:49.180]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:49.180]                                 info)
[16:01:49.180]                             }
[16:01:49.180]                             else {
[16:01:49.180]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:49.180]                                 info, version)
[16:01:49.180]                             }
[16:01:49.180]                             base::stop(msg)
[16:01:49.180]                           }
[16:01:49.180]                         })
[16:01:49.180]                       }
[16:01:49.180]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:49.180]                       base::options(mc.cores = 1L)
[16:01:49.180]                     }
[16:01:49.180]                     base::local({
[16:01:49.180]                       for (pkg in "stats") {
[16:01:49.180]                         base::loadNamespace(pkg)
[16:01:49.180]                         base::library(pkg, character.only = TRUE)
[16:01:49.180]                       }
[16:01:49.180]                     })
[16:01:49.180]                   }
[16:01:49.180]                   options(future.plan = NULL)
[16:01:49.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:49.180]                 }
[16:01:49.180]                 ...future.workdir <- getwd()
[16:01:49.180]             }
[16:01:49.180]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:49.180]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:49.180]         }
[16:01:49.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:49.180]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:49.180]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:49.180]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:49.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:49.180]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:49.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:49.180]             base::names(...future.oldOptions))
[16:01:49.180]     }
[16:01:49.180]     if (FALSE) {
[16:01:49.180]     }
[16:01:49.180]     else {
[16:01:49.180]         if (TRUE) {
[16:01:49.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:49.180]                 open = "w")
[16:01:49.180]         }
[16:01:49.180]         else {
[16:01:49.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:49.180]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:49.180]         }
[16:01:49.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:49.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:49.180]             base::sink(type = "output", split = FALSE)
[16:01:49.180]             base::close(...future.stdout)
[16:01:49.180]         }, add = TRUE)
[16:01:49.180]     }
[16:01:49.180]     ...future.frame <- base::sys.nframe()
[16:01:49.180]     ...future.conditions <- base::list()
[16:01:49.180]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:49.180]     if (FALSE) {
[16:01:49.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:49.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:49.180]     }
[16:01:49.180]     ...future.result <- base::tryCatch({
[16:01:49.180]         base::withCallingHandlers({
[16:01:49.180]             ...future.value <- base::withVisible(base::local({
[16:01:49.180]                 withCallingHandlers({
[16:01:49.180]                   {
[16:01:49.180]                     do.call(function(...) {
[16:01:49.180]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.180]                       if (!identical(...future.globals.maxSize.org, 
[16:01:49.180]                         ...future.globals.maxSize)) {
[16:01:49.180]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.180]                         on.exit(options(oopts), add = TRUE)
[16:01:49.180]                       }
[16:01:49.180]                       {
[16:01:49.180]                         lapply(seq_along(...future.elements_ii), 
[16:01:49.180]                           FUN = function(jj) {
[16:01:49.180]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.180]                             ...future.FUN(...future.X_jj, ...)
[16:01:49.180]                           })
[16:01:49.180]                       }
[16:01:49.180]                     }, args = future.call.arguments)
[16:01:49.180]                   }
[16:01:49.180]                 }, immediateCondition = function(cond) {
[16:01:49.180]                   save_rds <- function (object, pathname, ...) 
[16:01:49.180]                   {
[16:01:49.180]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:49.180]                     if (file_test("-f", pathname_tmp)) {
[16:01:49.180]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.180]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:49.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.180]                         fi_tmp[["mtime"]])
[16:01:49.180]                     }
[16:01:49.180]                     tryCatch({
[16:01:49.180]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:49.180]                     }, error = function(ex) {
[16:01:49.180]                       msg <- conditionMessage(ex)
[16:01:49.180]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.180]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:49.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.180]                         fi_tmp[["mtime"]], msg)
[16:01:49.180]                       ex$message <- msg
[16:01:49.180]                       stop(ex)
[16:01:49.180]                     })
[16:01:49.180]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:49.180]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:49.180]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:49.180]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.180]                       fi <- file.info(pathname)
[16:01:49.180]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:49.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.180]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:49.180]                         fi[["size"]], fi[["mtime"]])
[16:01:49.180]                       stop(msg)
[16:01:49.180]                     }
[16:01:49.180]                     invisible(pathname)
[16:01:49.180]                   }
[16:01:49.180]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:49.180]                     rootPath = tempdir()) 
[16:01:49.180]                   {
[16:01:49.180]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:49.180]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:49.180]                       tmpdir = path, fileext = ".rds")
[16:01:49.180]                     save_rds(obj, file)
[16:01:49.180]                   }
[16:01:49.180]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4bFpDe/.future/immediateConditions")
[16:01:49.180]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.180]                   {
[16:01:49.180]                     inherits <- base::inherits
[16:01:49.180]                     invokeRestart <- base::invokeRestart
[16:01:49.180]                     is.null <- base::is.null
[16:01:49.180]                     muffled <- FALSE
[16:01:49.180]                     if (inherits(cond, "message")) {
[16:01:49.180]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:49.180]                       if (muffled) 
[16:01:49.180]                         invokeRestart("muffleMessage")
[16:01:49.180]                     }
[16:01:49.180]                     else if (inherits(cond, "warning")) {
[16:01:49.180]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:49.180]                       if (muffled) 
[16:01:49.180]                         invokeRestart("muffleWarning")
[16:01:49.180]                     }
[16:01:49.180]                     else if (inherits(cond, "condition")) {
[16:01:49.180]                       if (!is.null(pattern)) {
[16:01:49.180]                         computeRestarts <- base::computeRestarts
[16:01:49.180]                         grepl <- base::grepl
[16:01:49.180]                         restarts <- computeRestarts(cond)
[16:01:49.180]                         for (restart in restarts) {
[16:01:49.180]                           name <- restart$name
[16:01:49.180]                           if (is.null(name)) 
[16:01:49.180]                             next
[16:01:49.180]                           if (!grepl(pattern, name)) 
[16:01:49.180]                             next
[16:01:49.180]                           invokeRestart(restart)
[16:01:49.180]                           muffled <- TRUE
[16:01:49.180]                           break
[16:01:49.180]                         }
[16:01:49.180]                       }
[16:01:49.180]                     }
[16:01:49.180]                     invisible(muffled)
[16:01:49.180]                   }
[16:01:49.180]                   muffleCondition(cond)
[16:01:49.180]                 })
[16:01:49.180]             }))
[16:01:49.180]             future::FutureResult(value = ...future.value$value, 
[16:01:49.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.180]                   ...future.rng), globalenv = if (FALSE) 
[16:01:49.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:49.180]                     ...future.globalenv.names))
[16:01:49.180]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:49.180]         }, condition = base::local({
[16:01:49.180]             c <- base::c
[16:01:49.180]             inherits <- base::inherits
[16:01:49.180]             invokeRestart <- base::invokeRestart
[16:01:49.180]             length <- base::length
[16:01:49.180]             list <- base::list
[16:01:49.180]             seq.int <- base::seq.int
[16:01:49.180]             signalCondition <- base::signalCondition
[16:01:49.180]             sys.calls <- base::sys.calls
[16:01:49.180]             `[[` <- base::`[[`
[16:01:49.180]             `+` <- base::`+`
[16:01:49.180]             `<<-` <- base::`<<-`
[16:01:49.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:49.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:49.180]                   3L)]
[16:01:49.180]             }
[16:01:49.180]             function(cond) {
[16:01:49.180]                 is_error <- inherits(cond, "error")
[16:01:49.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:49.180]                   NULL)
[16:01:49.180]                 if (is_error) {
[16:01:49.180]                   sessionInformation <- function() {
[16:01:49.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:49.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:49.180]                       search = base::search(), system = base::Sys.info())
[16:01:49.180]                   }
[16:01:49.180]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:49.180]                     cond$call), session = sessionInformation(), 
[16:01:49.180]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:49.180]                   signalCondition(cond)
[16:01:49.180]                 }
[16:01:49.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:49.180]                 "immediateCondition"))) {
[16:01:49.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:49.180]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:49.180]                   if (TRUE && !signal) {
[16:01:49.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.180]                     {
[16:01:49.180]                       inherits <- base::inherits
[16:01:49.180]                       invokeRestart <- base::invokeRestart
[16:01:49.180]                       is.null <- base::is.null
[16:01:49.180]                       muffled <- FALSE
[16:01:49.180]                       if (inherits(cond, "message")) {
[16:01:49.180]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.180]                         if (muffled) 
[16:01:49.180]                           invokeRestart("muffleMessage")
[16:01:49.180]                       }
[16:01:49.180]                       else if (inherits(cond, "warning")) {
[16:01:49.180]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.180]                         if (muffled) 
[16:01:49.180]                           invokeRestart("muffleWarning")
[16:01:49.180]                       }
[16:01:49.180]                       else if (inherits(cond, "condition")) {
[16:01:49.180]                         if (!is.null(pattern)) {
[16:01:49.180]                           computeRestarts <- base::computeRestarts
[16:01:49.180]                           grepl <- base::grepl
[16:01:49.180]                           restarts <- computeRestarts(cond)
[16:01:49.180]                           for (restart in restarts) {
[16:01:49.180]                             name <- restart$name
[16:01:49.180]                             if (is.null(name)) 
[16:01:49.180]                               next
[16:01:49.180]                             if (!grepl(pattern, name)) 
[16:01:49.180]                               next
[16:01:49.180]                             invokeRestart(restart)
[16:01:49.180]                             muffled <- TRUE
[16:01:49.180]                             break
[16:01:49.180]                           }
[16:01:49.180]                         }
[16:01:49.180]                       }
[16:01:49.180]                       invisible(muffled)
[16:01:49.180]                     }
[16:01:49.180]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.180]                   }
[16:01:49.180]                 }
[16:01:49.180]                 else {
[16:01:49.180]                   if (TRUE) {
[16:01:49.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.180]                     {
[16:01:49.180]                       inherits <- base::inherits
[16:01:49.180]                       invokeRestart <- base::invokeRestart
[16:01:49.180]                       is.null <- base::is.null
[16:01:49.180]                       muffled <- FALSE
[16:01:49.180]                       if (inherits(cond, "message")) {
[16:01:49.180]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.180]                         if (muffled) 
[16:01:49.180]                           invokeRestart("muffleMessage")
[16:01:49.180]                       }
[16:01:49.180]                       else if (inherits(cond, "warning")) {
[16:01:49.180]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.180]                         if (muffled) 
[16:01:49.180]                           invokeRestart("muffleWarning")
[16:01:49.180]                       }
[16:01:49.180]                       else if (inherits(cond, "condition")) {
[16:01:49.180]                         if (!is.null(pattern)) {
[16:01:49.180]                           computeRestarts <- base::computeRestarts
[16:01:49.180]                           grepl <- base::grepl
[16:01:49.180]                           restarts <- computeRestarts(cond)
[16:01:49.180]                           for (restart in restarts) {
[16:01:49.180]                             name <- restart$name
[16:01:49.180]                             if (is.null(name)) 
[16:01:49.180]                               next
[16:01:49.180]                             if (!grepl(pattern, name)) 
[16:01:49.180]                               next
[16:01:49.180]                             invokeRestart(restart)
[16:01:49.180]                             muffled <- TRUE
[16:01:49.180]                             break
[16:01:49.180]                           }
[16:01:49.180]                         }
[16:01:49.180]                       }
[16:01:49.180]                       invisible(muffled)
[16:01:49.180]                     }
[16:01:49.180]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.180]                   }
[16:01:49.180]                 }
[16:01:49.180]             }
[16:01:49.180]         }))
[16:01:49.180]     }, error = function(ex) {
[16:01:49.180]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:49.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.180]                 ...future.rng), started = ...future.startTime, 
[16:01:49.180]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:49.180]             version = "1.8"), class = "FutureResult")
[16:01:49.180]     }, finally = {
[16:01:49.180]         if (!identical(...future.workdir, getwd())) 
[16:01:49.180]             setwd(...future.workdir)
[16:01:49.180]         {
[16:01:49.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:49.180]                 ...future.oldOptions$nwarnings <- NULL
[16:01:49.180]             }
[16:01:49.180]             base::options(...future.oldOptions)
[16:01:49.180]             if (.Platform$OS.type == "windows") {
[16:01:49.180]                 old_names <- names(...future.oldEnvVars)
[16:01:49.180]                 envs <- base::Sys.getenv()
[16:01:49.180]                 names <- names(envs)
[16:01:49.180]                 common <- intersect(names, old_names)
[16:01:49.180]                 added <- setdiff(names, old_names)
[16:01:49.180]                 removed <- setdiff(old_names, names)
[16:01:49.180]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:49.180]                   envs[common]]
[16:01:49.180]                 NAMES <- toupper(changed)
[16:01:49.180]                 args <- list()
[16:01:49.180]                 for (kk in seq_along(NAMES)) {
[16:01:49.180]                   name <- changed[[kk]]
[16:01:49.180]                   NAME <- NAMES[[kk]]
[16:01:49.180]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.180]                     next
[16:01:49.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.180]                 }
[16:01:49.180]                 NAMES <- toupper(added)
[16:01:49.180]                 for (kk in seq_along(NAMES)) {
[16:01:49.180]                   name <- added[[kk]]
[16:01:49.180]                   NAME <- NAMES[[kk]]
[16:01:49.180]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.180]                     next
[16:01:49.180]                   args[[name]] <- ""
[16:01:49.180]                 }
[16:01:49.180]                 NAMES <- toupper(removed)
[16:01:49.180]                 for (kk in seq_along(NAMES)) {
[16:01:49.180]                   name <- removed[[kk]]
[16:01:49.180]                   NAME <- NAMES[[kk]]
[16:01:49.180]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.180]                     next
[16:01:49.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.180]                 }
[16:01:49.180]                 if (length(args) > 0) 
[16:01:49.180]                   base::do.call(base::Sys.setenv, args = args)
[16:01:49.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:49.180]             }
[16:01:49.180]             else {
[16:01:49.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:49.180]             }
[16:01:49.180]             {
[16:01:49.180]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:49.180]                   0L) {
[16:01:49.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:49.180]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:49.180]                   base::options(opts)
[16:01:49.180]                 }
[16:01:49.180]                 {
[16:01:49.180]                   {
[16:01:49.180]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:49.180]                     NULL
[16:01:49.180]                   }
[16:01:49.180]                   options(future.plan = NULL)
[16:01:49.180]                   if (is.na(NA_character_)) 
[16:01:49.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:49.180]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:49.180]                     envir = parent.frame()) 
[16:01:49.180]                   {
[16:01:49.180]                     default_workers <- missing(workers)
[16:01:49.180]                     if (is.function(workers)) 
[16:01:49.180]                       workers <- workers()
[16:01:49.180]                     workers <- structure(as.integer(workers), 
[16:01:49.180]                       class = class(workers))
[16:01:49.180]                     stop_if_not(is.finite(workers), workers >= 
[16:01:49.180]                       1L)
[16:01:49.180]                     if ((workers == 1L && !inherits(workers, 
[16:01:49.180]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:49.180]                       if (default_workers) 
[16:01:49.180]                         supportsMulticore(warn = TRUE)
[16:01:49.180]                       return(sequential(..., envir = envir))
[16:01:49.180]                     }
[16:01:49.180]                     oopts <- options(mc.cores = workers)
[16:01:49.180]                     on.exit(options(oopts))
[16:01:49.180]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:49.180]                       envir = envir)
[16:01:49.180]                     if (!future$lazy) 
[16:01:49.180]                       future <- run(future)
[16:01:49.180]                     invisible(future)
[16:01:49.180]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:49.180]                 }
[16:01:49.180]             }
[16:01:49.180]         }
[16:01:49.180]     })
[16:01:49.180]     if (TRUE) {
[16:01:49.180]         base::sink(type = "output", split = FALSE)
[16:01:49.180]         if (TRUE) {
[16:01:49.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:49.180]         }
[16:01:49.180]         else {
[16:01:49.180]             ...future.result["stdout"] <- base::list(NULL)
[16:01:49.180]         }
[16:01:49.180]         base::close(...future.stdout)
[16:01:49.180]         ...future.stdout <- NULL
[16:01:49.180]     }
[16:01:49.180]     ...future.result$conditions <- ...future.conditions
[16:01:49.180]     ...future.result$finished <- base::Sys.time()
[16:01:49.180]     ...future.result
[16:01:49.180] }
[16:01:49.184] assign_globals() ...
[16:01:49.184] List of 5
[16:01:49.184]  $ ...future.FUN            :function (x, ...)  
[16:01:49.184]  $ future.call.arguments    :List of 1
[16:01:49.184]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:01:49.184]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.184]  $ ...future.elements_ii    :List of 2
[16:01:49.184]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:01:49.184]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:01:49.184]  $ ...future.seeds_ii       : NULL
[16:01:49.184]  $ ...future.globals.maxSize: NULL
[16:01:49.184]  - attr(*, "where")=List of 5
[16:01:49.184]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:49.184]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:49.184]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:49.184]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:49.184]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:49.184]  - attr(*, "resolved")= logi FALSE
[16:01:49.184]  - attr(*, "total_size")= num 1328
[16:01:49.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.184]  - attr(*, "already-done")= logi TRUE
[16:01:49.194] - copied ‘...future.FUN’ to environment
[16:01:49.194] - copied ‘future.call.arguments’ to environment
[16:01:49.195] - copied ‘...future.elements_ii’ to environment
[16:01:49.195] - copied ‘...future.seeds_ii’ to environment
[16:01:49.195] - copied ‘...future.globals.maxSize’ to environment
[16:01:49.195] assign_globals() ... done
[16:01:49.195] requestCore(): workers = 2
[16:01:49.198] MulticoreFuture started
[16:01:49.198] - Launch lazy future ... done
[16:01:49.199] run() for ‘MulticoreFuture’ ... done
[16:01:49.199] Created future:
[16:01:49.200] plan(): Setting new future strategy stack:
[16:01:49.200] List of future strategies:
[16:01:49.200] 1. sequential:
[16:01:49.200]    - args: function (..., envir = parent.frame())
[16:01:49.200]    - tweaked: FALSE
[16:01:49.200]    - call: NULL
[16:01:49.201] plan(): nbrOfWorkers() = 1
[16:01:49.204] plan(): Setting new future strategy stack:
[16:01:49.204] List of future strategies:
[16:01:49.204] 1. multicore:
[16:01:49.204]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:49.204]    - tweaked: FALSE
[16:01:49.204]    - call: plan(strategy)
[16:01:49.210] plan(): nbrOfWorkers() = 2
[16:01:49.199] MulticoreFuture:
[16:01:49.199] Label: ‘future_eapply-2’
[16:01:49.199] Expression:
[16:01:49.199] {
[16:01:49.199]     do.call(function(...) {
[16:01:49.199]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.199]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.199]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.199]             on.exit(options(oopts), add = TRUE)
[16:01:49.199]         }
[16:01:49.199]         {
[16:01:49.199]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.199]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.199]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.199]             })
[16:01:49.199]         }
[16:01:49.199]     }, args = future.call.arguments)
[16:01:49.199] }
[16:01:49.199] Lazy evaluation: FALSE
[16:01:49.199] Asynchronous evaluation: TRUE
[16:01:49.199] Local evaluation: TRUE
[16:01:49.199] Environment: R_GlobalEnv
[16:01:49.199] Capture standard output: TRUE
[16:01:49.199] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:49.199] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:49.199] Packages: 1 packages (‘stats’)
[16:01:49.199] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:49.199] Resolved: TRUE
[16:01:49.199] Value: <not collected>
[16:01:49.199] Conditions captured: <none>
[16:01:49.199] Early signaling: FALSE
[16:01:49.199] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:49.199] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.211] Chunk #2 of 2 ... DONE
[16:01:49.211] Launching 2 futures (chunks) ... DONE
[16:01:49.211] Resolving 2 futures (chunks) ...
[16:01:49.212] resolve() on list ...
[16:01:49.212]  recursive: 0
[16:01:49.212]  length: 2
[16:01:49.212] 
[16:01:49.213] Future #1
[16:01:49.213] result() for MulticoreFuture ...
[16:01:49.214] result() for MulticoreFuture ...
[16:01:49.214] result() for MulticoreFuture ... done
[16:01:49.214] result() for MulticoreFuture ... done
[16:01:49.214] result() for MulticoreFuture ...
[16:01:49.215] result() for MulticoreFuture ... done
[16:01:49.215] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:49.215] - nx: 2
[16:01:49.215] - relay: TRUE
[16:01:49.215] - stdout: TRUE
[16:01:49.215] - signal: TRUE
[16:01:49.215] - resignal: FALSE
[16:01:49.216] - force: TRUE
[16:01:49.216] - relayed: [n=2] FALSE, FALSE
[16:01:49.216] - queued futures: [n=2] FALSE, FALSE
[16:01:49.216]  - until=1
[16:01:49.216]  - relaying element #1
[16:01:49.216] result() for MulticoreFuture ...
[16:01:49.217] result() for MulticoreFuture ... done
[16:01:49.217] result() for MulticoreFuture ...
[16:01:49.217] result() for MulticoreFuture ... done
[16:01:49.217] result() for MulticoreFuture ...
[16:01:49.217] result() for MulticoreFuture ... done
[16:01:49.217] result() for MulticoreFuture ...
[16:01:49.218] result() for MulticoreFuture ... done
[16:01:49.218] - relayed: [n=2] TRUE, FALSE
[16:01:49.218] - queued futures: [n=2] TRUE, FALSE
[16:01:49.218] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:49.218]  length: 1 (resolved future 1)
[16:01:49.219] Future #2
[16:01:49.219] result() for MulticoreFuture ...
[16:01:49.219] result() for MulticoreFuture ...
[16:01:49.220] result() for MulticoreFuture ... done
[16:01:49.220] result() for MulticoreFuture ... done
[16:01:49.220] result() for MulticoreFuture ...
[16:01:49.220] result() for MulticoreFuture ... done
[16:01:49.220] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:49.220] - nx: 2
[16:01:49.220] - relay: TRUE
[16:01:49.221] - stdout: TRUE
[16:01:49.221] - signal: TRUE
[16:01:49.221] - resignal: FALSE
[16:01:49.221] - force: TRUE
[16:01:49.221] - relayed: [n=2] TRUE, FALSE
[16:01:49.221] - queued futures: [n=2] TRUE, FALSE
[16:01:49.221]  - until=2
[16:01:49.221]  - relaying element #2
[16:01:49.222] result() for MulticoreFuture ...
[16:01:49.222] result() for MulticoreFuture ... done
[16:01:49.222] result() for MulticoreFuture ...
[16:01:49.222] result() for MulticoreFuture ... done
[16:01:49.222] result() for MulticoreFuture ...
[16:01:49.222] result() for MulticoreFuture ... done
[16:01:49.222] result() for MulticoreFuture ...
[16:01:49.222] result() for MulticoreFuture ... done
[16:01:49.222] - relayed: [n=2] TRUE, TRUE
[16:01:49.223] - queued futures: [n=2] TRUE, TRUE
[16:01:49.223] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:49.223]  length: 0 (resolved future 2)
[16:01:49.223] Relaying remaining futures
[16:01:49.223] signalConditionsASAP(NULL, pos=0) ...
[16:01:49.223] - nx: 2
[16:01:49.223] - relay: TRUE
[16:01:49.223] - stdout: TRUE
[16:01:49.224] - signal: TRUE
[16:01:49.224] - resignal: FALSE
[16:01:49.224] - force: TRUE
[16:01:49.224] - relayed: [n=2] TRUE, TRUE
[16:01:49.224] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:49.224] - relayed: [n=2] TRUE, TRUE
[16:01:49.224] - queued futures: [n=2] TRUE, TRUE
[16:01:49.224] signalConditionsASAP(NULL, pos=0) ... done
[16:01:49.224] resolve() on list ... DONE
[16:01:49.225] result() for MulticoreFuture ...
[16:01:49.225] result() for MulticoreFuture ... done
[16:01:49.225] result() for MulticoreFuture ...
[16:01:49.225] result() for MulticoreFuture ... done
[16:01:49.225] result() for MulticoreFuture ...
[16:01:49.225] result() for MulticoreFuture ... done
[16:01:49.225] result() for MulticoreFuture ...
[16:01:49.225] result() for MulticoreFuture ... done
[16:01:49.226]  - Number of value chunks collected: 2
[16:01:49.226] Resolving 2 futures (chunks) ... DONE
[16:01:49.226] Reducing values from 2 chunks ...
[16:01:49.226]  - Number of values collected after concatenation: 3
[16:01:49.226]  - Number of values expected: 3
[16:01:49.226] Reducing values from 2 chunks ... DONE
[16:01:49.226] future_lapply() ... DONE
[16:01:49.227] future_lapply() ...
[16:01:49.232] Number of chunks: 2
[16:01:49.232] getGlobalsAndPackagesXApply() ...
[16:01:49.232]  - future.globals: TRUE
[16:01:49.232] getGlobalsAndPackages() ...
[16:01:49.232] Searching for globals...
[16:01:49.234] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:49.234] Searching for globals ... DONE
[16:01:49.234] Resolving globals: FALSE
[16:01:49.234] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:49.235] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:49.235] - globals: [1] ‘FUN’
[16:01:49.235] - packages: [1] ‘stats’
[16:01:49.235] getGlobalsAndPackages() ... DONE
[16:01:49.235]  - globals found/used: [n=1] ‘FUN’
[16:01:49.235]  - needed namespaces: [n=1] ‘stats’
[16:01:49.236] Finding globals ... DONE
[16:01:49.236]  - use_args: TRUE
[16:01:49.236]  - Getting '...' globals ...
[16:01:49.236] resolve() on list ...
[16:01:49.236]  recursive: 0
[16:01:49.236]  length: 1
[16:01:49.237]  elements: ‘...’
[16:01:49.237]  length: 0 (resolved future 1)
[16:01:49.237] resolve() on list ... DONE
[16:01:49.237]    - '...' content: [n=0] 
[16:01:49.237] List of 1
[16:01:49.237]  $ ...: list()
[16:01:49.237]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.237]  - attr(*, "where")=List of 1
[16:01:49.237]   ..$ ...:<environment: 0x5620a1970648> 
[16:01:49.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.237]  - attr(*, "resolved")= logi TRUE
[16:01:49.237]  - attr(*, "total_size")= num NA
[16:01:49.242]  - Getting '...' globals ... DONE
[16:01:49.242] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:49.242] List of 2
[16:01:49.242]  $ ...future.FUN:function (x, ...)  
[16:01:49.242]  $ ...          : list()
[16:01:49.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.242]  - attr(*, "where")=List of 2
[16:01:49.242]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:49.242]   ..$ ...          :<environment: 0x5620a1970648> 
[16:01:49.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.242]  - attr(*, "resolved")= logi FALSE
[16:01:49.242]  - attr(*, "total_size")= num 1248
[16:01:49.245] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:49.245] getGlobalsAndPackagesXApply() ... DONE
[16:01:49.245] Number of futures (= number of chunks): 2
[16:01:49.246] Launching 2 futures (chunks) ...
[16:01:49.246] Chunk #1 of 2 ...
[16:01:49.246]  - Finding globals in 'X' for chunk #1 ...
[16:01:49.246] getGlobalsAndPackages() ...
[16:01:49.246] Searching for globals...
[16:01:49.246] 
[16:01:49.246] Searching for globals ... DONE
[16:01:49.246] - globals: [0] <none>
[16:01:49.247] getGlobalsAndPackages() ... DONE
[16:01:49.247]    + additional globals found: [n=0] 
[16:01:49.247]    + additional namespaces needed: [n=0] 
[16:01:49.247]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:49.247]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:49.247]  - seeds: <none>
[16:01:49.247]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.247] getGlobalsAndPackages() ...
[16:01:49.247] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.247] Resolving globals: FALSE
[16:01:49.248] Tweak future expression to call with '...' arguments ...
[16:01:49.248] {
[16:01:49.248]     do.call(function(...) {
[16:01:49.248]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.248]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.248]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.248]             on.exit(options(oopts), add = TRUE)
[16:01:49.248]         }
[16:01:49.248]         {
[16:01:49.248]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.248]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.248]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.248]             })
[16:01:49.248]         }
[16:01:49.248]     }, args = future.call.arguments)
[16:01:49.248] }
[16:01:49.248] Tweak future expression to call with '...' arguments ... DONE
[16:01:49.248] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.248] - packages: [1] ‘stats’
[16:01:49.249] getGlobalsAndPackages() ... DONE
[16:01:49.249] run() for ‘Future’ ...
[16:01:49.249] - state: ‘created’
[16:01:49.249] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:49.253] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.253] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:49.253]   - Field: ‘label’
[16:01:49.253]   - Field: ‘local’
[16:01:49.253]   - Field: ‘owner’
[16:01:49.253]   - Field: ‘envir’
[16:01:49.253]   - Field: ‘workers’
[16:01:49.254]   - Field: ‘packages’
[16:01:49.254]   - Field: ‘gc’
[16:01:49.254]   - Field: ‘job’
[16:01:49.254]   - Field: ‘conditions’
[16:01:49.254]   - Field: ‘expr’
[16:01:49.254]   - Field: ‘uuid’
[16:01:49.254]   - Field: ‘seed’
[16:01:49.254]   - Field: ‘version’
[16:01:49.254]   - Field: ‘result’
[16:01:49.254]   - Field: ‘asynchronous’
[16:01:49.254]   - Field: ‘calls’
[16:01:49.255]   - Field: ‘globals’
[16:01:49.255]   - Field: ‘stdout’
[16:01:49.255]   - Field: ‘earlySignal’
[16:01:49.255]   - Field: ‘lazy’
[16:01:49.255]   - Field: ‘state’
[16:01:49.255] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:49.255] - Launch lazy future ...
[16:01:49.255] Packages needed by the future expression (n = 1): ‘stats’
[16:01:49.256] Packages needed by future strategies (n = 0): <none>
[16:01:49.256] {
[16:01:49.256]     {
[16:01:49.256]         {
[16:01:49.256]             ...future.startTime <- base::Sys.time()
[16:01:49.256]             {
[16:01:49.256]                 {
[16:01:49.256]                   {
[16:01:49.256]                     {
[16:01:49.256]                       {
[16:01:49.256]                         base::local({
[16:01:49.256]                           has_future <- base::requireNamespace("future", 
[16:01:49.256]                             quietly = TRUE)
[16:01:49.256]                           if (has_future) {
[16:01:49.256]                             ns <- base::getNamespace("future")
[16:01:49.256]                             version <- ns[[".package"]][["version"]]
[16:01:49.256]                             if (is.null(version)) 
[16:01:49.256]                               version <- utils::packageVersion("future")
[16:01:49.256]                           }
[16:01:49.256]                           else {
[16:01:49.256]                             version <- NULL
[16:01:49.256]                           }
[16:01:49.256]                           if (!has_future || version < "1.8.0") {
[16:01:49.256]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:49.256]                               "", base::R.version$version.string), 
[16:01:49.256]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:49.256]                                 base::R.version$platform, 8 * 
[16:01:49.256]                                   base::.Machine$sizeof.pointer), 
[16:01:49.256]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:49.256]                                 "release", "version")], collapse = " "), 
[16:01:49.256]                               hostname = base::Sys.info()[["nodename"]])
[16:01:49.256]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:49.256]                               info)
[16:01:49.256]                             info <- base::paste(info, collapse = "; ")
[16:01:49.256]                             if (!has_future) {
[16:01:49.256]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:49.256]                                 info)
[16:01:49.256]                             }
[16:01:49.256]                             else {
[16:01:49.256]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:49.256]                                 info, version)
[16:01:49.256]                             }
[16:01:49.256]                             base::stop(msg)
[16:01:49.256]                           }
[16:01:49.256]                         })
[16:01:49.256]                       }
[16:01:49.256]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:49.256]                       base::options(mc.cores = 1L)
[16:01:49.256]                     }
[16:01:49.256]                     base::local({
[16:01:49.256]                       for (pkg in "stats") {
[16:01:49.256]                         base::loadNamespace(pkg)
[16:01:49.256]                         base::library(pkg, character.only = TRUE)
[16:01:49.256]                       }
[16:01:49.256]                     })
[16:01:49.256]                   }
[16:01:49.256]                   options(future.plan = NULL)
[16:01:49.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:49.256]                 }
[16:01:49.256]                 ...future.workdir <- getwd()
[16:01:49.256]             }
[16:01:49.256]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:49.256]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:49.256]         }
[16:01:49.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:49.256]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:49.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:49.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:49.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:49.256]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:49.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:49.256]             base::names(...future.oldOptions))
[16:01:49.256]     }
[16:01:49.256]     if (FALSE) {
[16:01:49.256]     }
[16:01:49.256]     else {
[16:01:49.256]         if (TRUE) {
[16:01:49.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:49.256]                 open = "w")
[16:01:49.256]         }
[16:01:49.256]         else {
[16:01:49.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:49.256]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:49.256]         }
[16:01:49.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:49.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:49.256]             base::sink(type = "output", split = FALSE)
[16:01:49.256]             base::close(...future.stdout)
[16:01:49.256]         }, add = TRUE)
[16:01:49.256]     }
[16:01:49.256]     ...future.frame <- base::sys.nframe()
[16:01:49.256]     ...future.conditions <- base::list()
[16:01:49.256]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:49.256]     if (FALSE) {
[16:01:49.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:49.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:49.256]     }
[16:01:49.256]     ...future.result <- base::tryCatch({
[16:01:49.256]         base::withCallingHandlers({
[16:01:49.256]             ...future.value <- base::withVisible(base::local({
[16:01:49.256]                 withCallingHandlers({
[16:01:49.256]                   {
[16:01:49.256]                     do.call(function(...) {
[16:01:49.256]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.256]                       if (!identical(...future.globals.maxSize.org, 
[16:01:49.256]                         ...future.globals.maxSize)) {
[16:01:49.256]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.256]                         on.exit(options(oopts), add = TRUE)
[16:01:49.256]                       }
[16:01:49.256]                       {
[16:01:49.256]                         lapply(seq_along(...future.elements_ii), 
[16:01:49.256]                           FUN = function(jj) {
[16:01:49.256]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.256]                             ...future.FUN(...future.X_jj, ...)
[16:01:49.256]                           })
[16:01:49.256]                       }
[16:01:49.256]                     }, args = future.call.arguments)
[16:01:49.256]                   }
[16:01:49.256]                 }, immediateCondition = function(cond) {
[16:01:49.256]                   save_rds <- function (object, pathname, ...) 
[16:01:49.256]                   {
[16:01:49.256]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:49.256]                     if (file_test("-f", pathname_tmp)) {
[16:01:49.256]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.256]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:49.256]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.256]                         fi_tmp[["mtime"]])
[16:01:49.256]                     }
[16:01:49.256]                     tryCatch({
[16:01:49.256]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:49.256]                     }, error = function(ex) {
[16:01:49.256]                       msg <- conditionMessage(ex)
[16:01:49.256]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.256]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:49.256]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.256]                         fi_tmp[["mtime"]], msg)
[16:01:49.256]                       ex$message <- msg
[16:01:49.256]                       stop(ex)
[16:01:49.256]                     })
[16:01:49.256]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:49.256]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:49.256]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:49.256]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.256]                       fi <- file.info(pathname)
[16:01:49.256]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:49.256]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.256]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:49.256]                         fi[["size"]], fi[["mtime"]])
[16:01:49.256]                       stop(msg)
[16:01:49.256]                     }
[16:01:49.256]                     invisible(pathname)
[16:01:49.256]                   }
[16:01:49.256]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:49.256]                     rootPath = tempdir()) 
[16:01:49.256]                   {
[16:01:49.256]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:49.256]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:49.256]                       tmpdir = path, fileext = ".rds")
[16:01:49.256]                     save_rds(obj, file)
[16:01:49.256]                   }
[16:01:49.256]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4bFpDe/.future/immediateConditions")
[16:01:49.256]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.256]                   {
[16:01:49.256]                     inherits <- base::inherits
[16:01:49.256]                     invokeRestart <- base::invokeRestart
[16:01:49.256]                     is.null <- base::is.null
[16:01:49.256]                     muffled <- FALSE
[16:01:49.256]                     if (inherits(cond, "message")) {
[16:01:49.256]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:49.256]                       if (muffled) 
[16:01:49.256]                         invokeRestart("muffleMessage")
[16:01:49.256]                     }
[16:01:49.256]                     else if (inherits(cond, "warning")) {
[16:01:49.256]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:49.256]                       if (muffled) 
[16:01:49.256]                         invokeRestart("muffleWarning")
[16:01:49.256]                     }
[16:01:49.256]                     else if (inherits(cond, "condition")) {
[16:01:49.256]                       if (!is.null(pattern)) {
[16:01:49.256]                         computeRestarts <- base::computeRestarts
[16:01:49.256]                         grepl <- base::grepl
[16:01:49.256]                         restarts <- computeRestarts(cond)
[16:01:49.256]                         for (restart in restarts) {
[16:01:49.256]                           name <- restart$name
[16:01:49.256]                           if (is.null(name)) 
[16:01:49.256]                             next
[16:01:49.256]                           if (!grepl(pattern, name)) 
[16:01:49.256]                             next
[16:01:49.256]                           invokeRestart(restart)
[16:01:49.256]                           muffled <- TRUE
[16:01:49.256]                           break
[16:01:49.256]                         }
[16:01:49.256]                       }
[16:01:49.256]                     }
[16:01:49.256]                     invisible(muffled)
[16:01:49.256]                   }
[16:01:49.256]                   muffleCondition(cond)
[16:01:49.256]                 })
[16:01:49.256]             }))
[16:01:49.256]             future::FutureResult(value = ...future.value$value, 
[16:01:49.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.256]                   ...future.rng), globalenv = if (FALSE) 
[16:01:49.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:49.256]                     ...future.globalenv.names))
[16:01:49.256]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:49.256]         }, condition = base::local({
[16:01:49.256]             c <- base::c
[16:01:49.256]             inherits <- base::inherits
[16:01:49.256]             invokeRestart <- base::invokeRestart
[16:01:49.256]             length <- base::length
[16:01:49.256]             list <- base::list
[16:01:49.256]             seq.int <- base::seq.int
[16:01:49.256]             signalCondition <- base::signalCondition
[16:01:49.256]             sys.calls <- base::sys.calls
[16:01:49.256]             `[[` <- base::`[[`
[16:01:49.256]             `+` <- base::`+`
[16:01:49.256]             `<<-` <- base::`<<-`
[16:01:49.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:49.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:49.256]                   3L)]
[16:01:49.256]             }
[16:01:49.256]             function(cond) {
[16:01:49.256]                 is_error <- inherits(cond, "error")
[16:01:49.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:49.256]                   NULL)
[16:01:49.256]                 if (is_error) {
[16:01:49.256]                   sessionInformation <- function() {
[16:01:49.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:49.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:49.256]                       search = base::search(), system = base::Sys.info())
[16:01:49.256]                   }
[16:01:49.256]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:49.256]                     cond$call), session = sessionInformation(), 
[16:01:49.256]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:49.256]                   signalCondition(cond)
[16:01:49.256]                 }
[16:01:49.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:49.256]                 "immediateCondition"))) {
[16:01:49.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:49.256]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:49.256]                   if (TRUE && !signal) {
[16:01:49.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.256]                     {
[16:01:49.256]                       inherits <- base::inherits
[16:01:49.256]                       invokeRestart <- base::invokeRestart
[16:01:49.256]                       is.null <- base::is.null
[16:01:49.256]                       muffled <- FALSE
[16:01:49.256]                       if (inherits(cond, "message")) {
[16:01:49.256]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.256]                         if (muffled) 
[16:01:49.256]                           invokeRestart("muffleMessage")
[16:01:49.256]                       }
[16:01:49.256]                       else if (inherits(cond, "warning")) {
[16:01:49.256]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.256]                         if (muffled) 
[16:01:49.256]                           invokeRestart("muffleWarning")
[16:01:49.256]                       }
[16:01:49.256]                       else if (inherits(cond, "condition")) {
[16:01:49.256]                         if (!is.null(pattern)) {
[16:01:49.256]                           computeRestarts <- base::computeRestarts
[16:01:49.256]                           grepl <- base::grepl
[16:01:49.256]                           restarts <- computeRestarts(cond)
[16:01:49.256]                           for (restart in restarts) {
[16:01:49.256]                             name <- restart$name
[16:01:49.256]                             if (is.null(name)) 
[16:01:49.256]                               next
[16:01:49.256]                             if (!grepl(pattern, name)) 
[16:01:49.256]                               next
[16:01:49.256]                             invokeRestart(restart)
[16:01:49.256]                             muffled <- TRUE
[16:01:49.256]                             break
[16:01:49.256]                           }
[16:01:49.256]                         }
[16:01:49.256]                       }
[16:01:49.256]                       invisible(muffled)
[16:01:49.256]                     }
[16:01:49.256]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.256]                   }
[16:01:49.256]                 }
[16:01:49.256]                 else {
[16:01:49.256]                   if (TRUE) {
[16:01:49.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.256]                     {
[16:01:49.256]                       inherits <- base::inherits
[16:01:49.256]                       invokeRestart <- base::invokeRestart
[16:01:49.256]                       is.null <- base::is.null
[16:01:49.256]                       muffled <- FALSE
[16:01:49.256]                       if (inherits(cond, "message")) {
[16:01:49.256]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.256]                         if (muffled) 
[16:01:49.256]                           invokeRestart("muffleMessage")
[16:01:49.256]                       }
[16:01:49.256]                       else if (inherits(cond, "warning")) {
[16:01:49.256]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.256]                         if (muffled) 
[16:01:49.256]                           invokeRestart("muffleWarning")
[16:01:49.256]                       }
[16:01:49.256]                       else if (inherits(cond, "condition")) {
[16:01:49.256]                         if (!is.null(pattern)) {
[16:01:49.256]                           computeRestarts <- base::computeRestarts
[16:01:49.256]                           grepl <- base::grepl
[16:01:49.256]                           restarts <- computeRestarts(cond)
[16:01:49.256]                           for (restart in restarts) {
[16:01:49.256]                             name <- restart$name
[16:01:49.256]                             if (is.null(name)) 
[16:01:49.256]                               next
[16:01:49.256]                             if (!grepl(pattern, name)) 
[16:01:49.256]                               next
[16:01:49.256]                             invokeRestart(restart)
[16:01:49.256]                             muffled <- TRUE
[16:01:49.256]                             break
[16:01:49.256]                           }
[16:01:49.256]                         }
[16:01:49.256]                       }
[16:01:49.256]                       invisible(muffled)
[16:01:49.256]                     }
[16:01:49.256]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.256]                   }
[16:01:49.256]                 }
[16:01:49.256]             }
[16:01:49.256]         }))
[16:01:49.256]     }, error = function(ex) {
[16:01:49.256]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:49.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.256]                 ...future.rng), started = ...future.startTime, 
[16:01:49.256]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:49.256]             version = "1.8"), class = "FutureResult")
[16:01:49.256]     }, finally = {
[16:01:49.256]         if (!identical(...future.workdir, getwd())) 
[16:01:49.256]             setwd(...future.workdir)
[16:01:49.256]         {
[16:01:49.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:49.256]                 ...future.oldOptions$nwarnings <- NULL
[16:01:49.256]             }
[16:01:49.256]             base::options(...future.oldOptions)
[16:01:49.256]             if (.Platform$OS.type == "windows") {
[16:01:49.256]                 old_names <- names(...future.oldEnvVars)
[16:01:49.256]                 envs <- base::Sys.getenv()
[16:01:49.256]                 names <- names(envs)
[16:01:49.256]                 common <- intersect(names, old_names)
[16:01:49.256]                 added <- setdiff(names, old_names)
[16:01:49.256]                 removed <- setdiff(old_names, names)
[16:01:49.256]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:49.256]                   envs[common]]
[16:01:49.256]                 NAMES <- toupper(changed)
[16:01:49.256]                 args <- list()
[16:01:49.256]                 for (kk in seq_along(NAMES)) {
[16:01:49.256]                   name <- changed[[kk]]
[16:01:49.256]                   NAME <- NAMES[[kk]]
[16:01:49.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.256]                     next
[16:01:49.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.256]                 }
[16:01:49.256]                 NAMES <- toupper(added)
[16:01:49.256]                 for (kk in seq_along(NAMES)) {
[16:01:49.256]                   name <- added[[kk]]
[16:01:49.256]                   NAME <- NAMES[[kk]]
[16:01:49.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.256]                     next
[16:01:49.256]                   args[[name]] <- ""
[16:01:49.256]                 }
[16:01:49.256]                 NAMES <- toupper(removed)
[16:01:49.256]                 for (kk in seq_along(NAMES)) {
[16:01:49.256]                   name <- removed[[kk]]
[16:01:49.256]                   NAME <- NAMES[[kk]]
[16:01:49.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.256]                     next
[16:01:49.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.256]                 }
[16:01:49.256]                 if (length(args) > 0) 
[16:01:49.256]                   base::do.call(base::Sys.setenv, args = args)
[16:01:49.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:49.256]             }
[16:01:49.256]             else {
[16:01:49.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:49.256]             }
[16:01:49.256]             {
[16:01:49.256]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:49.256]                   0L) {
[16:01:49.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:49.256]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:49.256]                   base::options(opts)
[16:01:49.256]                 }
[16:01:49.256]                 {
[16:01:49.256]                   {
[16:01:49.256]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:49.256]                     NULL
[16:01:49.256]                   }
[16:01:49.256]                   options(future.plan = NULL)
[16:01:49.256]                   if (is.na(NA_character_)) 
[16:01:49.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:49.256]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:49.256]                     envir = parent.frame()) 
[16:01:49.256]                   {
[16:01:49.256]                     default_workers <- missing(workers)
[16:01:49.256]                     if (is.function(workers)) 
[16:01:49.256]                       workers <- workers()
[16:01:49.256]                     workers <- structure(as.integer(workers), 
[16:01:49.256]                       class = class(workers))
[16:01:49.256]                     stop_if_not(is.finite(workers), workers >= 
[16:01:49.256]                       1L)
[16:01:49.256]                     if ((workers == 1L && !inherits(workers, 
[16:01:49.256]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:49.256]                       if (default_workers) 
[16:01:49.256]                         supportsMulticore(warn = TRUE)
[16:01:49.256]                       return(sequential(..., envir = envir))
[16:01:49.256]                     }
[16:01:49.256]                     oopts <- options(mc.cores = workers)
[16:01:49.256]                     on.exit(options(oopts))
[16:01:49.256]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:49.256]                       envir = envir)
[16:01:49.256]                     if (!future$lazy) 
[16:01:49.256]                       future <- run(future)
[16:01:49.256]                     invisible(future)
[16:01:49.256]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:49.256]                 }
[16:01:49.256]             }
[16:01:49.256]         }
[16:01:49.256]     })
[16:01:49.256]     if (TRUE) {
[16:01:49.256]         base::sink(type = "output", split = FALSE)
[16:01:49.256]         if (TRUE) {
[16:01:49.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:49.256]         }
[16:01:49.256]         else {
[16:01:49.256]             ...future.result["stdout"] <- base::list(NULL)
[16:01:49.256]         }
[16:01:49.256]         base::close(...future.stdout)
[16:01:49.256]         ...future.stdout <- NULL
[16:01:49.256]     }
[16:01:49.256]     ...future.result$conditions <- ...future.conditions
[16:01:49.256]     ...future.result$finished <- base::Sys.time()
[16:01:49.256]     ...future.result
[16:01:49.256] }
[16:01:49.259] assign_globals() ...
[16:01:49.259] List of 5
[16:01:49.259]  $ ...future.FUN            :function (x, ...)  
[16:01:49.259]  $ future.call.arguments    : list()
[16:01:49.259]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.259]  $ ...future.elements_ii    :List of 1
[16:01:49.259]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:01:49.259]  $ ...future.seeds_ii       : NULL
[16:01:49.259]  $ ...future.globals.maxSize: NULL
[16:01:49.259]  - attr(*, "where")=List of 5
[16:01:49.259]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:49.259]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:49.259]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:49.259]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:49.259]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:49.259]  - attr(*, "resolved")= logi FALSE
[16:01:49.259]  - attr(*, "total_size")= num 1248
[16:01:49.259]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.259]  - attr(*, "already-done")= logi TRUE
[16:01:49.264] - copied ‘...future.FUN’ to environment
[16:01:49.264] - copied ‘future.call.arguments’ to environment
[16:01:49.264] - copied ‘...future.elements_ii’ to environment
[16:01:49.264] - copied ‘...future.seeds_ii’ to environment
[16:01:49.264] - copied ‘...future.globals.maxSize’ to environment
[16:01:49.264] assign_globals() ... done
[16:01:49.264] requestCore(): workers = 2
[16:01:49.266] MulticoreFuture started
[16:01:49.267] - Launch lazy future ... done
[16:01:49.267] run() for ‘MulticoreFuture’ ... done
[16:01:49.267] Created future:
[16:01:49.268] plan(): Setting new future strategy stack:
[16:01:49.268] List of future strategies:
[16:01:49.268] 1. sequential:
[16:01:49.268]    - args: function (..., envir = parent.frame())
[16:01:49.268]    - tweaked: FALSE
[16:01:49.268]    - call: NULL
[16:01:49.272] plan(): nbrOfWorkers() = 1
[16:01:49.275] plan(): Setting new future strategy stack:
[16:01:49.275] List of future strategies:
[16:01:49.275] 1. multicore:
[16:01:49.275]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:49.275]    - tweaked: FALSE
[16:01:49.275]    - call: plan(strategy)
[16:01:49.281] plan(): nbrOfWorkers() = 2
[16:01:49.268] MulticoreFuture:
[16:01:49.268] Label: ‘future_eapply-1’
[16:01:49.268] Expression:
[16:01:49.268] {
[16:01:49.268]     do.call(function(...) {
[16:01:49.268]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.268]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.268]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.268]             on.exit(options(oopts), add = TRUE)
[16:01:49.268]         }
[16:01:49.268]         {
[16:01:49.268]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.268]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.268]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.268]             })
[16:01:49.268]         }
[16:01:49.268]     }, args = future.call.arguments)
[16:01:49.268] }
[16:01:49.268] Lazy evaluation: FALSE
[16:01:49.268] Asynchronous evaluation: TRUE
[16:01:49.268] Local evaluation: TRUE
[16:01:49.268] Environment: R_GlobalEnv
[16:01:49.268] Capture standard output: TRUE
[16:01:49.268] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:49.268] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:49.268] Packages: 1 packages (‘stats’)
[16:01:49.268] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:49.268] Resolved: TRUE
[16:01:49.268] Value: <not collected>
[16:01:49.268] Conditions captured: <none>
[16:01:49.268] Early signaling: FALSE
[16:01:49.268] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:49.268] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.282] Chunk #1 of 2 ... DONE
[16:01:49.282] Chunk #2 of 2 ...
[16:01:49.282]  - Finding globals in 'X' for chunk #2 ...
[16:01:49.283] getGlobalsAndPackages() ...
[16:01:49.283] Searching for globals...
[16:01:49.283] 
[16:01:49.284] Searching for globals ... DONE
[16:01:49.284] - globals: [0] <none>
[16:01:49.284] getGlobalsAndPackages() ... DONE
[16:01:49.284]    + additional globals found: [n=0] 
[16:01:49.284]    + additional namespaces needed: [n=0] 
[16:01:49.284]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:49.284]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:49.285]  - seeds: <none>
[16:01:49.285]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.285] getGlobalsAndPackages() ...
[16:01:49.285] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.285] Resolving globals: FALSE
[16:01:49.285] Tweak future expression to call with '...' arguments ...
[16:01:49.286] {
[16:01:49.286]     do.call(function(...) {
[16:01:49.286]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.286]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.286]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.286]             on.exit(options(oopts), add = TRUE)
[16:01:49.286]         }
[16:01:49.286]         {
[16:01:49.286]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.286]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.286]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.286]             })
[16:01:49.286]         }
[16:01:49.286]     }, args = future.call.arguments)
[16:01:49.286] }
[16:01:49.286] Tweak future expression to call with '...' arguments ... DONE
[16:01:49.287] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.287] - packages: [1] ‘stats’
[16:01:49.287] getGlobalsAndPackages() ... DONE
[16:01:49.288] run() for ‘Future’ ...
[16:01:49.288] - state: ‘created’
[16:01:49.288] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:49.293] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:49.293]   - Field: ‘label’
[16:01:49.293]   - Field: ‘local’
[16:01:49.294]   - Field: ‘owner’
[16:01:49.294]   - Field: ‘envir’
[16:01:49.294]   - Field: ‘workers’
[16:01:49.294]   - Field: ‘packages’
[16:01:49.294]   - Field: ‘gc’
[16:01:49.294]   - Field: ‘job’
[16:01:49.294]   - Field: ‘conditions’
[16:01:49.295]   - Field: ‘expr’
[16:01:49.295]   - Field: ‘uuid’
[16:01:49.295]   - Field: ‘seed’
[16:01:49.295]   - Field: ‘version’
[16:01:49.295]   - Field: ‘result’
[16:01:49.295]   - Field: ‘asynchronous’
[16:01:49.296]   - Field: ‘calls’
[16:01:49.296]   - Field: ‘globals’
[16:01:49.296]   - Field: ‘stdout’
[16:01:49.296]   - Field: ‘earlySignal’
[16:01:49.296]   - Field: ‘lazy’
[16:01:49.296]   - Field: ‘state’
[16:01:49.296] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:49.297] - Launch lazy future ...
[16:01:49.297] Packages needed by the future expression (n = 1): ‘stats’
[16:01:49.297] Packages needed by future strategies (n = 0): <none>
[16:01:49.298] {
[16:01:49.298]     {
[16:01:49.298]         {
[16:01:49.298]             ...future.startTime <- base::Sys.time()
[16:01:49.298]             {
[16:01:49.298]                 {
[16:01:49.298]                   {
[16:01:49.298]                     {
[16:01:49.298]                       {
[16:01:49.298]                         base::local({
[16:01:49.298]                           has_future <- base::requireNamespace("future", 
[16:01:49.298]                             quietly = TRUE)
[16:01:49.298]                           if (has_future) {
[16:01:49.298]                             ns <- base::getNamespace("future")
[16:01:49.298]                             version <- ns[[".package"]][["version"]]
[16:01:49.298]                             if (is.null(version)) 
[16:01:49.298]                               version <- utils::packageVersion("future")
[16:01:49.298]                           }
[16:01:49.298]                           else {
[16:01:49.298]                             version <- NULL
[16:01:49.298]                           }
[16:01:49.298]                           if (!has_future || version < "1.8.0") {
[16:01:49.298]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:49.298]                               "", base::R.version$version.string), 
[16:01:49.298]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:49.298]                                 base::R.version$platform, 8 * 
[16:01:49.298]                                   base::.Machine$sizeof.pointer), 
[16:01:49.298]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:49.298]                                 "release", "version")], collapse = " "), 
[16:01:49.298]                               hostname = base::Sys.info()[["nodename"]])
[16:01:49.298]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:49.298]                               info)
[16:01:49.298]                             info <- base::paste(info, collapse = "; ")
[16:01:49.298]                             if (!has_future) {
[16:01:49.298]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:49.298]                                 info)
[16:01:49.298]                             }
[16:01:49.298]                             else {
[16:01:49.298]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:49.298]                                 info, version)
[16:01:49.298]                             }
[16:01:49.298]                             base::stop(msg)
[16:01:49.298]                           }
[16:01:49.298]                         })
[16:01:49.298]                       }
[16:01:49.298]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:49.298]                       base::options(mc.cores = 1L)
[16:01:49.298]                     }
[16:01:49.298]                     base::local({
[16:01:49.298]                       for (pkg in "stats") {
[16:01:49.298]                         base::loadNamespace(pkg)
[16:01:49.298]                         base::library(pkg, character.only = TRUE)
[16:01:49.298]                       }
[16:01:49.298]                     })
[16:01:49.298]                   }
[16:01:49.298]                   options(future.plan = NULL)
[16:01:49.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:49.298]                 }
[16:01:49.298]                 ...future.workdir <- getwd()
[16:01:49.298]             }
[16:01:49.298]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:49.298]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:49.298]         }
[16:01:49.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:49.298]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:49.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:49.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:49.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:49.298]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:49.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:49.298]             base::names(...future.oldOptions))
[16:01:49.298]     }
[16:01:49.298]     if (FALSE) {
[16:01:49.298]     }
[16:01:49.298]     else {
[16:01:49.298]         if (TRUE) {
[16:01:49.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:49.298]                 open = "w")
[16:01:49.298]         }
[16:01:49.298]         else {
[16:01:49.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:49.298]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:49.298]         }
[16:01:49.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:49.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:49.298]             base::sink(type = "output", split = FALSE)
[16:01:49.298]             base::close(...future.stdout)
[16:01:49.298]         }, add = TRUE)
[16:01:49.298]     }
[16:01:49.298]     ...future.frame <- base::sys.nframe()
[16:01:49.298]     ...future.conditions <- base::list()
[16:01:49.298]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:49.298]     if (FALSE) {
[16:01:49.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:49.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:49.298]     }
[16:01:49.298]     ...future.result <- base::tryCatch({
[16:01:49.298]         base::withCallingHandlers({
[16:01:49.298]             ...future.value <- base::withVisible(base::local({
[16:01:49.298]                 withCallingHandlers({
[16:01:49.298]                   {
[16:01:49.298]                     do.call(function(...) {
[16:01:49.298]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.298]                       if (!identical(...future.globals.maxSize.org, 
[16:01:49.298]                         ...future.globals.maxSize)) {
[16:01:49.298]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.298]                         on.exit(options(oopts), add = TRUE)
[16:01:49.298]                       }
[16:01:49.298]                       {
[16:01:49.298]                         lapply(seq_along(...future.elements_ii), 
[16:01:49.298]                           FUN = function(jj) {
[16:01:49.298]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.298]                             ...future.FUN(...future.X_jj, ...)
[16:01:49.298]                           })
[16:01:49.298]                       }
[16:01:49.298]                     }, args = future.call.arguments)
[16:01:49.298]                   }
[16:01:49.298]                 }, immediateCondition = function(cond) {
[16:01:49.298]                   save_rds <- function (object, pathname, ...) 
[16:01:49.298]                   {
[16:01:49.298]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:49.298]                     if (file_test("-f", pathname_tmp)) {
[16:01:49.298]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.298]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:49.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.298]                         fi_tmp[["mtime"]])
[16:01:49.298]                     }
[16:01:49.298]                     tryCatch({
[16:01:49.298]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:49.298]                     }, error = function(ex) {
[16:01:49.298]                       msg <- conditionMessage(ex)
[16:01:49.298]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.298]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:49.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.298]                         fi_tmp[["mtime"]], msg)
[16:01:49.298]                       ex$message <- msg
[16:01:49.298]                       stop(ex)
[16:01:49.298]                     })
[16:01:49.298]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:49.298]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:49.298]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:49.298]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.298]                       fi <- file.info(pathname)
[16:01:49.298]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:49.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.298]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:49.298]                         fi[["size"]], fi[["mtime"]])
[16:01:49.298]                       stop(msg)
[16:01:49.298]                     }
[16:01:49.298]                     invisible(pathname)
[16:01:49.298]                   }
[16:01:49.298]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:49.298]                     rootPath = tempdir()) 
[16:01:49.298]                   {
[16:01:49.298]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:49.298]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:49.298]                       tmpdir = path, fileext = ".rds")
[16:01:49.298]                     save_rds(obj, file)
[16:01:49.298]                   }
[16:01:49.298]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4bFpDe/.future/immediateConditions")
[16:01:49.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.298]                   {
[16:01:49.298]                     inherits <- base::inherits
[16:01:49.298]                     invokeRestart <- base::invokeRestart
[16:01:49.298]                     is.null <- base::is.null
[16:01:49.298]                     muffled <- FALSE
[16:01:49.298]                     if (inherits(cond, "message")) {
[16:01:49.298]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:49.298]                       if (muffled) 
[16:01:49.298]                         invokeRestart("muffleMessage")
[16:01:49.298]                     }
[16:01:49.298]                     else if (inherits(cond, "warning")) {
[16:01:49.298]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:49.298]                       if (muffled) 
[16:01:49.298]                         invokeRestart("muffleWarning")
[16:01:49.298]                     }
[16:01:49.298]                     else if (inherits(cond, "condition")) {
[16:01:49.298]                       if (!is.null(pattern)) {
[16:01:49.298]                         computeRestarts <- base::computeRestarts
[16:01:49.298]                         grepl <- base::grepl
[16:01:49.298]                         restarts <- computeRestarts(cond)
[16:01:49.298]                         for (restart in restarts) {
[16:01:49.298]                           name <- restart$name
[16:01:49.298]                           if (is.null(name)) 
[16:01:49.298]                             next
[16:01:49.298]                           if (!grepl(pattern, name)) 
[16:01:49.298]                             next
[16:01:49.298]                           invokeRestart(restart)
[16:01:49.298]                           muffled <- TRUE
[16:01:49.298]                           break
[16:01:49.298]                         }
[16:01:49.298]                       }
[16:01:49.298]                     }
[16:01:49.298]                     invisible(muffled)
[16:01:49.298]                   }
[16:01:49.298]                   muffleCondition(cond)
[16:01:49.298]                 })
[16:01:49.298]             }))
[16:01:49.298]             future::FutureResult(value = ...future.value$value, 
[16:01:49.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.298]                   ...future.rng), globalenv = if (FALSE) 
[16:01:49.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:49.298]                     ...future.globalenv.names))
[16:01:49.298]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:49.298]         }, condition = base::local({
[16:01:49.298]             c <- base::c
[16:01:49.298]             inherits <- base::inherits
[16:01:49.298]             invokeRestart <- base::invokeRestart
[16:01:49.298]             length <- base::length
[16:01:49.298]             list <- base::list
[16:01:49.298]             seq.int <- base::seq.int
[16:01:49.298]             signalCondition <- base::signalCondition
[16:01:49.298]             sys.calls <- base::sys.calls
[16:01:49.298]             `[[` <- base::`[[`
[16:01:49.298]             `+` <- base::`+`
[16:01:49.298]             `<<-` <- base::`<<-`
[16:01:49.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:49.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:49.298]                   3L)]
[16:01:49.298]             }
[16:01:49.298]             function(cond) {
[16:01:49.298]                 is_error <- inherits(cond, "error")
[16:01:49.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:49.298]                   NULL)
[16:01:49.298]                 if (is_error) {
[16:01:49.298]                   sessionInformation <- function() {
[16:01:49.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:49.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:49.298]                       search = base::search(), system = base::Sys.info())
[16:01:49.298]                   }
[16:01:49.298]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:49.298]                     cond$call), session = sessionInformation(), 
[16:01:49.298]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:49.298]                   signalCondition(cond)
[16:01:49.298]                 }
[16:01:49.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:49.298]                 "immediateCondition"))) {
[16:01:49.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:49.298]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:49.298]                   if (TRUE && !signal) {
[16:01:49.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.298]                     {
[16:01:49.298]                       inherits <- base::inherits
[16:01:49.298]                       invokeRestart <- base::invokeRestart
[16:01:49.298]                       is.null <- base::is.null
[16:01:49.298]                       muffled <- FALSE
[16:01:49.298]                       if (inherits(cond, "message")) {
[16:01:49.298]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.298]                         if (muffled) 
[16:01:49.298]                           invokeRestart("muffleMessage")
[16:01:49.298]                       }
[16:01:49.298]                       else if (inherits(cond, "warning")) {
[16:01:49.298]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.298]                         if (muffled) 
[16:01:49.298]                           invokeRestart("muffleWarning")
[16:01:49.298]                       }
[16:01:49.298]                       else if (inherits(cond, "condition")) {
[16:01:49.298]                         if (!is.null(pattern)) {
[16:01:49.298]                           computeRestarts <- base::computeRestarts
[16:01:49.298]                           grepl <- base::grepl
[16:01:49.298]                           restarts <- computeRestarts(cond)
[16:01:49.298]                           for (restart in restarts) {
[16:01:49.298]                             name <- restart$name
[16:01:49.298]                             if (is.null(name)) 
[16:01:49.298]                               next
[16:01:49.298]                             if (!grepl(pattern, name)) 
[16:01:49.298]                               next
[16:01:49.298]                             invokeRestart(restart)
[16:01:49.298]                             muffled <- TRUE
[16:01:49.298]                             break
[16:01:49.298]                           }
[16:01:49.298]                         }
[16:01:49.298]                       }
[16:01:49.298]                       invisible(muffled)
[16:01:49.298]                     }
[16:01:49.298]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.298]                   }
[16:01:49.298]                 }
[16:01:49.298]                 else {
[16:01:49.298]                   if (TRUE) {
[16:01:49.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.298]                     {
[16:01:49.298]                       inherits <- base::inherits
[16:01:49.298]                       invokeRestart <- base::invokeRestart
[16:01:49.298]                       is.null <- base::is.null
[16:01:49.298]                       muffled <- FALSE
[16:01:49.298]                       if (inherits(cond, "message")) {
[16:01:49.298]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.298]                         if (muffled) 
[16:01:49.298]                           invokeRestart("muffleMessage")
[16:01:49.298]                       }
[16:01:49.298]                       else if (inherits(cond, "warning")) {
[16:01:49.298]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.298]                         if (muffled) 
[16:01:49.298]                           invokeRestart("muffleWarning")
[16:01:49.298]                       }
[16:01:49.298]                       else if (inherits(cond, "condition")) {
[16:01:49.298]                         if (!is.null(pattern)) {
[16:01:49.298]                           computeRestarts <- base::computeRestarts
[16:01:49.298]                           grepl <- base::grepl
[16:01:49.298]                           restarts <- computeRestarts(cond)
[16:01:49.298]                           for (restart in restarts) {
[16:01:49.298]                             name <- restart$name
[16:01:49.298]                             if (is.null(name)) 
[16:01:49.298]                               next
[16:01:49.298]                             if (!grepl(pattern, name)) 
[16:01:49.298]                               next
[16:01:49.298]                             invokeRestart(restart)
[16:01:49.298]                             muffled <- TRUE
[16:01:49.298]                             break
[16:01:49.298]                           }
[16:01:49.298]                         }
[16:01:49.298]                       }
[16:01:49.298]                       invisible(muffled)
[16:01:49.298]                     }
[16:01:49.298]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.298]                   }
[16:01:49.298]                 }
[16:01:49.298]             }
[16:01:49.298]         }))
[16:01:49.298]     }, error = function(ex) {
[16:01:49.298]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:49.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.298]                 ...future.rng), started = ...future.startTime, 
[16:01:49.298]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:49.298]             version = "1.8"), class = "FutureResult")
[16:01:49.298]     }, finally = {
[16:01:49.298]         if (!identical(...future.workdir, getwd())) 
[16:01:49.298]             setwd(...future.workdir)
[16:01:49.298]         {
[16:01:49.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:49.298]                 ...future.oldOptions$nwarnings <- NULL
[16:01:49.298]             }
[16:01:49.298]             base::options(...future.oldOptions)
[16:01:49.298]             if (.Platform$OS.type == "windows") {
[16:01:49.298]                 old_names <- names(...future.oldEnvVars)
[16:01:49.298]                 envs <- base::Sys.getenv()
[16:01:49.298]                 names <- names(envs)
[16:01:49.298]                 common <- intersect(names, old_names)
[16:01:49.298]                 added <- setdiff(names, old_names)
[16:01:49.298]                 removed <- setdiff(old_names, names)
[16:01:49.298]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:49.298]                   envs[common]]
[16:01:49.298]                 NAMES <- toupper(changed)
[16:01:49.298]                 args <- list()
[16:01:49.298]                 for (kk in seq_along(NAMES)) {
[16:01:49.298]                   name <- changed[[kk]]
[16:01:49.298]                   NAME <- NAMES[[kk]]
[16:01:49.298]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.298]                     next
[16:01:49.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.298]                 }
[16:01:49.298]                 NAMES <- toupper(added)
[16:01:49.298]                 for (kk in seq_along(NAMES)) {
[16:01:49.298]                   name <- added[[kk]]
[16:01:49.298]                   NAME <- NAMES[[kk]]
[16:01:49.298]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.298]                     next
[16:01:49.298]                   args[[name]] <- ""
[16:01:49.298]                 }
[16:01:49.298]                 NAMES <- toupper(removed)
[16:01:49.298]                 for (kk in seq_along(NAMES)) {
[16:01:49.298]                   name <- removed[[kk]]
[16:01:49.298]                   NAME <- NAMES[[kk]]
[16:01:49.298]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.298]                     next
[16:01:49.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.298]                 }
[16:01:49.298]                 if (length(args) > 0) 
[16:01:49.298]                   base::do.call(base::Sys.setenv, args = args)
[16:01:49.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:49.298]             }
[16:01:49.298]             else {
[16:01:49.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:49.298]             }
[16:01:49.298]             {
[16:01:49.298]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:49.298]                   0L) {
[16:01:49.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:49.298]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:49.298]                   base::options(opts)
[16:01:49.298]                 }
[16:01:49.298]                 {
[16:01:49.298]                   {
[16:01:49.298]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:49.298]                     NULL
[16:01:49.298]                   }
[16:01:49.298]                   options(future.plan = NULL)
[16:01:49.298]                   if (is.na(NA_character_)) 
[16:01:49.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:49.298]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:49.298]                     envir = parent.frame()) 
[16:01:49.298]                   {
[16:01:49.298]                     default_workers <- missing(workers)
[16:01:49.298]                     if (is.function(workers)) 
[16:01:49.298]                       workers <- workers()
[16:01:49.298]                     workers <- structure(as.integer(workers), 
[16:01:49.298]                       class = class(workers))
[16:01:49.298]                     stop_if_not(is.finite(workers), workers >= 
[16:01:49.298]                       1L)
[16:01:49.298]                     if ((workers == 1L && !inherits(workers, 
[16:01:49.298]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:49.298]                       if (default_workers) 
[16:01:49.298]                         supportsMulticore(warn = TRUE)
[16:01:49.298]                       return(sequential(..., envir = envir))
[16:01:49.298]                     }
[16:01:49.298]                     oopts <- options(mc.cores = workers)
[16:01:49.298]                     on.exit(options(oopts))
[16:01:49.298]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:49.298]                       envir = envir)
[16:01:49.298]                     if (!future$lazy) 
[16:01:49.298]                       future <- run(future)
[16:01:49.298]                     invisible(future)
[16:01:49.298]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:49.298]                 }
[16:01:49.298]             }
[16:01:49.298]         }
[16:01:49.298]     })
[16:01:49.298]     if (TRUE) {
[16:01:49.298]         base::sink(type = "output", split = FALSE)
[16:01:49.298]         if (TRUE) {
[16:01:49.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:49.298]         }
[16:01:49.298]         else {
[16:01:49.298]             ...future.result["stdout"] <- base::list(NULL)
[16:01:49.298]         }
[16:01:49.298]         base::close(...future.stdout)
[16:01:49.298]         ...future.stdout <- NULL
[16:01:49.298]     }
[16:01:49.298]     ...future.result$conditions <- ...future.conditions
[16:01:49.298]     ...future.result$finished <- base::Sys.time()
[16:01:49.298]     ...future.result
[16:01:49.298] }
[16:01:49.301] assign_globals() ...
[16:01:49.301] List of 5
[16:01:49.301]  $ ...future.FUN            :function (x, ...)  
[16:01:49.301]  $ future.call.arguments    : list()
[16:01:49.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.301]  $ ...future.elements_ii    :List of 2
[16:01:49.301]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:01:49.301]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:01:49.301]  $ ...future.seeds_ii       : NULL
[16:01:49.301]  $ ...future.globals.maxSize: NULL
[16:01:49.301]  - attr(*, "where")=List of 5
[16:01:49.301]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:49.301]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:49.301]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:49.301]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:49.301]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:49.301]  - attr(*, "resolved")= logi FALSE
[16:01:49.301]  - attr(*, "total_size")= num 1248
[16:01:49.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.301]  - attr(*, "already-done")= logi TRUE
[16:01:49.309] - copied ‘...future.FUN’ to environment
[16:01:49.309] - copied ‘future.call.arguments’ to environment
[16:01:49.309] - copied ‘...future.elements_ii’ to environment
[16:01:49.309] - copied ‘...future.seeds_ii’ to environment
[16:01:49.309] - copied ‘...future.globals.maxSize’ to environment
[16:01:49.309] assign_globals() ... done
[16:01:49.309] requestCore(): workers = 2
[16:01:49.312] MulticoreFuture started
[16:01:49.312] - Launch lazy future ... done
[16:01:49.312] run() for ‘MulticoreFuture’ ... done
[16:01:49.312] Created future:
[16:01:49.313] plan(): Setting new future strategy stack:
[16:01:49.313] List of future strategies:
[16:01:49.313] 1. sequential:
[16:01:49.313]    - args: function (..., envir = parent.frame())
[16:01:49.313]    - tweaked: FALSE
[16:01:49.313]    - call: NULL
[16:01:49.314] plan(): nbrOfWorkers() = 1
[16:01:49.317] plan(): Setting new future strategy stack:
[16:01:49.317] List of future strategies:
[16:01:49.317] 1. multicore:
[16:01:49.317]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:49.317]    - tweaked: FALSE
[16:01:49.317]    - call: plan(strategy)
[16:01:49.322] plan(): nbrOfWorkers() = 2
[16:01:49.313] MulticoreFuture:
[16:01:49.313] Label: ‘future_eapply-2’
[16:01:49.313] Expression:
[16:01:49.313] {
[16:01:49.313]     do.call(function(...) {
[16:01:49.313]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.313]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.313]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.313]             on.exit(options(oopts), add = TRUE)
[16:01:49.313]         }
[16:01:49.313]         {
[16:01:49.313]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.313]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.313]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.313]             })
[16:01:49.313]         }
[16:01:49.313]     }, args = future.call.arguments)
[16:01:49.313] }
[16:01:49.313] Lazy evaluation: FALSE
[16:01:49.313] Asynchronous evaluation: TRUE
[16:01:49.313] Local evaluation: TRUE
[16:01:49.313] Environment: R_GlobalEnv
[16:01:49.313] Capture standard output: TRUE
[16:01:49.313] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:49.313] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:49.313] Packages: 1 packages (‘stats’)
[16:01:49.313] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:49.313] Resolved: TRUE
[16:01:49.313] Value: <not collected>
[16:01:49.313] Conditions captured: <none>
[16:01:49.313] Early signaling: FALSE
[16:01:49.313] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:49.313] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.323] Chunk #2 of 2 ... DONE
[16:01:49.324] Launching 2 futures (chunks) ... DONE
[16:01:49.324] Resolving 2 futures (chunks) ...
[16:01:49.324] resolve() on list ...
[16:01:49.324]  recursive: 0
[16:01:49.324]  length: 2
[16:01:49.324] 
[16:01:49.325] Future #1
[16:01:49.325] result() for MulticoreFuture ...
[16:01:49.326] result() for MulticoreFuture ...
[16:01:49.326] result() for MulticoreFuture ... done
[16:01:49.326] result() for MulticoreFuture ... done
[16:01:49.326] result() for MulticoreFuture ...
[16:01:49.326] result() for MulticoreFuture ... done
[16:01:49.327] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:49.327] - nx: 2
[16:01:49.327] - relay: TRUE
[16:01:49.327] - stdout: TRUE
[16:01:49.327] - signal: TRUE
[16:01:49.327] - resignal: FALSE
[16:01:49.327] - force: TRUE
[16:01:49.327] - relayed: [n=2] FALSE, FALSE
[16:01:49.328] - queued futures: [n=2] FALSE, FALSE
[16:01:49.328]  - until=1
[16:01:49.328]  - relaying element #1
[16:01:49.328] result() for MulticoreFuture ...
[16:01:49.328] result() for MulticoreFuture ... done
[16:01:49.328] result() for MulticoreFuture ...
[16:01:49.328] result() for MulticoreFuture ... done
[16:01:49.332] result() for MulticoreFuture ...
[16:01:49.332] result() for MulticoreFuture ... done
[16:01:49.333] result() for MulticoreFuture ...
[16:01:49.333] result() for MulticoreFuture ... done
[16:01:49.333] - relayed: [n=2] TRUE, FALSE
[16:01:49.333] - queued futures: [n=2] TRUE, FALSE
[16:01:49.333] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:49.333]  length: 1 (resolved future 1)
[16:01:49.334] Future #2
[16:01:49.334] result() for MulticoreFuture ...
[16:01:49.335] result() for MulticoreFuture ...
[16:01:49.336] result() for MulticoreFuture ... done
[16:01:49.336] result() for MulticoreFuture ... done
[16:01:49.336] result() for MulticoreFuture ...
[16:01:49.336] result() for MulticoreFuture ... done
[16:01:49.336] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:49.336] - nx: 2
[16:01:49.337] - relay: TRUE
[16:01:49.337] - stdout: TRUE
[16:01:49.337] - signal: TRUE
[16:01:49.337] - resignal: FALSE
[16:01:49.337] - force: TRUE
[16:01:49.337] - relayed: [n=2] TRUE, FALSE
[16:01:49.337] - queued futures: [n=2] TRUE, FALSE
[16:01:49.337]  - until=2
[16:01:49.338]  - relaying element #2
[16:01:49.338] result() for MulticoreFuture ...
[16:01:49.338] result() for MulticoreFuture ... done
[16:01:49.338] result() for MulticoreFuture ...
[16:01:49.338] result() for MulticoreFuture ... done
[16:01:49.338] result() for MulticoreFuture ...
[16:01:49.338] result() for MulticoreFuture ... done
[16:01:49.339] result() for MulticoreFuture ...
[16:01:49.339] result() for MulticoreFuture ... done
[16:01:49.339] - relayed: [n=2] TRUE, TRUE
[16:01:49.339] - queued futures: [n=2] TRUE, TRUE
[16:01:49.339] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:49.339]  length: 0 (resolved future 2)
[16:01:49.339] Relaying remaining futures
[16:01:49.339] signalConditionsASAP(NULL, pos=0) ...
[16:01:49.339] - nx: 2
[16:01:49.340] - relay: TRUE
[16:01:49.340] - stdout: TRUE
[16:01:49.340] - signal: TRUE
[16:01:49.340] - resignal: FALSE
[16:01:49.340] - force: TRUE
[16:01:49.340] - relayed: [n=2] TRUE, TRUE
[16:01:49.340] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:49.340] - relayed: [n=2] TRUE, TRUE
[16:01:49.340] - queued futures: [n=2] TRUE, TRUE
[16:01:49.341] signalConditionsASAP(NULL, pos=0) ... done
[16:01:49.341] resolve() on list ... DONE
[16:01:49.341] result() for MulticoreFuture ...
[16:01:49.341] result() for MulticoreFuture ... done
[16:01:49.341] result() for MulticoreFuture ...
[16:01:49.341] result() for MulticoreFuture ... done
[16:01:49.341] result() for MulticoreFuture ...
[16:01:49.341] result() for MulticoreFuture ... done
[16:01:49.342] result() for MulticoreFuture ...
[16:01:49.342] result() for MulticoreFuture ... done
[16:01:49.342]  - Number of value chunks collected: 2
[16:01:49.342] Resolving 2 futures (chunks) ... DONE
[16:01:49.342] Reducing values from 2 chunks ...
[16:01:49.342]  - Number of values collected after concatenation: 3
[16:01:49.342]  - Number of values expected: 3
[16:01:49.342] Reducing values from 2 chunks ... DONE
[16:01:49.343] future_lapply() ... DONE
[16:01:49.343] future_lapply() ...
[16:01:49.348] Number of chunks: 2
[16:01:49.348] getGlobalsAndPackagesXApply() ...
[16:01:49.348]  - future.globals: TRUE
[16:01:49.348] getGlobalsAndPackages() ...
[16:01:49.348] Searching for globals...
[16:01:49.350] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:49.350] Searching for globals ... DONE
[16:01:49.350] Resolving globals: FALSE
[16:01:49.350] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:49.351] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:49.351] - globals: [1] ‘FUN’
[16:01:49.351] - packages: [1] ‘stats’
[16:01:49.351] getGlobalsAndPackages() ... DONE
[16:01:49.351]  - globals found/used: [n=1] ‘FUN’
[16:01:49.352]  - needed namespaces: [n=1] ‘stats’
[16:01:49.352] Finding globals ... DONE
[16:01:49.352]  - use_args: TRUE
[16:01:49.352]  - Getting '...' globals ...
[16:01:49.352] resolve() on list ...
[16:01:49.352]  recursive: 0
[16:01:49.352]  length: 1
[16:01:49.353]  elements: ‘...’
[16:01:49.353]  length: 0 (resolved future 1)
[16:01:49.353] resolve() on list ... DONE
[16:01:49.353]    - '...' content: [n=0] 
[16:01:49.353] List of 1
[16:01:49.353]  $ ...: list()
[16:01:49.353]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.353]  - attr(*, "where")=List of 1
[16:01:49.353]   ..$ ...:<environment: 0x56209f8a73d8> 
[16:01:49.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.353]  - attr(*, "resolved")= logi TRUE
[16:01:49.353]  - attr(*, "total_size")= num NA
[16:01:49.356]  - Getting '...' globals ... DONE
[16:01:49.356] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:49.356] List of 2
[16:01:49.356]  $ ...future.FUN:function (x, ...)  
[16:01:49.356]  $ ...          : list()
[16:01:49.356]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.356]  - attr(*, "where")=List of 2
[16:01:49.356]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:49.356]   ..$ ...          :<environment: 0x56209f8a73d8> 
[16:01:49.356]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.356]  - attr(*, "resolved")= logi FALSE
[16:01:49.356]  - attr(*, "total_size")= num 1248
[16:01:49.359] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:49.359] getGlobalsAndPackagesXApply() ... DONE
[16:01:49.359] Number of futures (= number of chunks): 2
[16:01:49.359] Launching 2 futures (chunks) ...
[16:01:49.360] Chunk #1 of 2 ...
[16:01:49.360]  - Finding globals in 'X' for chunk #1 ...
[16:01:49.360] getGlobalsAndPackages() ...
[16:01:49.362] Searching for globals...
[16:01:49.362] 
[16:01:49.362] Searching for globals ... DONE
[16:01:49.362] - globals: [0] <none>
[16:01:49.362] getGlobalsAndPackages() ... DONE
[16:01:49.362]    + additional globals found: [n=0] 
[16:01:49.363]    + additional namespaces needed: [n=0] 
[16:01:49.363]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:49.363]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:49.363]  - seeds: <none>
[16:01:49.363]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.363] getGlobalsAndPackages() ...
[16:01:49.363] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.363] Resolving globals: FALSE
[16:01:49.363] Tweak future expression to call with '...' arguments ...
[16:01:49.364] {
[16:01:49.364]     do.call(function(...) {
[16:01:49.364]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.364]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.364]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.364]             on.exit(options(oopts), add = TRUE)
[16:01:49.364]         }
[16:01:49.364]         {
[16:01:49.364]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.364]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.364]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.364]             })
[16:01:49.364]         }
[16:01:49.364]     }, args = future.call.arguments)
[16:01:49.364] }
[16:01:49.364] Tweak future expression to call with '...' arguments ... DONE
[16:01:49.364] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.364] - packages: [1] ‘stats’
[16:01:49.364] getGlobalsAndPackages() ... DONE
[16:01:49.365] run() for ‘Future’ ...
[16:01:49.365] - state: ‘created’
[16:01:49.365] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:49.369] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:49.369]   - Field: ‘label’
[16:01:49.370]   - Field: ‘local’
[16:01:49.370]   - Field: ‘owner’
[16:01:49.370]   - Field: ‘envir’
[16:01:49.370]   - Field: ‘workers’
[16:01:49.370]   - Field: ‘packages’
[16:01:49.370]   - Field: ‘gc’
[16:01:49.370]   - Field: ‘job’
[16:01:49.370]   - Field: ‘conditions’
[16:01:49.370]   - Field: ‘expr’
[16:01:49.371]   - Field: ‘uuid’
[16:01:49.371]   - Field: ‘seed’
[16:01:49.371]   - Field: ‘version’
[16:01:49.371]   - Field: ‘result’
[16:01:49.371]   - Field: ‘asynchronous’
[16:01:49.371]   - Field: ‘calls’
[16:01:49.371]   - Field: ‘globals’
[16:01:49.371]   - Field: ‘stdout’
[16:01:49.371]   - Field: ‘earlySignal’
[16:01:49.371]   - Field: ‘lazy’
[16:01:49.372]   - Field: ‘state’
[16:01:49.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:49.372] - Launch lazy future ...
[16:01:49.372] Packages needed by the future expression (n = 1): ‘stats’
[16:01:49.372] Packages needed by future strategies (n = 0): <none>
[16:01:49.373] {
[16:01:49.373]     {
[16:01:49.373]         {
[16:01:49.373]             ...future.startTime <- base::Sys.time()
[16:01:49.373]             {
[16:01:49.373]                 {
[16:01:49.373]                   {
[16:01:49.373]                     {
[16:01:49.373]                       {
[16:01:49.373]                         base::local({
[16:01:49.373]                           has_future <- base::requireNamespace("future", 
[16:01:49.373]                             quietly = TRUE)
[16:01:49.373]                           if (has_future) {
[16:01:49.373]                             ns <- base::getNamespace("future")
[16:01:49.373]                             version <- ns[[".package"]][["version"]]
[16:01:49.373]                             if (is.null(version)) 
[16:01:49.373]                               version <- utils::packageVersion("future")
[16:01:49.373]                           }
[16:01:49.373]                           else {
[16:01:49.373]                             version <- NULL
[16:01:49.373]                           }
[16:01:49.373]                           if (!has_future || version < "1.8.0") {
[16:01:49.373]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:49.373]                               "", base::R.version$version.string), 
[16:01:49.373]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:49.373]                                 base::R.version$platform, 8 * 
[16:01:49.373]                                   base::.Machine$sizeof.pointer), 
[16:01:49.373]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:49.373]                                 "release", "version")], collapse = " "), 
[16:01:49.373]                               hostname = base::Sys.info()[["nodename"]])
[16:01:49.373]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:49.373]                               info)
[16:01:49.373]                             info <- base::paste(info, collapse = "; ")
[16:01:49.373]                             if (!has_future) {
[16:01:49.373]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:49.373]                                 info)
[16:01:49.373]                             }
[16:01:49.373]                             else {
[16:01:49.373]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:49.373]                                 info, version)
[16:01:49.373]                             }
[16:01:49.373]                             base::stop(msg)
[16:01:49.373]                           }
[16:01:49.373]                         })
[16:01:49.373]                       }
[16:01:49.373]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:49.373]                       base::options(mc.cores = 1L)
[16:01:49.373]                     }
[16:01:49.373]                     base::local({
[16:01:49.373]                       for (pkg in "stats") {
[16:01:49.373]                         base::loadNamespace(pkg)
[16:01:49.373]                         base::library(pkg, character.only = TRUE)
[16:01:49.373]                       }
[16:01:49.373]                     })
[16:01:49.373]                   }
[16:01:49.373]                   options(future.plan = NULL)
[16:01:49.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:49.373]                 }
[16:01:49.373]                 ...future.workdir <- getwd()
[16:01:49.373]             }
[16:01:49.373]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:49.373]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:49.373]         }
[16:01:49.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:49.373]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:49.373]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:49.373]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:49.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:49.373]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:49.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:49.373]             base::names(...future.oldOptions))
[16:01:49.373]     }
[16:01:49.373]     if (FALSE) {
[16:01:49.373]     }
[16:01:49.373]     else {
[16:01:49.373]         if (TRUE) {
[16:01:49.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:49.373]                 open = "w")
[16:01:49.373]         }
[16:01:49.373]         else {
[16:01:49.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:49.373]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:49.373]         }
[16:01:49.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:49.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:49.373]             base::sink(type = "output", split = FALSE)
[16:01:49.373]             base::close(...future.stdout)
[16:01:49.373]         }, add = TRUE)
[16:01:49.373]     }
[16:01:49.373]     ...future.frame <- base::sys.nframe()
[16:01:49.373]     ...future.conditions <- base::list()
[16:01:49.373]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:49.373]     if (FALSE) {
[16:01:49.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:49.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:49.373]     }
[16:01:49.373]     ...future.result <- base::tryCatch({
[16:01:49.373]         base::withCallingHandlers({
[16:01:49.373]             ...future.value <- base::withVisible(base::local({
[16:01:49.373]                 withCallingHandlers({
[16:01:49.373]                   {
[16:01:49.373]                     do.call(function(...) {
[16:01:49.373]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.373]                       if (!identical(...future.globals.maxSize.org, 
[16:01:49.373]                         ...future.globals.maxSize)) {
[16:01:49.373]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.373]                         on.exit(options(oopts), add = TRUE)
[16:01:49.373]                       }
[16:01:49.373]                       {
[16:01:49.373]                         lapply(seq_along(...future.elements_ii), 
[16:01:49.373]                           FUN = function(jj) {
[16:01:49.373]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.373]                             ...future.FUN(...future.X_jj, ...)
[16:01:49.373]                           })
[16:01:49.373]                       }
[16:01:49.373]                     }, args = future.call.arguments)
[16:01:49.373]                   }
[16:01:49.373]                 }, immediateCondition = function(cond) {
[16:01:49.373]                   save_rds <- function (object, pathname, ...) 
[16:01:49.373]                   {
[16:01:49.373]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:49.373]                     if (file_test("-f", pathname_tmp)) {
[16:01:49.373]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.373]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:49.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.373]                         fi_tmp[["mtime"]])
[16:01:49.373]                     }
[16:01:49.373]                     tryCatch({
[16:01:49.373]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:49.373]                     }, error = function(ex) {
[16:01:49.373]                       msg <- conditionMessage(ex)
[16:01:49.373]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.373]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:49.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.373]                         fi_tmp[["mtime"]], msg)
[16:01:49.373]                       ex$message <- msg
[16:01:49.373]                       stop(ex)
[16:01:49.373]                     })
[16:01:49.373]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:49.373]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:49.373]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:49.373]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.373]                       fi <- file.info(pathname)
[16:01:49.373]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:49.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.373]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:49.373]                         fi[["size"]], fi[["mtime"]])
[16:01:49.373]                       stop(msg)
[16:01:49.373]                     }
[16:01:49.373]                     invisible(pathname)
[16:01:49.373]                   }
[16:01:49.373]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:49.373]                     rootPath = tempdir()) 
[16:01:49.373]                   {
[16:01:49.373]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:49.373]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:49.373]                       tmpdir = path, fileext = ".rds")
[16:01:49.373]                     save_rds(obj, file)
[16:01:49.373]                   }
[16:01:49.373]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4bFpDe/.future/immediateConditions")
[16:01:49.373]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.373]                   {
[16:01:49.373]                     inherits <- base::inherits
[16:01:49.373]                     invokeRestart <- base::invokeRestart
[16:01:49.373]                     is.null <- base::is.null
[16:01:49.373]                     muffled <- FALSE
[16:01:49.373]                     if (inherits(cond, "message")) {
[16:01:49.373]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:49.373]                       if (muffled) 
[16:01:49.373]                         invokeRestart("muffleMessage")
[16:01:49.373]                     }
[16:01:49.373]                     else if (inherits(cond, "warning")) {
[16:01:49.373]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:49.373]                       if (muffled) 
[16:01:49.373]                         invokeRestart("muffleWarning")
[16:01:49.373]                     }
[16:01:49.373]                     else if (inherits(cond, "condition")) {
[16:01:49.373]                       if (!is.null(pattern)) {
[16:01:49.373]                         computeRestarts <- base::computeRestarts
[16:01:49.373]                         grepl <- base::grepl
[16:01:49.373]                         restarts <- computeRestarts(cond)
[16:01:49.373]                         for (restart in restarts) {
[16:01:49.373]                           name <- restart$name
[16:01:49.373]                           if (is.null(name)) 
[16:01:49.373]                             next
[16:01:49.373]                           if (!grepl(pattern, name)) 
[16:01:49.373]                             next
[16:01:49.373]                           invokeRestart(restart)
[16:01:49.373]                           muffled <- TRUE
[16:01:49.373]                           break
[16:01:49.373]                         }
[16:01:49.373]                       }
[16:01:49.373]                     }
[16:01:49.373]                     invisible(muffled)
[16:01:49.373]                   }
[16:01:49.373]                   muffleCondition(cond)
[16:01:49.373]                 })
[16:01:49.373]             }))
[16:01:49.373]             future::FutureResult(value = ...future.value$value, 
[16:01:49.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.373]                   ...future.rng), globalenv = if (FALSE) 
[16:01:49.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:49.373]                     ...future.globalenv.names))
[16:01:49.373]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:49.373]         }, condition = base::local({
[16:01:49.373]             c <- base::c
[16:01:49.373]             inherits <- base::inherits
[16:01:49.373]             invokeRestart <- base::invokeRestart
[16:01:49.373]             length <- base::length
[16:01:49.373]             list <- base::list
[16:01:49.373]             seq.int <- base::seq.int
[16:01:49.373]             signalCondition <- base::signalCondition
[16:01:49.373]             sys.calls <- base::sys.calls
[16:01:49.373]             `[[` <- base::`[[`
[16:01:49.373]             `+` <- base::`+`
[16:01:49.373]             `<<-` <- base::`<<-`
[16:01:49.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:49.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:49.373]                   3L)]
[16:01:49.373]             }
[16:01:49.373]             function(cond) {
[16:01:49.373]                 is_error <- inherits(cond, "error")
[16:01:49.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:49.373]                   NULL)
[16:01:49.373]                 if (is_error) {
[16:01:49.373]                   sessionInformation <- function() {
[16:01:49.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:49.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:49.373]                       search = base::search(), system = base::Sys.info())
[16:01:49.373]                   }
[16:01:49.373]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:49.373]                     cond$call), session = sessionInformation(), 
[16:01:49.373]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:49.373]                   signalCondition(cond)
[16:01:49.373]                 }
[16:01:49.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:49.373]                 "immediateCondition"))) {
[16:01:49.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:49.373]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:49.373]                   if (TRUE && !signal) {
[16:01:49.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.373]                     {
[16:01:49.373]                       inherits <- base::inherits
[16:01:49.373]                       invokeRestart <- base::invokeRestart
[16:01:49.373]                       is.null <- base::is.null
[16:01:49.373]                       muffled <- FALSE
[16:01:49.373]                       if (inherits(cond, "message")) {
[16:01:49.373]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.373]                         if (muffled) 
[16:01:49.373]                           invokeRestart("muffleMessage")
[16:01:49.373]                       }
[16:01:49.373]                       else if (inherits(cond, "warning")) {
[16:01:49.373]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.373]                         if (muffled) 
[16:01:49.373]                           invokeRestart("muffleWarning")
[16:01:49.373]                       }
[16:01:49.373]                       else if (inherits(cond, "condition")) {
[16:01:49.373]                         if (!is.null(pattern)) {
[16:01:49.373]                           computeRestarts <- base::computeRestarts
[16:01:49.373]                           grepl <- base::grepl
[16:01:49.373]                           restarts <- computeRestarts(cond)
[16:01:49.373]                           for (restart in restarts) {
[16:01:49.373]                             name <- restart$name
[16:01:49.373]                             if (is.null(name)) 
[16:01:49.373]                               next
[16:01:49.373]                             if (!grepl(pattern, name)) 
[16:01:49.373]                               next
[16:01:49.373]                             invokeRestart(restart)
[16:01:49.373]                             muffled <- TRUE
[16:01:49.373]                             break
[16:01:49.373]                           }
[16:01:49.373]                         }
[16:01:49.373]                       }
[16:01:49.373]                       invisible(muffled)
[16:01:49.373]                     }
[16:01:49.373]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.373]                   }
[16:01:49.373]                 }
[16:01:49.373]                 else {
[16:01:49.373]                   if (TRUE) {
[16:01:49.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.373]                     {
[16:01:49.373]                       inherits <- base::inherits
[16:01:49.373]                       invokeRestart <- base::invokeRestart
[16:01:49.373]                       is.null <- base::is.null
[16:01:49.373]                       muffled <- FALSE
[16:01:49.373]                       if (inherits(cond, "message")) {
[16:01:49.373]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.373]                         if (muffled) 
[16:01:49.373]                           invokeRestart("muffleMessage")
[16:01:49.373]                       }
[16:01:49.373]                       else if (inherits(cond, "warning")) {
[16:01:49.373]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.373]                         if (muffled) 
[16:01:49.373]                           invokeRestart("muffleWarning")
[16:01:49.373]                       }
[16:01:49.373]                       else if (inherits(cond, "condition")) {
[16:01:49.373]                         if (!is.null(pattern)) {
[16:01:49.373]                           computeRestarts <- base::computeRestarts
[16:01:49.373]                           grepl <- base::grepl
[16:01:49.373]                           restarts <- computeRestarts(cond)
[16:01:49.373]                           for (restart in restarts) {
[16:01:49.373]                             name <- restart$name
[16:01:49.373]                             if (is.null(name)) 
[16:01:49.373]                               next
[16:01:49.373]                             if (!grepl(pattern, name)) 
[16:01:49.373]                               next
[16:01:49.373]                             invokeRestart(restart)
[16:01:49.373]                             muffled <- TRUE
[16:01:49.373]                             break
[16:01:49.373]                           }
[16:01:49.373]                         }
[16:01:49.373]                       }
[16:01:49.373]                       invisible(muffled)
[16:01:49.373]                     }
[16:01:49.373]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.373]                   }
[16:01:49.373]                 }
[16:01:49.373]             }
[16:01:49.373]         }))
[16:01:49.373]     }, error = function(ex) {
[16:01:49.373]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:49.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.373]                 ...future.rng), started = ...future.startTime, 
[16:01:49.373]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:49.373]             version = "1.8"), class = "FutureResult")
[16:01:49.373]     }, finally = {
[16:01:49.373]         if (!identical(...future.workdir, getwd())) 
[16:01:49.373]             setwd(...future.workdir)
[16:01:49.373]         {
[16:01:49.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:49.373]                 ...future.oldOptions$nwarnings <- NULL
[16:01:49.373]             }
[16:01:49.373]             base::options(...future.oldOptions)
[16:01:49.373]             if (.Platform$OS.type == "windows") {
[16:01:49.373]                 old_names <- names(...future.oldEnvVars)
[16:01:49.373]                 envs <- base::Sys.getenv()
[16:01:49.373]                 names <- names(envs)
[16:01:49.373]                 common <- intersect(names, old_names)
[16:01:49.373]                 added <- setdiff(names, old_names)
[16:01:49.373]                 removed <- setdiff(old_names, names)
[16:01:49.373]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:49.373]                   envs[common]]
[16:01:49.373]                 NAMES <- toupper(changed)
[16:01:49.373]                 args <- list()
[16:01:49.373]                 for (kk in seq_along(NAMES)) {
[16:01:49.373]                   name <- changed[[kk]]
[16:01:49.373]                   NAME <- NAMES[[kk]]
[16:01:49.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.373]                     next
[16:01:49.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.373]                 }
[16:01:49.373]                 NAMES <- toupper(added)
[16:01:49.373]                 for (kk in seq_along(NAMES)) {
[16:01:49.373]                   name <- added[[kk]]
[16:01:49.373]                   NAME <- NAMES[[kk]]
[16:01:49.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.373]                     next
[16:01:49.373]                   args[[name]] <- ""
[16:01:49.373]                 }
[16:01:49.373]                 NAMES <- toupper(removed)
[16:01:49.373]                 for (kk in seq_along(NAMES)) {
[16:01:49.373]                   name <- removed[[kk]]
[16:01:49.373]                   NAME <- NAMES[[kk]]
[16:01:49.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.373]                     next
[16:01:49.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.373]                 }
[16:01:49.373]                 if (length(args) > 0) 
[16:01:49.373]                   base::do.call(base::Sys.setenv, args = args)
[16:01:49.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:49.373]             }
[16:01:49.373]             else {
[16:01:49.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:49.373]             }
[16:01:49.373]             {
[16:01:49.373]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:49.373]                   0L) {
[16:01:49.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:49.373]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:49.373]                   base::options(opts)
[16:01:49.373]                 }
[16:01:49.373]                 {
[16:01:49.373]                   {
[16:01:49.373]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:49.373]                     NULL
[16:01:49.373]                   }
[16:01:49.373]                   options(future.plan = NULL)
[16:01:49.373]                   if (is.na(NA_character_)) 
[16:01:49.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:49.373]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:49.373]                     envir = parent.frame()) 
[16:01:49.373]                   {
[16:01:49.373]                     default_workers <- missing(workers)
[16:01:49.373]                     if (is.function(workers)) 
[16:01:49.373]                       workers <- workers()
[16:01:49.373]                     workers <- structure(as.integer(workers), 
[16:01:49.373]                       class = class(workers))
[16:01:49.373]                     stop_if_not(is.finite(workers), workers >= 
[16:01:49.373]                       1L)
[16:01:49.373]                     if ((workers == 1L && !inherits(workers, 
[16:01:49.373]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:49.373]                       if (default_workers) 
[16:01:49.373]                         supportsMulticore(warn = TRUE)
[16:01:49.373]                       return(sequential(..., envir = envir))
[16:01:49.373]                     }
[16:01:49.373]                     oopts <- options(mc.cores = workers)
[16:01:49.373]                     on.exit(options(oopts))
[16:01:49.373]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:49.373]                       envir = envir)
[16:01:49.373]                     if (!future$lazy) 
[16:01:49.373]                       future <- run(future)
[16:01:49.373]                     invisible(future)
[16:01:49.373]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:49.373]                 }
[16:01:49.373]             }
[16:01:49.373]         }
[16:01:49.373]     })
[16:01:49.373]     if (TRUE) {
[16:01:49.373]         base::sink(type = "output", split = FALSE)
[16:01:49.373]         if (TRUE) {
[16:01:49.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:49.373]         }
[16:01:49.373]         else {
[16:01:49.373]             ...future.result["stdout"] <- base::list(NULL)
[16:01:49.373]         }
[16:01:49.373]         base::close(...future.stdout)
[16:01:49.373]         ...future.stdout <- NULL
[16:01:49.373]     }
[16:01:49.373]     ...future.result$conditions <- ...future.conditions
[16:01:49.373]     ...future.result$finished <- base::Sys.time()
[16:01:49.373]     ...future.result
[16:01:49.373] }
[16:01:49.375] assign_globals() ...
[16:01:49.375] List of 5
[16:01:49.375]  $ ...future.FUN            :function (x, ...)  
[16:01:49.375]  $ future.call.arguments    : list()
[16:01:49.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.375]  $ ...future.elements_ii    :List of 1
[16:01:49.375]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:01:49.375]  $ ...future.seeds_ii       : NULL
[16:01:49.375]  $ ...future.globals.maxSize: NULL
[16:01:49.375]  - attr(*, "where")=List of 5
[16:01:49.375]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:49.375]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:49.375]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:49.375]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:49.375]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:49.375]  - attr(*, "resolved")= logi FALSE
[16:01:49.375]  - attr(*, "total_size")= num 1248
[16:01:49.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.375]  - attr(*, "already-done")= logi TRUE
[16:01:49.380] - copied ‘...future.FUN’ to environment
[16:01:49.380] - copied ‘future.call.arguments’ to environment
[16:01:49.380] - copied ‘...future.elements_ii’ to environment
[16:01:49.380] - copied ‘...future.seeds_ii’ to environment
[16:01:49.380] - copied ‘...future.globals.maxSize’ to environment
[16:01:49.381] assign_globals() ... done
[16:01:49.381] requestCore(): workers = 2
[16:01:49.383] MulticoreFuture started
[16:01:49.383] - Launch lazy future ... done
[16:01:49.383] run() for ‘MulticoreFuture’ ... done
[16:01:49.384] Created future:
[16:01:49.384] plan(): Setting new future strategy stack:
[16:01:49.385] List of future strategies:
[16:01:49.385] 1. sequential:
[16:01:49.385]    - args: function (..., envir = parent.frame())
[16:01:49.385]    - tweaked: FALSE
[16:01:49.385]    - call: NULL
[16:01:49.385] plan(): nbrOfWorkers() = 1
[16:01:49.388] plan(): Setting new future strategy stack:
[16:01:49.388] List of future strategies:
[16:01:49.388] 1. multicore:
[16:01:49.388]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:49.388]    - tweaked: FALSE
[16:01:49.388]    - call: plan(strategy)
[16:01:49.393] plan(): nbrOfWorkers() = 2
[16:01:49.384] MulticoreFuture:
[16:01:49.384] Label: ‘future_eapply-1’
[16:01:49.384] Expression:
[16:01:49.384] {
[16:01:49.384]     do.call(function(...) {
[16:01:49.384]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.384]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.384]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.384]             on.exit(options(oopts), add = TRUE)
[16:01:49.384]         }
[16:01:49.384]         {
[16:01:49.384]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.384]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.384]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.384]             })
[16:01:49.384]         }
[16:01:49.384]     }, args = future.call.arguments)
[16:01:49.384] }
[16:01:49.384] Lazy evaluation: FALSE
[16:01:49.384] Asynchronous evaluation: TRUE
[16:01:49.384] Local evaluation: TRUE
[16:01:49.384] Environment: R_GlobalEnv
[16:01:49.384] Capture standard output: TRUE
[16:01:49.384] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:49.384] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:49.384] Packages: 1 packages (‘stats’)
[16:01:49.384] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:49.384] Resolved: TRUE
[16:01:49.384] Value: <not collected>
[16:01:49.384] Conditions captured: <none>
[16:01:49.384] Early signaling: FALSE
[16:01:49.384] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:49.384] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.394] Chunk #1 of 2 ... DONE
[16:01:49.395] Chunk #2 of 2 ...
[16:01:49.395]  - Finding globals in 'X' for chunk #2 ...
[16:01:49.395] getGlobalsAndPackages() ...
[16:01:49.395] Searching for globals...
[16:01:49.395] 
[16:01:49.396] Searching for globals ... DONE
[16:01:49.396] - globals: [0] <none>
[16:01:49.396] getGlobalsAndPackages() ... DONE
[16:01:49.396]    + additional globals found: [n=0] 
[16:01:49.396]    + additional namespaces needed: [n=0] 
[16:01:49.396]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:49.396]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:49.396]  - seeds: <none>
[16:01:49.397]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.397] getGlobalsAndPackages() ...
[16:01:49.397] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.397] Resolving globals: FALSE
[16:01:49.397] Tweak future expression to call with '...' arguments ...
[16:01:49.397] {
[16:01:49.397]     do.call(function(...) {
[16:01:49.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.397]             on.exit(options(oopts), add = TRUE)
[16:01:49.397]         }
[16:01:49.397]         {
[16:01:49.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.397]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.397]             })
[16:01:49.397]         }
[16:01:49.397]     }, args = future.call.arguments)
[16:01:49.397] }
[16:01:49.398] Tweak future expression to call with '...' arguments ... DONE
[16:01:49.398] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:49.399] - packages: [1] ‘stats’
[16:01:49.399] getGlobalsAndPackages() ... DONE
[16:01:49.399] run() for ‘Future’ ...
[16:01:49.399] - state: ‘created’
[16:01:49.400] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:49.408] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:49.408]   - Field: ‘label’
[16:01:49.408]   - Field: ‘local’
[16:01:49.409]   - Field: ‘owner’
[16:01:49.409]   - Field: ‘envir’
[16:01:49.409]   - Field: ‘workers’
[16:01:49.409]   - Field: ‘packages’
[16:01:49.409]   - Field: ‘gc’
[16:01:49.409]   - Field: ‘job’
[16:01:49.410]   - Field: ‘conditions’
[16:01:49.410]   - Field: ‘expr’
[16:01:49.410]   - Field: ‘uuid’
[16:01:49.410]   - Field: ‘seed’
[16:01:49.411]   - Field: ‘version’
[16:01:49.411]   - Field: ‘result’
[16:01:49.411]   - Field: ‘asynchronous’
[16:01:49.411]   - Field: ‘calls’
[16:01:49.411]   - Field: ‘globals’
[16:01:49.412]   - Field: ‘stdout’
[16:01:49.412]   - Field: ‘earlySignal’
[16:01:49.412]   - Field: ‘lazy’
[16:01:49.412]   - Field: ‘state’
[16:01:49.412] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:49.413] - Launch lazy future ...
[16:01:49.413] Packages needed by the future expression (n = 1): ‘stats’
[16:01:49.413] Packages needed by future strategies (n = 0): <none>
[16:01:49.414] {
[16:01:49.414]     {
[16:01:49.414]         {
[16:01:49.414]             ...future.startTime <- base::Sys.time()
[16:01:49.414]             {
[16:01:49.414]                 {
[16:01:49.414]                   {
[16:01:49.414]                     {
[16:01:49.414]                       {
[16:01:49.414]                         base::local({
[16:01:49.414]                           has_future <- base::requireNamespace("future", 
[16:01:49.414]                             quietly = TRUE)
[16:01:49.414]                           if (has_future) {
[16:01:49.414]                             ns <- base::getNamespace("future")
[16:01:49.414]                             version <- ns[[".package"]][["version"]]
[16:01:49.414]                             if (is.null(version)) 
[16:01:49.414]                               version <- utils::packageVersion("future")
[16:01:49.414]                           }
[16:01:49.414]                           else {
[16:01:49.414]                             version <- NULL
[16:01:49.414]                           }
[16:01:49.414]                           if (!has_future || version < "1.8.0") {
[16:01:49.414]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:49.414]                               "", base::R.version$version.string), 
[16:01:49.414]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:49.414]                                 base::R.version$platform, 8 * 
[16:01:49.414]                                   base::.Machine$sizeof.pointer), 
[16:01:49.414]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:49.414]                                 "release", "version")], collapse = " "), 
[16:01:49.414]                               hostname = base::Sys.info()[["nodename"]])
[16:01:49.414]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:49.414]                               info)
[16:01:49.414]                             info <- base::paste(info, collapse = "; ")
[16:01:49.414]                             if (!has_future) {
[16:01:49.414]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:49.414]                                 info)
[16:01:49.414]                             }
[16:01:49.414]                             else {
[16:01:49.414]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:49.414]                                 info, version)
[16:01:49.414]                             }
[16:01:49.414]                             base::stop(msg)
[16:01:49.414]                           }
[16:01:49.414]                         })
[16:01:49.414]                       }
[16:01:49.414]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:49.414]                       base::options(mc.cores = 1L)
[16:01:49.414]                     }
[16:01:49.414]                     base::local({
[16:01:49.414]                       for (pkg in "stats") {
[16:01:49.414]                         base::loadNamespace(pkg)
[16:01:49.414]                         base::library(pkg, character.only = TRUE)
[16:01:49.414]                       }
[16:01:49.414]                     })
[16:01:49.414]                   }
[16:01:49.414]                   options(future.plan = NULL)
[16:01:49.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:49.414]                 }
[16:01:49.414]                 ...future.workdir <- getwd()
[16:01:49.414]             }
[16:01:49.414]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:49.414]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:49.414]         }
[16:01:49.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:49.414]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:49.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:49.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:49.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:49.414]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:49.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:49.414]             base::names(...future.oldOptions))
[16:01:49.414]     }
[16:01:49.414]     if (FALSE) {
[16:01:49.414]     }
[16:01:49.414]     else {
[16:01:49.414]         if (TRUE) {
[16:01:49.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:49.414]                 open = "w")
[16:01:49.414]         }
[16:01:49.414]         else {
[16:01:49.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:49.414]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:49.414]         }
[16:01:49.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:49.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:49.414]             base::sink(type = "output", split = FALSE)
[16:01:49.414]             base::close(...future.stdout)
[16:01:49.414]         }, add = TRUE)
[16:01:49.414]     }
[16:01:49.414]     ...future.frame <- base::sys.nframe()
[16:01:49.414]     ...future.conditions <- base::list()
[16:01:49.414]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:49.414]     if (FALSE) {
[16:01:49.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:49.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:49.414]     }
[16:01:49.414]     ...future.result <- base::tryCatch({
[16:01:49.414]         base::withCallingHandlers({
[16:01:49.414]             ...future.value <- base::withVisible(base::local({
[16:01:49.414]                 withCallingHandlers({
[16:01:49.414]                   {
[16:01:49.414]                     do.call(function(...) {
[16:01:49.414]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.414]                       if (!identical(...future.globals.maxSize.org, 
[16:01:49.414]                         ...future.globals.maxSize)) {
[16:01:49.414]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.414]                         on.exit(options(oopts), add = TRUE)
[16:01:49.414]                       }
[16:01:49.414]                       {
[16:01:49.414]                         lapply(seq_along(...future.elements_ii), 
[16:01:49.414]                           FUN = function(jj) {
[16:01:49.414]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.414]                             ...future.FUN(...future.X_jj, ...)
[16:01:49.414]                           })
[16:01:49.414]                       }
[16:01:49.414]                     }, args = future.call.arguments)
[16:01:49.414]                   }
[16:01:49.414]                 }, immediateCondition = function(cond) {
[16:01:49.414]                   save_rds <- function (object, pathname, ...) 
[16:01:49.414]                   {
[16:01:49.414]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:49.414]                     if (file_test("-f", pathname_tmp)) {
[16:01:49.414]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.414]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:49.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.414]                         fi_tmp[["mtime"]])
[16:01:49.414]                     }
[16:01:49.414]                     tryCatch({
[16:01:49.414]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:49.414]                     }, error = function(ex) {
[16:01:49.414]                       msg <- conditionMessage(ex)
[16:01:49.414]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.414]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:49.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.414]                         fi_tmp[["mtime"]], msg)
[16:01:49.414]                       ex$message <- msg
[16:01:49.414]                       stop(ex)
[16:01:49.414]                     })
[16:01:49.414]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:49.414]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:49.414]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:49.414]                       fi_tmp <- file.info(pathname_tmp)
[16:01:49.414]                       fi <- file.info(pathname)
[16:01:49.414]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:49.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:49.414]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:49.414]                         fi[["size"]], fi[["mtime"]])
[16:01:49.414]                       stop(msg)
[16:01:49.414]                     }
[16:01:49.414]                     invisible(pathname)
[16:01:49.414]                   }
[16:01:49.414]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:49.414]                     rootPath = tempdir()) 
[16:01:49.414]                   {
[16:01:49.414]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:49.414]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:49.414]                       tmpdir = path, fileext = ".rds")
[16:01:49.414]                     save_rds(obj, file)
[16:01:49.414]                   }
[16:01:49.414]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4bFpDe/.future/immediateConditions")
[16:01:49.414]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.414]                   {
[16:01:49.414]                     inherits <- base::inherits
[16:01:49.414]                     invokeRestart <- base::invokeRestart
[16:01:49.414]                     is.null <- base::is.null
[16:01:49.414]                     muffled <- FALSE
[16:01:49.414]                     if (inherits(cond, "message")) {
[16:01:49.414]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:49.414]                       if (muffled) 
[16:01:49.414]                         invokeRestart("muffleMessage")
[16:01:49.414]                     }
[16:01:49.414]                     else if (inherits(cond, "warning")) {
[16:01:49.414]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:49.414]                       if (muffled) 
[16:01:49.414]                         invokeRestart("muffleWarning")
[16:01:49.414]                     }
[16:01:49.414]                     else if (inherits(cond, "condition")) {
[16:01:49.414]                       if (!is.null(pattern)) {
[16:01:49.414]                         computeRestarts <- base::computeRestarts
[16:01:49.414]                         grepl <- base::grepl
[16:01:49.414]                         restarts <- computeRestarts(cond)
[16:01:49.414]                         for (restart in restarts) {
[16:01:49.414]                           name <- restart$name
[16:01:49.414]                           if (is.null(name)) 
[16:01:49.414]                             next
[16:01:49.414]                           if (!grepl(pattern, name)) 
[16:01:49.414]                             next
[16:01:49.414]                           invokeRestart(restart)
[16:01:49.414]                           muffled <- TRUE
[16:01:49.414]                           break
[16:01:49.414]                         }
[16:01:49.414]                       }
[16:01:49.414]                     }
[16:01:49.414]                     invisible(muffled)
[16:01:49.414]                   }
[16:01:49.414]                   muffleCondition(cond)
[16:01:49.414]                 })
[16:01:49.414]             }))
[16:01:49.414]             future::FutureResult(value = ...future.value$value, 
[16:01:49.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.414]                   ...future.rng), globalenv = if (FALSE) 
[16:01:49.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:49.414]                     ...future.globalenv.names))
[16:01:49.414]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:49.414]         }, condition = base::local({
[16:01:49.414]             c <- base::c
[16:01:49.414]             inherits <- base::inherits
[16:01:49.414]             invokeRestart <- base::invokeRestart
[16:01:49.414]             length <- base::length
[16:01:49.414]             list <- base::list
[16:01:49.414]             seq.int <- base::seq.int
[16:01:49.414]             signalCondition <- base::signalCondition
[16:01:49.414]             sys.calls <- base::sys.calls
[16:01:49.414]             `[[` <- base::`[[`
[16:01:49.414]             `+` <- base::`+`
[16:01:49.414]             `<<-` <- base::`<<-`
[16:01:49.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:49.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:49.414]                   3L)]
[16:01:49.414]             }
[16:01:49.414]             function(cond) {
[16:01:49.414]                 is_error <- inherits(cond, "error")
[16:01:49.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:49.414]                   NULL)
[16:01:49.414]                 if (is_error) {
[16:01:49.414]                   sessionInformation <- function() {
[16:01:49.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:49.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:49.414]                       search = base::search(), system = base::Sys.info())
[16:01:49.414]                   }
[16:01:49.414]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:49.414]                     cond$call), session = sessionInformation(), 
[16:01:49.414]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:49.414]                   signalCondition(cond)
[16:01:49.414]                 }
[16:01:49.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:49.414]                 "immediateCondition"))) {
[16:01:49.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:49.414]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:49.414]                   if (TRUE && !signal) {
[16:01:49.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.414]                     {
[16:01:49.414]                       inherits <- base::inherits
[16:01:49.414]                       invokeRestart <- base::invokeRestart
[16:01:49.414]                       is.null <- base::is.null
[16:01:49.414]                       muffled <- FALSE
[16:01:49.414]                       if (inherits(cond, "message")) {
[16:01:49.414]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.414]                         if (muffled) 
[16:01:49.414]                           invokeRestart("muffleMessage")
[16:01:49.414]                       }
[16:01:49.414]                       else if (inherits(cond, "warning")) {
[16:01:49.414]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.414]                         if (muffled) 
[16:01:49.414]                           invokeRestart("muffleWarning")
[16:01:49.414]                       }
[16:01:49.414]                       else if (inherits(cond, "condition")) {
[16:01:49.414]                         if (!is.null(pattern)) {
[16:01:49.414]                           computeRestarts <- base::computeRestarts
[16:01:49.414]                           grepl <- base::grepl
[16:01:49.414]                           restarts <- computeRestarts(cond)
[16:01:49.414]                           for (restart in restarts) {
[16:01:49.414]                             name <- restart$name
[16:01:49.414]                             if (is.null(name)) 
[16:01:49.414]                               next
[16:01:49.414]                             if (!grepl(pattern, name)) 
[16:01:49.414]                               next
[16:01:49.414]                             invokeRestart(restart)
[16:01:49.414]                             muffled <- TRUE
[16:01:49.414]                             break
[16:01:49.414]                           }
[16:01:49.414]                         }
[16:01:49.414]                       }
[16:01:49.414]                       invisible(muffled)
[16:01:49.414]                     }
[16:01:49.414]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.414]                   }
[16:01:49.414]                 }
[16:01:49.414]                 else {
[16:01:49.414]                   if (TRUE) {
[16:01:49.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.414]                     {
[16:01:49.414]                       inherits <- base::inherits
[16:01:49.414]                       invokeRestart <- base::invokeRestart
[16:01:49.414]                       is.null <- base::is.null
[16:01:49.414]                       muffled <- FALSE
[16:01:49.414]                       if (inherits(cond, "message")) {
[16:01:49.414]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.414]                         if (muffled) 
[16:01:49.414]                           invokeRestart("muffleMessage")
[16:01:49.414]                       }
[16:01:49.414]                       else if (inherits(cond, "warning")) {
[16:01:49.414]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.414]                         if (muffled) 
[16:01:49.414]                           invokeRestart("muffleWarning")
[16:01:49.414]                       }
[16:01:49.414]                       else if (inherits(cond, "condition")) {
[16:01:49.414]                         if (!is.null(pattern)) {
[16:01:49.414]                           computeRestarts <- base::computeRestarts
[16:01:49.414]                           grepl <- base::grepl
[16:01:49.414]                           restarts <- computeRestarts(cond)
[16:01:49.414]                           for (restart in restarts) {
[16:01:49.414]                             name <- restart$name
[16:01:49.414]                             if (is.null(name)) 
[16:01:49.414]                               next
[16:01:49.414]                             if (!grepl(pattern, name)) 
[16:01:49.414]                               next
[16:01:49.414]                             invokeRestart(restart)
[16:01:49.414]                             muffled <- TRUE
[16:01:49.414]                             break
[16:01:49.414]                           }
[16:01:49.414]                         }
[16:01:49.414]                       }
[16:01:49.414]                       invisible(muffled)
[16:01:49.414]                     }
[16:01:49.414]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.414]                   }
[16:01:49.414]                 }
[16:01:49.414]             }
[16:01:49.414]         }))
[16:01:49.414]     }, error = function(ex) {
[16:01:49.414]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:49.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.414]                 ...future.rng), started = ...future.startTime, 
[16:01:49.414]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:49.414]             version = "1.8"), class = "FutureResult")
[16:01:49.414]     }, finally = {
[16:01:49.414]         if (!identical(...future.workdir, getwd())) 
[16:01:49.414]             setwd(...future.workdir)
[16:01:49.414]         {
[16:01:49.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:49.414]                 ...future.oldOptions$nwarnings <- NULL
[16:01:49.414]             }
[16:01:49.414]             base::options(...future.oldOptions)
[16:01:49.414]             if (.Platform$OS.type == "windows") {
[16:01:49.414]                 old_names <- names(...future.oldEnvVars)
[16:01:49.414]                 envs <- base::Sys.getenv()
[16:01:49.414]                 names <- names(envs)
[16:01:49.414]                 common <- intersect(names, old_names)
[16:01:49.414]                 added <- setdiff(names, old_names)
[16:01:49.414]                 removed <- setdiff(old_names, names)
[16:01:49.414]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:49.414]                   envs[common]]
[16:01:49.414]                 NAMES <- toupper(changed)
[16:01:49.414]                 args <- list()
[16:01:49.414]                 for (kk in seq_along(NAMES)) {
[16:01:49.414]                   name <- changed[[kk]]
[16:01:49.414]                   NAME <- NAMES[[kk]]
[16:01:49.414]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.414]                     next
[16:01:49.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.414]                 }
[16:01:49.414]                 NAMES <- toupper(added)
[16:01:49.414]                 for (kk in seq_along(NAMES)) {
[16:01:49.414]                   name <- added[[kk]]
[16:01:49.414]                   NAME <- NAMES[[kk]]
[16:01:49.414]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.414]                     next
[16:01:49.414]                   args[[name]] <- ""
[16:01:49.414]                 }
[16:01:49.414]                 NAMES <- toupper(removed)
[16:01:49.414]                 for (kk in seq_along(NAMES)) {
[16:01:49.414]                   name <- removed[[kk]]
[16:01:49.414]                   NAME <- NAMES[[kk]]
[16:01:49.414]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.414]                     next
[16:01:49.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.414]                 }
[16:01:49.414]                 if (length(args) > 0) 
[16:01:49.414]                   base::do.call(base::Sys.setenv, args = args)
[16:01:49.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:49.414]             }
[16:01:49.414]             else {
[16:01:49.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:49.414]             }
[16:01:49.414]             {
[16:01:49.414]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:49.414]                   0L) {
[16:01:49.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:49.414]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:49.414]                   base::options(opts)
[16:01:49.414]                 }
[16:01:49.414]                 {
[16:01:49.414]                   {
[16:01:49.414]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:49.414]                     NULL
[16:01:49.414]                   }
[16:01:49.414]                   options(future.plan = NULL)
[16:01:49.414]                   if (is.na(NA_character_)) 
[16:01:49.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:49.414]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:49.414]                     envir = parent.frame()) 
[16:01:49.414]                   {
[16:01:49.414]                     default_workers <- missing(workers)
[16:01:49.414]                     if (is.function(workers)) 
[16:01:49.414]                       workers <- workers()
[16:01:49.414]                     workers <- structure(as.integer(workers), 
[16:01:49.414]                       class = class(workers))
[16:01:49.414]                     stop_if_not(is.finite(workers), workers >= 
[16:01:49.414]                       1L)
[16:01:49.414]                     if ((workers == 1L && !inherits(workers, 
[16:01:49.414]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:49.414]                       if (default_workers) 
[16:01:49.414]                         supportsMulticore(warn = TRUE)
[16:01:49.414]                       return(sequential(..., envir = envir))
[16:01:49.414]                     }
[16:01:49.414]                     oopts <- options(mc.cores = workers)
[16:01:49.414]                     on.exit(options(oopts))
[16:01:49.414]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:49.414]                       envir = envir)
[16:01:49.414]                     if (!future$lazy) 
[16:01:49.414]                       future <- run(future)
[16:01:49.414]                     invisible(future)
[16:01:49.414]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:49.414]                 }
[16:01:49.414]             }
[16:01:49.414]         }
[16:01:49.414]     })
[16:01:49.414]     if (TRUE) {
[16:01:49.414]         base::sink(type = "output", split = FALSE)
[16:01:49.414]         if (TRUE) {
[16:01:49.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:49.414]         }
[16:01:49.414]         else {
[16:01:49.414]             ...future.result["stdout"] <- base::list(NULL)
[16:01:49.414]         }
[16:01:49.414]         base::close(...future.stdout)
[16:01:49.414]         ...future.stdout <- NULL
[16:01:49.414]     }
[16:01:49.414]     ...future.result$conditions <- ...future.conditions
[16:01:49.414]     ...future.result$finished <- base::Sys.time()
[16:01:49.414]     ...future.result
[16:01:49.414] }
[16:01:49.417] assign_globals() ...
[16:01:49.417] List of 5
[16:01:49.417]  $ ...future.FUN            :function (x, ...)  
[16:01:49.417]  $ future.call.arguments    : list()
[16:01:49.417]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:49.417]  $ ...future.elements_ii    :List of 2
[16:01:49.417]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:01:49.417]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:01:49.417]  $ ...future.seeds_ii       : NULL
[16:01:49.417]  $ ...future.globals.maxSize: NULL
[16:01:49.417]  - attr(*, "where")=List of 5
[16:01:49.417]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:49.417]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:49.417]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:49.417]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:49.417]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:49.417]  - attr(*, "resolved")= logi FALSE
[16:01:49.417]  - attr(*, "total_size")= num 1248
[16:01:49.417]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:49.417]  - attr(*, "already-done")= logi TRUE
[16:01:49.425] - copied ‘...future.FUN’ to environment
[16:01:49.426] - copied ‘future.call.arguments’ to environment
[16:01:49.426] - copied ‘...future.elements_ii’ to environment
[16:01:49.426] - copied ‘...future.seeds_ii’ to environment
[16:01:49.426] - copied ‘...future.globals.maxSize’ to environment
[16:01:49.426] assign_globals() ... done
[16:01:49.426] requestCore(): workers = 2
[16:01:49.429] MulticoreFuture started
[16:01:49.429] - Launch lazy future ... done
[16:01:49.429] run() for ‘MulticoreFuture’ ... done
[16:01:49.429] Created future:
[16:01:49.430] plan(): Setting new future strategy stack:
[16:01:49.430] List of future strategies:
[16:01:49.430] 1. sequential:
[16:01:49.430]    - args: function (..., envir = parent.frame())
[16:01:49.430]    - tweaked: FALSE
[16:01:49.430]    - call: NULL
[16:01:49.431] plan(): nbrOfWorkers() = 1
[16:01:49.434] plan(): Setting new future strategy stack:
[16:01:49.434] List of future strategies:
[16:01:49.434] 1. multicore:
[16:01:49.434]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:49.434]    - tweaked: FALSE
[16:01:49.434]    - call: plan(strategy)
[16:01:49.439] plan(): nbrOfWorkers() = 2
[16:01:49.430] MulticoreFuture:
[16:01:49.430] Label: ‘future_eapply-2’
[16:01:49.430] Expression:
[16:01:49.430] {
[16:01:49.430]     do.call(function(...) {
[16:01:49.430]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:49.430]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:49.430]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:49.430]             on.exit(options(oopts), add = TRUE)
[16:01:49.430]         }
[16:01:49.430]         {
[16:01:49.430]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:49.430]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:49.430]                 ...future.FUN(...future.X_jj, ...)
[16:01:49.430]             })
[16:01:49.430]         }
[16:01:49.430]     }, args = future.call.arguments)
[16:01:49.430] }
[16:01:49.430] Lazy evaluation: FALSE
[16:01:49.430] Asynchronous evaluation: TRUE
[16:01:49.430] Local evaluation: TRUE
[16:01:49.430] Environment: R_GlobalEnv
[16:01:49.430] Capture standard output: TRUE
[16:01:49.430] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:49.430] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:49.430] Packages: 1 packages (‘stats’)
[16:01:49.430] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:49.430] Resolved: TRUE
[16:01:49.430] Value: <not collected>
[16:01:49.430] Conditions captured: <none>
[16:01:49.430] Early signaling: FALSE
[16:01:49.430] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:49.430] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:49.440] Chunk #2 of 2 ... DONE
[16:01:49.440] Launching 2 futures (chunks) ... DONE
[16:01:49.441] Resolving 2 futures (chunks) ...
[16:01:49.441] resolve() on list ...
[16:01:49.441]  recursive: 0
[16:01:49.441]  length: 2
[16:01:49.441] 
[16:01:49.442] Future #1
[16:01:49.442] result() for MulticoreFuture ...
[16:01:49.443] result() for MulticoreFuture ...
[16:01:49.443] result() for MulticoreFuture ... done
[16:01:49.443] result() for MulticoreFuture ... done
[16:01:49.443] result() for MulticoreFuture ...
[16:01:49.443] result() for MulticoreFuture ... done
[16:01:49.444] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:49.444] - nx: 2
[16:01:49.444] - relay: TRUE
[16:01:49.444] - stdout: TRUE
[16:01:49.444] - signal: TRUE
[16:01:49.444] - resignal: FALSE
[16:01:49.444] - force: TRUE
[16:01:49.444] - relayed: [n=2] FALSE, FALSE
[16:01:49.445] - queued futures: [n=2] FALSE, FALSE
[16:01:49.445]  - until=1
[16:01:49.445]  - relaying element #1
[16:01:49.445] result() for MulticoreFuture ...
[16:01:49.445] result() for MulticoreFuture ... done
[16:01:49.445] result() for MulticoreFuture ...
[16:01:49.445] result() for MulticoreFuture ... done
[16:01:49.446] result() for MulticoreFuture ...
[16:01:49.446] result() for MulticoreFuture ... done
[16:01:49.446] result() for MulticoreFuture ...
[16:01:49.446] result() for MulticoreFuture ... done
[16:01:49.446] - relayed: [n=2] TRUE, FALSE
[16:01:49.446] - queued futures: [n=2] TRUE, FALSE
[16:01:49.446] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:49.447]  length: 1 (resolved future 1)
[16:01:49.447] Future #2
[16:01:49.447] result() for MulticoreFuture ...
[16:01:49.448] result() for MulticoreFuture ...
[16:01:49.448] result() for MulticoreFuture ... done
[16:01:49.448] result() for MulticoreFuture ... done
[16:01:49.448] result() for MulticoreFuture ...
[16:01:49.448] result() for MulticoreFuture ... done
[16:01:49.448] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:49.449] - nx: 2
[16:01:49.449] - relay: TRUE
[16:01:49.449] - stdout: TRUE
[16:01:49.449] - signal: TRUE
[16:01:49.449] - resignal: FALSE
[16:01:49.449] - force: TRUE
[16:01:49.449] - relayed: [n=2] TRUE, FALSE
[16:01:49.449] - queued futures: [n=2] TRUE, FALSE
[16:01:49.450]  - until=2
[16:01:49.450]  - relaying element #2
[16:01:49.450] result() for MulticoreFuture ...
[16:01:49.450] result() for MulticoreFuture ... done
[16:01:49.450] result() for MulticoreFuture ...
[16:01:49.450] result() for MulticoreFuture ... done
[16:01:49.450] result() for MulticoreFuture ...
[16:01:49.450] result() for MulticoreFuture ... done
[16:01:49.450] result() for MulticoreFuture ...
[16:01:49.451] result() for MulticoreFuture ... done
[16:01:49.451] - relayed: [n=2] TRUE, TRUE
[16:01:49.451] - queued futures: [n=2] TRUE, TRUE
[16:01:49.451] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:49.451]  length: 0 (resolved future 2)
[16:01:49.451] Relaying remaining futures
[16:01:49.451] signalConditionsASAP(NULL, pos=0) ...
[16:01:49.451] - nx: 2
[16:01:49.452] - relay: TRUE
[16:01:49.452] - stdout: TRUE
[16:01:49.452] - signal: TRUE
[16:01:49.452] - resignal: FALSE
[16:01:49.452] - force: TRUE
[16:01:49.455] - relayed: [n=2] TRUE, TRUE
[16:01:49.455] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:49.455] - relayed: [n=2] TRUE, TRUE
[16:01:49.455] - queued futures: [n=2] TRUE, TRUE
[16:01:49.455] signalConditionsASAP(NULL, pos=0) ... done
[16:01:49.455] resolve() on list ... DONE
[16:01:49.455] result() for MulticoreFuture ...
[16:01:49.456] result() for MulticoreFuture ... done
[16:01:49.456] result() for MulticoreFuture ...
[16:01:49.456] result() for MulticoreFuture ... done
[16:01:49.456] result() for MulticoreFuture ...
[16:01:49.456] result() for MulticoreFuture ... done
[16:01:49.456] result() for MulticoreFuture ...
[16:01:49.457] result() for MulticoreFuture ... done
[16:01:49.457]  - Number of value chunks collected: 2
[16:01:49.457] Resolving 2 futures (chunks) ... DONE
[16:01:49.457] Reducing values from 2 chunks ...
[16:01:49.457]  - Number of values collected after concatenation: 3
[16:01:49.457]  - Number of values expected: 3
[16:01:49.457] Reducing values from 2 chunks ... DONE
[16:01:49.457] future_lapply() ... DONE
[16:01:49.458] plan(): Setting new future strategy stack:
[16:01:49.458] List of future strategies:
[16:01:49.458] 1. sequential:
[16:01:49.458]    - args: function (..., envir = parent.frame())
[16:01:49.458]    - tweaked: FALSE
[16:01:49.458]    - call: plan(sequential)
[16:01:49.459] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:01:49.459] plan(): Setting new future strategy stack:
[16:01:49.459] List of future strategies:
[16:01:49.459] 1. multisession:
[16:01:49.459]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:49.459]    - tweaked: FALSE
[16:01:49.459]    - call: plan(strategy)
[16:01:49.460] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:01:49.460] multisession:
[16:01:49.460] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:49.460] - tweaked: FALSE
[16:01:49.460] - call: plan(strategy)
[16:01:49.468] getGlobalsAndPackages() ...
[16:01:49.468] Not searching for globals
[16:01:49.468] - globals: [0] <none>
[16:01:49.468] getGlobalsAndPackages() ... DONE
[16:01:49.469] [local output] makeClusterPSOCK() ...
[16:01:49.510] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:01:49.511] [local output] Base port: 11771
[16:01:49.511] [local output] Getting setup options for 2 cluster nodes ...
[16:01:49.512] [local output]  - Node 1 of 2 ...
[16:01:49.512] [local output] localMachine=TRUE => revtunnel=FALSE

[16:01:49.513] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4bFpDe/worker.rank=1.parallelly.parent=68974.10d6e6adc802d.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp4bFpDe/worker.rank=1.parallelly.parent=68974.10d6e6adc802d.pid")'’
[16:01:49.703] - Possible to infer worker's PID: TRUE
[16:01:49.704] [local output] Rscript port: 11771

[16:01:49.704] [local output]  - Node 2 of 2 ...
[16:01:49.705] [local output] localMachine=TRUE => revtunnel=FALSE

[16:01:49.705] [local output] Rscript port: 11771

[16:01:49.705] [local output] Getting setup options for 2 cluster nodes ... done
[16:01:49.706] [local output]  - Parallel setup requested for some PSOCK nodes
[16:01:49.706] [local output] Setting up PSOCK nodes in parallel
[16:01:49.706] List of 36
[16:01:49.706]  $ worker          : chr "localhost"
[16:01:49.706]   ..- attr(*, "localhost")= logi TRUE
[16:01:49.706]  $ master          : chr "localhost"
[16:01:49.706]  $ port            : int 11771
[16:01:49.706]  $ connectTimeout  : num 120
[16:01:49.706]  $ timeout         : num 2592000
[16:01:49.706]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:01:49.706]  $ homogeneous     : logi TRUE
[16:01:49.706]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:01:49.706]  $ rscript_envs    : NULL
[16:01:49.706]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:01:49.706]  $ rscript_startup : NULL
[16:01:49.706]  $ rscript_sh      : chr "sh"
[16:01:49.706]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:01:49.706]  $ methods         : logi TRUE
[16:01:49.706]  $ socketOptions   : chr "no-delay"
[16:01:49.706]  $ useXDR          : logi FALSE
[16:01:49.706]  $ outfile         : chr "/dev/null"
[16:01:49.706]  $ renice          : int NA
[16:01:49.706]  $ rshcmd          : NULL
[16:01:49.706]  $ user            : chr(0) 
[16:01:49.706]  $ revtunnel       : logi FALSE
[16:01:49.706]  $ rshlogfile      : NULL
[16:01:49.706]  $ rshopts         : chr(0) 
[16:01:49.706]  $ rank            : int 1
[16:01:49.706]  $ manual          : logi FALSE
[16:01:49.706]  $ dryrun          : logi FALSE
[16:01:49.706]  $ quiet           : logi FALSE
[16:01:49.706]  $ setup_strategy  : chr "parallel"
[16:01:49.706]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:01:49.706]  $ pidfile         : chr "/tmp/Rtmp4bFpDe/worker.rank=1.parallelly.parent=68974.10d6e6adc802d.pid"
[16:01:49.706]  $ rshcmd_label    : NULL
[16:01:49.706]  $ rsh_call        : NULL
[16:01:49.706]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:01:49.706]  $ localMachine    : logi TRUE
[16:01:49.706]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:01:49.706]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:01:49.706]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:01:49.706]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:01:49.706]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:01:49.706]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:01:49.706]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:01:49.706]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:01:49.706]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:01:49.706]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:01:49.706]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:01:49.706]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:01:49.706]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:01:49.706]  $ arguments       :List of 28
[16:01:49.706]   ..$ worker          : chr "localhost"
[16:01:49.706]   ..$ master          : NULL
[16:01:49.706]   ..$ port            : int 11771
[16:01:49.706]   ..$ connectTimeout  : num 120
[16:01:49.706]   ..$ timeout         : num 2592000
[16:01:49.706]   ..$ rscript         : NULL
[16:01:49.706]   ..$ homogeneous     : NULL
[16:01:49.706]   ..$ rscript_args    : NULL
[16:01:49.706]   ..$ rscript_envs    : NULL
[16:01:49.706]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:01:49.706]   ..$ rscript_startup : NULL
[16:01:49.706]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:01:49.706]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:01:49.706]   ..$ methods         : logi TRUE
[16:01:49.706]   ..$ socketOptions   : chr "no-delay"
[16:01:49.706]   ..$ useXDR          : logi FALSE
[16:01:49.706]   ..$ outfile         : chr "/dev/null"
[16:01:49.706]   ..$ renice          : int NA
[16:01:49.706]   ..$ rshcmd          : NULL
[16:01:49.706]   ..$ user            : NULL
[16:01:49.706]   ..$ revtunnel       : logi NA
[16:01:49.706]   ..$ rshlogfile      : NULL
[16:01:49.706]   ..$ rshopts         : NULL
[16:01:49.706]   ..$ rank            : int 1
[16:01:49.706]   ..$ manual          : logi FALSE
[16:01:49.706]   ..$ dryrun          : logi FALSE
[16:01:49.706]   ..$ quiet           : logi FALSE
[16:01:49.706]   ..$ setup_strategy  : chr "parallel"
[16:01:49.706]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:01:49.723] [local output] System call to launch all workers:
[16:01:49.723] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4bFpDe/worker.rank=1.parallelly.parent=68974.10d6e6adc802d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11771 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:01:49.723] [local output] Starting PSOCK main server
[16:01:49.729] [local output] Workers launched
[16:01:49.729] [local output] Waiting for workers to connect back
[16:01:49.729]  - [local output] 0 workers out of 2 ready
[16:01:49.973]  - [local output] 0 workers out of 2 ready
[16:01:49.974]  - [local output] 1 workers out of 2 ready
[16:01:49.974]  - [local output] 2 workers out of 2 ready
[16:01:49.974] [local output] Launching of workers completed
[16:01:49.974] [local output] Collecting session information from workers
[16:01:49.975] [local output]  - Worker #1 of 2
[16:01:49.976] [local output]  - Worker #2 of 2
[16:01:49.976] [local output] makeClusterPSOCK() ... done
[16:01:49.987] Packages needed by the future expression (n = 0): <none>
[16:01:49.987] Packages needed by future strategies (n = 0): <none>
[16:01:49.988] {
[16:01:49.988]     {
[16:01:49.988]         {
[16:01:49.988]             ...future.startTime <- base::Sys.time()
[16:01:49.988]             {
[16:01:49.988]                 {
[16:01:49.988]                   {
[16:01:49.988]                     {
[16:01:49.988]                       base::local({
[16:01:49.988]                         has_future <- base::requireNamespace("future", 
[16:01:49.988]                           quietly = TRUE)
[16:01:49.988]                         if (has_future) {
[16:01:49.988]                           ns <- base::getNamespace("future")
[16:01:49.988]                           version <- ns[[".package"]][["version"]]
[16:01:49.988]                           if (is.null(version)) 
[16:01:49.988]                             version <- utils::packageVersion("future")
[16:01:49.988]                         }
[16:01:49.988]                         else {
[16:01:49.988]                           version <- NULL
[16:01:49.988]                         }
[16:01:49.988]                         if (!has_future || version < "1.8.0") {
[16:01:49.988]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:49.988]                             "", base::R.version$version.string), 
[16:01:49.988]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:49.988]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:49.988]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:49.988]                               "release", "version")], collapse = " "), 
[16:01:49.988]                             hostname = base::Sys.info()[["nodename"]])
[16:01:49.988]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:49.988]                             info)
[16:01:49.988]                           info <- base::paste(info, collapse = "; ")
[16:01:49.988]                           if (!has_future) {
[16:01:49.988]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:49.988]                               info)
[16:01:49.988]                           }
[16:01:49.988]                           else {
[16:01:49.988]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:49.988]                               info, version)
[16:01:49.988]                           }
[16:01:49.988]                           base::stop(msg)
[16:01:49.988]                         }
[16:01:49.988]                       })
[16:01:49.988]                     }
[16:01:49.988]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:49.988]                     base::options(mc.cores = 1L)
[16:01:49.988]                   }
[16:01:49.988]                   options(future.plan = NULL)
[16:01:49.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:49.988]                 }
[16:01:49.988]                 ...future.workdir <- getwd()
[16:01:49.988]             }
[16:01:49.988]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:49.988]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:49.988]         }
[16:01:49.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:49.988]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:49.988]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:49.988]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:49.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:49.988]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:49.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:49.988]             base::names(...future.oldOptions))
[16:01:49.988]     }
[16:01:49.988]     if (FALSE) {
[16:01:49.988]     }
[16:01:49.988]     else {
[16:01:49.988]         if (TRUE) {
[16:01:49.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:49.988]                 open = "w")
[16:01:49.988]         }
[16:01:49.988]         else {
[16:01:49.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:49.988]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:49.988]         }
[16:01:49.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:49.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:49.988]             base::sink(type = "output", split = FALSE)
[16:01:49.988]             base::close(...future.stdout)
[16:01:49.988]         }, add = TRUE)
[16:01:49.988]     }
[16:01:49.988]     ...future.frame <- base::sys.nframe()
[16:01:49.988]     ...future.conditions <- base::list()
[16:01:49.988]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:49.988]     if (FALSE) {
[16:01:49.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:49.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:49.988]     }
[16:01:49.988]     ...future.result <- base::tryCatch({
[16:01:49.988]         base::withCallingHandlers({
[16:01:49.988]             ...future.value <- base::withVisible(base::local({
[16:01:49.988]                 ...future.makeSendCondition <- base::local({
[16:01:49.988]                   sendCondition <- NULL
[16:01:49.988]                   function(frame = 1L) {
[16:01:49.988]                     if (is.function(sendCondition)) 
[16:01:49.988]                       return(sendCondition)
[16:01:49.988]                     ns <- getNamespace("parallel")
[16:01:49.988]                     if (exists("sendData", mode = "function", 
[16:01:49.988]                       envir = ns)) {
[16:01:49.988]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:49.988]                         envir = ns)
[16:01:49.988]                       envir <- sys.frame(frame)
[16:01:49.988]                       master <- NULL
[16:01:49.988]                       while (!identical(envir, .GlobalEnv) && 
[16:01:49.988]                         !identical(envir, emptyenv())) {
[16:01:49.988]                         if (exists("master", mode = "list", envir = envir, 
[16:01:49.988]                           inherits = FALSE)) {
[16:01:49.988]                           master <- get("master", mode = "list", 
[16:01:49.988]                             envir = envir, inherits = FALSE)
[16:01:49.988]                           if (inherits(master, c("SOCKnode", 
[16:01:49.988]                             "SOCK0node"))) {
[16:01:49.988]                             sendCondition <<- function(cond) {
[16:01:49.988]                               data <- list(type = "VALUE", value = cond, 
[16:01:49.988]                                 success = TRUE)
[16:01:49.988]                               parallel_sendData(master, data)
[16:01:49.988]                             }
[16:01:49.988]                             return(sendCondition)
[16:01:49.988]                           }
[16:01:49.988]                         }
[16:01:49.988]                         frame <- frame + 1L
[16:01:49.988]                         envir <- sys.frame(frame)
[16:01:49.988]                       }
[16:01:49.988]                     }
[16:01:49.988]                     sendCondition <<- function(cond) NULL
[16:01:49.988]                   }
[16:01:49.988]                 })
[16:01:49.988]                 withCallingHandlers({
[16:01:49.988]                   NA
[16:01:49.988]                 }, immediateCondition = function(cond) {
[16:01:49.988]                   sendCondition <- ...future.makeSendCondition()
[16:01:49.988]                   sendCondition(cond)
[16:01:49.988]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.988]                   {
[16:01:49.988]                     inherits <- base::inherits
[16:01:49.988]                     invokeRestart <- base::invokeRestart
[16:01:49.988]                     is.null <- base::is.null
[16:01:49.988]                     muffled <- FALSE
[16:01:49.988]                     if (inherits(cond, "message")) {
[16:01:49.988]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:49.988]                       if (muffled) 
[16:01:49.988]                         invokeRestart("muffleMessage")
[16:01:49.988]                     }
[16:01:49.988]                     else if (inherits(cond, "warning")) {
[16:01:49.988]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:49.988]                       if (muffled) 
[16:01:49.988]                         invokeRestart("muffleWarning")
[16:01:49.988]                     }
[16:01:49.988]                     else if (inherits(cond, "condition")) {
[16:01:49.988]                       if (!is.null(pattern)) {
[16:01:49.988]                         computeRestarts <- base::computeRestarts
[16:01:49.988]                         grepl <- base::grepl
[16:01:49.988]                         restarts <- computeRestarts(cond)
[16:01:49.988]                         for (restart in restarts) {
[16:01:49.988]                           name <- restart$name
[16:01:49.988]                           if (is.null(name)) 
[16:01:49.988]                             next
[16:01:49.988]                           if (!grepl(pattern, name)) 
[16:01:49.988]                             next
[16:01:49.988]                           invokeRestart(restart)
[16:01:49.988]                           muffled <- TRUE
[16:01:49.988]                           break
[16:01:49.988]                         }
[16:01:49.988]                       }
[16:01:49.988]                     }
[16:01:49.988]                     invisible(muffled)
[16:01:49.988]                   }
[16:01:49.988]                   muffleCondition(cond)
[16:01:49.988]                 })
[16:01:49.988]             }))
[16:01:49.988]             future::FutureResult(value = ...future.value$value, 
[16:01:49.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.988]                   ...future.rng), globalenv = if (FALSE) 
[16:01:49.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:49.988]                     ...future.globalenv.names))
[16:01:49.988]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:49.988]         }, condition = base::local({
[16:01:49.988]             c <- base::c
[16:01:49.988]             inherits <- base::inherits
[16:01:49.988]             invokeRestart <- base::invokeRestart
[16:01:49.988]             length <- base::length
[16:01:49.988]             list <- base::list
[16:01:49.988]             seq.int <- base::seq.int
[16:01:49.988]             signalCondition <- base::signalCondition
[16:01:49.988]             sys.calls <- base::sys.calls
[16:01:49.988]             `[[` <- base::`[[`
[16:01:49.988]             `+` <- base::`+`
[16:01:49.988]             `<<-` <- base::`<<-`
[16:01:49.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:49.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:49.988]                   3L)]
[16:01:49.988]             }
[16:01:49.988]             function(cond) {
[16:01:49.988]                 is_error <- inherits(cond, "error")
[16:01:49.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:49.988]                   NULL)
[16:01:49.988]                 if (is_error) {
[16:01:49.988]                   sessionInformation <- function() {
[16:01:49.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:49.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:49.988]                       search = base::search(), system = base::Sys.info())
[16:01:49.988]                   }
[16:01:49.988]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:49.988]                     cond$call), session = sessionInformation(), 
[16:01:49.988]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:49.988]                   signalCondition(cond)
[16:01:49.988]                 }
[16:01:49.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:49.988]                 "immediateCondition"))) {
[16:01:49.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:49.988]                   ...future.conditions[[length(...future.conditions) + 
[16:01:49.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:49.988]                   if (TRUE && !signal) {
[16:01:49.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.988]                     {
[16:01:49.988]                       inherits <- base::inherits
[16:01:49.988]                       invokeRestart <- base::invokeRestart
[16:01:49.988]                       is.null <- base::is.null
[16:01:49.988]                       muffled <- FALSE
[16:01:49.988]                       if (inherits(cond, "message")) {
[16:01:49.988]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.988]                         if (muffled) 
[16:01:49.988]                           invokeRestart("muffleMessage")
[16:01:49.988]                       }
[16:01:49.988]                       else if (inherits(cond, "warning")) {
[16:01:49.988]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.988]                         if (muffled) 
[16:01:49.988]                           invokeRestart("muffleWarning")
[16:01:49.988]                       }
[16:01:49.988]                       else if (inherits(cond, "condition")) {
[16:01:49.988]                         if (!is.null(pattern)) {
[16:01:49.988]                           computeRestarts <- base::computeRestarts
[16:01:49.988]                           grepl <- base::grepl
[16:01:49.988]                           restarts <- computeRestarts(cond)
[16:01:49.988]                           for (restart in restarts) {
[16:01:49.988]                             name <- restart$name
[16:01:49.988]                             if (is.null(name)) 
[16:01:49.988]                               next
[16:01:49.988]                             if (!grepl(pattern, name)) 
[16:01:49.988]                               next
[16:01:49.988]                             invokeRestart(restart)
[16:01:49.988]                             muffled <- TRUE
[16:01:49.988]                             break
[16:01:49.988]                           }
[16:01:49.988]                         }
[16:01:49.988]                       }
[16:01:49.988]                       invisible(muffled)
[16:01:49.988]                     }
[16:01:49.988]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.988]                   }
[16:01:49.988]                 }
[16:01:49.988]                 else {
[16:01:49.988]                   if (TRUE) {
[16:01:49.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:49.988]                     {
[16:01:49.988]                       inherits <- base::inherits
[16:01:49.988]                       invokeRestart <- base::invokeRestart
[16:01:49.988]                       is.null <- base::is.null
[16:01:49.988]                       muffled <- FALSE
[16:01:49.988]                       if (inherits(cond, "message")) {
[16:01:49.988]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:49.988]                         if (muffled) 
[16:01:49.988]                           invokeRestart("muffleMessage")
[16:01:49.988]                       }
[16:01:49.988]                       else if (inherits(cond, "warning")) {
[16:01:49.988]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:49.988]                         if (muffled) 
[16:01:49.988]                           invokeRestart("muffleWarning")
[16:01:49.988]                       }
[16:01:49.988]                       else if (inherits(cond, "condition")) {
[16:01:49.988]                         if (!is.null(pattern)) {
[16:01:49.988]                           computeRestarts <- base::computeRestarts
[16:01:49.988]                           grepl <- base::grepl
[16:01:49.988]                           restarts <- computeRestarts(cond)
[16:01:49.988]                           for (restart in restarts) {
[16:01:49.988]                             name <- restart$name
[16:01:49.988]                             if (is.null(name)) 
[16:01:49.988]                               next
[16:01:49.988]                             if (!grepl(pattern, name)) 
[16:01:49.988]                               next
[16:01:49.988]                             invokeRestart(restart)
[16:01:49.988]                             muffled <- TRUE
[16:01:49.988]                             break
[16:01:49.988]                           }
[16:01:49.988]                         }
[16:01:49.988]                       }
[16:01:49.988]                       invisible(muffled)
[16:01:49.988]                     }
[16:01:49.988]                     muffleCondition(cond, pattern = "^muffle")
[16:01:49.988]                   }
[16:01:49.988]                 }
[16:01:49.988]             }
[16:01:49.988]         }))
[16:01:49.988]     }, error = function(ex) {
[16:01:49.988]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:49.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:49.988]                 ...future.rng), started = ...future.startTime, 
[16:01:49.988]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:49.988]             version = "1.8"), class = "FutureResult")
[16:01:49.988]     }, finally = {
[16:01:49.988]         if (!identical(...future.workdir, getwd())) 
[16:01:49.988]             setwd(...future.workdir)
[16:01:49.988]         {
[16:01:49.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:49.988]                 ...future.oldOptions$nwarnings <- NULL
[16:01:49.988]             }
[16:01:49.988]             base::options(...future.oldOptions)
[16:01:49.988]             if (.Platform$OS.type == "windows") {
[16:01:49.988]                 old_names <- names(...future.oldEnvVars)
[16:01:49.988]                 envs <- base::Sys.getenv()
[16:01:49.988]                 names <- names(envs)
[16:01:49.988]                 common <- intersect(names, old_names)
[16:01:49.988]                 added <- setdiff(names, old_names)
[16:01:49.988]                 removed <- setdiff(old_names, names)
[16:01:49.988]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:49.988]                   envs[common]]
[16:01:49.988]                 NAMES <- toupper(changed)
[16:01:49.988]                 args <- list()
[16:01:49.988]                 for (kk in seq_along(NAMES)) {
[16:01:49.988]                   name <- changed[[kk]]
[16:01:49.988]                   NAME <- NAMES[[kk]]
[16:01:49.988]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.988]                     next
[16:01:49.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.988]                 }
[16:01:49.988]                 NAMES <- toupper(added)
[16:01:49.988]                 for (kk in seq_along(NAMES)) {
[16:01:49.988]                   name <- added[[kk]]
[16:01:49.988]                   NAME <- NAMES[[kk]]
[16:01:49.988]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.988]                     next
[16:01:49.988]                   args[[name]] <- ""
[16:01:49.988]                 }
[16:01:49.988]                 NAMES <- toupper(removed)
[16:01:49.988]                 for (kk in seq_along(NAMES)) {
[16:01:49.988]                   name <- removed[[kk]]
[16:01:49.988]                   NAME <- NAMES[[kk]]
[16:01:49.988]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:49.988]                     next
[16:01:49.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:49.988]                 }
[16:01:49.988]                 if (length(args) > 0) 
[16:01:49.988]                   base::do.call(base::Sys.setenv, args = args)
[16:01:49.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:49.988]             }
[16:01:49.988]             else {
[16:01:49.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:49.988]             }
[16:01:49.988]             {
[16:01:49.988]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:49.988]                   0L) {
[16:01:49.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:49.988]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:49.988]                   base::options(opts)
[16:01:49.988]                 }
[16:01:49.988]                 {
[16:01:49.988]                   {
[16:01:49.988]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:49.988]                     NULL
[16:01:49.988]                   }
[16:01:49.988]                   options(future.plan = NULL)
[16:01:49.988]                   if (is.na(NA_character_)) 
[16:01:49.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:49.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:49.988]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:49.988]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:49.988]                     envir = parent.frame()) 
[16:01:49.988]                   {
[16:01:49.988]                     if (is.function(workers)) 
[16:01:49.988]                       workers <- workers()
[16:01:49.988]                     workers <- structure(as.integer(workers), 
[16:01:49.988]                       class = class(workers))
[16:01:49.988]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:49.988]                       workers >= 1)
[16:01:49.988]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:49.988]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:49.988]                     }
[16:01:49.988]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:49.988]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:49.988]                       envir = envir)
[16:01:49.988]                     if (!future$lazy) 
[16:01:49.988]                       future <- run(future)
[16:01:49.988]                     invisible(future)
[16:01:49.988]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:49.988]                 }
[16:01:49.988]             }
[16:01:49.988]         }
[16:01:49.988]     })
[16:01:49.988]     if (TRUE) {
[16:01:49.988]         base::sink(type = "output", split = FALSE)
[16:01:49.988]         if (TRUE) {
[16:01:49.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:49.988]         }
[16:01:49.988]         else {
[16:01:49.988]             ...future.result["stdout"] <- base::list(NULL)
[16:01:49.988]         }
[16:01:49.988]         base::close(...future.stdout)
[16:01:49.988]         ...future.stdout <- NULL
[16:01:49.988]     }
[16:01:49.988]     ...future.result$conditions <- ...future.conditions
[16:01:49.988]     ...future.result$finished <- base::Sys.time()
[16:01:49.988]     ...future.result
[16:01:49.988] }
[16:01:50.043] MultisessionFuture started
[16:01:50.044] result() for ClusterFuture ...
[16:01:50.045] receiveMessageFromWorker() for ClusterFuture ...
[16:01:50.045] - Validating connection of MultisessionFuture
[16:01:50.090] - received message: FutureResult
[16:01:50.090] - Received FutureResult
[16:01:50.090] - Erased future from FutureRegistry
[16:01:50.090] result() for ClusterFuture ...
[16:01:50.090] - result already collected: FutureResult
[16:01:50.091] result() for ClusterFuture ... done
[16:01:50.091] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:50.091] result() for ClusterFuture ... done
[16:01:50.091] result() for ClusterFuture ...
[16:01:50.091] - result already collected: FutureResult
[16:01:50.091] result() for ClusterFuture ... done
[16:01:50.091] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:01:50.095] plan(): nbrOfWorkers() = 2
[16:01:50.095] future_lapply() ...
[16:01:50.099] Number of chunks: 2
[16:01:50.099] getGlobalsAndPackagesXApply() ...
[16:01:50.099]  - future.globals: TRUE
[16:01:50.100] getGlobalsAndPackages() ...
[16:01:50.100] Searching for globals...
[16:01:50.101] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:50.101] Searching for globals ... DONE
[16:01:50.101] Resolving globals: FALSE
[16:01:50.102] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:50.102] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:50.102] - globals: [1] ‘FUN’
[16:01:50.102] 
[16:01:50.103] getGlobalsAndPackages() ... DONE
[16:01:50.103]  - globals found/used: [n=1] ‘FUN’
[16:01:50.103]  - needed namespaces: [n=0] 
[16:01:50.103] Finding globals ... DONE
[16:01:50.103]  - use_args: TRUE
[16:01:50.103]  - Getting '...' globals ...
[16:01:50.104] resolve() on list ...
[16:01:50.104]  recursive: 0
[16:01:50.104]  length: 1
[16:01:50.104]  elements: ‘...’
[16:01:50.104]  length: 0 (resolved future 1)
[16:01:50.104] resolve() on list ... DONE
[16:01:50.104]    - '...' content: [n=0] 
[16:01:50.104] List of 1
[16:01:50.104]  $ ...: list()
[16:01:50.104]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:50.104]  - attr(*, "where")=List of 1
[16:01:50.104]   ..$ ...:<environment: 0x5620a2a55be0> 
[16:01:50.104]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:50.104]  - attr(*, "resolved")= logi TRUE
[16:01:50.104]  - attr(*, "total_size")= num NA
[16:01:50.108]  - Getting '...' globals ... DONE
[16:01:50.108] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:50.108] List of 2
[16:01:50.108]  $ ...future.FUN:function (x, ...)  
[16:01:50.108]  $ ...          : list()
[16:01:50.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:50.108]  - attr(*, "where")=List of 2
[16:01:50.108]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:50.108]   ..$ ...          :<environment: 0x5620a2a55be0> 
[16:01:50.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:50.108]  - attr(*, "resolved")= logi FALSE
[16:01:50.108]  - attr(*, "total_size")= num 1240
[16:01:50.111] Packages to be attached in all futures: [n=0] 
[16:01:50.111] getGlobalsAndPackagesXApply() ... DONE
[16:01:50.112] Number of futures (= number of chunks): 2
[16:01:50.112] Launching 2 futures (chunks) ...
[16:01:50.112] Chunk #1 of 2 ...
[16:01:50.112]  - Finding globals in 'X' for chunk #1 ...
[16:01:50.112] getGlobalsAndPackages() ...
[16:01:50.112] Searching for globals...
[16:01:50.113] 
[16:01:50.113] Searching for globals ... DONE
[16:01:50.113] - globals: [0] <none>
[16:01:50.113] getGlobalsAndPackages() ... DONE
[16:01:50.113]    + additional globals found: [n=0] 
[16:01:50.113]    + additional namespaces needed: [n=0] 
[16:01:50.113]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:50.113]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:50.113]  - seeds: <none>
[16:01:50.114]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.114] getGlobalsAndPackages() ...
[16:01:50.114] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.114] Resolving globals: FALSE
[16:01:50.114] Tweak future expression to call with '...' arguments ...
[16:01:50.114] {
[16:01:50.114]     do.call(function(...) {
[16:01:50.114]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.114]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.114]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.114]             on.exit(options(oopts), add = TRUE)
[16:01:50.114]         }
[16:01:50.114]         {
[16:01:50.114]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.114]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.114]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.114]             })
[16:01:50.114]         }
[16:01:50.114]     }, args = future.call.arguments)
[16:01:50.114] }
[16:01:50.115] Tweak future expression to call with '...' arguments ... DONE
[16:01:50.115] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.115] 
[16:01:50.115] getGlobalsAndPackages() ... DONE
[16:01:50.116] run() for ‘Future’ ...
[16:01:50.116] - state: ‘created’
[16:01:50.116] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:50.131] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:50.131]   - Field: ‘node’
[16:01:50.131]   - Field: ‘label’
[16:01:50.131]   - Field: ‘local’
[16:01:50.131]   - Field: ‘owner’
[16:01:50.131]   - Field: ‘envir’
[16:01:50.131]   - Field: ‘workers’
[16:01:50.132]   - Field: ‘packages’
[16:01:50.132]   - Field: ‘gc’
[16:01:50.132]   - Field: ‘conditions’
[16:01:50.132]   - Field: ‘persistent’
[16:01:50.132]   - Field: ‘expr’
[16:01:50.132]   - Field: ‘uuid’
[16:01:50.132]   - Field: ‘seed’
[16:01:50.132]   - Field: ‘version’
[16:01:50.132]   - Field: ‘result’
[16:01:50.133]   - Field: ‘asynchronous’
[16:01:50.133]   - Field: ‘calls’
[16:01:50.133]   - Field: ‘globals’
[16:01:50.133]   - Field: ‘stdout’
[16:01:50.133]   - Field: ‘earlySignal’
[16:01:50.133]   - Field: ‘lazy’
[16:01:50.133]   - Field: ‘state’
[16:01:50.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:50.134] - Launch lazy future ...
[16:01:50.134] Packages needed by the future expression (n = 0): <none>
[16:01:50.134] Packages needed by future strategies (n = 0): <none>
[16:01:50.135] {
[16:01:50.135]     {
[16:01:50.135]         {
[16:01:50.135]             ...future.startTime <- base::Sys.time()
[16:01:50.135]             {
[16:01:50.135]                 {
[16:01:50.135]                   {
[16:01:50.135]                     {
[16:01:50.135]                       base::local({
[16:01:50.135]                         has_future <- base::requireNamespace("future", 
[16:01:50.135]                           quietly = TRUE)
[16:01:50.135]                         if (has_future) {
[16:01:50.135]                           ns <- base::getNamespace("future")
[16:01:50.135]                           version <- ns[[".package"]][["version"]]
[16:01:50.135]                           if (is.null(version)) 
[16:01:50.135]                             version <- utils::packageVersion("future")
[16:01:50.135]                         }
[16:01:50.135]                         else {
[16:01:50.135]                           version <- NULL
[16:01:50.135]                         }
[16:01:50.135]                         if (!has_future || version < "1.8.0") {
[16:01:50.135]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:50.135]                             "", base::R.version$version.string), 
[16:01:50.135]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:50.135]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:50.135]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:50.135]                               "release", "version")], collapse = " "), 
[16:01:50.135]                             hostname = base::Sys.info()[["nodename"]])
[16:01:50.135]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:50.135]                             info)
[16:01:50.135]                           info <- base::paste(info, collapse = "; ")
[16:01:50.135]                           if (!has_future) {
[16:01:50.135]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:50.135]                               info)
[16:01:50.135]                           }
[16:01:50.135]                           else {
[16:01:50.135]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:50.135]                               info, version)
[16:01:50.135]                           }
[16:01:50.135]                           base::stop(msg)
[16:01:50.135]                         }
[16:01:50.135]                       })
[16:01:50.135]                     }
[16:01:50.135]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:50.135]                     base::options(mc.cores = 1L)
[16:01:50.135]                   }
[16:01:50.135]                   options(future.plan = NULL)
[16:01:50.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:50.135]                 }
[16:01:50.135]                 ...future.workdir <- getwd()
[16:01:50.135]             }
[16:01:50.135]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:50.135]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:50.135]         }
[16:01:50.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:50.135]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:50.135]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:50.135]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:50.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:50.135]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:50.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:50.135]             base::names(...future.oldOptions))
[16:01:50.135]     }
[16:01:50.135]     if (FALSE) {
[16:01:50.135]     }
[16:01:50.135]     else {
[16:01:50.135]         if (TRUE) {
[16:01:50.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:50.135]                 open = "w")
[16:01:50.135]         }
[16:01:50.135]         else {
[16:01:50.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:50.135]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:50.135]         }
[16:01:50.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:50.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:50.135]             base::sink(type = "output", split = FALSE)
[16:01:50.135]             base::close(...future.stdout)
[16:01:50.135]         }, add = TRUE)
[16:01:50.135]     }
[16:01:50.135]     ...future.frame <- base::sys.nframe()
[16:01:50.135]     ...future.conditions <- base::list()
[16:01:50.135]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:50.135]     if (FALSE) {
[16:01:50.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:50.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:50.135]     }
[16:01:50.135]     ...future.result <- base::tryCatch({
[16:01:50.135]         base::withCallingHandlers({
[16:01:50.135]             ...future.value <- base::withVisible(base::local({
[16:01:50.135]                 ...future.makeSendCondition <- base::local({
[16:01:50.135]                   sendCondition <- NULL
[16:01:50.135]                   function(frame = 1L) {
[16:01:50.135]                     if (is.function(sendCondition)) 
[16:01:50.135]                       return(sendCondition)
[16:01:50.135]                     ns <- getNamespace("parallel")
[16:01:50.135]                     if (exists("sendData", mode = "function", 
[16:01:50.135]                       envir = ns)) {
[16:01:50.135]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:50.135]                         envir = ns)
[16:01:50.135]                       envir <- sys.frame(frame)
[16:01:50.135]                       master <- NULL
[16:01:50.135]                       while (!identical(envir, .GlobalEnv) && 
[16:01:50.135]                         !identical(envir, emptyenv())) {
[16:01:50.135]                         if (exists("master", mode = "list", envir = envir, 
[16:01:50.135]                           inherits = FALSE)) {
[16:01:50.135]                           master <- get("master", mode = "list", 
[16:01:50.135]                             envir = envir, inherits = FALSE)
[16:01:50.135]                           if (inherits(master, c("SOCKnode", 
[16:01:50.135]                             "SOCK0node"))) {
[16:01:50.135]                             sendCondition <<- function(cond) {
[16:01:50.135]                               data <- list(type = "VALUE", value = cond, 
[16:01:50.135]                                 success = TRUE)
[16:01:50.135]                               parallel_sendData(master, data)
[16:01:50.135]                             }
[16:01:50.135]                             return(sendCondition)
[16:01:50.135]                           }
[16:01:50.135]                         }
[16:01:50.135]                         frame <- frame + 1L
[16:01:50.135]                         envir <- sys.frame(frame)
[16:01:50.135]                       }
[16:01:50.135]                     }
[16:01:50.135]                     sendCondition <<- function(cond) NULL
[16:01:50.135]                   }
[16:01:50.135]                 })
[16:01:50.135]                 withCallingHandlers({
[16:01:50.135]                   {
[16:01:50.135]                     do.call(function(...) {
[16:01:50.135]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.135]                       if (!identical(...future.globals.maxSize.org, 
[16:01:50.135]                         ...future.globals.maxSize)) {
[16:01:50.135]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.135]                         on.exit(options(oopts), add = TRUE)
[16:01:50.135]                       }
[16:01:50.135]                       {
[16:01:50.135]                         lapply(seq_along(...future.elements_ii), 
[16:01:50.135]                           FUN = function(jj) {
[16:01:50.135]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.135]                             ...future.FUN(...future.X_jj, ...)
[16:01:50.135]                           })
[16:01:50.135]                       }
[16:01:50.135]                     }, args = future.call.arguments)
[16:01:50.135]                   }
[16:01:50.135]                 }, immediateCondition = function(cond) {
[16:01:50.135]                   sendCondition <- ...future.makeSendCondition()
[16:01:50.135]                   sendCondition(cond)
[16:01:50.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.135]                   {
[16:01:50.135]                     inherits <- base::inherits
[16:01:50.135]                     invokeRestart <- base::invokeRestart
[16:01:50.135]                     is.null <- base::is.null
[16:01:50.135]                     muffled <- FALSE
[16:01:50.135]                     if (inherits(cond, "message")) {
[16:01:50.135]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:50.135]                       if (muffled) 
[16:01:50.135]                         invokeRestart("muffleMessage")
[16:01:50.135]                     }
[16:01:50.135]                     else if (inherits(cond, "warning")) {
[16:01:50.135]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:50.135]                       if (muffled) 
[16:01:50.135]                         invokeRestart("muffleWarning")
[16:01:50.135]                     }
[16:01:50.135]                     else if (inherits(cond, "condition")) {
[16:01:50.135]                       if (!is.null(pattern)) {
[16:01:50.135]                         computeRestarts <- base::computeRestarts
[16:01:50.135]                         grepl <- base::grepl
[16:01:50.135]                         restarts <- computeRestarts(cond)
[16:01:50.135]                         for (restart in restarts) {
[16:01:50.135]                           name <- restart$name
[16:01:50.135]                           if (is.null(name)) 
[16:01:50.135]                             next
[16:01:50.135]                           if (!grepl(pattern, name)) 
[16:01:50.135]                             next
[16:01:50.135]                           invokeRestart(restart)
[16:01:50.135]                           muffled <- TRUE
[16:01:50.135]                           break
[16:01:50.135]                         }
[16:01:50.135]                       }
[16:01:50.135]                     }
[16:01:50.135]                     invisible(muffled)
[16:01:50.135]                   }
[16:01:50.135]                   muffleCondition(cond)
[16:01:50.135]                 })
[16:01:50.135]             }))
[16:01:50.135]             future::FutureResult(value = ...future.value$value, 
[16:01:50.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.135]                   ...future.rng), globalenv = if (FALSE) 
[16:01:50.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:50.135]                     ...future.globalenv.names))
[16:01:50.135]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:50.135]         }, condition = base::local({
[16:01:50.135]             c <- base::c
[16:01:50.135]             inherits <- base::inherits
[16:01:50.135]             invokeRestart <- base::invokeRestart
[16:01:50.135]             length <- base::length
[16:01:50.135]             list <- base::list
[16:01:50.135]             seq.int <- base::seq.int
[16:01:50.135]             signalCondition <- base::signalCondition
[16:01:50.135]             sys.calls <- base::sys.calls
[16:01:50.135]             `[[` <- base::`[[`
[16:01:50.135]             `+` <- base::`+`
[16:01:50.135]             `<<-` <- base::`<<-`
[16:01:50.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:50.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:50.135]                   3L)]
[16:01:50.135]             }
[16:01:50.135]             function(cond) {
[16:01:50.135]                 is_error <- inherits(cond, "error")
[16:01:50.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:50.135]                   NULL)
[16:01:50.135]                 if (is_error) {
[16:01:50.135]                   sessionInformation <- function() {
[16:01:50.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:50.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:50.135]                       search = base::search(), system = base::Sys.info())
[16:01:50.135]                   }
[16:01:50.135]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:50.135]                     cond$call), session = sessionInformation(), 
[16:01:50.135]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:50.135]                   signalCondition(cond)
[16:01:50.135]                 }
[16:01:50.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:50.135]                 "immediateCondition"))) {
[16:01:50.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:50.135]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:50.135]                   if (TRUE && !signal) {
[16:01:50.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.135]                     {
[16:01:50.135]                       inherits <- base::inherits
[16:01:50.135]                       invokeRestart <- base::invokeRestart
[16:01:50.135]                       is.null <- base::is.null
[16:01:50.135]                       muffled <- FALSE
[16:01:50.135]                       if (inherits(cond, "message")) {
[16:01:50.135]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.135]                         if (muffled) 
[16:01:50.135]                           invokeRestart("muffleMessage")
[16:01:50.135]                       }
[16:01:50.135]                       else if (inherits(cond, "warning")) {
[16:01:50.135]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.135]                         if (muffled) 
[16:01:50.135]                           invokeRestart("muffleWarning")
[16:01:50.135]                       }
[16:01:50.135]                       else if (inherits(cond, "condition")) {
[16:01:50.135]                         if (!is.null(pattern)) {
[16:01:50.135]                           computeRestarts <- base::computeRestarts
[16:01:50.135]                           grepl <- base::grepl
[16:01:50.135]                           restarts <- computeRestarts(cond)
[16:01:50.135]                           for (restart in restarts) {
[16:01:50.135]                             name <- restart$name
[16:01:50.135]                             if (is.null(name)) 
[16:01:50.135]                               next
[16:01:50.135]                             if (!grepl(pattern, name)) 
[16:01:50.135]                               next
[16:01:50.135]                             invokeRestart(restart)
[16:01:50.135]                             muffled <- TRUE
[16:01:50.135]                             break
[16:01:50.135]                           }
[16:01:50.135]                         }
[16:01:50.135]                       }
[16:01:50.135]                       invisible(muffled)
[16:01:50.135]                     }
[16:01:50.135]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.135]                   }
[16:01:50.135]                 }
[16:01:50.135]                 else {
[16:01:50.135]                   if (TRUE) {
[16:01:50.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.135]                     {
[16:01:50.135]                       inherits <- base::inherits
[16:01:50.135]                       invokeRestart <- base::invokeRestart
[16:01:50.135]                       is.null <- base::is.null
[16:01:50.135]                       muffled <- FALSE
[16:01:50.135]                       if (inherits(cond, "message")) {
[16:01:50.135]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.135]                         if (muffled) 
[16:01:50.135]                           invokeRestart("muffleMessage")
[16:01:50.135]                       }
[16:01:50.135]                       else if (inherits(cond, "warning")) {
[16:01:50.135]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.135]                         if (muffled) 
[16:01:50.135]                           invokeRestart("muffleWarning")
[16:01:50.135]                       }
[16:01:50.135]                       else if (inherits(cond, "condition")) {
[16:01:50.135]                         if (!is.null(pattern)) {
[16:01:50.135]                           computeRestarts <- base::computeRestarts
[16:01:50.135]                           grepl <- base::grepl
[16:01:50.135]                           restarts <- computeRestarts(cond)
[16:01:50.135]                           for (restart in restarts) {
[16:01:50.135]                             name <- restart$name
[16:01:50.135]                             if (is.null(name)) 
[16:01:50.135]                               next
[16:01:50.135]                             if (!grepl(pattern, name)) 
[16:01:50.135]                               next
[16:01:50.135]                             invokeRestart(restart)
[16:01:50.135]                             muffled <- TRUE
[16:01:50.135]                             break
[16:01:50.135]                           }
[16:01:50.135]                         }
[16:01:50.135]                       }
[16:01:50.135]                       invisible(muffled)
[16:01:50.135]                     }
[16:01:50.135]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.135]                   }
[16:01:50.135]                 }
[16:01:50.135]             }
[16:01:50.135]         }))
[16:01:50.135]     }, error = function(ex) {
[16:01:50.135]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:50.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.135]                 ...future.rng), started = ...future.startTime, 
[16:01:50.135]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:50.135]             version = "1.8"), class = "FutureResult")
[16:01:50.135]     }, finally = {
[16:01:50.135]         if (!identical(...future.workdir, getwd())) 
[16:01:50.135]             setwd(...future.workdir)
[16:01:50.135]         {
[16:01:50.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:50.135]                 ...future.oldOptions$nwarnings <- NULL
[16:01:50.135]             }
[16:01:50.135]             base::options(...future.oldOptions)
[16:01:50.135]             if (.Platform$OS.type == "windows") {
[16:01:50.135]                 old_names <- names(...future.oldEnvVars)
[16:01:50.135]                 envs <- base::Sys.getenv()
[16:01:50.135]                 names <- names(envs)
[16:01:50.135]                 common <- intersect(names, old_names)
[16:01:50.135]                 added <- setdiff(names, old_names)
[16:01:50.135]                 removed <- setdiff(old_names, names)
[16:01:50.135]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:50.135]                   envs[common]]
[16:01:50.135]                 NAMES <- toupper(changed)
[16:01:50.135]                 args <- list()
[16:01:50.135]                 for (kk in seq_along(NAMES)) {
[16:01:50.135]                   name <- changed[[kk]]
[16:01:50.135]                   NAME <- NAMES[[kk]]
[16:01:50.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.135]                     next
[16:01:50.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.135]                 }
[16:01:50.135]                 NAMES <- toupper(added)
[16:01:50.135]                 for (kk in seq_along(NAMES)) {
[16:01:50.135]                   name <- added[[kk]]
[16:01:50.135]                   NAME <- NAMES[[kk]]
[16:01:50.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.135]                     next
[16:01:50.135]                   args[[name]] <- ""
[16:01:50.135]                 }
[16:01:50.135]                 NAMES <- toupper(removed)
[16:01:50.135]                 for (kk in seq_along(NAMES)) {
[16:01:50.135]                   name <- removed[[kk]]
[16:01:50.135]                   NAME <- NAMES[[kk]]
[16:01:50.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.135]                     next
[16:01:50.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.135]                 }
[16:01:50.135]                 if (length(args) > 0) 
[16:01:50.135]                   base::do.call(base::Sys.setenv, args = args)
[16:01:50.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:50.135]             }
[16:01:50.135]             else {
[16:01:50.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:50.135]             }
[16:01:50.135]             {
[16:01:50.135]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:50.135]                   0L) {
[16:01:50.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:50.135]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:50.135]                   base::options(opts)
[16:01:50.135]                 }
[16:01:50.135]                 {
[16:01:50.135]                   {
[16:01:50.135]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:50.135]                     NULL
[16:01:50.135]                   }
[16:01:50.135]                   options(future.plan = NULL)
[16:01:50.135]                   if (is.na(NA_character_)) 
[16:01:50.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:50.135]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:50.135]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:50.135]                     envir = parent.frame()) 
[16:01:50.135]                   {
[16:01:50.135]                     if (is.function(workers)) 
[16:01:50.135]                       workers <- workers()
[16:01:50.135]                     workers <- structure(as.integer(workers), 
[16:01:50.135]                       class = class(workers))
[16:01:50.135]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:50.135]                       workers >= 1)
[16:01:50.135]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:50.135]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:50.135]                     }
[16:01:50.135]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:50.135]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:50.135]                       envir = envir)
[16:01:50.135]                     if (!future$lazy) 
[16:01:50.135]                       future <- run(future)
[16:01:50.135]                     invisible(future)
[16:01:50.135]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:50.135]                 }
[16:01:50.135]             }
[16:01:50.135]         }
[16:01:50.135]     })
[16:01:50.135]     if (TRUE) {
[16:01:50.135]         base::sink(type = "output", split = FALSE)
[16:01:50.135]         if (TRUE) {
[16:01:50.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:50.135]         }
[16:01:50.135]         else {
[16:01:50.135]             ...future.result["stdout"] <- base::list(NULL)
[16:01:50.135]         }
[16:01:50.135]         base::close(...future.stdout)
[16:01:50.135]         ...future.stdout <- NULL
[16:01:50.135]     }
[16:01:50.135]     ...future.result$conditions <- ...future.conditions
[16:01:50.135]     ...future.result$finished <- base::Sys.time()
[16:01:50.135]     ...future.result
[16:01:50.135] }
[16:01:50.138] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:01:50.138] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:01:50.138] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:01:50.139] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:50.139] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:50.139] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:01:50.140] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:01:50.140] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:50.140] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:50.141] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:01:50.141] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:01:50.141] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:01:50.142] MultisessionFuture started
[16:01:50.142] - Launch lazy future ... done
[16:01:50.142] run() for ‘MultisessionFuture’ ... done
[16:01:50.142] Created future:
[16:01:50.142] MultisessionFuture:
[16:01:50.142] Label: ‘future_eapply-1’
[16:01:50.142] Expression:
[16:01:50.142] {
[16:01:50.142]     do.call(function(...) {
[16:01:50.142]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.142]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.142]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.142]             on.exit(options(oopts), add = TRUE)
[16:01:50.142]         }
[16:01:50.142]         {
[16:01:50.142]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.142]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.142]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.142]             })
[16:01:50.142]         }
[16:01:50.142]     }, args = future.call.arguments)
[16:01:50.142] }
[16:01:50.142] Lazy evaluation: FALSE
[16:01:50.142] Asynchronous evaluation: TRUE
[16:01:50.142] Local evaluation: TRUE
[16:01:50.142] Environment: R_GlobalEnv
[16:01:50.142] Capture standard output: TRUE
[16:01:50.142] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:50.142] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:50.142] Packages: <none>
[16:01:50.142] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:50.142] Resolved: FALSE
[16:01:50.142] Value: <not collected>
[16:01:50.142] Conditions captured: <none>
[16:01:50.142] Early signaling: FALSE
[16:01:50.142] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:50.142] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.155] Chunk #1 of 2 ... DONE
[16:01:50.155] Chunk #2 of 2 ...
[16:01:50.155]  - Finding globals in 'X' for chunk #2 ...
[16:01:50.155] getGlobalsAndPackages() ...
[16:01:50.155] Searching for globals...
[16:01:50.156] 
[16:01:50.156] Searching for globals ... DONE
[16:01:50.156] - globals: [0] <none>
[16:01:50.156] getGlobalsAndPackages() ... DONE
[16:01:50.156]    + additional globals found: [n=0] 
[16:01:50.156]    + additional namespaces needed: [n=0] 
[16:01:50.156]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:50.156]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:50.157]  - seeds: <none>
[16:01:50.157]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.157] getGlobalsAndPackages() ...
[16:01:50.157] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.157] Resolving globals: FALSE
[16:01:50.157] Tweak future expression to call with '...' arguments ...
[16:01:50.157] {
[16:01:50.157]     do.call(function(...) {
[16:01:50.157]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.157]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.157]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.157]             on.exit(options(oopts), add = TRUE)
[16:01:50.157]         }
[16:01:50.157]         {
[16:01:50.157]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.157]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.157]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.157]             })
[16:01:50.157]         }
[16:01:50.157]     }, args = future.call.arguments)
[16:01:50.157] }
[16:01:50.158] Tweak future expression to call with '...' arguments ... DONE
[16:01:50.158] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.158] 
[16:01:50.158] getGlobalsAndPackages() ... DONE
[16:01:50.159] run() for ‘Future’ ...
[16:01:50.159] - state: ‘created’
[16:01:50.159] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:50.173] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:50.174]   - Field: ‘node’
[16:01:50.174]   - Field: ‘label’
[16:01:50.174]   - Field: ‘local’
[16:01:50.174]   - Field: ‘owner’
[16:01:50.174]   - Field: ‘envir’
[16:01:50.174]   - Field: ‘workers’
[16:01:50.174]   - Field: ‘packages’
[16:01:50.174]   - Field: ‘gc’
[16:01:50.175]   - Field: ‘conditions’
[16:01:50.175]   - Field: ‘persistent’
[16:01:50.175]   - Field: ‘expr’
[16:01:50.175]   - Field: ‘uuid’
[16:01:50.175]   - Field: ‘seed’
[16:01:50.175]   - Field: ‘version’
[16:01:50.175]   - Field: ‘result’
[16:01:50.175]   - Field: ‘asynchronous’
[16:01:50.176]   - Field: ‘calls’
[16:01:50.176]   - Field: ‘globals’
[16:01:50.176]   - Field: ‘stdout’
[16:01:50.176]   - Field: ‘earlySignal’
[16:01:50.176]   - Field: ‘lazy’
[16:01:50.176]   - Field: ‘state’
[16:01:50.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:50.176] - Launch lazy future ...
[16:01:50.177] Packages needed by the future expression (n = 0): <none>
[16:01:50.177] Packages needed by future strategies (n = 0): <none>
[16:01:50.177] {
[16:01:50.177]     {
[16:01:50.177]         {
[16:01:50.177]             ...future.startTime <- base::Sys.time()
[16:01:50.177]             {
[16:01:50.177]                 {
[16:01:50.177]                   {
[16:01:50.177]                     {
[16:01:50.177]                       base::local({
[16:01:50.177]                         has_future <- base::requireNamespace("future", 
[16:01:50.177]                           quietly = TRUE)
[16:01:50.177]                         if (has_future) {
[16:01:50.177]                           ns <- base::getNamespace("future")
[16:01:50.177]                           version <- ns[[".package"]][["version"]]
[16:01:50.177]                           if (is.null(version)) 
[16:01:50.177]                             version <- utils::packageVersion("future")
[16:01:50.177]                         }
[16:01:50.177]                         else {
[16:01:50.177]                           version <- NULL
[16:01:50.177]                         }
[16:01:50.177]                         if (!has_future || version < "1.8.0") {
[16:01:50.177]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:50.177]                             "", base::R.version$version.string), 
[16:01:50.177]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:50.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:50.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:50.177]                               "release", "version")], collapse = " "), 
[16:01:50.177]                             hostname = base::Sys.info()[["nodename"]])
[16:01:50.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:50.177]                             info)
[16:01:50.177]                           info <- base::paste(info, collapse = "; ")
[16:01:50.177]                           if (!has_future) {
[16:01:50.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:50.177]                               info)
[16:01:50.177]                           }
[16:01:50.177]                           else {
[16:01:50.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:50.177]                               info, version)
[16:01:50.177]                           }
[16:01:50.177]                           base::stop(msg)
[16:01:50.177]                         }
[16:01:50.177]                       })
[16:01:50.177]                     }
[16:01:50.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:50.177]                     base::options(mc.cores = 1L)
[16:01:50.177]                   }
[16:01:50.177]                   options(future.plan = NULL)
[16:01:50.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:50.177]                 }
[16:01:50.177]                 ...future.workdir <- getwd()
[16:01:50.177]             }
[16:01:50.177]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:50.177]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:50.177]         }
[16:01:50.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:50.177]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:50.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:50.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:50.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:50.177]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:50.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:50.177]             base::names(...future.oldOptions))
[16:01:50.177]     }
[16:01:50.177]     if (FALSE) {
[16:01:50.177]     }
[16:01:50.177]     else {
[16:01:50.177]         if (TRUE) {
[16:01:50.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:50.177]                 open = "w")
[16:01:50.177]         }
[16:01:50.177]         else {
[16:01:50.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:50.177]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:50.177]         }
[16:01:50.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:50.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:50.177]             base::sink(type = "output", split = FALSE)
[16:01:50.177]             base::close(...future.stdout)
[16:01:50.177]         }, add = TRUE)
[16:01:50.177]     }
[16:01:50.177]     ...future.frame <- base::sys.nframe()
[16:01:50.177]     ...future.conditions <- base::list()
[16:01:50.177]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:50.177]     if (FALSE) {
[16:01:50.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:50.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:50.177]     }
[16:01:50.177]     ...future.result <- base::tryCatch({
[16:01:50.177]         base::withCallingHandlers({
[16:01:50.177]             ...future.value <- base::withVisible(base::local({
[16:01:50.177]                 ...future.makeSendCondition <- base::local({
[16:01:50.177]                   sendCondition <- NULL
[16:01:50.177]                   function(frame = 1L) {
[16:01:50.177]                     if (is.function(sendCondition)) 
[16:01:50.177]                       return(sendCondition)
[16:01:50.177]                     ns <- getNamespace("parallel")
[16:01:50.177]                     if (exists("sendData", mode = "function", 
[16:01:50.177]                       envir = ns)) {
[16:01:50.177]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:50.177]                         envir = ns)
[16:01:50.177]                       envir <- sys.frame(frame)
[16:01:50.177]                       master <- NULL
[16:01:50.177]                       while (!identical(envir, .GlobalEnv) && 
[16:01:50.177]                         !identical(envir, emptyenv())) {
[16:01:50.177]                         if (exists("master", mode = "list", envir = envir, 
[16:01:50.177]                           inherits = FALSE)) {
[16:01:50.177]                           master <- get("master", mode = "list", 
[16:01:50.177]                             envir = envir, inherits = FALSE)
[16:01:50.177]                           if (inherits(master, c("SOCKnode", 
[16:01:50.177]                             "SOCK0node"))) {
[16:01:50.177]                             sendCondition <<- function(cond) {
[16:01:50.177]                               data <- list(type = "VALUE", value = cond, 
[16:01:50.177]                                 success = TRUE)
[16:01:50.177]                               parallel_sendData(master, data)
[16:01:50.177]                             }
[16:01:50.177]                             return(sendCondition)
[16:01:50.177]                           }
[16:01:50.177]                         }
[16:01:50.177]                         frame <- frame + 1L
[16:01:50.177]                         envir <- sys.frame(frame)
[16:01:50.177]                       }
[16:01:50.177]                     }
[16:01:50.177]                     sendCondition <<- function(cond) NULL
[16:01:50.177]                   }
[16:01:50.177]                 })
[16:01:50.177]                 withCallingHandlers({
[16:01:50.177]                   {
[16:01:50.177]                     do.call(function(...) {
[16:01:50.177]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.177]                       if (!identical(...future.globals.maxSize.org, 
[16:01:50.177]                         ...future.globals.maxSize)) {
[16:01:50.177]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.177]                         on.exit(options(oopts), add = TRUE)
[16:01:50.177]                       }
[16:01:50.177]                       {
[16:01:50.177]                         lapply(seq_along(...future.elements_ii), 
[16:01:50.177]                           FUN = function(jj) {
[16:01:50.177]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.177]                             ...future.FUN(...future.X_jj, ...)
[16:01:50.177]                           })
[16:01:50.177]                       }
[16:01:50.177]                     }, args = future.call.arguments)
[16:01:50.177]                   }
[16:01:50.177]                 }, immediateCondition = function(cond) {
[16:01:50.177]                   sendCondition <- ...future.makeSendCondition()
[16:01:50.177]                   sendCondition(cond)
[16:01:50.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.177]                   {
[16:01:50.177]                     inherits <- base::inherits
[16:01:50.177]                     invokeRestart <- base::invokeRestart
[16:01:50.177]                     is.null <- base::is.null
[16:01:50.177]                     muffled <- FALSE
[16:01:50.177]                     if (inherits(cond, "message")) {
[16:01:50.177]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:50.177]                       if (muffled) 
[16:01:50.177]                         invokeRestart("muffleMessage")
[16:01:50.177]                     }
[16:01:50.177]                     else if (inherits(cond, "warning")) {
[16:01:50.177]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:50.177]                       if (muffled) 
[16:01:50.177]                         invokeRestart("muffleWarning")
[16:01:50.177]                     }
[16:01:50.177]                     else if (inherits(cond, "condition")) {
[16:01:50.177]                       if (!is.null(pattern)) {
[16:01:50.177]                         computeRestarts <- base::computeRestarts
[16:01:50.177]                         grepl <- base::grepl
[16:01:50.177]                         restarts <- computeRestarts(cond)
[16:01:50.177]                         for (restart in restarts) {
[16:01:50.177]                           name <- restart$name
[16:01:50.177]                           if (is.null(name)) 
[16:01:50.177]                             next
[16:01:50.177]                           if (!grepl(pattern, name)) 
[16:01:50.177]                             next
[16:01:50.177]                           invokeRestart(restart)
[16:01:50.177]                           muffled <- TRUE
[16:01:50.177]                           break
[16:01:50.177]                         }
[16:01:50.177]                       }
[16:01:50.177]                     }
[16:01:50.177]                     invisible(muffled)
[16:01:50.177]                   }
[16:01:50.177]                   muffleCondition(cond)
[16:01:50.177]                 })
[16:01:50.177]             }))
[16:01:50.177]             future::FutureResult(value = ...future.value$value, 
[16:01:50.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.177]                   ...future.rng), globalenv = if (FALSE) 
[16:01:50.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:50.177]                     ...future.globalenv.names))
[16:01:50.177]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:50.177]         }, condition = base::local({
[16:01:50.177]             c <- base::c
[16:01:50.177]             inherits <- base::inherits
[16:01:50.177]             invokeRestart <- base::invokeRestart
[16:01:50.177]             length <- base::length
[16:01:50.177]             list <- base::list
[16:01:50.177]             seq.int <- base::seq.int
[16:01:50.177]             signalCondition <- base::signalCondition
[16:01:50.177]             sys.calls <- base::sys.calls
[16:01:50.177]             `[[` <- base::`[[`
[16:01:50.177]             `+` <- base::`+`
[16:01:50.177]             `<<-` <- base::`<<-`
[16:01:50.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:50.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:50.177]                   3L)]
[16:01:50.177]             }
[16:01:50.177]             function(cond) {
[16:01:50.177]                 is_error <- inherits(cond, "error")
[16:01:50.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:50.177]                   NULL)
[16:01:50.177]                 if (is_error) {
[16:01:50.177]                   sessionInformation <- function() {
[16:01:50.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:50.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:50.177]                       search = base::search(), system = base::Sys.info())
[16:01:50.177]                   }
[16:01:50.177]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:50.177]                     cond$call), session = sessionInformation(), 
[16:01:50.177]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:50.177]                   signalCondition(cond)
[16:01:50.177]                 }
[16:01:50.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:50.177]                 "immediateCondition"))) {
[16:01:50.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:50.177]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:50.177]                   if (TRUE && !signal) {
[16:01:50.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.177]                     {
[16:01:50.177]                       inherits <- base::inherits
[16:01:50.177]                       invokeRestart <- base::invokeRestart
[16:01:50.177]                       is.null <- base::is.null
[16:01:50.177]                       muffled <- FALSE
[16:01:50.177]                       if (inherits(cond, "message")) {
[16:01:50.177]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.177]                         if (muffled) 
[16:01:50.177]                           invokeRestart("muffleMessage")
[16:01:50.177]                       }
[16:01:50.177]                       else if (inherits(cond, "warning")) {
[16:01:50.177]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.177]                         if (muffled) 
[16:01:50.177]                           invokeRestart("muffleWarning")
[16:01:50.177]                       }
[16:01:50.177]                       else if (inherits(cond, "condition")) {
[16:01:50.177]                         if (!is.null(pattern)) {
[16:01:50.177]                           computeRestarts <- base::computeRestarts
[16:01:50.177]                           grepl <- base::grepl
[16:01:50.177]                           restarts <- computeRestarts(cond)
[16:01:50.177]                           for (restart in restarts) {
[16:01:50.177]                             name <- restart$name
[16:01:50.177]                             if (is.null(name)) 
[16:01:50.177]                               next
[16:01:50.177]                             if (!grepl(pattern, name)) 
[16:01:50.177]                               next
[16:01:50.177]                             invokeRestart(restart)
[16:01:50.177]                             muffled <- TRUE
[16:01:50.177]                             break
[16:01:50.177]                           }
[16:01:50.177]                         }
[16:01:50.177]                       }
[16:01:50.177]                       invisible(muffled)
[16:01:50.177]                     }
[16:01:50.177]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.177]                   }
[16:01:50.177]                 }
[16:01:50.177]                 else {
[16:01:50.177]                   if (TRUE) {
[16:01:50.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.177]                     {
[16:01:50.177]                       inherits <- base::inherits
[16:01:50.177]                       invokeRestart <- base::invokeRestart
[16:01:50.177]                       is.null <- base::is.null
[16:01:50.177]                       muffled <- FALSE
[16:01:50.177]                       if (inherits(cond, "message")) {
[16:01:50.177]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.177]                         if (muffled) 
[16:01:50.177]                           invokeRestart("muffleMessage")
[16:01:50.177]                       }
[16:01:50.177]                       else if (inherits(cond, "warning")) {
[16:01:50.177]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.177]                         if (muffled) 
[16:01:50.177]                           invokeRestart("muffleWarning")
[16:01:50.177]                       }
[16:01:50.177]                       else if (inherits(cond, "condition")) {
[16:01:50.177]                         if (!is.null(pattern)) {
[16:01:50.177]                           computeRestarts <- base::computeRestarts
[16:01:50.177]                           grepl <- base::grepl
[16:01:50.177]                           restarts <- computeRestarts(cond)
[16:01:50.177]                           for (restart in restarts) {
[16:01:50.177]                             name <- restart$name
[16:01:50.177]                             if (is.null(name)) 
[16:01:50.177]                               next
[16:01:50.177]                             if (!grepl(pattern, name)) 
[16:01:50.177]                               next
[16:01:50.177]                             invokeRestart(restart)
[16:01:50.177]                             muffled <- TRUE
[16:01:50.177]                             break
[16:01:50.177]                           }
[16:01:50.177]                         }
[16:01:50.177]                       }
[16:01:50.177]                       invisible(muffled)
[16:01:50.177]                     }
[16:01:50.177]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.177]                   }
[16:01:50.177]                 }
[16:01:50.177]             }
[16:01:50.177]         }))
[16:01:50.177]     }, error = function(ex) {
[16:01:50.177]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:50.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.177]                 ...future.rng), started = ...future.startTime, 
[16:01:50.177]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:50.177]             version = "1.8"), class = "FutureResult")
[16:01:50.177]     }, finally = {
[16:01:50.177]         if (!identical(...future.workdir, getwd())) 
[16:01:50.177]             setwd(...future.workdir)
[16:01:50.177]         {
[16:01:50.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:50.177]                 ...future.oldOptions$nwarnings <- NULL
[16:01:50.177]             }
[16:01:50.177]             base::options(...future.oldOptions)
[16:01:50.177]             if (.Platform$OS.type == "windows") {
[16:01:50.177]                 old_names <- names(...future.oldEnvVars)
[16:01:50.177]                 envs <- base::Sys.getenv()
[16:01:50.177]                 names <- names(envs)
[16:01:50.177]                 common <- intersect(names, old_names)
[16:01:50.177]                 added <- setdiff(names, old_names)
[16:01:50.177]                 removed <- setdiff(old_names, names)
[16:01:50.177]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:50.177]                   envs[common]]
[16:01:50.177]                 NAMES <- toupper(changed)
[16:01:50.177]                 args <- list()
[16:01:50.177]                 for (kk in seq_along(NAMES)) {
[16:01:50.177]                   name <- changed[[kk]]
[16:01:50.177]                   NAME <- NAMES[[kk]]
[16:01:50.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.177]                     next
[16:01:50.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.177]                 }
[16:01:50.177]                 NAMES <- toupper(added)
[16:01:50.177]                 for (kk in seq_along(NAMES)) {
[16:01:50.177]                   name <- added[[kk]]
[16:01:50.177]                   NAME <- NAMES[[kk]]
[16:01:50.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.177]                     next
[16:01:50.177]                   args[[name]] <- ""
[16:01:50.177]                 }
[16:01:50.177]                 NAMES <- toupper(removed)
[16:01:50.177]                 for (kk in seq_along(NAMES)) {
[16:01:50.177]                   name <- removed[[kk]]
[16:01:50.177]                   NAME <- NAMES[[kk]]
[16:01:50.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.177]                     next
[16:01:50.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.177]                 }
[16:01:50.177]                 if (length(args) > 0) 
[16:01:50.177]                   base::do.call(base::Sys.setenv, args = args)
[16:01:50.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:50.177]             }
[16:01:50.177]             else {
[16:01:50.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:50.177]             }
[16:01:50.177]             {
[16:01:50.177]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:50.177]                   0L) {
[16:01:50.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:50.177]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:50.177]                   base::options(opts)
[16:01:50.177]                 }
[16:01:50.177]                 {
[16:01:50.177]                   {
[16:01:50.177]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:50.177]                     NULL
[16:01:50.177]                   }
[16:01:50.177]                   options(future.plan = NULL)
[16:01:50.177]                   if (is.na(NA_character_)) 
[16:01:50.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:50.177]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:50.177]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:50.177]                     envir = parent.frame()) 
[16:01:50.177]                   {
[16:01:50.177]                     if (is.function(workers)) 
[16:01:50.177]                       workers <- workers()
[16:01:50.177]                     workers <- structure(as.integer(workers), 
[16:01:50.177]                       class = class(workers))
[16:01:50.177]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:50.177]                       workers >= 1)
[16:01:50.177]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:50.177]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:50.177]                     }
[16:01:50.177]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:50.177]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:50.177]                       envir = envir)
[16:01:50.177]                     if (!future$lazy) 
[16:01:50.177]                       future <- run(future)
[16:01:50.177]                     invisible(future)
[16:01:50.177]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:50.177]                 }
[16:01:50.177]             }
[16:01:50.177]         }
[16:01:50.177]     })
[16:01:50.177]     if (TRUE) {
[16:01:50.177]         base::sink(type = "output", split = FALSE)
[16:01:50.177]         if (TRUE) {
[16:01:50.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:50.177]         }
[16:01:50.177]         else {
[16:01:50.177]             ...future.result["stdout"] <- base::list(NULL)
[16:01:50.177]         }
[16:01:50.177]         base::close(...future.stdout)
[16:01:50.177]         ...future.stdout <- NULL
[16:01:50.177]     }
[16:01:50.177]     ...future.result$conditions <- ...future.conditions
[16:01:50.177]     ...future.result$finished <- base::Sys.time()
[16:01:50.177]     ...future.result
[16:01:50.177] }
[16:01:50.232] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:01:50.232] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:01:50.233] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:01:50.233] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:50.233] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:50.233] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:01:50.234] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:01:50.234] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:50.235] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:50.235] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:01:50.235] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:01:50.235] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:01:50.236] MultisessionFuture started
[16:01:50.236] - Launch lazy future ... done
[16:01:50.236] run() for ‘MultisessionFuture’ ... done
[16:01:50.237] Created future:
[16:01:50.237] MultisessionFuture:
[16:01:50.237] Label: ‘future_eapply-2’
[16:01:50.237] Expression:
[16:01:50.237] {
[16:01:50.237]     do.call(function(...) {
[16:01:50.237]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.237]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.237]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.237]             on.exit(options(oopts), add = TRUE)
[16:01:50.237]         }
[16:01:50.237]         {
[16:01:50.237]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.237]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.237]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.237]             })
[16:01:50.237]         }
[16:01:50.237]     }, args = future.call.arguments)
[16:01:50.237] }
[16:01:50.237] Lazy evaluation: FALSE
[16:01:50.237] Asynchronous evaluation: TRUE
[16:01:50.237] Local evaluation: TRUE
[16:01:50.237] Environment: R_GlobalEnv
[16:01:50.237] Capture standard output: TRUE
[16:01:50.237] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:50.237] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:50.237] Packages: <none>
[16:01:50.237] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:50.237] Resolved: FALSE
[16:01:50.237] Value: <not collected>
[16:01:50.237] Conditions captured: <none>
[16:01:50.237] Early signaling: FALSE
[16:01:50.237] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:50.237] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.249] Chunk #2 of 2 ... DONE
[16:01:50.249] Launching 2 futures (chunks) ... DONE
[16:01:50.249] Resolving 2 futures (chunks) ...
[16:01:50.249] resolve() on list ...
[16:01:50.249]  recursive: 0
[16:01:50.249]  length: 2
[16:01:50.249] 
[16:01:50.250] receiveMessageFromWorker() for ClusterFuture ...
[16:01:50.250] - Validating connection of MultisessionFuture
[16:01:50.250] - received message: FutureResult
[16:01:50.250] - Received FutureResult
[16:01:50.251] - Erased future from FutureRegistry
[16:01:50.251] result() for ClusterFuture ...
[16:01:50.251] - result already collected: FutureResult
[16:01:50.251] result() for ClusterFuture ... done
[16:01:50.251] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:50.251] Future #1
[16:01:50.251] result() for ClusterFuture ...
[16:01:50.255] - result already collected: FutureResult
[16:01:50.255] result() for ClusterFuture ... done
[16:01:50.256] result() for ClusterFuture ...
[16:01:50.256] - result already collected: FutureResult
[16:01:50.256] result() for ClusterFuture ... done
[16:01:50.256] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:50.256] - nx: 2
[16:01:50.256] - relay: TRUE
[16:01:50.256] - stdout: TRUE
[16:01:50.256] - signal: TRUE
[16:01:50.256] - resignal: FALSE
[16:01:50.256] - force: TRUE
[16:01:50.256] - relayed: [n=2] FALSE, FALSE
[16:01:50.256] - queued futures: [n=2] FALSE, FALSE
[16:01:50.257]  - until=1
[16:01:50.257]  - relaying element #1
[16:01:50.257] result() for ClusterFuture ...
[16:01:50.257] - result already collected: FutureResult
[16:01:50.257] result() for ClusterFuture ... done
[16:01:50.257] result() for ClusterFuture ...
[16:01:50.257] - result already collected: FutureResult
[16:01:50.257] result() for ClusterFuture ... done
[16:01:50.257] result() for ClusterFuture ...
[16:01:50.257] - result already collected: FutureResult
[16:01:50.257] result() for ClusterFuture ... done
[16:01:50.258] result() for ClusterFuture ...
[16:01:50.258] - result already collected: FutureResult
[16:01:50.258] result() for ClusterFuture ... done
[16:01:50.258] - relayed: [n=2] TRUE, FALSE
[16:01:50.258] - queued futures: [n=2] TRUE, FALSE
[16:01:50.258] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:50.258]  length: 1 (resolved future 1)
[16:01:50.324] receiveMessageFromWorker() for ClusterFuture ...
[16:01:50.325] - Validating connection of MultisessionFuture
[16:01:50.325] - received message: FutureResult
[16:01:50.325] - Received FutureResult
[16:01:50.325] - Erased future from FutureRegistry
[16:01:50.325] result() for ClusterFuture ...
[16:01:50.325] - result already collected: FutureResult
[16:01:50.325] result() for ClusterFuture ... done
[16:01:50.325] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:50.326] Future #2
[16:01:50.326] result() for ClusterFuture ...
[16:01:50.326] - result already collected: FutureResult
[16:01:50.326] result() for ClusterFuture ... done
[16:01:50.326] result() for ClusterFuture ...
[16:01:50.326] - result already collected: FutureResult
[16:01:50.326] result() for ClusterFuture ... done
[16:01:50.326] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:50.326] - nx: 2
[16:01:50.326] - relay: TRUE
[16:01:50.326] - stdout: TRUE
[16:01:50.326] - signal: TRUE
[16:01:50.327] - resignal: FALSE
[16:01:50.327] - force: TRUE
[16:01:50.327] - relayed: [n=2] TRUE, FALSE
[16:01:50.327] - queued futures: [n=2] TRUE, FALSE
[16:01:50.327]  - until=2
[16:01:50.327]  - relaying element #2
[16:01:50.327] result() for ClusterFuture ...
[16:01:50.327] - result already collected: FutureResult
[16:01:50.327] result() for ClusterFuture ... done
[16:01:50.327] result() for ClusterFuture ...
[16:01:50.327] - result already collected: FutureResult
[16:01:50.328] result() for ClusterFuture ... done
[16:01:50.328] result() for ClusterFuture ...
[16:01:50.328] - result already collected: FutureResult
[16:01:50.328] result() for ClusterFuture ... done
[16:01:50.328] result() for ClusterFuture ...
[16:01:50.328] - result already collected: FutureResult
[16:01:50.328] result() for ClusterFuture ... done
[16:01:50.328] - relayed: [n=2] TRUE, TRUE
[16:01:50.328] - queued futures: [n=2] TRUE, TRUE
[16:01:50.328] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:50.328]  length: 0 (resolved future 2)
[16:01:50.329] Relaying remaining futures
[16:01:50.329] signalConditionsASAP(NULL, pos=0) ...
[16:01:50.329] - nx: 2
[16:01:50.329] - relay: TRUE
[16:01:50.329] - stdout: TRUE
[16:01:50.329] - signal: TRUE
[16:01:50.329] - resignal: FALSE
[16:01:50.329] - force: TRUE
[16:01:50.329] - relayed: [n=2] TRUE, TRUE
[16:01:50.329] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:50.329] - relayed: [n=2] TRUE, TRUE
[16:01:50.329] - queued futures: [n=2] TRUE, TRUE
[16:01:50.330] signalConditionsASAP(NULL, pos=0) ... done
[16:01:50.330] resolve() on list ... DONE
[16:01:50.330] result() for ClusterFuture ...
[16:01:50.330] - result already collected: FutureResult
[16:01:50.330] result() for ClusterFuture ... done
[16:01:50.330] result() for ClusterFuture ...
[16:01:50.330] - result already collected: FutureResult
[16:01:50.330] result() for ClusterFuture ... done
[16:01:50.330] result() for ClusterFuture ...
[16:01:50.330] - result already collected: FutureResult
[16:01:50.330] result() for ClusterFuture ... done
[16:01:50.330] result() for ClusterFuture ...
[16:01:50.331] - result already collected: FutureResult
[16:01:50.331] result() for ClusterFuture ... done
[16:01:50.331]  - Number of value chunks collected: 2
[16:01:50.331] Resolving 2 futures (chunks) ... DONE
[16:01:50.331] Reducing values from 2 chunks ...
[16:01:50.331]  - Number of values collected after concatenation: 3
[16:01:50.331]  - Number of values expected: 3
[16:01:50.331] Reducing values from 2 chunks ... DONE
[16:01:50.331] future_lapply() ... DONE
[16:01:50.332] future_lapply() ...
[16:01:50.336] Number of chunks: 2
[16:01:50.336] getGlobalsAndPackagesXApply() ...
[16:01:50.336]  - future.globals: TRUE
[16:01:50.336] getGlobalsAndPackages() ...
[16:01:50.336] Searching for globals...
[16:01:50.337] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:50.338] Searching for globals ... DONE
[16:01:50.338] Resolving globals: FALSE
[16:01:50.338] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:50.338] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:50.338] - globals: [1] ‘FUN’
[16:01:50.339] - packages: [1] ‘stats’
[16:01:50.339] getGlobalsAndPackages() ... DONE
[16:01:50.339]  - globals found/used: [n=1] ‘FUN’
[16:01:50.339]  - needed namespaces: [n=1] ‘stats’
[16:01:50.339] Finding globals ... DONE
[16:01:50.339]  - use_args: TRUE
[16:01:50.339]  - Getting '...' globals ...
[16:01:50.340] resolve() on list ...
[16:01:50.340]  recursive: 0
[16:01:50.340]  length: 1
[16:01:50.340]  elements: ‘...’
[16:01:50.340]  length: 0 (resolved future 1)
[16:01:50.340] resolve() on list ... DONE
[16:01:50.340]    - '...' content: [n=1] ‘probs’
[16:01:50.340] List of 1
[16:01:50.340]  $ ...:List of 1
[16:01:50.340]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:01:50.340]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:50.340]  - attr(*, "where")=List of 1
[16:01:50.340]   ..$ ...:<environment: 0x5620a19709c8> 
[16:01:50.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:50.340]  - attr(*, "resolved")= logi TRUE
[16:01:50.340]  - attr(*, "total_size")= num NA
[16:01:50.343]  - Getting '...' globals ... DONE
[16:01:50.343] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:50.344] List of 2
[16:01:50.344]  $ ...future.FUN:function (x, ...)  
[16:01:50.344]  $ ...          :List of 1
[16:01:50.344]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:01:50.344]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:50.344]  - attr(*, "where")=List of 2
[16:01:50.344]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:50.344]   ..$ ...          :<environment: 0x5620a19709c8> 
[16:01:50.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:50.344]  - attr(*, "resolved")= logi FALSE
[16:01:50.344]  - attr(*, "total_size")= num 1328
[16:01:50.347] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:50.347] getGlobalsAndPackagesXApply() ... DONE
[16:01:50.347] Number of futures (= number of chunks): 2
[16:01:50.347] Launching 2 futures (chunks) ...
[16:01:50.347] Chunk #1 of 2 ...
[16:01:50.347]  - Finding globals in 'X' for chunk #1 ...
[16:01:50.347] getGlobalsAndPackages() ...
[16:01:50.347] Searching for globals...
[16:01:50.348] 
[16:01:50.348] Searching for globals ... DONE
[16:01:50.348] - globals: [0] <none>
[16:01:50.348] getGlobalsAndPackages() ... DONE
[16:01:50.348]    + additional globals found: [n=0] 
[16:01:50.348]    + additional namespaces needed: [n=0] 
[16:01:50.348]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:50.348]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:50.348]  - seeds: <none>
[16:01:50.348]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.349] getGlobalsAndPackages() ...
[16:01:50.349] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.349] Resolving globals: FALSE
[16:01:50.349] Tweak future expression to call with '...' arguments ...
[16:01:50.349] {
[16:01:50.349]     do.call(function(...) {
[16:01:50.349]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.349]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.349]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.349]             on.exit(options(oopts), add = TRUE)
[16:01:50.349]         }
[16:01:50.349]         {
[16:01:50.349]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.349]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.349]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.349]             })
[16:01:50.349]         }
[16:01:50.349]     }, args = future.call.arguments)
[16:01:50.349] }
[16:01:50.349] Tweak future expression to call with '...' arguments ... DONE
[16:01:50.350] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.350] - packages: [1] ‘stats’
[16:01:50.350] getGlobalsAndPackages() ... DONE
[16:01:50.350] run() for ‘Future’ ...
[16:01:50.350] - state: ‘created’
[16:01:50.350] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:50.364] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.364] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:50.364]   - Field: ‘node’
[16:01:50.364]   - Field: ‘label’
[16:01:50.364]   - Field: ‘local’
[16:01:50.365]   - Field: ‘owner’
[16:01:50.365]   - Field: ‘envir’
[16:01:50.365]   - Field: ‘workers’
[16:01:50.365]   - Field: ‘packages’
[16:01:50.365]   - Field: ‘gc’
[16:01:50.365]   - Field: ‘conditions’
[16:01:50.365]   - Field: ‘persistent’
[16:01:50.365]   - Field: ‘expr’
[16:01:50.365]   - Field: ‘uuid’
[16:01:50.365]   - Field: ‘seed’
[16:01:50.366]   - Field: ‘version’
[16:01:50.366]   - Field: ‘result’
[16:01:50.366]   - Field: ‘asynchronous’
[16:01:50.366]   - Field: ‘calls’
[16:01:50.366]   - Field: ‘globals’
[16:01:50.366]   - Field: ‘stdout’
[16:01:50.366]   - Field: ‘earlySignal’
[16:01:50.366]   - Field: ‘lazy’
[16:01:50.366]   - Field: ‘state’
[16:01:50.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:50.366] - Launch lazy future ...
[16:01:50.367] Packages needed by the future expression (n = 1): ‘stats’
[16:01:50.367] Packages needed by future strategies (n = 0): <none>
[16:01:50.367] {
[16:01:50.367]     {
[16:01:50.367]         {
[16:01:50.367]             ...future.startTime <- base::Sys.time()
[16:01:50.367]             {
[16:01:50.367]                 {
[16:01:50.367]                   {
[16:01:50.367]                     {
[16:01:50.367]                       {
[16:01:50.367]                         base::local({
[16:01:50.367]                           has_future <- base::requireNamespace("future", 
[16:01:50.367]                             quietly = TRUE)
[16:01:50.367]                           if (has_future) {
[16:01:50.367]                             ns <- base::getNamespace("future")
[16:01:50.367]                             version <- ns[[".package"]][["version"]]
[16:01:50.367]                             if (is.null(version)) 
[16:01:50.367]                               version <- utils::packageVersion("future")
[16:01:50.367]                           }
[16:01:50.367]                           else {
[16:01:50.367]                             version <- NULL
[16:01:50.367]                           }
[16:01:50.367]                           if (!has_future || version < "1.8.0") {
[16:01:50.367]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:50.367]                               "", base::R.version$version.string), 
[16:01:50.367]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:50.367]                                 base::R.version$platform, 8 * 
[16:01:50.367]                                   base::.Machine$sizeof.pointer), 
[16:01:50.367]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:50.367]                                 "release", "version")], collapse = " "), 
[16:01:50.367]                               hostname = base::Sys.info()[["nodename"]])
[16:01:50.367]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:50.367]                               info)
[16:01:50.367]                             info <- base::paste(info, collapse = "; ")
[16:01:50.367]                             if (!has_future) {
[16:01:50.367]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:50.367]                                 info)
[16:01:50.367]                             }
[16:01:50.367]                             else {
[16:01:50.367]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:50.367]                                 info, version)
[16:01:50.367]                             }
[16:01:50.367]                             base::stop(msg)
[16:01:50.367]                           }
[16:01:50.367]                         })
[16:01:50.367]                       }
[16:01:50.367]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:50.367]                       base::options(mc.cores = 1L)
[16:01:50.367]                     }
[16:01:50.367]                     base::local({
[16:01:50.367]                       for (pkg in "stats") {
[16:01:50.367]                         base::loadNamespace(pkg)
[16:01:50.367]                         base::library(pkg, character.only = TRUE)
[16:01:50.367]                       }
[16:01:50.367]                     })
[16:01:50.367]                   }
[16:01:50.367]                   options(future.plan = NULL)
[16:01:50.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:50.367]                 }
[16:01:50.367]                 ...future.workdir <- getwd()
[16:01:50.367]             }
[16:01:50.367]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:50.367]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:50.367]         }
[16:01:50.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:50.367]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:50.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:50.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:50.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:50.367]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:50.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:50.367]             base::names(...future.oldOptions))
[16:01:50.367]     }
[16:01:50.367]     if (FALSE) {
[16:01:50.367]     }
[16:01:50.367]     else {
[16:01:50.367]         if (TRUE) {
[16:01:50.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:50.367]                 open = "w")
[16:01:50.367]         }
[16:01:50.367]         else {
[16:01:50.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:50.367]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:50.367]         }
[16:01:50.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:50.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:50.367]             base::sink(type = "output", split = FALSE)
[16:01:50.367]             base::close(...future.stdout)
[16:01:50.367]         }, add = TRUE)
[16:01:50.367]     }
[16:01:50.367]     ...future.frame <- base::sys.nframe()
[16:01:50.367]     ...future.conditions <- base::list()
[16:01:50.367]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:50.367]     if (FALSE) {
[16:01:50.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:50.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:50.367]     }
[16:01:50.367]     ...future.result <- base::tryCatch({
[16:01:50.367]         base::withCallingHandlers({
[16:01:50.367]             ...future.value <- base::withVisible(base::local({
[16:01:50.367]                 ...future.makeSendCondition <- base::local({
[16:01:50.367]                   sendCondition <- NULL
[16:01:50.367]                   function(frame = 1L) {
[16:01:50.367]                     if (is.function(sendCondition)) 
[16:01:50.367]                       return(sendCondition)
[16:01:50.367]                     ns <- getNamespace("parallel")
[16:01:50.367]                     if (exists("sendData", mode = "function", 
[16:01:50.367]                       envir = ns)) {
[16:01:50.367]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:50.367]                         envir = ns)
[16:01:50.367]                       envir <- sys.frame(frame)
[16:01:50.367]                       master <- NULL
[16:01:50.367]                       while (!identical(envir, .GlobalEnv) && 
[16:01:50.367]                         !identical(envir, emptyenv())) {
[16:01:50.367]                         if (exists("master", mode = "list", envir = envir, 
[16:01:50.367]                           inherits = FALSE)) {
[16:01:50.367]                           master <- get("master", mode = "list", 
[16:01:50.367]                             envir = envir, inherits = FALSE)
[16:01:50.367]                           if (inherits(master, c("SOCKnode", 
[16:01:50.367]                             "SOCK0node"))) {
[16:01:50.367]                             sendCondition <<- function(cond) {
[16:01:50.367]                               data <- list(type = "VALUE", value = cond, 
[16:01:50.367]                                 success = TRUE)
[16:01:50.367]                               parallel_sendData(master, data)
[16:01:50.367]                             }
[16:01:50.367]                             return(sendCondition)
[16:01:50.367]                           }
[16:01:50.367]                         }
[16:01:50.367]                         frame <- frame + 1L
[16:01:50.367]                         envir <- sys.frame(frame)
[16:01:50.367]                       }
[16:01:50.367]                     }
[16:01:50.367]                     sendCondition <<- function(cond) NULL
[16:01:50.367]                   }
[16:01:50.367]                 })
[16:01:50.367]                 withCallingHandlers({
[16:01:50.367]                   {
[16:01:50.367]                     do.call(function(...) {
[16:01:50.367]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.367]                       if (!identical(...future.globals.maxSize.org, 
[16:01:50.367]                         ...future.globals.maxSize)) {
[16:01:50.367]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.367]                         on.exit(options(oopts), add = TRUE)
[16:01:50.367]                       }
[16:01:50.367]                       {
[16:01:50.367]                         lapply(seq_along(...future.elements_ii), 
[16:01:50.367]                           FUN = function(jj) {
[16:01:50.367]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.367]                             ...future.FUN(...future.X_jj, ...)
[16:01:50.367]                           })
[16:01:50.367]                       }
[16:01:50.367]                     }, args = future.call.arguments)
[16:01:50.367]                   }
[16:01:50.367]                 }, immediateCondition = function(cond) {
[16:01:50.367]                   sendCondition <- ...future.makeSendCondition()
[16:01:50.367]                   sendCondition(cond)
[16:01:50.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.367]                   {
[16:01:50.367]                     inherits <- base::inherits
[16:01:50.367]                     invokeRestart <- base::invokeRestart
[16:01:50.367]                     is.null <- base::is.null
[16:01:50.367]                     muffled <- FALSE
[16:01:50.367]                     if (inherits(cond, "message")) {
[16:01:50.367]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:50.367]                       if (muffled) 
[16:01:50.367]                         invokeRestart("muffleMessage")
[16:01:50.367]                     }
[16:01:50.367]                     else if (inherits(cond, "warning")) {
[16:01:50.367]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:50.367]                       if (muffled) 
[16:01:50.367]                         invokeRestart("muffleWarning")
[16:01:50.367]                     }
[16:01:50.367]                     else if (inherits(cond, "condition")) {
[16:01:50.367]                       if (!is.null(pattern)) {
[16:01:50.367]                         computeRestarts <- base::computeRestarts
[16:01:50.367]                         grepl <- base::grepl
[16:01:50.367]                         restarts <- computeRestarts(cond)
[16:01:50.367]                         for (restart in restarts) {
[16:01:50.367]                           name <- restart$name
[16:01:50.367]                           if (is.null(name)) 
[16:01:50.367]                             next
[16:01:50.367]                           if (!grepl(pattern, name)) 
[16:01:50.367]                             next
[16:01:50.367]                           invokeRestart(restart)
[16:01:50.367]                           muffled <- TRUE
[16:01:50.367]                           break
[16:01:50.367]                         }
[16:01:50.367]                       }
[16:01:50.367]                     }
[16:01:50.367]                     invisible(muffled)
[16:01:50.367]                   }
[16:01:50.367]                   muffleCondition(cond)
[16:01:50.367]                 })
[16:01:50.367]             }))
[16:01:50.367]             future::FutureResult(value = ...future.value$value, 
[16:01:50.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.367]                   ...future.rng), globalenv = if (FALSE) 
[16:01:50.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:50.367]                     ...future.globalenv.names))
[16:01:50.367]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:50.367]         }, condition = base::local({
[16:01:50.367]             c <- base::c
[16:01:50.367]             inherits <- base::inherits
[16:01:50.367]             invokeRestart <- base::invokeRestart
[16:01:50.367]             length <- base::length
[16:01:50.367]             list <- base::list
[16:01:50.367]             seq.int <- base::seq.int
[16:01:50.367]             signalCondition <- base::signalCondition
[16:01:50.367]             sys.calls <- base::sys.calls
[16:01:50.367]             `[[` <- base::`[[`
[16:01:50.367]             `+` <- base::`+`
[16:01:50.367]             `<<-` <- base::`<<-`
[16:01:50.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:50.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:50.367]                   3L)]
[16:01:50.367]             }
[16:01:50.367]             function(cond) {
[16:01:50.367]                 is_error <- inherits(cond, "error")
[16:01:50.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:50.367]                   NULL)
[16:01:50.367]                 if (is_error) {
[16:01:50.367]                   sessionInformation <- function() {
[16:01:50.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:50.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:50.367]                       search = base::search(), system = base::Sys.info())
[16:01:50.367]                   }
[16:01:50.367]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:50.367]                     cond$call), session = sessionInformation(), 
[16:01:50.367]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:50.367]                   signalCondition(cond)
[16:01:50.367]                 }
[16:01:50.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:50.367]                 "immediateCondition"))) {
[16:01:50.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:50.367]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:50.367]                   if (TRUE && !signal) {
[16:01:50.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.367]                     {
[16:01:50.367]                       inherits <- base::inherits
[16:01:50.367]                       invokeRestart <- base::invokeRestart
[16:01:50.367]                       is.null <- base::is.null
[16:01:50.367]                       muffled <- FALSE
[16:01:50.367]                       if (inherits(cond, "message")) {
[16:01:50.367]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.367]                         if (muffled) 
[16:01:50.367]                           invokeRestart("muffleMessage")
[16:01:50.367]                       }
[16:01:50.367]                       else if (inherits(cond, "warning")) {
[16:01:50.367]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.367]                         if (muffled) 
[16:01:50.367]                           invokeRestart("muffleWarning")
[16:01:50.367]                       }
[16:01:50.367]                       else if (inherits(cond, "condition")) {
[16:01:50.367]                         if (!is.null(pattern)) {
[16:01:50.367]                           computeRestarts <- base::computeRestarts
[16:01:50.367]                           grepl <- base::grepl
[16:01:50.367]                           restarts <- computeRestarts(cond)
[16:01:50.367]                           for (restart in restarts) {
[16:01:50.367]                             name <- restart$name
[16:01:50.367]                             if (is.null(name)) 
[16:01:50.367]                               next
[16:01:50.367]                             if (!grepl(pattern, name)) 
[16:01:50.367]                               next
[16:01:50.367]                             invokeRestart(restart)
[16:01:50.367]                             muffled <- TRUE
[16:01:50.367]                             break
[16:01:50.367]                           }
[16:01:50.367]                         }
[16:01:50.367]                       }
[16:01:50.367]                       invisible(muffled)
[16:01:50.367]                     }
[16:01:50.367]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.367]                   }
[16:01:50.367]                 }
[16:01:50.367]                 else {
[16:01:50.367]                   if (TRUE) {
[16:01:50.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.367]                     {
[16:01:50.367]                       inherits <- base::inherits
[16:01:50.367]                       invokeRestart <- base::invokeRestart
[16:01:50.367]                       is.null <- base::is.null
[16:01:50.367]                       muffled <- FALSE
[16:01:50.367]                       if (inherits(cond, "message")) {
[16:01:50.367]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.367]                         if (muffled) 
[16:01:50.367]                           invokeRestart("muffleMessage")
[16:01:50.367]                       }
[16:01:50.367]                       else if (inherits(cond, "warning")) {
[16:01:50.367]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.367]                         if (muffled) 
[16:01:50.367]                           invokeRestart("muffleWarning")
[16:01:50.367]                       }
[16:01:50.367]                       else if (inherits(cond, "condition")) {
[16:01:50.367]                         if (!is.null(pattern)) {
[16:01:50.367]                           computeRestarts <- base::computeRestarts
[16:01:50.367]                           grepl <- base::grepl
[16:01:50.367]                           restarts <- computeRestarts(cond)
[16:01:50.367]                           for (restart in restarts) {
[16:01:50.367]                             name <- restart$name
[16:01:50.367]                             if (is.null(name)) 
[16:01:50.367]                               next
[16:01:50.367]                             if (!grepl(pattern, name)) 
[16:01:50.367]                               next
[16:01:50.367]                             invokeRestart(restart)
[16:01:50.367]                             muffled <- TRUE
[16:01:50.367]                             break
[16:01:50.367]                           }
[16:01:50.367]                         }
[16:01:50.367]                       }
[16:01:50.367]                       invisible(muffled)
[16:01:50.367]                     }
[16:01:50.367]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.367]                   }
[16:01:50.367]                 }
[16:01:50.367]             }
[16:01:50.367]         }))
[16:01:50.367]     }, error = function(ex) {
[16:01:50.367]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:50.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.367]                 ...future.rng), started = ...future.startTime, 
[16:01:50.367]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:50.367]             version = "1.8"), class = "FutureResult")
[16:01:50.367]     }, finally = {
[16:01:50.367]         if (!identical(...future.workdir, getwd())) 
[16:01:50.367]             setwd(...future.workdir)
[16:01:50.367]         {
[16:01:50.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:50.367]                 ...future.oldOptions$nwarnings <- NULL
[16:01:50.367]             }
[16:01:50.367]             base::options(...future.oldOptions)
[16:01:50.367]             if (.Platform$OS.type == "windows") {
[16:01:50.367]                 old_names <- names(...future.oldEnvVars)
[16:01:50.367]                 envs <- base::Sys.getenv()
[16:01:50.367]                 names <- names(envs)
[16:01:50.367]                 common <- intersect(names, old_names)
[16:01:50.367]                 added <- setdiff(names, old_names)
[16:01:50.367]                 removed <- setdiff(old_names, names)
[16:01:50.367]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:50.367]                   envs[common]]
[16:01:50.367]                 NAMES <- toupper(changed)
[16:01:50.367]                 args <- list()
[16:01:50.367]                 for (kk in seq_along(NAMES)) {
[16:01:50.367]                   name <- changed[[kk]]
[16:01:50.367]                   NAME <- NAMES[[kk]]
[16:01:50.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.367]                     next
[16:01:50.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.367]                 }
[16:01:50.367]                 NAMES <- toupper(added)
[16:01:50.367]                 for (kk in seq_along(NAMES)) {
[16:01:50.367]                   name <- added[[kk]]
[16:01:50.367]                   NAME <- NAMES[[kk]]
[16:01:50.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.367]                     next
[16:01:50.367]                   args[[name]] <- ""
[16:01:50.367]                 }
[16:01:50.367]                 NAMES <- toupper(removed)
[16:01:50.367]                 for (kk in seq_along(NAMES)) {
[16:01:50.367]                   name <- removed[[kk]]
[16:01:50.367]                   NAME <- NAMES[[kk]]
[16:01:50.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.367]                     next
[16:01:50.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.367]                 }
[16:01:50.367]                 if (length(args) > 0) 
[16:01:50.367]                   base::do.call(base::Sys.setenv, args = args)
[16:01:50.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:50.367]             }
[16:01:50.367]             else {
[16:01:50.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:50.367]             }
[16:01:50.367]             {
[16:01:50.367]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:50.367]                   0L) {
[16:01:50.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:50.367]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:50.367]                   base::options(opts)
[16:01:50.367]                 }
[16:01:50.367]                 {
[16:01:50.367]                   {
[16:01:50.367]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:50.367]                     NULL
[16:01:50.367]                   }
[16:01:50.367]                   options(future.plan = NULL)
[16:01:50.367]                   if (is.na(NA_character_)) 
[16:01:50.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:50.367]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:50.367]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:50.367]                     envir = parent.frame()) 
[16:01:50.367]                   {
[16:01:50.367]                     if (is.function(workers)) 
[16:01:50.367]                       workers <- workers()
[16:01:50.367]                     workers <- structure(as.integer(workers), 
[16:01:50.367]                       class = class(workers))
[16:01:50.367]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:50.367]                       workers >= 1)
[16:01:50.367]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:50.367]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:50.367]                     }
[16:01:50.367]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:50.367]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:50.367]                       envir = envir)
[16:01:50.367]                     if (!future$lazy) 
[16:01:50.367]                       future <- run(future)
[16:01:50.367]                     invisible(future)
[16:01:50.367]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:50.367]                 }
[16:01:50.367]             }
[16:01:50.367]         }
[16:01:50.367]     })
[16:01:50.367]     if (TRUE) {
[16:01:50.367]         base::sink(type = "output", split = FALSE)
[16:01:50.367]         if (TRUE) {
[16:01:50.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:50.367]         }
[16:01:50.367]         else {
[16:01:50.367]             ...future.result["stdout"] <- base::list(NULL)
[16:01:50.367]         }
[16:01:50.367]         base::close(...future.stdout)
[16:01:50.367]         ...future.stdout <- NULL
[16:01:50.367]     }
[16:01:50.367]     ...future.result$conditions <- ...future.conditions
[16:01:50.367]     ...future.result$finished <- base::Sys.time()
[16:01:50.367]     ...future.result
[16:01:50.367] }
[16:01:50.370] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[16:01:50.370] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:01:50.371] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:01:50.371] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[16:01:50.371] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[16:01:50.372] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:01:50.372] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:01:50.372] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:50.373] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:50.373] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:01:50.373] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:01:50.373] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[16:01:50.374] MultisessionFuture started
[16:01:50.374] - Launch lazy future ... done
[16:01:50.374] run() for ‘MultisessionFuture’ ... done
[16:01:50.374] Created future:
[16:01:50.374] MultisessionFuture:
[16:01:50.374] Label: ‘future_eapply-1’
[16:01:50.374] Expression:
[16:01:50.374] {
[16:01:50.374]     do.call(function(...) {
[16:01:50.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.374]             on.exit(options(oopts), add = TRUE)
[16:01:50.374]         }
[16:01:50.374]         {
[16:01:50.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.374]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.374]             })
[16:01:50.374]         }
[16:01:50.374]     }, args = future.call.arguments)
[16:01:50.374] }
[16:01:50.374] Lazy evaluation: FALSE
[16:01:50.374] Asynchronous evaluation: TRUE
[16:01:50.374] Local evaluation: TRUE
[16:01:50.374] Environment: R_GlobalEnv
[16:01:50.374] Capture standard output: TRUE
[16:01:50.374] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:50.374] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:50.374] Packages: 1 packages (‘stats’)
[16:01:50.374] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:50.374] Resolved: FALSE
[16:01:50.374] Value: <not collected>
[16:01:50.374] Conditions captured: <none>
[16:01:50.374] Early signaling: FALSE
[16:01:50.374] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:50.374] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.386] Chunk #1 of 2 ... DONE
[16:01:50.386] Chunk #2 of 2 ...
[16:01:50.386]  - Finding globals in 'X' for chunk #2 ...
[16:01:50.386] getGlobalsAndPackages() ...
[16:01:50.386] Searching for globals...
[16:01:50.387] 
[16:01:50.387] Searching for globals ... DONE
[16:01:50.387] - globals: [0] <none>
[16:01:50.387] getGlobalsAndPackages() ... DONE
[16:01:50.387]    + additional globals found: [n=0] 
[16:01:50.387]    + additional namespaces needed: [n=0] 
[16:01:50.387]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:50.387]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:50.387]  - seeds: <none>
[16:01:50.388]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.388] getGlobalsAndPackages() ...
[16:01:50.388] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.388] Resolving globals: FALSE
[16:01:50.388] Tweak future expression to call with '...' arguments ...
[16:01:50.388] {
[16:01:50.388]     do.call(function(...) {
[16:01:50.388]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.388]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.388]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.388]             on.exit(options(oopts), add = TRUE)
[16:01:50.388]         }
[16:01:50.388]         {
[16:01:50.388]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.388]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.388]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.388]             })
[16:01:50.388]         }
[16:01:50.388]     }, args = future.call.arguments)
[16:01:50.388] }
[16:01:50.388] Tweak future expression to call with '...' arguments ... DONE
[16:01:50.389] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.389] - packages: [1] ‘stats’
[16:01:50.389] getGlobalsAndPackages() ... DONE
[16:01:50.389] run() for ‘Future’ ...
[16:01:50.389] - state: ‘created’
[16:01:50.390] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:50.404] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.404] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:50.404]   - Field: ‘node’
[16:01:50.404]   - Field: ‘label’
[16:01:50.404]   - Field: ‘local’
[16:01:50.404]   - Field: ‘owner’
[16:01:50.405]   - Field: ‘envir’
[16:01:50.405]   - Field: ‘workers’
[16:01:50.405]   - Field: ‘packages’
[16:01:50.405]   - Field: ‘gc’
[16:01:50.405]   - Field: ‘conditions’
[16:01:50.405]   - Field: ‘persistent’
[16:01:50.405]   - Field: ‘expr’
[16:01:50.405]   - Field: ‘uuid’
[16:01:50.405]   - Field: ‘seed’
[16:01:50.405]   - Field: ‘version’
[16:01:50.405]   - Field: ‘result’
[16:01:50.406]   - Field: ‘asynchronous’
[16:01:50.406]   - Field: ‘calls’
[16:01:50.406]   - Field: ‘globals’
[16:01:50.406]   - Field: ‘stdout’
[16:01:50.406]   - Field: ‘earlySignal’
[16:01:50.406]   - Field: ‘lazy’
[16:01:50.406]   - Field: ‘state’
[16:01:50.406] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:50.406] - Launch lazy future ...
[16:01:50.407] Packages needed by the future expression (n = 1): ‘stats’
[16:01:50.407] Packages needed by future strategies (n = 0): <none>
[16:01:50.407] {
[16:01:50.407]     {
[16:01:50.407]         {
[16:01:50.407]             ...future.startTime <- base::Sys.time()
[16:01:50.407]             {
[16:01:50.407]                 {
[16:01:50.407]                   {
[16:01:50.407]                     {
[16:01:50.407]                       {
[16:01:50.407]                         base::local({
[16:01:50.407]                           has_future <- base::requireNamespace("future", 
[16:01:50.407]                             quietly = TRUE)
[16:01:50.407]                           if (has_future) {
[16:01:50.407]                             ns <- base::getNamespace("future")
[16:01:50.407]                             version <- ns[[".package"]][["version"]]
[16:01:50.407]                             if (is.null(version)) 
[16:01:50.407]                               version <- utils::packageVersion("future")
[16:01:50.407]                           }
[16:01:50.407]                           else {
[16:01:50.407]                             version <- NULL
[16:01:50.407]                           }
[16:01:50.407]                           if (!has_future || version < "1.8.0") {
[16:01:50.407]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:50.407]                               "", base::R.version$version.string), 
[16:01:50.407]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:50.407]                                 base::R.version$platform, 8 * 
[16:01:50.407]                                   base::.Machine$sizeof.pointer), 
[16:01:50.407]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:50.407]                                 "release", "version")], collapse = " "), 
[16:01:50.407]                               hostname = base::Sys.info()[["nodename"]])
[16:01:50.407]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:50.407]                               info)
[16:01:50.407]                             info <- base::paste(info, collapse = "; ")
[16:01:50.407]                             if (!has_future) {
[16:01:50.407]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:50.407]                                 info)
[16:01:50.407]                             }
[16:01:50.407]                             else {
[16:01:50.407]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:50.407]                                 info, version)
[16:01:50.407]                             }
[16:01:50.407]                             base::stop(msg)
[16:01:50.407]                           }
[16:01:50.407]                         })
[16:01:50.407]                       }
[16:01:50.407]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:50.407]                       base::options(mc.cores = 1L)
[16:01:50.407]                     }
[16:01:50.407]                     base::local({
[16:01:50.407]                       for (pkg in "stats") {
[16:01:50.407]                         base::loadNamespace(pkg)
[16:01:50.407]                         base::library(pkg, character.only = TRUE)
[16:01:50.407]                       }
[16:01:50.407]                     })
[16:01:50.407]                   }
[16:01:50.407]                   options(future.plan = NULL)
[16:01:50.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:50.407]                 }
[16:01:50.407]                 ...future.workdir <- getwd()
[16:01:50.407]             }
[16:01:50.407]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:50.407]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:50.407]         }
[16:01:50.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:50.407]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:50.407]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:50.407]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:50.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:50.407]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:50.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:50.407]             base::names(...future.oldOptions))
[16:01:50.407]     }
[16:01:50.407]     if (FALSE) {
[16:01:50.407]     }
[16:01:50.407]     else {
[16:01:50.407]         if (TRUE) {
[16:01:50.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:50.407]                 open = "w")
[16:01:50.407]         }
[16:01:50.407]         else {
[16:01:50.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:50.407]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:50.407]         }
[16:01:50.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:50.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:50.407]             base::sink(type = "output", split = FALSE)
[16:01:50.407]             base::close(...future.stdout)
[16:01:50.407]         }, add = TRUE)
[16:01:50.407]     }
[16:01:50.407]     ...future.frame <- base::sys.nframe()
[16:01:50.407]     ...future.conditions <- base::list()
[16:01:50.407]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:50.407]     if (FALSE) {
[16:01:50.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:50.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:50.407]     }
[16:01:50.407]     ...future.result <- base::tryCatch({
[16:01:50.407]         base::withCallingHandlers({
[16:01:50.407]             ...future.value <- base::withVisible(base::local({
[16:01:50.407]                 ...future.makeSendCondition <- base::local({
[16:01:50.407]                   sendCondition <- NULL
[16:01:50.407]                   function(frame = 1L) {
[16:01:50.407]                     if (is.function(sendCondition)) 
[16:01:50.407]                       return(sendCondition)
[16:01:50.407]                     ns <- getNamespace("parallel")
[16:01:50.407]                     if (exists("sendData", mode = "function", 
[16:01:50.407]                       envir = ns)) {
[16:01:50.407]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:50.407]                         envir = ns)
[16:01:50.407]                       envir <- sys.frame(frame)
[16:01:50.407]                       master <- NULL
[16:01:50.407]                       while (!identical(envir, .GlobalEnv) && 
[16:01:50.407]                         !identical(envir, emptyenv())) {
[16:01:50.407]                         if (exists("master", mode = "list", envir = envir, 
[16:01:50.407]                           inherits = FALSE)) {
[16:01:50.407]                           master <- get("master", mode = "list", 
[16:01:50.407]                             envir = envir, inherits = FALSE)
[16:01:50.407]                           if (inherits(master, c("SOCKnode", 
[16:01:50.407]                             "SOCK0node"))) {
[16:01:50.407]                             sendCondition <<- function(cond) {
[16:01:50.407]                               data <- list(type = "VALUE", value = cond, 
[16:01:50.407]                                 success = TRUE)
[16:01:50.407]                               parallel_sendData(master, data)
[16:01:50.407]                             }
[16:01:50.407]                             return(sendCondition)
[16:01:50.407]                           }
[16:01:50.407]                         }
[16:01:50.407]                         frame <- frame + 1L
[16:01:50.407]                         envir <- sys.frame(frame)
[16:01:50.407]                       }
[16:01:50.407]                     }
[16:01:50.407]                     sendCondition <<- function(cond) NULL
[16:01:50.407]                   }
[16:01:50.407]                 })
[16:01:50.407]                 withCallingHandlers({
[16:01:50.407]                   {
[16:01:50.407]                     do.call(function(...) {
[16:01:50.407]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.407]                       if (!identical(...future.globals.maxSize.org, 
[16:01:50.407]                         ...future.globals.maxSize)) {
[16:01:50.407]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.407]                         on.exit(options(oopts), add = TRUE)
[16:01:50.407]                       }
[16:01:50.407]                       {
[16:01:50.407]                         lapply(seq_along(...future.elements_ii), 
[16:01:50.407]                           FUN = function(jj) {
[16:01:50.407]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.407]                             ...future.FUN(...future.X_jj, ...)
[16:01:50.407]                           })
[16:01:50.407]                       }
[16:01:50.407]                     }, args = future.call.arguments)
[16:01:50.407]                   }
[16:01:50.407]                 }, immediateCondition = function(cond) {
[16:01:50.407]                   sendCondition <- ...future.makeSendCondition()
[16:01:50.407]                   sendCondition(cond)
[16:01:50.407]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.407]                   {
[16:01:50.407]                     inherits <- base::inherits
[16:01:50.407]                     invokeRestart <- base::invokeRestart
[16:01:50.407]                     is.null <- base::is.null
[16:01:50.407]                     muffled <- FALSE
[16:01:50.407]                     if (inherits(cond, "message")) {
[16:01:50.407]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:50.407]                       if (muffled) 
[16:01:50.407]                         invokeRestart("muffleMessage")
[16:01:50.407]                     }
[16:01:50.407]                     else if (inherits(cond, "warning")) {
[16:01:50.407]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:50.407]                       if (muffled) 
[16:01:50.407]                         invokeRestart("muffleWarning")
[16:01:50.407]                     }
[16:01:50.407]                     else if (inherits(cond, "condition")) {
[16:01:50.407]                       if (!is.null(pattern)) {
[16:01:50.407]                         computeRestarts <- base::computeRestarts
[16:01:50.407]                         grepl <- base::grepl
[16:01:50.407]                         restarts <- computeRestarts(cond)
[16:01:50.407]                         for (restart in restarts) {
[16:01:50.407]                           name <- restart$name
[16:01:50.407]                           if (is.null(name)) 
[16:01:50.407]                             next
[16:01:50.407]                           if (!grepl(pattern, name)) 
[16:01:50.407]                             next
[16:01:50.407]                           invokeRestart(restart)
[16:01:50.407]                           muffled <- TRUE
[16:01:50.407]                           break
[16:01:50.407]                         }
[16:01:50.407]                       }
[16:01:50.407]                     }
[16:01:50.407]                     invisible(muffled)
[16:01:50.407]                   }
[16:01:50.407]                   muffleCondition(cond)
[16:01:50.407]                 })
[16:01:50.407]             }))
[16:01:50.407]             future::FutureResult(value = ...future.value$value, 
[16:01:50.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.407]                   ...future.rng), globalenv = if (FALSE) 
[16:01:50.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:50.407]                     ...future.globalenv.names))
[16:01:50.407]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:50.407]         }, condition = base::local({
[16:01:50.407]             c <- base::c
[16:01:50.407]             inherits <- base::inherits
[16:01:50.407]             invokeRestart <- base::invokeRestart
[16:01:50.407]             length <- base::length
[16:01:50.407]             list <- base::list
[16:01:50.407]             seq.int <- base::seq.int
[16:01:50.407]             signalCondition <- base::signalCondition
[16:01:50.407]             sys.calls <- base::sys.calls
[16:01:50.407]             `[[` <- base::`[[`
[16:01:50.407]             `+` <- base::`+`
[16:01:50.407]             `<<-` <- base::`<<-`
[16:01:50.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:50.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:50.407]                   3L)]
[16:01:50.407]             }
[16:01:50.407]             function(cond) {
[16:01:50.407]                 is_error <- inherits(cond, "error")
[16:01:50.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:50.407]                   NULL)
[16:01:50.407]                 if (is_error) {
[16:01:50.407]                   sessionInformation <- function() {
[16:01:50.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:50.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:50.407]                       search = base::search(), system = base::Sys.info())
[16:01:50.407]                   }
[16:01:50.407]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:50.407]                     cond$call), session = sessionInformation(), 
[16:01:50.407]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:50.407]                   signalCondition(cond)
[16:01:50.407]                 }
[16:01:50.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:50.407]                 "immediateCondition"))) {
[16:01:50.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:50.407]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:50.407]                   if (TRUE && !signal) {
[16:01:50.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.407]                     {
[16:01:50.407]                       inherits <- base::inherits
[16:01:50.407]                       invokeRestart <- base::invokeRestart
[16:01:50.407]                       is.null <- base::is.null
[16:01:50.407]                       muffled <- FALSE
[16:01:50.407]                       if (inherits(cond, "message")) {
[16:01:50.407]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.407]                         if (muffled) 
[16:01:50.407]                           invokeRestart("muffleMessage")
[16:01:50.407]                       }
[16:01:50.407]                       else if (inherits(cond, "warning")) {
[16:01:50.407]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.407]                         if (muffled) 
[16:01:50.407]                           invokeRestart("muffleWarning")
[16:01:50.407]                       }
[16:01:50.407]                       else if (inherits(cond, "condition")) {
[16:01:50.407]                         if (!is.null(pattern)) {
[16:01:50.407]                           computeRestarts <- base::computeRestarts
[16:01:50.407]                           grepl <- base::grepl
[16:01:50.407]                           restarts <- computeRestarts(cond)
[16:01:50.407]                           for (restart in restarts) {
[16:01:50.407]                             name <- restart$name
[16:01:50.407]                             if (is.null(name)) 
[16:01:50.407]                               next
[16:01:50.407]                             if (!grepl(pattern, name)) 
[16:01:50.407]                               next
[16:01:50.407]                             invokeRestart(restart)
[16:01:50.407]                             muffled <- TRUE
[16:01:50.407]                             break
[16:01:50.407]                           }
[16:01:50.407]                         }
[16:01:50.407]                       }
[16:01:50.407]                       invisible(muffled)
[16:01:50.407]                     }
[16:01:50.407]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.407]                   }
[16:01:50.407]                 }
[16:01:50.407]                 else {
[16:01:50.407]                   if (TRUE) {
[16:01:50.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.407]                     {
[16:01:50.407]                       inherits <- base::inherits
[16:01:50.407]                       invokeRestart <- base::invokeRestart
[16:01:50.407]                       is.null <- base::is.null
[16:01:50.407]                       muffled <- FALSE
[16:01:50.407]                       if (inherits(cond, "message")) {
[16:01:50.407]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.407]                         if (muffled) 
[16:01:50.407]                           invokeRestart("muffleMessage")
[16:01:50.407]                       }
[16:01:50.407]                       else if (inherits(cond, "warning")) {
[16:01:50.407]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.407]                         if (muffled) 
[16:01:50.407]                           invokeRestart("muffleWarning")
[16:01:50.407]                       }
[16:01:50.407]                       else if (inherits(cond, "condition")) {
[16:01:50.407]                         if (!is.null(pattern)) {
[16:01:50.407]                           computeRestarts <- base::computeRestarts
[16:01:50.407]                           grepl <- base::grepl
[16:01:50.407]                           restarts <- computeRestarts(cond)
[16:01:50.407]                           for (restart in restarts) {
[16:01:50.407]                             name <- restart$name
[16:01:50.407]                             if (is.null(name)) 
[16:01:50.407]                               next
[16:01:50.407]                             if (!grepl(pattern, name)) 
[16:01:50.407]                               next
[16:01:50.407]                             invokeRestart(restart)
[16:01:50.407]                             muffled <- TRUE
[16:01:50.407]                             break
[16:01:50.407]                           }
[16:01:50.407]                         }
[16:01:50.407]                       }
[16:01:50.407]                       invisible(muffled)
[16:01:50.407]                     }
[16:01:50.407]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.407]                   }
[16:01:50.407]                 }
[16:01:50.407]             }
[16:01:50.407]         }))
[16:01:50.407]     }, error = function(ex) {
[16:01:50.407]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:50.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.407]                 ...future.rng), started = ...future.startTime, 
[16:01:50.407]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:50.407]             version = "1.8"), class = "FutureResult")
[16:01:50.407]     }, finally = {
[16:01:50.407]         if (!identical(...future.workdir, getwd())) 
[16:01:50.407]             setwd(...future.workdir)
[16:01:50.407]         {
[16:01:50.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:50.407]                 ...future.oldOptions$nwarnings <- NULL
[16:01:50.407]             }
[16:01:50.407]             base::options(...future.oldOptions)
[16:01:50.407]             if (.Platform$OS.type == "windows") {
[16:01:50.407]                 old_names <- names(...future.oldEnvVars)
[16:01:50.407]                 envs <- base::Sys.getenv()
[16:01:50.407]                 names <- names(envs)
[16:01:50.407]                 common <- intersect(names, old_names)
[16:01:50.407]                 added <- setdiff(names, old_names)
[16:01:50.407]                 removed <- setdiff(old_names, names)
[16:01:50.407]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:50.407]                   envs[common]]
[16:01:50.407]                 NAMES <- toupper(changed)
[16:01:50.407]                 args <- list()
[16:01:50.407]                 for (kk in seq_along(NAMES)) {
[16:01:50.407]                   name <- changed[[kk]]
[16:01:50.407]                   NAME <- NAMES[[kk]]
[16:01:50.407]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.407]                     next
[16:01:50.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.407]                 }
[16:01:50.407]                 NAMES <- toupper(added)
[16:01:50.407]                 for (kk in seq_along(NAMES)) {
[16:01:50.407]                   name <- added[[kk]]
[16:01:50.407]                   NAME <- NAMES[[kk]]
[16:01:50.407]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.407]                     next
[16:01:50.407]                   args[[name]] <- ""
[16:01:50.407]                 }
[16:01:50.407]                 NAMES <- toupper(removed)
[16:01:50.407]                 for (kk in seq_along(NAMES)) {
[16:01:50.407]                   name <- removed[[kk]]
[16:01:50.407]                   NAME <- NAMES[[kk]]
[16:01:50.407]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.407]                     next
[16:01:50.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.407]                 }
[16:01:50.407]                 if (length(args) > 0) 
[16:01:50.407]                   base::do.call(base::Sys.setenv, args = args)
[16:01:50.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:50.407]             }
[16:01:50.407]             else {
[16:01:50.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:50.407]             }
[16:01:50.407]             {
[16:01:50.407]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:50.407]                   0L) {
[16:01:50.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:50.407]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:50.407]                   base::options(opts)
[16:01:50.407]                 }
[16:01:50.407]                 {
[16:01:50.407]                   {
[16:01:50.407]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:50.407]                     NULL
[16:01:50.407]                   }
[16:01:50.407]                   options(future.plan = NULL)
[16:01:50.407]                   if (is.na(NA_character_)) 
[16:01:50.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:50.407]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:50.407]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:50.407]                     envir = parent.frame()) 
[16:01:50.407]                   {
[16:01:50.407]                     if (is.function(workers)) 
[16:01:50.407]                       workers <- workers()
[16:01:50.407]                     workers <- structure(as.integer(workers), 
[16:01:50.407]                       class = class(workers))
[16:01:50.407]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:50.407]                       workers >= 1)
[16:01:50.407]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:50.407]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:50.407]                     }
[16:01:50.407]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:50.407]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:50.407]                       envir = envir)
[16:01:50.407]                     if (!future$lazy) 
[16:01:50.407]                       future <- run(future)
[16:01:50.407]                     invisible(future)
[16:01:50.407]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:50.407]                 }
[16:01:50.407]             }
[16:01:50.407]         }
[16:01:50.407]     })
[16:01:50.407]     if (TRUE) {
[16:01:50.407]         base::sink(type = "output", split = FALSE)
[16:01:50.407]         if (TRUE) {
[16:01:50.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:50.407]         }
[16:01:50.407]         else {
[16:01:50.407]             ...future.result["stdout"] <- base::list(NULL)
[16:01:50.407]         }
[16:01:50.407]         base::close(...future.stdout)
[16:01:50.407]         ...future.stdout <- NULL
[16:01:50.407]     }
[16:01:50.407]     ...future.result$conditions <- ...future.conditions
[16:01:50.407]     ...future.result$finished <- base::Sys.time()
[16:01:50.407]     ...future.result
[16:01:50.407] }
[16:01:50.410] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[16:01:50.410] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:01:50.411] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:01:50.411] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[16:01:50.411] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[16:01:50.412] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:01:50.412] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:01:50.412] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:50.412] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:50.412] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:01:50.413] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:01:50.413] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[16:01:50.413] MultisessionFuture started
[16:01:50.413] - Launch lazy future ... done
[16:01:50.413] run() for ‘MultisessionFuture’ ... done
[16:01:50.414] Created future:
[16:01:50.414] MultisessionFuture:
[16:01:50.414] Label: ‘future_eapply-2’
[16:01:50.414] Expression:
[16:01:50.414] {
[16:01:50.414]     do.call(function(...) {
[16:01:50.414]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.414]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.414]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.414]             on.exit(options(oopts), add = TRUE)
[16:01:50.414]         }
[16:01:50.414]         {
[16:01:50.414]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.414]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.414]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.414]             })
[16:01:50.414]         }
[16:01:50.414]     }, args = future.call.arguments)
[16:01:50.414] }
[16:01:50.414] Lazy evaluation: FALSE
[16:01:50.414] Asynchronous evaluation: TRUE
[16:01:50.414] Local evaluation: TRUE
[16:01:50.414] Environment: R_GlobalEnv
[16:01:50.414] Capture standard output: TRUE
[16:01:50.414] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:50.414] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:50.414] Packages: 1 packages (‘stats’)
[16:01:50.414] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:50.414] Resolved: FALSE
[16:01:50.414] Value: <not collected>
[16:01:50.414] Conditions captured: <none>
[16:01:50.414] Early signaling: FALSE
[16:01:50.414] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:50.414] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.425] Chunk #2 of 2 ... DONE
[16:01:50.425] Launching 2 futures (chunks) ... DONE
[16:01:50.426] Resolving 2 futures (chunks) ...
[16:01:50.426] resolve() on list ...
[16:01:50.426]  recursive: 0
[16:01:50.426]  length: 2
[16:01:50.426] 
[16:01:50.426] receiveMessageFromWorker() for ClusterFuture ...
[16:01:50.427] - Validating connection of MultisessionFuture
[16:01:50.427] - received message: FutureResult
[16:01:50.427] - Received FutureResult
[16:01:50.427] - Erased future from FutureRegistry
[16:01:50.427] result() for ClusterFuture ...
[16:01:50.427] - result already collected: FutureResult
[16:01:50.427] result() for ClusterFuture ... done
[16:01:50.427] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:50.427] Future #1
[16:01:50.428] result() for ClusterFuture ...
[16:01:50.428] - result already collected: FutureResult
[16:01:50.428] result() for ClusterFuture ... done
[16:01:50.428] result() for ClusterFuture ...
[16:01:50.428] - result already collected: FutureResult
[16:01:50.428] result() for ClusterFuture ... done
[16:01:50.428] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:50.428] - nx: 2
[16:01:50.428] - relay: TRUE
[16:01:50.428] - stdout: TRUE
[16:01:50.428] - signal: TRUE
[16:01:50.429] - resignal: FALSE
[16:01:50.429] - force: TRUE
[16:01:50.429] - relayed: [n=2] FALSE, FALSE
[16:01:50.429] - queued futures: [n=2] FALSE, FALSE
[16:01:50.429]  - until=1
[16:01:50.429]  - relaying element #1
[16:01:50.429] result() for ClusterFuture ...
[16:01:50.429] - result already collected: FutureResult
[16:01:50.429] result() for ClusterFuture ... done
[16:01:50.429] result() for ClusterFuture ...
[16:01:50.429] - result already collected: FutureResult
[16:01:50.430] result() for ClusterFuture ... done
[16:01:50.430] result() for ClusterFuture ...
[16:01:50.430] - result already collected: FutureResult
[16:01:50.430] result() for ClusterFuture ... done
[16:01:50.430] result() for ClusterFuture ...
[16:01:50.430] - result already collected: FutureResult
[16:01:50.430] result() for ClusterFuture ... done
[16:01:50.430] - relayed: [n=2] TRUE, FALSE
[16:01:50.430] - queued futures: [n=2] TRUE, FALSE
[16:01:50.430] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:50.430]  length: 1 (resolved future 1)
[16:01:50.472] receiveMessageFromWorker() for ClusterFuture ...
[16:01:50.472] - Validating connection of MultisessionFuture
[16:01:50.473] - received message: FutureResult
[16:01:50.473] - Received FutureResult
[16:01:50.473] - Erased future from FutureRegistry
[16:01:50.473] result() for ClusterFuture ...
[16:01:50.473] - result already collected: FutureResult
[16:01:50.473] result() for ClusterFuture ... done
[16:01:50.473] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:50.473] Future #2
[16:01:50.474] result() for ClusterFuture ...
[16:01:50.474] - result already collected: FutureResult
[16:01:50.474] result() for ClusterFuture ... done
[16:01:50.474] result() for ClusterFuture ...
[16:01:50.474] - result already collected: FutureResult
[16:01:50.474] result() for ClusterFuture ... done
[16:01:50.474] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:50.474] - nx: 2
[16:01:50.474] - relay: TRUE
[16:01:50.474] - stdout: TRUE
[16:01:50.474] - signal: TRUE
[16:01:50.474] - resignal: FALSE
[16:01:50.475] - force: TRUE
[16:01:50.475] - relayed: [n=2] TRUE, FALSE
[16:01:50.475] - queued futures: [n=2] TRUE, FALSE
[16:01:50.475]  - until=2
[16:01:50.475]  - relaying element #2
[16:01:50.475] result() for ClusterFuture ...
[16:01:50.475] - result already collected: FutureResult
[16:01:50.475] result() for ClusterFuture ... done
[16:01:50.475] result() for ClusterFuture ...
[16:01:50.475] - result already collected: FutureResult
[16:01:50.475] result() for ClusterFuture ... done
[16:01:50.476] result() for ClusterFuture ...
[16:01:50.476] - result already collected: FutureResult
[16:01:50.476] result() for ClusterFuture ... done
[16:01:50.476] result() for ClusterFuture ...
[16:01:50.476] - result already collected: FutureResult
[16:01:50.476] result() for ClusterFuture ... done
[16:01:50.476] - relayed: [n=2] TRUE, TRUE
[16:01:50.476] - queued futures: [n=2] TRUE, TRUE
[16:01:50.476] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:50.476]  length: 0 (resolved future 2)
[16:01:50.477] Relaying remaining futures
[16:01:50.477] signalConditionsASAP(NULL, pos=0) ...
[16:01:50.477] - nx: 2
[16:01:50.477] - relay: TRUE
[16:01:50.477] - stdout: TRUE
[16:01:50.477] - signal: TRUE
[16:01:50.477] - resignal: FALSE
[16:01:50.477] - force: TRUE
[16:01:50.477] - relayed: [n=2] TRUE, TRUE
[16:01:50.477] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:50.477] - relayed: [n=2] TRUE, TRUE
[16:01:50.478] - queued futures: [n=2] TRUE, TRUE
[16:01:50.478] signalConditionsASAP(NULL, pos=0) ... done
[16:01:50.478] resolve() on list ... DONE
[16:01:50.478] result() for ClusterFuture ...
[16:01:50.478] - result already collected: FutureResult
[16:01:50.478] result() for ClusterFuture ... done
[16:01:50.478] result() for ClusterFuture ...
[16:01:50.478] - result already collected: FutureResult
[16:01:50.478] result() for ClusterFuture ... done
[16:01:50.478] result() for ClusterFuture ...
[16:01:50.478] - result already collected: FutureResult
[16:01:50.479] result() for ClusterFuture ... done
[16:01:50.479] result() for ClusterFuture ...
[16:01:50.479] - result already collected: FutureResult
[16:01:50.479] result() for ClusterFuture ... done
[16:01:50.479]  - Number of value chunks collected: 2
[16:01:50.479] Resolving 2 futures (chunks) ... DONE
[16:01:50.479] Reducing values from 2 chunks ...
[16:01:50.479]  - Number of values collected after concatenation: 3
[16:01:50.479]  - Number of values expected: 3
[16:01:50.479] Reducing values from 2 chunks ... DONE
[16:01:50.480] future_lapply() ... DONE
[16:01:50.480] future_lapply() ...
[16:01:50.485] Number of chunks: 2
[16:01:50.485] getGlobalsAndPackagesXApply() ...
[16:01:50.485]  - future.globals: TRUE
[16:01:50.485] getGlobalsAndPackages() ...
[16:01:50.485] Searching for globals...
[16:01:50.486] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:50.486] Searching for globals ... DONE
[16:01:50.486] Resolving globals: FALSE
[16:01:50.487] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:50.487] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:50.487] - globals: [1] ‘FUN’
[16:01:50.487] - packages: [1] ‘stats’
[16:01:50.487] getGlobalsAndPackages() ... DONE
[16:01:50.488]  - globals found/used: [n=1] ‘FUN’
[16:01:50.488]  - needed namespaces: [n=1] ‘stats’
[16:01:50.488] Finding globals ... DONE
[16:01:50.488]  - use_args: TRUE
[16:01:50.488]  - Getting '...' globals ...
[16:01:50.488] resolve() on list ...
[16:01:50.488]  recursive: 0
[16:01:50.488]  length: 1
[16:01:50.489]  elements: ‘...’
[16:01:50.489]  length: 0 (resolved future 1)
[16:01:50.489] resolve() on list ... DONE
[16:01:50.489]    - '...' content: [n=0] 
[16:01:50.489] List of 1
[16:01:50.489]  $ ...: list()
[16:01:50.489]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:50.489]  - attr(*, "where")=List of 1
[16:01:50.489]   ..$ ...:<environment: 0x5620a3352eb0> 
[16:01:50.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:50.489]  - attr(*, "resolved")= logi TRUE
[16:01:50.489]  - attr(*, "total_size")= num NA
[16:01:50.493]  - Getting '...' globals ... DONE
[16:01:50.494] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:50.494] List of 2
[16:01:50.494]  $ ...future.FUN:function (x, ...)  
[16:01:50.494]  $ ...          : list()
[16:01:50.494]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:50.494]  - attr(*, "where")=List of 2
[16:01:50.494]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:50.494]   ..$ ...          :<environment: 0x5620a3352eb0> 
[16:01:50.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:50.494]  - attr(*, "resolved")= logi FALSE
[16:01:50.494]  - attr(*, "total_size")= num 1248
[16:01:50.496] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:50.496] getGlobalsAndPackagesXApply() ... DONE
[16:01:50.497] Number of futures (= number of chunks): 2
[16:01:50.497] Launching 2 futures (chunks) ...
[16:01:50.497] Chunk #1 of 2 ...
[16:01:50.497]  - Finding globals in 'X' for chunk #1 ...
[16:01:50.497] getGlobalsAndPackages() ...
[16:01:50.497] Searching for globals...
[16:01:50.497] 
[16:01:50.497] Searching for globals ... DONE
[16:01:50.498] - globals: [0] <none>
[16:01:50.498] getGlobalsAndPackages() ... DONE
[16:01:50.498]    + additional globals found: [n=0] 
[16:01:50.498]    + additional namespaces needed: [n=0] 
[16:01:50.498]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:50.498]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:50.498]  - seeds: <none>
[16:01:50.498]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.498] getGlobalsAndPackages() ...
[16:01:50.498] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.498] Resolving globals: FALSE
[16:01:50.499] Tweak future expression to call with '...' arguments ...
[16:01:50.499] {
[16:01:50.499]     do.call(function(...) {
[16:01:50.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.499]             on.exit(options(oopts), add = TRUE)
[16:01:50.499]         }
[16:01:50.499]         {
[16:01:50.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.499]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.499]             })
[16:01:50.499]         }
[16:01:50.499]     }, args = future.call.arguments)
[16:01:50.499] }
[16:01:50.499] Tweak future expression to call with '...' arguments ... DONE
[16:01:50.499] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.500] - packages: [1] ‘stats’
[16:01:50.500] getGlobalsAndPackages() ... DONE
[16:01:50.500] run() for ‘Future’ ...
[16:01:50.500] - state: ‘created’
[16:01:50.500] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:50.514] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:50.514]   - Field: ‘node’
[16:01:50.514]   - Field: ‘label’
[16:01:50.514]   - Field: ‘local’
[16:01:50.515]   - Field: ‘owner’
[16:01:50.515]   - Field: ‘envir’
[16:01:50.515]   - Field: ‘workers’
[16:01:50.515]   - Field: ‘packages’
[16:01:50.515]   - Field: ‘gc’
[16:01:50.515]   - Field: ‘conditions’
[16:01:50.515]   - Field: ‘persistent’
[16:01:50.515]   - Field: ‘expr’
[16:01:50.515]   - Field: ‘uuid’
[16:01:50.515]   - Field: ‘seed’
[16:01:50.515]   - Field: ‘version’
[16:01:50.516]   - Field: ‘result’
[16:01:50.516]   - Field: ‘asynchronous’
[16:01:50.516]   - Field: ‘calls’
[16:01:50.516]   - Field: ‘globals’
[16:01:50.516]   - Field: ‘stdout’
[16:01:50.516]   - Field: ‘earlySignal’
[16:01:50.516]   - Field: ‘lazy’
[16:01:50.516]   - Field: ‘state’
[16:01:50.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:50.516] - Launch lazy future ...
[16:01:50.517] Packages needed by the future expression (n = 1): ‘stats’
[16:01:50.517] Packages needed by future strategies (n = 0): <none>
[16:01:50.517] {
[16:01:50.517]     {
[16:01:50.517]         {
[16:01:50.517]             ...future.startTime <- base::Sys.time()
[16:01:50.517]             {
[16:01:50.517]                 {
[16:01:50.517]                   {
[16:01:50.517]                     {
[16:01:50.517]                       {
[16:01:50.517]                         base::local({
[16:01:50.517]                           has_future <- base::requireNamespace("future", 
[16:01:50.517]                             quietly = TRUE)
[16:01:50.517]                           if (has_future) {
[16:01:50.517]                             ns <- base::getNamespace("future")
[16:01:50.517]                             version <- ns[[".package"]][["version"]]
[16:01:50.517]                             if (is.null(version)) 
[16:01:50.517]                               version <- utils::packageVersion("future")
[16:01:50.517]                           }
[16:01:50.517]                           else {
[16:01:50.517]                             version <- NULL
[16:01:50.517]                           }
[16:01:50.517]                           if (!has_future || version < "1.8.0") {
[16:01:50.517]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:50.517]                               "", base::R.version$version.string), 
[16:01:50.517]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:50.517]                                 base::R.version$platform, 8 * 
[16:01:50.517]                                   base::.Machine$sizeof.pointer), 
[16:01:50.517]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:50.517]                                 "release", "version")], collapse = " "), 
[16:01:50.517]                               hostname = base::Sys.info()[["nodename"]])
[16:01:50.517]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:50.517]                               info)
[16:01:50.517]                             info <- base::paste(info, collapse = "; ")
[16:01:50.517]                             if (!has_future) {
[16:01:50.517]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:50.517]                                 info)
[16:01:50.517]                             }
[16:01:50.517]                             else {
[16:01:50.517]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:50.517]                                 info, version)
[16:01:50.517]                             }
[16:01:50.517]                             base::stop(msg)
[16:01:50.517]                           }
[16:01:50.517]                         })
[16:01:50.517]                       }
[16:01:50.517]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:50.517]                       base::options(mc.cores = 1L)
[16:01:50.517]                     }
[16:01:50.517]                     base::local({
[16:01:50.517]                       for (pkg in "stats") {
[16:01:50.517]                         base::loadNamespace(pkg)
[16:01:50.517]                         base::library(pkg, character.only = TRUE)
[16:01:50.517]                       }
[16:01:50.517]                     })
[16:01:50.517]                   }
[16:01:50.517]                   options(future.plan = NULL)
[16:01:50.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:50.517]                 }
[16:01:50.517]                 ...future.workdir <- getwd()
[16:01:50.517]             }
[16:01:50.517]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:50.517]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:50.517]         }
[16:01:50.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:50.517]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:50.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:50.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:50.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:50.517]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:50.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:50.517]             base::names(...future.oldOptions))
[16:01:50.517]     }
[16:01:50.517]     if (FALSE) {
[16:01:50.517]     }
[16:01:50.517]     else {
[16:01:50.517]         if (TRUE) {
[16:01:50.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:50.517]                 open = "w")
[16:01:50.517]         }
[16:01:50.517]         else {
[16:01:50.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:50.517]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:50.517]         }
[16:01:50.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:50.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:50.517]             base::sink(type = "output", split = FALSE)
[16:01:50.517]             base::close(...future.stdout)
[16:01:50.517]         }, add = TRUE)
[16:01:50.517]     }
[16:01:50.517]     ...future.frame <- base::sys.nframe()
[16:01:50.517]     ...future.conditions <- base::list()
[16:01:50.517]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:50.517]     if (FALSE) {
[16:01:50.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:50.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:50.517]     }
[16:01:50.517]     ...future.result <- base::tryCatch({
[16:01:50.517]         base::withCallingHandlers({
[16:01:50.517]             ...future.value <- base::withVisible(base::local({
[16:01:50.517]                 ...future.makeSendCondition <- base::local({
[16:01:50.517]                   sendCondition <- NULL
[16:01:50.517]                   function(frame = 1L) {
[16:01:50.517]                     if (is.function(sendCondition)) 
[16:01:50.517]                       return(sendCondition)
[16:01:50.517]                     ns <- getNamespace("parallel")
[16:01:50.517]                     if (exists("sendData", mode = "function", 
[16:01:50.517]                       envir = ns)) {
[16:01:50.517]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:50.517]                         envir = ns)
[16:01:50.517]                       envir <- sys.frame(frame)
[16:01:50.517]                       master <- NULL
[16:01:50.517]                       while (!identical(envir, .GlobalEnv) && 
[16:01:50.517]                         !identical(envir, emptyenv())) {
[16:01:50.517]                         if (exists("master", mode = "list", envir = envir, 
[16:01:50.517]                           inherits = FALSE)) {
[16:01:50.517]                           master <- get("master", mode = "list", 
[16:01:50.517]                             envir = envir, inherits = FALSE)
[16:01:50.517]                           if (inherits(master, c("SOCKnode", 
[16:01:50.517]                             "SOCK0node"))) {
[16:01:50.517]                             sendCondition <<- function(cond) {
[16:01:50.517]                               data <- list(type = "VALUE", value = cond, 
[16:01:50.517]                                 success = TRUE)
[16:01:50.517]                               parallel_sendData(master, data)
[16:01:50.517]                             }
[16:01:50.517]                             return(sendCondition)
[16:01:50.517]                           }
[16:01:50.517]                         }
[16:01:50.517]                         frame <- frame + 1L
[16:01:50.517]                         envir <- sys.frame(frame)
[16:01:50.517]                       }
[16:01:50.517]                     }
[16:01:50.517]                     sendCondition <<- function(cond) NULL
[16:01:50.517]                   }
[16:01:50.517]                 })
[16:01:50.517]                 withCallingHandlers({
[16:01:50.517]                   {
[16:01:50.517]                     do.call(function(...) {
[16:01:50.517]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.517]                       if (!identical(...future.globals.maxSize.org, 
[16:01:50.517]                         ...future.globals.maxSize)) {
[16:01:50.517]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.517]                         on.exit(options(oopts), add = TRUE)
[16:01:50.517]                       }
[16:01:50.517]                       {
[16:01:50.517]                         lapply(seq_along(...future.elements_ii), 
[16:01:50.517]                           FUN = function(jj) {
[16:01:50.517]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.517]                             ...future.FUN(...future.X_jj, ...)
[16:01:50.517]                           })
[16:01:50.517]                       }
[16:01:50.517]                     }, args = future.call.arguments)
[16:01:50.517]                   }
[16:01:50.517]                 }, immediateCondition = function(cond) {
[16:01:50.517]                   sendCondition <- ...future.makeSendCondition()
[16:01:50.517]                   sendCondition(cond)
[16:01:50.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.517]                   {
[16:01:50.517]                     inherits <- base::inherits
[16:01:50.517]                     invokeRestart <- base::invokeRestart
[16:01:50.517]                     is.null <- base::is.null
[16:01:50.517]                     muffled <- FALSE
[16:01:50.517]                     if (inherits(cond, "message")) {
[16:01:50.517]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:50.517]                       if (muffled) 
[16:01:50.517]                         invokeRestart("muffleMessage")
[16:01:50.517]                     }
[16:01:50.517]                     else if (inherits(cond, "warning")) {
[16:01:50.517]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:50.517]                       if (muffled) 
[16:01:50.517]                         invokeRestart("muffleWarning")
[16:01:50.517]                     }
[16:01:50.517]                     else if (inherits(cond, "condition")) {
[16:01:50.517]                       if (!is.null(pattern)) {
[16:01:50.517]                         computeRestarts <- base::computeRestarts
[16:01:50.517]                         grepl <- base::grepl
[16:01:50.517]                         restarts <- computeRestarts(cond)
[16:01:50.517]                         for (restart in restarts) {
[16:01:50.517]                           name <- restart$name
[16:01:50.517]                           if (is.null(name)) 
[16:01:50.517]                             next
[16:01:50.517]                           if (!grepl(pattern, name)) 
[16:01:50.517]                             next
[16:01:50.517]                           invokeRestart(restart)
[16:01:50.517]                           muffled <- TRUE
[16:01:50.517]                           break
[16:01:50.517]                         }
[16:01:50.517]                       }
[16:01:50.517]                     }
[16:01:50.517]                     invisible(muffled)
[16:01:50.517]                   }
[16:01:50.517]                   muffleCondition(cond)
[16:01:50.517]                 })
[16:01:50.517]             }))
[16:01:50.517]             future::FutureResult(value = ...future.value$value, 
[16:01:50.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.517]                   ...future.rng), globalenv = if (FALSE) 
[16:01:50.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:50.517]                     ...future.globalenv.names))
[16:01:50.517]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:50.517]         }, condition = base::local({
[16:01:50.517]             c <- base::c
[16:01:50.517]             inherits <- base::inherits
[16:01:50.517]             invokeRestart <- base::invokeRestart
[16:01:50.517]             length <- base::length
[16:01:50.517]             list <- base::list
[16:01:50.517]             seq.int <- base::seq.int
[16:01:50.517]             signalCondition <- base::signalCondition
[16:01:50.517]             sys.calls <- base::sys.calls
[16:01:50.517]             `[[` <- base::`[[`
[16:01:50.517]             `+` <- base::`+`
[16:01:50.517]             `<<-` <- base::`<<-`
[16:01:50.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:50.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:50.517]                   3L)]
[16:01:50.517]             }
[16:01:50.517]             function(cond) {
[16:01:50.517]                 is_error <- inherits(cond, "error")
[16:01:50.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:50.517]                   NULL)
[16:01:50.517]                 if (is_error) {
[16:01:50.517]                   sessionInformation <- function() {
[16:01:50.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:50.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:50.517]                       search = base::search(), system = base::Sys.info())
[16:01:50.517]                   }
[16:01:50.517]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:50.517]                     cond$call), session = sessionInformation(), 
[16:01:50.517]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:50.517]                   signalCondition(cond)
[16:01:50.517]                 }
[16:01:50.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:50.517]                 "immediateCondition"))) {
[16:01:50.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:50.517]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:50.517]                   if (TRUE && !signal) {
[16:01:50.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.517]                     {
[16:01:50.517]                       inherits <- base::inherits
[16:01:50.517]                       invokeRestart <- base::invokeRestart
[16:01:50.517]                       is.null <- base::is.null
[16:01:50.517]                       muffled <- FALSE
[16:01:50.517]                       if (inherits(cond, "message")) {
[16:01:50.517]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.517]                         if (muffled) 
[16:01:50.517]                           invokeRestart("muffleMessage")
[16:01:50.517]                       }
[16:01:50.517]                       else if (inherits(cond, "warning")) {
[16:01:50.517]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.517]                         if (muffled) 
[16:01:50.517]                           invokeRestart("muffleWarning")
[16:01:50.517]                       }
[16:01:50.517]                       else if (inherits(cond, "condition")) {
[16:01:50.517]                         if (!is.null(pattern)) {
[16:01:50.517]                           computeRestarts <- base::computeRestarts
[16:01:50.517]                           grepl <- base::grepl
[16:01:50.517]                           restarts <- computeRestarts(cond)
[16:01:50.517]                           for (restart in restarts) {
[16:01:50.517]                             name <- restart$name
[16:01:50.517]                             if (is.null(name)) 
[16:01:50.517]                               next
[16:01:50.517]                             if (!grepl(pattern, name)) 
[16:01:50.517]                               next
[16:01:50.517]                             invokeRestart(restart)
[16:01:50.517]                             muffled <- TRUE
[16:01:50.517]                             break
[16:01:50.517]                           }
[16:01:50.517]                         }
[16:01:50.517]                       }
[16:01:50.517]                       invisible(muffled)
[16:01:50.517]                     }
[16:01:50.517]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.517]                   }
[16:01:50.517]                 }
[16:01:50.517]                 else {
[16:01:50.517]                   if (TRUE) {
[16:01:50.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.517]                     {
[16:01:50.517]                       inherits <- base::inherits
[16:01:50.517]                       invokeRestart <- base::invokeRestart
[16:01:50.517]                       is.null <- base::is.null
[16:01:50.517]                       muffled <- FALSE
[16:01:50.517]                       if (inherits(cond, "message")) {
[16:01:50.517]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.517]                         if (muffled) 
[16:01:50.517]                           invokeRestart("muffleMessage")
[16:01:50.517]                       }
[16:01:50.517]                       else if (inherits(cond, "warning")) {
[16:01:50.517]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.517]                         if (muffled) 
[16:01:50.517]                           invokeRestart("muffleWarning")
[16:01:50.517]                       }
[16:01:50.517]                       else if (inherits(cond, "condition")) {
[16:01:50.517]                         if (!is.null(pattern)) {
[16:01:50.517]                           computeRestarts <- base::computeRestarts
[16:01:50.517]                           grepl <- base::grepl
[16:01:50.517]                           restarts <- computeRestarts(cond)
[16:01:50.517]                           for (restart in restarts) {
[16:01:50.517]                             name <- restart$name
[16:01:50.517]                             if (is.null(name)) 
[16:01:50.517]                               next
[16:01:50.517]                             if (!grepl(pattern, name)) 
[16:01:50.517]                               next
[16:01:50.517]                             invokeRestart(restart)
[16:01:50.517]                             muffled <- TRUE
[16:01:50.517]                             break
[16:01:50.517]                           }
[16:01:50.517]                         }
[16:01:50.517]                       }
[16:01:50.517]                       invisible(muffled)
[16:01:50.517]                     }
[16:01:50.517]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.517]                   }
[16:01:50.517]                 }
[16:01:50.517]             }
[16:01:50.517]         }))
[16:01:50.517]     }, error = function(ex) {
[16:01:50.517]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:50.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.517]                 ...future.rng), started = ...future.startTime, 
[16:01:50.517]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:50.517]             version = "1.8"), class = "FutureResult")
[16:01:50.517]     }, finally = {
[16:01:50.517]         if (!identical(...future.workdir, getwd())) 
[16:01:50.517]             setwd(...future.workdir)
[16:01:50.517]         {
[16:01:50.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:50.517]                 ...future.oldOptions$nwarnings <- NULL
[16:01:50.517]             }
[16:01:50.517]             base::options(...future.oldOptions)
[16:01:50.517]             if (.Platform$OS.type == "windows") {
[16:01:50.517]                 old_names <- names(...future.oldEnvVars)
[16:01:50.517]                 envs <- base::Sys.getenv()
[16:01:50.517]                 names <- names(envs)
[16:01:50.517]                 common <- intersect(names, old_names)
[16:01:50.517]                 added <- setdiff(names, old_names)
[16:01:50.517]                 removed <- setdiff(old_names, names)
[16:01:50.517]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:50.517]                   envs[common]]
[16:01:50.517]                 NAMES <- toupper(changed)
[16:01:50.517]                 args <- list()
[16:01:50.517]                 for (kk in seq_along(NAMES)) {
[16:01:50.517]                   name <- changed[[kk]]
[16:01:50.517]                   NAME <- NAMES[[kk]]
[16:01:50.517]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.517]                     next
[16:01:50.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.517]                 }
[16:01:50.517]                 NAMES <- toupper(added)
[16:01:50.517]                 for (kk in seq_along(NAMES)) {
[16:01:50.517]                   name <- added[[kk]]
[16:01:50.517]                   NAME <- NAMES[[kk]]
[16:01:50.517]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.517]                     next
[16:01:50.517]                   args[[name]] <- ""
[16:01:50.517]                 }
[16:01:50.517]                 NAMES <- toupper(removed)
[16:01:50.517]                 for (kk in seq_along(NAMES)) {
[16:01:50.517]                   name <- removed[[kk]]
[16:01:50.517]                   NAME <- NAMES[[kk]]
[16:01:50.517]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.517]                     next
[16:01:50.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.517]                 }
[16:01:50.517]                 if (length(args) > 0) 
[16:01:50.517]                   base::do.call(base::Sys.setenv, args = args)
[16:01:50.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:50.517]             }
[16:01:50.517]             else {
[16:01:50.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:50.517]             }
[16:01:50.517]             {
[16:01:50.517]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:50.517]                   0L) {
[16:01:50.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:50.517]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:50.517]                   base::options(opts)
[16:01:50.517]                 }
[16:01:50.517]                 {
[16:01:50.517]                   {
[16:01:50.517]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:50.517]                     NULL
[16:01:50.517]                   }
[16:01:50.517]                   options(future.plan = NULL)
[16:01:50.517]                   if (is.na(NA_character_)) 
[16:01:50.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:50.517]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:50.517]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:50.517]                     envir = parent.frame()) 
[16:01:50.517]                   {
[16:01:50.517]                     if (is.function(workers)) 
[16:01:50.517]                       workers <- workers()
[16:01:50.517]                     workers <- structure(as.integer(workers), 
[16:01:50.517]                       class = class(workers))
[16:01:50.517]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:50.517]                       workers >= 1)
[16:01:50.517]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:50.517]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:50.517]                     }
[16:01:50.517]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:50.517]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:50.517]                       envir = envir)
[16:01:50.517]                     if (!future$lazy) 
[16:01:50.517]                       future <- run(future)
[16:01:50.517]                     invisible(future)
[16:01:50.517]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:50.517]                 }
[16:01:50.517]             }
[16:01:50.517]         }
[16:01:50.517]     })
[16:01:50.517]     if (TRUE) {
[16:01:50.517]         base::sink(type = "output", split = FALSE)
[16:01:50.517]         if (TRUE) {
[16:01:50.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:50.517]         }
[16:01:50.517]         else {
[16:01:50.517]             ...future.result["stdout"] <- base::list(NULL)
[16:01:50.517]         }
[16:01:50.517]         base::close(...future.stdout)
[16:01:50.517]         ...future.stdout <- NULL
[16:01:50.517]     }
[16:01:50.517]     ...future.result$conditions <- ...future.conditions
[16:01:50.517]     ...future.result$finished <- base::Sys.time()
[16:01:50.517]     ...future.result
[16:01:50.517] }
[16:01:50.520] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[16:01:50.520] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:01:50.521] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:01:50.521] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:50.521] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:50.522] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:01:50.522] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:01:50.522] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:50.522] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:50.523] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:01:50.523] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:01:50.523] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[16:01:50.524] MultisessionFuture started
[16:01:50.524] - Launch lazy future ... done
[16:01:50.524] run() for ‘MultisessionFuture’ ... done
[16:01:50.524] Created future:
[16:01:50.524] MultisessionFuture:
[16:01:50.524] Label: ‘future_eapply-1’
[16:01:50.524] Expression:
[16:01:50.524] {
[16:01:50.524]     do.call(function(...) {
[16:01:50.524]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.524]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.524]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.524]             on.exit(options(oopts), add = TRUE)
[16:01:50.524]         }
[16:01:50.524]         {
[16:01:50.524]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.524]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.524]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.524]             })
[16:01:50.524]         }
[16:01:50.524]     }, args = future.call.arguments)
[16:01:50.524] }
[16:01:50.524] Lazy evaluation: FALSE
[16:01:50.524] Asynchronous evaluation: TRUE
[16:01:50.524] Local evaluation: TRUE
[16:01:50.524] Environment: R_GlobalEnv
[16:01:50.524] Capture standard output: TRUE
[16:01:50.524] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:50.524] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:50.524] Packages: 1 packages (‘stats’)
[16:01:50.524] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:50.524] Resolved: FALSE
[16:01:50.524] Value: <not collected>
[16:01:50.524] Conditions captured: <none>
[16:01:50.524] Early signaling: FALSE
[16:01:50.524] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:50.524] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.536] Chunk #1 of 2 ... DONE
[16:01:50.536] Chunk #2 of 2 ...
[16:01:50.536]  - Finding globals in 'X' for chunk #2 ...
[16:01:50.536] getGlobalsAndPackages() ...
[16:01:50.536] Searching for globals...
[16:01:50.536] 
[16:01:50.537] Searching for globals ... DONE
[16:01:50.537] - globals: [0] <none>
[16:01:50.537] getGlobalsAndPackages() ... DONE
[16:01:50.537]    + additional globals found: [n=0] 
[16:01:50.537]    + additional namespaces needed: [n=0] 
[16:01:50.537]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:50.537]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:50.537]  - seeds: <none>
[16:01:50.537]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.537] getGlobalsAndPackages() ...
[16:01:50.538] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.538] Resolving globals: FALSE
[16:01:50.538] Tweak future expression to call with '...' arguments ...
[16:01:50.538] {
[16:01:50.538]     do.call(function(...) {
[16:01:50.538]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.538]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.538]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.538]             on.exit(options(oopts), add = TRUE)
[16:01:50.538]         }
[16:01:50.538]         {
[16:01:50.538]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.538]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.538]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.538]             })
[16:01:50.538]         }
[16:01:50.538]     }, args = future.call.arguments)
[16:01:50.538] }
[16:01:50.538] Tweak future expression to call with '...' arguments ... DONE
[16:01:50.539] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.539] - packages: [1] ‘stats’
[16:01:50.539] getGlobalsAndPackages() ... DONE
[16:01:50.539] run() for ‘Future’ ...
[16:01:50.539] - state: ‘created’
[16:01:50.539] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:50.555] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:50.555]   - Field: ‘node’
[16:01:50.555]   - Field: ‘label’
[16:01:50.555]   - Field: ‘local’
[16:01:50.556]   - Field: ‘owner’
[16:01:50.556]   - Field: ‘envir’
[16:01:50.556]   - Field: ‘workers’
[16:01:50.556]   - Field: ‘packages’
[16:01:50.556]   - Field: ‘gc’
[16:01:50.556]   - Field: ‘conditions’
[16:01:50.556]   - Field: ‘persistent’
[16:01:50.556]   - Field: ‘expr’
[16:01:50.556]   - Field: ‘uuid’
[16:01:50.556]   - Field: ‘seed’
[16:01:50.556]   - Field: ‘version’
[16:01:50.557]   - Field: ‘result’
[16:01:50.557]   - Field: ‘asynchronous’
[16:01:50.557]   - Field: ‘calls’
[16:01:50.557]   - Field: ‘globals’
[16:01:50.557]   - Field: ‘stdout’
[16:01:50.557]   - Field: ‘earlySignal’
[16:01:50.557]   - Field: ‘lazy’
[16:01:50.557]   - Field: ‘state’
[16:01:50.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:50.557] - Launch lazy future ...
[16:01:50.558] Packages needed by the future expression (n = 1): ‘stats’
[16:01:50.558] Packages needed by future strategies (n = 0): <none>
[16:01:50.558] {
[16:01:50.558]     {
[16:01:50.558]         {
[16:01:50.558]             ...future.startTime <- base::Sys.time()
[16:01:50.558]             {
[16:01:50.558]                 {
[16:01:50.558]                   {
[16:01:50.558]                     {
[16:01:50.558]                       {
[16:01:50.558]                         base::local({
[16:01:50.558]                           has_future <- base::requireNamespace("future", 
[16:01:50.558]                             quietly = TRUE)
[16:01:50.558]                           if (has_future) {
[16:01:50.558]                             ns <- base::getNamespace("future")
[16:01:50.558]                             version <- ns[[".package"]][["version"]]
[16:01:50.558]                             if (is.null(version)) 
[16:01:50.558]                               version <- utils::packageVersion("future")
[16:01:50.558]                           }
[16:01:50.558]                           else {
[16:01:50.558]                             version <- NULL
[16:01:50.558]                           }
[16:01:50.558]                           if (!has_future || version < "1.8.0") {
[16:01:50.558]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:50.558]                               "", base::R.version$version.string), 
[16:01:50.558]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:50.558]                                 base::R.version$platform, 8 * 
[16:01:50.558]                                   base::.Machine$sizeof.pointer), 
[16:01:50.558]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:50.558]                                 "release", "version")], collapse = " "), 
[16:01:50.558]                               hostname = base::Sys.info()[["nodename"]])
[16:01:50.558]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:50.558]                               info)
[16:01:50.558]                             info <- base::paste(info, collapse = "; ")
[16:01:50.558]                             if (!has_future) {
[16:01:50.558]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:50.558]                                 info)
[16:01:50.558]                             }
[16:01:50.558]                             else {
[16:01:50.558]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:50.558]                                 info, version)
[16:01:50.558]                             }
[16:01:50.558]                             base::stop(msg)
[16:01:50.558]                           }
[16:01:50.558]                         })
[16:01:50.558]                       }
[16:01:50.558]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:50.558]                       base::options(mc.cores = 1L)
[16:01:50.558]                     }
[16:01:50.558]                     base::local({
[16:01:50.558]                       for (pkg in "stats") {
[16:01:50.558]                         base::loadNamespace(pkg)
[16:01:50.558]                         base::library(pkg, character.only = TRUE)
[16:01:50.558]                       }
[16:01:50.558]                     })
[16:01:50.558]                   }
[16:01:50.558]                   options(future.plan = NULL)
[16:01:50.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:50.558]                 }
[16:01:50.558]                 ...future.workdir <- getwd()
[16:01:50.558]             }
[16:01:50.558]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:50.558]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:50.558]         }
[16:01:50.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:50.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:50.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:50.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:50.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:50.558]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:50.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:50.558]             base::names(...future.oldOptions))
[16:01:50.558]     }
[16:01:50.558]     if (FALSE) {
[16:01:50.558]     }
[16:01:50.558]     else {
[16:01:50.558]         if (TRUE) {
[16:01:50.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:50.558]                 open = "w")
[16:01:50.558]         }
[16:01:50.558]         else {
[16:01:50.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:50.558]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:50.558]         }
[16:01:50.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:50.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:50.558]             base::sink(type = "output", split = FALSE)
[16:01:50.558]             base::close(...future.stdout)
[16:01:50.558]         }, add = TRUE)
[16:01:50.558]     }
[16:01:50.558]     ...future.frame <- base::sys.nframe()
[16:01:50.558]     ...future.conditions <- base::list()
[16:01:50.558]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:50.558]     if (FALSE) {
[16:01:50.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:50.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:50.558]     }
[16:01:50.558]     ...future.result <- base::tryCatch({
[16:01:50.558]         base::withCallingHandlers({
[16:01:50.558]             ...future.value <- base::withVisible(base::local({
[16:01:50.558]                 ...future.makeSendCondition <- base::local({
[16:01:50.558]                   sendCondition <- NULL
[16:01:50.558]                   function(frame = 1L) {
[16:01:50.558]                     if (is.function(sendCondition)) 
[16:01:50.558]                       return(sendCondition)
[16:01:50.558]                     ns <- getNamespace("parallel")
[16:01:50.558]                     if (exists("sendData", mode = "function", 
[16:01:50.558]                       envir = ns)) {
[16:01:50.558]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:50.558]                         envir = ns)
[16:01:50.558]                       envir <- sys.frame(frame)
[16:01:50.558]                       master <- NULL
[16:01:50.558]                       while (!identical(envir, .GlobalEnv) && 
[16:01:50.558]                         !identical(envir, emptyenv())) {
[16:01:50.558]                         if (exists("master", mode = "list", envir = envir, 
[16:01:50.558]                           inherits = FALSE)) {
[16:01:50.558]                           master <- get("master", mode = "list", 
[16:01:50.558]                             envir = envir, inherits = FALSE)
[16:01:50.558]                           if (inherits(master, c("SOCKnode", 
[16:01:50.558]                             "SOCK0node"))) {
[16:01:50.558]                             sendCondition <<- function(cond) {
[16:01:50.558]                               data <- list(type = "VALUE", value = cond, 
[16:01:50.558]                                 success = TRUE)
[16:01:50.558]                               parallel_sendData(master, data)
[16:01:50.558]                             }
[16:01:50.558]                             return(sendCondition)
[16:01:50.558]                           }
[16:01:50.558]                         }
[16:01:50.558]                         frame <- frame + 1L
[16:01:50.558]                         envir <- sys.frame(frame)
[16:01:50.558]                       }
[16:01:50.558]                     }
[16:01:50.558]                     sendCondition <<- function(cond) NULL
[16:01:50.558]                   }
[16:01:50.558]                 })
[16:01:50.558]                 withCallingHandlers({
[16:01:50.558]                   {
[16:01:50.558]                     do.call(function(...) {
[16:01:50.558]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.558]                       if (!identical(...future.globals.maxSize.org, 
[16:01:50.558]                         ...future.globals.maxSize)) {
[16:01:50.558]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.558]                         on.exit(options(oopts), add = TRUE)
[16:01:50.558]                       }
[16:01:50.558]                       {
[16:01:50.558]                         lapply(seq_along(...future.elements_ii), 
[16:01:50.558]                           FUN = function(jj) {
[16:01:50.558]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.558]                             ...future.FUN(...future.X_jj, ...)
[16:01:50.558]                           })
[16:01:50.558]                       }
[16:01:50.558]                     }, args = future.call.arguments)
[16:01:50.558]                   }
[16:01:50.558]                 }, immediateCondition = function(cond) {
[16:01:50.558]                   sendCondition <- ...future.makeSendCondition()
[16:01:50.558]                   sendCondition(cond)
[16:01:50.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.558]                   {
[16:01:50.558]                     inherits <- base::inherits
[16:01:50.558]                     invokeRestart <- base::invokeRestart
[16:01:50.558]                     is.null <- base::is.null
[16:01:50.558]                     muffled <- FALSE
[16:01:50.558]                     if (inherits(cond, "message")) {
[16:01:50.558]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:50.558]                       if (muffled) 
[16:01:50.558]                         invokeRestart("muffleMessage")
[16:01:50.558]                     }
[16:01:50.558]                     else if (inherits(cond, "warning")) {
[16:01:50.558]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:50.558]                       if (muffled) 
[16:01:50.558]                         invokeRestart("muffleWarning")
[16:01:50.558]                     }
[16:01:50.558]                     else if (inherits(cond, "condition")) {
[16:01:50.558]                       if (!is.null(pattern)) {
[16:01:50.558]                         computeRestarts <- base::computeRestarts
[16:01:50.558]                         grepl <- base::grepl
[16:01:50.558]                         restarts <- computeRestarts(cond)
[16:01:50.558]                         for (restart in restarts) {
[16:01:50.558]                           name <- restart$name
[16:01:50.558]                           if (is.null(name)) 
[16:01:50.558]                             next
[16:01:50.558]                           if (!grepl(pattern, name)) 
[16:01:50.558]                             next
[16:01:50.558]                           invokeRestart(restart)
[16:01:50.558]                           muffled <- TRUE
[16:01:50.558]                           break
[16:01:50.558]                         }
[16:01:50.558]                       }
[16:01:50.558]                     }
[16:01:50.558]                     invisible(muffled)
[16:01:50.558]                   }
[16:01:50.558]                   muffleCondition(cond)
[16:01:50.558]                 })
[16:01:50.558]             }))
[16:01:50.558]             future::FutureResult(value = ...future.value$value, 
[16:01:50.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.558]                   ...future.rng), globalenv = if (FALSE) 
[16:01:50.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:50.558]                     ...future.globalenv.names))
[16:01:50.558]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:50.558]         }, condition = base::local({
[16:01:50.558]             c <- base::c
[16:01:50.558]             inherits <- base::inherits
[16:01:50.558]             invokeRestart <- base::invokeRestart
[16:01:50.558]             length <- base::length
[16:01:50.558]             list <- base::list
[16:01:50.558]             seq.int <- base::seq.int
[16:01:50.558]             signalCondition <- base::signalCondition
[16:01:50.558]             sys.calls <- base::sys.calls
[16:01:50.558]             `[[` <- base::`[[`
[16:01:50.558]             `+` <- base::`+`
[16:01:50.558]             `<<-` <- base::`<<-`
[16:01:50.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:50.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:50.558]                   3L)]
[16:01:50.558]             }
[16:01:50.558]             function(cond) {
[16:01:50.558]                 is_error <- inherits(cond, "error")
[16:01:50.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:50.558]                   NULL)
[16:01:50.558]                 if (is_error) {
[16:01:50.558]                   sessionInformation <- function() {
[16:01:50.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:50.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:50.558]                       search = base::search(), system = base::Sys.info())
[16:01:50.558]                   }
[16:01:50.558]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:50.558]                     cond$call), session = sessionInformation(), 
[16:01:50.558]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:50.558]                   signalCondition(cond)
[16:01:50.558]                 }
[16:01:50.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:50.558]                 "immediateCondition"))) {
[16:01:50.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:50.558]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:50.558]                   if (TRUE && !signal) {
[16:01:50.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.558]                     {
[16:01:50.558]                       inherits <- base::inherits
[16:01:50.558]                       invokeRestart <- base::invokeRestart
[16:01:50.558]                       is.null <- base::is.null
[16:01:50.558]                       muffled <- FALSE
[16:01:50.558]                       if (inherits(cond, "message")) {
[16:01:50.558]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.558]                         if (muffled) 
[16:01:50.558]                           invokeRestart("muffleMessage")
[16:01:50.558]                       }
[16:01:50.558]                       else if (inherits(cond, "warning")) {
[16:01:50.558]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.558]                         if (muffled) 
[16:01:50.558]                           invokeRestart("muffleWarning")
[16:01:50.558]                       }
[16:01:50.558]                       else if (inherits(cond, "condition")) {
[16:01:50.558]                         if (!is.null(pattern)) {
[16:01:50.558]                           computeRestarts <- base::computeRestarts
[16:01:50.558]                           grepl <- base::grepl
[16:01:50.558]                           restarts <- computeRestarts(cond)
[16:01:50.558]                           for (restart in restarts) {
[16:01:50.558]                             name <- restart$name
[16:01:50.558]                             if (is.null(name)) 
[16:01:50.558]                               next
[16:01:50.558]                             if (!grepl(pattern, name)) 
[16:01:50.558]                               next
[16:01:50.558]                             invokeRestart(restart)
[16:01:50.558]                             muffled <- TRUE
[16:01:50.558]                             break
[16:01:50.558]                           }
[16:01:50.558]                         }
[16:01:50.558]                       }
[16:01:50.558]                       invisible(muffled)
[16:01:50.558]                     }
[16:01:50.558]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.558]                   }
[16:01:50.558]                 }
[16:01:50.558]                 else {
[16:01:50.558]                   if (TRUE) {
[16:01:50.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.558]                     {
[16:01:50.558]                       inherits <- base::inherits
[16:01:50.558]                       invokeRestart <- base::invokeRestart
[16:01:50.558]                       is.null <- base::is.null
[16:01:50.558]                       muffled <- FALSE
[16:01:50.558]                       if (inherits(cond, "message")) {
[16:01:50.558]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.558]                         if (muffled) 
[16:01:50.558]                           invokeRestart("muffleMessage")
[16:01:50.558]                       }
[16:01:50.558]                       else if (inherits(cond, "warning")) {
[16:01:50.558]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.558]                         if (muffled) 
[16:01:50.558]                           invokeRestart("muffleWarning")
[16:01:50.558]                       }
[16:01:50.558]                       else if (inherits(cond, "condition")) {
[16:01:50.558]                         if (!is.null(pattern)) {
[16:01:50.558]                           computeRestarts <- base::computeRestarts
[16:01:50.558]                           grepl <- base::grepl
[16:01:50.558]                           restarts <- computeRestarts(cond)
[16:01:50.558]                           for (restart in restarts) {
[16:01:50.558]                             name <- restart$name
[16:01:50.558]                             if (is.null(name)) 
[16:01:50.558]                               next
[16:01:50.558]                             if (!grepl(pattern, name)) 
[16:01:50.558]                               next
[16:01:50.558]                             invokeRestart(restart)
[16:01:50.558]                             muffled <- TRUE
[16:01:50.558]                             break
[16:01:50.558]                           }
[16:01:50.558]                         }
[16:01:50.558]                       }
[16:01:50.558]                       invisible(muffled)
[16:01:50.558]                     }
[16:01:50.558]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.558]                   }
[16:01:50.558]                 }
[16:01:50.558]             }
[16:01:50.558]         }))
[16:01:50.558]     }, error = function(ex) {
[16:01:50.558]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:50.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.558]                 ...future.rng), started = ...future.startTime, 
[16:01:50.558]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:50.558]             version = "1.8"), class = "FutureResult")
[16:01:50.558]     }, finally = {
[16:01:50.558]         if (!identical(...future.workdir, getwd())) 
[16:01:50.558]             setwd(...future.workdir)
[16:01:50.558]         {
[16:01:50.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:50.558]                 ...future.oldOptions$nwarnings <- NULL
[16:01:50.558]             }
[16:01:50.558]             base::options(...future.oldOptions)
[16:01:50.558]             if (.Platform$OS.type == "windows") {
[16:01:50.558]                 old_names <- names(...future.oldEnvVars)
[16:01:50.558]                 envs <- base::Sys.getenv()
[16:01:50.558]                 names <- names(envs)
[16:01:50.558]                 common <- intersect(names, old_names)
[16:01:50.558]                 added <- setdiff(names, old_names)
[16:01:50.558]                 removed <- setdiff(old_names, names)
[16:01:50.558]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:50.558]                   envs[common]]
[16:01:50.558]                 NAMES <- toupper(changed)
[16:01:50.558]                 args <- list()
[16:01:50.558]                 for (kk in seq_along(NAMES)) {
[16:01:50.558]                   name <- changed[[kk]]
[16:01:50.558]                   NAME <- NAMES[[kk]]
[16:01:50.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.558]                     next
[16:01:50.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.558]                 }
[16:01:50.558]                 NAMES <- toupper(added)
[16:01:50.558]                 for (kk in seq_along(NAMES)) {
[16:01:50.558]                   name <- added[[kk]]
[16:01:50.558]                   NAME <- NAMES[[kk]]
[16:01:50.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.558]                     next
[16:01:50.558]                   args[[name]] <- ""
[16:01:50.558]                 }
[16:01:50.558]                 NAMES <- toupper(removed)
[16:01:50.558]                 for (kk in seq_along(NAMES)) {
[16:01:50.558]                   name <- removed[[kk]]
[16:01:50.558]                   NAME <- NAMES[[kk]]
[16:01:50.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.558]                     next
[16:01:50.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.558]                 }
[16:01:50.558]                 if (length(args) > 0) 
[16:01:50.558]                   base::do.call(base::Sys.setenv, args = args)
[16:01:50.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:50.558]             }
[16:01:50.558]             else {
[16:01:50.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:50.558]             }
[16:01:50.558]             {
[16:01:50.558]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:50.558]                   0L) {
[16:01:50.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:50.558]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:50.558]                   base::options(opts)
[16:01:50.558]                 }
[16:01:50.558]                 {
[16:01:50.558]                   {
[16:01:50.558]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:50.558]                     NULL
[16:01:50.558]                   }
[16:01:50.558]                   options(future.plan = NULL)
[16:01:50.558]                   if (is.na(NA_character_)) 
[16:01:50.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:50.558]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:50.558]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:50.558]                     envir = parent.frame()) 
[16:01:50.558]                   {
[16:01:50.558]                     if (is.function(workers)) 
[16:01:50.558]                       workers <- workers()
[16:01:50.558]                     workers <- structure(as.integer(workers), 
[16:01:50.558]                       class = class(workers))
[16:01:50.558]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:50.558]                       workers >= 1)
[16:01:50.558]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:50.558]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:50.558]                     }
[16:01:50.558]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:50.558]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:50.558]                       envir = envir)
[16:01:50.558]                     if (!future$lazy) 
[16:01:50.558]                       future <- run(future)
[16:01:50.558]                     invisible(future)
[16:01:50.558]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:50.558]                 }
[16:01:50.558]             }
[16:01:50.558]         }
[16:01:50.558]     })
[16:01:50.558]     if (TRUE) {
[16:01:50.558]         base::sink(type = "output", split = FALSE)
[16:01:50.558]         if (TRUE) {
[16:01:50.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:50.558]         }
[16:01:50.558]         else {
[16:01:50.558]             ...future.result["stdout"] <- base::list(NULL)
[16:01:50.558]         }
[16:01:50.558]         base::close(...future.stdout)
[16:01:50.558]         ...future.stdout <- NULL
[16:01:50.558]     }
[16:01:50.558]     ...future.result$conditions <- ...future.conditions
[16:01:50.558]     ...future.result$finished <- base::Sys.time()
[16:01:50.558]     ...future.result
[16:01:50.558] }
[16:01:50.561] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[16:01:50.561] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:01:50.562] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:01:50.562] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:50.562] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:50.563] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:01:50.563] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:01:50.563] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:50.564] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:50.564] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:01:50.564] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:01:50.564] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[16:01:50.565] MultisessionFuture started
[16:01:50.565] - Launch lazy future ... done
[16:01:50.565] run() for ‘MultisessionFuture’ ... done
[16:01:50.565] Created future:
[16:01:50.565] MultisessionFuture:
[16:01:50.565] Label: ‘future_eapply-2’
[16:01:50.565] Expression:
[16:01:50.565] {
[16:01:50.565]     do.call(function(...) {
[16:01:50.565]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.565]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.565]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.565]             on.exit(options(oopts), add = TRUE)
[16:01:50.565]         }
[16:01:50.565]         {
[16:01:50.565]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.565]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.565]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.565]             })
[16:01:50.565]         }
[16:01:50.565]     }, args = future.call.arguments)
[16:01:50.565] }
[16:01:50.565] Lazy evaluation: FALSE
[16:01:50.565] Asynchronous evaluation: TRUE
[16:01:50.565] Local evaluation: TRUE
[16:01:50.565] Environment: R_GlobalEnv
[16:01:50.565] Capture standard output: TRUE
[16:01:50.565] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:50.565] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:50.565] Packages: 1 packages (‘stats’)
[16:01:50.565] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:50.565] Resolved: FALSE
[16:01:50.565] Value: <not collected>
[16:01:50.565] Conditions captured: <none>
[16:01:50.565] Early signaling: FALSE
[16:01:50.565] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:50.565] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.577] Chunk #2 of 2 ... DONE
[16:01:50.577] Launching 2 futures (chunks) ... DONE
[16:01:50.577] Resolving 2 futures (chunks) ...
[16:01:50.577] resolve() on list ...
[16:01:50.577]  recursive: 0
[16:01:50.578]  length: 2
[16:01:50.578] 
[16:01:50.578] receiveMessageFromWorker() for ClusterFuture ...
[16:01:50.578] - Validating connection of MultisessionFuture
[16:01:50.578] - received message: FutureResult
[16:01:50.579] - Received FutureResult
[16:01:50.579] - Erased future from FutureRegistry
[16:01:50.579] result() for ClusterFuture ...
[16:01:50.579] - result already collected: FutureResult
[16:01:50.579] result() for ClusterFuture ... done
[16:01:50.579] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:50.579] Future #1
[16:01:50.579] result() for ClusterFuture ...
[16:01:50.579] - result already collected: FutureResult
[16:01:50.579] result() for ClusterFuture ... done
[16:01:50.580] result() for ClusterFuture ...
[16:01:50.580] - result already collected: FutureResult
[16:01:50.580] result() for ClusterFuture ... done
[16:01:50.580] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:50.580] - nx: 2
[16:01:50.580] - relay: TRUE
[16:01:50.580] - stdout: TRUE
[16:01:50.580] - signal: TRUE
[16:01:50.580] - resignal: FALSE
[16:01:50.580] - force: TRUE
[16:01:50.580] - relayed: [n=2] FALSE, FALSE
[16:01:50.580] - queued futures: [n=2] FALSE, FALSE
[16:01:50.581]  - until=1
[16:01:50.581]  - relaying element #1
[16:01:50.581] result() for ClusterFuture ...
[16:01:50.581] - result already collected: FutureResult
[16:01:50.581] result() for ClusterFuture ... done
[16:01:50.581] result() for ClusterFuture ...
[16:01:50.581] - result already collected: FutureResult
[16:01:50.581] result() for ClusterFuture ... done
[16:01:50.581] result() for ClusterFuture ...
[16:01:50.581] - result already collected: FutureResult
[16:01:50.581] result() for ClusterFuture ... done
[16:01:50.582] result() for ClusterFuture ...
[16:01:50.582] - result already collected: FutureResult
[16:01:50.582] result() for ClusterFuture ... done
[16:01:50.582] - relayed: [n=2] TRUE, FALSE
[16:01:50.582] - queued futures: [n=2] TRUE, FALSE
[16:01:50.582] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:50.582]  length: 1 (resolved future 1)
[16:01:50.613] receiveMessageFromWorker() for ClusterFuture ...
[16:01:50.613] - Validating connection of MultisessionFuture
[16:01:50.613] - received message: FutureResult
[16:01:50.614] - Received FutureResult
[16:01:50.614] - Erased future from FutureRegistry
[16:01:50.614] result() for ClusterFuture ...
[16:01:50.614] - result already collected: FutureResult
[16:01:50.614] result() for ClusterFuture ... done
[16:01:50.614] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:50.614] Future #2
[16:01:50.614] result() for ClusterFuture ...
[16:01:50.614] - result already collected: FutureResult
[16:01:50.614] result() for ClusterFuture ... done
[16:01:50.615] result() for ClusterFuture ...
[16:01:50.615] - result already collected: FutureResult
[16:01:50.615] result() for ClusterFuture ... done
[16:01:50.615] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:50.615] - nx: 2
[16:01:50.615] - relay: TRUE
[16:01:50.615] - stdout: TRUE
[16:01:50.615] - signal: TRUE
[16:01:50.615] - resignal: FALSE
[16:01:50.615] - force: TRUE
[16:01:50.615] - relayed: [n=2] TRUE, FALSE
[16:01:50.616] - queued futures: [n=2] TRUE, FALSE
[16:01:50.616]  - until=2
[16:01:50.616]  - relaying element #2
[16:01:50.616] result() for ClusterFuture ...
[16:01:50.616] - result already collected: FutureResult
[16:01:50.616] result() for ClusterFuture ... done
[16:01:50.616] result() for ClusterFuture ...
[16:01:50.616] - result already collected: FutureResult
[16:01:50.616] result() for ClusterFuture ... done
[16:01:50.616] result() for ClusterFuture ...
[16:01:50.616] - result already collected: FutureResult
[16:01:50.617] result() for ClusterFuture ... done
[16:01:50.617] result() for ClusterFuture ...
[16:01:50.617] - result already collected: FutureResult
[16:01:50.617] result() for ClusterFuture ... done
[16:01:50.617] - relayed: [n=2] TRUE, TRUE
[16:01:50.617] - queued futures: [n=2] TRUE, TRUE
[16:01:50.617] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:50.617]  length: 0 (resolved future 2)
[16:01:50.617] Relaying remaining futures
[16:01:50.617] signalConditionsASAP(NULL, pos=0) ...
[16:01:50.617] - nx: 2
[16:01:50.618] - relay: TRUE
[16:01:50.618] - stdout: TRUE
[16:01:50.618] - signal: TRUE
[16:01:50.618] - resignal: FALSE
[16:01:50.618] - force: TRUE
[16:01:50.618] - relayed: [n=2] TRUE, TRUE
[16:01:50.618] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:50.618] - relayed: [n=2] TRUE, TRUE
[16:01:50.618] - queued futures: [n=2] TRUE, TRUE
[16:01:50.618] signalConditionsASAP(NULL, pos=0) ... done
[16:01:50.618] resolve() on list ... DONE
[16:01:50.619] result() for ClusterFuture ...
[16:01:50.619] - result already collected: FutureResult
[16:01:50.619] result() for ClusterFuture ... done
[16:01:50.619] result() for ClusterFuture ...
[16:01:50.619] - result already collected: FutureResult
[16:01:50.619] result() for ClusterFuture ... done
[16:01:50.619] result() for ClusterFuture ...
[16:01:50.619] - result already collected: FutureResult
[16:01:50.619] result() for ClusterFuture ... done
[16:01:50.619] result() for ClusterFuture ...
[16:01:50.620] - result already collected: FutureResult
[16:01:50.620] result() for ClusterFuture ... done
[16:01:50.620]  - Number of value chunks collected: 2
[16:01:50.620] Resolving 2 futures (chunks) ... DONE
[16:01:50.620] Reducing values from 2 chunks ...
[16:01:50.620]  - Number of values collected after concatenation: 3
[16:01:50.620]  - Number of values expected: 3
[16:01:50.620] Reducing values from 2 chunks ... DONE
[16:01:50.620] future_lapply() ... DONE
[16:01:50.621] future_lapply() ...
[16:01:50.625] Number of chunks: 2
[16:01:50.625] getGlobalsAndPackagesXApply() ...
[16:01:50.625]  - future.globals: TRUE
[16:01:50.625] getGlobalsAndPackages() ...
[16:01:50.625] Searching for globals...
[16:01:50.626] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:50.626] Searching for globals ... DONE
[16:01:50.626] Resolving globals: FALSE
[16:01:50.627] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:50.627] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:50.627] - globals: [1] ‘FUN’
[16:01:50.627] - packages: [1] ‘stats’
[16:01:50.628] getGlobalsAndPackages() ... DONE
[16:01:50.628]  - globals found/used: [n=1] ‘FUN’
[16:01:50.628]  - needed namespaces: [n=1] ‘stats’
[16:01:50.628] Finding globals ... DONE
[16:01:50.628]  - use_args: TRUE
[16:01:50.628]  - Getting '...' globals ...
[16:01:50.628] resolve() on list ...
[16:01:50.628]  recursive: 0
[16:01:50.629]  length: 1
[16:01:50.629]  elements: ‘...’
[16:01:50.629]  length: 0 (resolved future 1)
[16:01:50.629] resolve() on list ... DONE
[16:01:50.629]    - '...' content: [n=0] 
[16:01:50.629] List of 1
[16:01:50.629]  $ ...: list()
[16:01:50.629]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:50.629]  - attr(*, "where")=List of 1
[16:01:50.629]   ..$ ...:<environment: 0x5620a27dd2d8> 
[16:01:50.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:50.629]  - attr(*, "resolved")= logi TRUE
[16:01:50.629]  - attr(*, "total_size")= num NA
[16:01:50.632]  - Getting '...' globals ... DONE
[16:01:50.632] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:50.632] List of 2
[16:01:50.632]  $ ...future.FUN:function (x, ...)  
[16:01:50.632]  $ ...          : list()
[16:01:50.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:50.632]  - attr(*, "where")=List of 2
[16:01:50.632]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:50.632]   ..$ ...          :<environment: 0x5620a27dd2d8> 
[16:01:50.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:50.632]  - attr(*, "resolved")= logi FALSE
[16:01:50.632]  - attr(*, "total_size")= num 1248
[16:01:50.634] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:50.635] getGlobalsAndPackagesXApply() ... DONE
[16:01:50.635] Number of futures (= number of chunks): 2
[16:01:50.635] Launching 2 futures (chunks) ...
[16:01:50.635] Chunk #1 of 2 ...
[16:01:50.635]  - Finding globals in 'X' for chunk #1 ...
[16:01:50.635] getGlobalsAndPackages() ...
[16:01:50.635] Searching for globals...
[16:01:50.636] 
[16:01:50.636] Searching for globals ... DONE
[16:01:50.636] - globals: [0] <none>
[16:01:50.636] getGlobalsAndPackages() ... DONE
[16:01:50.636]    + additional globals found: [n=0] 
[16:01:50.636]    + additional namespaces needed: [n=0] 
[16:01:50.636]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:50.636]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:50.636]  - seeds: <none>
[16:01:50.636]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.637] getGlobalsAndPackages() ...
[16:01:50.637] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.637] Resolving globals: FALSE
[16:01:50.637] Tweak future expression to call with '...' arguments ...
[16:01:50.637] {
[16:01:50.637]     do.call(function(...) {
[16:01:50.637]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.637]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.637]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.637]             on.exit(options(oopts), add = TRUE)
[16:01:50.637]         }
[16:01:50.637]         {
[16:01:50.637]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.637]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.637]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.637]             })
[16:01:50.637]         }
[16:01:50.637]     }, args = future.call.arguments)
[16:01:50.637] }
[16:01:50.637] Tweak future expression to call with '...' arguments ... DONE
[16:01:50.638] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.638] - packages: [1] ‘stats’
[16:01:50.638] getGlobalsAndPackages() ... DONE
[16:01:50.638] run() for ‘Future’ ...
[16:01:50.638] - state: ‘created’
[16:01:50.638] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:50.652] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.652] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:50.652]   - Field: ‘node’
[16:01:50.652]   - Field: ‘label’
[16:01:50.653]   - Field: ‘local’
[16:01:50.653]   - Field: ‘owner’
[16:01:50.653]   - Field: ‘envir’
[16:01:50.653]   - Field: ‘workers’
[16:01:50.653]   - Field: ‘packages’
[16:01:50.653]   - Field: ‘gc’
[16:01:50.653]   - Field: ‘conditions’
[16:01:50.653]   - Field: ‘persistent’
[16:01:50.653]   - Field: ‘expr’
[16:01:50.653]   - Field: ‘uuid’
[16:01:50.653]   - Field: ‘seed’
[16:01:50.654]   - Field: ‘version’
[16:01:50.654]   - Field: ‘result’
[16:01:50.654]   - Field: ‘asynchronous’
[16:01:50.654]   - Field: ‘calls’
[16:01:50.654]   - Field: ‘globals’
[16:01:50.654]   - Field: ‘stdout’
[16:01:50.654]   - Field: ‘earlySignal’
[16:01:50.654]   - Field: ‘lazy’
[16:01:50.654]   - Field: ‘state’
[16:01:50.654] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:50.654] - Launch lazy future ...
[16:01:50.655] Packages needed by the future expression (n = 1): ‘stats’
[16:01:50.655] Packages needed by future strategies (n = 0): <none>
[16:01:50.656] {
[16:01:50.656]     {
[16:01:50.656]         {
[16:01:50.656]             ...future.startTime <- base::Sys.time()
[16:01:50.656]             {
[16:01:50.656]                 {
[16:01:50.656]                   {
[16:01:50.656]                     {
[16:01:50.656]                       {
[16:01:50.656]                         base::local({
[16:01:50.656]                           has_future <- base::requireNamespace("future", 
[16:01:50.656]                             quietly = TRUE)
[16:01:50.656]                           if (has_future) {
[16:01:50.656]                             ns <- base::getNamespace("future")
[16:01:50.656]                             version <- ns[[".package"]][["version"]]
[16:01:50.656]                             if (is.null(version)) 
[16:01:50.656]                               version <- utils::packageVersion("future")
[16:01:50.656]                           }
[16:01:50.656]                           else {
[16:01:50.656]                             version <- NULL
[16:01:50.656]                           }
[16:01:50.656]                           if (!has_future || version < "1.8.0") {
[16:01:50.656]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:50.656]                               "", base::R.version$version.string), 
[16:01:50.656]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:50.656]                                 base::R.version$platform, 8 * 
[16:01:50.656]                                   base::.Machine$sizeof.pointer), 
[16:01:50.656]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:50.656]                                 "release", "version")], collapse = " "), 
[16:01:50.656]                               hostname = base::Sys.info()[["nodename"]])
[16:01:50.656]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:50.656]                               info)
[16:01:50.656]                             info <- base::paste(info, collapse = "; ")
[16:01:50.656]                             if (!has_future) {
[16:01:50.656]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:50.656]                                 info)
[16:01:50.656]                             }
[16:01:50.656]                             else {
[16:01:50.656]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:50.656]                                 info, version)
[16:01:50.656]                             }
[16:01:50.656]                             base::stop(msg)
[16:01:50.656]                           }
[16:01:50.656]                         })
[16:01:50.656]                       }
[16:01:50.656]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:50.656]                       base::options(mc.cores = 1L)
[16:01:50.656]                     }
[16:01:50.656]                     base::local({
[16:01:50.656]                       for (pkg in "stats") {
[16:01:50.656]                         base::loadNamespace(pkg)
[16:01:50.656]                         base::library(pkg, character.only = TRUE)
[16:01:50.656]                       }
[16:01:50.656]                     })
[16:01:50.656]                   }
[16:01:50.656]                   options(future.plan = NULL)
[16:01:50.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:50.656]                 }
[16:01:50.656]                 ...future.workdir <- getwd()
[16:01:50.656]             }
[16:01:50.656]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:50.656]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:50.656]         }
[16:01:50.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:50.656]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:50.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:50.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:50.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:50.656]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:50.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:50.656]             base::names(...future.oldOptions))
[16:01:50.656]     }
[16:01:50.656]     if (FALSE) {
[16:01:50.656]     }
[16:01:50.656]     else {
[16:01:50.656]         if (TRUE) {
[16:01:50.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:50.656]                 open = "w")
[16:01:50.656]         }
[16:01:50.656]         else {
[16:01:50.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:50.656]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:50.656]         }
[16:01:50.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:50.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:50.656]             base::sink(type = "output", split = FALSE)
[16:01:50.656]             base::close(...future.stdout)
[16:01:50.656]         }, add = TRUE)
[16:01:50.656]     }
[16:01:50.656]     ...future.frame <- base::sys.nframe()
[16:01:50.656]     ...future.conditions <- base::list()
[16:01:50.656]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:50.656]     if (FALSE) {
[16:01:50.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:50.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:50.656]     }
[16:01:50.656]     ...future.result <- base::tryCatch({
[16:01:50.656]         base::withCallingHandlers({
[16:01:50.656]             ...future.value <- base::withVisible(base::local({
[16:01:50.656]                 ...future.makeSendCondition <- base::local({
[16:01:50.656]                   sendCondition <- NULL
[16:01:50.656]                   function(frame = 1L) {
[16:01:50.656]                     if (is.function(sendCondition)) 
[16:01:50.656]                       return(sendCondition)
[16:01:50.656]                     ns <- getNamespace("parallel")
[16:01:50.656]                     if (exists("sendData", mode = "function", 
[16:01:50.656]                       envir = ns)) {
[16:01:50.656]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:50.656]                         envir = ns)
[16:01:50.656]                       envir <- sys.frame(frame)
[16:01:50.656]                       master <- NULL
[16:01:50.656]                       while (!identical(envir, .GlobalEnv) && 
[16:01:50.656]                         !identical(envir, emptyenv())) {
[16:01:50.656]                         if (exists("master", mode = "list", envir = envir, 
[16:01:50.656]                           inherits = FALSE)) {
[16:01:50.656]                           master <- get("master", mode = "list", 
[16:01:50.656]                             envir = envir, inherits = FALSE)
[16:01:50.656]                           if (inherits(master, c("SOCKnode", 
[16:01:50.656]                             "SOCK0node"))) {
[16:01:50.656]                             sendCondition <<- function(cond) {
[16:01:50.656]                               data <- list(type = "VALUE", value = cond, 
[16:01:50.656]                                 success = TRUE)
[16:01:50.656]                               parallel_sendData(master, data)
[16:01:50.656]                             }
[16:01:50.656]                             return(sendCondition)
[16:01:50.656]                           }
[16:01:50.656]                         }
[16:01:50.656]                         frame <- frame + 1L
[16:01:50.656]                         envir <- sys.frame(frame)
[16:01:50.656]                       }
[16:01:50.656]                     }
[16:01:50.656]                     sendCondition <<- function(cond) NULL
[16:01:50.656]                   }
[16:01:50.656]                 })
[16:01:50.656]                 withCallingHandlers({
[16:01:50.656]                   {
[16:01:50.656]                     do.call(function(...) {
[16:01:50.656]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.656]                       if (!identical(...future.globals.maxSize.org, 
[16:01:50.656]                         ...future.globals.maxSize)) {
[16:01:50.656]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.656]                         on.exit(options(oopts), add = TRUE)
[16:01:50.656]                       }
[16:01:50.656]                       {
[16:01:50.656]                         lapply(seq_along(...future.elements_ii), 
[16:01:50.656]                           FUN = function(jj) {
[16:01:50.656]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.656]                             ...future.FUN(...future.X_jj, ...)
[16:01:50.656]                           })
[16:01:50.656]                       }
[16:01:50.656]                     }, args = future.call.arguments)
[16:01:50.656]                   }
[16:01:50.656]                 }, immediateCondition = function(cond) {
[16:01:50.656]                   sendCondition <- ...future.makeSendCondition()
[16:01:50.656]                   sendCondition(cond)
[16:01:50.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.656]                   {
[16:01:50.656]                     inherits <- base::inherits
[16:01:50.656]                     invokeRestart <- base::invokeRestart
[16:01:50.656]                     is.null <- base::is.null
[16:01:50.656]                     muffled <- FALSE
[16:01:50.656]                     if (inherits(cond, "message")) {
[16:01:50.656]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:50.656]                       if (muffled) 
[16:01:50.656]                         invokeRestart("muffleMessage")
[16:01:50.656]                     }
[16:01:50.656]                     else if (inherits(cond, "warning")) {
[16:01:50.656]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:50.656]                       if (muffled) 
[16:01:50.656]                         invokeRestart("muffleWarning")
[16:01:50.656]                     }
[16:01:50.656]                     else if (inherits(cond, "condition")) {
[16:01:50.656]                       if (!is.null(pattern)) {
[16:01:50.656]                         computeRestarts <- base::computeRestarts
[16:01:50.656]                         grepl <- base::grepl
[16:01:50.656]                         restarts <- computeRestarts(cond)
[16:01:50.656]                         for (restart in restarts) {
[16:01:50.656]                           name <- restart$name
[16:01:50.656]                           if (is.null(name)) 
[16:01:50.656]                             next
[16:01:50.656]                           if (!grepl(pattern, name)) 
[16:01:50.656]                             next
[16:01:50.656]                           invokeRestart(restart)
[16:01:50.656]                           muffled <- TRUE
[16:01:50.656]                           break
[16:01:50.656]                         }
[16:01:50.656]                       }
[16:01:50.656]                     }
[16:01:50.656]                     invisible(muffled)
[16:01:50.656]                   }
[16:01:50.656]                   muffleCondition(cond)
[16:01:50.656]                 })
[16:01:50.656]             }))
[16:01:50.656]             future::FutureResult(value = ...future.value$value, 
[16:01:50.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.656]                   ...future.rng), globalenv = if (FALSE) 
[16:01:50.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:50.656]                     ...future.globalenv.names))
[16:01:50.656]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:50.656]         }, condition = base::local({
[16:01:50.656]             c <- base::c
[16:01:50.656]             inherits <- base::inherits
[16:01:50.656]             invokeRestart <- base::invokeRestart
[16:01:50.656]             length <- base::length
[16:01:50.656]             list <- base::list
[16:01:50.656]             seq.int <- base::seq.int
[16:01:50.656]             signalCondition <- base::signalCondition
[16:01:50.656]             sys.calls <- base::sys.calls
[16:01:50.656]             `[[` <- base::`[[`
[16:01:50.656]             `+` <- base::`+`
[16:01:50.656]             `<<-` <- base::`<<-`
[16:01:50.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:50.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:50.656]                   3L)]
[16:01:50.656]             }
[16:01:50.656]             function(cond) {
[16:01:50.656]                 is_error <- inherits(cond, "error")
[16:01:50.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:50.656]                   NULL)
[16:01:50.656]                 if (is_error) {
[16:01:50.656]                   sessionInformation <- function() {
[16:01:50.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:50.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:50.656]                       search = base::search(), system = base::Sys.info())
[16:01:50.656]                   }
[16:01:50.656]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:50.656]                     cond$call), session = sessionInformation(), 
[16:01:50.656]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:50.656]                   signalCondition(cond)
[16:01:50.656]                 }
[16:01:50.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:50.656]                 "immediateCondition"))) {
[16:01:50.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:50.656]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:50.656]                   if (TRUE && !signal) {
[16:01:50.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.656]                     {
[16:01:50.656]                       inherits <- base::inherits
[16:01:50.656]                       invokeRestart <- base::invokeRestart
[16:01:50.656]                       is.null <- base::is.null
[16:01:50.656]                       muffled <- FALSE
[16:01:50.656]                       if (inherits(cond, "message")) {
[16:01:50.656]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.656]                         if (muffled) 
[16:01:50.656]                           invokeRestart("muffleMessage")
[16:01:50.656]                       }
[16:01:50.656]                       else if (inherits(cond, "warning")) {
[16:01:50.656]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.656]                         if (muffled) 
[16:01:50.656]                           invokeRestart("muffleWarning")
[16:01:50.656]                       }
[16:01:50.656]                       else if (inherits(cond, "condition")) {
[16:01:50.656]                         if (!is.null(pattern)) {
[16:01:50.656]                           computeRestarts <- base::computeRestarts
[16:01:50.656]                           grepl <- base::grepl
[16:01:50.656]                           restarts <- computeRestarts(cond)
[16:01:50.656]                           for (restart in restarts) {
[16:01:50.656]                             name <- restart$name
[16:01:50.656]                             if (is.null(name)) 
[16:01:50.656]                               next
[16:01:50.656]                             if (!grepl(pattern, name)) 
[16:01:50.656]                               next
[16:01:50.656]                             invokeRestart(restart)
[16:01:50.656]                             muffled <- TRUE
[16:01:50.656]                             break
[16:01:50.656]                           }
[16:01:50.656]                         }
[16:01:50.656]                       }
[16:01:50.656]                       invisible(muffled)
[16:01:50.656]                     }
[16:01:50.656]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.656]                   }
[16:01:50.656]                 }
[16:01:50.656]                 else {
[16:01:50.656]                   if (TRUE) {
[16:01:50.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.656]                     {
[16:01:50.656]                       inherits <- base::inherits
[16:01:50.656]                       invokeRestart <- base::invokeRestart
[16:01:50.656]                       is.null <- base::is.null
[16:01:50.656]                       muffled <- FALSE
[16:01:50.656]                       if (inherits(cond, "message")) {
[16:01:50.656]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.656]                         if (muffled) 
[16:01:50.656]                           invokeRestart("muffleMessage")
[16:01:50.656]                       }
[16:01:50.656]                       else if (inherits(cond, "warning")) {
[16:01:50.656]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.656]                         if (muffled) 
[16:01:50.656]                           invokeRestart("muffleWarning")
[16:01:50.656]                       }
[16:01:50.656]                       else if (inherits(cond, "condition")) {
[16:01:50.656]                         if (!is.null(pattern)) {
[16:01:50.656]                           computeRestarts <- base::computeRestarts
[16:01:50.656]                           grepl <- base::grepl
[16:01:50.656]                           restarts <- computeRestarts(cond)
[16:01:50.656]                           for (restart in restarts) {
[16:01:50.656]                             name <- restart$name
[16:01:50.656]                             if (is.null(name)) 
[16:01:50.656]                               next
[16:01:50.656]                             if (!grepl(pattern, name)) 
[16:01:50.656]                               next
[16:01:50.656]                             invokeRestart(restart)
[16:01:50.656]                             muffled <- TRUE
[16:01:50.656]                             break
[16:01:50.656]                           }
[16:01:50.656]                         }
[16:01:50.656]                       }
[16:01:50.656]                       invisible(muffled)
[16:01:50.656]                     }
[16:01:50.656]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.656]                   }
[16:01:50.656]                 }
[16:01:50.656]             }
[16:01:50.656]         }))
[16:01:50.656]     }, error = function(ex) {
[16:01:50.656]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:50.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.656]                 ...future.rng), started = ...future.startTime, 
[16:01:50.656]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:50.656]             version = "1.8"), class = "FutureResult")
[16:01:50.656]     }, finally = {
[16:01:50.656]         if (!identical(...future.workdir, getwd())) 
[16:01:50.656]             setwd(...future.workdir)
[16:01:50.656]         {
[16:01:50.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:50.656]                 ...future.oldOptions$nwarnings <- NULL
[16:01:50.656]             }
[16:01:50.656]             base::options(...future.oldOptions)
[16:01:50.656]             if (.Platform$OS.type == "windows") {
[16:01:50.656]                 old_names <- names(...future.oldEnvVars)
[16:01:50.656]                 envs <- base::Sys.getenv()
[16:01:50.656]                 names <- names(envs)
[16:01:50.656]                 common <- intersect(names, old_names)
[16:01:50.656]                 added <- setdiff(names, old_names)
[16:01:50.656]                 removed <- setdiff(old_names, names)
[16:01:50.656]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:50.656]                   envs[common]]
[16:01:50.656]                 NAMES <- toupper(changed)
[16:01:50.656]                 args <- list()
[16:01:50.656]                 for (kk in seq_along(NAMES)) {
[16:01:50.656]                   name <- changed[[kk]]
[16:01:50.656]                   NAME <- NAMES[[kk]]
[16:01:50.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.656]                     next
[16:01:50.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.656]                 }
[16:01:50.656]                 NAMES <- toupper(added)
[16:01:50.656]                 for (kk in seq_along(NAMES)) {
[16:01:50.656]                   name <- added[[kk]]
[16:01:50.656]                   NAME <- NAMES[[kk]]
[16:01:50.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.656]                     next
[16:01:50.656]                   args[[name]] <- ""
[16:01:50.656]                 }
[16:01:50.656]                 NAMES <- toupper(removed)
[16:01:50.656]                 for (kk in seq_along(NAMES)) {
[16:01:50.656]                   name <- removed[[kk]]
[16:01:50.656]                   NAME <- NAMES[[kk]]
[16:01:50.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.656]                     next
[16:01:50.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.656]                 }
[16:01:50.656]                 if (length(args) > 0) 
[16:01:50.656]                   base::do.call(base::Sys.setenv, args = args)
[16:01:50.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:50.656]             }
[16:01:50.656]             else {
[16:01:50.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:50.656]             }
[16:01:50.656]             {
[16:01:50.656]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:50.656]                   0L) {
[16:01:50.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:50.656]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:50.656]                   base::options(opts)
[16:01:50.656]                 }
[16:01:50.656]                 {
[16:01:50.656]                   {
[16:01:50.656]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:50.656]                     NULL
[16:01:50.656]                   }
[16:01:50.656]                   options(future.plan = NULL)
[16:01:50.656]                   if (is.na(NA_character_)) 
[16:01:50.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:50.656]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:50.656]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:50.656]                     envir = parent.frame()) 
[16:01:50.656]                   {
[16:01:50.656]                     if (is.function(workers)) 
[16:01:50.656]                       workers <- workers()
[16:01:50.656]                     workers <- structure(as.integer(workers), 
[16:01:50.656]                       class = class(workers))
[16:01:50.656]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:50.656]                       workers >= 1)
[16:01:50.656]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:50.656]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:50.656]                     }
[16:01:50.656]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:50.656]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:50.656]                       envir = envir)
[16:01:50.656]                     if (!future$lazy) 
[16:01:50.656]                       future <- run(future)
[16:01:50.656]                     invisible(future)
[16:01:50.656]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:50.656]                 }
[16:01:50.656]             }
[16:01:50.656]         }
[16:01:50.656]     })
[16:01:50.656]     if (TRUE) {
[16:01:50.656]         base::sink(type = "output", split = FALSE)
[16:01:50.656]         if (TRUE) {
[16:01:50.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:50.656]         }
[16:01:50.656]         else {
[16:01:50.656]             ...future.result["stdout"] <- base::list(NULL)
[16:01:50.656]         }
[16:01:50.656]         base::close(...future.stdout)
[16:01:50.656]         ...future.stdout <- NULL
[16:01:50.656]     }
[16:01:50.656]     ...future.result$conditions <- ...future.conditions
[16:01:50.656]     ...future.result$finished <- base::Sys.time()
[16:01:50.656]     ...future.result
[16:01:50.656] }
[16:01:50.658] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[16:01:50.659] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:01:50.659] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:01:50.659] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:50.660] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:50.660] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:01:50.660] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:01:50.660] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:50.660] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:50.661] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:01:50.661] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:01:50.661] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[16:01:50.661] MultisessionFuture started
[16:01:50.662] - Launch lazy future ... done
[16:01:50.662] run() for ‘MultisessionFuture’ ... done
[16:01:50.662] Created future:
[16:01:50.662] MultisessionFuture:
[16:01:50.662] Label: ‘future_eapply-1’
[16:01:50.662] Expression:
[16:01:50.662] {
[16:01:50.662]     do.call(function(...) {
[16:01:50.662]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.662]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.662]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.662]             on.exit(options(oopts), add = TRUE)
[16:01:50.662]         }
[16:01:50.662]         {
[16:01:50.662]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.662]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.662]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.662]             })
[16:01:50.662]         }
[16:01:50.662]     }, args = future.call.arguments)
[16:01:50.662] }
[16:01:50.662] Lazy evaluation: FALSE
[16:01:50.662] Asynchronous evaluation: TRUE
[16:01:50.662] Local evaluation: TRUE
[16:01:50.662] Environment: R_GlobalEnv
[16:01:50.662] Capture standard output: TRUE
[16:01:50.662] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:50.662] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:50.662] Packages: 1 packages (‘stats’)
[16:01:50.662] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:50.662] Resolved: FALSE
[16:01:50.662] Value: <not collected>
[16:01:50.662] Conditions captured: <none>
[16:01:50.662] Early signaling: FALSE
[16:01:50.662] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:50.662] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.673] Chunk #1 of 2 ... DONE
[16:01:50.674] Chunk #2 of 2 ...
[16:01:50.674]  - Finding globals in 'X' for chunk #2 ...
[16:01:50.674] getGlobalsAndPackages() ...
[16:01:50.674] Searching for globals...
[16:01:50.674] 
[16:01:50.674] Searching for globals ... DONE
[16:01:50.675] - globals: [0] <none>
[16:01:50.675] getGlobalsAndPackages() ... DONE
[16:01:50.675]    + additional globals found: [n=0] 
[16:01:50.675]    + additional namespaces needed: [n=0] 
[16:01:50.675]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:50.675]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:50.675]  - seeds: <none>
[16:01:50.675]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.675] getGlobalsAndPackages() ...
[16:01:50.675] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.676] Resolving globals: FALSE
[16:01:50.676] Tweak future expression to call with '...' arguments ...
[16:01:50.676] {
[16:01:50.676]     do.call(function(...) {
[16:01:50.676]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.676]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.676]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.676]             on.exit(options(oopts), add = TRUE)
[16:01:50.676]         }
[16:01:50.676]         {
[16:01:50.676]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.676]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.676]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.676]             })
[16:01:50.676]         }
[16:01:50.676]     }, args = future.call.arguments)
[16:01:50.676] }
[16:01:50.676] Tweak future expression to call with '...' arguments ... DONE
[16:01:50.676] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:50.677] - packages: [1] ‘stats’
[16:01:50.679] getGlobalsAndPackages() ... DONE
[16:01:50.679] run() for ‘Future’ ...
[16:01:50.679] - state: ‘created’
[16:01:50.679] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:50.694] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:50.694]   - Field: ‘node’
[16:01:50.694]   - Field: ‘label’
[16:01:50.694]   - Field: ‘local’
[16:01:50.694]   - Field: ‘owner’
[16:01:50.694]   - Field: ‘envir’
[16:01:50.694]   - Field: ‘workers’
[16:01:50.695]   - Field: ‘packages’
[16:01:50.695]   - Field: ‘gc’
[16:01:50.695]   - Field: ‘conditions’
[16:01:50.695]   - Field: ‘persistent’
[16:01:50.695]   - Field: ‘expr’
[16:01:50.695]   - Field: ‘uuid’
[16:01:50.695]   - Field: ‘seed’
[16:01:50.695]   - Field: ‘version’
[16:01:50.695]   - Field: ‘result’
[16:01:50.695]   - Field: ‘asynchronous’
[16:01:50.696]   - Field: ‘calls’
[16:01:50.696]   - Field: ‘globals’
[16:01:50.696]   - Field: ‘stdout’
[16:01:50.696]   - Field: ‘earlySignal’
[16:01:50.696]   - Field: ‘lazy’
[16:01:50.696]   - Field: ‘state’
[16:01:50.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:50.696] - Launch lazy future ...
[16:01:50.696] Packages needed by the future expression (n = 1): ‘stats’
[16:01:50.697] Packages needed by future strategies (n = 0): <none>
[16:01:50.697] {
[16:01:50.697]     {
[16:01:50.697]         {
[16:01:50.697]             ...future.startTime <- base::Sys.time()
[16:01:50.697]             {
[16:01:50.697]                 {
[16:01:50.697]                   {
[16:01:50.697]                     {
[16:01:50.697]                       {
[16:01:50.697]                         base::local({
[16:01:50.697]                           has_future <- base::requireNamespace("future", 
[16:01:50.697]                             quietly = TRUE)
[16:01:50.697]                           if (has_future) {
[16:01:50.697]                             ns <- base::getNamespace("future")
[16:01:50.697]                             version <- ns[[".package"]][["version"]]
[16:01:50.697]                             if (is.null(version)) 
[16:01:50.697]                               version <- utils::packageVersion("future")
[16:01:50.697]                           }
[16:01:50.697]                           else {
[16:01:50.697]                             version <- NULL
[16:01:50.697]                           }
[16:01:50.697]                           if (!has_future || version < "1.8.0") {
[16:01:50.697]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:50.697]                               "", base::R.version$version.string), 
[16:01:50.697]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:50.697]                                 base::R.version$platform, 8 * 
[16:01:50.697]                                   base::.Machine$sizeof.pointer), 
[16:01:50.697]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:50.697]                                 "release", "version")], collapse = " "), 
[16:01:50.697]                               hostname = base::Sys.info()[["nodename"]])
[16:01:50.697]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:50.697]                               info)
[16:01:50.697]                             info <- base::paste(info, collapse = "; ")
[16:01:50.697]                             if (!has_future) {
[16:01:50.697]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:50.697]                                 info)
[16:01:50.697]                             }
[16:01:50.697]                             else {
[16:01:50.697]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:50.697]                                 info, version)
[16:01:50.697]                             }
[16:01:50.697]                             base::stop(msg)
[16:01:50.697]                           }
[16:01:50.697]                         })
[16:01:50.697]                       }
[16:01:50.697]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:50.697]                       base::options(mc.cores = 1L)
[16:01:50.697]                     }
[16:01:50.697]                     base::local({
[16:01:50.697]                       for (pkg in "stats") {
[16:01:50.697]                         base::loadNamespace(pkg)
[16:01:50.697]                         base::library(pkg, character.only = TRUE)
[16:01:50.697]                       }
[16:01:50.697]                     })
[16:01:50.697]                   }
[16:01:50.697]                   options(future.plan = NULL)
[16:01:50.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:50.697]                 }
[16:01:50.697]                 ...future.workdir <- getwd()
[16:01:50.697]             }
[16:01:50.697]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:50.697]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:50.697]         }
[16:01:50.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:50.697]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:50.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:50.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:50.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:50.697]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:50.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:50.697]             base::names(...future.oldOptions))
[16:01:50.697]     }
[16:01:50.697]     if (FALSE) {
[16:01:50.697]     }
[16:01:50.697]     else {
[16:01:50.697]         if (TRUE) {
[16:01:50.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:50.697]                 open = "w")
[16:01:50.697]         }
[16:01:50.697]         else {
[16:01:50.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:50.697]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:50.697]         }
[16:01:50.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:50.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:50.697]             base::sink(type = "output", split = FALSE)
[16:01:50.697]             base::close(...future.stdout)
[16:01:50.697]         }, add = TRUE)
[16:01:50.697]     }
[16:01:50.697]     ...future.frame <- base::sys.nframe()
[16:01:50.697]     ...future.conditions <- base::list()
[16:01:50.697]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:50.697]     if (FALSE) {
[16:01:50.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:50.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:50.697]     }
[16:01:50.697]     ...future.result <- base::tryCatch({
[16:01:50.697]         base::withCallingHandlers({
[16:01:50.697]             ...future.value <- base::withVisible(base::local({
[16:01:50.697]                 ...future.makeSendCondition <- base::local({
[16:01:50.697]                   sendCondition <- NULL
[16:01:50.697]                   function(frame = 1L) {
[16:01:50.697]                     if (is.function(sendCondition)) 
[16:01:50.697]                       return(sendCondition)
[16:01:50.697]                     ns <- getNamespace("parallel")
[16:01:50.697]                     if (exists("sendData", mode = "function", 
[16:01:50.697]                       envir = ns)) {
[16:01:50.697]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:50.697]                         envir = ns)
[16:01:50.697]                       envir <- sys.frame(frame)
[16:01:50.697]                       master <- NULL
[16:01:50.697]                       while (!identical(envir, .GlobalEnv) && 
[16:01:50.697]                         !identical(envir, emptyenv())) {
[16:01:50.697]                         if (exists("master", mode = "list", envir = envir, 
[16:01:50.697]                           inherits = FALSE)) {
[16:01:50.697]                           master <- get("master", mode = "list", 
[16:01:50.697]                             envir = envir, inherits = FALSE)
[16:01:50.697]                           if (inherits(master, c("SOCKnode", 
[16:01:50.697]                             "SOCK0node"))) {
[16:01:50.697]                             sendCondition <<- function(cond) {
[16:01:50.697]                               data <- list(type = "VALUE", value = cond, 
[16:01:50.697]                                 success = TRUE)
[16:01:50.697]                               parallel_sendData(master, data)
[16:01:50.697]                             }
[16:01:50.697]                             return(sendCondition)
[16:01:50.697]                           }
[16:01:50.697]                         }
[16:01:50.697]                         frame <- frame + 1L
[16:01:50.697]                         envir <- sys.frame(frame)
[16:01:50.697]                       }
[16:01:50.697]                     }
[16:01:50.697]                     sendCondition <<- function(cond) NULL
[16:01:50.697]                   }
[16:01:50.697]                 })
[16:01:50.697]                 withCallingHandlers({
[16:01:50.697]                   {
[16:01:50.697]                     do.call(function(...) {
[16:01:50.697]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.697]                       if (!identical(...future.globals.maxSize.org, 
[16:01:50.697]                         ...future.globals.maxSize)) {
[16:01:50.697]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.697]                         on.exit(options(oopts), add = TRUE)
[16:01:50.697]                       }
[16:01:50.697]                       {
[16:01:50.697]                         lapply(seq_along(...future.elements_ii), 
[16:01:50.697]                           FUN = function(jj) {
[16:01:50.697]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.697]                             ...future.FUN(...future.X_jj, ...)
[16:01:50.697]                           })
[16:01:50.697]                       }
[16:01:50.697]                     }, args = future.call.arguments)
[16:01:50.697]                   }
[16:01:50.697]                 }, immediateCondition = function(cond) {
[16:01:50.697]                   sendCondition <- ...future.makeSendCondition()
[16:01:50.697]                   sendCondition(cond)
[16:01:50.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.697]                   {
[16:01:50.697]                     inherits <- base::inherits
[16:01:50.697]                     invokeRestart <- base::invokeRestart
[16:01:50.697]                     is.null <- base::is.null
[16:01:50.697]                     muffled <- FALSE
[16:01:50.697]                     if (inherits(cond, "message")) {
[16:01:50.697]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:50.697]                       if (muffled) 
[16:01:50.697]                         invokeRestart("muffleMessage")
[16:01:50.697]                     }
[16:01:50.697]                     else if (inherits(cond, "warning")) {
[16:01:50.697]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:50.697]                       if (muffled) 
[16:01:50.697]                         invokeRestart("muffleWarning")
[16:01:50.697]                     }
[16:01:50.697]                     else if (inherits(cond, "condition")) {
[16:01:50.697]                       if (!is.null(pattern)) {
[16:01:50.697]                         computeRestarts <- base::computeRestarts
[16:01:50.697]                         grepl <- base::grepl
[16:01:50.697]                         restarts <- computeRestarts(cond)
[16:01:50.697]                         for (restart in restarts) {
[16:01:50.697]                           name <- restart$name
[16:01:50.697]                           if (is.null(name)) 
[16:01:50.697]                             next
[16:01:50.697]                           if (!grepl(pattern, name)) 
[16:01:50.697]                             next
[16:01:50.697]                           invokeRestart(restart)
[16:01:50.697]                           muffled <- TRUE
[16:01:50.697]                           break
[16:01:50.697]                         }
[16:01:50.697]                       }
[16:01:50.697]                     }
[16:01:50.697]                     invisible(muffled)
[16:01:50.697]                   }
[16:01:50.697]                   muffleCondition(cond)
[16:01:50.697]                 })
[16:01:50.697]             }))
[16:01:50.697]             future::FutureResult(value = ...future.value$value, 
[16:01:50.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.697]                   ...future.rng), globalenv = if (FALSE) 
[16:01:50.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:50.697]                     ...future.globalenv.names))
[16:01:50.697]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:50.697]         }, condition = base::local({
[16:01:50.697]             c <- base::c
[16:01:50.697]             inherits <- base::inherits
[16:01:50.697]             invokeRestart <- base::invokeRestart
[16:01:50.697]             length <- base::length
[16:01:50.697]             list <- base::list
[16:01:50.697]             seq.int <- base::seq.int
[16:01:50.697]             signalCondition <- base::signalCondition
[16:01:50.697]             sys.calls <- base::sys.calls
[16:01:50.697]             `[[` <- base::`[[`
[16:01:50.697]             `+` <- base::`+`
[16:01:50.697]             `<<-` <- base::`<<-`
[16:01:50.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:50.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:50.697]                   3L)]
[16:01:50.697]             }
[16:01:50.697]             function(cond) {
[16:01:50.697]                 is_error <- inherits(cond, "error")
[16:01:50.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:50.697]                   NULL)
[16:01:50.697]                 if (is_error) {
[16:01:50.697]                   sessionInformation <- function() {
[16:01:50.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:50.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:50.697]                       search = base::search(), system = base::Sys.info())
[16:01:50.697]                   }
[16:01:50.697]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:50.697]                     cond$call), session = sessionInformation(), 
[16:01:50.697]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:50.697]                   signalCondition(cond)
[16:01:50.697]                 }
[16:01:50.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:50.697]                 "immediateCondition"))) {
[16:01:50.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:50.697]                   ...future.conditions[[length(...future.conditions) + 
[16:01:50.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:50.697]                   if (TRUE && !signal) {
[16:01:50.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.697]                     {
[16:01:50.697]                       inherits <- base::inherits
[16:01:50.697]                       invokeRestart <- base::invokeRestart
[16:01:50.697]                       is.null <- base::is.null
[16:01:50.697]                       muffled <- FALSE
[16:01:50.697]                       if (inherits(cond, "message")) {
[16:01:50.697]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.697]                         if (muffled) 
[16:01:50.697]                           invokeRestart("muffleMessage")
[16:01:50.697]                       }
[16:01:50.697]                       else if (inherits(cond, "warning")) {
[16:01:50.697]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.697]                         if (muffled) 
[16:01:50.697]                           invokeRestart("muffleWarning")
[16:01:50.697]                       }
[16:01:50.697]                       else if (inherits(cond, "condition")) {
[16:01:50.697]                         if (!is.null(pattern)) {
[16:01:50.697]                           computeRestarts <- base::computeRestarts
[16:01:50.697]                           grepl <- base::grepl
[16:01:50.697]                           restarts <- computeRestarts(cond)
[16:01:50.697]                           for (restart in restarts) {
[16:01:50.697]                             name <- restart$name
[16:01:50.697]                             if (is.null(name)) 
[16:01:50.697]                               next
[16:01:50.697]                             if (!grepl(pattern, name)) 
[16:01:50.697]                               next
[16:01:50.697]                             invokeRestart(restart)
[16:01:50.697]                             muffled <- TRUE
[16:01:50.697]                             break
[16:01:50.697]                           }
[16:01:50.697]                         }
[16:01:50.697]                       }
[16:01:50.697]                       invisible(muffled)
[16:01:50.697]                     }
[16:01:50.697]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.697]                   }
[16:01:50.697]                 }
[16:01:50.697]                 else {
[16:01:50.697]                   if (TRUE) {
[16:01:50.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:50.697]                     {
[16:01:50.697]                       inherits <- base::inherits
[16:01:50.697]                       invokeRestart <- base::invokeRestart
[16:01:50.697]                       is.null <- base::is.null
[16:01:50.697]                       muffled <- FALSE
[16:01:50.697]                       if (inherits(cond, "message")) {
[16:01:50.697]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:50.697]                         if (muffled) 
[16:01:50.697]                           invokeRestart("muffleMessage")
[16:01:50.697]                       }
[16:01:50.697]                       else if (inherits(cond, "warning")) {
[16:01:50.697]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:50.697]                         if (muffled) 
[16:01:50.697]                           invokeRestart("muffleWarning")
[16:01:50.697]                       }
[16:01:50.697]                       else if (inherits(cond, "condition")) {
[16:01:50.697]                         if (!is.null(pattern)) {
[16:01:50.697]                           computeRestarts <- base::computeRestarts
[16:01:50.697]                           grepl <- base::grepl
[16:01:50.697]                           restarts <- computeRestarts(cond)
[16:01:50.697]                           for (restart in restarts) {
[16:01:50.697]                             name <- restart$name
[16:01:50.697]                             if (is.null(name)) 
[16:01:50.697]                               next
[16:01:50.697]                             if (!grepl(pattern, name)) 
[16:01:50.697]                               next
[16:01:50.697]                             invokeRestart(restart)
[16:01:50.697]                             muffled <- TRUE
[16:01:50.697]                             break
[16:01:50.697]                           }
[16:01:50.697]                         }
[16:01:50.697]                       }
[16:01:50.697]                       invisible(muffled)
[16:01:50.697]                     }
[16:01:50.697]                     muffleCondition(cond, pattern = "^muffle")
[16:01:50.697]                   }
[16:01:50.697]                 }
[16:01:50.697]             }
[16:01:50.697]         }))
[16:01:50.697]     }, error = function(ex) {
[16:01:50.697]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:50.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:50.697]                 ...future.rng), started = ...future.startTime, 
[16:01:50.697]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:50.697]             version = "1.8"), class = "FutureResult")
[16:01:50.697]     }, finally = {
[16:01:50.697]         if (!identical(...future.workdir, getwd())) 
[16:01:50.697]             setwd(...future.workdir)
[16:01:50.697]         {
[16:01:50.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:50.697]                 ...future.oldOptions$nwarnings <- NULL
[16:01:50.697]             }
[16:01:50.697]             base::options(...future.oldOptions)
[16:01:50.697]             if (.Platform$OS.type == "windows") {
[16:01:50.697]                 old_names <- names(...future.oldEnvVars)
[16:01:50.697]                 envs <- base::Sys.getenv()
[16:01:50.697]                 names <- names(envs)
[16:01:50.697]                 common <- intersect(names, old_names)
[16:01:50.697]                 added <- setdiff(names, old_names)
[16:01:50.697]                 removed <- setdiff(old_names, names)
[16:01:50.697]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:50.697]                   envs[common]]
[16:01:50.697]                 NAMES <- toupper(changed)
[16:01:50.697]                 args <- list()
[16:01:50.697]                 for (kk in seq_along(NAMES)) {
[16:01:50.697]                   name <- changed[[kk]]
[16:01:50.697]                   NAME <- NAMES[[kk]]
[16:01:50.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.697]                     next
[16:01:50.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.697]                 }
[16:01:50.697]                 NAMES <- toupper(added)
[16:01:50.697]                 for (kk in seq_along(NAMES)) {
[16:01:50.697]                   name <- added[[kk]]
[16:01:50.697]                   NAME <- NAMES[[kk]]
[16:01:50.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.697]                     next
[16:01:50.697]                   args[[name]] <- ""
[16:01:50.697]                 }
[16:01:50.697]                 NAMES <- toupper(removed)
[16:01:50.697]                 for (kk in seq_along(NAMES)) {
[16:01:50.697]                   name <- removed[[kk]]
[16:01:50.697]                   NAME <- NAMES[[kk]]
[16:01:50.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:50.697]                     next
[16:01:50.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:50.697]                 }
[16:01:50.697]                 if (length(args) > 0) 
[16:01:50.697]                   base::do.call(base::Sys.setenv, args = args)
[16:01:50.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:50.697]             }
[16:01:50.697]             else {
[16:01:50.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:50.697]             }
[16:01:50.697]             {
[16:01:50.697]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:50.697]                   0L) {
[16:01:50.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:50.697]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:50.697]                   base::options(opts)
[16:01:50.697]                 }
[16:01:50.697]                 {
[16:01:50.697]                   {
[16:01:50.697]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:50.697]                     NULL
[16:01:50.697]                   }
[16:01:50.697]                   options(future.plan = NULL)
[16:01:50.697]                   if (is.na(NA_character_)) 
[16:01:50.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:50.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:50.697]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:50.697]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:50.697]                     envir = parent.frame()) 
[16:01:50.697]                   {
[16:01:50.697]                     if (is.function(workers)) 
[16:01:50.697]                       workers <- workers()
[16:01:50.697]                     workers <- structure(as.integer(workers), 
[16:01:50.697]                       class = class(workers))
[16:01:50.697]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:50.697]                       workers >= 1)
[16:01:50.697]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:50.697]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:50.697]                     }
[16:01:50.697]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:50.697]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:50.697]                       envir = envir)
[16:01:50.697]                     if (!future$lazy) 
[16:01:50.697]                       future <- run(future)
[16:01:50.697]                     invisible(future)
[16:01:50.697]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:50.697]                 }
[16:01:50.697]             }
[16:01:50.697]         }
[16:01:50.697]     })
[16:01:50.697]     if (TRUE) {
[16:01:50.697]         base::sink(type = "output", split = FALSE)
[16:01:50.697]         if (TRUE) {
[16:01:50.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:50.697]         }
[16:01:50.697]         else {
[16:01:50.697]             ...future.result["stdout"] <- base::list(NULL)
[16:01:50.697]         }
[16:01:50.697]         base::close(...future.stdout)
[16:01:50.697]         ...future.stdout <- NULL
[16:01:50.697]     }
[16:01:50.697]     ...future.result$conditions <- ...future.conditions
[16:01:50.697]     ...future.result$finished <- base::Sys.time()
[16:01:50.697]     ...future.result
[16:01:50.697] }
[16:01:50.700] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[16:01:50.700] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:01:50.700] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:01:50.701] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:50.701] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:50.701] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:01:50.702] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:01:50.702] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:50.702] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:50.702] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:01:50.703] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:01:50.703] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[16:01:50.703] MultisessionFuture started
[16:01:50.703] - Launch lazy future ... done
[16:01:50.704] run() for ‘MultisessionFuture’ ... done
[16:01:50.704] Created future:
[16:01:50.704] MultisessionFuture:
[16:01:50.704] Label: ‘future_eapply-2’
[16:01:50.704] Expression:
[16:01:50.704] {
[16:01:50.704]     do.call(function(...) {
[16:01:50.704]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:50.704]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:50.704]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:50.704]             on.exit(options(oopts), add = TRUE)
[16:01:50.704]         }
[16:01:50.704]         {
[16:01:50.704]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:50.704]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:50.704]                 ...future.FUN(...future.X_jj, ...)
[16:01:50.704]             })
[16:01:50.704]         }
[16:01:50.704]     }, args = future.call.arguments)
[16:01:50.704] }
[16:01:50.704] Lazy evaluation: FALSE
[16:01:50.704] Asynchronous evaluation: TRUE
[16:01:50.704] Local evaluation: TRUE
[16:01:50.704] Environment: R_GlobalEnv
[16:01:50.704] Capture standard output: TRUE
[16:01:50.704] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:50.704] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:50.704] Packages: 1 packages (‘stats’)
[16:01:50.704] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:50.704] Resolved: FALSE
[16:01:50.704] Value: <not collected>
[16:01:50.704] Conditions captured: <none>
[16:01:50.704] Early signaling: FALSE
[16:01:50.704] Owner process: 498d2bf8-ba55-0b3e-7484-8824aaab3794
[16:01:50.704] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:50.715] Chunk #2 of 2 ... DONE
[16:01:50.716] Launching 2 futures (chunks) ... DONE
[16:01:50.716] Resolving 2 futures (chunks) ...
[16:01:50.716] resolve() on list ...
[16:01:50.716]  recursive: 0
[16:01:50.716]  length: 2
[16:01:50.716] 
[16:01:50.717] receiveMessageFromWorker() for ClusterFuture ...
[16:01:50.717] - Validating connection of MultisessionFuture
[16:01:50.717] - received message: FutureResult
[16:01:50.717] - Received FutureResult
[16:01:50.717] - Erased future from FutureRegistry
[16:01:50.717] result() for ClusterFuture ...
[16:01:50.717] - result already collected: FutureResult
[16:01:50.717] result() for ClusterFuture ... done
[16:01:50.718] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:50.718] Future #1
[16:01:50.718] result() for ClusterFuture ...
[16:01:50.718] - result already collected: FutureResult
[16:01:50.718] result() for ClusterFuture ... done
[16:01:50.718] result() for ClusterFuture ...
[16:01:50.718] - result already collected: FutureResult
[16:01:50.718] result() for ClusterFuture ... done
[16:01:50.718] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:50.718] - nx: 2
[16:01:50.718] - relay: TRUE
[16:01:50.718] - stdout: TRUE
[16:01:50.719] - signal: TRUE
[16:01:50.719] - resignal: FALSE
[16:01:50.719] - force: TRUE
[16:01:50.719] - relayed: [n=2] FALSE, FALSE
[16:01:50.719] - queued futures: [n=2] FALSE, FALSE
[16:01:50.719]  - until=1
[16:01:50.719]  - relaying element #1
[16:01:50.719] result() for ClusterFuture ...
[16:01:50.719] - result already collected: FutureResult
[16:01:50.719] result() for ClusterFuture ... done
[16:01:50.719] result() for ClusterFuture ...
[16:01:50.720] - result already collected: FutureResult
[16:01:50.720] result() for ClusterFuture ... done
[16:01:50.720] result() for ClusterFuture ...
[16:01:50.720] - result already collected: FutureResult
[16:01:50.720] result() for ClusterFuture ... done
[16:01:50.720] result() for ClusterFuture ...
[16:01:50.720] - result already collected: FutureResult
[16:01:50.720] result() for ClusterFuture ... done
[16:01:50.720] - relayed: [n=2] TRUE, FALSE
[16:01:50.720] - queued futures: [n=2] TRUE, FALSE
[16:01:50.720] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:50.721]  length: 1 (resolved future 1)
[16:01:50.762] receiveMessageFromWorker() for ClusterFuture ...
[16:01:50.763] - Validating connection of MultisessionFuture
[16:01:50.763] - received message: FutureResult
[16:01:50.763] - Received FutureResult
[16:01:50.763] - Erased future from FutureRegistry
[16:01:50.763] result() for ClusterFuture ...
[16:01:50.763] - result already collected: FutureResult
[16:01:50.763] result() for ClusterFuture ... done
[16:01:50.764] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:50.764] Future #2
[16:01:50.764] result() for ClusterFuture ...
[16:01:50.764] - result already collected: FutureResult
[16:01:50.764] result() for ClusterFuture ... done
[16:01:50.764] result() for ClusterFuture ...
[16:01:50.764] - result already collected: FutureResult
[16:01:50.764] result() for ClusterFuture ... done
[16:01:50.764] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:50.764] - nx: 2
[16:01:50.764] - relay: TRUE
[16:01:50.765] - stdout: TRUE
[16:01:50.765] - signal: TRUE
[16:01:50.765] - resignal: FALSE
[16:01:50.765] - force: TRUE
[16:01:50.765] - relayed: [n=2] TRUE, FALSE
[16:01:50.765] - queued futures: [n=2] TRUE, FALSE
[16:01:50.765]  - until=2
[16:01:50.765]  - relaying element #2
[16:01:50.765] result() for ClusterFuture ...
[16:01:50.765] - result already collected: FutureResult
[16:01:50.765] result() for ClusterFuture ... done
[16:01:50.765] result() for ClusterFuture ...
[16:01:50.766] - result already collected: FutureResult
[16:01:50.766] result() for ClusterFuture ... done
[16:01:50.766] result() for ClusterFuture ...
[16:01:50.766] - result already collected: FutureResult
[16:01:50.766] result() for ClusterFuture ... done
[16:01:50.766] result() for ClusterFuture ...
[16:01:50.766] - result already collected: FutureResult
[16:01:50.766] result() for ClusterFuture ... done
[16:01:50.766] - relayed: [n=2] TRUE, TRUE
[16:01:50.766] - queued futures: [n=2] TRUE, TRUE
[16:01:50.766] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:50.767]  length: 0 (resolved future 2)
[16:01:50.767] Relaying remaining futures
[16:01:50.767] signalConditionsASAP(NULL, pos=0) ...
[16:01:50.767] - nx: 2
[16:01:50.767] - relay: TRUE
[16:01:50.767] - stdout: TRUE
[16:01:50.767] - signal: TRUE
[16:01:50.767] - resignal: FALSE
[16:01:50.767] - force: TRUE
[16:01:50.767] - relayed: [n=2] TRUE, TRUE
[16:01:50.767] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:50.768] - relayed: [n=2] TRUE, TRUE
[16:01:50.768] - queued futures: [n=2] TRUE, TRUE
[16:01:50.768] signalConditionsASAP(NULL, pos=0) ... done
[16:01:50.768] resolve() on list ... DONE
[16:01:50.768] result() for ClusterFuture ...
[16:01:50.768] - result already collected: FutureResult
[16:01:50.768] result() for ClusterFuture ... done
[16:01:50.768] result() for ClusterFuture ...
[16:01:50.768] - result already collected: FutureResult
[16:01:50.768] result() for ClusterFuture ... done
[16:01:50.769] result() for ClusterFuture ...
[16:01:50.769] - result already collected: FutureResult
[16:01:50.769] result() for ClusterFuture ... done
[16:01:50.769] result() for ClusterFuture ...
[16:01:50.769] - result already collected: FutureResult
[16:01:50.769] result() for ClusterFuture ... done
[16:01:50.769]  - Number of value chunks collected: 2
[16:01:50.769] Resolving 2 futures (chunks) ... DONE
[16:01:50.769] Reducing values from 2 chunks ...
[16:01:50.769]  - Number of values collected after concatenation: 3
[16:01:50.769]  - Number of values expected: 3
[16:01:50.770] Reducing values from 2 chunks ... DONE
[16:01:50.770] future_lapply() ... DONE
[16:01:50.770] plan(): Setting new future strategy stack:
[16:01:50.770] List of future strategies:
[16:01:50.770] 1. sequential:
[16:01:50.770]    - args: function (..., envir = parent.frame())
[16:01:50.770]    - tweaked: FALSE
[16:01:50.770]    - call: plan(sequential)
[16:01:50.771] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[16:01:50.772] plan(): Setting new future strategy stack:
[16:01:50.772] List of future strategies:
[16:01:50.772] 1. FutureStrategy:
[16:01:50.772]    - args: function (..., envir = parent.frame())
[16:01:50.772]    - tweaked: FALSE
[16:01:50.772]    - call: future::plan(oplan)
[16:01:50.773] plan(): nbrOfWorkers() = 1
> 
