
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:19:56.545] plan(): Setting new future strategy stack:
[13:19:56.545] List of future strategies:
[13:19:56.545] 1. sequential:
[13:19:56.545]    - args: function (..., envir = parent.frame())
[13:19:56.545]    - tweaked: FALSE
[13:19:56.545]    - call: future::plan("sequential")
[13:19:56.560] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[13:19:56.621] plan(): Setting new future strategy stack:
[13:19:56.621] List of future strategies:
[13:19:56.621] 1. sequential:
[13:19:56.621]    - args: function (..., envir = parent.frame())
[13:19:56.621]    - tweaked: FALSE
[13:19:56.621]    - call: plan(strategy)
[13:19:56.632] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[13:19:56.633] getGlobalsAndPackagesXApply() ...
[13:19:56.634]  - future.globals: TRUE
[13:19:56.634] getGlobalsAndPackages() ...
[13:19:56.634] Searching for globals...
[13:19:56.677] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:19:56.677] Searching for globals ... DONE
[13:19:56.678] Resolving globals: FALSE
[13:19:56.680] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:19:56.681] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:19:56.681] - globals: [1] ‘FUN’
[13:19:56.681] 
[13:19:56.681] getGlobalsAndPackages() ... DONE
[13:19:56.681]  - globals found/used: [n=1] ‘FUN’
[13:19:56.681]  - needed namespaces: [n=0] 
[13:19:56.681] Finding globals ... DONE
[13:19:56.681]  - use_args: TRUE
[13:19:56.681]  - Getting '...' globals ...
[13:19:56.682] resolve() on list ...
[13:19:56.682]  recursive: 0
[13:19:56.683]  length: 1
[13:19:56.683]  elements: ‘...’
[13:19:56.683]  length: 0 (resolved future 1)
[13:19:56.683] resolve() on list ... DONE
[13:19:56.683]    - '...' content: [n=0] 
[13:19:56.683] List of 1
[13:19:56.683]  $ ...: list()
[13:19:56.683]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.683]  - attr(*, "where")=List of 1
[13:19:56.683]   ..$ ...:<environment: 0x555922700850> 
[13:19:56.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.683]  - attr(*, "resolved")= logi TRUE
[13:19:56.683]  - attr(*, "total_size")= num NA
[13:19:56.688]  - Getting '...' globals ... DONE
[13:19:56.689] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:56.689] List of 2
[13:19:56.689]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:56.689]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:56.689]  $ ...          : list()
[13:19:56.689]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.689]  - attr(*, "where")=List of 2
[13:19:56.689]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:56.689]   ..$ ...          :<environment: 0x555922700850> 
[13:19:56.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.689]  - attr(*, "resolved")= logi FALSE
[13:19:56.689]  - attr(*, "total_size")= num 354224
[13:19:56.691] Packages to be attached in all futures: [n=0] 
[13:19:56.692] getGlobalsAndPackagesXApply() ... DONE
[13:19:56.692] future_lapply() ...
[13:19:56.727] Number of chunks: 1
[13:19:56.728] getGlobalsAndPackagesXApply() ...
[13:19:56.728]  - future.globals: <name-value list> with names ‘list()’
[13:19:56.728]  - use_args: TRUE
[13:19:56.728] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:56.728] List of 2
[13:19:56.728]  $ ...          : list()
[13:19:56.728]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.728]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:56.728]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:56.728]  - attr(*, "where")=List of 2
[13:19:56.728]   ..$ ...          :<environment: 0x555922700850> 
[13:19:56.728]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:56.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.728]  - attr(*, "resolved")= logi FALSE
[13:19:56.728]  - attr(*, "total_size")= num NA
[13:19:56.732] Packages to be attached in all futures: [n=0] 
[13:19:56.732] getGlobalsAndPackagesXApply() ... DONE
[13:19:56.732] Number of futures (= number of chunks): 1
[13:19:56.732] Launching 1 futures (chunks) ...
[13:19:56.732] Chunk #1 of 1 ...
[13:19:56.733]  - seeds: <none>
[13:19:56.733]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.733] getGlobalsAndPackages() ...
[13:19:56.733] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.733] Resolving globals: FALSE
[13:19:56.733] Tweak future expression to call with '...' arguments ...
[13:19:56.733] {
[13:19:56.733]     do.call(function(...) {
[13:19:56.733]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.733]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:56.733]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.733]             on.exit(options(oopts), add = TRUE)
[13:19:56.733]         }
[13:19:56.733]         {
[13:19:56.733]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:56.733]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.733]                 ...future.FUN(...future.X_jj, ...)
[13:19:56.733]             })
[13:19:56.733]         }
[13:19:56.733]     }, args = future.call.arguments)
[13:19:56.733] }
[13:19:56.734] Tweak future expression to call with '...' arguments ... DONE
[13:19:56.734] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.734] 
[13:19:56.734] getGlobalsAndPackages() ... DONE
[13:19:56.735] run() for ‘Future’ ...
[13:19:56.735] - state: ‘created’
[13:19:56.735] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:56.736] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.736] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:56.736]   - Field: ‘label’
[13:19:56.736]   - Field: ‘local’
[13:19:56.736]   - Field: ‘owner’
[13:19:56.736]   - Field: ‘envir’
[13:19:56.736]   - Field: ‘packages’
[13:19:56.737]   - Field: ‘gc’
[13:19:56.737]   - Field: ‘conditions’
[13:19:56.737]   - Field: ‘expr’
[13:19:56.737]   - Field: ‘uuid’
[13:19:56.737]   - Field: ‘seed’
[13:19:56.737]   - Field: ‘version’
[13:19:56.737]   - Field: ‘result’
[13:19:56.737]   - Field: ‘asynchronous’
[13:19:56.737]   - Field: ‘calls’
[13:19:56.737]   - Field: ‘globals’
[13:19:56.737]   - Field: ‘stdout’
[13:19:56.738]   - Field: ‘earlySignal’
[13:19:56.738]   - Field: ‘lazy’
[13:19:56.738]   - Field: ‘state’
[13:19:56.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:56.738] - Launch lazy future ...
[13:19:56.739] Packages needed by the future expression (n = 0): <none>
[13:19:56.739] Packages needed by future strategies (n = 0): <none>
[13:19:56.740] {
[13:19:56.740]     {
[13:19:56.740]         {
[13:19:56.740]             ...future.startTime <- base::Sys.time()
[13:19:56.740]             {
[13:19:56.740]                 {
[13:19:56.740]                   {
[13:19:56.740]                     base::local({
[13:19:56.740]                       has_future <- base::requireNamespace("future", 
[13:19:56.740]                         quietly = TRUE)
[13:19:56.740]                       if (has_future) {
[13:19:56.740]                         ns <- base::getNamespace("future")
[13:19:56.740]                         version <- ns[[".package"]][["version"]]
[13:19:56.740]                         if (is.null(version)) 
[13:19:56.740]                           version <- utils::packageVersion("future")
[13:19:56.740]                       }
[13:19:56.740]                       else {
[13:19:56.740]                         version <- NULL
[13:19:56.740]                       }
[13:19:56.740]                       if (!has_future || version < "1.8.0") {
[13:19:56.740]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:56.740]                           "", base::R.version$version.string), 
[13:19:56.740]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:56.740]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:56.740]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:56.740]                             "release", "version")], collapse = " "), 
[13:19:56.740]                           hostname = base::Sys.info()[["nodename"]])
[13:19:56.740]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:56.740]                           info)
[13:19:56.740]                         info <- base::paste(info, collapse = "; ")
[13:19:56.740]                         if (!has_future) {
[13:19:56.740]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:56.740]                             info)
[13:19:56.740]                         }
[13:19:56.740]                         else {
[13:19:56.740]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:56.740]                             info, version)
[13:19:56.740]                         }
[13:19:56.740]                         base::stop(msg)
[13:19:56.740]                       }
[13:19:56.740]                     })
[13:19:56.740]                   }
[13:19:56.740]                   options(future.plan = NULL)
[13:19:56.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:56.740]                 }
[13:19:56.740]                 ...future.workdir <- getwd()
[13:19:56.740]             }
[13:19:56.740]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:56.740]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:56.740]         }
[13:19:56.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:56.740]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:56.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:56.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:56.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:56.740]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:56.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:56.740]             base::names(...future.oldOptions))
[13:19:56.740]     }
[13:19:56.740]     if (FALSE) {
[13:19:56.740]     }
[13:19:56.740]     else {
[13:19:56.740]         if (TRUE) {
[13:19:56.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:56.740]                 open = "w")
[13:19:56.740]         }
[13:19:56.740]         else {
[13:19:56.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:56.740]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:56.740]         }
[13:19:56.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:56.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:56.740]             base::sink(type = "output", split = FALSE)
[13:19:56.740]             base::close(...future.stdout)
[13:19:56.740]         }, add = TRUE)
[13:19:56.740]     }
[13:19:56.740]     ...future.frame <- base::sys.nframe()
[13:19:56.740]     ...future.conditions <- base::list()
[13:19:56.740]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:56.740]     if (FALSE) {
[13:19:56.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:56.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:56.740]     }
[13:19:56.740]     ...future.result <- base::tryCatch({
[13:19:56.740]         base::withCallingHandlers({
[13:19:56.740]             ...future.value <- base::withVisible(base::local({
[13:19:56.740]                 do.call(function(...) {
[13:19:56.740]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.740]                   if (!identical(...future.globals.maxSize.org, 
[13:19:56.740]                     ...future.globals.maxSize)) {
[13:19:56.740]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.740]                     on.exit(options(oopts), add = TRUE)
[13:19:56.740]                   }
[13:19:56.740]                   {
[13:19:56.740]                     lapply(seq_along(...future.elements_ii), 
[13:19:56.740]                       FUN = function(jj) {
[13:19:56.740]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.740]                         ...future.FUN(...future.X_jj, ...)
[13:19:56.740]                       })
[13:19:56.740]                   }
[13:19:56.740]                 }, args = future.call.arguments)
[13:19:56.740]             }))
[13:19:56.740]             future::FutureResult(value = ...future.value$value, 
[13:19:56.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.740]                   ...future.rng), globalenv = if (FALSE) 
[13:19:56.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:56.740]                     ...future.globalenv.names))
[13:19:56.740]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:56.740]         }, condition = base::local({
[13:19:56.740]             c <- base::c
[13:19:56.740]             inherits <- base::inherits
[13:19:56.740]             invokeRestart <- base::invokeRestart
[13:19:56.740]             length <- base::length
[13:19:56.740]             list <- base::list
[13:19:56.740]             seq.int <- base::seq.int
[13:19:56.740]             signalCondition <- base::signalCondition
[13:19:56.740]             sys.calls <- base::sys.calls
[13:19:56.740]             `[[` <- base::`[[`
[13:19:56.740]             `+` <- base::`+`
[13:19:56.740]             `<<-` <- base::`<<-`
[13:19:56.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:56.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:56.740]                   3L)]
[13:19:56.740]             }
[13:19:56.740]             function(cond) {
[13:19:56.740]                 is_error <- inherits(cond, "error")
[13:19:56.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:56.740]                   NULL)
[13:19:56.740]                 if (is_error) {
[13:19:56.740]                   sessionInformation <- function() {
[13:19:56.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:56.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:56.740]                       search = base::search(), system = base::Sys.info())
[13:19:56.740]                   }
[13:19:56.740]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:56.740]                     cond$call), session = sessionInformation(), 
[13:19:56.740]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:56.740]                   signalCondition(cond)
[13:19:56.740]                 }
[13:19:56.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:56.740]                 "immediateCondition"))) {
[13:19:56.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:56.740]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:56.740]                   if (TRUE && !signal) {
[13:19:56.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.740]                     {
[13:19:56.740]                       inherits <- base::inherits
[13:19:56.740]                       invokeRestart <- base::invokeRestart
[13:19:56.740]                       is.null <- base::is.null
[13:19:56.740]                       muffled <- FALSE
[13:19:56.740]                       if (inherits(cond, "message")) {
[13:19:56.740]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.740]                         if (muffled) 
[13:19:56.740]                           invokeRestart("muffleMessage")
[13:19:56.740]                       }
[13:19:56.740]                       else if (inherits(cond, "warning")) {
[13:19:56.740]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.740]                         if (muffled) 
[13:19:56.740]                           invokeRestart("muffleWarning")
[13:19:56.740]                       }
[13:19:56.740]                       else if (inherits(cond, "condition")) {
[13:19:56.740]                         if (!is.null(pattern)) {
[13:19:56.740]                           computeRestarts <- base::computeRestarts
[13:19:56.740]                           grepl <- base::grepl
[13:19:56.740]                           restarts <- computeRestarts(cond)
[13:19:56.740]                           for (restart in restarts) {
[13:19:56.740]                             name <- restart$name
[13:19:56.740]                             if (is.null(name)) 
[13:19:56.740]                               next
[13:19:56.740]                             if (!grepl(pattern, name)) 
[13:19:56.740]                               next
[13:19:56.740]                             invokeRestart(restart)
[13:19:56.740]                             muffled <- TRUE
[13:19:56.740]                             break
[13:19:56.740]                           }
[13:19:56.740]                         }
[13:19:56.740]                       }
[13:19:56.740]                       invisible(muffled)
[13:19:56.740]                     }
[13:19:56.740]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.740]                   }
[13:19:56.740]                 }
[13:19:56.740]                 else {
[13:19:56.740]                   if (TRUE) {
[13:19:56.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.740]                     {
[13:19:56.740]                       inherits <- base::inherits
[13:19:56.740]                       invokeRestart <- base::invokeRestart
[13:19:56.740]                       is.null <- base::is.null
[13:19:56.740]                       muffled <- FALSE
[13:19:56.740]                       if (inherits(cond, "message")) {
[13:19:56.740]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.740]                         if (muffled) 
[13:19:56.740]                           invokeRestart("muffleMessage")
[13:19:56.740]                       }
[13:19:56.740]                       else if (inherits(cond, "warning")) {
[13:19:56.740]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.740]                         if (muffled) 
[13:19:56.740]                           invokeRestart("muffleWarning")
[13:19:56.740]                       }
[13:19:56.740]                       else if (inherits(cond, "condition")) {
[13:19:56.740]                         if (!is.null(pattern)) {
[13:19:56.740]                           computeRestarts <- base::computeRestarts
[13:19:56.740]                           grepl <- base::grepl
[13:19:56.740]                           restarts <- computeRestarts(cond)
[13:19:56.740]                           for (restart in restarts) {
[13:19:56.740]                             name <- restart$name
[13:19:56.740]                             if (is.null(name)) 
[13:19:56.740]                               next
[13:19:56.740]                             if (!grepl(pattern, name)) 
[13:19:56.740]                               next
[13:19:56.740]                             invokeRestart(restart)
[13:19:56.740]                             muffled <- TRUE
[13:19:56.740]                             break
[13:19:56.740]                           }
[13:19:56.740]                         }
[13:19:56.740]                       }
[13:19:56.740]                       invisible(muffled)
[13:19:56.740]                     }
[13:19:56.740]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.740]                   }
[13:19:56.740]                 }
[13:19:56.740]             }
[13:19:56.740]         }))
[13:19:56.740]     }, error = function(ex) {
[13:19:56.740]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:56.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.740]                 ...future.rng), started = ...future.startTime, 
[13:19:56.740]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:56.740]             version = "1.8"), class = "FutureResult")
[13:19:56.740]     }, finally = {
[13:19:56.740]         if (!identical(...future.workdir, getwd())) 
[13:19:56.740]             setwd(...future.workdir)
[13:19:56.740]         {
[13:19:56.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:56.740]                 ...future.oldOptions$nwarnings <- NULL
[13:19:56.740]             }
[13:19:56.740]             base::options(...future.oldOptions)
[13:19:56.740]             if (.Platform$OS.type == "windows") {
[13:19:56.740]                 old_names <- names(...future.oldEnvVars)
[13:19:56.740]                 envs <- base::Sys.getenv()
[13:19:56.740]                 names <- names(envs)
[13:19:56.740]                 common <- intersect(names, old_names)
[13:19:56.740]                 added <- setdiff(names, old_names)
[13:19:56.740]                 removed <- setdiff(old_names, names)
[13:19:56.740]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:56.740]                   envs[common]]
[13:19:56.740]                 NAMES <- toupper(changed)
[13:19:56.740]                 args <- list()
[13:19:56.740]                 for (kk in seq_along(NAMES)) {
[13:19:56.740]                   name <- changed[[kk]]
[13:19:56.740]                   NAME <- NAMES[[kk]]
[13:19:56.740]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.740]                     next
[13:19:56.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.740]                 }
[13:19:56.740]                 NAMES <- toupper(added)
[13:19:56.740]                 for (kk in seq_along(NAMES)) {
[13:19:56.740]                   name <- added[[kk]]
[13:19:56.740]                   NAME <- NAMES[[kk]]
[13:19:56.740]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.740]                     next
[13:19:56.740]                   args[[name]] <- ""
[13:19:56.740]                 }
[13:19:56.740]                 NAMES <- toupper(removed)
[13:19:56.740]                 for (kk in seq_along(NAMES)) {
[13:19:56.740]                   name <- removed[[kk]]
[13:19:56.740]                   NAME <- NAMES[[kk]]
[13:19:56.740]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.740]                     next
[13:19:56.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.740]                 }
[13:19:56.740]                 if (length(args) > 0) 
[13:19:56.740]                   base::do.call(base::Sys.setenv, args = args)
[13:19:56.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:56.740]             }
[13:19:56.740]             else {
[13:19:56.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:56.740]             }
[13:19:56.740]             {
[13:19:56.740]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:56.740]                   0L) {
[13:19:56.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:56.740]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:56.740]                   base::options(opts)
[13:19:56.740]                 }
[13:19:56.740]                 {
[13:19:56.740]                   {
[13:19:56.740]                     NULL
[13:19:56.740]                     RNGkind("Mersenne-Twister")
[13:19:56.740]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:56.740]                       inherits = FALSE)
[13:19:56.740]                   }
[13:19:56.740]                   options(future.plan = NULL)
[13:19:56.740]                   if (is.na(NA_character_)) 
[13:19:56.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:56.740]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:56.740]                   {
[13:19:56.740]                     future <- SequentialFuture(..., envir = envir)
[13:19:56.740]                     if (!future$lazy) 
[13:19:56.740]                       future <- run(future)
[13:19:56.740]                     invisible(future)
[13:19:56.740]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:56.740]                 }
[13:19:56.740]             }
[13:19:56.740]         }
[13:19:56.740]     })
[13:19:56.740]     if (TRUE) {
[13:19:56.740]         base::sink(type = "output", split = FALSE)
[13:19:56.740]         if (TRUE) {
[13:19:56.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:56.740]         }
[13:19:56.740]         else {
[13:19:56.740]             ...future.result["stdout"] <- base::list(NULL)
[13:19:56.740]         }
[13:19:56.740]         base::close(...future.stdout)
[13:19:56.740]         ...future.stdout <- NULL
[13:19:56.740]     }
[13:19:56.740]     ...future.result$conditions <- ...future.conditions
[13:19:56.740]     ...future.result$finished <- base::Sys.time()
[13:19:56.740]     ...future.result
[13:19:56.740] }
[13:19:56.742] assign_globals() ...
[13:19:56.742] List of 5
[13:19:56.742]  $ future.call.arguments    : list()
[13:19:56.742]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.742]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:56.742]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:56.742]  $ ...future.elements_ii    :List of 2
[13:19:56.742]   ..$ : num [1:4] 1 3 1 7
[13:19:56.742]   ..$ : num [1:4] 2 4 6 8
[13:19:56.742]  $ ...future.seeds_ii       : NULL
[13:19:56.742]  $ ...future.globals.maxSize: num Inf
[13:19:56.742]  - attr(*, "resolved")= logi FALSE
[13:19:56.742]  - attr(*, "total_size")= num NA
[13:19:56.742]  - attr(*, "where")=List of 5
[13:19:56.742]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:56.742]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:56.742]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:56.742]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:56.742]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:56.742]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.742]  - attr(*, "already-done")= logi TRUE
[13:19:56.747] - copied ‘future.call.arguments’ to environment
[13:19:56.747] - copied ‘...future.FUN’ to environment
[13:19:56.747] - copied ‘...future.elements_ii’ to environment
[13:19:56.747] - copied ‘...future.seeds_ii’ to environment
[13:19:56.747] - copied ‘...future.globals.maxSize’ to environment
[13:19:56.748] assign_globals() ... done
[13:19:56.748] plan(): Setting new future strategy stack:
[13:19:56.748] List of future strategies:
[13:19:56.748] 1. sequential:
[13:19:56.748]    - args: function (..., envir = parent.frame())
[13:19:56.748]    - tweaked: FALSE
[13:19:56.748]    - call: NULL
[13:19:56.748] plan(): nbrOfWorkers() = 1
[13:19:56.750] plan(): Setting new future strategy stack:
[13:19:56.750] List of future strategies:
[13:19:56.750] 1. sequential:
[13:19:56.750]    - args: function (..., envir = parent.frame())
[13:19:56.750]    - tweaked: FALSE
[13:19:56.750]    - call: plan(strategy)
[13:19:56.750] plan(): nbrOfWorkers() = 1
[13:19:56.750] SequentialFuture started (and completed)
[13:19:56.751] - Launch lazy future ... done
[13:19:56.751] run() for ‘SequentialFuture’ ... done
[13:19:56.751] Created future:
[13:19:56.751] SequentialFuture:
[13:19:56.751] Label: ‘future_apply-1’
[13:19:56.751] Expression:
[13:19:56.751] {
[13:19:56.751]     do.call(function(...) {
[13:19:56.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:56.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.751]             on.exit(options(oopts), add = TRUE)
[13:19:56.751]         }
[13:19:56.751]         {
[13:19:56.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:56.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.751]                 ...future.FUN(...future.X_jj, ...)
[13:19:56.751]             })
[13:19:56.751]         }
[13:19:56.751]     }, args = future.call.arguments)
[13:19:56.751] }
[13:19:56.751] Lazy evaluation: FALSE
[13:19:56.751] Asynchronous evaluation: FALSE
[13:19:56.751] Local evaluation: TRUE
[13:19:56.751] Environment: R_GlobalEnv
[13:19:56.751] Capture standard output: TRUE
[13:19:56.751] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:56.751] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:56.751] Packages: <none>
[13:19:56.751] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:56.751] Resolved: TRUE
[13:19:56.751] Value: 2.21 KiB of class ‘list’
[13:19:56.751] Early signaling: FALSE
[13:19:56.751] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:56.751] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.755] Chunk #1 of 1 ... DONE
[13:19:56.755] Launching 1 futures (chunks) ... DONE
[13:19:56.755] Resolving 1 futures (chunks) ...
[13:19:56.755] resolve() on list ...
[13:19:56.756]  recursive: 0
[13:19:56.756]  length: 1
[13:19:56.756] 
[13:19:56.756] resolved() for ‘SequentialFuture’ ...
[13:19:56.756] - state: ‘finished’
[13:19:56.756] - run: TRUE
[13:19:56.756] - result: ‘FutureResult’
[13:19:56.756] resolved() for ‘SequentialFuture’ ... done
[13:19:56.756] Future #1
[13:19:56.757] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:56.757] - nx: 1
[13:19:56.757] - relay: TRUE
[13:19:56.757] - stdout: TRUE
[13:19:56.757] - signal: TRUE
[13:19:56.757] - resignal: FALSE
[13:19:56.757] - force: TRUE
[13:19:56.758] - relayed: [n=1] FALSE
[13:19:56.758] - queued futures: [n=1] FALSE
[13:19:56.758]  - until=1
[13:19:56.758]  - relaying element #1
[13:19:56.758] - relayed: [n=1] TRUE
[13:19:56.758] - queued futures: [n=1] TRUE
[13:19:56.758] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:56.758]  length: 0 (resolved future 1)
[13:19:56.759] Relaying remaining futures
[13:19:56.759] signalConditionsASAP(NULL, pos=0) ...
[13:19:56.759] - nx: 1
[13:19:56.759] - relay: TRUE
[13:19:56.759] - stdout: TRUE
[13:19:56.759] - signal: TRUE
[13:19:56.759] - resignal: FALSE
[13:19:56.759] - force: TRUE
[13:19:56.759] - relayed: [n=1] TRUE
[13:19:56.759] - queued futures: [n=1] TRUE
 - flush all
[13:19:56.759] - relayed: [n=1] TRUE
[13:19:56.760] - queued futures: [n=1] TRUE
[13:19:56.760] signalConditionsASAP(NULL, pos=0) ... done
[13:19:56.760] resolve() on list ... DONE
[13:19:56.760]  - Number of value chunks collected: 1
[13:19:56.760] Resolving 1 futures (chunks) ... DONE
[13:19:56.760] Reducing values from 1 chunks ...
[13:19:56.760]  - Number of values collected after concatenation: 2
[13:19:56.760]  - Number of values expected: 2
[13:19:56.760] Reducing values from 1 chunks ... DONE
[13:19:56.761] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:19:56.762] getGlobalsAndPackagesXApply() ...
[13:19:56.762]  - future.globals: TRUE
[13:19:56.762] getGlobalsAndPackages() ...
[13:19:56.762] Searching for globals...
[13:19:56.799] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:19:56.799] Searching for globals ... DONE
[13:19:56.799] Resolving globals: FALSE
[13:19:56.801] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:19:56.801] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:19:56.801] - globals: [1] ‘FUN’
[13:19:56.801] 
[13:19:56.802] getGlobalsAndPackages() ... DONE
[13:19:56.802]  - globals found/used: [n=1] ‘FUN’
[13:19:56.802]  - needed namespaces: [n=0] 
[13:19:56.802] Finding globals ... DONE
[13:19:56.802]  - use_args: TRUE
[13:19:56.802]  - Getting '...' globals ...
[13:19:56.802] resolve() on list ...
[13:19:56.803]  recursive: 0
[13:19:56.803]  length: 1
[13:19:56.803]  elements: ‘...’
[13:19:56.803]  length: 0 (resolved future 1)
[13:19:56.803] resolve() on list ... DONE
[13:19:56.803]    - '...' content: [n=0] 
[13:19:56.803] List of 1
[13:19:56.803]  $ ...: list()
[13:19:56.803]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.803]  - attr(*, "where")=List of 1
[13:19:56.803]   ..$ ...:<environment: 0x555920553448> 
[13:19:56.803]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.803]  - attr(*, "resolved")= logi TRUE
[13:19:56.803]  - attr(*, "total_size")= num NA
[13:19:56.806]  - Getting '...' globals ... DONE
[13:19:56.806] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:56.806] List of 2
[13:19:56.806]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:56.806]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:56.806]  $ ...          : list()
[13:19:56.806]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.806]  - attr(*, "where")=List of 2
[13:19:56.806]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:56.806]   ..$ ...          :<environment: 0x555920553448> 
[13:19:56.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.806]  - attr(*, "resolved")= logi FALSE
[13:19:56.806]  - attr(*, "total_size")= num 354224
[13:19:56.809] Packages to be attached in all futures: [n=0] 
[13:19:56.809] getGlobalsAndPackagesXApply() ... DONE
[13:19:56.809] future_lapply() ...
[13:19:56.843] Number of chunks: 1
[13:19:56.843] getGlobalsAndPackagesXApply() ...
[13:19:56.843]  - future.globals: <name-value list> with names ‘list()’
[13:19:56.844]  - use_args: TRUE
[13:19:56.844] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:56.844] List of 2
[13:19:56.844]  $ ...          : list()
[13:19:56.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.844]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:56.844]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:56.844]  - attr(*, "where")=List of 2
[13:19:56.844]   ..$ ...          :<environment: 0x555920553448> 
[13:19:56.844]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:56.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.844]  - attr(*, "resolved")= logi FALSE
[13:19:56.844]  - attr(*, "total_size")= num NA
[13:19:56.847] Packages to be attached in all futures: [n=0] 
[13:19:56.847] getGlobalsAndPackagesXApply() ... DONE
[13:19:56.848] Number of futures (= number of chunks): 1
[13:19:56.848] Launching 1 futures (chunks) ...
[13:19:56.848] Chunk #1 of 1 ...
[13:19:56.848]  - seeds: <none>
[13:19:56.848]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.848] getGlobalsAndPackages() ...
[13:19:56.848] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.848] Resolving globals: FALSE
[13:19:56.849] Tweak future expression to call with '...' arguments ...
[13:19:56.849] {
[13:19:56.849]     do.call(function(...) {
[13:19:56.849]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.849]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:56.849]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.849]             on.exit(options(oopts), add = TRUE)
[13:19:56.849]         }
[13:19:56.849]         {
[13:19:56.849]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:56.849]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.849]                 ...future.FUN(...future.X_jj, ...)
[13:19:56.849]             })
[13:19:56.849]         }
[13:19:56.849]     }, args = future.call.arguments)
[13:19:56.849] }
[13:19:56.849] Tweak future expression to call with '...' arguments ... DONE
[13:19:56.849] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.849] 
[13:19:56.850] getGlobalsAndPackages() ... DONE
[13:19:56.850] run() for ‘Future’ ...
[13:19:56.850] - state: ‘created’
[13:19:56.850] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:56.850] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.850] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:56.851]   - Field: ‘label’
[13:19:56.851]   - Field: ‘local’
[13:19:56.851]   - Field: ‘owner’
[13:19:56.851]   - Field: ‘envir’
[13:19:56.851]   - Field: ‘packages’
[13:19:56.851]   - Field: ‘gc’
[13:19:56.851]   - Field: ‘conditions’
[13:19:56.851]   - Field: ‘expr’
[13:19:56.851]   - Field: ‘uuid’
[13:19:56.851]   - Field: ‘seed’
[13:19:56.852]   - Field: ‘version’
[13:19:56.852]   - Field: ‘result’
[13:19:56.852]   - Field: ‘asynchronous’
[13:19:56.852]   - Field: ‘calls’
[13:19:56.852]   - Field: ‘globals’
[13:19:56.852]   - Field: ‘stdout’
[13:19:56.852]   - Field: ‘earlySignal’
[13:19:56.852]   - Field: ‘lazy’
[13:19:56.852]   - Field: ‘state’
[13:19:56.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:56.853] - Launch lazy future ...
[13:19:56.853] Packages needed by the future expression (n = 0): <none>
[13:19:56.853] Packages needed by future strategies (n = 0): <none>
[13:19:56.853] {
[13:19:56.853]     {
[13:19:56.853]         {
[13:19:56.853]             ...future.startTime <- base::Sys.time()
[13:19:56.853]             {
[13:19:56.853]                 {
[13:19:56.853]                   {
[13:19:56.853]                     base::local({
[13:19:56.853]                       has_future <- base::requireNamespace("future", 
[13:19:56.853]                         quietly = TRUE)
[13:19:56.853]                       if (has_future) {
[13:19:56.853]                         ns <- base::getNamespace("future")
[13:19:56.853]                         version <- ns[[".package"]][["version"]]
[13:19:56.853]                         if (is.null(version)) 
[13:19:56.853]                           version <- utils::packageVersion("future")
[13:19:56.853]                       }
[13:19:56.853]                       else {
[13:19:56.853]                         version <- NULL
[13:19:56.853]                       }
[13:19:56.853]                       if (!has_future || version < "1.8.0") {
[13:19:56.853]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:56.853]                           "", base::R.version$version.string), 
[13:19:56.853]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:56.853]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:56.853]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:56.853]                             "release", "version")], collapse = " "), 
[13:19:56.853]                           hostname = base::Sys.info()[["nodename"]])
[13:19:56.853]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:56.853]                           info)
[13:19:56.853]                         info <- base::paste(info, collapse = "; ")
[13:19:56.853]                         if (!has_future) {
[13:19:56.853]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:56.853]                             info)
[13:19:56.853]                         }
[13:19:56.853]                         else {
[13:19:56.853]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:56.853]                             info, version)
[13:19:56.853]                         }
[13:19:56.853]                         base::stop(msg)
[13:19:56.853]                       }
[13:19:56.853]                     })
[13:19:56.853]                   }
[13:19:56.853]                   options(future.plan = NULL)
[13:19:56.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:56.853]                 }
[13:19:56.853]                 ...future.workdir <- getwd()
[13:19:56.853]             }
[13:19:56.853]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:56.853]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:56.853]         }
[13:19:56.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:56.853]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:56.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:56.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:56.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:56.853]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:56.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:56.853]             base::names(...future.oldOptions))
[13:19:56.853]     }
[13:19:56.853]     if (FALSE) {
[13:19:56.853]     }
[13:19:56.853]     else {
[13:19:56.853]         if (TRUE) {
[13:19:56.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:56.853]                 open = "w")
[13:19:56.853]         }
[13:19:56.853]         else {
[13:19:56.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:56.853]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:56.853]         }
[13:19:56.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:56.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:56.853]             base::sink(type = "output", split = FALSE)
[13:19:56.853]             base::close(...future.stdout)
[13:19:56.853]         }, add = TRUE)
[13:19:56.853]     }
[13:19:56.853]     ...future.frame <- base::sys.nframe()
[13:19:56.853]     ...future.conditions <- base::list()
[13:19:56.853]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:56.853]     if (FALSE) {
[13:19:56.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:56.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:56.853]     }
[13:19:56.853]     ...future.result <- base::tryCatch({
[13:19:56.853]         base::withCallingHandlers({
[13:19:56.853]             ...future.value <- base::withVisible(base::local({
[13:19:56.853]                 do.call(function(...) {
[13:19:56.853]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.853]                   if (!identical(...future.globals.maxSize.org, 
[13:19:56.853]                     ...future.globals.maxSize)) {
[13:19:56.853]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.853]                     on.exit(options(oopts), add = TRUE)
[13:19:56.853]                   }
[13:19:56.853]                   {
[13:19:56.853]                     lapply(seq_along(...future.elements_ii), 
[13:19:56.853]                       FUN = function(jj) {
[13:19:56.853]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.853]                         ...future.FUN(...future.X_jj, ...)
[13:19:56.853]                       })
[13:19:56.853]                   }
[13:19:56.853]                 }, args = future.call.arguments)
[13:19:56.853]             }))
[13:19:56.853]             future::FutureResult(value = ...future.value$value, 
[13:19:56.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.853]                   ...future.rng), globalenv = if (FALSE) 
[13:19:56.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:56.853]                     ...future.globalenv.names))
[13:19:56.853]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:56.853]         }, condition = base::local({
[13:19:56.853]             c <- base::c
[13:19:56.853]             inherits <- base::inherits
[13:19:56.853]             invokeRestart <- base::invokeRestart
[13:19:56.853]             length <- base::length
[13:19:56.853]             list <- base::list
[13:19:56.853]             seq.int <- base::seq.int
[13:19:56.853]             signalCondition <- base::signalCondition
[13:19:56.853]             sys.calls <- base::sys.calls
[13:19:56.853]             `[[` <- base::`[[`
[13:19:56.853]             `+` <- base::`+`
[13:19:56.853]             `<<-` <- base::`<<-`
[13:19:56.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:56.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:56.853]                   3L)]
[13:19:56.853]             }
[13:19:56.853]             function(cond) {
[13:19:56.853]                 is_error <- inherits(cond, "error")
[13:19:56.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:56.853]                   NULL)
[13:19:56.853]                 if (is_error) {
[13:19:56.853]                   sessionInformation <- function() {
[13:19:56.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:56.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:56.853]                       search = base::search(), system = base::Sys.info())
[13:19:56.853]                   }
[13:19:56.853]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:56.853]                     cond$call), session = sessionInformation(), 
[13:19:56.853]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:56.853]                   signalCondition(cond)
[13:19:56.853]                 }
[13:19:56.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:56.853]                 "immediateCondition"))) {
[13:19:56.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:56.853]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:56.853]                   if (TRUE && !signal) {
[13:19:56.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.853]                     {
[13:19:56.853]                       inherits <- base::inherits
[13:19:56.853]                       invokeRestart <- base::invokeRestart
[13:19:56.853]                       is.null <- base::is.null
[13:19:56.853]                       muffled <- FALSE
[13:19:56.853]                       if (inherits(cond, "message")) {
[13:19:56.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.853]                         if (muffled) 
[13:19:56.853]                           invokeRestart("muffleMessage")
[13:19:56.853]                       }
[13:19:56.853]                       else if (inherits(cond, "warning")) {
[13:19:56.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.853]                         if (muffled) 
[13:19:56.853]                           invokeRestart("muffleWarning")
[13:19:56.853]                       }
[13:19:56.853]                       else if (inherits(cond, "condition")) {
[13:19:56.853]                         if (!is.null(pattern)) {
[13:19:56.853]                           computeRestarts <- base::computeRestarts
[13:19:56.853]                           grepl <- base::grepl
[13:19:56.853]                           restarts <- computeRestarts(cond)
[13:19:56.853]                           for (restart in restarts) {
[13:19:56.853]                             name <- restart$name
[13:19:56.853]                             if (is.null(name)) 
[13:19:56.853]                               next
[13:19:56.853]                             if (!grepl(pattern, name)) 
[13:19:56.853]                               next
[13:19:56.853]                             invokeRestart(restart)
[13:19:56.853]                             muffled <- TRUE
[13:19:56.853]                             break
[13:19:56.853]                           }
[13:19:56.853]                         }
[13:19:56.853]                       }
[13:19:56.853]                       invisible(muffled)
[13:19:56.853]                     }
[13:19:56.853]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.853]                   }
[13:19:56.853]                 }
[13:19:56.853]                 else {
[13:19:56.853]                   if (TRUE) {
[13:19:56.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.853]                     {
[13:19:56.853]                       inherits <- base::inherits
[13:19:56.853]                       invokeRestart <- base::invokeRestart
[13:19:56.853]                       is.null <- base::is.null
[13:19:56.853]                       muffled <- FALSE
[13:19:56.853]                       if (inherits(cond, "message")) {
[13:19:56.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.853]                         if (muffled) 
[13:19:56.853]                           invokeRestart("muffleMessage")
[13:19:56.853]                       }
[13:19:56.853]                       else if (inherits(cond, "warning")) {
[13:19:56.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.853]                         if (muffled) 
[13:19:56.853]                           invokeRestart("muffleWarning")
[13:19:56.853]                       }
[13:19:56.853]                       else if (inherits(cond, "condition")) {
[13:19:56.853]                         if (!is.null(pattern)) {
[13:19:56.853]                           computeRestarts <- base::computeRestarts
[13:19:56.853]                           grepl <- base::grepl
[13:19:56.853]                           restarts <- computeRestarts(cond)
[13:19:56.853]                           for (restart in restarts) {
[13:19:56.853]                             name <- restart$name
[13:19:56.853]                             if (is.null(name)) 
[13:19:56.853]                               next
[13:19:56.853]                             if (!grepl(pattern, name)) 
[13:19:56.853]                               next
[13:19:56.853]                             invokeRestart(restart)
[13:19:56.853]                             muffled <- TRUE
[13:19:56.853]                             break
[13:19:56.853]                           }
[13:19:56.853]                         }
[13:19:56.853]                       }
[13:19:56.853]                       invisible(muffled)
[13:19:56.853]                     }
[13:19:56.853]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.853]                   }
[13:19:56.853]                 }
[13:19:56.853]             }
[13:19:56.853]         }))
[13:19:56.853]     }, error = function(ex) {
[13:19:56.853]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:56.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.853]                 ...future.rng), started = ...future.startTime, 
[13:19:56.853]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:56.853]             version = "1.8"), class = "FutureResult")
[13:19:56.853]     }, finally = {
[13:19:56.853]         if (!identical(...future.workdir, getwd())) 
[13:19:56.853]             setwd(...future.workdir)
[13:19:56.853]         {
[13:19:56.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:56.853]                 ...future.oldOptions$nwarnings <- NULL
[13:19:56.853]             }
[13:19:56.853]             base::options(...future.oldOptions)
[13:19:56.853]             if (.Platform$OS.type == "windows") {
[13:19:56.853]                 old_names <- names(...future.oldEnvVars)
[13:19:56.853]                 envs <- base::Sys.getenv()
[13:19:56.853]                 names <- names(envs)
[13:19:56.853]                 common <- intersect(names, old_names)
[13:19:56.853]                 added <- setdiff(names, old_names)
[13:19:56.853]                 removed <- setdiff(old_names, names)
[13:19:56.853]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:56.853]                   envs[common]]
[13:19:56.853]                 NAMES <- toupper(changed)
[13:19:56.853]                 args <- list()
[13:19:56.853]                 for (kk in seq_along(NAMES)) {
[13:19:56.853]                   name <- changed[[kk]]
[13:19:56.853]                   NAME <- NAMES[[kk]]
[13:19:56.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.853]                     next
[13:19:56.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.853]                 }
[13:19:56.853]                 NAMES <- toupper(added)
[13:19:56.853]                 for (kk in seq_along(NAMES)) {
[13:19:56.853]                   name <- added[[kk]]
[13:19:56.853]                   NAME <- NAMES[[kk]]
[13:19:56.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.853]                     next
[13:19:56.853]                   args[[name]] <- ""
[13:19:56.853]                 }
[13:19:56.853]                 NAMES <- toupper(removed)
[13:19:56.853]                 for (kk in seq_along(NAMES)) {
[13:19:56.853]                   name <- removed[[kk]]
[13:19:56.853]                   NAME <- NAMES[[kk]]
[13:19:56.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.853]                     next
[13:19:56.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.853]                 }
[13:19:56.853]                 if (length(args) > 0) 
[13:19:56.853]                   base::do.call(base::Sys.setenv, args = args)
[13:19:56.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:56.853]             }
[13:19:56.853]             else {
[13:19:56.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:56.853]             }
[13:19:56.853]             {
[13:19:56.853]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:56.853]                   0L) {
[13:19:56.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:56.853]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:56.853]                   base::options(opts)
[13:19:56.853]                 }
[13:19:56.853]                 {
[13:19:56.853]                   {
[13:19:56.853]                     NULL
[13:19:56.853]                     RNGkind("Mersenne-Twister")
[13:19:56.853]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:56.853]                       inherits = FALSE)
[13:19:56.853]                   }
[13:19:56.853]                   options(future.plan = NULL)
[13:19:56.853]                   if (is.na(NA_character_)) 
[13:19:56.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:56.853]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:56.853]                   {
[13:19:56.853]                     future <- SequentialFuture(..., envir = envir)
[13:19:56.853]                     if (!future$lazy) 
[13:19:56.853]                       future <- run(future)
[13:19:56.853]                     invisible(future)
[13:19:56.853]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:56.853]                 }
[13:19:56.853]             }
[13:19:56.853]         }
[13:19:56.853]     })
[13:19:56.853]     if (TRUE) {
[13:19:56.853]         base::sink(type = "output", split = FALSE)
[13:19:56.853]         if (TRUE) {
[13:19:56.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:56.853]         }
[13:19:56.853]         else {
[13:19:56.853]             ...future.result["stdout"] <- base::list(NULL)
[13:19:56.853]         }
[13:19:56.853]         base::close(...future.stdout)
[13:19:56.853]         ...future.stdout <- NULL
[13:19:56.853]     }
[13:19:56.853]     ...future.result$conditions <- ...future.conditions
[13:19:56.853]     ...future.result$finished <- base::Sys.time()
[13:19:56.853]     ...future.result
[13:19:56.853] }
[13:19:56.855] assign_globals() ...
[13:19:56.855] List of 5
[13:19:56.855]  $ future.call.arguments    : list()
[13:19:56.855]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.855]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:56.855]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:56.855]  $ ...future.elements_ii    :List of 2
[13:19:56.855]   ..$ : num [1:4] 1 3 1 7
[13:19:56.855]   ..$ : num [1:4] 2 4 6 8
[13:19:56.855]  $ ...future.seeds_ii       : NULL
[13:19:56.855]  $ ...future.globals.maxSize: num Inf
[13:19:56.855]  - attr(*, "resolved")= logi FALSE
[13:19:56.855]  - attr(*, "total_size")= num NA
[13:19:56.855]  - attr(*, "where")=List of 5
[13:19:56.855]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:56.855]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:56.855]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:56.855]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:56.855]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:56.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.855]  - attr(*, "already-done")= logi TRUE
[13:19:56.862] - copied ‘future.call.arguments’ to environment
[13:19:56.862] - copied ‘...future.FUN’ to environment
[13:19:56.862] - copied ‘...future.elements_ii’ to environment
[13:19:56.862] - copied ‘...future.seeds_ii’ to environment
[13:19:56.862] - copied ‘...future.globals.maxSize’ to environment
[13:19:56.863] assign_globals() ... done
[13:19:56.863] plan(): Setting new future strategy stack:
[13:19:56.863] List of future strategies:
[13:19:56.863] 1. sequential:
[13:19:56.863]    - args: function (..., envir = parent.frame())
[13:19:56.863]    - tweaked: FALSE
[13:19:56.863]    - call: NULL
[13:19:56.863] plan(): nbrOfWorkers() = 1
[13:19:56.864] plan(): Setting new future strategy stack:
[13:19:56.864] List of future strategies:
[13:19:56.864] 1. sequential:
[13:19:56.864]    - args: function (..., envir = parent.frame())
[13:19:56.864]    - tweaked: FALSE
[13:19:56.864]    - call: plan(strategy)
[13:19:56.865] plan(): nbrOfWorkers() = 1
[13:19:56.865] SequentialFuture started (and completed)
[13:19:56.865] - Launch lazy future ... done
[13:19:56.865] run() for ‘SequentialFuture’ ... done
[13:19:56.865] Created future:
[13:19:56.865] SequentialFuture:
[13:19:56.865] Label: ‘future_apply-1’
[13:19:56.865] Expression:
[13:19:56.865] {
[13:19:56.865]     do.call(function(...) {
[13:19:56.865]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.865]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:56.865]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.865]             on.exit(options(oopts), add = TRUE)
[13:19:56.865]         }
[13:19:56.865]         {
[13:19:56.865]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:56.865]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.865]                 ...future.FUN(...future.X_jj, ...)
[13:19:56.865]             })
[13:19:56.865]         }
[13:19:56.865]     }, args = future.call.arguments)
[13:19:56.865] }
[13:19:56.865] Lazy evaluation: FALSE
[13:19:56.865] Asynchronous evaluation: FALSE
[13:19:56.865] Local evaluation: TRUE
[13:19:56.865] Environment: R_GlobalEnv
[13:19:56.865] Capture standard output: TRUE
[13:19:56.865] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:56.865] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:56.865] Packages: <none>
[13:19:56.865] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:56.865] Resolved: TRUE
[13:19:56.865] Value: 2.21 KiB of class ‘list’
[13:19:56.865] Early signaling: FALSE
[13:19:56.865] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:56.865] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.866] Chunk #1 of 1 ... DONE
[13:19:56.867] Launching 1 futures (chunks) ... DONE
[13:19:56.867] Resolving 1 futures (chunks) ...
[13:19:56.867] resolve() on list ...
[13:19:56.867]  recursive: 0
[13:19:56.867]  length: 1
[13:19:56.867] 
[13:19:56.867] resolved() for ‘SequentialFuture’ ...
[13:19:56.867] - state: ‘finished’
[13:19:56.867] - run: TRUE
[13:19:56.867] - result: ‘FutureResult’
[13:19:56.867] resolved() for ‘SequentialFuture’ ... done
[13:19:56.868] Future #1
[13:19:56.868] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:56.868] - nx: 1
[13:19:56.868] - relay: TRUE
[13:19:56.868] - stdout: TRUE
[13:19:56.868] - signal: TRUE
[13:19:56.868] - resignal: FALSE
[13:19:56.868] - force: TRUE
[13:19:56.868] - relayed: [n=1] FALSE
[13:19:56.868] - queued futures: [n=1] FALSE
[13:19:56.869]  - until=1
[13:19:56.869]  - relaying element #1
[13:19:56.869] - relayed: [n=1] TRUE
[13:19:56.869] - queued futures: [n=1] TRUE
[13:19:56.869] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:56.869]  length: 0 (resolved future 1)
[13:19:56.869] Relaying remaining futures
[13:19:56.869] signalConditionsASAP(NULL, pos=0) ...
[13:19:56.869] - nx: 1
[13:19:56.869] - relay: TRUE
[13:19:56.870] - stdout: TRUE
[13:19:56.870] - signal: TRUE
[13:19:56.870] - resignal: FALSE
[13:19:56.870] - force: TRUE
[13:19:56.870] - relayed: [n=1] TRUE
[13:19:56.870] - queued futures: [n=1] TRUE
 - flush all
[13:19:56.870] - relayed: [n=1] TRUE
[13:19:56.870] - queued futures: [n=1] TRUE
[13:19:56.870] signalConditionsASAP(NULL, pos=0) ... done
[13:19:56.870] resolve() on list ... DONE
[13:19:56.871]  - Number of value chunks collected: 1
[13:19:56.871] Resolving 1 futures (chunks) ... DONE
[13:19:56.871] Reducing values from 1 chunks ...
[13:19:56.871]  - Number of values collected after concatenation: 2
[13:19:56.871]  - Number of values expected: 2
[13:19:56.871] Reducing values from 1 chunks ... DONE
[13:19:56.871] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:19:56.874] getGlobalsAndPackagesXApply() ...
[13:19:56.874]  - future.globals: TRUE
[13:19:56.874] getGlobalsAndPackages() ...
[13:19:56.874] Searching for globals...
[13:19:56.875] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:19:56.875] Searching for globals ... DONE
[13:19:56.875] Resolving globals: FALSE
[13:19:56.876] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:19:56.876] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:19:56.876] - globals: [1] ‘FUN’
[13:19:56.876] - packages: [1] ‘stats’
[13:19:56.876] getGlobalsAndPackages() ... DONE
[13:19:56.876]  - globals found/used: [n=1] ‘FUN’
[13:19:56.876]  - needed namespaces: [n=1] ‘stats’
[13:19:56.877] Finding globals ... DONE
[13:19:56.877]  - use_args: TRUE
[13:19:56.877]  - Getting '...' globals ...
[13:19:56.877] resolve() on list ...
[13:19:56.877]  recursive: 0
[13:19:56.877]  length: 1
[13:19:56.877]  elements: ‘...’
[13:19:56.877]  length: 0 (resolved future 1)
[13:19:56.878] resolve() on list ... DONE
[13:19:56.878]    - '...' content: [n=0] 
[13:19:56.878] List of 1
[13:19:56.878]  $ ...: list()
[13:19:56.878]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.878]  - attr(*, "where")=List of 1
[13:19:56.878]   ..$ ...:<environment: 0x5559221d8878> 
[13:19:56.878]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.878]  - attr(*, "resolved")= logi TRUE
[13:19:56.878]  - attr(*, "total_size")= num NA
[13:19:56.880]  - Getting '...' globals ... DONE
[13:19:56.880] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:56.881] List of 2
[13:19:56.881]  $ ...future.FUN:function (x, ...)  
[13:19:56.881]  $ ...          : list()
[13:19:56.881]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.881]  - attr(*, "where")=List of 2
[13:19:56.881]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:56.881]   ..$ ...          :<environment: 0x5559221d8878> 
[13:19:56.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.881]  - attr(*, "resolved")= logi FALSE
[13:19:56.881]  - attr(*, "total_size")= num 1248
[13:19:56.883] Packages to be attached in all futures: [n=1] ‘stats’
[13:19:56.883] getGlobalsAndPackagesXApply() ... DONE
[13:19:56.884] future_lapply() ...
[13:19:56.884] Number of chunks: 1
[13:19:56.884] getGlobalsAndPackagesXApply() ...
[13:19:56.884]  - future.globals: <name-value list> with names ‘list()’
[13:19:56.884]  - use_args: TRUE
[13:19:56.886] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:56.886] List of 2
[13:19:56.886]  $ ...          : list()
[13:19:56.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.886]  $ ...future.FUN:function (x, ...)  
[13:19:56.886]  - attr(*, "where")=List of 2
[13:19:56.886]   ..$ ...          :<environment: 0x5559221d8878> 
[13:19:56.886]   ..$ ...future.FUN:<environment: namespace:stats> 
[13:19:56.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.886]  - attr(*, "resolved")= logi FALSE
[13:19:56.886]  - attr(*, "total_size")= num NA
[13:19:56.889] Packages to be attached in all futures: [n=1] ‘stats’
[13:19:56.889] getGlobalsAndPackagesXApply() ... DONE
[13:19:56.889] Number of futures (= number of chunks): 1
[13:19:56.889] Launching 1 futures (chunks) ...
[13:19:56.890] Chunk #1 of 1 ...
[13:19:56.890]  - seeds: <none>
[13:19:56.890]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.890] getGlobalsAndPackages() ...
[13:19:56.890] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.890] Resolving globals: FALSE
[13:19:56.890] Tweak future expression to call with '...' arguments ...
[13:19:56.890] {
[13:19:56.890]     do.call(function(...) {
[13:19:56.890]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.890]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:56.890]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.890]             on.exit(options(oopts), add = TRUE)
[13:19:56.890]         }
[13:19:56.890]         {
[13:19:56.890]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:56.890]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.890]                 ...future.FUN(...future.X_jj, ...)
[13:19:56.890]             })
[13:19:56.890]         }
[13:19:56.890]     }, args = future.call.arguments)
[13:19:56.890] }
[13:19:56.891] Tweak future expression to call with '...' arguments ... DONE
[13:19:56.891] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.891] - packages: [1] ‘stats’
[13:19:56.891] getGlobalsAndPackages() ... DONE
[13:19:56.892] run() for ‘Future’ ...
[13:19:56.892] - state: ‘created’
[13:19:56.892] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:56.892] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.892] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:56.892]   - Field: ‘label’
[13:19:56.892]   - Field: ‘local’
[13:19:56.893]   - Field: ‘owner’
[13:19:56.893]   - Field: ‘envir’
[13:19:56.893]   - Field: ‘packages’
[13:19:56.893]   - Field: ‘gc’
[13:19:56.893]   - Field: ‘conditions’
[13:19:56.893]   - Field: ‘expr’
[13:19:56.893]   - Field: ‘uuid’
[13:19:56.893]   - Field: ‘seed’
[13:19:56.893]   - Field: ‘version’
[13:19:56.893]   - Field: ‘result’
[13:19:56.893]   - Field: ‘asynchronous’
[13:19:56.894]   - Field: ‘calls’
[13:19:56.894]   - Field: ‘globals’
[13:19:56.894]   - Field: ‘stdout’
[13:19:56.894]   - Field: ‘earlySignal’
[13:19:56.894]   - Field: ‘lazy’
[13:19:56.894]   - Field: ‘state’
[13:19:56.894] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:56.894] - Launch lazy future ...
[13:19:56.894] Packages needed by the future expression (n = 1): ‘stats’
[13:19:56.894] Packages needed by future strategies (n = 0): <none>
[13:19:56.895] {
[13:19:56.895]     {
[13:19:56.895]         {
[13:19:56.895]             ...future.startTime <- base::Sys.time()
[13:19:56.895]             {
[13:19:56.895]                 {
[13:19:56.895]                   {
[13:19:56.895]                     {
[13:19:56.895]                       base::local({
[13:19:56.895]                         has_future <- base::requireNamespace("future", 
[13:19:56.895]                           quietly = TRUE)
[13:19:56.895]                         if (has_future) {
[13:19:56.895]                           ns <- base::getNamespace("future")
[13:19:56.895]                           version <- ns[[".package"]][["version"]]
[13:19:56.895]                           if (is.null(version)) 
[13:19:56.895]                             version <- utils::packageVersion("future")
[13:19:56.895]                         }
[13:19:56.895]                         else {
[13:19:56.895]                           version <- NULL
[13:19:56.895]                         }
[13:19:56.895]                         if (!has_future || version < "1.8.0") {
[13:19:56.895]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:56.895]                             "", base::R.version$version.string), 
[13:19:56.895]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:56.895]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:56.895]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:56.895]                               "release", "version")], collapse = " "), 
[13:19:56.895]                             hostname = base::Sys.info()[["nodename"]])
[13:19:56.895]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:56.895]                             info)
[13:19:56.895]                           info <- base::paste(info, collapse = "; ")
[13:19:56.895]                           if (!has_future) {
[13:19:56.895]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:56.895]                               info)
[13:19:56.895]                           }
[13:19:56.895]                           else {
[13:19:56.895]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:56.895]                               info, version)
[13:19:56.895]                           }
[13:19:56.895]                           base::stop(msg)
[13:19:56.895]                         }
[13:19:56.895]                       })
[13:19:56.895]                     }
[13:19:56.895]                     base::local({
[13:19:56.895]                       for (pkg in "stats") {
[13:19:56.895]                         base::loadNamespace(pkg)
[13:19:56.895]                         base::library(pkg, character.only = TRUE)
[13:19:56.895]                       }
[13:19:56.895]                     })
[13:19:56.895]                   }
[13:19:56.895]                   options(future.plan = NULL)
[13:19:56.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:56.895]                 }
[13:19:56.895]                 ...future.workdir <- getwd()
[13:19:56.895]             }
[13:19:56.895]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:56.895]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:56.895]         }
[13:19:56.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:56.895]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:56.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:56.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:56.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:56.895]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:56.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:56.895]             base::names(...future.oldOptions))
[13:19:56.895]     }
[13:19:56.895]     if (FALSE) {
[13:19:56.895]     }
[13:19:56.895]     else {
[13:19:56.895]         if (TRUE) {
[13:19:56.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:56.895]                 open = "w")
[13:19:56.895]         }
[13:19:56.895]         else {
[13:19:56.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:56.895]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:56.895]         }
[13:19:56.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:56.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:56.895]             base::sink(type = "output", split = FALSE)
[13:19:56.895]             base::close(...future.stdout)
[13:19:56.895]         }, add = TRUE)
[13:19:56.895]     }
[13:19:56.895]     ...future.frame <- base::sys.nframe()
[13:19:56.895]     ...future.conditions <- base::list()
[13:19:56.895]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:56.895]     if (FALSE) {
[13:19:56.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:56.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:56.895]     }
[13:19:56.895]     ...future.result <- base::tryCatch({
[13:19:56.895]         base::withCallingHandlers({
[13:19:56.895]             ...future.value <- base::withVisible(base::local({
[13:19:56.895]                 do.call(function(...) {
[13:19:56.895]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.895]                   if (!identical(...future.globals.maxSize.org, 
[13:19:56.895]                     ...future.globals.maxSize)) {
[13:19:56.895]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.895]                     on.exit(options(oopts), add = TRUE)
[13:19:56.895]                   }
[13:19:56.895]                   {
[13:19:56.895]                     lapply(seq_along(...future.elements_ii), 
[13:19:56.895]                       FUN = function(jj) {
[13:19:56.895]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.895]                         ...future.FUN(...future.X_jj, ...)
[13:19:56.895]                       })
[13:19:56.895]                   }
[13:19:56.895]                 }, args = future.call.arguments)
[13:19:56.895]             }))
[13:19:56.895]             future::FutureResult(value = ...future.value$value, 
[13:19:56.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.895]                   ...future.rng), globalenv = if (FALSE) 
[13:19:56.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:56.895]                     ...future.globalenv.names))
[13:19:56.895]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:56.895]         }, condition = base::local({
[13:19:56.895]             c <- base::c
[13:19:56.895]             inherits <- base::inherits
[13:19:56.895]             invokeRestart <- base::invokeRestart
[13:19:56.895]             length <- base::length
[13:19:56.895]             list <- base::list
[13:19:56.895]             seq.int <- base::seq.int
[13:19:56.895]             signalCondition <- base::signalCondition
[13:19:56.895]             sys.calls <- base::sys.calls
[13:19:56.895]             `[[` <- base::`[[`
[13:19:56.895]             `+` <- base::`+`
[13:19:56.895]             `<<-` <- base::`<<-`
[13:19:56.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:56.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:56.895]                   3L)]
[13:19:56.895]             }
[13:19:56.895]             function(cond) {
[13:19:56.895]                 is_error <- inherits(cond, "error")
[13:19:56.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:56.895]                   NULL)
[13:19:56.895]                 if (is_error) {
[13:19:56.895]                   sessionInformation <- function() {
[13:19:56.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:56.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:56.895]                       search = base::search(), system = base::Sys.info())
[13:19:56.895]                   }
[13:19:56.895]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:56.895]                     cond$call), session = sessionInformation(), 
[13:19:56.895]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:56.895]                   signalCondition(cond)
[13:19:56.895]                 }
[13:19:56.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:56.895]                 "immediateCondition"))) {
[13:19:56.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:56.895]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:56.895]                   if (TRUE && !signal) {
[13:19:56.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.895]                     {
[13:19:56.895]                       inherits <- base::inherits
[13:19:56.895]                       invokeRestart <- base::invokeRestart
[13:19:56.895]                       is.null <- base::is.null
[13:19:56.895]                       muffled <- FALSE
[13:19:56.895]                       if (inherits(cond, "message")) {
[13:19:56.895]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.895]                         if (muffled) 
[13:19:56.895]                           invokeRestart("muffleMessage")
[13:19:56.895]                       }
[13:19:56.895]                       else if (inherits(cond, "warning")) {
[13:19:56.895]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.895]                         if (muffled) 
[13:19:56.895]                           invokeRestart("muffleWarning")
[13:19:56.895]                       }
[13:19:56.895]                       else if (inherits(cond, "condition")) {
[13:19:56.895]                         if (!is.null(pattern)) {
[13:19:56.895]                           computeRestarts <- base::computeRestarts
[13:19:56.895]                           grepl <- base::grepl
[13:19:56.895]                           restarts <- computeRestarts(cond)
[13:19:56.895]                           for (restart in restarts) {
[13:19:56.895]                             name <- restart$name
[13:19:56.895]                             if (is.null(name)) 
[13:19:56.895]                               next
[13:19:56.895]                             if (!grepl(pattern, name)) 
[13:19:56.895]                               next
[13:19:56.895]                             invokeRestart(restart)
[13:19:56.895]                             muffled <- TRUE
[13:19:56.895]                             break
[13:19:56.895]                           }
[13:19:56.895]                         }
[13:19:56.895]                       }
[13:19:56.895]                       invisible(muffled)
[13:19:56.895]                     }
[13:19:56.895]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.895]                   }
[13:19:56.895]                 }
[13:19:56.895]                 else {
[13:19:56.895]                   if (TRUE) {
[13:19:56.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.895]                     {
[13:19:56.895]                       inherits <- base::inherits
[13:19:56.895]                       invokeRestart <- base::invokeRestart
[13:19:56.895]                       is.null <- base::is.null
[13:19:56.895]                       muffled <- FALSE
[13:19:56.895]                       if (inherits(cond, "message")) {
[13:19:56.895]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.895]                         if (muffled) 
[13:19:56.895]                           invokeRestart("muffleMessage")
[13:19:56.895]                       }
[13:19:56.895]                       else if (inherits(cond, "warning")) {
[13:19:56.895]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.895]                         if (muffled) 
[13:19:56.895]                           invokeRestart("muffleWarning")
[13:19:56.895]                       }
[13:19:56.895]                       else if (inherits(cond, "condition")) {
[13:19:56.895]                         if (!is.null(pattern)) {
[13:19:56.895]                           computeRestarts <- base::computeRestarts
[13:19:56.895]                           grepl <- base::grepl
[13:19:56.895]                           restarts <- computeRestarts(cond)
[13:19:56.895]                           for (restart in restarts) {
[13:19:56.895]                             name <- restart$name
[13:19:56.895]                             if (is.null(name)) 
[13:19:56.895]                               next
[13:19:56.895]                             if (!grepl(pattern, name)) 
[13:19:56.895]                               next
[13:19:56.895]                             invokeRestart(restart)
[13:19:56.895]                             muffled <- TRUE
[13:19:56.895]                             break
[13:19:56.895]                           }
[13:19:56.895]                         }
[13:19:56.895]                       }
[13:19:56.895]                       invisible(muffled)
[13:19:56.895]                     }
[13:19:56.895]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.895]                   }
[13:19:56.895]                 }
[13:19:56.895]             }
[13:19:56.895]         }))
[13:19:56.895]     }, error = function(ex) {
[13:19:56.895]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:56.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.895]                 ...future.rng), started = ...future.startTime, 
[13:19:56.895]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:56.895]             version = "1.8"), class = "FutureResult")
[13:19:56.895]     }, finally = {
[13:19:56.895]         if (!identical(...future.workdir, getwd())) 
[13:19:56.895]             setwd(...future.workdir)
[13:19:56.895]         {
[13:19:56.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:56.895]                 ...future.oldOptions$nwarnings <- NULL
[13:19:56.895]             }
[13:19:56.895]             base::options(...future.oldOptions)
[13:19:56.895]             if (.Platform$OS.type == "windows") {
[13:19:56.895]                 old_names <- names(...future.oldEnvVars)
[13:19:56.895]                 envs <- base::Sys.getenv()
[13:19:56.895]                 names <- names(envs)
[13:19:56.895]                 common <- intersect(names, old_names)
[13:19:56.895]                 added <- setdiff(names, old_names)
[13:19:56.895]                 removed <- setdiff(old_names, names)
[13:19:56.895]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:56.895]                   envs[common]]
[13:19:56.895]                 NAMES <- toupper(changed)
[13:19:56.895]                 args <- list()
[13:19:56.895]                 for (kk in seq_along(NAMES)) {
[13:19:56.895]                   name <- changed[[kk]]
[13:19:56.895]                   NAME <- NAMES[[kk]]
[13:19:56.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.895]                     next
[13:19:56.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.895]                 }
[13:19:56.895]                 NAMES <- toupper(added)
[13:19:56.895]                 for (kk in seq_along(NAMES)) {
[13:19:56.895]                   name <- added[[kk]]
[13:19:56.895]                   NAME <- NAMES[[kk]]
[13:19:56.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.895]                     next
[13:19:56.895]                   args[[name]] <- ""
[13:19:56.895]                 }
[13:19:56.895]                 NAMES <- toupper(removed)
[13:19:56.895]                 for (kk in seq_along(NAMES)) {
[13:19:56.895]                   name <- removed[[kk]]
[13:19:56.895]                   NAME <- NAMES[[kk]]
[13:19:56.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.895]                     next
[13:19:56.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.895]                 }
[13:19:56.895]                 if (length(args) > 0) 
[13:19:56.895]                   base::do.call(base::Sys.setenv, args = args)
[13:19:56.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:56.895]             }
[13:19:56.895]             else {
[13:19:56.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:56.895]             }
[13:19:56.895]             {
[13:19:56.895]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:56.895]                   0L) {
[13:19:56.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:56.895]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:56.895]                   base::options(opts)
[13:19:56.895]                 }
[13:19:56.895]                 {
[13:19:56.895]                   {
[13:19:56.895]                     NULL
[13:19:56.895]                     RNGkind("Mersenne-Twister")
[13:19:56.895]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:56.895]                       inherits = FALSE)
[13:19:56.895]                   }
[13:19:56.895]                   options(future.plan = NULL)
[13:19:56.895]                   if (is.na(NA_character_)) 
[13:19:56.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:56.895]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:56.895]                   {
[13:19:56.895]                     future <- SequentialFuture(..., envir = envir)
[13:19:56.895]                     if (!future$lazy) 
[13:19:56.895]                       future <- run(future)
[13:19:56.895]                     invisible(future)
[13:19:56.895]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:56.895]                 }
[13:19:56.895]             }
[13:19:56.895]         }
[13:19:56.895]     })
[13:19:56.895]     if (TRUE) {
[13:19:56.895]         base::sink(type = "output", split = FALSE)
[13:19:56.895]         if (TRUE) {
[13:19:56.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:56.895]         }
[13:19:56.895]         else {
[13:19:56.895]             ...future.result["stdout"] <- base::list(NULL)
[13:19:56.895]         }
[13:19:56.895]         base::close(...future.stdout)
[13:19:56.895]         ...future.stdout <- NULL
[13:19:56.895]     }
[13:19:56.895]     ...future.result$conditions <- ...future.conditions
[13:19:56.895]     ...future.result$finished <- base::Sys.time()
[13:19:56.895]     ...future.result
[13:19:56.895] }
[13:19:56.897] assign_globals() ...
[13:19:56.897] List of 5
[13:19:56.897]  $ future.call.arguments    : list()
[13:19:56.897]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.897]  $ ...future.FUN            :function (x, ...)  
[13:19:56.897]  $ ...future.elements_ii    :List of 2
[13:19:56.897]   ..$ : num [1:4] 1 3 1 7
[13:19:56.897]   ..$ : num [1:4] 2 4 6 8
[13:19:56.897]  $ ...future.seeds_ii       : NULL
[13:19:56.897]  $ ...future.globals.maxSize: num Inf
[13:19:56.897]  - attr(*, "resolved")= logi FALSE
[13:19:56.897]  - attr(*, "total_size")= num NA
[13:19:56.897]  - attr(*, "where")=List of 5
[13:19:56.897]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:56.897]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:56.897]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:56.897]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:56.897]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:56.897]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.897]  - attr(*, "already-done")= logi TRUE
[13:19:56.902] - copied ‘future.call.arguments’ to environment
[13:19:56.902] - copied ‘...future.FUN’ to environment
[13:19:56.902] - copied ‘...future.elements_ii’ to environment
[13:19:56.902] - copied ‘...future.seeds_ii’ to environment
[13:19:56.902] - copied ‘...future.globals.maxSize’ to environment
[13:19:56.902] assign_globals() ... done
[13:19:56.903] plan(): Setting new future strategy stack:
[13:19:56.903] List of future strategies:
[13:19:56.903] 1. sequential:
[13:19:56.903]    - args: function (..., envir = parent.frame())
[13:19:56.903]    - tweaked: FALSE
[13:19:56.903]    - call: NULL
[13:19:56.903] plan(): nbrOfWorkers() = 1
[13:19:56.904] plan(): Setting new future strategy stack:
[13:19:56.904] List of future strategies:
[13:19:56.904] 1. sequential:
[13:19:56.904]    - args: function (..., envir = parent.frame())
[13:19:56.904]    - tweaked: FALSE
[13:19:56.904]    - call: plan(strategy)
[13:19:56.905] plan(): nbrOfWorkers() = 1
[13:19:56.905] SequentialFuture started (and completed)
[13:19:56.905] - Launch lazy future ... done
[13:19:56.905] run() for ‘SequentialFuture’ ... done
[13:19:56.905] Created future:
[13:19:56.905] SequentialFuture:
[13:19:56.905] Label: ‘future_apply-1’
[13:19:56.905] Expression:
[13:19:56.905] {
[13:19:56.905]     do.call(function(...) {
[13:19:56.905]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.905]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:56.905]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.905]             on.exit(options(oopts), add = TRUE)
[13:19:56.905]         }
[13:19:56.905]         {
[13:19:56.905]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:56.905]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.905]                 ...future.FUN(...future.X_jj, ...)
[13:19:56.905]             })
[13:19:56.905]         }
[13:19:56.905]     }, args = future.call.arguments)
[13:19:56.905] }
[13:19:56.905] Lazy evaluation: FALSE
[13:19:56.905] Asynchronous evaluation: FALSE
[13:19:56.905] Local evaluation: TRUE
[13:19:56.905] Environment: R_GlobalEnv
[13:19:56.905] Capture standard output: TRUE
[13:19:56.905] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:56.905] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:56.905] Packages: 1 packages (‘stats’)
[13:19:56.905] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:56.905] Resolved: TRUE
[13:19:56.905] Value: 1.14 KiB of class ‘list’
[13:19:56.905] Early signaling: FALSE
[13:19:56.905] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:56.905] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.906] Chunk #1 of 1 ... DONE
[13:19:56.907] Launching 1 futures (chunks) ... DONE
[13:19:56.907] Resolving 1 futures (chunks) ...
[13:19:56.907] resolve() on list ...
[13:19:56.907]  recursive: 0
[13:19:56.907]  length: 1
[13:19:56.907] 
[13:19:56.907] resolved() for ‘SequentialFuture’ ...
[13:19:56.907] - state: ‘finished’
[13:19:56.907] - run: TRUE
[13:19:56.907] - result: ‘FutureResult’
[13:19:56.908] resolved() for ‘SequentialFuture’ ... done
[13:19:56.908] Future #1
[13:19:56.908] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:56.908] - nx: 1
[13:19:56.908] - relay: TRUE
[13:19:56.908] - stdout: TRUE
[13:19:56.908] - signal: TRUE
[13:19:56.908] - resignal: FALSE
[13:19:56.908] - force: TRUE
[13:19:56.908] - relayed: [n=1] FALSE
[13:19:56.908] - queued futures: [n=1] FALSE
[13:19:56.909]  - until=1
[13:19:56.909]  - relaying element #1
[13:19:56.910] - relayed: [n=1] TRUE
[13:19:56.911] - queued futures: [n=1] TRUE
[13:19:56.911] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:56.911]  length: 0 (resolved future 1)
[13:19:56.911] Relaying remaining futures
[13:19:56.911] signalConditionsASAP(NULL, pos=0) ...
[13:19:56.911] - nx: 1
[13:19:56.911] - relay: TRUE
[13:19:56.911] - stdout: TRUE
[13:19:56.911] - signal: TRUE
[13:19:56.911] - resignal: FALSE
[13:19:56.911] - force: TRUE
[13:19:56.911] - relayed: [n=1] TRUE
[13:19:56.912] - queued futures: [n=1] TRUE
 - flush all
[13:19:56.912] - relayed: [n=1] TRUE
[13:19:56.912] - queued futures: [n=1] TRUE
[13:19:56.912] signalConditionsASAP(NULL, pos=0) ... done
[13:19:56.912] resolve() on list ... DONE
[13:19:56.912]  - Number of value chunks collected: 1
[13:19:56.912] Resolving 1 futures (chunks) ... DONE
[13:19:56.912] Reducing values from 1 chunks ...
[13:19:56.912]  - Number of values collected after concatenation: 2
[13:19:56.913]  - Number of values expected: 2
[13:19:56.913] Reducing values from 1 chunks ... DONE
[13:19:56.913] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[13:19:56.914] getGlobalsAndPackagesXApply() ...
[13:19:56.914]  - future.globals: TRUE
[13:19:56.914] getGlobalsAndPackages() ...
[13:19:56.914] Searching for globals...
[13:19:56.915] - globals found: [1] ‘FUN’
[13:19:56.915] Searching for globals ... DONE
[13:19:56.915] Resolving globals: FALSE
[13:19:56.915] The total size of the 1 globals is 848 bytes (848 bytes)
[13:19:56.916] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:19:56.916] - globals: [1] ‘FUN’
[13:19:56.916] 
[13:19:56.916] getGlobalsAndPackages() ... DONE
[13:19:56.916]  - globals found/used: [n=1] ‘FUN’
[13:19:56.916]  - needed namespaces: [n=0] 
[13:19:56.916] Finding globals ... DONE
[13:19:56.916]  - use_args: TRUE
[13:19:56.917]  - Getting '...' globals ...
[13:19:56.917] resolve() on list ...
[13:19:56.917]  recursive: 0
[13:19:56.917]  length: 1
[13:19:56.917]  elements: ‘...’
[13:19:56.917]  length: 0 (resolved future 1)
[13:19:56.917] resolve() on list ... DONE
[13:19:56.917]    - '...' content: [n=0] 
[13:19:56.918] List of 1
[13:19:56.918]  $ ...: list()
[13:19:56.918]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.918]  - attr(*, "where")=List of 1
[13:19:56.918]   ..$ ...:<environment: 0x555921152180> 
[13:19:56.918]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.918]  - attr(*, "resolved")= logi TRUE
[13:19:56.918]  - attr(*, "total_size")= num NA
[13:19:56.920]  - Getting '...' globals ... DONE
[13:19:56.920] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:56.920] List of 2
[13:19:56.920]  $ ...future.FUN:function (x)  
[13:19:56.920]  $ ...          : list()
[13:19:56.920]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.920]  - attr(*, "where")=List of 2
[13:19:56.920]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:56.920]   ..$ ...          :<environment: 0x555921152180> 
[13:19:56.920]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.920]  - attr(*, "resolved")= logi FALSE
[13:19:56.920]  - attr(*, "total_size")= num 848
[13:19:56.923] Packages to be attached in all futures: [n=0] 
[13:19:56.923] getGlobalsAndPackagesXApply() ... DONE
[13:19:56.923] future_lapply() ...
[13:19:56.924] Number of chunks: 1
[13:19:56.924] getGlobalsAndPackagesXApply() ...
[13:19:56.924]  - future.globals: <name-value list> with names ‘list()’
[13:19:56.924]  - use_args: TRUE
[13:19:56.924] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:56.925] List of 2
[13:19:56.925]  $ ...          : list()
[13:19:56.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.925]  $ ...future.FUN:function (x)  
[13:19:56.925]  - attr(*, "where")=List of 2
[13:19:56.925]   ..$ ...          :<environment: 0x555921152180> 
[13:19:56.925]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:56.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.925]  - attr(*, "resolved")= logi FALSE
[13:19:56.925]  - attr(*, "total_size")= num NA
[13:19:56.928] Packages to be attached in all futures: [n=0] 
[13:19:56.928] getGlobalsAndPackagesXApply() ... DONE
[13:19:56.928] Number of futures (= number of chunks): 1
[13:19:56.928] Launching 1 futures (chunks) ...
[13:19:56.928] Chunk #1 of 1 ...
[13:19:56.929]  - seeds: <none>
[13:19:56.929]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.929] getGlobalsAndPackages() ...
[13:19:56.929] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.929] Resolving globals: FALSE
[13:19:56.929] Tweak future expression to call with '...' arguments ...
[13:19:56.929] {
[13:19:56.929]     do.call(function(...) {
[13:19:56.929]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.929]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:56.929]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.929]             on.exit(options(oopts), add = TRUE)
[13:19:56.929]         }
[13:19:56.929]         {
[13:19:56.929]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:56.929]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.929]                 ...future.FUN(...future.X_jj, ...)
[13:19:56.929]             })
[13:19:56.929]         }
[13:19:56.929]     }, args = future.call.arguments)
[13:19:56.929] }
[13:19:56.930] Tweak future expression to call with '...' arguments ... DONE
[13:19:56.930] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.930] 
[13:19:56.930] getGlobalsAndPackages() ... DONE
[13:19:56.930] run() for ‘Future’ ...
[13:19:56.931] - state: ‘created’
[13:19:56.931] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:56.931] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.931] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:56.931]   - Field: ‘label’
[13:19:56.931]   - Field: ‘local’
[13:19:56.931]   - Field: ‘owner’
[13:19:56.932]   - Field: ‘envir’
[13:19:56.932]   - Field: ‘packages’
[13:19:56.932]   - Field: ‘gc’
[13:19:56.932]   - Field: ‘conditions’
[13:19:56.932]   - Field: ‘expr’
[13:19:56.932]   - Field: ‘uuid’
[13:19:56.932]   - Field: ‘seed’
[13:19:56.932]   - Field: ‘version’
[13:19:56.934]   - Field: ‘result’
[13:19:56.934]   - Field: ‘asynchronous’
[13:19:56.934]   - Field: ‘calls’
[13:19:56.934]   - Field: ‘globals’
[13:19:56.934]   - Field: ‘stdout’
[13:19:56.935]   - Field: ‘earlySignal’
[13:19:56.935]   - Field: ‘lazy’
[13:19:56.935]   - Field: ‘state’
[13:19:56.935] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:56.935] - Launch lazy future ...
[13:19:56.935] Packages needed by the future expression (n = 0): <none>
[13:19:56.935] Packages needed by future strategies (n = 0): <none>
[13:19:56.936] {
[13:19:56.936]     {
[13:19:56.936]         {
[13:19:56.936]             ...future.startTime <- base::Sys.time()
[13:19:56.936]             {
[13:19:56.936]                 {
[13:19:56.936]                   {
[13:19:56.936]                     base::local({
[13:19:56.936]                       has_future <- base::requireNamespace("future", 
[13:19:56.936]                         quietly = TRUE)
[13:19:56.936]                       if (has_future) {
[13:19:56.936]                         ns <- base::getNamespace("future")
[13:19:56.936]                         version <- ns[[".package"]][["version"]]
[13:19:56.936]                         if (is.null(version)) 
[13:19:56.936]                           version <- utils::packageVersion("future")
[13:19:56.936]                       }
[13:19:56.936]                       else {
[13:19:56.936]                         version <- NULL
[13:19:56.936]                       }
[13:19:56.936]                       if (!has_future || version < "1.8.0") {
[13:19:56.936]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:56.936]                           "", base::R.version$version.string), 
[13:19:56.936]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:56.936]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:56.936]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:56.936]                             "release", "version")], collapse = " "), 
[13:19:56.936]                           hostname = base::Sys.info()[["nodename"]])
[13:19:56.936]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:56.936]                           info)
[13:19:56.936]                         info <- base::paste(info, collapse = "; ")
[13:19:56.936]                         if (!has_future) {
[13:19:56.936]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:56.936]                             info)
[13:19:56.936]                         }
[13:19:56.936]                         else {
[13:19:56.936]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:56.936]                             info, version)
[13:19:56.936]                         }
[13:19:56.936]                         base::stop(msg)
[13:19:56.936]                       }
[13:19:56.936]                     })
[13:19:56.936]                   }
[13:19:56.936]                   options(future.plan = NULL)
[13:19:56.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:56.936]                 }
[13:19:56.936]                 ...future.workdir <- getwd()
[13:19:56.936]             }
[13:19:56.936]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:56.936]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:56.936]         }
[13:19:56.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:56.936]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:56.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:56.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:56.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:56.936]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:56.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:56.936]             base::names(...future.oldOptions))
[13:19:56.936]     }
[13:19:56.936]     if (FALSE) {
[13:19:56.936]     }
[13:19:56.936]     else {
[13:19:56.936]         if (TRUE) {
[13:19:56.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:56.936]                 open = "w")
[13:19:56.936]         }
[13:19:56.936]         else {
[13:19:56.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:56.936]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:56.936]         }
[13:19:56.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:56.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:56.936]             base::sink(type = "output", split = FALSE)
[13:19:56.936]             base::close(...future.stdout)
[13:19:56.936]         }, add = TRUE)
[13:19:56.936]     }
[13:19:56.936]     ...future.frame <- base::sys.nframe()
[13:19:56.936]     ...future.conditions <- base::list()
[13:19:56.936]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:56.936]     if (FALSE) {
[13:19:56.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:56.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:56.936]     }
[13:19:56.936]     ...future.result <- base::tryCatch({
[13:19:56.936]         base::withCallingHandlers({
[13:19:56.936]             ...future.value <- base::withVisible(base::local({
[13:19:56.936]                 do.call(function(...) {
[13:19:56.936]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.936]                   if (!identical(...future.globals.maxSize.org, 
[13:19:56.936]                     ...future.globals.maxSize)) {
[13:19:56.936]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.936]                     on.exit(options(oopts), add = TRUE)
[13:19:56.936]                   }
[13:19:56.936]                   {
[13:19:56.936]                     lapply(seq_along(...future.elements_ii), 
[13:19:56.936]                       FUN = function(jj) {
[13:19:56.936]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.936]                         ...future.FUN(...future.X_jj, ...)
[13:19:56.936]                       })
[13:19:56.936]                   }
[13:19:56.936]                 }, args = future.call.arguments)
[13:19:56.936]             }))
[13:19:56.936]             future::FutureResult(value = ...future.value$value, 
[13:19:56.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.936]                   ...future.rng), globalenv = if (FALSE) 
[13:19:56.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:56.936]                     ...future.globalenv.names))
[13:19:56.936]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:56.936]         }, condition = base::local({
[13:19:56.936]             c <- base::c
[13:19:56.936]             inherits <- base::inherits
[13:19:56.936]             invokeRestart <- base::invokeRestart
[13:19:56.936]             length <- base::length
[13:19:56.936]             list <- base::list
[13:19:56.936]             seq.int <- base::seq.int
[13:19:56.936]             signalCondition <- base::signalCondition
[13:19:56.936]             sys.calls <- base::sys.calls
[13:19:56.936]             `[[` <- base::`[[`
[13:19:56.936]             `+` <- base::`+`
[13:19:56.936]             `<<-` <- base::`<<-`
[13:19:56.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:56.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:56.936]                   3L)]
[13:19:56.936]             }
[13:19:56.936]             function(cond) {
[13:19:56.936]                 is_error <- inherits(cond, "error")
[13:19:56.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:56.936]                   NULL)
[13:19:56.936]                 if (is_error) {
[13:19:56.936]                   sessionInformation <- function() {
[13:19:56.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:56.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:56.936]                       search = base::search(), system = base::Sys.info())
[13:19:56.936]                   }
[13:19:56.936]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:56.936]                     cond$call), session = sessionInformation(), 
[13:19:56.936]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:56.936]                   signalCondition(cond)
[13:19:56.936]                 }
[13:19:56.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:56.936]                 "immediateCondition"))) {
[13:19:56.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:56.936]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:56.936]                   if (TRUE && !signal) {
[13:19:56.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.936]                     {
[13:19:56.936]                       inherits <- base::inherits
[13:19:56.936]                       invokeRestart <- base::invokeRestart
[13:19:56.936]                       is.null <- base::is.null
[13:19:56.936]                       muffled <- FALSE
[13:19:56.936]                       if (inherits(cond, "message")) {
[13:19:56.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.936]                         if (muffled) 
[13:19:56.936]                           invokeRestart("muffleMessage")
[13:19:56.936]                       }
[13:19:56.936]                       else if (inherits(cond, "warning")) {
[13:19:56.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.936]                         if (muffled) 
[13:19:56.936]                           invokeRestart("muffleWarning")
[13:19:56.936]                       }
[13:19:56.936]                       else if (inherits(cond, "condition")) {
[13:19:56.936]                         if (!is.null(pattern)) {
[13:19:56.936]                           computeRestarts <- base::computeRestarts
[13:19:56.936]                           grepl <- base::grepl
[13:19:56.936]                           restarts <- computeRestarts(cond)
[13:19:56.936]                           for (restart in restarts) {
[13:19:56.936]                             name <- restart$name
[13:19:56.936]                             if (is.null(name)) 
[13:19:56.936]                               next
[13:19:56.936]                             if (!grepl(pattern, name)) 
[13:19:56.936]                               next
[13:19:56.936]                             invokeRestart(restart)
[13:19:56.936]                             muffled <- TRUE
[13:19:56.936]                             break
[13:19:56.936]                           }
[13:19:56.936]                         }
[13:19:56.936]                       }
[13:19:56.936]                       invisible(muffled)
[13:19:56.936]                     }
[13:19:56.936]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.936]                   }
[13:19:56.936]                 }
[13:19:56.936]                 else {
[13:19:56.936]                   if (TRUE) {
[13:19:56.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.936]                     {
[13:19:56.936]                       inherits <- base::inherits
[13:19:56.936]                       invokeRestart <- base::invokeRestart
[13:19:56.936]                       is.null <- base::is.null
[13:19:56.936]                       muffled <- FALSE
[13:19:56.936]                       if (inherits(cond, "message")) {
[13:19:56.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.936]                         if (muffled) 
[13:19:56.936]                           invokeRestart("muffleMessage")
[13:19:56.936]                       }
[13:19:56.936]                       else if (inherits(cond, "warning")) {
[13:19:56.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.936]                         if (muffled) 
[13:19:56.936]                           invokeRestart("muffleWarning")
[13:19:56.936]                       }
[13:19:56.936]                       else if (inherits(cond, "condition")) {
[13:19:56.936]                         if (!is.null(pattern)) {
[13:19:56.936]                           computeRestarts <- base::computeRestarts
[13:19:56.936]                           grepl <- base::grepl
[13:19:56.936]                           restarts <- computeRestarts(cond)
[13:19:56.936]                           for (restart in restarts) {
[13:19:56.936]                             name <- restart$name
[13:19:56.936]                             if (is.null(name)) 
[13:19:56.936]                               next
[13:19:56.936]                             if (!grepl(pattern, name)) 
[13:19:56.936]                               next
[13:19:56.936]                             invokeRestart(restart)
[13:19:56.936]                             muffled <- TRUE
[13:19:56.936]                             break
[13:19:56.936]                           }
[13:19:56.936]                         }
[13:19:56.936]                       }
[13:19:56.936]                       invisible(muffled)
[13:19:56.936]                     }
[13:19:56.936]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.936]                   }
[13:19:56.936]                 }
[13:19:56.936]             }
[13:19:56.936]         }))
[13:19:56.936]     }, error = function(ex) {
[13:19:56.936]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:56.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.936]                 ...future.rng), started = ...future.startTime, 
[13:19:56.936]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:56.936]             version = "1.8"), class = "FutureResult")
[13:19:56.936]     }, finally = {
[13:19:56.936]         if (!identical(...future.workdir, getwd())) 
[13:19:56.936]             setwd(...future.workdir)
[13:19:56.936]         {
[13:19:56.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:56.936]                 ...future.oldOptions$nwarnings <- NULL
[13:19:56.936]             }
[13:19:56.936]             base::options(...future.oldOptions)
[13:19:56.936]             if (.Platform$OS.type == "windows") {
[13:19:56.936]                 old_names <- names(...future.oldEnvVars)
[13:19:56.936]                 envs <- base::Sys.getenv()
[13:19:56.936]                 names <- names(envs)
[13:19:56.936]                 common <- intersect(names, old_names)
[13:19:56.936]                 added <- setdiff(names, old_names)
[13:19:56.936]                 removed <- setdiff(old_names, names)
[13:19:56.936]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:56.936]                   envs[common]]
[13:19:56.936]                 NAMES <- toupper(changed)
[13:19:56.936]                 args <- list()
[13:19:56.936]                 for (kk in seq_along(NAMES)) {
[13:19:56.936]                   name <- changed[[kk]]
[13:19:56.936]                   NAME <- NAMES[[kk]]
[13:19:56.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.936]                     next
[13:19:56.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.936]                 }
[13:19:56.936]                 NAMES <- toupper(added)
[13:19:56.936]                 for (kk in seq_along(NAMES)) {
[13:19:56.936]                   name <- added[[kk]]
[13:19:56.936]                   NAME <- NAMES[[kk]]
[13:19:56.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.936]                     next
[13:19:56.936]                   args[[name]] <- ""
[13:19:56.936]                 }
[13:19:56.936]                 NAMES <- toupper(removed)
[13:19:56.936]                 for (kk in seq_along(NAMES)) {
[13:19:56.936]                   name <- removed[[kk]]
[13:19:56.936]                   NAME <- NAMES[[kk]]
[13:19:56.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.936]                     next
[13:19:56.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.936]                 }
[13:19:56.936]                 if (length(args) > 0) 
[13:19:56.936]                   base::do.call(base::Sys.setenv, args = args)
[13:19:56.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:56.936]             }
[13:19:56.936]             else {
[13:19:56.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:56.936]             }
[13:19:56.936]             {
[13:19:56.936]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:56.936]                   0L) {
[13:19:56.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:56.936]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:56.936]                   base::options(opts)
[13:19:56.936]                 }
[13:19:56.936]                 {
[13:19:56.936]                   {
[13:19:56.936]                     NULL
[13:19:56.936]                     RNGkind("Mersenne-Twister")
[13:19:56.936]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:56.936]                       inherits = FALSE)
[13:19:56.936]                   }
[13:19:56.936]                   options(future.plan = NULL)
[13:19:56.936]                   if (is.na(NA_character_)) 
[13:19:56.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:56.936]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:56.936]                   {
[13:19:56.936]                     future <- SequentialFuture(..., envir = envir)
[13:19:56.936]                     if (!future$lazy) 
[13:19:56.936]                       future <- run(future)
[13:19:56.936]                     invisible(future)
[13:19:56.936]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:56.936]                 }
[13:19:56.936]             }
[13:19:56.936]         }
[13:19:56.936]     })
[13:19:56.936]     if (TRUE) {
[13:19:56.936]         base::sink(type = "output", split = FALSE)
[13:19:56.936]         if (TRUE) {
[13:19:56.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:56.936]         }
[13:19:56.936]         else {
[13:19:56.936]             ...future.result["stdout"] <- base::list(NULL)
[13:19:56.936]         }
[13:19:56.936]         base::close(...future.stdout)
[13:19:56.936]         ...future.stdout <- NULL
[13:19:56.936]     }
[13:19:56.936]     ...future.result$conditions <- ...future.conditions
[13:19:56.936]     ...future.result$finished <- base::Sys.time()
[13:19:56.936]     ...future.result
[13:19:56.936] }
[13:19:56.938] assign_globals() ...
[13:19:56.938] List of 5
[13:19:56.938]  $ future.call.arguments    : list()
[13:19:56.938]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.938]  $ ...future.FUN            :function (x)  
[13:19:56.938]  $ ...future.elements_ii    :List of 2
[13:19:56.938]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:19:56.938]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:19:56.938]  $ ...future.seeds_ii       : NULL
[13:19:56.938]  $ ...future.globals.maxSize: num Inf
[13:19:56.938]  - attr(*, "resolved")= logi FALSE
[13:19:56.938]  - attr(*, "total_size")= num NA
[13:19:56.938]  - attr(*, "where")=List of 5
[13:19:56.938]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:56.938]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:56.938]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:56.938]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:56.938]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:56.938]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.938]  - attr(*, "already-done")= logi TRUE
[13:19:56.943] - copied ‘future.call.arguments’ to environment
[13:19:56.943] - copied ‘...future.FUN’ to environment
[13:19:56.943] - copied ‘...future.elements_ii’ to environment
[13:19:56.943] - copied ‘...future.seeds_ii’ to environment
[13:19:56.943] - copied ‘...future.globals.maxSize’ to environment
[13:19:56.943] assign_globals() ... done
[13:19:56.944] plan(): Setting new future strategy stack:
[13:19:56.944] List of future strategies:
[13:19:56.944] 1. sequential:
[13:19:56.944]    - args: function (..., envir = parent.frame())
[13:19:56.944]    - tweaked: FALSE
[13:19:56.944]    - call: NULL
[13:19:56.944] plan(): nbrOfWorkers() = 1
[13:19:56.945] plan(): Setting new future strategy stack:
[13:19:56.945] List of future strategies:
[13:19:56.945] 1. sequential:
[13:19:56.945]    - args: function (..., envir = parent.frame())
[13:19:56.945]    - tweaked: FALSE
[13:19:56.945]    - call: plan(strategy)
[13:19:56.945] plan(): nbrOfWorkers() = 1
[13:19:56.945] SequentialFuture started (and completed)
[13:19:56.946] - Launch lazy future ... done
[13:19:56.946] run() for ‘SequentialFuture’ ... done
[13:19:56.946] Created future:
[13:19:56.946] SequentialFuture:
[13:19:56.946] Label: ‘future_apply-1’
[13:19:56.946] Expression:
[13:19:56.946] {
[13:19:56.946]     do.call(function(...) {
[13:19:56.946]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.946]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:56.946]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.946]             on.exit(options(oopts), add = TRUE)
[13:19:56.946]         }
[13:19:56.946]         {
[13:19:56.946]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:56.946]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.946]                 ...future.FUN(...future.X_jj, ...)
[13:19:56.946]             })
[13:19:56.946]         }
[13:19:56.946]     }, args = future.call.arguments)
[13:19:56.946] }
[13:19:56.946] Lazy evaluation: FALSE
[13:19:56.946] Asynchronous evaluation: FALSE
[13:19:56.946] Local evaluation: TRUE
[13:19:56.946] Environment: R_GlobalEnv
[13:19:56.946] Capture standard output: TRUE
[13:19:56.946] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:56.946] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:56.946] Packages: <none>
[13:19:56.946] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:56.946] Resolved: TRUE
[13:19:56.946] Value: 224 bytes of class ‘list’
[13:19:56.946] Early signaling: FALSE
[13:19:56.946] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:56.946] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.947] Chunk #1 of 1 ... DONE
[13:19:56.947] Launching 1 futures (chunks) ... DONE
[13:19:56.947] Resolving 1 futures (chunks) ...
[13:19:56.947] resolve() on list ...
[13:19:56.947]  recursive: 0
[13:19:56.947]  length: 1
[13:19:56.948] 
[13:19:56.948] resolved() for ‘SequentialFuture’ ...
[13:19:56.948] - state: ‘finished’
[13:19:56.948] - run: TRUE
[13:19:56.948] - result: ‘FutureResult’
[13:19:56.948] resolved() for ‘SequentialFuture’ ... done
[13:19:56.948] Future #1
[13:19:56.948] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:56.948] - nx: 1
[13:19:56.948] - relay: TRUE
[13:19:56.949] - stdout: TRUE
[13:19:56.949] - signal: TRUE
[13:19:56.949] - resignal: FALSE
[13:19:56.949] - force: TRUE
[13:19:56.949] - relayed: [n=1] FALSE
[13:19:56.949] - queued futures: [n=1] FALSE
[13:19:56.949]  - until=1
[13:19:56.949]  - relaying element #1
[13:19:56.949] - relayed: [n=1] TRUE
[13:19:56.949] - queued futures: [n=1] TRUE
[13:19:56.950] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:56.950]  length: 0 (resolved future 1)
[13:19:56.950] Relaying remaining futures
[13:19:56.950] signalConditionsASAP(NULL, pos=0) ...
[13:19:56.950] - nx: 1
[13:19:56.950] - relay: TRUE
[13:19:56.950] - stdout: TRUE
[13:19:56.950] - signal: TRUE
[13:19:56.950] - resignal: FALSE
[13:19:56.950] - force: TRUE
[13:19:56.950] - relayed: [n=1] TRUE
[13:19:56.950] - queued futures: [n=1] TRUE
 - flush all
[13:19:56.951] - relayed: [n=1] TRUE
[13:19:56.951] - queued futures: [n=1] TRUE
[13:19:56.951] signalConditionsASAP(NULL, pos=0) ... done
[13:19:56.951] resolve() on list ... DONE
[13:19:56.951]  - Number of value chunks collected: 1
[13:19:56.951] Resolving 1 futures (chunks) ... DONE
[13:19:56.951] Reducing values from 1 chunks ...
[13:19:56.951]  - Number of values collected after concatenation: 2
[13:19:56.951]  - Number of values expected: 2
[13:19:56.951] Reducing values from 1 chunks ... DONE
[13:19:56.952] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[13:19:56.952] getGlobalsAndPackagesXApply() ...
[13:19:56.952]  - future.globals: TRUE
[13:19:56.952] getGlobalsAndPackages() ...
[13:19:56.952] Searching for globals...
[13:19:56.953] - globals found: [1] ‘FUN’
[13:19:56.953] Searching for globals ... DONE
[13:19:56.953] Resolving globals: FALSE
[13:19:56.954] The total size of the 1 globals is 848 bytes (848 bytes)
[13:19:56.954] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:19:56.954] - globals: [1] ‘FUN’
[13:19:56.954] 
[13:19:56.954] getGlobalsAndPackages() ... DONE
[13:19:56.955]  - globals found/used: [n=1] ‘FUN’
[13:19:56.955]  - needed namespaces: [n=0] 
[13:19:56.955] Finding globals ... DONE
[13:19:56.955]  - use_args: TRUE
[13:19:56.955]  - Getting '...' globals ...
[13:19:56.955] resolve() on list ...
[13:19:56.955]  recursive: 0
[13:19:56.955]  length: 1
[13:19:56.955]  elements: ‘...’
[13:19:56.956]  length: 0 (resolved future 1)
[13:19:56.956] resolve() on list ... DONE
[13:19:56.956]    - '...' content: [n=0] 
[13:19:56.956] List of 1
[13:19:56.956]  $ ...: list()
[13:19:56.956]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.956]  - attr(*, "where")=List of 1
[13:19:56.956]   ..$ ...:<environment: 0x555922b4e030> 
[13:19:56.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.956]  - attr(*, "resolved")= logi TRUE
[13:19:56.956]  - attr(*, "total_size")= num NA
[13:19:56.960]  - Getting '...' globals ... DONE
[13:19:56.961] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:56.961] List of 2
[13:19:56.961]  $ ...future.FUN:function (x)  
[13:19:56.961]  $ ...          : list()
[13:19:56.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.961]  - attr(*, "where")=List of 2
[13:19:56.961]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:56.961]   ..$ ...          :<environment: 0x555922b4e030> 
[13:19:56.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.961]  - attr(*, "resolved")= logi FALSE
[13:19:56.961]  - attr(*, "total_size")= num 848
[13:19:56.963] Packages to be attached in all futures: [n=0] 
[13:19:56.964] getGlobalsAndPackagesXApply() ... DONE
[13:19:56.964] future_lapply() ...
[13:19:56.964] Number of chunks: 1
[13:19:56.964] getGlobalsAndPackagesXApply() ...
[13:19:56.965]  - future.globals: <name-value list> with names ‘list()’
[13:19:56.965]  - use_args: TRUE
[13:19:56.965] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:56.965] List of 2
[13:19:56.965]  $ ...          : list()
[13:19:56.965]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.965]  $ ...future.FUN:function (x)  
[13:19:56.965]  - attr(*, "where")=List of 2
[13:19:56.965]   ..$ ...          :<environment: 0x555922b4e030> 
[13:19:56.965]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:56.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.965]  - attr(*, "resolved")= logi FALSE
[13:19:56.965]  - attr(*, "total_size")= num NA
[13:19:56.968] Packages to be attached in all futures: [n=0] 
[13:19:56.968] getGlobalsAndPackagesXApply() ... DONE
[13:19:56.969] Number of futures (= number of chunks): 1
[13:19:56.969] Launching 1 futures (chunks) ...
[13:19:56.969] Chunk #1 of 1 ...
[13:19:56.969]  - seeds: <none>
[13:19:56.969]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.969] getGlobalsAndPackages() ...
[13:19:56.969] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.969] Resolving globals: FALSE
[13:19:56.969] Tweak future expression to call with '...' arguments ...
[13:19:56.970] {
[13:19:56.970]     do.call(function(...) {
[13:19:56.970]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.970]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:56.970]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.970]             on.exit(options(oopts), add = TRUE)
[13:19:56.970]         }
[13:19:56.970]         {
[13:19:56.970]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:56.970]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.970]                 ...future.FUN(...future.X_jj, ...)
[13:19:56.970]             })
[13:19:56.970]         }
[13:19:56.970]     }, args = future.call.arguments)
[13:19:56.970] }
[13:19:56.970] Tweak future expression to call with '...' arguments ... DONE
[13:19:56.970] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:56.970] 
[13:19:56.970] getGlobalsAndPackages() ... DONE
[13:19:56.971] run() for ‘Future’ ...
[13:19:56.971] - state: ‘created’
[13:19:56.971] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:56.971] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:56.972]   - Field: ‘label’
[13:19:56.972]   - Field: ‘local’
[13:19:56.972]   - Field: ‘owner’
[13:19:56.972]   - Field: ‘envir’
[13:19:56.972]   - Field: ‘packages’
[13:19:56.972]   - Field: ‘gc’
[13:19:56.972]   - Field: ‘conditions’
[13:19:56.972]   - Field: ‘expr’
[13:19:56.972]   - Field: ‘uuid’
[13:19:56.972]   - Field: ‘seed’
[13:19:56.973]   - Field: ‘version’
[13:19:56.973]   - Field: ‘result’
[13:19:56.973]   - Field: ‘asynchronous’
[13:19:56.973]   - Field: ‘calls’
[13:19:56.973]   - Field: ‘globals’
[13:19:56.973]   - Field: ‘stdout’
[13:19:56.973]   - Field: ‘earlySignal’
[13:19:56.973]   - Field: ‘lazy’
[13:19:56.973]   - Field: ‘state’
[13:19:56.973] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:56.973] - Launch lazy future ...
[13:19:56.974] Packages needed by the future expression (n = 0): <none>
[13:19:56.974] Packages needed by future strategies (n = 0): <none>
[13:19:56.974] {
[13:19:56.974]     {
[13:19:56.974]         {
[13:19:56.974]             ...future.startTime <- base::Sys.time()
[13:19:56.974]             {
[13:19:56.974]                 {
[13:19:56.974]                   {
[13:19:56.974]                     base::local({
[13:19:56.974]                       has_future <- base::requireNamespace("future", 
[13:19:56.974]                         quietly = TRUE)
[13:19:56.974]                       if (has_future) {
[13:19:56.974]                         ns <- base::getNamespace("future")
[13:19:56.974]                         version <- ns[[".package"]][["version"]]
[13:19:56.974]                         if (is.null(version)) 
[13:19:56.974]                           version <- utils::packageVersion("future")
[13:19:56.974]                       }
[13:19:56.974]                       else {
[13:19:56.974]                         version <- NULL
[13:19:56.974]                       }
[13:19:56.974]                       if (!has_future || version < "1.8.0") {
[13:19:56.974]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:56.974]                           "", base::R.version$version.string), 
[13:19:56.974]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:56.974]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:56.974]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:56.974]                             "release", "version")], collapse = " "), 
[13:19:56.974]                           hostname = base::Sys.info()[["nodename"]])
[13:19:56.974]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:56.974]                           info)
[13:19:56.974]                         info <- base::paste(info, collapse = "; ")
[13:19:56.974]                         if (!has_future) {
[13:19:56.974]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:56.974]                             info)
[13:19:56.974]                         }
[13:19:56.974]                         else {
[13:19:56.974]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:56.974]                             info, version)
[13:19:56.974]                         }
[13:19:56.974]                         base::stop(msg)
[13:19:56.974]                       }
[13:19:56.974]                     })
[13:19:56.974]                   }
[13:19:56.974]                   options(future.plan = NULL)
[13:19:56.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:56.974]                 }
[13:19:56.974]                 ...future.workdir <- getwd()
[13:19:56.974]             }
[13:19:56.974]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:56.974]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:56.974]         }
[13:19:56.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:56.974]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:56.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:56.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:56.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:56.974]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:56.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:56.974]             base::names(...future.oldOptions))
[13:19:56.974]     }
[13:19:56.974]     if (FALSE) {
[13:19:56.974]     }
[13:19:56.974]     else {
[13:19:56.974]         if (TRUE) {
[13:19:56.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:56.974]                 open = "w")
[13:19:56.974]         }
[13:19:56.974]         else {
[13:19:56.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:56.974]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:56.974]         }
[13:19:56.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:56.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:56.974]             base::sink(type = "output", split = FALSE)
[13:19:56.974]             base::close(...future.stdout)
[13:19:56.974]         }, add = TRUE)
[13:19:56.974]     }
[13:19:56.974]     ...future.frame <- base::sys.nframe()
[13:19:56.974]     ...future.conditions <- base::list()
[13:19:56.974]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:56.974]     if (FALSE) {
[13:19:56.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:56.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:56.974]     }
[13:19:56.974]     ...future.result <- base::tryCatch({
[13:19:56.974]         base::withCallingHandlers({
[13:19:56.974]             ...future.value <- base::withVisible(base::local({
[13:19:56.974]                 do.call(function(...) {
[13:19:56.974]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.974]                   if (!identical(...future.globals.maxSize.org, 
[13:19:56.974]                     ...future.globals.maxSize)) {
[13:19:56.974]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.974]                     on.exit(options(oopts), add = TRUE)
[13:19:56.974]                   }
[13:19:56.974]                   {
[13:19:56.974]                     lapply(seq_along(...future.elements_ii), 
[13:19:56.974]                       FUN = function(jj) {
[13:19:56.974]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.974]                         ...future.FUN(...future.X_jj, ...)
[13:19:56.974]                       })
[13:19:56.974]                   }
[13:19:56.974]                 }, args = future.call.arguments)
[13:19:56.974]             }))
[13:19:56.974]             future::FutureResult(value = ...future.value$value, 
[13:19:56.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.974]                   ...future.rng), globalenv = if (FALSE) 
[13:19:56.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:56.974]                     ...future.globalenv.names))
[13:19:56.974]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:56.974]         }, condition = base::local({
[13:19:56.974]             c <- base::c
[13:19:56.974]             inherits <- base::inherits
[13:19:56.974]             invokeRestart <- base::invokeRestart
[13:19:56.974]             length <- base::length
[13:19:56.974]             list <- base::list
[13:19:56.974]             seq.int <- base::seq.int
[13:19:56.974]             signalCondition <- base::signalCondition
[13:19:56.974]             sys.calls <- base::sys.calls
[13:19:56.974]             `[[` <- base::`[[`
[13:19:56.974]             `+` <- base::`+`
[13:19:56.974]             `<<-` <- base::`<<-`
[13:19:56.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:56.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:56.974]                   3L)]
[13:19:56.974]             }
[13:19:56.974]             function(cond) {
[13:19:56.974]                 is_error <- inherits(cond, "error")
[13:19:56.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:56.974]                   NULL)
[13:19:56.974]                 if (is_error) {
[13:19:56.974]                   sessionInformation <- function() {
[13:19:56.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:56.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:56.974]                       search = base::search(), system = base::Sys.info())
[13:19:56.974]                   }
[13:19:56.974]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:56.974]                     cond$call), session = sessionInformation(), 
[13:19:56.974]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:56.974]                   signalCondition(cond)
[13:19:56.974]                 }
[13:19:56.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:56.974]                 "immediateCondition"))) {
[13:19:56.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:56.974]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:56.974]                   if (TRUE && !signal) {
[13:19:56.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.974]                     {
[13:19:56.974]                       inherits <- base::inherits
[13:19:56.974]                       invokeRestart <- base::invokeRestart
[13:19:56.974]                       is.null <- base::is.null
[13:19:56.974]                       muffled <- FALSE
[13:19:56.974]                       if (inherits(cond, "message")) {
[13:19:56.974]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.974]                         if (muffled) 
[13:19:56.974]                           invokeRestart("muffleMessage")
[13:19:56.974]                       }
[13:19:56.974]                       else if (inherits(cond, "warning")) {
[13:19:56.974]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.974]                         if (muffled) 
[13:19:56.974]                           invokeRestart("muffleWarning")
[13:19:56.974]                       }
[13:19:56.974]                       else if (inherits(cond, "condition")) {
[13:19:56.974]                         if (!is.null(pattern)) {
[13:19:56.974]                           computeRestarts <- base::computeRestarts
[13:19:56.974]                           grepl <- base::grepl
[13:19:56.974]                           restarts <- computeRestarts(cond)
[13:19:56.974]                           for (restart in restarts) {
[13:19:56.974]                             name <- restart$name
[13:19:56.974]                             if (is.null(name)) 
[13:19:56.974]                               next
[13:19:56.974]                             if (!grepl(pattern, name)) 
[13:19:56.974]                               next
[13:19:56.974]                             invokeRestart(restart)
[13:19:56.974]                             muffled <- TRUE
[13:19:56.974]                             break
[13:19:56.974]                           }
[13:19:56.974]                         }
[13:19:56.974]                       }
[13:19:56.974]                       invisible(muffled)
[13:19:56.974]                     }
[13:19:56.974]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.974]                   }
[13:19:56.974]                 }
[13:19:56.974]                 else {
[13:19:56.974]                   if (TRUE) {
[13:19:56.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.974]                     {
[13:19:56.974]                       inherits <- base::inherits
[13:19:56.974]                       invokeRestart <- base::invokeRestart
[13:19:56.974]                       is.null <- base::is.null
[13:19:56.974]                       muffled <- FALSE
[13:19:56.974]                       if (inherits(cond, "message")) {
[13:19:56.974]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.974]                         if (muffled) 
[13:19:56.974]                           invokeRestart("muffleMessage")
[13:19:56.974]                       }
[13:19:56.974]                       else if (inherits(cond, "warning")) {
[13:19:56.974]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.974]                         if (muffled) 
[13:19:56.974]                           invokeRestart("muffleWarning")
[13:19:56.974]                       }
[13:19:56.974]                       else if (inherits(cond, "condition")) {
[13:19:56.974]                         if (!is.null(pattern)) {
[13:19:56.974]                           computeRestarts <- base::computeRestarts
[13:19:56.974]                           grepl <- base::grepl
[13:19:56.974]                           restarts <- computeRestarts(cond)
[13:19:56.974]                           for (restart in restarts) {
[13:19:56.974]                             name <- restart$name
[13:19:56.974]                             if (is.null(name)) 
[13:19:56.974]                               next
[13:19:56.974]                             if (!grepl(pattern, name)) 
[13:19:56.974]                               next
[13:19:56.974]                             invokeRestart(restart)
[13:19:56.974]                             muffled <- TRUE
[13:19:56.974]                             break
[13:19:56.974]                           }
[13:19:56.974]                         }
[13:19:56.974]                       }
[13:19:56.974]                       invisible(muffled)
[13:19:56.974]                     }
[13:19:56.974]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.974]                   }
[13:19:56.974]                 }
[13:19:56.974]             }
[13:19:56.974]         }))
[13:19:56.974]     }, error = function(ex) {
[13:19:56.974]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:56.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.974]                 ...future.rng), started = ...future.startTime, 
[13:19:56.974]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:56.974]             version = "1.8"), class = "FutureResult")
[13:19:56.974]     }, finally = {
[13:19:56.974]         if (!identical(...future.workdir, getwd())) 
[13:19:56.974]             setwd(...future.workdir)
[13:19:56.974]         {
[13:19:56.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:56.974]                 ...future.oldOptions$nwarnings <- NULL
[13:19:56.974]             }
[13:19:56.974]             base::options(...future.oldOptions)
[13:19:56.974]             if (.Platform$OS.type == "windows") {
[13:19:56.974]                 old_names <- names(...future.oldEnvVars)
[13:19:56.974]                 envs <- base::Sys.getenv()
[13:19:56.974]                 names <- names(envs)
[13:19:56.974]                 common <- intersect(names, old_names)
[13:19:56.974]                 added <- setdiff(names, old_names)
[13:19:56.974]                 removed <- setdiff(old_names, names)
[13:19:56.974]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:56.974]                   envs[common]]
[13:19:56.974]                 NAMES <- toupper(changed)
[13:19:56.974]                 args <- list()
[13:19:56.974]                 for (kk in seq_along(NAMES)) {
[13:19:56.974]                   name <- changed[[kk]]
[13:19:56.974]                   NAME <- NAMES[[kk]]
[13:19:56.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.974]                     next
[13:19:56.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.974]                 }
[13:19:56.974]                 NAMES <- toupper(added)
[13:19:56.974]                 for (kk in seq_along(NAMES)) {
[13:19:56.974]                   name <- added[[kk]]
[13:19:56.974]                   NAME <- NAMES[[kk]]
[13:19:56.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.974]                     next
[13:19:56.974]                   args[[name]] <- ""
[13:19:56.974]                 }
[13:19:56.974]                 NAMES <- toupper(removed)
[13:19:56.974]                 for (kk in seq_along(NAMES)) {
[13:19:56.974]                   name <- removed[[kk]]
[13:19:56.974]                   NAME <- NAMES[[kk]]
[13:19:56.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.974]                     next
[13:19:56.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.974]                 }
[13:19:56.974]                 if (length(args) > 0) 
[13:19:56.974]                   base::do.call(base::Sys.setenv, args = args)
[13:19:56.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:56.974]             }
[13:19:56.974]             else {
[13:19:56.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:56.974]             }
[13:19:56.974]             {
[13:19:56.974]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:56.974]                   0L) {
[13:19:56.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:56.974]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:56.974]                   base::options(opts)
[13:19:56.974]                 }
[13:19:56.974]                 {
[13:19:56.974]                   {
[13:19:56.974]                     NULL
[13:19:56.974]                     RNGkind("Mersenne-Twister")
[13:19:56.974]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:56.974]                       inherits = FALSE)
[13:19:56.974]                   }
[13:19:56.974]                   options(future.plan = NULL)
[13:19:56.974]                   if (is.na(NA_character_)) 
[13:19:56.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:56.974]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:56.974]                   {
[13:19:56.974]                     future <- SequentialFuture(..., envir = envir)
[13:19:56.974]                     if (!future$lazy) 
[13:19:56.974]                       future <- run(future)
[13:19:56.974]                     invisible(future)
[13:19:56.974]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:56.974]                 }
[13:19:56.974]             }
[13:19:56.974]         }
[13:19:56.974]     })
[13:19:56.974]     if (TRUE) {
[13:19:56.974]         base::sink(type = "output", split = FALSE)
[13:19:56.974]         if (TRUE) {
[13:19:56.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:56.974]         }
[13:19:56.974]         else {
[13:19:56.974]             ...future.result["stdout"] <- base::list(NULL)
[13:19:56.974]         }
[13:19:56.974]         base::close(...future.stdout)
[13:19:56.974]         ...future.stdout <- NULL
[13:19:56.974]     }
[13:19:56.974]     ...future.result$conditions <- ...future.conditions
[13:19:56.974]     ...future.result$finished <- base::Sys.time()
[13:19:56.974]     ...future.result
[13:19:56.974] }
[13:19:56.976] assign_globals() ...
[13:19:56.976] List of 5
[13:19:56.976]  $ future.call.arguments    : list()
[13:19:56.976]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.976]  $ ...future.FUN            :function (x)  
[13:19:56.976]  $ ...future.elements_ii    :List of 6
[13:19:56.976]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:19:56.976]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:19:56.976]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:19:56.976]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:19:56.976]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:19:56.976]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:19:56.976]  $ ...future.seeds_ii       : NULL
[13:19:56.976]  $ ...future.globals.maxSize: num Inf
[13:19:56.976]  - attr(*, "resolved")= logi FALSE
[13:19:56.976]  - attr(*, "total_size")= num NA
[13:19:56.976]  - attr(*, "where")=List of 5
[13:19:56.976]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:56.976]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:56.976]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:56.976]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:56.976]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:56.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.976]  - attr(*, "already-done")= logi TRUE
[13:19:56.984] - copied ‘future.call.arguments’ to environment
[13:19:56.985] - copied ‘...future.FUN’ to environment
[13:19:56.985] - copied ‘...future.elements_ii’ to environment
[13:19:56.985] - copied ‘...future.seeds_ii’ to environment
[13:19:56.985] - copied ‘...future.globals.maxSize’ to environment
[13:19:56.985] assign_globals() ... done
[13:19:56.985] plan(): Setting new future strategy stack:
[13:19:56.985] List of future strategies:
[13:19:56.985] 1. sequential:
[13:19:56.985]    - args: function (..., envir = parent.frame())
[13:19:56.985]    - tweaked: FALSE
[13:19:56.985]    - call: NULL
[13:19:56.986] plan(): nbrOfWorkers() = 1
[13:19:56.986] plan(): Setting new future strategy stack:
[13:19:56.986] List of future strategies:
[13:19:56.986] 1. sequential:
[13:19:56.986]    - args: function (..., envir = parent.frame())
[13:19:56.986]    - tweaked: FALSE
[13:19:56.986]    - call: plan(strategy)
[13:19:56.987] plan(): nbrOfWorkers() = 1
[13:19:56.987] SequentialFuture started (and completed)
[13:19:56.987] - Launch lazy future ... done
[13:19:56.987] run() for ‘SequentialFuture’ ... done
[13:19:56.987] Created future:
[13:19:56.988] SequentialFuture:
[13:19:56.988] Label: ‘future_apply-1’
[13:19:56.988] Expression:
[13:19:56.988] {
[13:19:56.988]     do.call(function(...) {
[13:19:56.988]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:56.988]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:56.988]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:56.988]             on.exit(options(oopts), add = TRUE)
[13:19:56.988]         }
[13:19:56.988]         {
[13:19:56.988]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:56.988]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:56.988]                 ...future.FUN(...future.X_jj, ...)
[13:19:56.988]             })
[13:19:56.988]         }
[13:19:56.988]     }, args = future.call.arguments)
[13:19:56.988] }
[13:19:56.988] Lazy evaluation: FALSE
[13:19:56.988] Asynchronous evaluation: FALSE
[13:19:56.988] Local evaluation: TRUE
[13:19:56.988] Environment: R_GlobalEnv
[13:19:56.988] Capture standard output: TRUE
[13:19:56.988] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:56.988] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:56.988] Packages: <none>
[13:19:56.988] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:56.988] Resolved: TRUE
[13:19:56.988] Value: 672 bytes of class ‘list’
[13:19:56.988] Early signaling: FALSE
[13:19:56.988] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:56.988] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.989] Chunk #1 of 1 ... DONE
[13:19:56.989] Launching 1 futures (chunks) ... DONE
[13:19:56.989] Resolving 1 futures (chunks) ...
[13:19:56.989] resolve() on list ...
[13:19:56.989]  recursive: 0
[13:19:56.989]  length: 1
[13:19:56.989] 
[13:19:56.989] resolved() for ‘SequentialFuture’ ...
[13:19:56.989] - state: ‘finished’
[13:19:56.990] - run: TRUE
[13:19:56.990] - result: ‘FutureResult’
[13:19:56.990] resolved() for ‘SequentialFuture’ ... done
[13:19:56.990] Future #1
[13:19:56.990] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:56.990] - nx: 1
[13:19:56.990] - relay: TRUE
[13:19:56.990] - stdout: TRUE
[13:19:56.990] - signal: TRUE
[13:19:56.990] - resignal: FALSE
[13:19:56.991] - force: TRUE
[13:19:56.991] - relayed: [n=1] FALSE
[13:19:56.991] - queued futures: [n=1] FALSE
[13:19:56.991]  - until=1
[13:19:56.991]  - relaying element #1
[13:19:56.991] - relayed: [n=1] TRUE
[13:19:56.991] - queued futures: [n=1] TRUE
[13:19:56.991] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:56.991]  length: 0 (resolved future 1)
[13:19:56.991] Relaying remaining futures
[13:19:56.992] signalConditionsASAP(NULL, pos=0) ...
[13:19:56.992] - nx: 1
[13:19:56.992] - relay: TRUE
[13:19:56.992] - stdout: TRUE
[13:19:56.992] - signal: TRUE
[13:19:56.992] - resignal: FALSE
[13:19:56.992] - force: TRUE
[13:19:56.992] - relayed: [n=1] TRUE
[13:19:56.992] - queued futures: [n=1] TRUE
 - flush all
[13:19:56.992] - relayed: [n=1] TRUE
[13:19:56.992] - queued futures: [n=1] TRUE
[13:19:56.993] signalConditionsASAP(NULL, pos=0) ... done
[13:19:56.993] resolve() on list ... DONE
[13:19:56.993]  - Number of value chunks collected: 1
[13:19:56.993] Resolving 1 futures (chunks) ... DONE
[13:19:56.993] Reducing values from 1 chunks ...
[13:19:56.993]  - Number of values collected after concatenation: 6
[13:19:56.993]  - Number of values expected: 6
[13:19:56.993] Reducing values from 1 chunks ... DONE
[13:19:56.993] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[13:19:56.994] getGlobalsAndPackagesXApply() ...
[13:19:56.994]  - future.globals: TRUE
[13:19:56.994] getGlobalsAndPackages() ...
[13:19:56.994] Searching for globals...
[13:19:56.995] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[13:19:56.996] Searching for globals ... DONE
[13:19:56.996] Resolving globals: FALSE
[13:19:56.996] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[13:19:56.996] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[13:19:56.997] - globals: [1] ‘FUN’
[13:19:56.997] 
[13:19:56.997] getGlobalsAndPackages() ... DONE
[13:19:56.997]  - globals found/used: [n=1] ‘FUN’
[13:19:56.997]  - needed namespaces: [n=0] 
[13:19:56.997] Finding globals ... DONE
[13:19:56.997]  - use_args: TRUE
[13:19:56.997]  - Getting '...' globals ...
[13:19:56.998] resolve() on list ...
[13:19:56.998]  recursive: 0
[13:19:56.998]  length: 1
[13:19:56.998]  elements: ‘...’
[13:19:56.998]  length: 0 (resolved future 1)
[13:19:56.998] resolve() on list ... DONE
[13:19:56.998]    - '...' content: [n=0] 
[13:19:56.998] List of 1
[13:19:56.998]  $ ...: list()
[13:19:56.998]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:56.998]  - attr(*, "where")=List of 1
[13:19:56.998]   ..$ ...:<environment: 0x55592263c568> 
[13:19:56.998]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.998]  - attr(*, "resolved")= logi TRUE
[13:19:56.998]  - attr(*, "total_size")= num NA
[13:19:57.001]  - Getting '...' globals ... DONE
[13:19:57.001] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:57.001] List of 2
[13:19:57.001]  $ ...future.FUN:function (x)  
[13:19:57.001]  $ ...          : list()
[13:19:57.001]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.001]  - attr(*, "where")=List of 2
[13:19:57.001]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:57.001]   ..$ ...          :<environment: 0x55592263c568> 
[13:19:57.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.001]  - attr(*, "resolved")= logi FALSE
[13:19:57.001]  - attr(*, "total_size")= num 1768
[13:19:57.006] Packages to be attached in all futures: [n=0] 
[13:19:57.006] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.006] future_lapply() ...
[13:19:57.007] Number of chunks: 1
[13:19:57.007] getGlobalsAndPackagesXApply() ...
[13:19:57.007]  - future.globals: <name-value list> with names ‘list()’
[13:19:57.007]  - use_args: TRUE
[13:19:57.007] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:57.007] List of 2
[13:19:57.007]  $ ...          : list()
[13:19:57.007]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.007]  $ ...future.FUN:function (x)  
[13:19:57.007]  - attr(*, "where")=List of 2
[13:19:57.007]   ..$ ...          :<environment: 0x55592263c568> 
[13:19:57.007]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:19:57.007]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.007]  - attr(*, "resolved")= logi FALSE
[13:19:57.007]  - attr(*, "total_size")= num NA
[13:19:57.010] Packages to be attached in all futures: [n=0] 
[13:19:57.010] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.010] Number of futures (= number of chunks): 1
[13:19:57.011] Launching 1 futures (chunks) ...
[13:19:57.011] Chunk #1 of 1 ...
[13:19:57.011]  - seeds: <none>
[13:19:57.011]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.011] getGlobalsAndPackages() ...
[13:19:57.011] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.011] Resolving globals: FALSE
[13:19:57.011] Tweak future expression to call with '...' arguments ...
[13:19:57.011] {
[13:19:57.011]     do.call(function(...) {
[13:19:57.011]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.011]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.011]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.011]             on.exit(options(oopts), add = TRUE)
[13:19:57.011]         }
[13:19:57.011]         {
[13:19:57.011]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.011]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.011]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.011]             })
[13:19:57.011]         }
[13:19:57.011]     }, args = future.call.arguments)
[13:19:57.011] }
[13:19:57.012] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.012] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.012] 
[13:19:57.012] getGlobalsAndPackages() ... DONE
[13:19:57.013] run() for ‘Future’ ...
[13:19:57.013] - state: ‘created’
[13:19:57.013] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:57.013] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:57.013] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:57.013]   - Field: ‘label’
[13:19:57.014]   - Field: ‘local’
[13:19:57.014]   - Field: ‘owner’
[13:19:57.014]   - Field: ‘envir’
[13:19:57.014]   - Field: ‘packages’
[13:19:57.014]   - Field: ‘gc’
[13:19:57.014]   - Field: ‘conditions’
[13:19:57.014]   - Field: ‘expr’
[13:19:57.014]   - Field: ‘uuid’
[13:19:57.014]   - Field: ‘seed’
[13:19:57.014]   - Field: ‘version’
[13:19:57.014]   - Field: ‘result’
[13:19:57.015]   - Field: ‘asynchronous’
[13:19:57.015]   - Field: ‘calls’
[13:19:57.015]   - Field: ‘globals’
[13:19:57.015]   - Field: ‘stdout’
[13:19:57.015]   - Field: ‘earlySignal’
[13:19:57.015]   - Field: ‘lazy’
[13:19:57.015]   - Field: ‘state’
[13:19:57.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:57.015] - Launch lazy future ...
[13:19:57.015] Packages needed by the future expression (n = 0): <none>
[13:19:57.016] Packages needed by future strategies (n = 0): <none>
[13:19:57.016] {
[13:19:57.016]     {
[13:19:57.016]         {
[13:19:57.016]             ...future.startTime <- base::Sys.time()
[13:19:57.016]             {
[13:19:57.016]                 {
[13:19:57.016]                   {
[13:19:57.016]                     base::local({
[13:19:57.016]                       has_future <- base::requireNamespace("future", 
[13:19:57.016]                         quietly = TRUE)
[13:19:57.016]                       if (has_future) {
[13:19:57.016]                         ns <- base::getNamespace("future")
[13:19:57.016]                         version <- ns[[".package"]][["version"]]
[13:19:57.016]                         if (is.null(version)) 
[13:19:57.016]                           version <- utils::packageVersion("future")
[13:19:57.016]                       }
[13:19:57.016]                       else {
[13:19:57.016]                         version <- NULL
[13:19:57.016]                       }
[13:19:57.016]                       if (!has_future || version < "1.8.0") {
[13:19:57.016]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.016]                           "", base::R.version$version.string), 
[13:19:57.016]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:57.016]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.016]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.016]                             "release", "version")], collapse = " "), 
[13:19:57.016]                           hostname = base::Sys.info()[["nodename"]])
[13:19:57.016]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.016]                           info)
[13:19:57.016]                         info <- base::paste(info, collapse = "; ")
[13:19:57.016]                         if (!has_future) {
[13:19:57.016]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.016]                             info)
[13:19:57.016]                         }
[13:19:57.016]                         else {
[13:19:57.016]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.016]                             info, version)
[13:19:57.016]                         }
[13:19:57.016]                         base::stop(msg)
[13:19:57.016]                       }
[13:19:57.016]                     })
[13:19:57.016]                   }
[13:19:57.016]                   options(future.plan = NULL)
[13:19:57.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.016]                 }
[13:19:57.016]                 ...future.workdir <- getwd()
[13:19:57.016]             }
[13:19:57.016]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.016]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.016]         }
[13:19:57.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.016]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.016]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.016]             base::names(...future.oldOptions))
[13:19:57.016]     }
[13:19:57.016]     if (FALSE) {
[13:19:57.016]     }
[13:19:57.016]     else {
[13:19:57.016]         if (TRUE) {
[13:19:57.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.016]                 open = "w")
[13:19:57.016]         }
[13:19:57.016]         else {
[13:19:57.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.016]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.016]         }
[13:19:57.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.016]             base::sink(type = "output", split = FALSE)
[13:19:57.016]             base::close(...future.stdout)
[13:19:57.016]         }, add = TRUE)
[13:19:57.016]     }
[13:19:57.016]     ...future.frame <- base::sys.nframe()
[13:19:57.016]     ...future.conditions <- base::list()
[13:19:57.016]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.016]     if (FALSE) {
[13:19:57.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.016]     }
[13:19:57.016]     ...future.result <- base::tryCatch({
[13:19:57.016]         base::withCallingHandlers({
[13:19:57.016]             ...future.value <- base::withVisible(base::local({
[13:19:57.016]                 do.call(function(...) {
[13:19:57.016]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.016]                   if (!identical(...future.globals.maxSize.org, 
[13:19:57.016]                     ...future.globals.maxSize)) {
[13:19:57.016]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.016]                     on.exit(options(oopts), add = TRUE)
[13:19:57.016]                   }
[13:19:57.016]                   {
[13:19:57.016]                     lapply(seq_along(...future.elements_ii), 
[13:19:57.016]                       FUN = function(jj) {
[13:19:57.016]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.016]                         ...future.FUN(...future.X_jj, ...)
[13:19:57.016]                       })
[13:19:57.016]                   }
[13:19:57.016]                 }, args = future.call.arguments)
[13:19:57.016]             }))
[13:19:57.016]             future::FutureResult(value = ...future.value$value, 
[13:19:57.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.016]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.016]                     ...future.globalenv.names))
[13:19:57.016]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.016]         }, condition = base::local({
[13:19:57.016]             c <- base::c
[13:19:57.016]             inherits <- base::inherits
[13:19:57.016]             invokeRestart <- base::invokeRestart
[13:19:57.016]             length <- base::length
[13:19:57.016]             list <- base::list
[13:19:57.016]             seq.int <- base::seq.int
[13:19:57.016]             signalCondition <- base::signalCondition
[13:19:57.016]             sys.calls <- base::sys.calls
[13:19:57.016]             `[[` <- base::`[[`
[13:19:57.016]             `+` <- base::`+`
[13:19:57.016]             `<<-` <- base::`<<-`
[13:19:57.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.016]                   3L)]
[13:19:57.016]             }
[13:19:57.016]             function(cond) {
[13:19:57.016]                 is_error <- inherits(cond, "error")
[13:19:57.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.016]                   NULL)
[13:19:57.016]                 if (is_error) {
[13:19:57.016]                   sessionInformation <- function() {
[13:19:57.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.016]                       search = base::search(), system = base::Sys.info())
[13:19:57.016]                   }
[13:19:57.016]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.016]                     cond$call), session = sessionInformation(), 
[13:19:57.016]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.016]                   signalCondition(cond)
[13:19:57.016]                 }
[13:19:57.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.016]                 "immediateCondition"))) {
[13:19:57.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.016]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.016]                   if (TRUE && !signal) {
[13:19:57.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.016]                     {
[13:19:57.016]                       inherits <- base::inherits
[13:19:57.016]                       invokeRestart <- base::invokeRestart
[13:19:57.016]                       is.null <- base::is.null
[13:19:57.016]                       muffled <- FALSE
[13:19:57.016]                       if (inherits(cond, "message")) {
[13:19:57.016]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.016]                         if (muffled) 
[13:19:57.016]                           invokeRestart("muffleMessage")
[13:19:57.016]                       }
[13:19:57.016]                       else if (inherits(cond, "warning")) {
[13:19:57.016]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.016]                         if (muffled) 
[13:19:57.016]                           invokeRestart("muffleWarning")
[13:19:57.016]                       }
[13:19:57.016]                       else if (inherits(cond, "condition")) {
[13:19:57.016]                         if (!is.null(pattern)) {
[13:19:57.016]                           computeRestarts <- base::computeRestarts
[13:19:57.016]                           grepl <- base::grepl
[13:19:57.016]                           restarts <- computeRestarts(cond)
[13:19:57.016]                           for (restart in restarts) {
[13:19:57.016]                             name <- restart$name
[13:19:57.016]                             if (is.null(name)) 
[13:19:57.016]                               next
[13:19:57.016]                             if (!grepl(pattern, name)) 
[13:19:57.016]                               next
[13:19:57.016]                             invokeRestart(restart)
[13:19:57.016]                             muffled <- TRUE
[13:19:57.016]                             break
[13:19:57.016]                           }
[13:19:57.016]                         }
[13:19:57.016]                       }
[13:19:57.016]                       invisible(muffled)
[13:19:57.016]                     }
[13:19:57.016]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.016]                   }
[13:19:57.016]                 }
[13:19:57.016]                 else {
[13:19:57.016]                   if (TRUE) {
[13:19:57.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.016]                     {
[13:19:57.016]                       inherits <- base::inherits
[13:19:57.016]                       invokeRestart <- base::invokeRestart
[13:19:57.016]                       is.null <- base::is.null
[13:19:57.016]                       muffled <- FALSE
[13:19:57.016]                       if (inherits(cond, "message")) {
[13:19:57.016]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.016]                         if (muffled) 
[13:19:57.016]                           invokeRestart("muffleMessage")
[13:19:57.016]                       }
[13:19:57.016]                       else if (inherits(cond, "warning")) {
[13:19:57.016]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.016]                         if (muffled) 
[13:19:57.016]                           invokeRestart("muffleWarning")
[13:19:57.016]                       }
[13:19:57.016]                       else if (inherits(cond, "condition")) {
[13:19:57.016]                         if (!is.null(pattern)) {
[13:19:57.016]                           computeRestarts <- base::computeRestarts
[13:19:57.016]                           grepl <- base::grepl
[13:19:57.016]                           restarts <- computeRestarts(cond)
[13:19:57.016]                           for (restart in restarts) {
[13:19:57.016]                             name <- restart$name
[13:19:57.016]                             if (is.null(name)) 
[13:19:57.016]                               next
[13:19:57.016]                             if (!grepl(pattern, name)) 
[13:19:57.016]                               next
[13:19:57.016]                             invokeRestart(restart)
[13:19:57.016]                             muffled <- TRUE
[13:19:57.016]                             break
[13:19:57.016]                           }
[13:19:57.016]                         }
[13:19:57.016]                       }
[13:19:57.016]                       invisible(muffled)
[13:19:57.016]                     }
[13:19:57.016]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.016]                   }
[13:19:57.016]                 }
[13:19:57.016]             }
[13:19:57.016]         }))
[13:19:57.016]     }, error = function(ex) {
[13:19:57.016]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.016]                 ...future.rng), started = ...future.startTime, 
[13:19:57.016]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.016]             version = "1.8"), class = "FutureResult")
[13:19:57.016]     }, finally = {
[13:19:57.016]         if (!identical(...future.workdir, getwd())) 
[13:19:57.016]             setwd(...future.workdir)
[13:19:57.016]         {
[13:19:57.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.016]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.016]             }
[13:19:57.016]             base::options(...future.oldOptions)
[13:19:57.016]             if (.Platform$OS.type == "windows") {
[13:19:57.016]                 old_names <- names(...future.oldEnvVars)
[13:19:57.016]                 envs <- base::Sys.getenv()
[13:19:57.016]                 names <- names(envs)
[13:19:57.016]                 common <- intersect(names, old_names)
[13:19:57.016]                 added <- setdiff(names, old_names)
[13:19:57.016]                 removed <- setdiff(old_names, names)
[13:19:57.016]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.016]                   envs[common]]
[13:19:57.016]                 NAMES <- toupper(changed)
[13:19:57.016]                 args <- list()
[13:19:57.016]                 for (kk in seq_along(NAMES)) {
[13:19:57.016]                   name <- changed[[kk]]
[13:19:57.016]                   NAME <- NAMES[[kk]]
[13:19:57.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.016]                     next
[13:19:57.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.016]                 }
[13:19:57.016]                 NAMES <- toupper(added)
[13:19:57.016]                 for (kk in seq_along(NAMES)) {
[13:19:57.016]                   name <- added[[kk]]
[13:19:57.016]                   NAME <- NAMES[[kk]]
[13:19:57.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.016]                     next
[13:19:57.016]                   args[[name]] <- ""
[13:19:57.016]                 }
[13:19:57.016]                 NAMES <- toupper(removed)
[13:19:57.016]                 for (kk in seq_along(NAMES)) {
[13:19:57.016]                   name <- removed[[kk]]
[13:19:57.016]                   NAME <- NAMES[[kk]]
[13:19:57.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.016]                     next
[13:19:57.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.016]                 }
[13:19:57.016]                 if (length(args) > 0) 
[13:19:57.016]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.016]             }
[13:19:57.016]             else {
[13:19:57.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.016]             }
[13:19:57.016]             {
[13:19:57.016]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.016]                   0L) {
[13:19:57.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.016]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.016]                   base::options(opts)
[13:19:57.016]                 }
[13:19:57.016]                 {
[13:19:57.016]                   {
[13:19:57.016]                     NULL
[13:19:57.016]                     RNGkind("Mersenne-Twister")
[13:19:57.016]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:57.016]                       inherits = FALSE)
[13:19:57.016]                   }
[13:19:57.016]                   options(future.plan = NULL)
[13:19:57.016]                   if (is.na(NA_character_)) 
[13:19:57.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.016]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:57.016]                   {
[13:19:57.016]                     future <- SequentialFuture(..., envir = envir)
[13:19:57.016]                     if (!future$lazy) 
[13:19:57.016]                       future <- run(future)
[13:19:57.016]                     invisible(future)
[13:19:57.016]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.016]                 }
[13:19:57.016]             }
[13:19:57.016]         }
[13:19:57.016]     })
[13:19:57.016]     if (TRUE) {
[13:19:57.016]         base::sink(type = "output", split = FALSE)
[13:19:57.016]         if (TRUE) {
[13:19:57.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.016]         }
[13:19:57.016]         else {
[13:19:57.016]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.016]         }
[13:19:57.016]         base::close(...future.stdout)
[13:19:57.016]         ...future.stdout <- NULL
[13:19:57.016]     }
[13:19:57.016]     ...future.result$conditions <- ...future.conditions
[13:19:57.016]     ...future.result$finished <- base::Sys.time()
[13:19:57.016]     ...future.result
[13:19:57.016] }
[13:19:57.018] assign_globals() ...
[13:19:57.018] List of 5
[13:19:57.018]  $ future.call.arguments    : list()
[13:19:57.018]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.018]  $ ...future.FUN            :function (x)  
[13:19:57.018]  $ ...future.elements_ii    :List of 6
[13:19:57.018]   ..$ : int [1:4] 1 7 13 19
[13:19:57.018]   ..$ : int [1:4] 2 8 14 20
[13:19:57.018]   ..$ : int [1:4] 3 9 15 21
[13:19:57.018]   ..$ : int [1:4] 4 10 16 22
[13:19:57.018]   ..$ : int [1:4] 5 11 17 23
[13:19:57.018]   ..$ : int [1:4] 6 12 18 24
[13:19:57.018]  $ ...future.seeds_ii       : NULL
[13:19:57.018]  $ ...future.globals.maxSize: num Inf
[13:19:57.018]  - attr(*, "resolved")= logi FALSE
[13:19:57.018]  - attr(*, "total_size")= num NA
[13:19:57.018]  - attr(*, "where")=List of 5
[13:19:57.018]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.018]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.018]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.018]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.018]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.018]  - attr(*, "already-done")= logi TRUE
[13:19:57.024] - copied ‘future.call.arguments’ to environment
[13:19:57.024] - reassign environment for ‘...future.FUN’
[13:19:57.024] - copied ‘...future.FUN’ to environment
[13:19:57.025] - copied ‘...future.elements_ii’ to environment
[13:19:57.025] - copied ‘...future.seeds_ii’ to environment
[13:19:57.025] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.025] assign_globals() ... done
[13:19:57.025] plan(): Setting new future strategy stack:
[13:19:57.025] List of future strategies:
[13:19:57.025] 1. sequential:
[13:19:57.025]    - args: function (..., envir = parent.frame())
[13:19:57.025]    - tweaked: FALSE
[13:19:57.025]    - call: NULL
[13:19:57.026] plan(): nbrOfWorkers() = 1
[13:19:57.026] plan(): Setting new future strategy stack:
[13:19:57.026] List of future strategies:
[13:19:57.026] 1. sequential:
[13:19:57.026]    - args: function (..., envir = parent.frame())
[13:19:57.026]    - tweaked: FALSE
[13:19:57.026]    - call: plan(strategy)
[13:19:57.027] plan(): nbrOfWorkers() = 1
[13:19:57.027] SequentialFuture started (and completed)
[13:19:57.027] - Launch lazy future ... done
[13:19:57.027] run() for ‘SequentialFuture’ ... done
[13:19:57.027] Created future:
[13:19:57.056] SequentialFuture:
[13:19:57.056] Label: ‘future_apply-1’
[13:19:57.056] Expression:
[13:19:57.056] {
[13:19:57.056]     do.call(function(...) {
[13:19:57.056]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.056]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.056]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.056]             on.exit(options(oopts), add = TRUE)
[13:19:57.056]         }
[13:19:57.056]         {
[13:19:57.056]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.056]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.056]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.056]             })
[13:19:57.056]         }
[13:19:57.056]     }, args = future.call.arguments)
[13:19:57.056] }
[13:19:57.056] Lazy evaluation: FALSE
[13:19:57.056] Asynchronous evaluation: FALSE
[13:19:57.056] Local evaluation: TRUE
[13:19:57.056] Environment: R_GlobalEnv
[13:19:57.056] Capture standard output: TRUE
[13:19:57.056] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.056] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.056] Packages: <none>
[13:19:57.056] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.056] Resolved: TRUE
[13:19:57.056] Value: 1.03 KiB of class ‘list’
[13:19:57.056] Early signaling: FALSE
[13:19:57.056] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.056] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:57.057] Chunk #1 of 1 ... DONE
[13:19:57.058] Launching 1 futures (chunks) ... DONE
[13:19:57.058] Resolving 1 futures (chunks) ...
[13:19:57.058] resolve() on list ...
[13:19:57.058]  recursive: 0
[13:19:57.058]  length: 1
[13:19:57.058] 
[13:19:57.058] resolved() for ‘SequentialFuture’ ...
[13:19:57.058] - state: ‘finished’
[13:19:57.059] - run: TRUE
[13:19:57.059] - result: ‘FutureResult’
[13:19:57.059] resolved() for ‘SequentialFuture’ ... done
[13:19:57.059] Future #1
[13:19:57.059] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:57.059] - nx: 1
[13:19:57.059] - relay: TRUE
[13:19:57.059] - stdout: TRUE
[13:19:57.059] - signal: TRUE
[13:19:57.059] - resignal: FALSE
[13:19:57.059] - force: TRUE
[13:19:57.060] - relayed: [n=1] FALSE
[13:19:57.060] - queued futures: [n=1] FALSE
[13:19:57.060]  - until=1
[13:19:57.060]  - relaying element #1
[13:19:57.060] - relayed: [n=1] TRUE
[13:19:57.060] - queued futures: [n=1] TRUE
[13:19:57.060] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:57.060]  length: 0 (resolved future 1)
[13:19:57.060] Relaying remaining futures
[13:19:57.060] signalConditionsASAP(NULL, pos=0) ...
[13:19:57.061] - nx: 1
[13:19:57.061] - relay: TRUE
[13:19:57.061] - stdout: TRUE
[13:19:57.061] - signal: TRUE
[13:19:57.061] - resignal: FALSE
[13:19:57.061] - force: TRUE
[13:19:57.061] - relayed: [n=1] TRUE
[13:19:57.061] - queued futures: [n=1] TRUE
 - flush all
[13:19:57.061] - relayed: [n=1] TRUE
[13:19:57.061] - queued futures: [n=1] TRUE
[13:19:57.061] signalConditionsASAP(NULL, pos=0) ... done
[13:19:57.062] resolve() on list ... DONE
[13:19:57.062]  - Number of value chunks collected: 1
[13:19:57.062] Resolving 1 futures (chunks) ... DONE
[13:19:57.062] Reducing values from 1 chunks ...
[13:19:57.062]  - Number of values collected after concatenation: 6
[13:19:57.062]  - Number of values expected: 6
[13:19:57.062] Reducing values from 1 chunks ... DONE
[13:19:57.062] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[13:19:57.062] getGlobalsAndPackagesXApply() ...
[13:19:57.063]  - future.globals: TRUE
[13:19:57.063] getGlobalsAndPackages() ...
[13:19:57.063] Searching for globals...
[13:19:57.064] - globals found: [1] ‘FUN’
[13:19:57.064] Searching for globals ... DONE
[13:19:57.064] Resolving globals: FALSE
[13:19:57.064] The total size of the 1 globals is 848 bytes (848 bytes)
[13:19:57.065] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:19:57.065] - globals: [1] ‘FUN’
[13:19:57.065] 
[13:19:57.065] getGlobalsAndPackages() ... DONE
[13:19:57.065]  - globals found/used: [n=1] ‘FUN’
[13:19:57.065]  - needed namespaces: [n=0] 
[13:19:57.065] Finding globals ... DONE
[13:19:57.065]  - use_args: TRUE
[13:19:57.065]  - Getting '...' globals ...
[13:19:57.066] resolve() on list ...
[13:19:57.066]  recursive: 0
[13:19:57.066]  length: 1
[13:19:57.066]  elements: ‘...’
[13:19:57.066]  length: 0 (resolved future 1)
[13:19:57.066] resolve() on list ... DONE
[13:19:57.066]    - '...' content: [n=0] 
[13:19:57.066] List of 1
[13:19:57.066]  $ ...: list()
[13:19:57.066]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.066]  - attr(*, "where")=List of 1
[13:19:57.066]   ..$ ...:<environment: 0x5559209c8200> 
[13:19:57.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.066]  - attr(*, "resolved")= logi TRUE
[13:19:57.066]  - attr(*, "total_size")= num NA
[13:19:57.069]  - Getting '...' globals ... DONE
[13:19:57.069] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:57.069] List of 2
[13:19:57.069]  $ ...future.FUN:function (x)  
[13:19:57.069]  $ ...          : list()
[13:19:57.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.069]  - attr(*, "where")=List of 2
[13:19:57.069]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:57.069]   ..$ ...          :<environment: 0x5559209c8200> 
[13:19:57.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.069]  - attr(*, "resolved")= logi FALSE
[13:19:57.069]  - attr(*, "total_size")= num 848
[13:19:57.072] Packages to be attached in all futures: [n=0] 
[13:19:57.072] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.072] future_lapply() ...
[13:19:57.073] Number of chunks: 1
[13:19:57.073] getGlobalsAndPackagesXApply() ...
[13:19:57.073]  - future.globals: <name-value list> with names ‘list()’
[13:19:57.073]  - use_args: TRUE
[13:19:57.073] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:57.073] List of 2
[13:19:57.073]  $ ...          : list()
[13:19:57.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.073]  $ ...future.FUN:function (x)  
[13:19:57.073]  - attr(*, "where")=List of 2
[13:19:57.073]   ..$ ...          :<environment: 0x5559209c8200> 
[13:19:57.073]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:57.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.073]  - attr(*, "resolved")= logi FALSE
[13:19:57.073]  - attr(*, "total_size")= num NA
[13:19:57.076] Packages to be attached in all futures: [n=0] 
[13:19:57.076] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.077] Number of futures (= number of chunks): 1
[13:19:57.077] Launching 1 futures (chunks) ...
[13:19:57.077] Chunk #1 of 1 ...
[13:19:57.077]  - seeds: <none>
[13:19:57.077]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.077] getGlobalsAndPackages() ...
[13:19:57.077] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.077] Resolving globals: FALSE
[13:19:57.077] Tweak future expression to call with '...' arguments ...
[13:19:57.078] {
[13:19:57.078]     do.call(function(...) {
[13:19:57.078]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.078]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.078]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.078]             on.exit(options(oopts), add = TRUE)
[13:19:57.078]         }
[13:19:57.078]         {
[13:19:57.078]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.078]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.078]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.078]             })
[13:19:57.078]         }
[13:19:57.078]     }, args = future.call.arguments)
[13:19:57.078] }
[13:19:57.078] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.078] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.078] 
[13:19:57.078] getGlobalsAndPackages() ... DONE
[13:19:57.079] run() for ‘Future’ ...
[13:19:57.079] - state: ‘created’
[13:19:57.079] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:57.079] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:57.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:57.081]   - Field: ‘label’
[13:19:57.081]   - Field: ‘local’
[13:19:57.081]   - Field: ‘owner’
[13:19:57.081]   - Field: ‘envir’
[13:19:57.081]   - Field: ‘packages’
[13:19:57.081]   - Field: ‘gc’
[13:19:57.081]   - Field: ‘conditions’
[13:19:57.081]   - Field: ‘expr’
[13:19:57.082]   - Field: ‘uuid’
[13:19:57.082]   - Field: ‘seed’
[13:19:57.082]   - Field: ‘version’
[13:19:57.082]   - Field: ‘result’
[13:19:57.082]   - Field: ‘asynchronous’
[13:19:57.082]   - Field: ‘calls’
[13:19:57.082]   - Field: ‘globals’
[13:19:57.082]   - Field: ‘stdout’
[13:19:57.082]   - Field: ‘earlySignal’
[13:19:57.082]   - Field: ‘lazy’
[13:19:57.083]   - Field: ‘state’
[13:19:57.083] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:57.083] - Launch lazy future ...
[13:19:57.083] Packages needed by the future expression (n = 0): <none>
[13:19:57.083] Packages needed by future strategies (n = 0): <none>
[13:19:57.084] {
[13:19:57.084]     {
[13:19:57.084]         {
[13:19:57.084]             ...future.startTime <- base::Sys.time()
[13:19:57.084]             {
[13:19:57.084]                 {
[13:19:57.084]                   {
[13:19:57.084]                     base::local({
[13:19:57.084]                       has_future <- base::requireNamespace("future", 
[13:19:57.084]                         quietly = TRUE)
[13:19:57.084]                       if (has_future) {
[13:19:57.084]                         ns <- base::getNamespace("future")
[13:19:57.084]                         version <- ns[[".package"]][["version"]]
[13:19:57.084]                         if (is.null(version)) 
[13:19:57.084]                           version <- utils::packageVersion("future")
[13:19:57.084]                       }
[13:19:57.084]                       else {
[13:19:57.084]                         version <- NULL
[13:19:57.084]                       }
[13:19:57.084]                       if (!has_future || version < "1.8.0") {
[13:19:57.084]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.084]                           "", base::R.version$version.string), 
[13:19:57.084]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:57.084]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.084]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.084]                             "release", "version")], collapse = " "), 
[13:19:57.084]                           hostname = base::Sys.info()[["nodename"]])
[13:19:57.084]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.084]                           info)
[13:19:57.084]                         info <- base::paste(info, collapse = "; ")
[13:19:57.084]                         if (!has_future) {
[13:19:57.084]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.084]                             info)
[13:19:57.084]                         }
[13:19:57.084]                         else {
[13:19:57.084]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.084]                             info, version)
[13:19:57.084]                         }
[13:19:57.084]                         base::stop(msg)
[13:19:57.084]                       }
[13:19:57.084]                     })
[13:19:57.084]                   }
[13:19:57.084]                   options(future.plan = NULL)
[13:19:57.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.084]                 }
[13:19:57.084]                 ...future.workdir <- getwd()
[13:19:57.084]             }
[13:19:57.084]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.084]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.084]         }
[13:19:57.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.084]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.084]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.084]             base::names(...future.oldOptions))
[13:19:57.084]     }
[13:19:57.084]     if (FALSE) {
[13:19:57.084]     }
[13:19:57.084]     else {
[13:19:57.084]         if (TRUE) {
[13:19:57.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.084]                 open = "w")
[13:19:57.084]         }
[13:19:57.084]         else {
[13:19:57.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.084]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.084]         }
[13:19:57.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.084]             base::sink(type = "output", split = FALSE)
[13:19:57.084]             base::close(...future.stdout)
[13:19:57.084]         }, add = TRUE)
[13:19:57.084]     }
[13:19:57.084]     ...future.frame <- base::sys.nframe()
[13:19:57.084]     ...future.conditions <- base::list()
[13:19:57.084]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.084]     if (FALSE) {
[13:19:57.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.084]     }
[13:19:57.084]     ...future.result <- base::tryCatch({
[13:19:57.084]         base::withCallingHandlers({
[13:19:57.084]             ...future.value <- base::withVisible(base::local({
[13:19:57.084]                 do.call(function(...) {
[13:19:57.084]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.084]                   if (!identical(...future.globals.maxSize.org, 
[13:19:57.084]                     ...future.globals.maxSize)) {
[13:19:57.084]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.084]                     on.exit(options(oopts), add = TRUE)
[13:19:57.084]                   }
[13:19:57.084]                   {
[13:19:57.084]                     lapply(seq_along(...future.elements_ii), 
[13:19:57.084]                       FUN = function(jj) {
[13:19:57.084]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.084]                         ...future.FUN(...future.X_jj, ...)
[13:19:57.084]                       })
[13:19:57.084]                   }
[13:19:57.084]                 }, args = future.call.arguments)
[13:19:57.084]             }))
[13:19:57.084]             future::FutureResult(value = ...future.value$value, 
[13:19:57.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.084]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.084]                     ...future.globalenv.names))
[13:19:57.084]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.084]         }, condition = base::local({
[13:19:57.084]             c <- base::c
[13:19:57.084]             inherits <- base::inherits
[13:19:57.084]             invokeRestart <- base::invokeRestart
[13:19:57.084]             length <- base::length
[13:19:57.084]             list <- base::list
[13:19:57.084]             seq.int <- base::seq.int
[13:19:57.084]             signalCondition <- base::signalCondition
[13:19:57.084]             sys.calls <- base::sys.calls
[13:19:57.084]             `[[` <- base::`[[`
[13:19:57.084]             `+` <- base::`+`
[13:19:57.084]             `<<-` <- base::`<<-`
[13:19:57.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.084]                   3L)]
[13:19:57.084]             }
[13:19:57.084]             function(cond) {
[13:19:57.084]                 is_error <- inherits(cond, "error")
[13:19:57.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.084]                   NULL)
[13:19:57.084]                 if (is_error) {
[13:19:57.084]                   sessionInformation <- function() {
[13:19:57.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.084]                       search = base::search(), system = base::Sys.info())
[13:19:57.084]                   }
[13:19:57.084]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.084]                     cond$call), session = sessionInformation(), 
[13:19:57.084]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.084]                   signalCondition(cond)
[13:19:57.084]                 }
[13:19:57.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.084]                 "immediateCondition"))) {
[13:19:57.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.084]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.084]                   if (TRUE && !signal) {
[13:19:57.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.084]                     {
[13:19:57.084]                       inherits <- base::inherits
[13:19:57.084]                       invokeRestart <- base::invokeRestart
[13:19:57.084]                       is.null <- base::is.null
[13:19:57.084]                       muffled <- FALSE
[13:19:57.084]                       if (inherits(cond, "message")) {
[13:19:57.084]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.084]                         if (muffled) 
[13:19:57.084]                           invokeRestart("muffleMessage")
[13:19:57.084]                       }
[13:19:57.084]                       else if (inherits(cond, "warning")) {
[13:19:57.084]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.084]                         if (muffled) 
[13:19:57.084]                           invokeRestart("muffleWarning")
[13:19:57.084]                       }
[13:19:57.084]                       else if (inherits(cond, "condition")) {
[13:19:57.084]                         if (!is.null(pattern)) {
[13:19:57.084]                           computeRestarts <- base::computeRestarts
[13:19:57.084]                           grepl <- base::grepl
[13:19:57.084]                           restarts <- computeRestarts(cond)
[13:19:57.084]                           for (restart in restarts) {
[13:19:57.084]                             name <- restart$name
[13:19:57.084]                             if (is.null(name)) 
[13:19:57.084]                               next
[13:19:57.084]                             if (!grepl(pattern, name)) 
[13:19:57.084]                               next
[13:19:57.084]                             invokeRestart(restart)
[13:19:57.084]                             muffled <- TRUE
[13:19:57.084]                             break
[13:19:57.084]                           }
[13:19:57.084]                         }
[13:19:57.084]                       }
[13:19:57.084]                       invisible(muffled)
[13:19:57.084]                     }
[13:19:57.084]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.084]                   }
[13:19:57.084]                 }
[13:19:57.084]                 else {
[13:19:57.084]                   if (TRUE) {
[13:19:57.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.084]                     {
[13:19:57.084]                       inherits <- base::inherits
[13:19:57.084]                       invokeRestart <- base::invokeRestart
[13:19:57.084]                       is.null <- base::is.null
[13:19:57.084]                       muffled <- FALSE
[13:19:57.084]                       if (inherits(cond, "message")) {
[13:19:57.084]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.084]                         if (muffled) 
[13:19:57.084]                           invokeRestart("muffleMessage")
[13:19:57.084]                       }
[13:19:57.084]                       else if (inherits(cond, "warning")) {
[13:19:57.084]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.084]                         if (muffled) 
[13:19:57.084]                           invokeRestart("muffleWarning")
[13:19:57.084]                       }
[13:19:57.084]                       else if (inherits(cond, "condition")) {
[13:19:57.084]                         if (!is.null(pattern)) {
[13:19:57.084]                           computeRestarts <- base::computeRestarts
[13:19:57.084]                           grepl <- base::grepl
[13:19:57.084]                           restarts <- computeRestarts(cond)
[13:19:57.084]                           for (restart in restarts) {
[13:19:57.084]                             name <- restart$name
[13:19:57.084]                             if (is.null(name)) 
[13:19:57.084]                               next
[13:19:57.084]                             if (!grepl(pattern, name)) 
[13:19:57.084]                               next
[13:19:57.084]                             invokeRestart(restart)
[13:19:57.084]                             muffled <- TRUE
[13:19:57.084]                             break
[13:19:57.084]                           }
[13:19:57.084]                         }
[13:19:57.084]                       }
[13:19:57.084]                       invisible(muffled)
[13:19:57.084]                     }
[13:19:57.084]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.084]                   }
[13:19:57.084]                 }
[13:19:57.084]             }
[13:19:57.084]         }))
[13:19:57.084]     }, error = function(ex) {
[13:19:57.084]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.084]                 ...future.rng), started = ...future.startTime, 
[13:19:57.084]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.084]             version = "1.8"), class = "FutureResult")
[13:19:57.084]     }, finally = {
[13:19:57.084]         if (!identical(...future.workdir, getwd())) 
[13:19:57.084]             setwd(...future.workdir)
[13:19:57.084]         {
[13:19:57.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.084]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.084]             }
[13:19:57.084]             base::options(...future.oldOptions)
[13:19:57.084]             if (.Platform$OS.type == "windows") {
[13:19:57.084]                 old_names <- names(...future.oldEnvVars)
[13:19:57.084]                 envs <- base::Sys.getenv()
[13:19:57.084]                 names <- names(envs)
[13:19:57.084]                 common <- intersect(names, old_names)
[13:19:57.084]                 added <- setdiff(names, old_names)
[13:19:57.084]                 removed <- setdiff(old_names, names)
[13:19:57.084]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.084]                   envs[common]]
[13:19:57.084]                 NAMES <- toupper(changed)
[13:19:57.084]                 args <- list()
[13:19:57.084]                 for (kk in seq_along(NAMES)) {
[13:19:57.084]                   name <- changed[[kk]]
[13:19:57.084]                   NAME <- NAMES[[kk]]
[13:19:57.084]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.084]                     next
[13:19:57.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.084]                 }
[13:19:57.084]                 NAMES <- toupper(added)
[13:19:57.084]                 for (kk in seq_along(NAMES)) {
[13:19:57.084]                   name <- added[[kk]]
[13:19:57.084]                   NAME <- NAMES[[kk]]
[13:19:57.084]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.084]                     next
[13:19:57.084]                   args[[name]] <- ""
[13:19:57.084]                 }
[13:19:57.084]                 NAMES <- toupper(removed)
[13:19:57.084]                 for (kk in seq_along(NAMES)) {
[13:19:57.084]                   name <- removed[[kk]]
[13:19:57.084]                   NAME <- NAMES[[kk]]
[13:19:57.084]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.084]                     next
[13:19:57.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.084]                 }
[13:19:57.084]                 if (length(args) > 0) 
[13:19:57.084]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.084]             }
[13:19:57.084]             else {
[13:19:57.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.084]             }
[13:19:57.084]             {
[13:19:57.084]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.084]                   0L) {
[13:19:57.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.084]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.084]                   base::options(opts)
[13:19:57.084]                 }
[13:19:57.084]                 {
[13:19:57.084]                   {
[13:19:57.084]                     NULL
[13:19:57.084]                     RNGkind("Mersenne-Twister")
[13:19:57.084]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:57.084]                       inherits = FALSE)
[13:19:57.084]                   }
[13:19:57.084]                   options(future.plan = NULL)
[13:19:57.084]                   if (is.na(NA_character_)) 
[13:19:57.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.084]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:57.084]                   {
[13:19:57.084]                     future <- SequentialFuture(..., envir = envir)
[13:19:57.084]                     if (!future$lazy) 
[13:19:57.084]                       future <- run(future)
[13:19:57.084]                     invisible(future)
[13:19:57.084]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.084]                 }
[13:19:57.084]             }
[13:19:57.084]         }
[13:19:57.084]     })
[13:19:57.084]     if (TRUE) {
[13:19:57.084]         base::sink(type = "output", split = FALSE)
[13:19:57.084]         if (TRUE) {
[13:19:57.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.084]         }
[13:19:57.084]         else {
[13:19:57.084]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.084]         }
[13:19:57.084]         base::close(...future.stdout)
[13:19:57.084]         ...future.stdout <- NULL
[13:19:57.084]     }
[13:19:57.084]     ...future.result$conditions <- ...future.conditions
[13:19:57.084]     ...future.result$finished <- base::Sys.time()
[13:19:57.084]     ...future.result
[13:19:57.084] }
[13:19:57.085] assign_globals() ...
[13:19:57.085] List of 5
[13:19:57.085]  $ future.call.arguments    : list()
[13:19:57.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.085]  $ ...future.FUN            :function (x)  
[13:19:57.085]  $ ...future.elements_ii    :List of 2
[13:19:57.085]   ..$ : int 1
[13:19:57.085]   ..$ : int 2
[13:19:57.085]  $ ...future.seeds_ii       : NULL
[13:19:57.085]  $ ...future.globals.maxSize: num Inf
[13:19:57.085]  - attr(*, "resolved")= logi FALSE
[13:19:57.085]  - attr(*, "total_size")= num NA
[13:19:57.085]  - attr(*, "where")=List of 5
[13:19:57.085]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.085]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.085]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.085]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.085]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.085]  - attr(*, "already-done")= logi TRUE
[13:19:57.091] - copied ‘future.call.arguments’ to environment
[13:19:57.091] - copied ‘...future.FUN’ to environment
[13:19:57.091] - copied ‘...future.elements_ii’ to environment
[13:19:57.091] - copied ‘...future.seeds_ii’ to environment
[13:19:57.091] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.091] assign_globals() ... done
[13:19:57.091] plan(): Setting new future strategy stack:
[13:19:57.092] List of future strategies:
[13:19:57.092] 1. sequential:
[13:19:57.092]    - args: function (..., envir = parent.frame())
[13:19:57.092]    - tweaked: FALSE
[13:19:57.092]    - call: NULL
[13:19:57.092] plan(): nbrOfWorkers() = 1
[13:19:57.093] plan(): Setting new future strategy stack:
[13:19:57.093] List of future strategies:
[13:19:57.093] 1. sequential:
[13:19:57.093]    - args: function (..., envir = parent.frame())
[13:19:57.093]    - tweaked: FALSE
[13:19:57.093]    - call: plan(strategy)
[13:19:57.093] plan(): nbrOfWorkers() = 1
[13:19:57.093] SequentialFuture started (and completed)
[13:19:57.094] - Launch lazy future ... done
[13:19:57.094] run() for ‘SequentialFuture’ ... done
[13:19:57.094] Created future:
[13:19:57.094] SequentialFuture:
[13:19:57.094] Label: ‘future_apply-1’
[13:19:57.094] Expression:
[13:19:57.094] {
[13:19:57.094]     do.call(function(...) {
[13:19:57.094]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.094]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.094]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.094]             on.exit(options(oopts), add = TRUE)
[13:19:57.094]         }
[13:19:57.094]         {
[13:19:57.094]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.094]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.094]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.094]             })
[13:19:57.094]         }
[13:19:57.094]     }, args = future.call.arguments)
[13:19:57.094] }
[13:19:57.094] Lazy evaluation: FALSE
[13:19:57.094] Asynchronous evaluation: FALSE
[13:19:57.094] Local evaluation: TRUE
[13:19:57.094] Environment: R_GlobalEnv
[13:19:57.094] Capture standard output: TRUE
[13:19:57.094] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.094] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.094] Packages: <none>
[13:19:57.094] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.094] Resolved: TRUE
[13:19:57.094] Value: 112 bytes of class ‘list’
[13:19:57.094] Early signaling: FALSE
[13:19:57.094] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.094] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:57.095] Chunk #1 of 1 ... DONE
[13:19:57.095] Launching 1 futures (chunks) ... DONE
[13:19:57.095] Resolving 1 futures (chunks) ...
[13:19:57.095] resolve() on list ...
[13:19:57.095]  recursive: 0
[13:19:57.095]  length: 1
[13:19:57.096] 
[13:19:57.096] resolved() for ‘SequentialFuture’ ...
[13:19:57.096] - state: ‘finished’
[13:19:57.096] - run: TRUE
[13:19:57.096] - result: ‘FutureResult’
[13:19:57.096] resolved() for ‘SequentialFuture’ ... done
[13:19:57.096] Future #1
[13:19:57.096] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:57.096] - nx: 1
[13:19:57.097] - relay: TRUE
[13:19:57.097] - stdout: TRUE
[13:19:57.097] - signal: TRUE
[13:19:57.097] - resignal: FALSE
[13:19:57.097] - force: TRUE
[13:19:57.097] - relayed: [n=1] FALSE
[13:19:57.097] - queued futures: [n=1] FALSE
[13:19:57.097]  - until=1
[13:19:57.097]  - relaying element #1
[13:19:57.097] - relayed: [n=1] TRUE
[13:19:57.098] - queued futures: [n=1] TRUE
[13:19:57.098] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:57.098]  length: 0 (resolved future 1)
[13:19:57.098] Relaying remaining futures
[13:19:57.098] signalConditionsASAP(NULL, pos=0) ...
[13:19:57.098] - nx: 1
[13:19:57.098] - relay: TRUE
[13:19:57.098] - stdout: TRUE
[13:19:57.098] - signal: TRUE
[13:19:57.098] - resignal: FALSE
[13:19:57.098] - force: TRUE
[13:19:57.098] - relayed: [n=1] TRUE
[13:19:57.099] - queued futures: [n=1] TRUE
 - flush all
[13:19:57.099] - relayed: [n=1] TRUE
[13:19:57.099] - queued futures: [n=1] TRUE
[13:19:57.099] signalConditionsASAP(NULL, pos=0) ... done
[13:19:57.099] resolve() on list ... DONE
[13:19:57.099]  - Number of value chunks collected: 1
[13:19:57.099] Resolving 1 futures (chunks) ... DONE
[13:19:57.099] Reducing values from 1 chunks ...
[13:19:57.099]  - Number of values collected after concatenation: 2
[13:19:57.100]  - Number of values expected: 2
[13:19:57.100] Reducing values from 1 chunks ... DONE
[13:19:57.100] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[13:19:57.100] getGlobalsAndPackagesXApply() ...
[13:19:57.100]  - future.globals: TRUE
[13:19:57.101] getGlobalsAndPackages() ...
[13:19:57.101] Searching for globals...
[13:19:57.102] - globals found: [1] ‘FUN’
[13:19:57.102] Searching for globals ... DONE
[13:19:57.102] Resolving globals: FALSE
[13:19:57.103] The total size of the 1 globals is 848 bytes (848 bytes)
[13:19:57.103] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:19:57.103] - globals: [1] ‘FUN’
[13:19:57.103] 
[13:19:57.103] getGlobalsAndPackages() ... DONE
[13:19:57.104]  - globals found/used: [n=1] ‘FUN’
[13:19:57.104]  - needed namespaces: [n=0] 
[13:19:57.104] Finding globals ... DONE
[13:19:57.104]  - use_args: TRUE
[13:19:57.104]  - Getting '...' globals ...
[13:19:57.105] resolve() on list ...
[13:19:57.105]  recursive: 0
[13:19:57.105]  length: 1
[13:19:57.105]  elements: ‘...’
[13:19:57.105]  length: 0 (resolved future 1)
[13:19:57.105] resolve() on list ... DONE
[13:19:57.105]    - '...' content: [n=0] 
[13:19:57.105] List of 1
[13:19:57.105]  $ ...: list()
[13:19:57.105]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.105]  - attr(*, "where")=List of 1
[13:19:57.105]   ..$ ...:<environment: 0x555922b1e308> 
[13:19:57.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.105]  - attr(*, "resolved")= logi TRUE
[13:19:57.105]  - attr(*, "total_size")= num NA
[13:19:57.110]  - Getting '...' globals ... DONE
[13:19:57.110] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:57.110] List of 2
[13:19:57.110]  $ ...future.FUN:function (x)  
[13:19:57.110]  $ ...          : list()
[13:19:57.110]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.110]  - attr(*, "where")=List of 2
[13:19:57.110]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:57.110]   ..$ ...          :<environment: 0x555922b1e308> 
[13:19:57.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.110]  - attr(*, "resolved")= logi FALSE
[13:19:57.110]  - attr(*, "total_size")= num 848
[13:19:57.113] Packages to be attached in all futures: [n=0] 
[13:19:57.113] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.114] future_lapply() ...
[13:19:57.114] Number of chunks: 1
[13:19:57.114] getGlobalsAndPackagesXApply() ...
[13:19:57.114]  - future.globals: <name-value list> with names ‘list()’
[13:19:57.114]  - use_args: TRUE
[13:19:57.115] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:57.115] List of 2
[13:19:57.115]  $ ...          : list()
[13:19:57.115]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.115]  $ ...future.FUN:function (x)  
[13:19:57.115]  - attr(*, "where")=List of 2
[13:19:57.115]   ..$ ...          :<environment: 0x555922b1e308> 
[13:19:57.115]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:57.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.115]  - attr(*, "resolved")= logi FALSE
[13:19:57.115]  - attr(*, "total_size")= num NA
[13:19:57.119] Packages to be attached in all futures: [n=0] 
[13:19:57.119] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.119] Number of futures (= number of chunks): 1
[13:19:57.120] Launching 1 futures (chunks) ...
[13:19:57.120] Chunk #1 of 1 ...
[13:19:57.120]  - seeds: <none>
[13:19:57.120]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.120] getGlobalsAndPackages() ...
[13:19:57.120] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.121] Resolving globals: FALSE
[13:19:57.121] Tweak future expression to call with '...' arguments ...
[13:19:57.121] {
[13:19:57.121]     do.call(function(...) {
[13:19:57.121]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.121]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.121]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.121]             on.exit(options(oopts), add = TRUE)
[13:19:57.121]         }
[13:19:57.121]         {
[13:19:57.121]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.121]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.121]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.121]             })
[13:19:57.121]         }
[13:19:57.121]     }, args = future.call.arguments)
[13:19:57.121] }
[13:19:57.121] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.122] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.122] 
[13:19:57.122] getGlobalsAndPackages() ... DONE
[13:19:57.123] run() for ‘Future’ ...
[13:19:57.123] - state: ‘created’
[13:19:57.123] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:57.124] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:57.124] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:57.124]   - Field: ‘label’
[13:19:57.124]   - Field: ‘local’
[13:19:57.124]   - Field: ‘owner’
[13:19:57.124]   - Field: ‘envir’
[13:19:57.124]   - Field: ‘packages’
[13:19:57.125]   - Field: ‘gc’
[13:19:57.125]   - Field: ‘conditions’
[13:19:57.125]   - Field: ‘expr’
[13:19:57.125]   - Field: ‘uuid’
[13:19:57.125]   - Field: ‘seed’
[13:19:57.125]   - Field: ‘version’
[13:19:57.125]   - Field: ‘result’
[13:19:57.126]   - Field: ‘asynchronous’
[13:19:57.126]   - Field: ‘calls’
[13:19:57.126]   - Field: ‘globals’
[13:19:57.126]   - Field: ‘stdout’
[13:19:57.126]   - Field: ‘earlySignal’
[13:19:57.126]   - Field: ‘lazy’
[13:19:57.126]   - Field: ‘state’
[13:19:57.126] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:57.126] - Launch lazy future ...
[13:19:57.127] Packages needed by the future expression (n = 0): <none>
[13:19:57.127] Packages needed by future strategies (n = 0): <none>
[13:19:57.127] {
[13:19:57.127]     {
[13:19:57.127]         {
[13:19:57.127]             ...future.startTime <- base::Sys.time()
[13:19:57.127]             {
[13:19:57.127]                 {
[13:19:57.127]                   {
[13:19:57.127]                     base::local({
[13:19:57.127]                       has_future <- base::requireNamespace("future", 
[13:19:57.127]                         quietly = TRUE)
[13:19:57.127]                       if (has_future) {
[13:19:57.127]                         ns <- base::getNamespace("future")
[13:19:57.127]                         version <- ns[[".package"]][["version"]]
[13:19:57.127]                         if (is.null(version)) 
[13:19:57.127]                           version <- utils::packageVersion("future")
[13:19:57.127]                       }
[13:19:57.127]                       else {
[13:19:57.127]                         version <- NULL
[13:19:57.127]                       }
[13:19:57.127]                       if (!has_future || version < "1.8.0") {
[13:19:57.127]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.127]                           "", base::R.version$version.string), 
[13:19:57.127]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:57.127]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.127]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.127]                             "release", "version")], collapse = " "), 
[13:19:57.127]                           hostname = base::Sys.info()[["nodename"]])
[13:19:57.127]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.127]                           info)
[13:19:57.127]                         info <- base::paste(info, collapse = "; ")
[13:19:57.127]                         if (!has_future) {
[13:19:57.127]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.127]                             info)
[13:19:57.127]                         }
[13:19:57.127]                         else {
[13:19:57.127]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.127]                             info, version)
[13:19:57.127]                         }
[13:19:57.127]                         base::stop(msg)
[13:19:57.127]                       }
[13:19:57.127]                     })
[13:19:57.127]                   }
[13:19:57.127]                   options(future.plan = NULL)
[13:19:57.127]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.127]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.127]                 }
[13:19:57.127]                 ...future.workdir <- getwd()
[13:19:57.127]             }
[13:19:57.127]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.127]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.127]         }
[13:19:57.127]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.127]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.127]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.127]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.127]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.127]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.127]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.127]             base::names(...future.oldOptions))
[13:19:57.127]     }
[13:19:57.127]     if (FALSE) {
[13:19:57.127]     }
[13:19:57.127]     else {
[13:19:57.127]         if (TRUE) {
[13:19:57.127]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.127]                 open = "w")
[13:19:57.127]         }
[13:19:57.127]         else {
[13:19:57.127]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.127]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.127]         }
[13:19:57.127]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.127]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.127]             base::sink(type = "output", split = FALSE)
[13:19:57.127]             base::close(...future.stdout)
[13:19:57.127]         }, add = TRUE)
[13:19:57.127]     }
[13:19:57.127]     ...future.frame <- base::sys.nframe()
[13:19:57.127]     ...future.conditions <- base::list()
[13:19:57.127]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.127]     if (FALSE) {
[13:19:57.127]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.127]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.127]     }
[13:19:57.127]     ...future.result <- base::tryCatch({
[13:19:57.127]         base::withCallingHandlers({
[13:19:57.127]             ...future.value <- base::withVisible(base::local({
[13:19:57.127]                 do.call(function(...) {
[13:19:57.127]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.127]                   if (!identical(...future.globals.maxSize.org, 
[13:19:57.127]                     ...future.globals.maxSize)) {
[13:19:57.127]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.127]                     on.exit(options(oopts), add = TRUE)
[13:19:57.127]                   }
[13:19:57.127]                   {
[13:19:57.127]                     lapply(seq_along(...future.elements_ii), 
[13:19:57.127]                       FUN = function(jj) {
[13:19:57.127]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.127]                         ...future.FUN(...future.X_jj, ...)
[13:19:57.127]                       })
[13:19:57.127]                   }
[13:19:57.127]                 }, args = future.call.arguments)
[13:19:57.127]             }))
[13:19:57.127]             future::FutureResult(value = ...future.value$value, 
[13:19:57.127]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.127]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.127]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.127]                     ...future.globalenv.names))
[13:19:57.127]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.127]         }, condition = base::local({
[13:19:57.127]             c <- base::c
[13:19:57.127]             inherits <- base::inherits
[13:19:57.127]             invokeRestart <- base::invokeRestart
[13:19:57.127]             length <- base::length
[13:19:57.127]             list <- base::list
[13:19:57.127]             seq.int <- base::seq.int
[13:19:57.127]             signalCondition <- base::signalCondition
[13:19:57.127]             sys.calls <- base::sys.calls
[13:19:57.127]             `[[` <- base::`[[`
[13:19:57.127]             `+` <- base::`+`
[13:19:57.127]             `<<-` <- base::`<<-`
[13:19:57.127]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.127]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.127]                   3L)]
[13:19:57.127]             }
[13:19:57.127]             function(cond) {
[13:19:57.127]                 is_error <- inherits(cond, "error")
[13:19:57.127]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.127]                   NULL)
[13:19:57.127]                 if (is_error) {
[13:19:57.127]                   sessionInformation <- function() {
[13:19:57.127]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.127]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.127]                       search = base::search(), system = base::Sys.info())
[13:19:57.127]                   }
[13:19:57.127]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.127]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.127]                     cond$call), session = sessionInformation(), 
[13:19:57.127]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.127]                   signalCondition(cond)
[13:19:57.127]                 }
[13:19:57.127]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.127]                 "immediateCondition"))) {
[13:19:57.127]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.127]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.127]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.127]                   if (TRUE && !signal) {
[13:19:57.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.127]                     {
[13:19:57.127]                       inherits <- base::inherits
[13:19:57.127]                       invokeRestart <- base::invokeRestart
[13:19:57.127]                       is.null <- base::is.null
[13:19:57.127]                       muffled <- FALSE
[13:19:57.127]                       if (inherits(cond, "message")) {
[13:19:57.127]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.127]                         if (muffled) 
[13:19:57.127]                           invokeRestart("muffleMessage")
[13:19:57.127]                       }
[13:19:57.127]                       else if (inherits(cond, "warning")) {
[13:19:57.127]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.127]                         if (muffled) 
[13:19:57.127]                           invokeRestart("muffleWarning")
[13:19:57.127]                       }
[13:19:57.127]                       else if (inherits(cond, "condition")) {
[13:19:57.127]                         if (!is.null(pattern)) {
[13:19:57.127]                           computeRestarts <- base::computeRestarts
[13:19:57.127]                           grepl <- base::grepl
[13:19:57.127]                           restarts <- computeRestarts(cond)
[13:19:57.127]                           for (restart in restarts) {
[13:19:57.127]                             name <- restart$name
[13:19:57.127]                             if (is.null(name)) 
[13:19:57.127]                               next
[13:19:57.127]                             if (!grepl(pattern, name)) 
[13:19:57.127]                               next
[13:19:57.127]                             invokeRestart(restart)
[13:19:57.127]                             muffled <- TRUE
[13:19:57.127]                             break
[13:19:57.127]                           }
[13:19:57.127]                         }
[13:19:57.127]                       }
[13:19:57.127]                       invisible(muffled)
[13:19:57.127]                     }
[13:19:57.127]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.127]                   }
[13:19:57.127]                 }
[13:19:57.127]                 else {
[13:19:57.127]                   if (TRUE) {
[13:19:57.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.127]                     {
[13:19:57.127]                       inherits <- base::inherits
[13:19:57.127]                       invokeRestart <- base::invokeRestart
[13:19:57.127]                       is.null <- base::is.null
[13:19:57.127]                       muffled <- FALSE
[13:19:57.127]                       if (inherits(cond, "message")) {
[13:19:57.127]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.127]                         if (muffled) 
[13:19:57.127]                           invokeRestart("muffleMessage")
[13:19:57.127]                       }
[13:19:57.127]                       else if (inherits(cond, "warning")) {
[13:19:57.127]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.127]                         if (muffled) 
[13:19:57.127]                           invokeRestart("muffleWarning")
[13:19:57.127]                       }
[13:19:57.127]                       else if (inherits(cond, "condition")) {
[13:19:57.127]                         if (!is.null(pattern)) {
[13:19:57.127]                           computeRestarts <- base::computeRestarts
[13:19:57.127]                           grepl <- base::grepl
[13:19:57.127]                           restarts <- computeRestarts(cond)
[13:19:57.127]                           for (restart in restarts) {
[13:19:57.127]                             name <- restart$name
[13:19:57.127]                             if (is.null(name)) 
[13:19:57.127]                               next
[13:19:57.127]                             if (!grepl(pattern, name)) 
[13:19:57.127]                               next
[13:19:57.127]                             invokeRestart(restart)
[13:19:57.127]                             muffled <- TRUE
[13:19:57.127]                             break
[13:19:57.127]                           }
[13:19:57.127]                         }
[13:19:57.127]                       }
[13:19:57.127]                       invisible(muffled)
[13:19:57.127]                     }
[13:19:57.127]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.127]                   }
[13:19:57.127]                 }
[13:19:57.127]             }
[13:19:57.127]         }))
[13:19:57.127]     }, error = function(ex) {
[13:19:57.127]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.127]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.127]                 ...future.rng), started = ...future.startTime, 
[13:19:57.127]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.127]             version = "1.8"), class = "FutureResult")
[13:19:57.127]     }, finally = {
[13:19:57.127]         if (!identical(...future.workdir, getwd())) 
[13:19:57.127]             setwd(...future.workdir)
[13:19:57.127]         {
[13:19:57.127]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.127]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.127]             }
[13:19:57.127]             base::options(...future.oldOptions)
[13:19:57.127]             if (.Platform$OS.type == "windows") {
[13:19:57.127]                 old_names <- names(...future.oldEnvVars)
[13:19:57.127]                 envs <- base::Sys.getenv()
[13:19:57.127]                 names <- names(envs)
[13:19:57.127]                 common <- intersect(names, old_names)
[13:19:57.127]                 added <- setdiff(names, old_names)
[13:19:57.127]                 removed <- setdiff(old_names, names)
[13:19:57.127]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.127]                   envs[common]]
[13:19:57.127]                 NAMES <- toupper(changed)
[13:19:57.127]                 args <- list()
[13:19:57.127]                 for (kk in seq_along(NAMES)) {
[13:19:57.127]                   name <- changed[[kk]]
[13:19:57.127]                   NAME <- NAMES[[kk]]
[13:19:57.127]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.127]                     next
[13:19:57.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.127]                 }
[13:19:57.127]                 NAMES <- toupper(added)
[13:19:57.127]                 for (kk in seq_along(NAMES)) {
[13:19:57.127]                   name <- added[[kk]]
[13:19:57.127]                   NAME <- NAMES[[kk]]
[13:19:57.127]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.127]                     next
[13:19:57.127]                   args[[name]] <- ""
[13:19:57.127]                 }
[13:19:57.127]                 NAMES <- toupper(removed)
[13:19:57.127]                 for (kk in seq_along(NAMES)) {
[13:19:57.127]                   name <- removed[[kk]]
[13:19:57.127]                   NAME <- NAMES[[kk]]
[13:19:57.127]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.127]                     next
[13:19:57.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.127]                 }
[13:19:57.127]                 if (length(args) > 0) 
[13:19:57.127]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.127]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.127]             }
[13:19:57.127]             else {
[13:19:57.127]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.127]             }
[13:19:57.127]             {
[13:19:57.127]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.127]                   0L) {
[13:19:57.127]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.127]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.127]                   base::options(opts)
[13:19:57.127]                 }
[13:19:57.127]                 {
[13:19:57.127]                   {
[13:19:57.127]                     NULL
[13:19:57.127]                     RNGkind("Mersenne-Twister")
[13:19:57.127]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:57.127]                       inherits = FALSE)
[13:19:57.127]                   }
[13:19:57.127]                   options(future.plan = NULL)
[13:19:57.127]                   if (is.na(NA_character_)) 
[13:19:57.127]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.127]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.127]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:57.127]                   {
[13:19:57.127]                     future <- SequentialFuture(..., envir = envir)
[13:19:57.127]                     if (!future$lazy) 
[13:19:57.127]                       future <- run(future)
[13:19:57.127]                     invisible(future)
[13:19:57.127]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.127]                 }
[13:19:57.127]             }
[13:19:57.127]         }
[13:19:57.127]     })
[13:19:57.127]     if (TRUE) {
[13:19:57.127]         base::sink(type = "output", split = FALSE)
[13:19:57.127]         if (TRUE) {
[13:19:57.127]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.127]         }
[13:19:57.127]         else {
[13:19:57.127]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.127]         }
[13:19:57.127]         base::close(...future.stdout)
[13:19:57.127]         ...future.stdout <- NULL
[13:19:57.127]     }
[13:19:57.127]     ...future.result$conditions <- ...future.conditions
[13:19:57.127]     ...future.result$finished <- base::Sys.time()
[13:19:57.127]     ...future.result
[13:19:57.127] }
[13:19:57.129] assign_globals() ...
[13:19:57.129] List of 5
[13:19:57.129]  $ future.call.arguments    : list()
[13:19:57.129]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.129]  $ ...future.FUN            :function (x)  
[13:19:57.129]  $ ...future.elements_ii    :List of 2
[13:19:57.129]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[13:19:57.129]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[13:19:57.129]  $ ...future.seeds_ii       : NULL
[13:19:57.129]  $ ...future.globals.maxSize: num Inf
[13:19:57.129]  - attr(*, "resolved")= logi FALSE
[13:19:57.129]  - attr(*, "total_size")= num NA
[13:19:57.129]  - attr(*, "where")=List of 5
[13:19:57.129]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.129]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.129]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.129]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.129]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.129]  - attr(*, "already-done")= logi TRUE
[13:19:57.134] - copied ‘future.call.arguments’ to environment
[13:19:57.134] - copied ‘...future.FUN’ to environment
[13:19:57.134] - copied ‘...future.elements_ii’ to environment
[13:19:57.135] - copied ‘...future.seeds_ii’ to environment
[13:19:57.135] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.135] assign_globals() ... done
[13:19:57.135] plan(): Setting new future strategy stack:
[13:19:57.135] List of future strategies:
[13:19:57.135] 1. sequential:
[13:19:57.135]    - args: function (..., envir = parent.frame())
[13:19:57.135]    - tweaked: FALSE
[13:19:57.135]    - call: NULL
[13:19:57.135] plan(): nbrOfWorkers() = 1
[13:19:57.136] plan(): Setting new future strategy stack:
[13:19:57.136] List of future strategies:
[13:19:57.136] 1. sequential:
[13:19:57.136]    - args: function (..., envir = parent.frame())
[13:19:57.136]    - tweaked: FALSE
[13:19:57.136]    - call: plan(strategy)
[13:19:57.138] plan(): nbrOfWorkers() = 1
[13:19:57.139] SequentialFuture started (and completed)
[13:19:57.139] - Launch lazy future ... done
[13:19:57.139] run() for ‘SequentialFuture’ ... done
[13:19:57.139] Created future:
[13:19:57.139] SequentialFuture:
[13:19:57.139] Label: ‘future_apply-1’
[13:19:57.139] Expression:
[13:19:57.139] {
[13:19:57.139]     do.call(function(...) {
[13:19:57.139]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.139]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.139]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.139]             on.exit(options(oopts), add = TRUE)
[13:19:57.139]         }
[13:19:57.139]         {
[13:19:57.139]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.139]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.139]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.139]             })
[13:19:57.139]         }
[13:19:57.139]     }, args = future.call.arguments)
[13:19:57.139] }
[13:19:57.139] Lazy evaluation: FALSE
[13:19:57.139] Asynchronous evaluation: FALSE
[13:19:57.139] Local evaluation: TRUE
[13:19:57.139] Environment: R_GlobalEnv
[13:19:57.139] Capture standard output: TRUE
[13:19:57.139] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.139] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.139] Packages: <none>
[13:19:57.139] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.139] Resolved: TRUE
[13:19:57.139] Value: 496 bytes of class ‘list’
[13:19:57.139] Early signaling: FALSE
[13:19:57.139] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.139] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:57.141] Chunk #1 of 1 ... DONE
[13:19:57.141] Launching 1 futures (chunks) ... DONE
[13:19:57.141] Resolving 1 futures (chunks) ...
[13:19:57.141] resolve() on list ...
[13:19:57.141]  recursive: 0
[13:19:57.141]  length: 1
[13:19:57.141] 
[13:19:57.141] resolved() for ‘SequentialFuture’ ...
[13:19:57.142] - state: ‘finished’
[13:19:57.142] - run: TRUE
[13:19:57.142] - result: ‘FutureResult’
[13:19:57.142] resolved() for ‘SequentialFuture’ ... done
[13:19:57.142] Future #1
[13:19:57.142] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:57.142] - nx: 1
[13:19:57.142] - relay: TRUE
[13:19:57.142] - stdout: TRUE
[13:19:57.142] - signal: TRUE
[13:19:57.143] - resignal: FALSE
[13:19:57.143] - force: TRUE
[13:19:57.143] - relayed: [n=1] FALSE
[13:19:57.143] - queued futures: [n=1] FALSE
[13:19:57.143]  - until=1
[13:19:57.143]  - relaying element #1
[13:19:57.143] - relayed: [n=1] TRUE
[13:19:57.143] - queued futures: [n=1] TRUE
[13:19:57.143] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:57.144]  length: 0 (resolved future 1)
[13:19:57.144] Relaying remaining futures
[13:19:57.144] signalConditionsASAP(NULL, pos=0) ...
[13:19:57.144] - nx: 1
[13:19:57.144] - relay: TRUE
[13:19:57.144] - stdout: TRUE
[13:19:57.144] - signal: TRUE
[13:19:57.144] - resignal: FALSE
[13:19:57.144] - force: TRUE
[13:19:57.144] - relayed: [n=1] TRUE
[13:19:57.145] - queued futures: [n=1] TRUE
 - flush all
[13:19:57.145] - relayed: [n=1] TRUE
[13:19:57.145] - queued futures: [n=1] TRUE
[13:19:57.145] signalConditionsASAP(NULL, pos=0) ... done
[13:19:57.145] resolve() on list ... DONE
[13:19:57.145]  - Number of value chunks collected: 1
[13:19:57.145] Resolving 1 futures (chunks) ... DONE
[13:19:57.145] Reducing values from 1 chunks ...
[13:19:57.145]  - Number of values collected after concatenation: 2
[13:19:57.145]  - Number of values expected: 2
[13:19:57.146] Reducing values from 1 chunks ... DONE
[13:19:57.146] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[13:19:57.146] getGlobalsAndPackagesXApply() ...
[13:19:57.146]  - future.globals: TRUE
[13:19:57.146] getGlobalsAndPackages() ...
[13:19:57.147] Searching for globals...
[13:19:57.150] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[13:19:57.150] Searching for globals ... DONE
[13:19:57.151] Resolving globals: FALSE
[13:19:57.151] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[13:19:57.152] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[13:19:57.152] - globals: [1] ‘FUN’
[13:19:57.152] 
[13:19:57.152] getGlobalsAndPackages() ... DONE
[13:19:57.153]  - globals found/used: [n=1] ‘FUN’
[13:19:57.153]  - needed namespaces: [n=0] 
[13:19:57.153] Finding globals ... DONE
[13:19:57.153]  - use_args: TRUE
[13:19:57.153]  - Getting '...' globals ...
[13:19:57.154] resolve() on list ...
[13:19:57.154]  recursive: 0
[13:19:57.154]  length: 1
[13:19:57.154]  elements: ‘...’
[13:19:57.154]  length: 0 (resolved future 1)
[13:19:57.154] resolve() on list ... DONE
[13:19:57.154]    - '...' content: [n=0] 
[13:19:57.154] List of 1
[13:19:57.154]  $ ...: list()
[13:19:57.154]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.154]  - attr(*, "where")=List of 1
[13:19:57.154]   ..$ ...:<environment: 0x5559206b8a48> 
[13:19:57.154]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.154]  - attr(*, "resolved")= logi TRUE
[13:19:57.154]  - attr(*, "total_size")= num NA
[13:19:57.157]  - Getting '...' globals ... DONE
[13:19:57.157] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:57.157] List of 2
[13:19:57.157]  $ ...future.FUN:function (x)  
[13:19:57.157]  $ ...          : list()
[13:19:57.157]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.157]  - attr(*, "where")=List of 2
[13:19:57.157]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:57.157]   ..$ ...          :<environment: 0x5559206b8a48> 
[13:19:57.157]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.157]  - attr(*, "resolved")= logi FALSE
[13:19:57.157]  - attr(*, "total_size")= num 9888
[13:19:57.160] Packages to be attached in all futures: [n=0] 
[13:19:57.160] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.160] future_lapply() ...
[13:19:57.162] Number of chunks: 1
[13:19:57.162] getGlobalsAndPackagesXApply() ...
[13:19:57.162]  - future.globals: <name-value list> with names ‘list()’
[13:19:57.162]  - use_args: TRUE
[13:19:57.163] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:57.163] List of 2
[13:19:57.163]  $ ...          : list()
[13:19:57.163]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.163]  $ ...future.FUN:function (x)  
[13:19:57.163]  - attr(*, "where")=List of 2
[13:19:57.163]   ..$ ...          :<environment: 0x5559206b8a48> 
[13:19:57.163]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:19:57.163]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.163]  - attr(*, "resolved")= logi FALSE
[13:19:57.163]  - attr(*, "total_size")= num NA
[13:19:57.168] Packages to be attached in all futures: [n=0] 
[13:19:57.168] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.168] Number of futures (= number of chunks): 1
[13:19:57.168] Launching 1 futures (chunks) ...
[13:19:57.168] Chunk #1 of 1 ...
[13:19:57.168]  - seeds: <none>
[13:19:57.168]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.169] getGlobalsAndPackages() ...
[13:19:57.169] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.169] Resolving globals: FALSE
[13:19:57.169] Tweak future expression to call with '...' arguments ...
[13:19:57.169] {
[13:19:57.169]     do.call(function(...) {
[13:19:57.169]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.169]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.169]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.169]             on.exit(options(oopts), add = TRUE)
[13:19:57.169]         }
[13:19:57.169]         {
[13:19:57.169]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.169]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.169]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.169]             })
[13:19:57.169]         }
[13:19:57.169]     }, args = future.call.arguments)
[13:19:57.169] }
[13:19:57.169] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.170] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.170] 
[13:19:57.170] getGlobalsAndPackages() ... DONE
[13:19:57.170] run() for ‘Future’ ...
[13:19:57.170] - state: ‘created’
[13:19:57.170] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:57.171] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:57.171] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:57.171]   - Field: ‘label’
[13:19:57.171]   - Field: ‘local’
[13:19:57.171]   - Field: ‘owner’
[13:19:57.171]   - Field: ‘envir’
[13:19:57.171]   - Field: ‘packages’
[13:19:57.171]   - Field: ‘gc’
[13:19:57.172]   - Field: ‘conditions’
[13:19:57.172]   - Field: ‘expr’
[13:19:57.172]   - Field: ‘uuid’
[13:19:57.172]   - Field: ‘seed’
[13:19:57.172]   - Field: ‘version’
[13:19:57.172]   - Field: ‘result’
[13:19:57.172]   - Field: ‘asynchronous’
[13:19:57.172]   - Field: ‘calls’
[13:19:57.172]   - Field: ‘globals’
[13:19:57.172]   - Field: ‘stdout’
[13:19:57.173]   - Field: ‘earlySignal’
[13:19:57.173]   - Field: ‘lazy’
[13:19:57.173]   - Field: ‘state’
[13:19:57.173] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:57.173] - Launch lazy future ...
[13:19:57.173] Packages needed by the future expression (n = 0): <none>
[13:19:57.173] Packages needed by future strategies (n = 0): <none>
[13:19:57.174] {
[13:19:57.174]     {
[13:19:57.174]         {
[13:19:57.174]             ...future.startTime <- base::Sys.time()
[13:19:57.174]             {
[13:19:57.174]                 {
[13:19:57.174]                   {
[13:19:57.174]                     base::local({
[13:19:57.174]                       has_future <- base::requireNamespace("future", 
[13:19:57.174]                         quietly = TRUE)
[13:19:57.174]                       if (has_future) {
[13:19:57.174]                         ns <- base::getNamespace("future")
[13:19:57.174]                         version <- ns[[".package"]][["version"]]
[13:19:57.174]                         if (is.null(version)) 
[13:19:57.174]                           version <- utils::packageVersion("future")
[13:19:57.174]                       }
[13:19:57.174]                       else {
[13:19:57.174]                         version <- NULL
[13:19:57.174]                       }
[13:19:57.174]                       if (!has_future || version < "1.8.0") {
[13:19:57.174]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.174]                           "", base::R.version$version.string), 
[13:19:57.174]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:57.174]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.174]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.174]                             "release", "version")], collapse = " "), 
[13:19:57.174]                           hostname = base::Sys.info()[["nodename"]])
[13:19:57.174]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.174]                           info)
[13:19:57.174]                         info <- base::paste(info, collapse = "; ")
[13:19:57.174]                         if (!has_future) {
[13:19:57.174]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.174]                             info)
[13:19:57.174]                         }
[13:19:57.174]                         else {
[13:19:57.174]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.174]                             info, version)
[13:19:57.174]                         }
[13:19:57.174]                         base::stop(msg)
[13:19:57.174]                       }
[13:19:57.174]                     })
[13:19:57.174]                   }
[13:19:57.174]                   options(future.plan = NULL)
[13:19:57.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.174]                 }
[13:19:57.174]                 ...future.workdir <- getwd()
[13:19:57.174]             }
[13:19:57.174]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.174]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.174]         }
[13:19:57.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.174]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.174]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.174]             base::names(...future.oldOptions))
[13:19:57.174]     }
[13:19:57.174]     if (FALSE) {
[13:19:57.174]     }
[13:19:57.174]     else {
[13:19:57.174]         if (TRUE) {
[13:19:57.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.174]                 open = "w")
[13:19:57.174]         }
[13:19:57.174]         else {
[13:19:57.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.174]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.174]         }
[13:19:57.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.174]             base::sink(type = "output", split = FALSE)
[13:19:57.174]             base::close(...future.stdout)
[13:19:57.174]         }, add = TRUE)
[13:19:57.174]     }
[13:19:57.174]     ...future.frame <- base::sys.nframe()
[13:19:57.174]     ...future.conditions <- base::list()
[13:19:57.174]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.174]     if (FALSE) {
[13:19:57.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.174]     }
[13:19:57.174]     ...future.result <- base::tryCatch({
[13:19:57.174]         base::withCallingHandlers({
[13:19:57.174]             ...future.value <- base::withVisible(base::local({
[13:19:57.174]                 do.call(function(...) {
[13:19:57.174]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.174]                   if (!identical(...future.globals.maxSize.org, 
[13:19:57.174]                     ...future.globals.maxSize)) {
[13:19:57.174]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.174]                     on.exit(options(oopts), add = TRUE)
[13:19:57.174]                   }
[13:19:57.174]                   {
[13:19:57.174]                     lapply(seq_along(...future.elements_ii), 
[13:19:57.174]                       FUN = function(jj) {
[13:19:57.174]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.174]                         ...future.FUN(...future.X_jj, ...)
[13:19:57.174]                       })
[13:19:57.174]                   }
[13:19:57.174]                 }, args = future.call.arguments)
[13:19:57.174]             }))
[13:19:57.174]             future::FutureResult(value = ...future.value$value, 
[13:19:57.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.174]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.174]                     ...future.globalenv.names))
[13:19:57.174]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.174]         }, condition = base::local({
[13:19:57.174]             c <- base::c
[13:19:57.174]             inherits <- base::inherits
[13:19:57.174]             invokeRestart <- base::invokeRestart
[13:19:57.174]             length <- base::length
[13:19:57.174]             list <- base::list
[13:19:57.174]             seq.int <- base::seq.int
[13:19:57.174]             signalCondition <- base::signalCondition
[13:19:57.174]             sys.calls <- base::sys.calls
[13:19:57.174]             `[[` <- base::`[[`
[13:19:57.174]             `+` <- base::`+`
[13:19:57.174]             `<<-` <- base::`<<-`
[13:19:57.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.174]                   3L)]
[13:19:57.174]             }
[13:19:57.174]             function(cond) {
[13:19:57.174]                 is_error <- inherits(cond, "error")
[13:19:57.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.174]                   NULL)
[13:19:57.174]                 if (is_error) {
[13:19:57.174]                   sessionInformation <- function() {
[13:19:57.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.174]                       search = base::search(), system = base::Sys.info())
[13:19:57.174]                   }
[13:19:57.174]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.174]                     cond$call), session = sessionInformation(), 
[13:19:57.174]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.174]                   signalCondition(cond)
[13:19:57.174]                 }
[13:19:57.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.174]                 "immediateCondition"))) {
[13:19:57.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.174]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.174]                   if (TRUE && !signal) {
[13:19:57.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.174]                     {
[13:19:57.174]                       inherits <- base::inherits
[13:19:57.174]                       invokeRestart <- base::invokeRestart
[13:19:57.174]                       is.null <- base::is.null
[13:19:57.174]                       muffled <- FALSE
[13:19:57.174]                       if (inherits(cond, "message")) {
[13:19:57.174]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.174]                         if (muffled) 
[13:19:57.174]                           invokeRestart("muffleMessage")
[13:19:57.174]                       }
[13:19:57.174]                       else if (inherits(cond, "warning")) {
[13:19:57.174]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.174]                         if (muffled) 
[13:19:57.174]                           invokeRestart("muffleWarning")
[13:19:57.174]                       }
[13:19:57.174]                       else if (inherits(cond, "condition")) {
[13:19:57.174]                         if (!is.null(pattern)) {
[13:19:57.174]                           computeRestarts <- base::computeRestarts
[13:19:57.174]                           grepl <- base::grepl
[13:19:57.174]                           restarts <- computeRestarts(cond)
[13:19:57.174]                           for (restart in restarts) {
[13:19:57.174]                             name <- restart$name
[13:19:57.174]                             if (is.null(name)) 
[13:19:57.174]                               next
[13:19:57.174]                             if (!grepl(pattern, name)) 
[13:19:57.174]                               next
[13:19:57.174]                             invokeRestart(restart)
[13:19:57.174]                             muffled <- TRUE
[13:19:57.174]                             break
[13:19:57.174]                           }
[13:19:57.174]                         }
[13:19:57.174]                       }
[13:19:57.174]                       invisible(muffled)
[13:19:57.174]                     }
[13:19:57.174]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.174]                   }
[13:19:57.174]                 }
[13:19:57.174]                 else {
[13:19:57.174]                   if (TRUE) {
[13:19:57.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.174]                     {
[13:19:57.174]                       inherits <- base::inherits
[13:19:57.174]                       invokeRestart <- base::invokeRestart
[13:19:57.174]                       is.null <- base::is.null
[13:19:57.174]                       muffled <- FALSE
[13:19:57.174]                       if (inherits(cond, "message")) {
[13:19:57.174]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.174]                         if (muffled) 
[13:19:57.174]                           invokeRestart("muffleMessage")
[13:19:57.174]                       }
[13:19:57.174]                       else if (inherits(cond, "warning")) {
[13:19:57.174]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.174]                         if (muffled) 
[13:19:57.174]                           invokeRestart("muffleWarning")
[13:19:57.174]                       }
[13:19:57.174]                       else if (inherits(cond, "condition")) {
[13:19:57.174]                         if (!is.null(pattern)) {
[13:19:57.174]                           computeRestarts <- base::computeRestarts
[13:19:57.174]                           grepl <- base::grepl
[13:19:57.174]                           restarts <- computeRestarts(cond)
[13:19:57.174]                           for (restart in restarts) {
[13:19:57.174]                             name <- restart$name
[13:19:57.174]                             if (is.null(name)) 
[13:19:57.174]                               next
[13:19:57.174]                             if (!grepl(pattern, name)) 
[13:19:57.174]                               next
[13:19:57.174]                             invokeRestart(restart)
[13:19:57.174]                             muffled <- TRUE
[13:19:57.174]                             break
[13:19:57.174]                           }
[13:19:57.174]                         }
[13:19:57.174]                       }
[13:19:57.174]                       invisible(muffled)
[13:19:57.174]                     }
[13:19:57.174]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.174]                   }
[13:19:57.174]                 }
[13:19:57.174]             }
[13:19:57.174]         }))
[13:19:57.174]     }, error = function(ex) {
[13:19:57.174]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.174]                 ...future.rng), started = ...future.startTime, 
[13:19:57.174]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.174]             version = "1.8"), class = "FutureResult")
[13:19:57.174]     }, finally = {
[13:19:57.174]         if (!identical(...future.workdir, getwd())) 
[13:19:57.174]             setwd(...future.workdir)
[13:19:57.174]         {
[13:19:57.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.174]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.174]             }
[13:19:57.174]             base::options(...future.oldOptions)
[13:19:57.174]             if (.Platform$OS.type == "windows") {
[13:19:57.174]                 old_names <- names(...future.oldEnvVars)
[13:19:57.174]                 envs <- base::Sys.getenv()
[13:19:57.174]                 names <- names(envs)
[13:19:57.174]                 common <- intersect(names, old_names)
[13:19:57.174]                 added <- setdiff(names, old_names)
[13:19:57.174]                 removed <- setdiff(old_names, names)
[13:19:57.174]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.174]                   envs[common]]
[13:19:57.174]                 NAMES <- toupper(changed)
[13:19:57.174]                 args <- list()
[13:19:57.174]                 for (kk in seq_along(NAMES)) {
[13:19:57.174]                   name <- changed[[kk]]
[13:19:57.174]                   NAME <- NAMES[[kk]]
[13:19:57.174]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.174]                     next
[13:19:57.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.174]                 }
[13:19:57.174]                 NAMES <- toupper(added)
[13:19:57.174]                 for (kk in seq_along(NAMES)) {
[13:19:57.174]                   name <- added[[kk]]
[13:19:57.174]                   NAME <- NAMES[[kk]]
[13:19:57.174]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.174]                     next
[13:19:57.174]                   args[[name]] <- ""
[13:19:57.174]                 }
[13:19:57.174]                 NAMES <- toupper(removed)
[13:19:57.174]                 for (kk in seq_along(NAMES)) {
[13:19:57.174]                   name <- removed[[kk]]
[13:19:57.174]                   NAME <- NAMES[[kk]]
[13:19:57.174]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.174]                     next
[13:19:57.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.174]                 }
[13:19:57.174]                 if (length(args) > 0) 
[13:19:57.174]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.174]             }
[13:19:57.174]             else {
[13:19:57.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.174]             }
[13:19:57.174]             {
[13:19:57.174]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.174]                   0L) {
[13:19:57.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.174]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.174]                   base::options(opts)
[13:19:57.174]                 }
[13:19:57.174]                 {
[13:19:57.174]                   {
[13:19:57.174]                     NULL
[13:19:57.174]                     RNGkind("Mersenne-Twister")
[13:19:57.174]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:57.174]                       inherits = FALSE)
[13:19:57.174]                   }
[13:19:57.174]                   options(future.plan = NULL)
[13:19:57.174]                   if (is.na(NA_character_)) 
[13:19:57.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.174]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:57.174]                   {
[13:19:57.174]                     future <- SequentialFuture(..., envir = envir)
[13:19:57.174]                     if (!future$lazy) 
[13:19:57.174]                       future <- run(future)
[13:19:57.174]                     invisible(future)
[13:19:57.174]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.174]                 }
[13:19:57.174]             }
[13:19:57.174]         }
[13:19:57.174]     })
[13:19:57.174]     if (TRUE) {
[13:19:57.174]         base::sink(type = "output", split = FALSE)
[13:19:57.174]         if (TRUE) {
[13:19:57.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.174]         }
[13:19:57.174]         else {
[13:19:57.174]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.174]         }
[13:19:57.174]         base::close(...future.stdout)
[13:19:57.174]         ...future.stdout <- NULL
[13:19:57.174]     }
[13:19:57.174]     ...future.result$conditions <- ...future.conditions
[13:19:57.174]     ...future.result$finished <- base::Sys.time()
[13:19:57.174]     ...future.result
[13:19:57.174] }
[13:19:57.176] assign_globals() ...
[13:19:57.176] List of 5
[13:19:57.176]  $ future.call.arguments    : list()
[13:19:57.176]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.176]  $ ...future.FUN            :function (x)  
[13:19:57.176]  $ ...future.elements_ii    :List of 2
[13:19:57.176]   ..$ : int [1:2] 1 3
[13:19:57.176]   ..$ : int [1:2] 2 4
[13:19:57.176]  $ ...future.seeds_ii       : NULL
[13:19:57.176]  $ ...future.globals.maxSize: num Inf
[13:19:57.176]  - attr(*, "resolved")= logi FALSE
[13:19:57.176]  - attr(*, "total_size")= num NA
[13:19:57.176]  - attr(*, "where")=List of 5
[13:19:57.176]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.176]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.176]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.176]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.176]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.176]  - attr(*, "already-done")= logi TRUE
[13:19:57.181] - copied ‘future.call.arguments’ to environment
[13:19:57.181] - reassign environment for ‘...future.FUN’
[13:19:57.181] - copied ‘...future.FUN’ to environment
[13:19:57.181] - copied ‘...future.elements_ii’ to environment
[13:19:57.181] - copied ‘...future.seeds_ii’ to environment
[13:19:57.181] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.181] assign_globals() ... done
[13:19:57.182] plan(): Setting new future strategy stack:
[13:19:57.182] List of future strategies:
[13:19:57.182] 1. sequential:
[13:19:57.182]    - args: function (..., envir = parent.frame())
[13:19:57.182]    - tweaked: FALSE
[13:19:57.182]    - call: NULL
[13:19:57.182] plan(): nbrOfWorkers() = 1
[13:19:57.183] plan(): Setting new future strategy stack:
[13:19:57.183] List of future strategies:
[13:19:57.183] 1. sequential:
[13:19:57.183]    - args: function (..., envir = parent.frame())
[13:19:57.183]    - tweaked: FALSE
[13:19:57.183]    - call: plan(strategy)
[13:19:57.183] plan(): nbrOfWorkers() = 1
[13:19:57.183] SequentialFuture started (and completed)
[13:19:57.184] - Launch lazy future ... done
[13:19:57.184] run() for ‘SequentialFuture’ ... done
[13:19:57.184] Created future:
[13:19:57.184] SequentialFuture:
[13:19:57.184] Label: ‘future_apply-1’
[13:19:57.184] Expression:
[13:19:57.184] {
[13:19:57.184]     do.call(function(...) {
[13:19:57.184]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.184]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.184]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.184]             on.exit(options(oopts), add = TRUE)
[13:19:57.184]         }
[13:19:57.184]         {
[13:19:57.184]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.184]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.184]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.184]             })
[13:19:57.184]         }
[13:19:57.184]     }, args = future.call.arguments)
[13:19:57.184] }
[13:19:57.184] Lazy evaluation: FALSE
[13:19:57.184] Asynchronous evaluation: FALSE
[13:19:57.184] Local evaluation: TRUE
[13:19:57.184] Environment: R_GlobalEnv
[13:19:57.184] Capture standard output: TRUE
[13:19:57.184] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.184] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.184] Packages: <none>
[13:19:57.184] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.184] Resolved: TRUE
[13:19:57.184] Value: 400 bytes of class ‘list’
[13:19:57.184] Early signaling: FALSE
[13:19:57.184] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.184] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:57.185] Chunk #1 of 1 ... DONE
[13:19:57.185] Launching 1 futures (chunks) ... DONE
[13:19:57.185] Resolving 1 futures (chunks) ...
[13:19:57.185] resolve() on list ...
[13:19:57.185]  recursive: 0
[13:19:57.186]  length: 1
[13:19:57.186] 
[13:19:57.186] resolved() for ‘SequentialFuture’ ...
[13:19:57.186] - state: ‘finished’
[13:19:57.186] - run: TRUE
[13:19:57.186] - result: ‘FutureResult’
[13:19:57.186] resolved() for ‘SequentialFuture’ ... done
[13:19:57.186] Future #1
[13:19:57.186] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:57.186] - nx: 1
[13:19:57.187] - relay: TRUE
[13:19:57.187] - stdout: TRUE
[13:19:57.187] - signal: TRUE
[13:19:57.187] - resignal: FALSE
[13:19:57.187] - force: TRUE
[13:19:57.187] - relayed: [n=1] FALSE
[13:19:57.187] - queued futures: [n=1] FALSE
[13:19:57.187]  - until=1
[13:19:57.187]  - relaying element #1
[13:19:57.187] - relayed: [n=1] TRUE
[13:19:57.188] - queued futures: [n=1] TRUE
[13:19:57.188] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:57.188]  length: 0 (resolved future 1)
[13:19:57.188] Relaying remaining futures
[13:19:57.188] signalConditionsASAP(NULL, pos=0) ...
[13:19:57.188] - nx: 1
[13:19:57.188] - relay: TRUE
[13:19:57.188] - stdout: TRUE
[13:19:57.188] - signal: TRUE
[13:19:57.188] - resignal: FALSE
[13:19:57.188] - force: TRUE
[13:19:57.189] - relayed: [n=1] TRUE
[13:19:57.189] - queued futures: [n=1] TRUE
 - flush all
[13:19:57.189] - relayed: [n=1] TRUE
[13:19:57.189] - queued futures: [n=1] TRUE
[13:19:57.189] signalConditionsASAP(NULL, pos=0) ... done
[13:19:57.189] resolve() on list ... DONE
[13:19:57.189]  - Number of value chunks collected: 1
[13:19:57.189] Resolving 1 futures (chunks) ... DONE
[13:19:57.189] Reducing values from 1 chunks ...
[13:19:57.189]  - Number of values collected after concatenation: 2
[13:19:57.190]  - Number of values expected: 2
[13:19:57.190] Reducing values from 1 chunks ... DONE
[13:19:57.190] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[13:19:57.192] getGlobalsAndPackagesXApply() ...
[13:19:57.192]  - future.globals: TRUE
[13:19:57.192] getGlobalsAndPackages() ...
[13:19:57.192] Searching for globals...
[13:19:57.195] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[13:19:57.195] Searching for globals ... DONE
[13:19:57.196] Resolving globals: FALSE
[13:19:57.196] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[13:19:57.197] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[13:19:57.197] - globals: [1] ‘FUN’
[13:19:57.197] 
[13:19:57.197] getGlobalsAndPackages() ... DONE
[13:19:57.197]  - globals found/used: [n=1] ‘FUN’
[13:19:57.197]  - needed namespaces: [n=0] 
[13:19:57.197] Finding globals ... DONE
[13:19:57.197]  - use_args: TRUE
[13:19:57.197]  - Getting '...' globals ...
[13:19:57.198] resolve() on list ...
[13:19:57.198]  recursive: 0
[13:19:57.198]  length: 1
[13:19:57.198]  elements: ‘...’
[13:19:57.198]  length: 0 (resolved future 1)
[13:19:57.198] resolve() on list ... DONE
[13:19:57.198]    - '...' content: [n=0] 
[13:19:57.198] List of 1
[13:19:57.198]  $ ...: list()
[13:19:57.198]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.198]  - attr(*, "where")=List of 1
[13:19:57.198]   ..$ ...:<environment: 0x555920666338> 
[13:19:57.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.198]  - attr(*, "resolved")= logi TRUE
[13:19:57.198]  - attr(*, "total_size")= num NA
[13:19:57.201]  - Getting '...' globals ... DONE
[13:19:57.201] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:57.201] List of 2
[13:19:57.201]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:19:57.201]  $ ...          : list()
[13:19:57.201]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.201]  - attr(*, "where")=List of 2
[13:19:57.201]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:57.201]   ..$ ...          :<environment: 0x555920666338> 
[13:19:57.201]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.201]  - attr(*, "resolved")= logi FALSE
[13:19:57.201]  - attr(*, "total_size")= num 36296
[13:19:57.204] Packages to be attached in all futures: [n=0] 
[13:19:57.204] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.204] future_lapply() ...
[13:19:57.206] Generating random seeds ...
[13:19:57.206] Generating random seed streams for 2 elements ...
[13:19:57.207] Generating random seed streams for 2 elements ... DONE
[13:19:57.207] Generating random seeds ... DONE
[13:19:57.207] Will set RNG state on exit: 10407, 2085122710, 1372392505, -437060613, -1809204027, -1362710056, -1450170233
[13:19:57.207] Number of chunks: 1
[13:19:57.207] getGlobalsAndPackagesXApply() ...
[13:19:57.207]  - future.globals: <name-value list> with names ‘list()’
[13:19:57.207]  - use_args: TRUE
[13:19:57.208] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:57.208] List of 2
[13:19:57.208]  $ ...          : list()
[13:19:57.208]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.208]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:19:57.208]  - attr(*, "where")=List of 2
[13:19:57.208]   ..$ ...          :<environment: 0x555920666338> 
[13:19:57.208]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:57.208]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.208]  - attr(*, "resolved")= logi FALSE
[13:19:57.208]  - attr(*, "total_size")= num NA
[13:19:57.211] Packages to be attached in all futures: [n=0] 
[13:19:57.211] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.211] Number of futures (= number of chunks): 1
[13:19:57.211] Launching 1 futures (chunks) ...
[13:19:57.212] Chunk #1 of 1 ...
[13:19:57.212]  - seeds: [2] <seeds>
[13:19:57.212]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.212] getGlobalsAndPackages() ...
[13:19:57.212] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.212] Resolving globals: FALSE
[13:19:57.212] Tweak future expression to call with '...' arguments ...
[13:19:57.212] {
[13:19:57.212]     do.call(function(...) {
[13:19:57.212]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.212]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.212]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.212]             on.exit(options(oopts), add = TRUE)
[13:19:57.212]         }
[13:19:57.212]         {
[13:19:57.212]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.212]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.212]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:19:57.212]                   envir = globalenv(), inherits = FALSE)
[13:19:57.212]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.212]             })
[13:19:57.212]         }
[13:19:57.212]     }, args = future.call.arguments)
[13:19:57.212] }
[13:19:57.213] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.213] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.213] 
[13:19:57.213] getGlobalsAndPackages() ... DONE
[13:19:57.214] run() for ‘Future’ ...
[13:19:57.214] - state: ‘created’
[13:19:57.215] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:57.215] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:57.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:57.216]   - Field: ‘label’
[13:19:57.216]   - Field: ‘local’
[13:19:57.216]   - Field: ‘owner’
[13:19:57.216]   - Field: ‘envir’
[13:19:57.216]   - Field: ‘packages’
[13:19:57.216]   - Field: ‘gc’
[13:19:57.217]   - Field: ‘conditions’
[13:19:57.217]   - Field: ‘expr’
[13:19:57.217]   - Field: ‘uuid’
[13:19:57.217]   - Field: ‘seed’
[13:19:57.217]   - Field: ‘version’
[13:19:57.217]   - Field: ‘result’
[13:19:57.217]   - Field: ‘asynchronous’
[13:19:57.217]   - Field: ‘calls’
[13:19:57.217]   - Field: ‘globals’
[13:19:57.217]   - Field: ‘stdout’
[13:19:57.218]   - Field: ‘earlySignal’
[13:19:57.218]   - Field: ‘lazy’
[13:19:57.218]   - Field: ‘state’
[13:19:57.218] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:57.218] - Launch lazy future ...
[13:19:57.218] Packages needed by the future expression (n = 0): <none>
[13:19:57.218] Packages needed by future strategies (n = 0): <none>
[13:19:57.219] {
[13:19:57.219]     {
[13:19:57.219]         {
[13:19:57.219]             ...future.startTime <- base::Sys.time()
[13:19:57.219]             {
[13:19:57.219]                 {
[13:19:57.219]                   {
[13:19:57.219]                     base::local({
[13:19:57.219]                       has_future <- base::requireNamespace("future", 
[13:19:57.219]                         quietly = TRUE)
[13:19:57.219]                       if (has_future) {
[13:19:57.219]                         ns <- base::getNamespace("future")
[13:19:57.219]                         version <- ns[[".package"]][["version"]]
[13:19:57.219]                         if (is.null(version)) 
[13:19:57.219]                           version <- utils::packageVersion("future")
[13:19:57.219]                       }
[13:19:57.219]                       else {
[13:19:57.219]                         version <- NULL
[13:19:57.219]                       }
[13:19:57.219]                       if (!has_future || version < "1.8.0") {
[13:19:57.219]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.219]                           "", base::R.version$version.string), 
[13:19:57.219]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:57.219]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.219]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.219]                             "release", "version")], collapse = " "), 
[13:19:57.219]                           hostname = base::Sys.info()[["nodename"]])
[13:19:57.219]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.219]                           info)
[13:19:57.219]                         info <- base::paste(info, collapse = "; ")
[13:19:57.219]                         if (!has_future) {
[13:19:57.219]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.219]                             info)
[13:19:57.219]                         }
[13:19:57.219]                         else {
[13:19:57.219]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.219]                             info, version)
[13:19:57.219]                         }
[13:19:57.219]                         base::stop(msg)
[13:19:57.219]                       }
[13:19:57.219]                     })
[13:19:57.219]                   }
[13:19:57.219]                   options(future.plan = NULL)
[13:19:57.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.219]                 }
[13:19:57.219]                 ...future.workdir <- getwd()
[13:19:57.219]             }
[13:19:57.219]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.219]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.219]         }
[13:19:57.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.219]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.219]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.219]             base::names(...future.oldOptions))
[13:19:57.219]     }
[13:19:57.219]     if (FALSE) {
[13:19:57.219]     }
[13:19:57.219]     else {
[13:19:57.219]         if (TRUE) {
[13:19:57.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.219]                 open = "w")
[13:19:57.219]         }
[13:19:57.219]         else {
[13:19:57.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.219]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.219]         }
[13:19:57.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.219]             base::sink(type = "output", split = FALSE)
[13:19:57.219]             base::close(...future.stdout)
[13:19:57.219]         }, add = TRUE)
[13:19:57.219]     }
[13:19:57.219]     ...future.frame <- base::sys.nframe()
[13:19:57.219]     ...future.conditions <- base::list()
[13:19:57.219]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.219]     if (FALSE) {
[13:19:57.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.219]     }
[13:19:57.219]     ...future.result <- base::tryCatch({
[13:19:57.219]         base::withCallingHandlers({
[13:19:57.219]             ...future.value <- base::withVisible(base::local({
[13:19:57.219]                 do.call(function(...) {
[13:19:57.219]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.219]                   if (!identical(...future.globals.maxSize.org, 
[13:19:57.219]                     ...future.globals.maxSize)) {
[13:19:57.219]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.219]                     on.exit(options(oopts), add = TRUE)
[13:19:57.219]                   }
[13:19:57.219]                   {
[13:19:57.219]                     lapply(seq_along(...future.elements_ii), 
[13:19:57.219]                       FUN = function(jj) {
[13:19:57.219]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.219]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:19:57.219]                           envir = globalenv(), inherits = FALSE)
[13:19:57.219]                         ...future.FUN(...future.X_jj, ...)
[13:19:57.219]                       })
[13:19:57.219]                   }
[13:19:57.219]                 }, args = future.call.arguments)
[13:19:57.219]             }))
[13:19:57.219]             future::FutureResult(value = ...future.value$value, 
[13:19:57.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.219]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.219]                     ...future.globalenv.names))
[13:19:57.219]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.219]         }, condition = base::local({
[13:19:57.219]             c <- base::c
[13:19:57.219]             inherits <- base::inherits
[13:19:57.219]             invokeRestart <- base::invokeRestart
[13:19:57.219]             length <- base::length
[13:19:57.219]             list <- base::list
[13:19:57.219]             seq.int <- base::seq.int
[13:19:57.219]             signalCondition <- base::signalCondition
[13:19:57.219]             sys.calls <- base::sys.calls
[13:19:57.219]             `[[` <- base::`[[`
[13:19:57.219]             `+` <- base::`+`
[13:19:57.219]             `<<-` <- base::`<<-`
[13:19:57.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.219]                   3L)]
[13:19:57.219]             }
[13:19:57.219]             function(cond) {
[13:19:57.219]                 is_error <- inherits(cond, "error")
[13:19:57.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.219]                   NULL)
[13:19:57.219]                 if (is_error) {
[13:19:57.219]                   sessionInformation <- function() {
[13:19:57.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.219]                       search = base::search(), system = base::Sys.info())
[13:19:57.219]                   }
[13:19:57.219]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.219]                     cond$call), session = sessionInformation(), 
[13:19:57.219]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.219]                   signalCondition(cond)
[13:19:57.219]                 }
[13:19:57.219]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[13:19:57.219]                   signal <- TRUE && inherits(cond, character(0))
[13:19:57.219]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.219]                   if (TRUE && !signal) {
[13:19:57.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.219]                     {
[13:19:57.219]                       inherits <- base::inherits
[13:19:57.219]                       invokeRestart <- base::invokeRestart
[13:19:57.219]                       is.null <- base::is.null
[13:19:57.219]                       muffled <- FALSE
[13:19:57.219]                       if (inherits(cond, "message")) {
[13:19:57.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.219]                         if (muffled) 
[13:19:57.219]                           invokeRestart("muffleMessage")
[13:19:57.219]                       }
[13:19:57.219]                       else if (inherits(cond, "warning")) {
[13:19:57.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.219]                         if (muffled) 
[13:19:57.219]                           invokeRestart("muffleWarning")
[13:19:57.219]                       }
[13:19:57.219]                       else if (inherits(cond, "condition")) {
[13:19:57.219]                         if (!is.null(pattern)) {
[13:19:57.219]                           computeRestarts <- base::computeRestarts
[13:19:57.219]                           grepl <- base::grepl
[13:19:57.219]                           restarts <- computeRestarts(cond)
[13:19:57.219]                           for (restart in restarts) {
[13:19:57.219]                             name <- restart$name
[13:19:57.219]                             if (is.null(name)) 
[13:19:57.219]                               next
[13:19:57.219]                             if (!grepl(pattern, name)) 
[13:19:57.219]                               next
[13:19:57.219]                             invokeRestart(restart)
[13:19:57.219]                             muffled <- TRUE
[13:19:57.219]                             break
[13:19:57.219]                           }
[13:19:57.219]                         }
[13:19:57.219]                       }
[13:19:57.219]                       invisible(muffled)
[13:19:57.219]                     }
[13:19:57.219]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.219]                   }
[13:19:57.219]                 }
[13:19:57.219]                 else {
[13:19:57.219]                   if (FALSE) {
[13:19:57.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.219]                     {
[13:19:57.219]                       inherits <- base::inherits
[13:19:57.219]                       invokeRestart <- base::invokeRestart
[13:19:57.219]                       is.null <- base::is.null
[13:19:57.219]                       muffled <- FALSE
[13:19:57.219]                       if (inherits(cond, "message")) {
[13:19:57.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.219]                         if (muffled) 
[13:19:57.219]                           invokeRestart("muffleMessage")
[13:19:57.219]                       }
[13:19:57.219]                       else if (inherits(cond, "warning")) {
[13:19:57.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.219]                         if (muffled) 
[13:19:57.219]                           invokeRestart("muffleWarning")
[13:19:57.219]                       }
[13:19:57.219]                       else if (inherits(cond, "condition")) {
[13:19:57.219]                         if (!is.null(pattern)) {
[13:19:57.219]                           computeRestarts <- base::computeRestarts
[13:19:57.219]                           grepl <- base::grepl
[13:19:57.219]                           restarts <- computeRestarts(cond)
[13:19:57.219]                           for (restart in restarts) {
[13:19:57.219]                             name <- restart$name
[13:19:57.219]                             if (is.null(name)) 
[13:19:57.219]                               next
[13:19:57.219]                             if (!grepl(pattern, name)) 
[13:19:57.219]                               next
[13:19:57.219]                             invokeRestart(restart)
[13:19:57.219]                             muffled <- TRUE
[13:19:57.219]                             break
[13:19:57.219]                           }
[13:19:57.219]                         }
[13:19:57.219]                       }
[13:19:57.219]                       invisible(muffled)
[13:19:57.219]                     }
[13:19:57.219]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.219]                   }
[13:19:57.219]                 }
[13:19:57.219]             }
[13:19:57.219]         }))
[13:19:57.219]     }, error = function(ex) {
[13:19:57.219]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.219]                 ...future.rng), started = ...future.startTime, 
[13:19:57.219]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.219]             version = "1.8"), class = "FutureResult")
[13:19:57.219]     }, finally = {
[13:19:57.219]         if (!identical(...future.workdir, getwd())) 
[13:19:57.219]             setwd(...future.workdir)
[13:19:57.219]         {
[13:19:57.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.219]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.219]             }
[13:19:57.219]             base::options(...future.oldOptions)
[13:19:57.219]             if (.Platform$OS.type == "windows") {
[13:19:57.219]                 old_names <- names(...future.oldEnvVars)
[13:19:57.219]                 envs <- base::Sys.getenv()
[13:19:57.219]                 names <- names(envs)
[13:19:57.219]                 common <- intersect(names, old_names)
[13:19:57.219]                 added <- setdiff(names, old_names)
[13:19:57.219]                 removed <- setdiff(old_names, names)
[13:19:57.219]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.219]                   envs[common]]
[13:19:57.219]                 NAMES <- toupper(changed)
[13:19:57.219]                 args <- list()
[13:19:57.219]                 for (kk in seq_along(NAMES)) {
[13:19:57.219]                   name <- changed[[kk]]
[13:19:57.219]                   NAME <- NAMES[[kk]]
[13:19:57.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.219]                     next
[13:19:57.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.219]                 }
[13:19:57.219]                 NAMES <- toupper(added)
[13:19:57.219]                 for (kk in seq_along(NAMES)) {
[13:19:57.219]                   name <- added[[kk]]
[13:19:57.219]                   NAME <- NAMES[[kk]]
[13:19:57.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.219]                     next
[13:19:57.219]                   args[[name]] <- ""
[13:19:57.219]                 }
[13:19:57.219]                 NAMES <- toupper(removed)
[13:19:57.219]                 for (kk in seq_along(NAMES)) {
[13:19:57.219]                   name <- removed[[kk]]
[13:19:57.219]                   NAME <- NAMES[[kk]]
[13:19:57.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.219]                     next
[13:19:57.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.219]                 }
[13:19:57.219]                 if (length(args) > 0) 
[13:19:57.219]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.219]             }
[13:19:57.219]             else {
[13:19:57.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.219]             }
[13:19:57.219]             {
[13:19:57.219]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.219]                   0L) {
[13:19:57.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.219]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.219]                   base::options(opts)
[13:19:57.219]                 }
[13:19:57.219]                 {
[13:19:57.219]                   {
[13:19:57.219]                     base::assign(".Random.seed", c(10407L, 2085122710L, 
[13:19:57.219]                     1372392505L, -437060613L, -1809204027L, -1362710056L, 
[13:19:57.219]                     -1450170233L), envir = base::globalenv(), 
[13:19:57.219]                       inherits = FALSE)
[13:19:57.219]                     NULL
[13:19:57.219]                   }
[13:19:57.219]                   options(future.plan = NULL)
[13:19:57.219]                   if (is.na(NA_character_)) 
[13:19:57.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.219]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:57.219]                   {
[13:19:57.219]                     future <- SequentialFuture(..., envir = envir)
[13:19:57.219]                     if (!future$lazy) 
[13:19:57.219]                       future <- run(future)
[13:19:57.219]                     invisible(future)
[13:19:57.219]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.219]                 }
[13:19:57.219]             }
[13:19:57.219]         }
[13:19:57.219]     })
[13:19:57.219]     if (TRUE) {
[13:19:57.219]         base::sink(type = "output", split = FALSE)
[13:19:57.219]         if (TRUE) {
[13:19:57.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.219]         }
[13:19:57.219]         else {
[13:19:57.219]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.219]         }
[13:19:57.219]         base::close(...future.stdout)
[13:19:57.219]         ...future.stdout <- NULL
[13:19:57.219]     }
[13:19:57.219]     ...future.result$conditions <- ...future.conditions
[13:19:57.219]     ...future.result$finished <- base::Sys.time()
[13:19:57.219]     ...future.result
[13:19:57.219] }
[13:19:57.220] assign_globals() ...
[13:19:57.221] List of 5
[13:19:57.221]  $ future.call.arguments    : list()
[13:19:57.221]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.221]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[13:19:57.221]  $ ...future.elements_ii    :List of 2
[13:19:57.221]   ..$ : int [1:2] 1 3
[13:19:57.221]   ..$ : int [1:2] 2 4
[13:19:57.221]  $ ...future.seeds_ii       :List of 2
[13:19:57.221]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[13:19:57.221]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[13:19:57.221]  $ ...future.globals.maxSize: num Inf
[13:19:57.221]  - attr(*, "resolved")= logi FALSE
[13:19:57.221]  - attr(*, "total_size")= num NA
[13:19:57.221]  - attr(*, "where")=List of 5
[13:19:57.221]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.221]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.221]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.221]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.221]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.221]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.221]  - attr(*, "already-done")= logi TRUE
[13:19:57.226] - copied ‘future.call.arguments’ to environment
[13:19:57.226] - copied ‘...future.FUN’ to environment
[13:19:57.227] - copied ‘...future.elements_ii’ to environment
[13:19:57.227] - copied ‘...future.seeds_ii’ to environment
[13:19:57.227] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.227] assign_globals() ... done
[13:19:57.227] plan(): Setting new future strategy stack:
[13:19:57.227] List of future strategies:
[13:19:57.227] 1. sequential:
[13:19:57.227]    - args: function (..., envir = parent.frame())
[13:19:57.227]    - tweaked: FALSE
[13:19:57.227]    - call: NULL
[13:19:57.228] plan(): nbrOfWorkers() = 1
[13:19:57.228] plan(): Setting new future strategy stack:
[13:19:57.228] List of future strategies:
[13:19:57.228] 1. sequential:
[13:19:57.228]    - args: function (..., envir = parent.frame())
[13:19:57.228]    - tweaked: FALSE
[13:19:57.228]    - call: plan(strategy)
[13:19:57.229] plan(): nbrOfWorkers() = 1
[13:19:57.229] SequentialFuture started (and completed)
[13:19:57.229] - Launch lazy future ... done
[13:19:57.229] run() for ‘SequentialFuture’ ... done
[13:19:57.229] Created future:
[13:19:57.229] SequentialFuture:
[13:19:57.229] Label: ‘future_apply-1’
[13:19:57.229] Expression:
[13:19:57.229] {
[13:19:57.229]     do.call(function(...) {
[13:19:57.229]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.229]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.229]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.229]             on.exit(options(oopts), add = TRUE)
[13:19:57.229]         }
[13:19:57.229]         {
[13:19:57.229]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.229]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.229]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:19:57.229]                   envir = globalenv(), inherits = FALSE)
[13:19:57.229]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.229]             })
[13:19:57.229]         }
[13:19:57.229]     }, args = future.call.arguments)
[13:19:57.229] }
[13:19:57.229] Lazy evaluation: FALSE
[13:19:57.229] Asynchronous evaluation: FALSE
[13:19:57.229] Local evaluation: TRUE
[13:19:57.229] Environment: R_GlobalEnv
[13:19:57.229] Capture standard output: TRUE
[13:19:57.229] Capture condition classes: <none>
[13:19:57.229] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.229] Packages: <none>
[13:19:57.229] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:19:57.229] Resolved: TRUE
[13:19:57.229] Value: 112 bytes of class ‘list’
[13:19:57.229] Early signaling: FALSE
[13:19:57.229] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.229] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:57.230] Chunk #1 of 1 ... DONE
[13:19:57.231] Launching 1 futures (chunks) ... DONE
[13:19:57.231] Resolving 1 futures (chunks) ...
[13:19:57.231] resolve() on list ...
[13:19:57.231]  recursive: 0
[13:19:57.231]  length: 1
[13:19:57.231] 
[13:19:57.231] resolved() for ‘SequentialFuture’ ...
[13:19:57.231] - state: ‘finished’
[13:19:57.231] - run: TRUE
[13:19:57.231] - result: ‘FutureResult’
[13:19:57.232] resolved() for ‘SequentialFuture’ ... done
[13:19:57.232] Future #1
[13:19:57.232] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:57.232] - nx: 1
[13:19:57.232] - relay: TRUE
[13:19:57.232] - stdout: TRUE
[13:19:57.232] - signal: TRUE
[13:19:57.232] - resignal: FALSE
[13:19:57.232] - force: TRUE
[13:19:57.232] - relayed: [n=1] FALSE
[13:19:57.233] - queued futures: [n=1] FALSE
[13:19:57.233]  - until=1
[13:19:57.233]  - relaying element #1
[13:19:57.233] - relayed: [n=1] TRUE
[13:19:57.233] - queued futures: [n=1] TRUE
[13:19:57.233] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:57.233]  length: 0 (resolved future 1)
[13:19:57.233] Relaying remaining futures
[13:19:57.233] signalConditionsASAP(NULL, pos=0) ...
[13:19:57.234] - nx: 1
[13:19:57.234] - relay: TRUE
[13:19:57.234] - stdout: TRUE
[13:19:57.234] - signal: TRUE
[13:19:57.234] - resignal: FALSE
[13:19:57.234] - force: TRUE
[13:19:57.234] - relayed: [n=1] TRUE
[13:19:57.234] - queued futures: [n=1] TRUE
 - flush all
[13:19:57.234] - relayed: [n=1] TRUE
[13:19:57.234] - queued futures: [n=1] TRUE
[13:19:57.234] signalConditionsASAP(NULL, pos=0) ... done
[13:19:57.235] resolve() on list ... DONE
[13:19:57.235]  - Number of value chunks collected: 1
[13:19:57.235] Resolving 1 futures (chunks) ... DONE
[13:19:57.235] Reducing values from 1 chunks ...
[13:19:57.235]  - Number of values collected after concatenation: 2
[13:19:57.235]  - Number of values expected: 2
[13:19:57.235] Reducing values from 1 chunks ... DONE
[13:19:57.235] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[13:19:57.235] plan(): Setting new future strategy stack:
[13:19:57.236] List of future strategies:
[13:19:57.236] 1. sequential:
[13:19:57.236]    - args: function (..., envir = parent.frame())
[13:19:57.236]    - tweaked: FALSE
[13:19:57.236]    - call: plan(sequential)
[13:19:57.236] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[13:19:57.236] plan(): Setting new future strategy stack:
[13:19:57.236] List of future strategies:
[13:19:57.236] 1. multicore:
[13:19:57.236]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.236]    - tweaked: FALSE
[13:19:57.236]    - call: plan(strategy)
[13:19:57.240] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[13:19:57.241] getGlobalsAndPackagesXApply() ...
[13:19:57.241]  - future.globals: TRUE
[13:19:57.241] getGlobalsAndPackages() ...
[13:19:57.241] Searching for globals...
[13:19:57.278] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:19:57.279] Searching for globals ... DONE
[13:19:57.279] Resolving globals: FALSE
[13:19:57.282] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:19:57.283] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:19:57.283] - globals: [1] ‘FUN’
[13:19:57.283] 
[13:19:57.283] getGlobalsAndPackages() ... DONE
[13:19:57.283]  - globals found/used: [n=1] ‘FUN’
[13:19:57.284]  - needed namespaces: [n=0] 
[13:19:57.284] Finding globals ... DONE
[13:19:57.284]  - use_args: TRUE
[13:19:57.284]  - Getting '...' globals ...
[13:19:57.284] resolve() on list ...
[13:19:57.284]  recursive: 0
[13:19:57.284]  length: 1
[13:19:57.285]  elements: ‘...’
[13:19:57.285]  length: 0 (resolved future 1)
[13:19:57.285] resolve() on list ... DONE
[13:19:57.285]    - '...' content: [n=0] 
[13:19:57.285] List of 1
[13:19:57.285]  $ ...: list()
[13:19:57.285]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.285]  - attr(*, "where")=List of 1
[13:19:57.285]   ..$ ...:<environment: 0x555922e12fd8> 
[13:19:57.285]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.285]  - attr(*, "resolved")= logi TRUE
[13:19:57.285]  - attr(*, "total_size")= num NA
[13:19:57.288]  - Getting '...' globals ... DONE
[13:19:57.288] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:57.288] List of 2
[13:19:57.288]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:57.288]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:57.288]  $ ...          : list()
[13:19:57.288]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.288]  - attr(*, "where")=List of 2
[13:19:57.288]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:57.288]   ..$ ...          :<environment: 0x555922e12fd8> 
[13:19:57.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.288]  - attr(*, "resolved")= logi FALSE
[13:19:57.288]  - attr(*, "total_size")= num 354224
[13:19:57.291] Packages to be attached in all futures: [n=0] 
[13:19:57.291] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.295] future_lapply() ...
[13:19:57.332] Number of chunks: 2
[13:19:57.332] getGlobalsAndPackagesXApply() ...
[13:19:57.332]  - future.globals: <name-value list> with names ‘list()’
[13:19:57.333]  - use_args: TRUE
[13:19:57.333] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:57.333] List of 2
[13:19:57.333]  $ ...          : list()
[13:19:57.333]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.333]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:57.333]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:57.333]  - attr(*, "where")=List of 2
[13:19:57.333]   ..$ ...          :<environment: 0x555922e12fd8> 
[13:19:57.333]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:57.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.333]  - attr(*, "resolved")= logi FALSE
[13:19:57.333]  - attr(*, "total_size")= num NA
[13:19:57.336] Packages to be attached in all futures: [n=0] 
[13:19:57.336] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.337] Number of futures (= number of chunks): 2
[13:19:57.337] Launching 2 futures (chunks) ...
[13:19:57.337] Chunk #1 of 2 ...
[13:19:57.337]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:57.337]  - seeds: <none>
[13:19:57.337]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.337] getGlobalsAndPackages() ...
[13:19:57.337] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.337] Resolving globals: FALSE
[13:19:57.338] Tweak future expression to call with '...' arguments ...
[13:19:57.338] {
[13:19:57.338]     do.call(function(...) {
[13:19:57.338]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.338]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.338]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.338]             on.exit(options(oopts), add = TRUE)
[13:19:57.338]         }
[13:19:57.338]         {
[13:19:57.338]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.338]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.338]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.338]             })
[13:19:57.338]         }
[13:19:57.338]     }, args = future.call.arguments)
[13:19:57.338] }
[13:19:57.338] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.338] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.338] 
[13:19:57.339] getGlobalsAndPackages() ... DONE
[13:19:57.339] run() for ‘Future’ ...
[13:19:57.339] - state: ‘created’
[13:19:57.339] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.342] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.343] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.343]   - Field: ‘label’
[13:19:57.343]   - Field: ‘local’
[13:19:57.343]   - Field: ‘owner’
[13:19:57.343]   - Field: ‘envir’
[13:19:57.343]   - Field: ‘workers’
[13:19:57.343]   - Field: ‘packages’
[13:19:57.343]   - Field: ‘gc’
[13:19:57.343]   - Field: ‘job’
[13:19:57.343]   - Field: ‘conditions’
[13:19:57.344]   - Field: ‘expr’
[13:19:57.344]   - Field: ‘uuid’
[13:19:57.344]   - Field: ‘seed’
[13:19:57.344]   - Field: ‘version’
[13:19:57.344]   - Field: ‘result’
[13:19:57.344]   - Field: ‘asynchronous’
[13:19:57.344]   - Field: ‘calls’
[13:19:57.344]   - Field: ‘globals’
[13:19:57.344]   - Field: ‘stdout’
[13:19:57.345]   - Field: ‘earlySignal’
[13:19:57.345]   - Field: ‘lazy’
[13:19:57.345]   - Field: ‘state’
[13:19:57.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.345] - Launch lazy future ...
[13:19:57.346] Packages needed by the future expression (n = 0): <none>
[13:19:57.346] Packages needed by future strategies (n = 0): <none>
[13:19:57.347] {
[13:19:57.347]     {
[13:19:57.347]         {
[13:19:57.347]             ...future.startTime <- base::Sys.time()
[13:19:57.347]             {
[13:19:57.347]                 {
[13:19:57.347]                   {
[13:19:57.347]                     {
[13:19:57.347]                       base::local({
[13:19:57.347]                         has_future <- base::requireNamespace("future", 
[13:19:57.347]                           quietly = TRUE)
[13:19:57.347]                         if (has_future) {
[13:19:57.347]                           ns <- base::getNamespace("future")
[13:19:57.347]                           version <- ns[[".package"]][["version"]]
[13:19:57.347]                           if (is.null(version)) 
[13:19:57.347]                             version <- utils::packageVersion("future")
[13:19:57.347]                         }
[13:19:57.347]                         else {
[13:19:57.347]                           version <- NULL
[13:19:57.347]                         }
[13:19:57.347]                         if (!has_future || version < "1.8.0") {
[13:19:57.347]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.347]                             "", base::R.version$version.string), 
[13:19:57.347]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:57.347]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.347]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.347]                               "release", "version")], collapse = " "), 
[13:19:57.347]                             hostname = base::Sys.info()[["nodename"]])
[13:19:57.347]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.347]                             info)
[13:19:57.347]                           info <- base::paste(info, collapse = "; ")
[13:19:57.347]                           if (!has_future) {
[13:19:57.347]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.347]                               info)
[13:19:57.347]                           }
[13:19:57.347]                           else {
[13:19:57.347]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.347]                               info, version)
[13:19:57.347]                           }
[13:19:57.347]                           base::stop(msg)
[13:19:57.347]                         }
[13:19:57.347]                       })
[13:19:57.347]                     }
[13:19:57.347]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.347]                     base::options(mc.cores = 1L)
[13:19:57.347]                   }
[13:19:57.347]                   options(future.plan = NULL)
[13:19:57.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.347]                 }
[13:19:57.347]                 ...future.workdir <- getwd()
[13:19:57.347]             }
[13:19:57.347]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.347]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.347]         }
[13:19:57.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.347]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.347]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.347]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.347]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.347]             base::names(...future.oldOptions))
[13:19:57.347]     }
[13:19:57.347]     if (FALSE) {
[13:19:57.347]     }
[13:19:57.347]     else {
[13:19:57.347]         if (TRUE) {
[13:19:57.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.347]                 open = "w")
[13:19:57.347]         }
[13:19:57.347]         else {
[13:19:57.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.347]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.347]         }
[13:19:57.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.347]             base::sink(type = "output", split = FALSE)
[13:19:57.347]             base::close(...future.stdout)
[13:19:57.347]         }, add = TRUE)
[13:19:57.347]     }
[13:19:57.347]     ...future.frame <- base::sys.nframe()
[13:19:57.347]     ...future.conditions <- base::list()
[13:19:57.347]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.347]     if (FALSE) {
[13:19:57.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.347]     }
[13:19:57.347]     ...future.result <- base::tryCatch({
[13:19:57.347]         base::withCallingHandlers({
[13:19:57.347]             ...future.value <- base::withVisible(base::local({
[13:19:57.347]                 withCallingHandlers({
[13:19:57.347]                   {
[13:19:57.347]                     do.call(function(...) {
[13:19:57.347]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.347]                       if (!identical(...future.globals.maxSize.org, 
[13:19:57.347]                         ...future.globals.maxSize)) {
[13:19:57.347]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.347]                         on.exit(options(oopts), add = TRUE)
[13:19:57.347]                       }
[13:19:57.347]                       {
[13:19:57.347]                         lapply(seq_along(...future.elements_ii), 
[13:19:57.347]                           FUN = function(jj) {
[13:19:57.347]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.347]                             ...future.FUN(...future.X_jj, ...)
[13:19:57.347]                           })
[13:19:57.347]                       }
[13:19:57.347]                     }, args = future.call.arguments)
[13:19:57.347]                   }
[13:19:57.347]                 }, immediateCondition = function(cond) {
[13:19:57.347]                   save_rds <- function (object, pathname, ...) 
[13:19:57.347]                   {
[13:19:57.347]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.347]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.347]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.347]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.347]                         fi_tmp[["mtime"]])
[13:19:57.347]                     }
[13:19:57.347]                     tryCatch({
[13:19:57.347]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.347]                     }, error = function(ex) {
[13:19:57.347]                       msg <- conditionMessage(ex)
[13:19:57.347]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.347]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.347]                         fi_tmp[["mtime"]], msg)
[13:19:57.347]                       ex$message <- msg
[13:19:57.347]                       stop(ex)
[13:19:57.347]                     })
[13:19:57.347]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.347]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.347]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.347]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.347]                       fi <- file.info(pathname)
[13:19:57.347]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.347]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.347]                         fi[["size"]], fi[["mtime"]])
[13:19:57.347]                       stop(msg)
[13:19:57.347]                     }
[13:19:57.347]                     invisible(pathname)
[13:19:57.347]                   }
[13:19:57.347]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.347]                     rootPath = tempdir()) 
[13:19:57.347]                   {
[13:19:57.347]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.347]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.347]                       tmpdir = path, fileext = ".rds")
[13:19:57.347]                     save_rds(obj, file)
[13:19:57.347]                   }
[13:19:57.347]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:57.347]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.347]                   {
[13:19:57.347]                     inherits <- base::inherits
[13:19:57.347]                     invokeRestart <- base::invokeRestart
[13:19:57.347]                     is.null <- base::is.null
[13:19:57.347]                     muffled <- FALSE
[13:19:57.347]                     if (inherits(cond, "message")) {
[13:19:57.347]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.347]                       if (muffled) 
[13:19:57.347]                         invokeRestart("muffleMessage")
[13:19:57.347]                     }
[13:19:57.347]                     else if (inherits(cond, "warning")) {
[13:19:57.347]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.347]                       if (muffled) 
[13:19:57.347]                         invokeRestart("muffleWarning")
[13:19:57.347]                     }
[13:19:57.347]                     else if (inherits(cond, "condition")) {
[13:19:57.347]                       if (!is.null(pattern)) {
[13:19:57.347]                         computeRestarts <- base::computeRestarts
[13:19:57.347]                         grepl <- base::grepl
[13:19:57.347]                         restarts <- computeRestarts(cond)
[13:19:57.347]                         for (restart in restarts) {
[13:19:57.347]                           name <- restart$name
[13:19:57.347]                           if (is.null(name)) 
[13:19:57.347]                             next
[13:19:57.347]                           if (!grepl(pattern, name)) 
[13:19:57.347]                             next
[13:19:57.347]                           invokeRestart(restart)
[13:19:57.347]                           muffled <- TRUE
[13:19:57.347]                           break
[13:19:57.347]                         }
[13:19:57.347]                       }
[13:19:57.347]                     }
[13:19:57.347]                     invisible(muffled)
[13:19:57.347]                   }
[13:19:57.347]                   muffleCondition(cond)
[13:19:57.347]                 })
[13:19:57.347]             }))
[13:19:57.347]             future::FutureResult(value = ...future.value$value, 
[13:19:57.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.347]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.347]                     ...future.globalenv.names))
[13:19:57.347]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.347]         }, condition = base::local({
[13:19:57.347]             c <- base::c
[13:19:57.347]             inherits <- base::inherits
[13:19:57.347]             invokeRestart <- base::invokeRestart
[13:19:57.347]             length <- base::length
[13:19:57.347]             list <- base::list
[13:19:57.347]             seq.int <- base::seq.int
[13:19:57.347]             signalCondition <- base::signalCondition
[13:19:57.347]             sys.calls <- base::sys.calls
[13:19:57.347]             `[[` <- base::`[[`
[13:19:57.347]             `+` <- base::`+`
[13:19:57.347]             `<<-` <- base::`<<-`
[13:19:57.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.347]                   3L)]
[13:19:57.347]             }
[13:19:57.347]             function(cond) {
[13:19:57.347]                 is_error <- inherits(cond, "error")
[13:19:57.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.347]                   NULL)
[13:19:57.347]                 if (is_error) {
[13:19:57.347]                   sessionInformation <- function() {
[13:19:57.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.347]                       search = base::search(), system = base::Sys.info())
[13:19:57.347]                   }
[13:19:57.347]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.347]                     cond$call), session = sessionInformation(), 
[13:19:57.347]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.347]                   signalCondition(cond)
[13:19:57.347]                 }
[13:19:57.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.347]                 "immediateCondition"))) {
[13:19:57.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.347]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.347]                   if (TRUE && !signal) {
[13:19:57.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.347]                     {
[13:19:57.347]                       inherits <- base::inherits
[13:19:57.347]                       invokeRestart <- base::invokeRestart
[13:19:57.347]                       is.null <- base::is.null
[13:19:57.347]                       muffled <- FALSE
[13:19:57.347]                       if (inherits(cond, "message")) {
[13:19:57.347]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.347]                         if (muffled) 
[13:19:57.347]                           invokeRestart("muffleMessage")
[13:19:57.347]                       }
[13:19:57.347]                       else if (inherits(cond, "warning")) {
[13:19:57.347]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.347]                         if (muffled) 
[13:19:57.347]                           invokeRestart("muffleWarning")
[13:19:57.347]                       }
[13:19:57.347]                       else if (inherits(cond, "condition")) {
[13:19:57.347]                         if (!is.null(pattern)) {
[13:19:57.347]                           computeRestarts <- base::computeRestarts
[13:19:57.347]                           grepl <- base::grepl
[13:19:57.347]                           restarts <- computeRestarts(cond)
[13:19:57.347]                           for (restart in restarts) {
[13:19:57.347]                             name <- restart$name
[13:19:57.347]                             if (is.null(name)) 
[13:19:57.347]                               next
[13:19:57.347]                             if (!grepl(pattern, name)) 
[13:19:57.347]                               next
[13:19:57.347]                             invokeRestart(restart)
[13:19:57.347]                             muffled <- TRUE
[13:19:57.347]                             break
[13:19:57.347]                           }
[13:19:57.347]                         }
[13:19:57.347]                       }
[13:19:57.347]                       invisible(muffled)
[13:19:57.347]                     }
[13:19:57.347]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.347]                   }
[13:19:57.347]                 }
[13:19:57.347]                 else {
[13:19:57.347]                   if (TRUE) {
[13:19:57.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.347]                     {
[13:19:57.347]                       inherits <- base::inherits
[13:19:57.347]                       invokeRestart <- base::invokeRestart
[13:19:57.347]                       is.null <- base::is.null
[13:19:57.347]                       muffled <- FALSE
[13:19:57.347]                       if (inherits(cond, "message")) {
[13:19:57.347]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.347]                         if (muffled) 
[13:19:57.347]                           invokeRestart("muffleMessage")
[13:19:57.347]                       }
[13:19:57.347]                       else if (inherits(cond, "warning")) {
[13:19:57.347]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.347]                         if (muffled) 
[13:19:57.347]                           invokeRestart("muffleWarning")
[13:19:57.347]                       }
[13:19:57.347]                       else if (inherits(cond, "condition")) {
[13:19:57.347]                         if (!is.null(pattern)) {
[13:19:57.347]                           computeRestarts <- base::computeRestarts
[13:19:57.347]                           grepl <- base::grepl
[13:19:57.347]                           restarts <- computeRestarts(cond)
[13:19:57.347]                           for (restart in restarts) {
[13:19:57.347]                             name <- restart$name
[13:19:57.347]                             if (is.null(name)) 
[13:19:57.347]                               next
[13:19:57.347]                             if (!grepl(pattern, name)) 
[13:19:57.347]                               next
[13:19:57.347]                             invokeRestart(restart)
[13:19:57.347]                             muffled <- TRUE
[13:19:57.347]                             break
[13:19:57.347]                           }
[13:19:57.347]                         }
[13:19:57.347]                       }
[13:19:57.347]                       invisible(muffled)
[13:19:57.347]                     }
[13:19:57.347]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.347]                   }
[13:19:57.347]                 }
[13:19:57.347]             }
[13:19:57.347]         }))
[13:19:57.347]     }, error = function(ex) {
[13:19:57.347]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.347]                 ...future.rng), started = ...future.startTime, 
[13:19:57.347]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.347]             version = "1.8"), class = "FutureResult")
[13:19:57.347]     }, finally = {
[13:19:57.347]         if (!identical(...future.workdir, getwd())) 
[13:19:57.347]             setwd(...future.workdir)
[13:19:57.347]         {
[13:19:57.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.347]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.347]             }
[13:19:57.347]             base::options(...future.oldOptions)
[13:19:57.347]             if (.Platform$OS.type == "windows") {
[13:19:57.347]                 old_names <- names(...future.oldEnvVars)
[13:19:57.347]                 envs <- base::Sys.getenv()
[13:19:57.347]                 names <- names(envs)
[13:19:57.347]                 common <- intersect(names, old_names)
[13:19:57.347]                 added <- setdiff(names, old_names)
[13:19:57.347]                 removed <- setdiff(old_names, names)
[13:19:57.347]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.347]                   envs[common]]
[13:19:57.347]                 NAMES <- toupper(changed)
[13:19:57.347]                 args <- list()
[13:19:57.347]                 for (kk in seq_along(NAMES)) {
[13:19:57.347]                   name <- changed[[kk]]
[13:19:57.347]                   NAME <- NAMES[[kk]]
[13:19:57.347]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.347]                     next
[13:19:57.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.347]                 }
[13:19:57.347]                 NAMES <- toupper(added)
[13:19:57.347]                 for (kk in seq_along(NAMES)) {
[13:19:57.347]                   name <- added[[kk]]
[13:19:57.347]                   NAME <- NAMES[[kk]]
[13:19:57.347]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.347]                     next
[13:19:57.347]                   args[[name]] <- ""
[13:19:57.347]                 }
[13:19:57.347]                 NAMES <- toupper(removed)
[13:19:57.347]                 for (kk in seq_along(NAMES)) {
[13:19:57.347]                   name <- removed[[kk]]
[13:19:57.347]                   NAME <- NAMES[[kk]]
[13:19:57.347]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.347]                     next
[13:19:57.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.347]                 }
[13:19:57.347]                 if (length(args) > 0) 
[13:19:57.347]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.347]             }
[13:19:57.347]             else {
[13:19:57.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.347]             }
[13:19:57.347]             {
[13:19:57.347]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.347]                   0L) {
[13:19:57.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.347]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.347]                   base::options(opts)
[13:19:57.347]                 }
[13:19:57.347]                 {
[13:19:57.347]                   {
[13:19:57.347]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.347]                     NULL
[13:19:57.347]                   }
[13:19:57.347]                   options(future.plan = NULL)
[13:19:57.347]                   if (is.na(NA_character_)) 
[13:19:57.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.347]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.347]                     envir = parent.frame()) 
[13:19:57.347]                   {
[13:19:57.347]                     default_workers <- missing(workers)
[13:19:57.347]                     if (is.function(workers)) 
[13:19:57.347]                       workers <- workers()
[13:19:57.347]                     workers <- structure(as.integer(workers), 
[13:19:57.347]                       class = class(workers))
[13:19:57.347]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.347]                       1L)
[13:19:57.347]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.347]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.347]                       if (default_workers) 
[13:19:57.347]                         supportsMulticore(warn = TRUE)
[13:19:57.347]                       return(sequential(..., envir = envir))
[13:19:57.347]                     }
[13:19:57.347]                     oopts <- options(mc.cores = workers)
[13:19:57.347]                     on.exit(options(oopts))
[13:19:57.347]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.347]                       envir = envir)
[13:19:57.347]                     if (!future$lazy) 
[13:19:57.347]                       future <- run(future)
[13:19:57.347]                     invisible(future)
[13:19:57.347]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.347]                 }
[13:19:57.347]             }
[13:19:57.347]         }
[13:19:57.347]     })
[13:19:57.347]     if (TRUE) {
[13:19:57.347]         base::sink(type = "output", split = FALSE)
[13:19:57.347]         if (TRUE) {
[13:19:57.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.347]         }
[13:19:57.347]         else {
[13:19:57.347]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.347]         }
[13:19:57.347]         base::close(...future.stdout)
[13:19:57.347]         ...future.stdout <- NULL
[13:19:57.347]     }
[13:19:57.347]     ...future.result$conditions <- ...future.conditions
[13:19:57.347]     ...future.result$finished <- base::Sys.time()
[13:19:57.347]     ...future.result
[13:19:57.347] }
[13:19:57.349] assign_globals() ...
[13:19:57.349] List of 5
[13:19:57.349]  $ future.call.arguments    : list()
[13:19:57.349]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.349]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:57.349]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:57.349]  $ ...future.elements_ii    :List of 1
[13:19:57.349]   ..$ : num [1:4] 1 3 1 7
[13:19:57.349]  $ ...future.seeds_ii       : NULL
[13:19:57.349]  $ ...future.globals.maxSize: num Inf
[13:19:57.349]  - attr(*, "resolved")= logi FALSE
[13:19:57.349]  - attr(*, "total_size")= num NA
[13:19:57.349]  - attr(*, "where")=List of 5
[13:19:57.349]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.349]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.349]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.349]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.349]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.349]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.349]  - attr(*, "already-done")= logi TRUE
[13:19:57.356] - copied ‘future.call.arguments’ to environment
[13:19:57.356] - copied ‘...future.FUN’ to environment
[13:19:57.356] - copied ‘...future.elements_ii’ to environment
[13:19:57.356] - copied ‘...future.seeds_ii’ to environment
[13:19:57.357] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.357] assign_globals() ... done
[13:19:57.357] requestCore(): workers = 2
[13:19:57.360] MulticoreFuture started
[13:19:57.361] - Launch lazy future ... done
[13:19:57.361] plan(): Setting new future strategy stack:
[13:19:57.361] run() for ‘MulticoreFuture’ ... done
[13:19:57.362] Created future:
[13:19:57.361] List of future strategies:
[13:19:57.361] 1. sequential:
[13:19:57.361]    - args: function (..., envir = parent.frame())
[13:19:57.361]    - tweaked: FALSE
[13:19:57.361]    - call: NULL
[13:19:57.362] plan(): nbrOfWorkers() = 1
[13:19:57.365] plan(): Setting new future strategy stack:
[13:19:57.365] List of future strategies:
[13:19:57.365] 1. multicore:
[13:19:57.365]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.365]    - tweaked: FALSE
[13:19:57.365]    - call: plan(strategy)
[13:19:57.370] plan(): nbrOfWorkers() = 2
[13:19:57.362] MulticoreFuture:
[13:19:57.362] Label: ‘future_apply-1’
[13:19:57.362] Expression:
[13:19:57.362] {
[13:19:57.362]     do.call(function(...) {
[13:19:57.362]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.362]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.362]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.362]             on.exit(options(oopts), add = TRUE)
[13:19:57.362]         }
[13:19:57.362]         {
[13:19:57.362]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.362]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.362]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.362]             })
[13:19:57.362]         }
[13:19:57.362]     }, args = future.call.arguments)
[13:19:57.362] }
[13:19:57.362] Lazy evaluation: FALSE
[13:19:57.362] Asynchronous evaluation: TRUE
[13:19:57.362] Local evaluation: TRUE
[13:19:57.362] Environment: R_GlobalEnv
[13:19:57.362] Capture standard output: TRUE
[13:19:57.362] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.362] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.362] Packages: <none>
[13:19:57.362] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.362] Resolved: TRUE
[13:19:57.362] Value: <not collected>
[13:19:57.362] Conditions captured: <none>
[13:19:57.362] Early signaling: FALSE
[13:19:57.362] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.362] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.372] Chunk #1 of 2 ... DONE
[13:19:57.372] Chunk #2 of 2 ...
[13:19:57.372]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:57.373]  - seeds: <none>
[13:19:57.373]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.373] getGlobalsAndPackages() ...
[13:19:57.373] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.373] Resolving globals: FALSE
[13:19:57.373] Tweak future expression to call with '...' arguments ...
[13:19:57.374] {
[13:19:57.374]     do.call(function(...) {
[13:19:57.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.374]             on.exit(options(oopts), add = TRUE)
[13:19:57.374]         }
[13:19:57.374]         {
[13:19:57.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.374]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.374]             })
[13:19:57.374]         }
[13:19:57.374]     }, args = future.call.arguments)
[13:19:57.374] }
[13:19:57.374] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.375] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.375] 
[13:19:57.375] getGlobalsAndPackages() ... DONE
[13:19:57.376] run() for ‘Future’ ...
[13:19:57.376] - state: ‘created’
[13:19:57.376] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.380] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.381] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.381]   - Field: ‘label’
[13:19:57.381]   - Field: ‘local’
[13:19:57.381]   - Field: ‘owner’
[13:19:57.381]   - Field: ‘envir’
[13:19:57.381]   - Field: ‘workers’
[13:19:57.382]   - Field: ‘packages’
[13:19:57.382]   - Field: ‘gc’
[13:19:57.382]   - Field: ‘job’
[13:19:57.382]   - Field: ‘conditions’
[13:19:57.382]   - Field: ‘expr’
[13:19:57.382]   - Field: ‘uuid’
[13:19:57.382]   - Field: ‘seed’
[13:19:57.383]   - Field: ‘version’
[13:19:57.383]   - Field: ‘result’
[13:19:57.383]   - Field: ‘asynchronous’
[13:19:57.383]   - Field: ‘calls’
[13:19:57.383]   - Field: ‘globals’
[13:19:57.383]   - Field: ‘stdout’
[13:19:57.383]   - Field: ‘earlySignal’
[13:19:57.384]   - Field: ‘lazy’
[13:19:57.384]   - Field: ‘state’
[13:19:57.384] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.384] - Launch lazy future ...
[13:19:57.384] Packages needed by the future expression (n = 0): <none>
[13:19:57.385] Packages needed by future strategies (n = 0): <none>
[13:19:57.385] {
[13:19:57.385]     {
[13:19:57.385]         {
[13:19:57.385]             ...future.startTime <- base::Sys.time()
[13:19:57.385]             {
[13:19:57.385]                 {
[13:19:57.385]                   {
[13:19:57.385]                     {
[13:19:57.385]                       base::local({
[13:19:57.385]                         has_future <- base::requireNamespace("future", 
[13:19:57.385]                           quietly = TRUE)
[13:19:57.385]                         if (has_future) {
[13:19:57.385]                           ns <- base::getNamespace("future")
[13:19:57.385]                           version <- ns[[".package"]][["version"]]
[13:19:57.385]                           if (is.null(version)) 
[13:19:57.385]                             version <- utils::packageVersion("future")
[13:19:57.385]                         }
[13:19:57.385]                         else {
[13:19:57.385]                           version <- NULL
[13:19:57.385]                         }
[13:19:57.385]                         if (!has_future || version < "1.8.0") {
[13:19:57.385]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.385]                             "", base::R.version$version.string), 
[13:19:57.385]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:57.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.385]                               "release", "version")], collapse = " "), 
[13:19:57.385]                             hostname = base::Sys.info()[["nodename"]])
[13:19:57.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.385]                             info)
[13:19:57.385]                           info <- base::paste(info, collapse = "; ")
[13:19:57.385]                           if (!has_future) {
[13:19:57.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.385]                               info)
[13:19:57.385]                           }
[13:19:57.385]                           else {
[13:19:57.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.385]                               info, version)
[13:19:57.385]                           }
[13:19:57.385]                           base::stop(msg)
[13:19:57.385]                         }
[13:19:57.385]                       })
[13:19:57.385]                     }
[13:19:57.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.385]                     base::options(mc.cores = 1L)
[13:19:57.385]                   }
[13:19:57.385]                   options(future.plan = NULL)
[13:19:57.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.385]                 }
[13:19:57.385]                 ...future.workdir <- getwd()
[13:19:57.385]             }
[13:19:57.385]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.385]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.385]         }
[13:19:57.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.385]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.385]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.385]             base::names(...future.oldOptions))
[13:19:57.385]     }
[13:19:57.385]     if (FALSE) {
[13:19:57.385]     }
[13:19:57.385]     else {
[13:19:57.385]         if (TRUE) {
[13:19:57.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.385]                 open = "w")
[13:19:57.385]         }
[13:19:57.385]         else {
[13:19:57.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.385]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.385]         }
[13:19:57.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.385]             base::sink(type = "output", split = FALSE)
[13:19:57.385]             base::close(...future.stdout)
[13:19:57.385]         }, add = TRUE)
[13:19:57.385]     }
[13:19:57.385]     ...future.frame <- base::sys.nframe()
[13:19:57.385]     ...future.conditions <- base::list()
[13:19:57.385]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.385]     if (FALSE) {
[13:19:57.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.385]     }
[13:19:57.385]     ...future.result <- base::tryCatch({
[13:19:57.385]         base::withCallingHandlers({
[13:19:57.385]             ...future.value <- base::withVisible(base::local({
[13:19:57.385]                 withCallingHandlers({
[13:19:57.385]                   {
[13:19:57.385]                     do.call(function(...) {
[13:19:57.385]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.385]                       if (!identical(...future.globals.maxSize.org, 
[13:19:57.385]                         ...future.globals.maxSize)) {
[13:19:57.385]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.385]                         on.exit(options(oopts), add = TRUE)
[13:19:57.385]                       }
[13:19:57.385]                       {
[13:19:57.385]                         lapply(seq_along(...future.elements_ii), 
[13:19:57.385]                           FUN = function(jj) {
[13:19:57.385]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.385]                             ...future.FUN(...future.X_jj, ...)
[13:19:57.385]                           })
[13:19:57.385]                       }
[13:19:57.385]                     }, args = future.call.arguments)
[13:19:57.385]                   }
[13:19:57.385]                 }, immediateCondition = function(cond) {
[13:19:57.385]                   save_rds <- function (object, pathname, ...) 
[13:19:57.385]                   {
[13:19:57.385]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.385]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.385]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.385]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.385]                         fi_tmp[["mtime"]])
[13:19:57.385]                     }
[13:19:57.385]                     tryCatch({
[13:19:57.385]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.385]                     }, error = function(ex) {
[13:19:57.385]                       msg <- conditionMessage(ex)
[13:19:57.385]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.385]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.385]                         fi_tmp[["mtime"]], msg)
[13:19:57.385]                       ex$message <- msg
[13:19:57.385]                       stop(ex)
[13:19:57.385]                     })
[13:19:57.385]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.385]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.385]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.385]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.385]                       fi <- file.info(pathname)
[13:19:57.385]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.385]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.385]                         fi[["size"]], fi[["mtime"]])
[13:19:57.385]                       stop(msg)
[13:19:57.385]                     }
[13:19:57.385]                     invisible(pathname)
[13:19:57.385]                   }
[13:19:57.385]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.385]                     rootPath = tempdir()) 
[13:19:57.385]                   {
[13:19:57.385]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.385]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.385]                       tmpdir = path, fileext = ".rds")
[13:19:57.385]                     save_rds(obj, file)
[13:19:57.385]                   }
[13:19:57.385]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:57.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.385]                   {
[13:19:57.385]                     inherits <- base::inherits
[13:19:57.385]                     invokeRestart <- base::invokeRestart
[13:19:57.385]                     is.null <- base::is.null
[13:19:57.385]                     muffled <- FALSE
[13:19:57.385]                     if (inherits(cond, "message")) {
[13:19:57.385]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.385]                       if (muffled) 
[13:19:57.385]                         invokeRestart("muffleMessage")
[13:19:57.385]                     }
[13:19:57.385]                     else if (inherits(cond, "warning")) {
[13:19:57.385]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.385]                       if (muffled) 
[13:19:57.385]                         invokeRestart("muffleWarning")
[13:19:57.385]                     }
[13:19:57.385]                     else if (inherits(cond, "condition")) {
[13:19:57.385]                       if (!is.null(pattern)) {
[13:19:57.385]                         computeRestarts <- base::computeRestarts
[13:19:57.385]                         grepl <- base::grepl
[13:19:57.385]                         restarts <- computeRestarts(cond)
[13:19:57.385]                         for (restart in restarts) {
[13:19:57.385]                           name <- restart$name
[13:19:57.385]                           if (is.null(name)) 
[13:19:57.385]                             next
[13:19:57.385]                           if (!grepl(pattern, name)) 
[13:19:57.385]                             next
[13:19:57.385]                           invokeRestart(restart)
[13:19:57.385]                           muffled <- TRUE
[13:19:57.385]                           break
[13:19:57.385]                         }
[13:19:57.385]                       }
[13:19:57.385]                     }
[13:19:57.385]                     invisible(muffled)
[13:19:57.385]                   }
[13:19:57.385]                   muffleCondition(cond)
[13:19:57.385]                 })
[13:19:57.385]             }))
[13:19:57.385]             future::FutureResult(value = ...future.value$value, 
[13:19:57.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.385]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.385]                     ...future.globalenv.names))
[13:19:57.385]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.385]         }, condition = base::local({
[13:19:57.385]             c <- base::c
[13:19:57.385]             inherits <- base::inherits
[13:19:57.385]             invokeRestart <- base::invokeRestart
[13:19:57.385]             length <- base::length
[13:19:57.385]             list <- base::list
[13:19:57.385]             seq.int <- base::seq.int
[13:19:57.385]             signalCondition <- base::signalCondition
[13:19:57.385]             sys.calls <- base::sys.calls
[13:19:57.385]             `[[` <- base::`[[`
[13:19:57.385]             `+` <- base::`+`
[13:19:57.385]             `<<-` <- base::`<<-`
[13:19:57.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.385]                   3L)]
[13:19:57.385]             }
[13:19:57.385]             function(cond) {
[13:19:57.385]                 is_error <- inherits(cond, "error")
[13:19:57.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.385]                   NULL)
[13:19:57.385]                 if (is_error) {
[13:19:57.385]                   sessionInformation <- function() {
[13:19:57.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.385]                       search = base::search(), system = base::Sys.info())
[13:19:57.385]                   }
[13:19:57.385]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.385]                     cond$call), session = sessionInformation(), 
[13:19:57.385]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.385]                   signalCondition(cond)
[13:19:57.385]                 }
[13:19:57.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.385]                 "immediateCondition"))) {
[13:19:57.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.385]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.385]                   if (TRUE && !signal) {
[13:19:57.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.385]                     {
[13:19:57.385]                       inherits <- base::inherits
[13:19:57.385]                       invokeRestart <- base::invokeRestart
[13:19:57.385]                       is.null <- base::is.null
[13:19:57.385]                       muffled <- FALSE
[13:19:57.385]                       if (inherits(cond, "message")) {
[13:19:57.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.385]                         if (muffled) 
[13:19:57.385]                           invokeRestart("muffleMessage")
[13:19:57.385]                       }
[13:19:57.385]                       else if (inherits(cond, "warning")) {
[13:19:57.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.385]                         if (muffled) 
[13:19:57.385]                           invokeRestart("muffleWarning")
[13:19:57.385]                       }
[13:19:57.385]                       else if (inherits(cond, "condition")) {
[13:19:57.385]                         if (!is.null(pattern)) {
[13:19:57.385]                           computeRestarts <- base::computeRestarts
[13:19:57.385]                           grepl <- base::grepl
[13:19:57.385]                           restarts <- computeRestarts(cond)
[13:19:57.385]                           for (restart in restarts) {
[13:19:57.385]                             name <- restart$name
[13:19:57.385]                             if (is.null(name)) 
[13:19:57.385]                               next
[13:19:57.385]                             if (!grepl(pattern, name)) 
[13:19:57.385]                               next
[13:19:57.385]                             invokeRestart(restart)
[13:19:57.385]                             muffled <- TRUE
[13:19:57.385]                             break
[13:19:57.385]                           }
[13:19:57.385]                         }
[13:19:57.385]                       }
[13:19:57.385]                       invisible(muffled)
[13:19:57.385]                     }
[13:19:57.385]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.385]                   }
[13:19:57.385]                 }
[13:19:57.385]                 else {
[13:19:57.385]                   if (TRUE) {
[13:19:57.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.385]                     {
[13:19:57.385]                       inherits <- base::inherits
[13:19:57.385]                       invokeRestart <- base::invokeRestart
[13:19:57.385]                       is.null <- base::is.null
[13:19:57.385]                       muffled <- FALSE
[13:19:57.385]                       if (inherits(cond, "message")) {
[13:19:57.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.385]                         if (muffled) 
[13:19:57.385]                           invokeRestart("muffleMessage")
[13:19:57.385]                       }
[13:19:57.385]                       else if (inherits(cond, "warning")) {
[13:19:57.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.385]                         if (muffled) 
[13:19:57.385]                           invokeRestart("muffleWarning")
[13:19:57.385]                       }
[13:19:57.385]                       else if (inherits(cond, "condition")) {
[13:19:57.385]                         if (!is.null(pattern)) {
[13:19:57.385]                           computeRestarts <- base::computeRestarts
[13:19:57.385]                           grepl <- base::grepl
[13:19:57.385]                           restarts <- computeRestarts(cond)
[13:19:57.385]                           for (restart in restarts) {
[13:19:57.385]                             name <- restart$name
[13:19:57.385]                             if (is.null(name)) 
[13:19:57.385]                               next
[13:19:57.385]                             if (!grepl(pattern, name)) 
[13:19:57.385]                               next
[13:19:57.385]                             invokeRestart(restart)
[13:19:57.385]                             muffled <- TRUE
[13:19:57.385]                             break
[13:19:57.385]                           }
[13:19:57.385]                         }
[13:19:57.385]                       }
[13:19:57.385]                       invisible(muffled)
[13:19:57.385]                     }
[13:19:57.385]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.385]                   }
[13:19:57.385]                 }
[13:19:57.385]             }
[13:19:57.385]         }))
[13:19:57.385]     }, error = function(ex) {
[13:19:57.385]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.385]                 ...future.rng), started = ...future.startTime, 
[13:19:57.385]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.385]             version = "1.8"), class = "FutureResult")
[13:19:57.385]     }, finally = {
[13:19:57.385]         if (!identical(...future.workdir, getwd())) 
[13:19:57.385]             setwd(...future.workdir)
[13:19:57.385]         {
[13:19:57.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.385]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.385]             }
[13:19:57.385]             base::options(...future.oldOptions)
[13:19:57.385]             if (.Platform$OS.type == "windows") {
[13:19:57.385]                 old_names <- names(...future.oldEnvVars)
[13:19:57.385]                 envs <- base::Sys.getenv()
[13:19:57.385]                 names <- names(envs)
[13:19:57.385]                 common <- intersect(names, old_names)
[13:19:57.385]                 added <- setdiff(names, old_names)
[13:19:57.385]                 removed <- setdiff(old_names, names)
[13:19:57.385]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.385]                   envs[common]]
[13:19:57.385]                 NAMES <- toupper(changed)
[13:19:57.385]                 args <- list()
[13:19:57.385]                 for (kk in seq_along(NAMES)) {
[13:19:57.385]                   name <- changed[[kk]]
[13:19:57.385]                   NAME <- NAMES[[kk]]
[13:19:57.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.385]                     next
[13:19:57.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.385]                 }
[13:19:57.385]                 NAMES <- toupper(added)
[13:19:57.385]                 for (kk in seq_along(NAMES)) {
[13:19:57.385]                   name <- added[[kk]]
[13:19:57.385]                   NAME <- NAMES[[kk]]
[13:19:57.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.385]                     next
[13:19:57.385]                   args[[name]] <- ""
[13:19:57.385]                 }
[13:19:57.385]                 NAMES <- toupper(removed)
[13:19:57.385]                 for (kk in seq_along(NAMES)) {
[13:19:57.385]                   name <- removed[[kk]]
[13:19:57.385]                   NAME <- NAMES[[kk]]
[13:19:57.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.385]                     next
[13:19:57.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.385]                 }
[13:19:57.385]                 if (length(args) > 0) 
[13:19:57.385]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.385]             }
[13:19:57.385]             else {
[13:19:57.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.385]             }
[13:19:57.385]             {
[13:19:57.385]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.385]                   0L) {
[13:19:57.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.385]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.385]                   base::options(opts)
[13:19:57.385]                 }
[13:19:57.385]                 {
[13:19:57.385]                   {
[13:19:57.385]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.385]                     NULL
[13:19:57.385]                   }
[13:19:57.385]                   options(future.plan = NULL)
[13:19:57.385]                   if (is.na(NA_character_)) 
[13:19:57.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.385]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.385]                     envir = parent.frame()) 
[13:19:57.385]                   {
[13:19:57.385]                     default_workers <- missing(workers)
[13:19:57.385]                     if (is.function(workers)) 
[13:19:57.385]                       workers <- workers()
[13:19:57.385]                     workers <- structure(as.integer(workers), 
[13:19:57.385]                       class = class(workers))
[13:19:57.385]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.385]                       1L)
[13:19:57.385]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.385]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.385]                       if (default_workers) 
[13:19:57.385]                         supportsMulticore(warn = TRUE)
[13:19:57.385]                       return(sequential(..., envir = envir))
[13:19:57.385]                     }
[13:19:57.385]                     oopts <- options(mc.cores = workers)
[13:19:57.385]                     on.exit(options(oopts))
[13:19:57.385]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.385]                       envir = envir)
[13:19:57.385]                     if (!future$lazy) 
[13:19:57.385]                       future <- run(future)
[13:19:57.385]                     invisible(future)
[13:19:57.385]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.385]                 }
[13:19:57.385]             }
[13:19:57.385]         }
[13:19:57.385]     })
[13:19:57.385]     if (TRUE) {
[13:19:57.385]         base::sink(type = "output", split = FALSE)
[13:19:57.385]         if (TRUE) {
[13:19:57.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.385]         }
[13:19:57.385]         else {
[13:19:57.385]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.385]         }
[13:19:57.385]         base::close(...future.stdout)
[13:19:57.385]         ...future.stdout <- NULL
[13:19:57.385]     }
[13:19:57.385]     ...future.result$conditions <- ...future.conditions
[13:19:57.385]     ...future.result$finished <- base::Sys.time()
[13:19:57.385]     ...future.result
[13:19:57.385] }
[13:19:57.389] assign_globals() ...
[13:19:57.389] List of 5
[13:19:57.389]  $ future.call.arguments    : list()
[13:19:57.389]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.389]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:57.389]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:57.389]  $ ...future.elements_ii    :List of 1
[13:19:57.389]   ..$ : num [1:4] 2 4 6 8
[13:19:57.389]  $ ...future.seeds_ii       : NULL
[13:19:57.389]  $ ...future.globals.maxSize: num Inf
[13:19:57.389]  - attr(*, "resolved")= logi FALSE
[13:19:57.389]  - attr(*, "total_size")= num NA
[13:19:57.389]  - attr(*, "where")=List of 5
[13:19:57.389]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.389]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.389]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.389]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.389]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.389]  - attr(*, "already-done")= logi TRUE
[13:19:57.396] - copied ‘future.call.arguments’ to environment
[13:19:57.397] - copied ‘...future.FUN’ to environment
[13:19:57.397] - copied ‘...future.elements_ii’ to environment
[13:19:57.397] - copied ‘...future.seeds_ii’ to environment
[13:19:57.397] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.397] assign_globals() ... done
[13:19:57.397] requestCore(): workers = 2
[13:19:57.406] MulticoreFuture started
[13:19:57.407] - Launch lazy future ... done
[13:19:57.408] run() for ‘MulticoreFuture’ ... done
[13:19:57.408] plan(): Setting new future strategy stack:
[13:19:57.408] Created future:
[13:19:57.408] List of future strategies:
[13:19:57.408] 1. sequential:
[13:19:57.408]    - args: function (..., envir = parent.frame())
[13:19:57.408]    - tweaked: FALSE
[13:19:57.408]    - call: NULL
[13:19:57.409] plan(): nbrOfWorkers() = 1
[13:19:57.412] plan(): Setting new future strategy stack:
[13:19:57.412] List of future strategies:
[13:19:57.412] 1. multicore:
[13:19:57.412]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.412]    - tweaked: FALSE
[13:19:57.412]    - call: plan(strategy)
[13:19:57.418] plan(): nbrOfWorkers() = 2
[13:19:57.409] MulticoreFuture:
[13:19:57.409] Label: ‘future_apply-2’
[13:19:57.409] Expression:
[13:19:57.409] {
[13:19:57.409]     do.call(function(...) {
[13:19:57.409]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.409]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.409]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.409]             on.exit(options(oopts), add = TRUE)
[13:19:57.409]         }
[13:19:57.409]         {
[13:19:57.409]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.409]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.409]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.409]             })
[13:19:57.409]         }
[13:19:57.409]     }, args = future.call.arguments)
[13:19:57.409] }
[13:19:57.409] Lazy evaluation: FALSE
[13:19:57.409] Asynchronous evaluation: TRUE
[13:19:57.409] Local evaluation: TRUE
[13:19:57.409] Environment: R_GlobalEnv
[13:19:57.409] Capture standard output: TRUE
[13:19:57.409] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.409] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.409] Packages: <none>
[13:19:57.409] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.409] Resolved: TRUE
[13:19:57.409] Value: <not collected>
[13:19:57.409] Conditions captured: <none>
[13:19:57.409] Early signaling: FALSE
[13:19:57.409] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.409] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.419] Chunk #2 of 2 ... DONE
[13:19:57.419] Launching 2 futures (chunks) ... DONE
[13:19:57.420] Resolving 2 futures (chunks) ...
[13:19:57.420] resolve() on list ...
[13:19:57.420]  recursive: 0
[13:19:57.420]  length: 2
[13:19:57.420] 
[13:19:57.421] Future #1
[13:19:57.422] result() for MulticoreFuture ...
[13:19:57.424] result() for MulticoreFuture ...
[13:19:57.424] result() for MulticoreFuture ... done
[13:19:57.424] result() for MulticoreFuture ... done
[13:19:57.424] result() for MulticoreFuture ...
[13:19:57.425] result() for MulticoreFuture ... done
[13:19:57.425] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:57.425] - nx: 2
[13:19:57.425] - relay: TRUE
[13:19:57.425] - stdout: TRUE
[13:19:57.425] - signal: TRUE
[13:19:57.426] - resignal: FALSE
[13:19:57.426] - force: TRUE
[13:19:57.426] - relayed: [n=2] FALSE, FALSE
[13:19:57.426] - queued futures: [n=2] FALSE, FALSE
[13:19:57.426]  - until=1
[13:19:57.426]  - relaying element #1
[13:19:57.427] result() for MulticoreFuture ...
[13:19:57.427] result() for MulticoreFuture ... done
[13:19:57.427] result() for MulticoreFuture ...
[13:19:57.427] result() for MulticoreFuture ... done
[13:19:57.427] result() for MulticoreFuture ...
[13:19:57.427] result() for MulticoreFuture ... done
[13:19:57.428] result() for MulticoreFuture ...
[13:19:57.428] result() for MulticoreFuture ... done
[13:19:57.428] - relayed: [n=2] TRUE, FALSE
[13:19:57.428] - queued futures: [n=2] TRUE, FALSE
[13:19:57.428] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:57.428]  length: 1 (resolved future 1)
[13:19:57.429] Future #2
[13:19:57.429] result() for MulticoreFuture ...
[13:19:57.430] result() for MulticoreFuture ...
[13:19:57.430] result() for MulticoreFuture ... done
[13:19:57.430] result() for MulticoreFuture ... done
[13:19:57.430] result() for MulticoreFuture ...
[13:19:57.430] result() for MulticoreFuture ... done
[13:19:57.430] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:57.431] - nx: 2
[13:19:57.431] - relay: TRUE
[13:19:57.431] - stdout: TRUE
[13:19:57.431] - signal: TRUE
[13:19:57.431] - resignal: FALSE
[13:19:57.431] - force: TRUE
[13:19:57.431] - relayed: [n=2] TRUE, FALSE
[13:19:57.431] - queued futures: [n=2] TRUE, FALSE
[13:19:57.431]  - until=2
[13:19:57.432]  - relaying element #2
[13:19:57.432] result() for MulticoreFuture ...
[13:19:57.432] result() for MulticoreFuture ... done
[13:19:57.432] result() for MulticoreFuture ...
[13:19:57.432] result() for MulticoreFuture ... done
[13:19:57.432] result() for MulticoreFuture ...
[13:19:57.432] result() for MulticoreFuture ... done
[13:19:57.433] result() for MulticoreFuture ...
[13:19:57.433] result() for MulticoreFuture ... done
[13:19:57.433] - relayed: [n=2] TRUE, TRUE
[13:19:57.433] - queued futures: [n=2] TRUE, TRUE
[13:19:57.433] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:57.433]  length: 0 (resolved future 2)
[13:19:57.433] Relaying remaining futures
[13:19:57.433] signalConditionsASAP(NULL, pos=0) ...
[13:19:57.433] - nx: 2
[13:19:57.434] - relay: TRUE
[13:19:57.434] - stdout: TRUE
[13:19:57.434] - signal: TRUE
[13:19:57.434] - resignal: FALSE
[13:19:57.434] - force: TRUE
[13:19:57.434] - relayed: [n=2] TRUE, TRUE
[13:19:57.434] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:57.434] - relayed: [n=2] TRUE, TRUE
[13:19:57.434] - queued futures: [n=2] TRUE, TRUE
[13:19:57.435] signalConditionsASAP(NULL, pos=0) ... done
[13:19:57.435] resolve() on list ... DONE
[13:19:57.435] result() for MulticoreFuture ...
[13:19:57.435] result() for MulticoreFuture ... done
[13:19:57.435] result() for MulticoreFuture ...
[13:19:57.435] result() for MulticoreFuture ... done
[13:19:57.435] result() for MulticoreFuture ...
[13:19:57.435] result() for MulticoreFuture ... done
[13:19:57.435] result() for MulticoreFuture ...
[13:19:57.436] result() for MulticoreFuture ... done
[13:19:57.436]  - Number of value chunks collected: 2
[13:19:57.436] Resolving 2 futures (chunks) ... DONE
[13:19:57.436] Reducing values from 2 chunks ...
[13:19:57.436]  - Number of values collected after concatenation: 2
[13:19:57.436]  - Number of values expected: 2
[13:19:57.436] Reducing values from 2 chunks ... DONE
[13:19:57.436] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:19:57.437] getGlobalsAndPackagesXApply() ...
[13:19:57.437]  - future.globals: TRUE
[13:19:57.437] getGlobalsAndPackages() ...
[13:19:57.437] Searching for globals...
[13:19:57.478] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:19:57.478] Searching for globals ... DONE
[13:19:57.478] Resolving globals: FALSE
[13:19:57.480] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:19:57.481] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:19:57.481] - globals: [1] ‘FUN’
[13:19:57.481] 
[13:19:57.481] getGlobalsAndPackages() ... DONE
[13:19:57.481]  - globals found/used: [n=1] ‘FUN’
[13:19:57.481]  - needed namespaces: [n=0] 
[13:19:57.481] Finding globals ... DONE
[13:19:57.481]  - use_args: TRUE
[13:19:57.481]  - Getting '...' globals ...
[13:19:57.482] resolve() on list ...
[13:19:57.482]  recursive: 0
[13:19:57.482]  length: 1
[13:19:57.482]  elements: ‘...’
[13:19:57.482]  length: 0 (resolved future 1)
[13:19:57.484] resolve() on list ... DONE
[13:19:57.484]    - '...' content: [n=0] 
[13:19:57.484] List of 1
[13:19:57.484]  $ ...: list()
[13:19:57.484]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.484]  - attr(*, "where")=List of 1
[13:19:57.484]   ..$ ...:<environment: 0x5559228dab00> 
[13:19:57.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.484]  - attr(*, "resolved")= logi TRUE
[13:19:57.484]  - attr(*, "total_size")= num NA
[13:19:57.487]  - Getting '...' globals ... DONE
[13:19:57.488] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:57.488] List of 2
[13:19:57.488]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:57.488]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:57.488]  $ ...          : list()
[13:19:57.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.488]  - attr(*, "where")=List of 2
[13:19:57.488]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:57.488]   ..$ ...          :<environment: 0x5559228dab00> 
[13:19:57.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.488]  - attr(*, "resolved")= logi FALSE
[13:19:57.488]  - attr(*, "total_size")= num 354224
[13:19:57.491] Packages to be attached in all futures: [n=0] 
[13:19:57.491] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.494] future_lapply() ...
[13:19:57.533] Number of chunks: 2
[13:19:57.533] getGlobalsAndPackagesXApply() ...
[13:19:57.533]  - future.globals: <name-value list> with names ‘list()’
[13:19:57.533]  - use_args: TRUE
[13:19:57.533] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:57.533] List of 2
[13:19:57.533]  $ ...          : list()
[13:19:57.533]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.533]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:57.533]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:57.533]  - attr(*, "where")=List of 2
[13:19:57.533]   ..$ ...          :<environment: 0x5559228dab00> 
[13:19:57.533]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:57.533]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.533]  - attr(*, "resolved")= logi FALSE
[13:19:57.533]  - attr(*, "total_size")= num NA
[13:19:57.537] Packages to be attached in all futures: [n=0] 
[13:19:57.537] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.537] Number of futures (= number of chunks): 2
[13:19:57.537] Launching 2 futures (chunks) ...
[13:19:57.538] Chunk #1 of 2 ...
[13:19:57.538]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:57.538]  - seeds: <none>
[13:19:57.538]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.538] getGlobalsAndPackages() ...
[13:19:57.538] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.538] Resolving globals: FALSE
[13:19:57.538] Tweak future expression to call with '...' arguments ...
[13:19:57.539] {
[13:19:57.539]     do.call(function(...) {
[13:19:57.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.539]             on.exit(options(oopts), add = TRUE)
[13:19:57.539]         }
[13:19:57.539]         {
[13:19:57.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.539]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.539]             })
[13:19:57.539]         }
[13:19:57.539]     }, args = future.call.arguments)
[13:19:57.539] }
[13:19:57.539] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.539] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.539] 
[13:19:57.539] getGlobalsAndPackages() ... DONE
[13:19:57.540] run() for ‘Future’ ...
[13:19:57.540] - state: ‘created’
[13:19:57.540] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.544] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.544] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.544]   - Field: ‘label’
[13:19:57.544]   - Field: ‘local’
[13:19:57.544]   - Field: ‘owner’
[13:19:57.544]   - Field: ‘envir’
[13:19:57.544]   - Field: ‘workers’
[13:19:57.545]   - Field: ‘packages’
[13:19:57.545]   - Field: ‘gc’
[13:19:57.545]   - Field: ‘job’
[13:19:57.545]   - Field: ‘conditions’
[13:19:57.545]   - Field: ‘expr’
[13:19:57.545]   - Field: ‘uuid’
[13:19:57.545]   - Field: ‘seed’
[13:19:57.545]   - Field: ‘version’
[13:19:57.545]   - Field: ‘result’
[13:19:57.545]   - Field: ‘asynchronous’
[13:19:57.545]   - Field: ‘calls’
[13:19:57.546]   - Field: ‘globals’
[13:19:57.546]   - Field: ‘stdout’
[13:19:57.546]   - Field: ‘earlySignal’
[13:19:57.546]   - Field: ‘lazy’
[13:19:57.546]   - Field: ‘state’
[13:19:57.546] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.546] - Launch lazy future ...
[13:19:57.546] Packages needed by the future expression (n = 0): <none>
[13:19:57.547] Packages needed by future strategies (n = 0): <none>
[13:19:57.549] {
[13:19:57.549]     {
[13:19:57.549]         {
[13:19:57.549]             ...future.startTime <- base::Sys.time()
[13:19:57.549]             {
[13:19:57.549]                 {
[13:19:57.549]                   {
[13:19:57.549]                     {
[13:19:57.549]                       base::local({
[13:19:57.549]                         has_future <- base::requireNamespace("future", 
[13:19:57.549]                           quietly = TRUE)
[13:19:57.549]                         if (has_future) {
[13:19:57.549]                           ns <- base::getNamespace("future")
[13:19:57.549]                           version <- ns[[".package"]][["version"]]
[13:19:57.549]                           if (is.null(version)) 
[13:19:57.549]                             version <- utils::packageVersion("future")
[13:19:57.549]                         }
[13:19:57.549]                         else {
[13:19:57.549]                           version <- NULL
[13:19:57.549]                         }
[13:19:57.549]                         if (!has_future || version < "1.8.0") {
[13:19:57.549]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.549]                             "", base::R.version$version.string), 
[13:19:57.549]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:57.549]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.549]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.549]                               "release", "version")], collapse = " "), 
[13:19:57.549]                             hostname = base::Sys.info()[["nodename"]])
[13:19:57.549]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.549]                             info)
[13:19:57.549]                           info <- base::paste(info, collapse = "; ")
[13:19:57.549]                           if (!has_future) {
[13:19:57.549]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.549]                               info)
[13:19:57.549]                           }
[13:19:57.549]                           else {
[13:19:57.549]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.549]                               info, version)
[13:19:57.549]                           }
[13:19:57.549]                           base::stop(msg)
[13:19:57.549]                         }
[13:19:57.549]                       })
[13:19:57.549]                     }
[13:19:57.549]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.549]                     base::options(mc.cores = 1L)
[13:19:57.549]                   }
[13:19:57.549]                   options(future.plan = NULL)
[13:19:57.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.549]                 }
[13:19:57.549]                 ...future.workdir <- getwd()
[13:19:57.549]             }
[13:19:57.549]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.549]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.549]         }
[13:19:57.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.549]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.549]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.549]             base::names(...future.oldOptions))
[13:19:57.549]     }
[13:19:57.549]     if (FALSE) {
[13:19:57.549]     }
[13:19:57.549]     else {
[13:19:57.549]         if (TRUE) {
[13:19:57.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.549]                 open = "w")
[13:19:57.549]         }
[13:19:57.549]         else {
[13:19:57.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.549]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.549]         }
[13:19:57.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.549]             base::sink(type = "output", split = FALSE)
[13:19:57.549]             base::close(...future.stdout)
[13:19:57.549]         }, add = TRUE)
[13:19:57.549]     }
[13:19:57.549]     ...future.frame <- base::sys.nframe()
[13:19:57.549]     ...future.conditions <- base::list()
[13:19:57.549]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.549]     if (FALSE) {
[13:19:57.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.549]     }
[13:19:57.549]     ...future.result <- base::tryCatch({
[13:19:57.549]         base::withCallingHandlers({
[13:19:57.549]             ...future.value <- base::withVisible(base::local({
[13:19:57.549]                 withCallingHandlers({
[13:19:57.549]                   {
[13:19:57.549]                     do.call(function(...) {
[13:19:57.549]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.549]                       if (!identical(...future.globals.maxSize.org, 
[13:19:57.549]                         ...future.globals.maxSize)) {
[13:19:57.549]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.549]                         on.exit(options(oopts), add = TRUE)
[13:19:57.549]                       }
[13:19:57.549]                       {
[13:19:57.549]                         lapply(seq_along(...future.elements_ii), 
[13:19:57.549]                           FUN = function(jj) {
[13:19:57.549]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.549]                             ...future.FUN(...future.X_jj, ...)
[13:19:57.549]                           })
[13:19:57.549]                       }
[13:19:57.549]                     }, args = future.call.arguments)
[13:19:57.549]                   }
[13:19:57.549]                 }, immediateCondition = function(cond) {
[13:19:57.549]                   save_rds <- function (object, pathname, ...) 
[13:19:57.549]                   {
[13:19:57.549]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.549]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.549]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.549]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.549]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.549]                         fi_tmp[["mtime"]])
[13:19:57.549]                     }
[13:19:57.549]                     tryCatch({
[13:19:57.549]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.549]                     }, error = function(ex) {
[13:19:57.549]                       msg <- conditionMessage(ex)
[13:19:57.549]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.549]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.549]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.549]                         fi_tmp[["mtime"]], msg)
[13:19:57.549]                       ex$message <- msg
[13:19:57.549]                       stop(ex)
[13:19:57.549]                     })
[13:19:57.549]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.549]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.549]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.549]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.549]                       fi <- file.info(pathname)
[13:19:57.549]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.549]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.549]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.549]                         fi[["size"]], fi[["mtime"]])
[13:19:57.549]                       stop(msg)
[13:19:57.549]                     }
[13:19:57.549]                     invisible(pathname)
[13:19:57.549]                   }
[13:19:57.549]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.549]                     rootPath = tempdir()) 
[13:19:57.549]                   {
[13:19:57.549]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.549]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.549]                       tmpdir = path, fileext = ".rds")
[13:19:57.549]                     save_rds(obj, file)
[13:19:57.549]                   }
[13:19:57.549]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:57.549]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.549]                   {
[13:19:57.549]                     inherits <- base::inherits
[13:19:57.549]                     invokeRestart <- base::invokeRestart
[13:19:57.549]                     is.null <- base::is.null
[13:19:57.549]                     muffled <- FALSE
[13:19:57.549]                     if (inherits(cond, "message")) {
[13:19:57.549]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.549]                       if (muffled) 
[13:19:57.549]                         invokeRestart("muffleMessage")
[13:19:57.549]                     }
[13:19:57.549]                     else if (inherits(cond, "warning")) {
[13:19:57.549]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.549]                       if (muffled) 
[13:19:57.549]                         invokeRestart("muffleWarning")
[13:19:57.549]                     }
[13:19:57.549]                     else if (inherits(cond, "condition")) {
[13:19:57.549]                       if (!is.null(pattern)) {
[13:19:57.549]                         computeRestarts <- base::computeRestarts
[13:19:57.549]                         grepl <- base::grepl
[13:19:57.549]                         restarts <- computeRestarts(cond)
[13:19:57.549]                         for (restart in restarts) {
[13:19:57.549]                           name <- restart$name
[13:19:57.549]                           if (is.null(name)) 
[13:19:57.549]                             next
[13:19:57.549]                           if (!grepl(pattern, name)) 
[13:19:57.549]                             next
[13:19:57.549]                           invokeRestart(restart)
[13:19:57.549]                           muffled <- TRUE
[13:19:57.549]                           break
[13:19:57.549]                         }
[13:19:57.549]                       }
[13:19:57.549]                     }
[13:19:57.549]                     invisible(muffled)
[13:19:57.549]                   }
[13:19:57.549]                   muffleCondition(cond)
[13:19:57.549]                 })
[13:19:57.549]             }))
[13:19:57.549]             future::FutureResult(value = ...future.value$value, 
[13:19:57.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.549]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.549]                     ...future.globalenv.names))
[13:19:57.549]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.549]         }, condition = base::local({
[13:19:57.549]             c <- base::c
[13:19:57.549]             inherits <- base::inherits
[13:19:57.549]             invokeRestart <- base::invokeRestart
[13:19:57.549]             length <- base::length
[13:19:57.549]             list <- base::list
[13:19:57.549]             seq.int <- base::seq.int
[13:19:57.549]             signalCondition <- base::signalCondition
[13:19:57.549]             sys.calls <- base::sys.calls
[13:19:57.549]             `[[` <- base::`[[`
[13:19:57.549]             `+` <- base::`+`
[13:19:57.549]             `<<-` <- base::`<<-`
[13:19:57.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.549]                   3L)]
[13:19:57.549]             }
[13:19:57.549]             function(cond) {
[13:19:57.549]                 is_error <- inherits(cond, "error")
[13:19:57.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.549]                   NULL)
[13:19:57.549]                 if (is_error) {
[13:19:57.549]                   sessionInformation <- function() {
[13:19:57.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.549]                       search = base::search(), system = base::Sys.info())
[13:19:57.549]                   }
[13:19:57.549]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.549]                     cond$call), session = sessionInformation(), 
[13:19:57.549]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.549]                   signalCondition(cond)
[13:19:57.549]                 }
[13:19:57.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.549]                 "immediateCondition"))) {
[13:19:57.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.549]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.549]                   if (TRUE && !signal) {
[13:19:57.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.549]                     {
[13:19:57.549]                       inherits <- base::inherits
[13:19:57.549]                       invokeRestart <- base::invokeRestart
[13:19:57.549]                       is.null <- base::is.null
[13:19:57.549]                       muffled <- FALSE
[13:19:57.549]                       if (inherits(cond, "message")) {
[13:19:57.549]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.549]                         if (muffled) 
[13:19:57.549]                           invokeRestart("muffleMessage")
[13:19:57.549]                       }
[13:19:57.549]                       else if (inherits(cond, "warning")) {
[13:19:57.549]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.549]                         if (muffled) 
[13:19:57.549]                           invokeRestart("muffleWarning")
[13:19:57.549]                       }
[13:19:57.549]                       else if (inherits(cond, "condition")) {
[13:19:57.549]                         if (!is.null(pattern)) {
[13:19:57.549]                           computeRestarts <- base::computeRestarts
[13:19:57.549]                           grepl <- base::grepl
[13:19:57.549]                           restarts <- computeRestarts(cond)
[13:19:57.549]                           for (restart in restarts) {
[13:19:57.549]                             name <- restart$name
[13:19:57.549]                             if (is.null(name)) 
[13:19:57.549]                               next
[13:19:57.549]                             if (!grepl(pattern, name)) 
[13:19:57.549]                               next
[13:19:57.549]                             invokeRestart(restart)
[13:19:57.549]                             muffled <- TRUE
[13:19:57.549]                             break
[13:19:57.549]                           }
[13:19:57.549]                         }
[13:19:57.549]                       }
[13:19:57.549]                       invisible(muffled)
[13:19:57.549]                     }
[13:19:57.549]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.549]                   }
[13:19:57.549]                 }
[13:19:57.549]                 else {
[13:19:57.549]                   if (TRUE) {
[13:19:57.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.549]                     {
[13:19:57.549]                       inherits <- base::inherits
[13:19:57.549]                       invokeRestart <- base::invokeRestart
[13:19:57.549]                       is.null <- base::is.null
[13:19:57.549]                       muffled <- FALSE
[13:19:57.549]                       if (inherits(cond, "message")) {
[13:19:57.549]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.549]                         if (muffled) 
[13:19:57.549]                           invokeRestart("muffleMessage")
[13:19:57.549]                       }
[13:19:57.549]                       else if (inherits(cond, "warning")) {
[13:19:57.549]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.549]                         if (muffled) 
[13:19:57.549]                           invokeRestart("muffleWarning")
[13:19:57.549]                       }
[13:19:57.549]                       else if (inherits(cond, "condition")) {
[13:19:57.549]                         if (!is.null(pattern)) {
[13:19:57.549]                           computeRestarts <- base::computeRestarts
[13:19:57.549]                           grepl <- base::grepl
[13:19:57.549]                           restarts <- computeRestarts(cond)
[13:19:57.549]                           for (restart in restarts) {
[13:19:57.549]                             name <- restart$name
[13:19:57.549]                             if (is.null(name)) 
[13:19:57.549]                               next
[13:19:57.549]                             if (!grepl(pattern, name)) 
[13:19:57.549]                               next
[13:19:57.549]                             invokeRestart(restart)
[13:19:57.549]                             muffled <- TRUE
[13:19:57.549]                             break
[13:19:57.549]                           }
[13:19:57.549]                         }
[13:19:57.549]                       }
[13:19:57.549]                       invisible(muffled)
[13:19:57.549]                     }
[13:19:57.549]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.549]                   }
[13:19:57.549]                 }
[13:19:57.549]             }
[13:19:57.549]         }))
[13:19:57.549]     }, error = function(ex) {
[13:19:57.549]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.549]                 ...future.rng), started = ...future.startTime, 
[13:19:57.549]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.549]             version = "1.8"), class = "FutureResult")
[13:19:57.549]     }, finally = {
[13:19:57.549]         if (!identical(...future.workdir, getwd())) 
[13:19:57.549]             setwd(...future.workdir)
[13:19:57.549]         {
[13:19:57.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.549]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.549]             }
[13:19:57.549]             base::options(...future.oldOptions)
[13:19:57.549]             if (.Platform$OS.type == "windows") {
[13:19:57.549]                 old_names <- names(...future.oldEnvVars)
[13:19:57.549]                 envs <- base::Sys.getenv()
[13:19:57.549]                 names <- names(envs)
[13:19:57.549]                 common <- intersect(names, old_names)
[13:19:57.549]                 added <- setdiff(names, old_names)
[13:19:57.549]                 removed <- setdiff(old_names, names)
[13:19:57.549]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.549]                   envs[common]]
[13:19:57.549]                 NAMES <- toupper(changed)
[13:19:57.549]                 args <- list()
[13:19:57.549]                 for (kk in seq_along(NAMES)) {
[13:19:57.549]                   name <- changed[[kk]]
[13:19:57.549]                   NAME <- NAMES[[kk]]
[13:19:57.549]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.549]                     next
[13:19:57.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.549]                 }
[13:19:57.549]                 NAMES <- toupper(added)
[13:19:57.549]                 for (kk in seq_along(NAMES)) {
[13:19:57.549]                   name <- added[[kk]]
[13:19:57.549]                   NAME <- NAMES[[kk]]
[13:19:57.549]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.549]                     next
[13:19:57.549]                   args[[name]] <- ""
[13:19:57.549]                 }
[13:19:57.549]                 NAMES <- toupper(removed)
[13:19:57.549]                 for (kk in seq_along(NAMES)) {
[13:19:57.549]                   name <- removed[[kk]]
[13:19:57.549]                   NAME <- NAMES[[kk]]
[13:19:57.549]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.549]                     next
[13:19:57.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.549]                 }
[13:19:57.549]                 if (length(args) > 0) 
[13:19:57.549]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.549]             }
[13:19:57.549]             else {
[13:19:57.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.549]             }
[13:19:57.549]             {
[13:19:57.549]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.549]                   0L) {
[13:19:57.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.549]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.549]                   base::options(opts)
[13:19:57.549]                 }
[13:19:57.549]                 {
[13:19:57.549]                   {
[13:19:57.549]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.549]                     NULL
[13:19:57.549]                   }
[13:19:57.549]                   options(future.plan = NULL)
[13:19:57.549]                   if (is.na(NA_character_)) 
[13:19:57.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.549]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.549]                     envir = parent.frame()) 
[13:19:57.549]                   {
[13:19:57.549]                     default_workers <- missing(workers)
[13:19:57.549]                     if (is.function(workers)) 
[13:19:57.549]                       workers <- workers()
[13:19:57.549]                     workers <- structure(as.integer(workers), 
[13:19:57.549]                       class = class(workers))
[13:19:57.549]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.549]                       1L)
[13:19:57.549]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.549]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.549]                       if (default_workers) 
[13:19:57.549]                         supportsMulticore(warn = TRUE)
[13:19:57.549]                       return(sequential(..., envir = envir))
[13:19:57.549]                     }
[13:19:57.549]                     oopts <- options(mc.cores = workers)
[13:19:57.549]                     on.exit(options(oopts))
[13:19:57.549]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.549]                       envir = envir)
[13:19:57.549]                     if (!future$lazy) 
[13:19:57.549]                       future <- run(future)
[13:19:57.549]                     invisible(future)
[13:19:57.549]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.549]                 }
[13:19:57.549]             }
[13:19:57.549]         }
[13:19:57.549]     })
[13:19:57.549]     if (TRUE) {
[13:19:57.549]         base::sink(type = "output", split = FALSE)
[13:19:57.549]         if (TRUE) {
[13:19:57.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.549]         }
[13:19:57.549]         else {
[13:19:57.549]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.549]         }
[13:19:57.549]         base::close(...future.stdout)
[13:19:57.549]         ...future.stdout <- NULL
[13:19:57.549]     }
[13:19:57.549]     ...future.result$conditions <- ...future.conditions
[13:19:57.549]     ...future.result$finished <- base::Sys.time()
[13:19:57.549]     ...future.result
[13:19:57.549] }
[13:19:57.551] assign_globals() ...
[13:19:57.551] List of 5
[13:19:57.551]  $ future.call.arguments    : list()
[13:19:57.551]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.551]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:57.551]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:57.551]  $ ...future.elements_ii    :List of 1
[13:19:57.551]   ..$ : num [1:4] 1 3 1 7
[13:19:57.551]  $ ...future.seeds_ii       : NULL
[13:19:57.551]  $ ...future.globals.maxSize: num Inf
[13:19:57.551]  - attr(*, "resolved")= logi FALSE
[13:19:57.551]  - attr(*, "total_size")= num NA
[13:19:57.551]  - attr(*, "where")=List of 5
[13:19:57.551]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.551]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.551]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.551]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.551]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.551]  - attr(*, "already-done")= logi TRUE
[13:19:57.557] - copied ‘future.call.arguments’ to environment
[13:19:57.557] - copied ‘...future.FUN’ to environment
[13:19:57.557] - copied ‘...future.elements_ii’ to environment
[13:19:57.557] - copied ‘...future.seeds_ii’ to environment
[13:19:57.557] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.557] assign_globals() ... done
[13:19:57.557] requestCore(): workers = 2
[13:19:57.560] MulticoreFuture started
[13:19:57.560] - Launch lazy future ... done
[13:19:57.560] run() for ‘MulticoreFuture’ ... done
[13:19:57.561] Created future:
[13:19:57.561] plan(): Setting new future strategy stack:
[13:19:57.561] List of future strategies:
[13:19:57.561] 1. sequential:
[13:19:57.561]    - args: function (..., envir = parent.frame())
[13:19:57.561]    - tweaked: FALSE
[13:19:57.561]    - call: NULL
[13:19:57.562] plan(): nbrOfWorkers() = 1
[13:19:57.564] plan(): Setting new future strategy stack:
[13:19:57.564] List of future strategies:
[13:19:57.564] 1. multicore:
[13:19:57.564]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.564]    - tweaked: FALSE
[13:19:57.564]    - call: plan(strategy)
[13:19:57.569] plan(): nbrOfWorkers() = 2
[13:19:57.561] MulticoreFuture:
[13:19:57.561] Label: ‘future_apply-1’
[13:19:57.561] Expression:
[13:19:57.561] {
[13:19:57.561]     do.call(function(...) {
[13:19:57.561]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.561]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.561]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.561]             on.exit(options(oopts), add = TRUE)
[13:19:57.561]         }
[13:19:57.561]         {
[13:19:57.561]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.561]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.561]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.561]             })
[13:19:57.561]         }
[13:19:57.561]     }, args = future.call.arguments)
[13:19:57.561] }
[13:19:57.561] Lazy evaluation: FALSE
[13:19:57.561] Asynchronous evaluation: TRUE
[13:19:57.561] Local evaluation: TRUE
[13:19:57.561] Environment: R_GlobalEnv
[13:19:57.561] Capture standard output: TRUE
[13:19:57.561] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.561] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.561] Packages: <none>
[13:19:57.561] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.561] Resolved: TRUE
[13:19:57.561] Value: <not collected>
[13:19:57.561] Conditions captured: <none>
[13:19:57.561] Early signaling: FALSE
[13:19:57.561] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.561] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.570] Chunk #1 of 2 ... DONE
[13:19:57.570] Chunk #2 of 2 ...
[13:19:57.571]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:57.571]  - seeds: <none>
[13:19:57.571]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.571] getGlobalsAndPackages() ...
[13:19:57.571] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.572] Resolving globals: FALSE
[13:19:57.572] Tweak future expression to call with '...' arguments ...
[13:19:57.572] {
[13:19:57.572]     do.call(function(...) {
[13:19:57.572]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.572]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.572]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.572]             on.exit(options(oopts), add = TRUE)
[13:19:57.572]         }
[13:19:57.572]         {
[13:19:57.572]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.572]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.572]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.572]             })
[13:19:57.572]         }
[13:19:57.572]     }, args = future.call.arguments)
[13:19:57.572] }
[13:19:57.572] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.573] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.573] 
[13:19:57.573] getGlobalsAndPackages() ... DONE
[13:19:57.574] run() for ‘Future’ ...
[13:19:57.574] - state: ‘created’
[13:19:57.574] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.579] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.579] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.579]   - Field: ‘label’
[13:19:57.580]   - Field: ‘local’
[13:19:57.580]   - Field: ‘owner’
[13:19:57.580]   - Field: ‘envir’
[13:19:57.580]   - Field: ‘workers’
[13:19:57.580]   - Field: ‘packages’
[13:19:57.580]   - Field: ‘gc’
[13:19:57.581]   - Field: ‘job’
[13:19:57.581]   - Field: ‘conditions’
[13:19:57.581]   - Field: ‘expr’
[13:19:57.581]   - Field: ‘uuid’
[13:19:57.581]   - Field: ‘seed’
[13:19:57.581]   - Field: ‘version’
[13:19:57.582]   - Field: ‘result’
[13:19:57.582]   - Field: ‘asynchronous’
[13:19:57.582]   - Field: ‘calls’
[13:19:57.582]   - Field: ‘globals’
[13:19:57.582]   - Field: ‘stdout’
[13:19:57.582]   - Field: ‘earlySignal’
[13:19:57.582]   - Field: ‘lazy’
[13:19:57.583]   - Field: ‘state’
[13:19:57.583] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.583] - Launch lazy future ...
[13:19:57.583] Packages needed by the future expression (n = 0): <none>
[13:19:57.584] Packages needed by future strategies (n = 0): <none>
[13:19:57.584] {
[13:19:57.584]     {
[13:19:57.584]         {
[13:19:57.584]             ...future.startTime <- base::Sys.time()
[13:19:57.584]             {
[13:19:57.584]                 {
[13:19:57.584]                   {
[13:19:57.584]                     {
[13:19:57.584]                       base::local({
[13:19:57.584]                         has_future <- base::requireNamespace("future", 
[13:19:57.584]                           quietly = TRUE)
[13:19:57.584]                         if (has_future) {
[13:19:57.584]                           ns <- base::getNamespace("future")
[13:19:57.584]                           version <- ns[[".package"]][["version"]]
[13:19:57.584]                           if (is.null(version)) 
[13:19:57.584]                             version <- utils::packageVersion("future")
[13:19:57.584]                         }
[13:19:57.584]                         else {
[13:19:57.584]                           version <- NULL
[13:19:57.584]                         }
[13:19:57.584]                         if (!has_future || version < "1.8.0") {
[13:19:57.584]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.584]                             "", base::R.version$version.string), 
[13:19:57.584]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:57.584]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.584]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.584]                               "release", "version")], collapse = " "), 
[13:19:57.584]                             hostname = base::Sys.info()[["nodename"]])
[13:19:57.584]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.584]                             info)
[13:19:57.584]                           info <- base::paste(info, collapse = "; ")
[13:19:57.584]                           if (!has_future) {
[13:19:57.584]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.584]                               info)
[13:19:57.584]                           }
[13:19:57.584]                           else {
[13:19:57.584]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.584]                               info, version)
[13:19:57.584]                           }
[13:19:57.584]                           base::stop(msg)
[13:19:57.584]                         }
[13:19:57.584]                       })
[13:19:57.584]                     }
[13:19:57.584]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.584]                     base::options(mc.cores = 1L)
[13:19:57.584]                   }
[13:19:57.584]                   options(future.plan = NULL)
[13:19:57.584]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.584]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.584]                 }
[13:19:57.584]                 ...future.workdir <- getwd()
[13:19:57.584]             }
[13:19:57.584]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.584]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.584]         }
[13:19:57.584]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.584]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.584]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.584]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.584]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.584]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.584]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.584]             base::names(...future.oldOptions))
[13:19:57.584]     }
[13:19:57.584]     if (FALSE) {
[13:19:57.584]     }
[13:19:57.584]     else {
[13:19:57.584]         if (TRUE) {
[13:19:57.584]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.584]                 open = "w")
[13:19:57.584]         }
[13:19:57.584]         else {
[13:19:57.584]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.584]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.584]         }
[13:19:57.584]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.584]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.584]             base::sink(type = "output", split = FALSE)
[13:19:57.584]             base::close(...future.stdout)
[13:19:57.584]         }, add = TRUE)
[13:19:57.584]     }
[13:19:57.584]     ...future.frame <- base::sys.nframe()
[13:19:57.584]     ...future.conditions <- base::list()
[13:19:57.584]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.584]     if (FALSE) {
[13:19:57.584]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.584]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.584]     }
[13:19:57.584]     ...future.result <- base::tryCatch({
[13:19:57.584]         base::withCallingHandlers({
[13:19:57.584]             ...future.value <- base::withVisible(base::local({
[13:19:57.584]                 withCallingHandlers({
[13:19:57.584]                   {
[13:19:57.584]                     do.call(function(...) {
[13:19:57.584]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.584]                       if (!identical(...future.globals.maxSize.org, 
[13:19:57.584]                         ...future.globals.maxSize)) {
[13:19:57.584]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.584]                         on.exit(options(oopts), add = TRUE)
[13:19:57.584]                       }
[13:19:57.584]                       {
[13:19:57.584]                         lapply(seq_along(...future.elements_ii), 
[13:19:57.584]                           FUN = function(jj) {
[13:19:57.584]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.584]                             ...future.FUN(...future.X_jj, ...)
[13:19:57.584]                           })
[13:19:57.584]                       }
[13:19:57.584]                     }, args = future.call.arguments)
[13:19:57.584]                   }
[13:19:57.584]                 }, immediateCondition = function(cond) {
[13:19:57.584]                   save_rds <- function (object, pathname, ...) 
[13:19:57.584]                   {
[13:19:57.584]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.584]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.584]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.584]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.584]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.584]                         fi_tmp[["mtime"]])
[13:19:57.584]                     }
[13:19:57.584]                     tryCatch({
[13:19:57.584]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.584]                     }, error = function(ex) {
[13:19:57.584]                       msg <- conditionMessage(ex)
[13:19:57.584]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.584]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.584]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.584]                         fi_tmp[["mtime"]], msg)
[13:19:57.584]                       ex$message <- msg
[13:19:57.584]                       stop(ex)
[13:19:57.584]                     })
[13:19:57.584]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.584]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.584]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.584]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.584]                       fi <- file.info(pathname)
[13:19:57.584]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.584]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.584]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.584]                         fi[["size"]], fi[["mtime"]])
[13:19:57.584]                       stop(msg)
[13:19:57.584]                     }
[13:19:57.584]                     invisible(pathname)
[13:19:57.584]                   }
[13:19:57.584]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.584]                     rootPath = tempdir()) 
[13:19:57.584]                   {
[13:19:57.584]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.584]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.584]                       tmpdir = path, fileext = ".rds")
[13:19:57.584]                     save_rds(obj, file)
[13:19:57.584]                   }
[13:19:57.584]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:57.584]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.584]                   {
[13:19:57.584]                     inherits <- base::inherits
[13:19:57.584]                     invokeRestart <- base::invokeRestart
[13:19:57.584]                     is.null <- base::is.null
[13:19:57.584]                     muffled <- FALSE
[13:19:57.584]                     if (inherits(cond, "message")) {
[13:19:57.584]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.584]                       if (muffled) 
[13:19:57.584]                         invokeRestart("muffleMessage")
[13:19:57.584]                     }
[13:19:57.584]                     else if (inherits(cond, "warning")) {
[13:19:57.584]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.584]                       if (muffled) 
[13:19:57.584]                         invokeRestart("muffleWarning")
[13:19:57.584]                     }
[13:19:57.584]                     else if (inherits(cond, "condition")) {
[13:19:57.584]                       if (!is.null(pattern)) {
[13:19:57.584]                         computeRestarts <- base::computeRestarts
[13:19:57.584]                         grepl <- base::grepl
[13:19:57.584]                         restarts <- computeRestarts(cond)
[13:19:57.584]                         for (restart in restarts) {
[13:19:57.584]                           name <- restart$name
[13:19:57.584]                           if (is.null(name)) 
[13:19:57.584]                             next
[13:19:57.584]                           if (!grepl(pattern, name)) 
[13:19:57.584]                             next
[13:19:57.584]                           invokeRestart(restart)
[13:19:57.584]                           muffled <- TRUE
[13:19:57.584]                           break
[13:19:57.584]                         }
[13:19:57.584]                       }
[13:19:57.584]                     }
[13:19:57.584]                     invisible(muffled)
[13:19:57.584]                   }
[13:19:57.584]                   muffleCondition(cond)
[13:19:57.584]                 })
[13:19:57.584]             }))
[13:19:57.584]             future::FutureResult(value = ...future.value$value, 
[13:19:57.584]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.584]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.584]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.584]                     ...future.globalenv.names))
[13:19:57.584]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.584]         }, condition = base::local({
[13:19:57.584]             c <- base::c
[13:19:57.584]             inherits <- base::inherits
[13:19:57.584]             invokeRestart <- base::invokeRestart
[13:19:57.584]             length <- base::length
[13:19:57.584]             list <- base::list
[13:19:57.584]             seq.int <- base::seq.int
[13:19:57.584]             signalCondition <- base::signalCondition
[13:19:57.584]             sys.calls <- base::sys.calls
[13:19:57.584]             `[[` <- base::`[[`
[13:19:57.584]             `+` <- base::`+`
[13:19:57.584]             `<<-` <- base::`<<-`
[13:19:57.584]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.584]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.584]                   3L)]
[13:19:57.584]             }
[13:19:57.584]             function(cond) {
[13:19:57.584]                 is_error <- inherits(cond, "error")
[13:19:57.584]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.584]                   NULL)
[13:19:57.584]                 if (is_error) {
[13:19:57.584]                   sessionInformation <- function() {
[13:19:57.584]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.584]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.584]                       search = base::search(), system = base::Sys.info())
[13:19:57.584]                   }
[13:19:57.584]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.584]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.584]                     cond$call), session = sessionInformation(), 
[13:19:57.584]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.584]                   signalCondition(cond)
[13:19:57.584]                 }
[13:19:57.584]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.584]                 "immediateCondition"))) {
[13:19:57.584]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.584]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.584]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.584]                   if (TRUE && !signal) {
[13:19:57.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.584]                     {
[13:19:57.584]                       inherits <- base::inherits
[13:19:57.584]                       invokeRestart <- base::invokeRestart
[13:19:57.584]                       is.null <- base::is.null
[13:19:57.584]                       muffled <- FALSE
[13:19:57.584]                       if (inherits(cond, "message")) {
[13:19:57.584]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.584]                         if (muffled) 
[13:19:57.584]                           invokeRestart("muffleMessage")
[13:19:57.584]                       }
[13:19:57.584]                       else if (inherits(cond, "warning")) {
[13:19:57.584]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.584]                         if (muffled) 
[13:19:57.584]                           invokeRestart("muffleWarning")
[13:19:57.584]                       }
[13:19:57.584]                       else if (inherits(cond, "condition")) {
[13:19:57.584]                         if (!is.null(pattern)) {
[13:19:57.584]                           computeRestarts <- base::computeRestarts
[13:19:57.584]                           grepl <- base::grepl
[13:19:57.584]                           restarts <- computeRestarts(cond)
[13:19:57.584]                           for (restart in restarts) {
[13:19:57.584]                             name <- restart$name
[13:19:57.584]                             if (is.null(name)) 
[13:19:57.584]                               next
[13:19:57.584]                             if (!grepl(pattern, name)) 
[13:19:57.584]                               next
[13:19:57.584]                             invokeRestart(restart)
[13:19:57.584]                             muffled <- TRUE
[13:19:57.584]                             break
[13:19:57.584]                           }
[13:19:57.584]                         }
[13:19:57.584]                       }
[13:19:57.584]                       invisible(muffled)
[13:19:57.584]                     }
[13:19:57.584]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.584]                   }
[13:19:57.584]                 }
[13:19:57.584]                 else {
[13:19:57.584]                   if (TRUE) {
[13:19:57.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.584]                     {
[13:19:57.584]                       inherits <- base::inherits
[13:19:57.584]                       invokeRestart <- base::invokeRestart
[13:19:57.584]                       is.null <- base::is.null
[13:19:57.584]                       muffled <- FALSE
[13:19:57.584]                       if (inherits(cond, "message")) {
[13:19:57.584]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.584]                         if (muffled) 
[13:19:57.584]                           invokeRestart("muffleMessage")
[13:19:57.584]                       }
[13:19:57.584]                       else if (inherits(cond, "warning")) {
[13:19:57.584]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.584]                         if (muffled) 
[13:19:57.584]                           invokeRestart("muffleWarning")
[13:19:57.584]                       }
[13:19:57.584]                       else if (inherits(cond, "condition")) {
[13:19:57.584]                         if (!is.null(pattern)) {
[13:19:57.584]                           computeRestarts <- base::computeRestarts
[13:19:57.584]                           grepl <- base::grepl
[13:19:57.584]                           restarts <- computeRestarts(cond)
[13:19:57.584]                           for (restart in restarts) {
[13:19:57.584]                             name <- restart$name
[13:19:57.584]                             if (is.null(name)) 
[13:19:57.584]                               next
[13:19:57.584]                             if (!grepl(pattern, name)) 
[13:19:57.584]                               next
[13:19:57.584]                             invokeRestart(restart)
[13:19:57.584]                             muffled <- TRUE
[13:19:57.584]                             break
[13:19:57.584]                           }
[13:19:57.584]                         }
[13:19:57.584]                       }
[13:19:57.584]                       invisible(muffled)
[13:19:57.584]                     }
[13:19:57.584]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.584]                   }
[13:19:57.584]                 }
[13:19:57.584]             }
[13:19:57.584]         }))
[13:19:57.584]     }, error = function(ex) {
[13:19:57.584]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.584]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.584]                 ...future.rng), started = ...future.startTime, 
[13:19:57.584]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.584]             version = "1.8"), class = "FutureResult")
[13:19:57.584]     }, finally = {
[13:19:57.584]         if (!identical(...future.workdir, getwd())) 
[13:19:57.584]             setwd(...future.workdir)
[13:19:57.584]         {
[13:19:57.584]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.584]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.584]             }
[13:19:57.584]             base::options(...future.oldOptions)
[13:19:57.584]             if (.Platform$OS.type == "windows") {
[13:19:57.584]                 old_names <- names(...future.oldEnvVars)
[13:19:57.584]                 envs <- base::Sys.getenv()
[13:19:57.584]                 names <- names(envs)
[13:19:57.584]                 common <- intersect(names, old_names)
[13:19:57.584]                 added <- setdiff(names, old_names)
[13:19:57.584]                 removed <- setdiff(old_names, names)
[13:19:57.584]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.584]                   envs[common]]
[13:19:57.584]                 NAMES <- toupper(changed)
[13:19:57.584]                 args <- list()
[13:19:57.584]                 for (kk in seq_along(NAMES)) {
[13:19:57.584]                   name <- changed[[kk]]
[13:19:57.584]                   NAME <- NAMES[[kk]]
[13:19:57.584]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.584]                     next
[13:19:57.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.584]                 }
[13:19:57.584]                 NAMES <- toupper(added)
[13:19:57.584]                 for (kk in seq_along(NAMES)) {
[13:19:57.584]                   name <- added[[kk]]
[13:19:57.584]                   NAME <- NAMES[[kk]]
[13:19:57.584]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.584]                     next
[13:19:57.584]                   args[[name]] <- ""
[13:19:57.584]                 }
[13:19:57.584]                 NAMES <- toupper(removed)
[13:19:57.584]                 for (kk in seq_along(NAMES)) {
[13:19:57.584]                   name <- removed[[kk]]
[13:19:57.584]                   NAME <- NAMES[[kk]]
[13:19:57.584]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.584]                     next
[13:19:57.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.584]                 }
[13:19:57.584]                 if (length(args) > 0) 
[13:19:57.584]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.584]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.584]             }
[13:19:57.584]             else {
[13:19:57.584]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.584]             }
[13:19:57.584]             {
[13:19:57.584]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.584]                   0L) {
[13:19:57.584]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.584]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.584]                   base::options(opts)
[13:19:57.584]                 }
[13:19:57.584]                 {
[13:19:57.584]                   {
[13:19:57.584]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.584]                     NULL
[13:19:57.584]                   }
[13:19:57.584]                   options(future.plan = NULL)
[13:19:57.584]                   if (is.na(NA_character_)) 
[13:19:57.584]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.584]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.584]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.584]                     envir = parent.frame()) 
[13:19:57.584]                   {
[13:19:57.584]                     default_workers <- missing(workers)
[13:19:57.584]                     if (is.function(workers)) 
[13:19:57.584]                       workers <- workers()
[13:19:57.584]                     workers <- structure(as.integer(workers), 
[13:19:57.584]                       class = class(workers))
[13:19:57.584]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.584]                       1L)
[13:19:57.584]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.584]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.584]                       if (default_workers) 
[13:19:57.584]                         supportsMulticore(warn = TRUE)
[13:19:57.584]                       return(sequential(..., envir = envir))
[13:19:57.584]                     }
[13:19:57.584]                     oopts <- options(mc.cores = workers)
[13:19:57.584]                     on.exit(options(oopts))
[13:19:57.584]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.584]                       envir = envir)
[13:19:57.584]                     if (!future$lazy) 
[13:19:57.584]                       future <- run(future)
[13:19:57.584]                     invisible(future)
[13:19:57.584]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.584]                 }
[13:19:57.584]             }
[13:19:57.584]         }
[13:19:57.584]     })
[13:19:57.584]     if (TRUE) {
[13:19:57.584]         base::sink(type = "output", split = FALSE)
[13:19:57.584]         if (TRUE) {
[13:19:57.584]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.584]         }
[13:19:57.584]         else {
[13:19:57.584]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.584]         }
[13:19:57.584]         base::close(...future.stdout)
[13:19:57.584]         ...future.stdout <- NULL
[13:19:57.584]     }
[13:19:57.584]     ...future.result$conditions <- ...future.conditions
[13:19:57.584]     ...future.result$finished <- base::Sys.time()
[13:19:57.584]     ...future.result
[13:19:57.584] }
[13:19:57.588] assign_globals() ...
[13:19:57.588] List of 5
[13:19:57.588]  $ future.call.arguments    : list()
[13:19:57.588]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.588]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:57.588]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:57.588]  $ ...future.elements_ii    :List of 1
[13:19:57.588]   ..$ : num [1:4] 2 4 6 8
[13:19:57.588]  $ ...future.seeds_ii       : NULL
[13:19:57.588]  $ ...future.globals.maxSize: num Inf
[13:19:57.588]  - attr(*, "resolved")= logi FALSE
[13:19:57.588]  - attr(*, "total_size")= num NA
[13:19:57.588]  - attr(*, "where")=List of 5
[13:19:57.588]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.588]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.588]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.588]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.588]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.588]  - attr(*, "already-done")= logi TRUE
[13:19:57.599] - copied ‘future.call.arguments’ to environment
[13:19:57.599] - copied ‘...future.FUN’ to environment
[13:19:57.600] - copied ‘...future.elements_ii’ to environment
[13:19:57.600] - copied ‘...future.seeds_ii’ to environment
[13:19:57.600] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.600] assign_globals() ... done
[13:19:57.601] requestCore(): workers = 2
[13:19:57.603] MulticoreFuture started
[13:19:57.604] - Launch lazy future ... done
[13:19:57.604] run() for ‘MulticoreFuture’ ... done
[13:19:57.604] Created future:
[13:19:57.604] plan(): Setting new future strategy stack:
[13:19:57.605] List of future strategies:
[13:19:57.605] 1. sequential:
[13:19:57.605]    - args: function (..., envir = parent.frame())
[13:19:57.605]    - tweaked: FALSE
[13:19:57.605]    - call: NULL
[13:19:57.606] plan(): nbrOfWorkers() = 1
[13:19:57.608] plan(): Setting new future strategy stack:
[13:19:57.608] List of future strategies:
[13:19:57.608] 1. multicore:
[13:19:57.608]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.608]    - tweaked: FALSE
[13:19:57.608]    - call: plan(strategy)
[13:19:57.614] plan(): nbrOfWorkers() = 2
[13:19:57.605] MulticoreFuture:
[13:19:57.605] Label: ‘future_apply-2’
[13:19:57.605] Expression:
[13:19:57.605] {
[13:19:57.605]     do.call(function(...) {
[13:19:57.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.605]             on.exit(options(oopts), add = TRUE)
[13:19:57.605]         }
[13:19:57.605]         {
[13:19:57.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.605]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.605]             })
[13:19:57.605]         }
[13:19:57.605]     }, args = future.call.arguments)
[13:19:57.605] }
[13:19:57.605] Lazy evaluation: FALSE
[13:19:57.605] Asynchronous evaluation: TRUE
[13:19:57.605] Local evaluation: TRUE
[13:19:57.605] Environment: R_GlobalEnv
[13:19:57.605] Capture standard output: TRUE
[13:19:57.605] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.605] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.605] Packages: <none>
[13:19:57.605] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.605] Resolved: TRUE
[13:19:57.605] Value: <not collected>
[13:19:57.605] Conditions captured: <none>
[13:19:57.605] Early signaling: FALSE
[13:19:57.605] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.605] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.615] Chunk #2 of 2 ... DONE
[13:19:57.616] Launching 2 futures (chunks) ... DONE
[13:19:57.616] Resolving 2 futures (chunks) ...
[13:19:57.616] resolve() on list ...
[13:19:57.616]  recursive: 0
[13:19:57.617]  length: 2
[13:19:57.617] 
[13:19:57.617] Future #1
[13:19:57.617] result() for MulticoreFuture ...
[13:19:57.618] result() for MulticoreFuture ...
[13:19:57.619] result() for MulticoreFuture ... done
[13:19:57.619] result() for MulticoreFuture ... done
[13:19:57.619] result() for MulticoreFuture ...
[13:19:57.619] result() for MulticoreFuture ... done
[13:19:57.619] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:57.619] - nx: 2
[13:19:57.620] - relay: TRUE
[13:19:57.620] - stdout: TRUE
[13:19:57.620] - signal: TRUE
[13:19:57.620] - resignal: FALSE
[13:19:57.620] - force: TRUE
[13:19:57.620] - relayed: [n=2] FALSE, FALSE
[13:19:57.621] - queued futures: [n=2] FALSE, FALSE
[13:19:57.621]  - until=1
[13:19:57.621]  - relaying element #1
[13:19:57.621] result() for MulticoreFuture ...
[13:19:57.621] result() for MulticoreFuture ... done
[13:19:57.621] result() for MulticoreFuture ...
[13:19:57.622] result() for MulticoreFuture ... done
[13:19:57.622] result() for MulticoreFuture ...
[13:19:57.622] result() for MulticoreFuture ... done
[13:19:57.622] result() for MulticoreFuture ...
[13:19:57.622] result() for MulticoreFuture ... done
[13:19:57.622] - relayed: [n=2] TRUE, FALSE
[13:19:57.623] - queued futures: [n=2] TRUE, FALSE
[13:19:57.623] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:57.623]  length: 1 (resolved future 1)
[13:19:57.623] Future #2
[13:19:57.623] result() for MulticoreFuture ...
[13:19:57.624] result() for MulticoreFuture ...
[13:19:57.624] result() for MulticoreFuture ... done
[13:19:57.624] result() for MulticoreFuture ... done
[13:19:57.625] result() for MulticoreFuture ...
[13:19:57.625] result() for MulticoreFuture ... done
[13:19:57.625] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:57.625] - nx: 2
[13:19:57.625] - relay: TRUE
[13:19:57.625] - stdout: TRUE
[13:19:57.625] - signal: TRUE
[13:19:57.626] - resignal: FALSE
[13:19:57.626] - force: TRUE
[13:19:57.626] - relayed: [n=2] TRUE, FALSE
[13:19:57.626] - queued futures: [n=2] TRUE, FALSE
[13:19:57.626]  - until=2
[13:19:57.626]  - relaying element #2
[13:19:57.626] result() for MulticoreFuture ...
[13:19:57.626] result() for MulticoreFuture ... done
[13:19:57.627] result() for MulticoreFuture ...
[13:19:57.627] result() for MulticoreFuture ... done
[13:19:57.627] result() for MulticoreFuture ...
[13:19:57.627] result() for MulticoreFuture ... done
[13:19:57.627] result() for MulticoreFuture ...
[13:19:57.627] result() for MulticoreFuture ... done
[13:19:57.627] - relayed: [n=2] TRUE, TRUE
[13:19:57.627] - queued futures: [n=2] TRUE, TRUE
[13:19:57.628] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:57.628]  length: 0 (resolved future 2)
[13:19:57.628] Relaying remaining futures
[13:19:57.628] signalConditionsASAP(NULL, pos=0) ...
[13:19:57.628] - nx: 2
[13:19:57.628] - relay: TRUE
[13:19:57.628] - stdout: TRUE
[13:19:57.628] - signal: TRUE
[13:19:57.628] - resignal: FALSE
[13:19:57.629] - force: TRUE
[13:19:57.629] - relayed: [n=2] TRUE, TRUE
[13:19:57.629] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:57.629] - relayed: [n=2] TRUE, TRUE
[13:19:57.629] - queued futures: [n=2] TRUE, TRUE
[13:19:57.629] signalConditionsASAP(NULL, pos=0) ... done
[13:19:57.629] resolve() on list ... DONE
[13:19:57.629] result() for MulticoreFuture ...
[13:19:57.630] result() for MulticoreFuture ... done
[13:19:57.630] result() for MulticoreFuture ...
[13:19:57.630] result() for MulticoreFuture ... done
[13:19:57.630] result() for MulticoreFuture ...
[13:19:57.630] result() for MulticoreFuture ... done
[13:19:57.630] result() for MulticoreFuture ...
[13:19:57.630] result() for MulticoreFuture ... done
[13:19:57.630]  - Number of value chunks collected: 2
[13:19:57.631] Resolving 2 futures (chunks) ... DONE
[13:19:57.631] Reducing values from 2 chunks ...
[13:19:57.631]  - Number of values collected after concatenation: 2
[13:19:57.631]  - Number of values expected: 2
[13:19:57.631] Reducing values from 2 chunks ... DONE
[13:19:57.631] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:19:57.632] getGlobalsAndPackagesXApply() ...
[13:19:57.632]  - future.globals: TRUE
[13:19:57.633] getGlobalsAndPackages() ...
[13:19:57.633] Searching for globals...
[13:19:57.634] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:19:57.634] Searching for globals ... DONE
[13:19:57.634] Resolving globals: FALSE
[13:19:57.635] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:19:57.635] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:19:57.636] - globals: [1] ‘FUN’
[13:19:57.636] - packages: [1] ‘stats’
[13:19:57.636] getGlobalsAndPackages() ... DONE
[13:19:57.636]  - globals found/used: [n=1] ‘FUN’
[13:19:57.636]  - needed namespaces: [n=1] ‘stats’
[13:19:57.636] Finding globals ... DONE
[13:19:57.636]  - use_args: TRUE
[13:19:57.636]  - Getting '...' globals ...
[13:19:57.637] resolve() on list ...
[13:19:57.637]  recursive: 0
[13:19:57.637]  length: 1
[13:19:57.637]  elements: ‘...’
[13:19:57.637]  length: 0 (resolved future 1)
[13:19:57.637] resolve() on list ... DONE
[13:19:57.637]    - '...' content: [n=0] 
[13:19:57.638] List of 1
[13:19:57.638]  $ ...: list()
[13:19:57.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.638]  - attr(*, "where")=List of 1
[13:19:57.638]   ..$ ...:<environment: 0x5559229a5080> 
[13:19:57.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.638]  - attr(*, "resolved")= logi TRUE
[13:19:57.638]  - attr(*, "total_size")= num NA
[13:19:57.646]  - Getting '...' globals ... DONE
[13:19:57.646] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:57.646] List of 2
[13:19:57.646]  $ ...future.FUN:function (x, ...)  
[13:19:57.646]  $ ...          : list()
[13:19:57.646]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.646]  - attr(*, "where")=List of 2
[13:19:57.646]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:57.646]   ..$ ...          :<environment: 0x5559229a5080> 
[13:19:57.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.646]  - attr(*, "resolved")= logi FALSE
[13:19:57.646]  - attr(*, "total_size")= num 1248
[13:19:57.650] Packages to be attached in all futures: [n=1] ‘stats’
[13:19:57.650] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.654] future_lapply() ...
[13:19:57.658] Number of chunks: 2
[13:19:57.658] getGlobalsAndPackagesXApply() ...
[13:19:57.658]  - future.globals: <name-value list> with names ‘list()’
[13:19:57.658]  - use_args: TRUE
[13:19:57.659] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:57.659] List of 2
[13:19:57.659]  $ ...          : list()
[13:19:57.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.659]  $ ...future.FUN:function (x, ...)  
[13:19:57.659]  - attr(*, "where")=List of 2
[13:19:57.659]   ..$ ...          :<environment: 0x5559229a5080> 
[13:19:57.659]   ..$ ...future.FUN:<environment: namespace:stats> 
[13:19:57.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.659]  - attr(*, "resolved")= logi FALSE
[13:19:57.659]  - attr(*, "total_size")= num NA
[13:19:57.662] Packages to be attached in all futures: [n=1] ‘stats’
[13:19:57.662] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.662] Number of futures (= number of chunks): 2
[13:19:57.662] Launching 2 futures (chunks) ...
[13:19:57.662] Chunk #1 of 2 ...
[13:19:57.662]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:57.662]  - seeds: <none>
[13:19:57.663]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.663] getGlobalsAndPackages() ...
[13:19:57.663] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.663] Resolving globals: FALSE
[13:19:57.663] Tweak future expression to call with '...' arguments ...
[13:19:57.663] {
[13:19:57.663]     do.call(function(...) {
[13:19:57.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.663]             on.exit(options(oopts), add = TRUE)
[13:19:57.663]         }
[13:19:57.663]         {
[13:19:57.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.663]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.663]             })
[13:19:57.663]         }
[13:19:57.663]     }, args = future.call.arguments)
[13:19:57.663] }
[13:19:57.663] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.664] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.664] - packages: [1] ‘stats’
[13:19:57.664] getGlobalsAndPackages() ... DONE
[13:19:57.664] run() for ‘Future’ ...
[13:19:57.665] - state: ‘created’
[13:19:57.665] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.668] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.669]   - Field: ‘label’
[13:19:57.669]   - Field: ‘local’
[13:19:57.669]   - Field: ‘owner’
[13:19:57.669]   - Field: ‘envir’
[13:19:57.669]   - Field: ‘workers’
[13:19:57.669]   - Field: ‘packages’
[13:19:57.669]   - Field: ‘gc’
[13:19:57.669]   - Field: ‘job’
[13:19:57.669]   - Field: ‘conditions’
[13:19:57.669]   - Field: ‘expr’
[13:19:57.670]   - Field: ‘uuid’
[13:19:57.670]   - Field: ‘seed’
[13:19:57.670]   - Field: ‘version’
[13:19:57.670]   - Field: ‘result’
[13:19:57.670]   - Field: ‘asynchronous’
[13:19:57.670]   - Field: ‘calls’
[13:19:57.670]   - Field: ‘globals’
[13:19:57.670]   - Field: ‘stdout’
[13:19:57.670]   - Field: ‘earlySignal’
[13:19:57.670]   - Field: ‘lazy’
[13:19:57.670]   - Field: ‘state’
[13:19:57.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.671] - Launch lazy future ...
[13:19:57.671] Packages needed by the future expression (n = 1): ‘stats’
[13:19:57.671] Packages needed by future strategies (n = 0): <none>
[13:19:57.672] {
[13:19:57.672]     {
[13:19:57.672]         {
[13:19:57.672]             ...future.startTime <- base::Sys.time()
[13:19:57.672]             {
[13:19:57.672]                 {
[13:19:57.672]                   {
[13:19:57.672]                     {
[13:19:57.672]                       {
[13:19:57.672]                         base::local({
[13:19:57.672]                           has_future <- base::requireNamespace("future", 
[13:19:57.672]                             quietly = TRUE)
[13:19:57.672]                           if (has_future) {
[13:19:57.672]                             ns <- base::getNamespace("future")
[13:19:57.672]                             version <- ns[[".package"]][["version"]]
[13:19:57.672]                             if (is.null(version)) 
[13:19:57.672]                               version <- utils::packageVersion("future")
[13:19:57.672]                           }
[13:19:57.672]                           else {
[13:19:57.672]                             version <- NULL
[13:19:57.672]                           }
[13:19:57.672]                           if (!has_future || version < "1.8.0") {
[13:19:57.672]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.672]                               "", base::R.version$version.string), 
[13:19:57.672]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:57.672]                                 base::R.version$platform, 8 * 
[13:19:57.672]                                   base::.Machine$sizeof.pointer), 
[13:19:57.672]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.672]                                 "release", "version")], collapse = " "), 
[13:19:57.672]                               hostname = base::Sys.info()[["nodename"]])
[13:19:57.672]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.672]                               info)
[13:19:57.672]                             info <- base::paste(info, collapse = "; ")
[13:19:57.672]                             if (!has_future) {
[13:19:57.672]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.672]                                 info)
[13:19:57.672]                             }
[13:19:57.672]                             else {
[13:19:57.672]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.672]                                 info, version)
[13:19:57.672]                             }
[13:19:57.672]                             base::stop(msg)
[13:19:57.672]                           }
[13:19:57.672]                         })
[13:19:57.672]                       }
[13:19:57.672]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.672]                       base::options(mc.cores = 1L)
[13:19:57.672]                     }
[13:19:57.672]                     base::local({
[13:19:57.672]                       for (pkg in "stats") {
[13:19:57.672]                         base::loadNamespace(pkg)
[13:19:57.672]                         base::library(pkg, character.only = TRUE)
[13:19:57.672]                       }
[13:19:57.672]                     })
[13:19:57.672]                   }
[13:19:57.672]                   options(future.plan = NULL)
[13:19:57.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.672]                 }
[13:19:57.672]                 ...future.workdir <- getwd()
[13:19:57.672]             }
[13:19:57.672]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.672]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.672]         }
[13:19:57.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.672]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.672]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.672]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.672]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.672]             base::names(...future.oldOptions))
[13:19:57.672]     }
[13:19:57.672]     if (FALSE) {
[13:19:57.672]     }
[13:19:57.672]     else {
[13:19:57.672]         if (TRUE) {
[13:19:57.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.672]                 open = "w")
[13:19:57.672]         }
[13:19:57.672]         else {
[13:19:57.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.672]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.672]         }
[13:19:57.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.672]             base::sink(type = "output", split = FALSE)
[13:19:57.672]             base::close(...future.stdout)
[13:19:57.672]         }, add = TRUE)
[13:19:57.672]     }
[13:19:57.672]     ...future.frame <- base::sys.nframe()
[13:19:57.672]     ...future.conditions <- base::list()
[13:19:57.672]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.672]     if (FALSE) {
[13:19:57.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.672]     }
[13:19:57.672]     ...future.result <- base::tryCatch({
[13:19:57.672]         base::withCallingHandlers({
[13:19:57.672]             ...future.value <- base::withVisible(base::local({
[13:19:57.672]                 withCallingHandlers({
[13:19:57.672]                   {
[13:19:57.672]                     do.call(function(...) {
[13:19:57.672]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.672]                       if (!identical(...future.globals.maxSize.org, 
[13:19:57.672]                         ...future.globals.maxSize)) {
[13:19:57.672]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.672]                         on.exit(options(oopts), add = TRUE)
[13:19:57.672]                       }
[13:19:57.672]                       {
[13:19:57.672]                         lapply(seq_along(...future.elements_ii), 
[13:19:57.672]                           FUN = function(jj) {
[13:19:57.672]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.672]                             ...future.FUN(...future.X_jj, ...)
[13:19:57.672]                           })
[13:19:57.672]                       }
[13:19:57.672]                     }, args = future.call.arguments)
[13:19:57.672]                   }
[13:19:57.672]                 }, immediateCondition = function(cond) {
[13:19:57.672]                   save_rds <- function (object, pathname, ...) 
[13:19:57.672]                   {
[13:19:57.672]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.672]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.672]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.672]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.672]                         fi_tmp[["mtime"]])
[13:19:57.672]                     }
[13:19:57.672]                     tryCatch({
[13:19:57.672]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.672]                     }, error = function(ex) {
[13:19:57.672]                       msg <- conditionMessage(ex)
[13:19:57.672]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.672]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.672]                         fi_tmp[["mtime"]], msg)
[13:19:57.672]                       ex$message <- msg
[13:19:57.672]                       stop(ex)
[13:19:57.672]                     })
[13:19:57.672]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.672]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.672]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.672]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.672]                       fi <- file.info(pathname)
[13:19:57.672]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.672]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.672]                         fi[["size"]], fi[["mtime"]])
[13:19:57.672]                       stop(msg)
[13:19:57.672]                     }
[13:19:57.672]                     invisible(pathname)
[13:19:57.672]                   }
[13:19:57.672]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.672]                     rootPath = tempdir()) 
[13:19:57.672]                   {
[13:19:57.672]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.672]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.672]                       tmpdir = path, fileext = ".rds")
[13:19:57.672]                     save_rds(obj, file)
[13:19:57.672]                   }
[13:19:57.672]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:57.672]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.672]                   {
[13:19:57.672]                     inherits <- base::inherits
[13:19:57.672]                     invokeRestart <- base::invokeRestart
[13:19:57.672]                     is.null <- base::is.null
[13:19:57.672]                     muffled <- FALSE
[13:19:57.672]                     if (inherits(cond, "message")) {
[13:19:57.672]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.672]                       if (muffled) 
[13:19:57.672]                         invokeRestart("muffleMessage")
[13:19:57.672]                     }
[13:19:57.672]                     else if (inherits(cond, "warning")) {
[13:19:57.672]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.672]                       if (muffled) 
[13:19:57.672]                         invokeRestart("muffleWarning")
[13:19:57.672]                     }
[13:19:57.672]                     else if (inherits(cond, "condition")) {
[13:19:57.672]                       if (!is.null(pattern)) {
[13:19:57.672]                         computeRestarts <- base::computeRestarts
[13:19:57.672]                         grepl <- base::grepl
[13:19:57.672]                         restarts <- computeRestarts(cond)
[13:19:57.672]                         for (restart in restarts) {
[13:19:57.672]                           name <- restart$name
[13:19:57.672]                           if (is.null(name)) 
[13:19:57.672]                             next
[13:19:57.672]                           if (!grepl(pattern, name)) 
[13:19:57.672]                             next
[13:19:57.672]                           invokeRestart(restart)
[13:19:57.672]                           muffled <- TRUE
[13:19:57.672]                           break
[13:19:57.672]                         }
[13:19:57.672]                       }
[13:19:57.672]                     }
[13:19:57.672]                     invisible(muffled)
[13:19:57.672]                   }
[13:19:57.672]                   muffleCondition(cond)
[13:19:57.672]                 })
[13:19:57.672]             }))
[13:19:57.672]             future::FutureResult(value = ...future.value$value, 
[13:19:57.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.672]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.672]                     ...future.globalenv.names))
[13:19:57.672]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.672]         }, condition = base::local({
[13:19:57.672]             c <- base::c
[13:19:57.672]             inherits <- base::inherits
[13:19:57.672]             invokeRestart <- base::invokeRestart
[13:19:57.672]             length <- base::length
[13:19:57.672]             list <- base::list
[13:19:57.672]             seq.int <- base::seq.int
[13:19:57.672]             signalCondition <- base::signalCondition
[13:19:57.672]             sys.calls <- base::sys.calls
[13:19:57.672]             `[[` <- base::`[[`
[13:19:57.672]             `+` <- base::`+`
[13:19:57.672]             `<<-` <- base::`<<-`
[13:19:57.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.672]                   3L)]
[13:19:57.672]             }
[13:19:57.672]             function(cond) {
[13:19:57.672]                 is_error <- inherits(cond, "error")
[13:19:57.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.672]                   NULL)
[13:19:57.672]                 if (is_error) {
[13:19:57.672]                   sessionInformation <- function() {
[13:19:57.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.672]                       search = base::search(), system = base::Sys.info())
[13:19:57.672]                   }
[13:19:57.672]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.672]                     cond$call), session = sessionInformation(), 
[13:19:57.672]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.672]                   signalCondition(cond)
[13:19:57.672]                 }
[13:19:57.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.672]                 "immediateCondition"))) {
[13:19:57.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.672]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.672]                   if (TRUE && !signal) {
[13:19:57.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.672]                     {
[13:19:57.672]                       inherits <- base::inherits
[13:19:57.672]                       invokeRestart <- base::invokeRestart
[13:19:57.672]                       is.null <- base::is.null
[13:19:57.672]                       muffled <- FALSE
[13:19:57.672]                       if (inherits(cond, "message")) {
[13:19:57.672]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.672]                         if (muffled) 
[13:19:57.672]                           invokeRestart("muffleMessage")
[13:19:57.672]                       }
[13:19:57.672]                       else if (inherits(cond, "warning")) {
[13:19:57.672]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.672]                         if (muffled) 
[13:19:57.672]                           invokeRestart("muffleWarning")
[13:19:57.672]                       }
[13:19:57.672]                       else if (inherits(cond, "condition")) {
[13:19:57.672]                         if (!is.null(pattern)) {
[13:19:57.672]                           computeRestarts <- base::computeRestarts
[13:19:57.672]                           grepl <- base::grepl
[13:19:57.672]                           restarts <- computeRestarts(cond)
[13:19:57.672]                           for (restart in restarts) {
[13:19:57.672]                             name <- restart$name
[13:19:57.672]                             if (is.null(name)) 
[13:19:57.672]                               next
[13:19:57.672]                             if (!grepl(pattern, name)) 
[13:19:57.672]                               next
[13:19:57.672]                             invokeRestart(restart)
[13:19:57.672]                             muffled <- TRUE
[13:19:57.672]                             break
[13:19:57.672]                           }
[13:19:57.672]                         }
[13:19:57.672]                       }
[13:19:57.672]                       invisible(muffled)
[13:19:57.672]                     }
[13:19:57.672]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.672]                   }
[13:19:57.672]                 }
[13:19:57.672]                 else {
[13:19:57.672]                   if (TRUE) {
[13:19:57.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.672]                     {
[13:19:57.672]                       inherits <- base::inherits
[13:19:57.672]                       invokeRestart <- base::invokeRestart
[13:19:57.672]                       is.null <- base::is.null
[13:19:57.672]                       muffled <- FALSE
[13:19:57.672]                       if (inherits(cond, "message")) {
[13:19:57.672]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.672]                         if (muffled) 
[13:19:57.672]                           invokeRestart("muffleMessage")
[13:19:57.672]                       }
[13:19:57.672]                       else if (inherits(cond, "warning")) {
[13:19:57.672]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.672]                         if (muffled) 
[13:19:57.672]                           invokeRestart("muffleWarning")
[13:19:57.672]                       }
[13:19:57.672]                       else if (inherits(cond, "condition")) {
[13:19:57.672]                         if (!is.null(pattern)) {
[13:19:57.672]                           computeRestarts <- base::computeRestarts
[13:19:57.672]                           grepl <- base::grepl
[13:19:57.672]                           restarts <- computeRestarts(cond)
[13:19:57.672]                           for (restart in restarts) {
[13:19:57.672]                             name <- restart$name
[13:19:57.672]                             if (is.null(name)) 
[13:19:57.672]                               next
[13:19:57.672]                             if (!grepl(pattern, name)) 
[13:19:57.672]                               next
[13:19:57.672]                             invokeRestart(restart)
[13:19:57.672]                             muffled <- TRUE
[13:19:57.672]                             break
[13:19:57.672]                           }
[13:19:57.672]                         }
[13:19:57.672]                       }
[13:19:57.672]                       invisible(muffled)
[13:19:57.672]                     }
[13:19:57.672]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.672]                   }
[13:19:57.672]                 }
[13:19:57.672]             }
[13:19:57.672]         }))
[13:19:57.672]     }, error = function(ex) {
[13:19:57.672]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.672]                 ...future.rng), started = ...future.startTime, 
[13:19:57.672]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.672]             version = "1.8"), class = "FutureResult")
[13:19:57.672]     }, finally = {
[13:19:57.672]         if (!identical(...future.workdir, getwd())) 
[13:19:57.672]             setwd(...future.workdir)
[13:19:57.672]         {
[13:19:57.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.672]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.672]             }
[13:19:57.672]             base::options(...future.oldOptions)
[13:19:57.672]             if (.Platform$OS.type == "windows") {
[13:19:57.672]                 old_names <- names(...future.oldEnvVars)
[13:19:57.672]                 envs <- base::Sys.getenv()
[13:19:57.672]                 names <- names(envs)
[13:19:57.672]                 common <- intersect(names, old_names)
[13:19:57.672]                 added <- setdiff(names, old_names)
[13:19:57.672]                 removed <- setdiff(old_names, names)
[13:19:57.672]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.672]                   envs[common]]
[13:19:57.672]                 NAMES <- toupper(changed)
[13:19:57.672]                 args <- list()
[13:19:57.672]                 for (kk in seq_along(NAMES)) {
[13:19:57.672]                   name <- changed[[kk]]
[13:19:57.672]                   NAME <- NAMES[[kk]]
[13:19:57.672]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.672]                     next
[13:19:57.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.672]                 }
[13:19:57.672]                 NAMES <- toupper(added)
[13:19:57.672]                 for (kk in seq_along(NAMES)) {
[13:19:57.672]                   name <- added[[kk]]
[13:19:57.672]                   NAME <- NAMES[[kk]]
[13:19:57.672]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.672]                     next
[13:19:57.672]                   args[[name]] <- ""
[13:19:57.672]                 }
[13:19:57.672]                 NAMES <- toupper(removed)
[13:19:57.672]                 for (kk in seq_along(NAMES)) {
[13:19:57.672]                   name <- removed[[kk]]
[13:19:57.672]                   NAME <- NAMES[[kk]]
[13:19:57.672]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.672]                     next
[13:19:57.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.672]                 }
[13:19:57.672]                 if (length(args) > 0) 
[13:19:57.672]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.672]             }
[13:19:57.672]             else {
[13:19:57.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.672]             }
[13:19:57.672]             {
[13:19:57.672]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.672]                   0L) {
[13:19:57.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.672]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.672]                   base::options(opts)
[13:19:57.672]                 }
[13:19:57.672]                 {
[13:19:57.672]                   {
[13:19:57.672]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.672]                     NULL
[13:19:57.672]                   }
[13:19:57.672]                   options(future.plan = NULL)
[13:19:57.672]                   if (is.na(NA_character_)) 
[13:19:57.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.672]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.672]                     envir = parent.frame()) 
[13:19:57.672]                   {
[13:19:57.672]                     default_workers <- missing(workers)
[13:19:57.672]                     if (is.function(workers)) 
[13:19:57.672]                       workers <- workers()
[13:19:57.672]                     workers <- structure(as.integer(workers), 
[13:19:57.672]                       class = class(workers))
[13:19:57.672]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.672]                       1L)
[13:19:57.672]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.672]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.672]                       if (default_workers) 
[13:19:57.672]                         supportsMulticore(warn = TRUE)
[13:19:57.672]                       return(sequential(..., envir = envir))
[13:19:57.672]                     }
[13:19:57.672]                     oopts <- options(mc.cores = workers)
[13:19:57.672]                     on.exit(options(oopts))
[13:19:57.672]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.672]                       envir = envir)
[13:19:57.672]                     if (!future$lazy) 
[13:19:57.672]                       future <- run(future)
[13:19:57.672]                     invisible(future)
[13:19:57.672]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.672]                 }
[13:19:57.672]             }
[13:19:57.672]         }
[13:19:57.672]     })
[13:19:57.672]     if (TRUE) {
[13:19:57.672]         base::sink(type = "output", split = FALSE)
[13:19:57.672]         if (TRUE) {
[13:19:57.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.672]         }
[13:19:57.672]         else {
[13:19:57.672]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.672]         }
[13:19:57.672]         base::close(...future.stdout)
[13:19:57.672]         ...future.stdout <- NULL
[13:19:57.672]     }
[13:19:57.672]     ...future.result$conditions <- ...future.conditions
[13:19:57.672]     ...future.result$finished <- base::Sys.time()
[13:19:57.672]     ...future.result
[13:19:57.672] }
[13:19:57.674] assign_globals() ...
[13:19:57.674] List of 5
[13:19:57.674]  $ future.call.arguments    : list()
[13:19:57.674]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.674]  $ ...future.FUN            :function (x, ...)  
[13:19:57.674]  $ ...future.elements_ii    :List of 1
[13:19:57.674]   ..$ : num [1:4] 1 3 1 7
[13:19:57.674]  $ ...future.seeds_ii       : NULL
[13:19:57.674]  $ ...future.globals.maxSize: num Inf
[13:19:57.674]  - attr(*, "resolved")= logi FALSE
[13:19:57.674]  - attr(*, "total_size")= num NA
[13:19:57.674]  - attr(*, "where")=List of 5
[13:19:57.674]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.674]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.674]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.674]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.674]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.674]  - attr(*, "already-done")= logi TRUE
[13:19:57.682] - copied ‘future.call.arguments’ to environment
[13:19:57.682] - copied ‘...future.FUN’ to environment
[13:19:57.682] - copied ‘...future.elements_ii’ to environment
[13:19:57.683] - copied ‘...future.seeds_ii’ to environment
[13:19:57.683] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.683] assign_globals() ... done
[13:19:57.683] requestCore(): workers = 2
[13:19:57.685] MulticoreFuture started
[13:19:57.686] - Launch lazy future ... done
[13:19:57.686] run() for ‘MulticoreFuture’ ... done
[13:19:57.686] Created future:
[13:19:57.687] plan(): Setting new future strategy stack:
[13:19:57.687] List of future strategies:
[13:19:57.687] 1. sequential:
[13:19:57.687]    - args: function (..., envir = parent.frame())
[13:19:57.687]    - tweaked: FALSE
[13:19:57.687]    - call: NULL
[13:19:57.688] plan(): nbrOfWorkers() = 1
[13:19:57.691] plan(): Setting new future strategy stack:
[13:19:57.691] List of future strategies:
[13:19:57.691] 1. multicore:
[13:19:57.691]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.691]    - tweaked: FALSE
[13:19:57.691]    - call: plan(strategy)
[13:19:57.697] plan(): nbrOfWorkers() = 2
[13:19:57.687] MulticoreFuture:
[13:19:57.687] Label: ‘future_apply-1’
[13:19:57.687] Expression:
[13:19:57.687] {
[13:19:57.687]     do.call(function(...) {
[13:19:57.687]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.687]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.687]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.687]             on.exit(options(oopts), add = TRUE)
[13:19:57.687]         }
[13:19:57.687]         {
[13:19:57.687]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.687]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.687]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.687]             })
[13:19:57.687]         }
[13:19:57.687]     }, args = future.call.arguments)
[13:19:57.687] }
[13:19:57.687] Lazy evaluation: FALSE
[13:19:57.687] Asynchronous evaluation: TRUE
[13:19:57.687] Local evaluation: TRUE
[13:19:57.687] Environment: R_GlobalEnv
[13:19:57.687] Capture standard output: TRUE
[13:19:57.687] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.687] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.687] Packages: 1 packages (‘stats’)
[13:19:57.687] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.687] Resolved: TRUE
[13:19:57.687] Value: <not collected>
[13:19:57.687] Conditions captured: <none>
[13:19:57.687] Early signaling: FALSE
[13:19:57.687] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.687] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.698] Chunk #1 of 2 ... DONE
[13:19:57.698] Chunk #2 of 2 ...
[13:19:57.698]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:57.698]  - seeds: <none>
[13:19:57.699]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.699] getGlobalsAndPackages() ...
[13:19:57.699] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.699] Resolving globals: FALSE
[13:19:57.699] Tweak future expression to call with '...' arguments ...
[13:19:57.700] {
[13:19:57.700]     do.call(function(...) {
[13:19:57.700]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.700]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.700]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.700]             on.exit(options(oopts), add = TRUE)
[13:19:57.700]         }
[13:19:57.700]         {
[13:19:57.700]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.700]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.700]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.700]             })
[13:19:57.700]         }
[13:19:57.700]     }, args = future.call.arguments)
[13:19:57.700] }
[13:19:57.700] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.701] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.701] - packages: [1] ‘stats’
[13:19:57.701] getGlobalsAndPackages() ... DONE
[13:19:57.702] run() for ‘Future’ ...
[13:19:57.702] - state: ‘created’
[13:19:57.702] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.707] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.707]   - Field: ‘label’
[13:19:57.708]   - Field: ‘local’
[13:19:57.708]   - Field: ‘owner’
[13:19:57.708]   - Field: ‘envir’
[13:19:57.708]   - Field: ‘workers’
[13:19:57.708]   - Field: ‘packages’
[13:19:57.708]   - Field: ‘gc’
[13:19:57.709]   - Field: ‘job’
[13:19:57.709]   - Field: ‘conditions’
[13:19:57.709]   - Field: ‘expr’
[13:19:57.709]   - Field: ‘uuid’
[13:19:57.709]   - Field: ‘seed’
[13:19:57.709]   - Field: ‘version’
[13:19:57.709]   - Field: ‘result’
[13:19:57.709]   - Field: ‘asynchronous’
[13:19:57.710]   - Field: ‘calls’
[13:19:57.710]   - Field: ‘globals’
[13:19:57.710]   - Field: ‘stdout’
[13:19:57.710]   - Field: ‘earlySignal’
[13:19:57.710]   - Field: ‘lazy’
[13:19:57.710]   - Field: ‘state’
[13:19:57.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.711] - Launch lazy future ...
[13:19:57.711] Packages needed by the future expression (n = 1): ‘stats’
[13:19:57.711] Packages needed by future strategies (n = 0): <none>
[13:19:57.712] {
[13:19:57.712]     {
[13:19:57.712]         {
[13:19:57.712]             ...future.startTime <- base::Sys.time()
[13:19:57.712]             {
[13:19:57.712]                 {
[13:19:57.712]                   {
[13:19:57.712]                     {
[13:19:57.712]                       {
[13:19:57.712]                         base::local({
[13:19:57.712]                           has_future <- base::requireNamespace("future", 
[13:19:57.712]                             quietly = TRUE)
[13:19:57.712]                           if (has_future) {
[13:19:57.712]                             ns <- base::getNamespace("future")
[13:19:57.712]                             version <- ns[[".package"]][["version"]]
[13:19:57.712]                             if (is.null(version)) 
[13:19:57.712]                               version <- utils::packageVersion("future")
[13:19:57.712]                           }
[13:19:57.712]                           else {
[13:19:57.712]                             version <- NULL
[13:19:57.712]                           }
[13:19:57.712]                           if (!has_future || version < "1.8.0") {
[13:19:57.712]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.712]                               "", base::R.version$version.string), 
[13:19:57.712]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:57.712]                                 base::R.version$platform, 8 * 
[13:19:57.712]                                   base::.Machine$sizeof.pointer), 
[13:19:57.712]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.712]                                 "release", "version")], collapse = " "), 
[13:19:57.712]                               hostname = base::Sys.info()[["nodename"]])
[13:19:57.712]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.712]                               info)
[13:19:57.712]                             info <- base::paste(info, collapse = "; ")
[13:19:57.712]                             if (!has_future) {
[13:19:57.712]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.712]                                 info)
[13:19:57.712]                             }
[13:19:57.712]                             else {
[13:19:57.712]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.712]                                 info, version)
[13:19:57.712]                             }
[13:19:57.712]                             base::stop(msg)
[13:19:57.712]                           }
[13:19:57.712]                         })
[13:19:57.712]                       }
[13:19:57.712]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.712]                       base::options(mc.cores = 1L)
[13:19:57.712]                     }
[13:19:57.712]                     base::local({
[13:19:57.712]                       for (pkg in "stats") {
[13:19:57.712]                         base::loadNamespace(pkg)
[13:19:57.712]                         base::library(pkg, character.only = TRUE)
[13:19:57.712]                       }
[13:19:57.712]                     })
[13:19:57.712]                   }
[13:19:57.712]                   options(future.plan = NULL)
[13:19:57.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.712]                 }
[13:19:57.712]                 ...future.workdir <- getwd()
[13:19:57.712]             }
[13:19:57.712]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.712]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.712]         }
[13:19:57.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.712]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.712]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.712]             base::names(...future.oldOptions))
[13:19:57.712]     }
[13:19:57.712]     if (FALSE) {
[13:19:57.712]     }
[13:19:57.712]     else {
[13:19:57.712]         if (TRUE) {
[13:19:57.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.712]                 open = "w")
[13:19:57.712]         }
[13:19:57.712]         else {
[13:19:57.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.712]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.712]         }
[13:19:57.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.712]             base::sink(type = "output", split = FALSE)
[13:19:57.712]             base::close(...future.stdout)
[13:19:57.712]         }, add = TRUE)
[13:19:57.712]     }
[13:19:57.712]     ...future.frame <- base::sys.nframe()
[13:19:57.712]     ...future.conditions <- base::list()
[13:19:57.712]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.712]     if (FALSE) {
[13:19:57.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.712]     }
[13:19:57.712]     ...future.result <- base::tryCatch({
[13:19:57.712]         base::withCallingHandlers({
[13:19:57.712]             ...future.value <- base::withVisible(base::local({
[13:19:57.712]                 withCallingHandlers({
[13:19:57.712]                   {
[13:19:57.712]                     do.call(function(...) {
[13:19:57.712]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.712]                       if (!identical(...future.globals.maxSize.org, 
[13:19:57.712]                         ...future.globals.maxSize)) {
[13:19:57.712]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.712]                         on.exit(options(oopts), add = TRUE)
[13:19:57.712]                       }
[13:19:57.712]                       {
[13:19:57.712]                         lapply(seq_along(...future.elements_ii), 
[13:19:57.712]                           FUN = function(jj) {
[13:19:57.712]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.712]                             ...future.FUN(...future.X_jj, ...)
[13:19:57.712]                           })
[13:19:57.712]                       }
[13:19:57.712]                     }, args = future.call.arguments)
[13:19:57.712]                   }
[13:19:57.712]                 }, immediateCondition = function(cond) {
[13:19:57.712]                   save_rds <- function (object, pathname, ...) 
[13:19:57.712]                   {
[13:19:57.712]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.712]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.712]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.712]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.712]                         fi_tmp[["mtime"]])
[13:19:57.712]                     }
[13:19:57.712]                     tryCatch({
[13:19:57.712]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.712]                     }, error = function(ex) {
[13:19:57.712]                       msg <- conditionMessage(ex)
[13:19:57.712]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.712]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.712]                         fi_tmp[["mtime"]], msg)
[13:19:57.712]                       ex$message <- msg
[13:19:57.712]                       stop(ex)
[13:19:57.712]                     })
[13:19:57.712]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.712]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.712]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.712]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.712]                       fi <- file.info(pathname)
[13:19:57.712]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.712]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.712]                         fi[["size"]], fi[["mtime"]])
[13:19:57.712]                       stop(msg)
[13:19:57.712]                     }
[13:19:57.712]                     invisible(pathname)
[13:19:57.712]                   }
[13:19:57.712]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.712]                     rootPath = tempdir()) 
[13:19:57.712]                   {
[13:19:57.712]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.712]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.712]                       tmpdir = path, fileext = ".rds")
[13:19:57.712]                     save_rds(obj, file)
[13:19:57.712]                   }
[13:19:57.712]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:57.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.712]                   {
[13:19:57.712]                     inherits <- base::inherits
[13:19:57.712]                     invokeRestart <- base::invokeRestart
[13:19:57.712]                     is.null <- base::is.null
[13:19:57.712]                     muffled <- FALSE
[13:19:57.712]                     if (inherits(cond, "message")) {
[13:19:57.712]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.712]                       if (muffled) 
[13:19:57.712]                         invokeRestart("muffleMessage")
[13:19:57.712]                     }
[13:19:57.712]                     else if (inherits(cond, "warning")) {
[13:19:57.712]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.712]                       if (muffled) 
[13:19:57.712]                         invokeRestart("muffleWarning")
[13:19:57.712]                     }
[13:19:57.712]                     else if (inherits(cond, "condition")) {
[13:19:57.712]                       if (!is.null(pattern)) {
[13:19:57.712]                         computeRestarts <- base::computeRestarts
[13:19:57.712]                         grepl <- base::grepl
[13:19:57.712]                         restarts <- computeRestarts(cond)
[13:19:57.712]                         for (restart in restarts) {
[13:19:57.712]                           name <- restart$name
[13:19:57.712]                           if (is.null(name)) 
[13:19:57.712]                             next
[13:19:57.712]                           if (!grepl(pattern, name)) 
[13:19:57.712]                             next
[13:19:57.712]                           invokeRestart(restart)
[13:19:57.712]                           muffled <- TRUE
[13:19:57.712]                           break
[13:19:57.712]                         }
[13:19:57.712]                       }
[13:19:57.712]                     }
[13:19:57.712]                     invisible(muffled)
[13:19:57.712]                   }
[13:19:57.712]                   muffleCondition(cond)
[13:19:57.712]                 })
[13:19:57.712]             }))
[13:19:57.712]             future::FutureResult(value = ...future.value$value, 
[13:19:57.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.712]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.712]                     ...future.globalenv.names))
[13:19:57.712]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.712]         }, condition = base::local({
[13:19:57.712]             c <- base::c
[13:19:57.712]             inherits <- base::inherits
[13:19:57.712]             invokeRestart <- base::invokeRestart
[13:19:57.712]             length <- base::length
[13:19:57.712]             list <- base::list
[13:19:57.712]             seq.int <- base::seq.int
[13:19:57.712]             signalCondition <- base::signalCondition
[13:19:57.712]             sys.calls <- base::sys.calls
[13:19:57.712]             `[[` <- base::`[[`
[13:19:57.712]             `+` <- base::`+`
[13:19:57.712]             `<<-` <- base::`<<-`
[13:19:57.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.712]                   3L)]
[13:19:57.712]             }
[13:19:57.712]             function(cond) {
[13:19:57.712]                 is_error <- inherits(cond, "error")
[13:19:57.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.712]                   NULL)
[13:19:57.712]                 if (is_error) {
[13:19:57.712]                   sessionInformation <- function() {
[13:19:57.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.712]                       search = base::search(), system = base::Sys.info())
[13:19:57.712]                   }
[13:19:57.712]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.712]                     cond$call), session = sessionInformation(), 
[13:19:57.712]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.712]                   signalCondition(cond)
[13:19:57.712]                 }
[13:19:57.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.712]                 "immediateCondition"))) {
[13:19:57.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.712]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.712]                   if (TRUE && !signal) {
[13:19:57.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.712]                     {
[13:19:57.712]                       inherits <- base::inherits
[13:19:57.712]                       invokeRestart <- base::invokeRestart
[13:19:57.712]                       is.null <- base::is.null
[13:19:57.712]                       muffled <- FALSE
[13:19:57.712]                       if (inherits(cond, "message")) {
[13:19:57.712]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.712]                         if (muffled) 
[13:19:57.712]                           invokeRestart("muffleMessage")
[13:19:57.712]                       }
[13:19:57.712]                       else if (inherits(cond, "warning")) {
[13:19:57.712]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.712]                         if (muffled) 
[13:19:57.712]                           invokeRestart("muffleWarning")
[13:19:57.712]                       }
[13:19:57.712]                       else if (inherits(cond, "condition")) {
[13:19:57.712]                         if (!is.null(pattern)) {
[13:19:57.712]                           computeRestarts <- base::computeRestarts
[13:19:57.712]                           grepl <- base::grepl
[13:19:57.712]                           restarts <- computeRestarts(cond)
[13:19:57.712]                           for (restart in restarts) {
[13:19:57.712]                             name <- restart$name
[13:19:57.712]                             if (is.null(name)) 
[13:19:57.712]                               next
[13:19:57.712]                             if (!grepl(pattern, name)) 
[13:19:57.712]                               next
[13:19:57.712]                             invokeRestart(restart)
[13:19:57.712]                             muffled <- TRUE
[13:19:57.712]                             break
[13:19:57.712]                           }
[13:19:57.712]                         }
[13:19:57.712]                       }
[13:19:57.712]                       invisible(muffled)
[13:19:57.712]                     }
[13:19:57.712]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.712]                   }
[13:19:57.712]                 }
[13:19:57.712]                 else {
[13:19:57.712]                   if (TRUE) {
[13:19:57.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.712]                     {
[13:19:57.712]                       inherits <- base::inherits
[13:19:57.712]                       invokeRestart <- base::invokeRestart
[13:19:57.712]                       is.null <- base::is.null
[13:19:57.712]                       muffled <- FALSE
[13:19:57.712]                       if (inherits(cond, "message")) {
[13:19:57.712]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.712]                         if (muffled) 
[13:19:57.712]                           invokeRestart("muffleMessage")
[13:19:57.712]                       }
[13:19:57.712]                       else if (inherits(cond, "warning")) {
[13:19:57.712]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.712]                         if (muffled) 
[13:19:57.712]                           invokeRestart("muffleWarning")
[13:19:57.712]                       }
[13:19:57.712]                       else if (inherits(cond, "condition")) {
[13:19:57.712]                         if (!is.null(pattern)) {
[13:19:57.712]                           computeRestarts <- base::computeRestarts
[13:19:57.712]                           grepl <- base::grepl
[13:19:57.712]                           restarts <- computeRestarts(cond)
[13:19:57.712]                           for (restart in restarts) {
[13:19:57.712]                             name <- restart$name
[13:19:57.712]                             if (is.null(name)) 
[13:19:57.712]                               next
[13:19:57.712]                             if (!grepl(pattern, name)) 
[13:19:57.712]                               next
[13:19:57.712]                             invokeRestart(restart)
[13:19:57.712]                             muffled <- TRUE
[13:19:57.712]                             break
[13:19:57.712]                           }
[13:19:57.712]                         }
[13:19:57.712]                       }
[13:19:57.712]                       invisible(muffled)
[13:19:57.712]                     }
[13:19:57.712]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.712]                   }
[13:19:57.712]                 }
[13:19:57.712]             }
[13:19:57.712]         }))
[13:19:57.712]     }, error = function(ex) {
[13:19:57.712]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.712]                 ...future.rng), started = ...future.startTime, 
[13:19:57.712]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.712]             version = "1.8"), class = "FutureResult")
[13:19:57.712]     }, finally = {
[13:19:57.712]         if (!identical(...future.workdir, getwd())) 
[13:19:57.712]             setwd(...future.workdir)
[13:19:57.712]         {
[13:19:57.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.712]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.712]             }
[13:19:57.712]             base::options(...future.oldOptions)
[13:19:57.712]             if (.Platform$OS.type == "windows") {
[13:19:57.712]                 old_names <- names(...future.oldEnvVars)
[13:19:57.712]                 envs <- base::Sys.getenv()
[13:19:57.712]                 names <- names(envs)
[13:19:57.712]                 common <- intersect(names, old_names)
[13:19:57.712]                 added <- setdiff(names, old_names)
[13:19:57.712]                 removed <- setdiff(old_names, names)
[13:19:57.712]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.712]                   envs[common]]
[13:19:57.712]                 NAMES <- toupper(changed)
[13:19:57.712]                 args <- list()
[13:19:57.712]                 for (kk in seq_along(NAMES)) {
[13:19:57.712]                   name <- changed[[kk]]
[13:19:57.712]                   NAME <- NAMES[[kk]]
[13:19:57.712]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.712]                     next
[13:19:57.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.712]                 }
[13:19:57.712]                 NAMES <- toupper(added)
[13:19:57.712]                 for (kk in seq_along(NAMES)) {
[13:19:57.712]                   name <- added[[kk]]
[13:19:57.712]                   NAME <- NAMES[[kk]]
[13:19:57.712]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.712]                     next
[13:19:57.712]                   args[[name]] <- ""
[13:19:57.712]                 }
[13:19:57.712]                 NAMES <- toupper(removed)
[13:19:57.712]                 for (kk in seq_along(NAMES)) {
[13:19:57.712]                   name <- removed[[kk]]
[13:19:57.712]                   NAME <- NAMES[[kk]]
[13:19:57.712]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.712]                     next
[13:19:57.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.712]                 }
[13:19:57.712]                 if (length(args) > 0) 
[13:19:57.712]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.712]             }
[13:19:57.712]             else {
[13:19:57.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.712]             }
[13:19:57.712]             {
[13:19:57.712]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.712]                   0L) {
[13:19:57.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.712]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.712]                   base::options(opts)
[13:19:57.712]                 }
[13:19:57.712]                 {
[13:19:57.712]                   {
[13:19:57.712]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.712]                     NULL
[13:19:57.712]                   }
[13:19:57.712]                   options(future.plan = NULL)
[13:19:57.712]                   if (is.na(NA_character_)) 
[13:19:57.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.712]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.712]                     envir = parent.frame()) 
[13:19:57.712]                   {
[13:19:57.712]                     default_workers <- missing(workers)
[13:19:57.712]                     if (is.function(workers)) 
[13:19:57.712]                       workers <- workers()
[13:19:57.712]                     workers <- structure(as.integer(workers), 
[13:19:57.712]                       class = class(workers))
[13:19:57.712]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.712]                       1L)
[13:19:57.712]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.712]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.712]                       if (default_workers) 
[13:19:57.712]                         supportsMulticore(warn = TRUE)
[13:19:57.712]                       return(sequential(..., envir = envir))
[13:19:57.712]                     }
[13:19:57.712]                     oopts <- options(mc.cores = workers)
[13:19:57.712]                     on.exit(options(oopts))
[13:19:57.712]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.712]                       envir = envir)
[13:19:57.712]                     if (!future$lazy) 
[13:19:57.712]                       future <- run(future)
[13:19:57.712]                     invisible(future)
[13:19:57.712]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.712]                 }
[13:19:57.712]             }
[13:19:57.712]         }
[13:19:57.712]     })
[13:19:57.712]     if (TRUE) {
[13:19:57.712]         base::sink(type = "output", split = FALSE)
[13:19:57.712]         if (TRUE) {
[13:19:57.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.712]         }
[13:19:57.712]         else {
[13:19:57.712]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.712]         }
[13:19:57.712]         base::close(...future.stdout)
[13:19:57.712]         ...future.stdout <- NULL
[13:19:57.712]     }
[13:19:57.712]     ...future.result$conditions <- ...future.conditions
[13:19:57.712]     ...future.result$finished <- base::Sys.time()
[13:19:57.712]     ...future.result
[13:19:57.712] }
[13:19:57.716] assign_globals() ...
[13:19:57.716] List of 5
[13:19:57.716]  $ future.call.arguments    : list()
[13:19:57.716]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.716]  $ ...future.FUN            :function (x, ...)  
[13:19:57.716]  $ ...future.elements_ii    :List of 1
[13:19:57.716]   ..$ : num [1:4] 2 4 6 8
[13:19:57.716]  $ ...future.seeds_ii       : NULL
[13:19:57.716]  $ ...future.globals.maxSize: num Inf
[13:19:57.716]  - attr(*, "resolved")= logi FALSE
[13:19:57.716]  - attr(*, "total_size")= num NA
[13:19:57.716]  - attr(*, "where")=List of 5
[13:19:57.716]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.716]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.716]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.716]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.716]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.716]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.716]  - attr(*, "already-done")= logi TRUE
[13:19:57.723] - copied ‘future.call.arguments’ to environment
[13:19:57.724] - copied ‘...future.FUN’ to environment
[13:19:57.724] - copied ‘...future.elements_ii’ to environment
[13:19:57.724] - copied ‘...future.seeds_ii’ to environment
[13:19:57.724] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.724] assign_globals() ... done
[13:19:57.724] requestCore(): workers = 2
[13:19:57.727] MulticoreFuture started
[13:19:57.727] - Launch lazy future ... done
[13:19:57.727] run() for ‘MulticoreFuture’ ... done
[13:19:57.728] Created future:
[13:19:57.728] plan(): Setting new future strategy stack:
[13:19:57.729] List of future strategies:
[13:19:57.729] 1. sequential:
[13:19:57.729]    - args: function (..., envir = parent.frame())
[13:19:57.729]    - tweaked: FALSE
[13:19:57.729]    - call: NULL
[13:19:57.729] plan(): nbrOfWorkers() = 1
[13:19:57.732] plan(): Setting new future strategy stack:
[13:19:57.732] List of future strategies:
[13:19:57.732] 1. multicore:
[13:19:57.732]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.732]    - tweaked: FALSE
[13:19:57.732]    - call: plan(strategy)
[13:19:57.728] MulticoreFuture:
[13:19:57.728] Label: ‘future_apply-2’
[13:19:57.728] Expression:
[13:19:57.728] {
[13:19:57.728]     do.call(function(...) {
[13:19:57.728]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.728]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.728]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.728]             on.exit(options(oopts), add = TRUE)
[13:19:57.728]         }
[13:19:57.728]         {
[13:19:57.728]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.728]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.728]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.728]             })
[13:19:57.728]         }
[13:19:57.728]     }, args = future.call.arguments)
[13:19:57.728] }
[13:19:57.728] Lazy evaluation: FALSE
[13:19:57.728] Asynchronous evaluation: TRUE
[13:19:57.728] Local evaluation: TRUE
[13:19:57.728] Environment: R_GlobalEnv
[13:19:57.728] Capture standard output: TRUE
[13:19:57.728] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.728] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.728] Packages: 1 packages (‘stats’)
[13:19:57.728] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.728] Resolved: FALSE
[13:19:57.728] Value: <not collected>
[13:19:57.728] Conditions captured: <none>
[13:19:57.728] Early signaling: FALSE
[13:19:57.728] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.728] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.741] Chunk #2 of 2 ... DONE
[13:19:57.741] Launching 2 futures (chunks) ... DONE
[13:19:57.741] Resolving 2 futures (chunks) ...
[13:19:57.741] resolve() on list ...
[13:19:57.742]  recursive: 0
[13:19:57.742]  length: 2
[13:19:57.742] 
[13:19:57.743] plan(): nbrOfWorkers() = 2
[13:19:57.742] Future #1
[13:19:57.745] result() for MulticoreFuture ...
[13:19:57.747] result() for MulticoreFuture ...
[13:19:57.747] result() for MulticoreFuture ... done
[13:19:57.747] result() for MulticoreFuture ... done
[13:19:57.748] result() for MulticoreFuture ...
[13:19:57.748] result() for MulticoreFuture ... done
[13:19:57.748] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:57.748] - nx: 2
[13:19:57.749] - relay: TRUE
[13:19:57.749] - stdout: TRUE
[13:19:57.749] - signal: TRUE
[13:19:57.749] - resignal: FALSE
[13:19:57.750] - force: TRUE
[13:19:57.750] - relayed: [n=2] FALSE, FALSE
[13:19:57.750] - queued futures: [n=2] FALSE, FALSE
[13:19:57.750]  - until=1
[13:19:57.751]  - relaying element #1
[13:19:57.751] result() for MulticoreFuture ...
[13:19:57.751] result() for MulticoreFuture ... done
[13:19:57.751] result() for MulticoreFuture ...
[13:19:57.752] result() for MulticoreFuture ... done
[13:19:57.752] result() for MulticoreFuture ...
[13:19:57.753] result() for MulticoreFuture ... done
[13:19:57.753] result() for MulticoreFuture ...
[13:19:57.753] result() for MulticoreFuture ... done
[13:19:57.753] - relayed: [n=2] TRUE, FALSE
[13:19:57.753] - queued futures: [n=2] TRUE, FALSE
[13:19:57.754] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:57.754]  length: 1 (resolved future 1)
[13:19:57.754] Future #2
[13:19:57.755] result() for MulticoreFuture ...
[13:19:57.755] result() for MulticoreFuture ...
[13:19:57.755] result() for MulticoreFuture ... done
[13:19:57.756] result() for MulticoreFuture ... done
[13:19:57.756] result() for MulticoreFuture ...
[13:19:57.756] result() for MulticoreFuture ... done
[13:19:57.756] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:57.756] - nx: 2
[13:19:57.756] - relay: TRUE
[13:19:57.756] - stdout: TRUE
[13:19:57.757] - signal: TRUE
[13:19:57.757] - resignal: FALSE
[13:19:57.757] - force: TRUE
[13:19:57.757] - relayed: [n=2] TRUE, FALSE
[13:19:57.757] - queued futures: [n=2] TRUE, FALSE
[13:19:57.757]  - until=2
[13:19:57.757]  - relaying element #2
[13:19:57.758] result() for MulticoreFuture ...
[13:19:57.758] result() for MulticoreFuture ... done
[13:19:57.758] result() for MulticoreFuture ...
[13:19:57.758] result() for MulticoreFuture ... done
[13:19:57.758] result() for MulticoreFuture ...
[13:19:57.758] result() for MulticoreFuture ... done
[13:19:57.758] result() for MulticoreFuture ...
[13:19:57.758] result() for MulticoreFuture ... done
[13:19:57.759] - relayed: [n=2] TRUE, TRUE
[13:19:57.759] - queued futures: [n=2] TRUE, TRUE
[13:19:57.759] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:57.759]  length: 0 (resolved future 2)
[13:19:57.759] Relaying remaining futures
[13:19:57.759] signalConditionsASAP(NULL, pos=0) ...
[13:19:57.759] - nx: 2
[13:19:57.759] - relay: TRUE
[13:19:57.759] - stdout: TRUE
[13:19:57.760] - signal: TRUE
[13:19:57.760] - resignal: FALSE
[13:19:57.760] - force: TRUE
[13:19:57.760] - relayed: [n=2] TRUE, TRUE
[13:19:57.760] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:57.760] - relayed: [n=2] TRUE, TRUE
[13:19:57.760] - queued futures: [n=2] TRUE, TRUE
[13:19:57.760] signalConditionsASAP(NULL, pos=0) ... done
[13:19:57.760] resolve() on list ... DONE
[13:19:57.761] result() for MulticoreFuture ...
[13:19:57.761] result() for MulticoreFuture ... done
[13:19:57.761] result() for MulticoreFuture ...
[13:19:57.761] result() for MulticoreFuture ... done
[13:19:57.761] result() for MulticoreFuture ...
[13:19:57.761] result() for MulticoreFuture ... done
[13:19:57.761] result() for MulticoreFuture ...
[13:19:57.761] result() for MulticoreFuture ... done
[13:19:57.762]  - Number of value chunks collected: 2
[13:19:57.762] Resolving 2 futures (chunks) ... DONE
[13:19:57.762] Reducing values from 2 chunks ...
[13:19:57.762]  - Number of values collected after concatenation: 2
[13:19:57.762]  - Number of values expected: 2
[13:19:57.762] Reducing values from 2 chunks ... DONE
[13:19:57.762] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[13:19:57.763] getGlobalsAndPackagesXApply() ...
[13:19:57.763]  - future.globals: TRUE
[13:19:57.763] getGlobalsAndPackages() ...
[13:19:57.763] Searching for globals...
[13:19:57.764] - globals found: [1] ‘FUN’
[13:19:57.765] Searching for globals ... DONE
[13:19:57.765] Resolving globals: FALSE
[13:19:57.765] The total size of the 1 globals is 848 bytes (848 bytes)
[13:19:57.765] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:19:57.766] - globals: [1] ‘FUN’
[13:19:57.766] 
[13:19:57.766] getGlobalsAndPackages() ... DONE
[13:19:57.766]  - globals found/used: [n=1] ‘FUN’
[13:19:57.766]  - needed namespaces: [n=0] 
[13:19:57.766] Finding globals ... DONE
[13:19:57.766]  - use_args: TRUE
[13:19:57.766]  - Getting '...' globals ...
[13:19:57.767] resolve() on list ...
[13:19:57.767]  recursive: 0
[13:19:57.767]  length: 1
[13:19:57.767]  elements: ‘...’
[13:19:57.767]  length: 0 (resolved future 1)
[13:19:57.767] resolve() on list ... DONE
[13:19:57.767]    - '...' content: [n=0] 
[13:19:57.767] List of 1
[13:19:57.767]  $ ...: list()
[13:19:57.767]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.767]  - attr(*, "where")=List of 1
[13:19:57.767]   ..$ ...:<environment: 0x5559212924d0> 
[13:19:57.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.767]  - attr(*, "resolved")= logi TRUE
[13:19:57.767]  - attr(*, "total_size")= num NA
[13:19:57.770]  - Getting '...' globals ... DONE
[13:19:57.771] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:57.771] List of 2
[13:19:57.771]  $ ...future.FUN:function (x)  
[13:19:57.771]  $ ...          : list()
[13:19:57.771]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.771]  - attr(*, "where")=List of 2
[13:19:57.771]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:57.771]   ..$ ...          :<environment: 0x5559212924d0> 
[13:19:57.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.771]  - attr(*, "resolved")= logi FALSE
[13:19:57.771]  - attr(*, "total_size")= num 848
[13:19:57.774] Packages to be attached in all futures: [n=0] 
[13:19:57.774] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.780] future_lapply() ...
[13:19:57.785] Number of chunks: 2
[13:19:57.785] getGlobalsAndPackagesXApply() ...
[13:19:57.785]  - future.globals: <name-value list> with names ‘list()’
[13:19:57.785]  - use_args: TRUE
[13:19:57.785] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:57.786] List of 2
[13:19:57.786]  $ ...          : list()
[13:19:57.786]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.786]  $ ...future.FUN:function (x)  
[13:19:57.786]  - attr(*, "where")=List of 2
[13:19:57.786]   ..$ ...          :<environment: 0x5559212924d0> 
[13:19:57.786]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:57.786]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.786]  - attr(*, "resolved")= logi FALSE
[13:19:57.786]  - attr(*, "total_size")= num NA
[13:19:57.789] Packages to be attached in all futures: [n=0] 
[13:19:57.789] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.790] Number of futures (= number of chunks): 2
[13:19:57.790] Launching 2 futures (chunks) ...
[13:19:57.790] Chunk #1 of 2 ...
[13:19:57.790]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:57.790]  - seeds: <none>
[13:19:57.790]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.790] getGlobalsAndPackages() ...
[13:19:57.790] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.791] Resolving globals: FALSE
[13:19:57.791] Tweak future expression to call with '...' arguments ...
[13:19:57.791] {
[13:19:57.791]     do.call(function(...) {
[13:19:57.791]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.791]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.791]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.791]             on.exit(options(oopts), add = TRUE)
[13:19:57.791]         }
[13:19:57.791]         {
[13:19:57.791]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.791]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.791]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.791]             })
[13:19:57.791]         }
[13:19:57.791]     }, args = future.call.arguments)
[13:19:57.791] }
[13:19:57.791] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.791] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.792] 
[13:19:57.792] getGlobalsAndPackages() ... DONE
[13:19:57.792] run() for ‘Future’ ...
[13:19:57.792] - state: ‘created’
[13:19:57.792] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.796] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.796] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.796]   - Field: ‘label’
[13:19:57.796]   - Field: ‘local’
[13:19:57.796]   - Field: ‘owner’
[13:19:57.796]   - Field: ‘envir’
[13:19:57.796]   - Field: ‘workers’
[13:19:57.797]   - Field: ‘packages’
[13:19:57.797]   - Field: ‘gc’
[13:19:57.797]   - Field: ‘job’
[13:19:57.797]   - Field: ‘conditions’
[13:19:57.797]   - Field: ‘expr’
[13:19:57.797]   - Field: ‘uuid’
[13:19:57.797]   - Field: ‘seed’
[13:19:57.797]   - Field: ‘version’
[13:19:57.797]   - Field: ‘result’
[13:19:57.797]   - Field: ‘asynchronous’
[13:19:57.797]   - Field: ‘calls’
[13:19:57.798]   - Field: ‘globals’
[13:19:57.798]   - Field: ‘stdout’
[13:19:57.798]   - Field: ‘earlySignal’
[13:19:57.798]   - Field: ‘lazy’
[13:19:57.798]   - Field: ‘state’
[13:19:57.798] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.798] - Launch lazy future ...
[13:19:57.798] Packages needed by the future expression (n = 0): <none>
[13:19:57.799] Packages needed by future strategies (n = 0): <none>
[13:19:57.799] {
[13:19:57.799]     {
[13:19:57.799]         {
[13:19:57.799]             ...future.startTime <- base::Sys.time()
[13:19:57.799]             {
[13:19:57.799]                 {
[13:19:57.799]                   {
[13:19:57.799]                     {
[13:19:57.799]                       base::local({
[13:19:57.799]                         has_future <- base::requireNamespace("future", 
[13:19:57.799]                           quietly = TRUE)
[13:19:57.799]                         if (has_future) {
[13:19:57.799]                           ns <- base::getNamespace("future")
[13:19:57.799]                           version <- ns[[".package"]][["version"]]
[13:19:57.799]                           if (is.null(version)) 
[13:19:57.799]                             version <- utils::packageVersion("future")
[13:19:57.799]                         }
[13:19:57.799]                         else {
[13:19:57.799]                           version <- NULL
[13:19:57.799]                         }
[13:19:57.799]                         if (!has_future || version < "1.8.0") {
[13:19:57.799]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.799]                             "", base::R.version$version.string), 
[13:19:57.799]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:57.799]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.799]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.799]                               "release", "version")], collapse = " "), 
[13:19:57.799]                             hostname = base::Sys.info()[["nodename"]])
[13:19:57.799]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.799]                             info)
[13:19:57.799]                           info <- base::paste(info, collapse = "; ")
[13:19:57.799]                           if (!has_future) {
[13:19:57.799]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.799]                               info)
[13:19:57.799]                           }
[13:19:57.799]                           else {
[13:19:57.799]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.799]                               info, version)
[13:19:57.799]                           }
[13:19:57.799]                           base::stop(msg)
[13:19:57.799]                         }
[13:19:57.799]                       })
[13:19:57.799]                     }
[13:19:57.799]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.799]                     base::options(mc.cores = 1L)
[13:19:57.799]                   }
[13:19:57.799]                   options(future.plan = NULL)
[13:19:57.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.799]                 }
[13:19:57.799]                 ...future.workdir <- getwd()
[13:19:57.799]             }
[13:19:57.799]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.799]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.799]         }
[13:19:57.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.799]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.799]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.799]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.799]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.799]             base::names(...future.oldOptions))
[13:19:57.799]     }
[13:19:57.799]     if (FALSE) {
[13:19:57.799]     }
[13:19:57.799]     else {
[13:19:57.799]         if (TRUE) {
[13:19:57.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.799]                 open = "w")
[13:19:57.799]         }
[13:19:57.799]         else {
[13:19:57.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.799]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.799]         }
[13:19:57.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.799]             base::sink(type = "output", split = FALSE)
[13:19:57.799]             base::close(...future.stdout)
[13:19:57.799]         }, add = TRUE)
[13:19:57.799]     }
[13:19:57.799]     ...future.frame <- base::sys.nframe()
[13:19:57.799]     ...future.conditions <- base::list()
[13:19:57.799]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.799]     if (FALSE) {
[13:19:57.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.799]     }
[13:19:57.799]     ...future.result <- base::tryCatch({
[13:19:57.799]         base::withCallingHandlers({
[13:19:57.799]             ...future.value <- base::withVisible(base::local({
[13:19:57.799]                 withCallingHandlers({
[13:19:57.799]                   {
[13:19:57.799]                     do.call(function(...) {
[13:19:57.799]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.799]                       if (!identical(...future.globals.maxSize.org, 
[13:19:57.799]                         ...future.globals.maxSize)) {
[13:19:57.799]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.799]                         on.exit(options(oopts), add = TRUE)
[13:19:57.799]                       }
[13:19:57.799]                       {
[13:19:57.799]                         lapply(seq_along(...future.elements_ii), 
[13:19:57.799]                           FUN = function(jj) {
[13:19:57.799]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.799]                             ...future.FUN(...future.X_jj, ...)
[13:19:57.799]                           })
[13:19:57.799]                       }
[13:19:57.799]                     }, args = future.call.arguments)
[13:19:57.799]                   }
[13:19:57.799]                 }, immediateCondition = function(cond) {
[13:19:57.799]                   save_rds <- function (object, pathname, ...) 
[13:19:57.799]                   {
[13:19:57.799]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.799]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.799]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.799]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.799]                         fi_tmp[["mtime"]])
[13:19:57.799]                     }
[13:19:57.799]                     tryCatch({
[13:19:57.799]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.799]                     }, error = function(ex) {
[13:19:57.799]                       msg <- conditionMessage(ex)
[13:19:57.799]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.799]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.799]                         fi_tmp[["mtime"]], msg)
[13:19:57.799]                       ex$message <- msg
[13:19:57.799]                       stop(ex)
[13:19:57.799]                     })
[13:19:57.799]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.799]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.799]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.799]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.799]                       fi <- file.info(pathname)
[13:19:57.799]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.799]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.799]                         fi[["size"]], fi[["mtime"]])
[13:19:57.799]                       stop(msg)
[13:19:57.799]                     }
[13:19:57.799]                     invisible(pathname)
[13:19:57.799]                   }
[13:19:57.799]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.799]                     rootPath = tempdir()) 
[13:19:57.799]                   {
[13:19:57.799]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.799]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.799]                       tmpdir = path, fileext = ".rds")
[13:19:57.799]                     save_rds(obj, file)
[13:19:57.799]                   }
[13:19:57.799]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:57.799]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.799]                   {
[13:19:57.799]                     inherits <- base::inherits
[13:19:57.799]                     invokeRestart <- base::invokeRestart
[13:19:57.799]                     is.null <- base::is.null
[13:19:57.799]                     muffled <- FALSE
[13:19:57.799]                     if (inherits(cond, "message")) {
[13:19:57.799]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.799]                       if (muffled) 
[13:19:57.799]                         invokeRestart("muffleMessage")
[13:19:57.799]                     }
[13:19:57.799]                     else if (inherits(cond, "warning")) {
[13:19:57.799]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.799]                       if (muffled) 
[13:19:57.799]                         invokeRestart("muffleWarning")
[13:19:57.799]                     }
[13:19:57.799]                     else if (inherits(cond, "condition")) {
[13:19:57.799]                       if (!is.null(pattern)) {
[13:19:57.799]                         computeRestarts <- base::computeRestarts
[13:19:57.799]                         grepl <- base::grepl
[13:19:57.799]                         restarts <- computeRestarts(cond)
[13:19:57.799]                         for (restart in restarts) {
[13:19:57.799]                           name <- restart$name
[13:19:57.799]                           if (is.null(name)) 
[13:19:57.799]                             next
[13:19:57.799]                           if (!grepl(pattern, name)) 
[13:19:57.799]                             next
[13:19:57.799]                           invokeRestart(restart)
[13:19:57.799]                           muffled <- TRUE
[13:19:57.799]                           break
[13:19:57.799]                         }
[13:19:57.799]                       }
[13:19:57.799]                     }
[13:19:57.799]                     invisible(muffled)
[13:19:57.799]                   }
[13:19:57.799]                   muffleCondition(cond)
[13:19:57.799]                 })
[13:19:57.799]             }))
[13:19:57.799]             future::FutureResult(value = ...future.value$value, 
[13:19:57.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.799]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.799]                     ...future.globalenv.names))
[13:19:57.799]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.799]         }, condition = base::local({
[13:19:57.799]             c <- base::c
[13:19:57.799]             inherits <- base::inherits
[13:19:57.799]             invokeRestart <- base::invokeRestart
[13:19:57.799]             length <- base::length
[13:19:57.799]             list <- base::list
[13:19:57.799]             seq.int <- base::seq.int
[13:19:57.799]             signalCondition <- base::signalCondition
[13:19:57.799]             sys.calls <- base::sys.calls
[13:19:57.799]             `[[` <- base::`[[`
[13:19:57.799]             `+` <- base::`+`
[13:19:57.799]             `<<-` <- base::`<<-`
[13:19:57.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.799]                   3L)]
[13:19:57.799]             }
[13:19:57.799]             function(cond) {
[13:19:57.799]                 is_error <- inherits(cond, "error")
[13:19:57.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.799]                   NULL)
[13:19:57.799]                 if (is_error) {
[13:19:57.799]                   sessionInformation <- function() {
[13:19:57.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.799]                       search = base::search(), system = base::Sys.info())
[13:19:57.799]                   }
[13:19:57.799]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.799]                     cond$call), session = sessionInformation(), 
[13:19:57.799]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.799]                   signalCondition(cond)
[13:19:57.799]                 }
[13:19:57.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.799]                 "immediateCondition"))) {
[13:19:57.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.799]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.799]                   if (TRUE && !signal) {
[13:19:57.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.799]                     {
[13:19:57.799]                       inherits <- base::inherits
[13:19:57.799]                       invokeRestart <- base::invokeRestart
[13:19:57.799]                       is.null <- base::is.null
[13:19:57.799]                       muffled <- FALSE
[13:19:57.799]                       if (inherits(cond, "message")) {
[13:19:57.799]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.799]                         if (muffled) 
[13:19:57.799]                           invokeRestart("muffleMessage")
[13:19:57.799]                       }
[13:19:57.799]                       else if (inherits(cond, "warning")) {
[13:19:57.799]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.799]                         if (muffled) 
[13:19:57.799]                           invokeRestart("muffleWarning")
[13:19:57.799]                       }
[13:19:57.799]                       else if (inherits(cond, "condition")) {
[13:19:57.799]                         if (!is.null(pattern)) {
[13:19:57.799]                           computeRestarts <- base::computeRestarts
[13:19:57.799]                           grepl <- base::grepl
[13:19:57.799]                           restarts <- computeRestarts(cond)
[13:19:57.799]                           for (restart in restarts) {
[13:19:57.799]                             name <- restart$name
[13:19:57.799]                             if (is.null(name)) 
[13:19:57.799]                               next
[13:19:57.799]                             if (!grepl(pattern, name)) 
[13:19:57.799]                               next
[13:19:57.799]                             invokeRestart(restart)
[13:19:57.799]                             muffled <- TRUE
[13:19:57.799]                             break
[13:19:57.799]                           }
[13:19:57.799]                         }
[13:19:57.799]                       }
[13:19:57.799]                       invisible(muffled)
[13:19:57.799]                     }
[13:19:57.799]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.799]                   }
[13:19:57.799]                 }
[13:19:57.799]                 else {
[13:19:57.799]                   if (TRUE) {
[13:19:57.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.799]                     {
[13:19:57.799]                       inherits <- base::inherits
[13:19:57.799]                       invokeRestart <- base::invokeRestart
[13:19:57.799]                       is.null <- base::is.null
[13:19:57.799]                       muffled <- FALSE
[13:19:57.799]                       if (inherits(cond, "message")) {
[13:19:57.799]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.799]                         if (muffled) 
[13:19:57.799]                           invokeRestart("muffleMessage")
[13:19:57.799]                       }
[13:19:57.799]                       else if (inherits(cond, "warning")) {
[13:19:57.799]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.799]                         if (muffled) 
[13:19:57.799]                           invokeRestart("muffleWarning")
[13:19:57.799]                       }
[13:19:57.799]                       else if (inherits(cond, "condition")) {
[13:19:57.799]                         if (!is.null(pattern)) {
[13:19:57.799]                           computeRestarts <- base::computeRestarts
[13:19:57.799]                           grepl <- base::grepl
[13:19:57.799]                           restarts <- computeRestarts(cond)
[13:19:57.799]                           for (restart in restarts) {
[13:19:57.799]                             name <- restart$name
[13:19:57.799]                             if (is.null(name)) 
[13:19:57.799]                               next
[13:19:57.799]                             if (!grepl(pattern, name)) 
[13:19:57.799]                               next
[13:19:57.799]                             invokeRestart(restart)
[13:19:57.799]                             muffled <- TRUE
[13:19:57.799]                             break
[13:19:57.799]                           }
[13:19:57.799]                         }
[13:19:57.799]                       }
[13:19:57.799]                       invisible(muffled)
[13:19:57.799]                     }
[13:19:57.799]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.799]                   }
[13:19:57.799]                 }
[13:19:57.799]             }
[13:19:57.799]         }))
[13:19:57.799]     }, error = function(ex) {
[13:19:57.799]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.799]                 ...future.rng), started = ...future.startTime, 
[13:19:57.799]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.799]             version = "1.8"), class = "FutureResult")
[13:19:57.799]     }, finally = {
[13:19:57.799]         if (!identical(...future.workdir, getwd())) 
[13:19:57.799]             setwd(...future.workdir)
[13:19:57.799]         {
[13:19:57.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.799]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.799]             }
[13:19:57.799]             base::options(...future.oldOptions)
[13:19:57.799]             if (.Platform$OS.type == "windows") {
[13:19:57.799]                 old_names <- names(...future.oldEnvVars)
[13:19:57.799]                 envs <- base::Sys.getenv()
[13:19:57.799]                 names <- names(envs)
[13:19:57.799]                 common <- intersect(names, old_names)
[13:19:57.799]                 added <- setdiff(names, old_names)
[13:19:57.799]                 removed <- setdiff(old_names, names)
[13:19:57.799]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.799]                   envs[common]]
[13:19:57.799]                 NAMES <- toupper(changed)
[13:19:57.799]                 args <- list()
[13:19:57.799]                 for (kk in seq_along(NAMES)) {
[13:19:57.799]                   name <- changed[[kk]]
[13:19:57.799]                   NAME <- NAMES[[kk]]
[13:19:57.799]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.799]                     next
[13:19:57.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.799]                 }
[13:19:57.799]                 NAMES <- toupper(added)
[13:19:57.799]                 for (kk in seq_along(NAMES)) {
[13:19:57.799]                   name <- added[[kk]]
[13:19:57.799]                   NAME <- NAMES[[kk]]
[13:19:57.799]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.799]                     next
[13:19:57.799]                   args[[name]] <- ""
[13:19:57.799]                 }
[13:19:57.799]                 NAMES <- toupper(removed)
[13:19:57.799]                 for (kk in seq_along(NAMES)) {
[13:19:57.799]                   name <- removed[[kk]]
[13:19:57.799]                   NAME <- NAMES[[kk]]
[13:19:57.799]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.799]                     next
[13:19:57.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.799]                 }
[13:19:57.799]                 if (length(args) > 0) 
[13:19:57.799]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.799]             }
[13:19:57.799]             else {
[13:19:57.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.799]             }
[13:19:57.799]             {
[13:19:57.799]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.799]                   0L) {
[13:19:57.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.799]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.799]                   base::options(opts)
[13:19:57.799]                 }
[13:19:57.799]                 {
[13:19:57.799]                   {
[13:19:57.799]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.799]                     NULL
[13:19:57.799]                   }
[13:19:57.799]                   options(future.plan = NULL)
[13:19:57.799]                   if (is.na(NA_character_)) 
[13:19:57.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.799]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.799]                     envir = parent.frame()) 
[13:19:57.799]                   {
[13:19:57.799]                     default_workers <- missing(workers)
[13:19:57.799]                     if (is.function(workers)) 
[13:19:57.799]                       workers <- workers()
[13:19:57.799]                     workers <- structure(as.integer(workers), 
[13:19:57.799]                       class = class(workers))
[13:19:57.799]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.799]                       1L)
[13:19:57.799]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.799]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.799]                       if (default_workers) 
[13:19:57.799]                         supportsMulticore(warn = TRUE)
[13:19:57.799]                       return(sequential(..., envir = envir))
[13:19:57.799]                     }
[13:19:57.799]                     oopts <- options(mc.cores = workers)
[13:19:57.799]                     on.exit(options(oopts))
[13:19:57.799]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.799]                       envir = envir)
[13:19:57.799]                     if (!future$lazy) 
[13:19:57.799]                       future <- run(future)
[13:19:57.799]                     invisible(future)
[13:19:57.799]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.799]                 }
[13:19:57.799]             }
[13:19:57.799]         }
[13:19:57.799]     })
[13:19:57.799]     if (TRUE) {
[13:19:57.799]         base::sink(type = "output", split = FALSE)
[13:19:57.799]         if (TRUE) {
[13:19:57.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.799]         }
[13:19:57.799]         else {
[13:19:57.799]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.799]         }
[13:19:57.799]         base::close(...future.stdout)
[13:19:57.799]         ...future.stdout <- NULL
[13:19:57.799]     }
[13:19:57.799]     ...future.result$conditions <- ...future.conditions
[13:19:57.799]     ...future.result$finished <- base::Sys.time()
[13:19:57.799]     ...future.result
[13:19:57.799] }
[13:19:57.802] assign_globals() ...
[13:19:57.802] List of 5
[13:19:57.802]  $ future.call.arguments    : list()
[13:19:57.802]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.802]  $ ...future.FUN            :function (x)  
[13:19:57.802]  $ ...future.elements_ii    :List of 1
[13:19:57.802]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:19:57.802]  $ ...future.seeds_ii       : NULL
[13:19:57.802]  $ ...future.globals.maxSize: num Inf
[13:19:57.802]  - attr(*, "resolved")= logi FALSE
[13:19:57.802]  - attr(*, "total_size")= num NA
[13:19:57.802]  - attr(*, "where")=List of 5
[13:19:57.802]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.802]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.802]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.802]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.802]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.802]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.802]  - attr(*, "already-done")= logi TRUE
[13:19:57.807] - copied ‘future.call.arguments’ to environment
[13:19:57.807] - copied ‘...future.FUN’ to environment
[13:19:57.807] - copied ‘...future.elements_ii’ to environment
[13:19:57.807] - copied ‘...future.seeds_ii’ to environment
[13:19:57.807] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.807] assign_globals() ... done
[13:19:57.807] requestCore(): workers = 2
[13:19:57.810] MulticoreFuture started
[13:19:57.810] - Launch lazy future ... done
[13:19:57.810] run() for ‘MulticoreFuture’ ... done
[13:19:57.811] Created future:
[13:19:57.811] plan(): Setting new future strategy stack:
[13:19:57.811] List of future strategies:
[13:19:57.811] 1. sequential:
[13:19:57.811]    - args: function (..., envir = parent.frame())
[13:19:57.811]    - tweaked: FALSE
[13:19:57.811]    - call: NULL
[13:19:57.812] plan(): nbrOfWorkers() = 1
[13:19:57.814] plan(): Setting new future strategy stack:
[13:19:57.814] List of future strategies:
[13:19:57.814] 1. multicore:
[13:19:57.814]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.814]    - tweaked: FALSE
[13:19:57.814]    - call: plan(strategy)
[13:19:57.811] MulticoreFuture:
[13:19:57.811] Label: ‘future_apply-1’
[13:19:57.811] Expression:
[13:19:57.811] {
[13:19:57.811]     do.call(function(...) {
[13:19:57.811]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.811]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.811]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.811]             on.exit(options(oopts), add = TRUE)
[13:19:57.811]         }
[13:19:57.811]         {
[13:19:57.811]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.811]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.811]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.811]             })
[13:19:57.811]         }
[13:19:57.811]     }, args = future.call.arguments)
[13:19:57.811] }
[13:19:57.811] Lazy evaluation: FALSE
[13:19:57.811] Asynchronous evaluation: TRUE
[13:19:57.811] Local evaluation: TRUE
[13:19:57.811] Environment: R_GlobalEnv
[13:19:57.811] Capture standard output: TRUE
[13:19:57.811] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.811] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.811] Packages: <none>
[13:19:57.811] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.811] Resolved: FALSE
[13:19:57.811] Value: <not collected>
[13:19:57.811] Conditions captured: <none>
[13:19:57.811] Early signaling: FALSE
[13:19:57.811] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.811] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.824] Chunk #1 of 2 ... DONE
[13:19:57.824] Chunk #2 of 2 ...
[13:19:57.825] plan(): nbrOfWorkers() = 2
[13:19:57.827]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:57.827]  - seeds: <none>
[13:19:57.827]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.828] getGlobalsAndPackages() ...
[13:19:57.828] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.828] Resolving globals: FALSE
[13:19:57.828] Tweak future expression to call with '...' arguments ...
[13:19:57.829] {
[13:19:57.829]     do.call(function(...) {
[13:19:57.829]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.829]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.829]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.829]             on.exit(options(oopts), add = TRUE)
[13:19:57.829]         }
[13:19:57.829]         {
[13:19:57.829]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.829]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.829]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.829]             })
[13:19:57.829]         }
[13:19:57.829]     }, args = future.call.arguments)
[13:19:57.829] }
[13:19:57.829] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.830] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.831] 
[13:19:57.831] getGlobalsAndPackages() ... DONE
[13:19:57.832] run() for ‘Future’ ...
[13:19:57.832] - state: ‘created’
[13:19:57.832] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.838] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.839] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.839]   - Field: ‘label’
[13:19:57.839]   - Field: ‘local’
[13:19:57.839]   - Field: ‘owner’
[13:19:57.839]   - Field: ‘envir’
[13:19:57.839]   - Field: ‘workers’
[13:19:57.839]   - Field: ‘packages’
[13:19:57.840]   - Field: ‘gc’
[13:19:57.840]   - Field: ‘job’
[13:19:57.840]   - Field: ‘conditions’
[13:19:57.840]   - Field: ‘expr’
[13:19:57.840]   - Field: ‘uuid’
[13:19:57.841]   - Field: ‘seed’
[13:19:57.841]   - Field: ‘version’
[13:19:57.841]   - Field: ‘result’
[13:19:57.841]   - Field: ‘asynchronous’
[13:19:57.841]   - Field: ‘calls’
[13:19:57.842]   - Field: ‘globals’
[13:19:57.842]   - Field: ‘stdout’
[13:19:57.842]   - Field: ‘earlySignal’
[13:19:57.842]   - Field: ‘lazy’
[13:19:57.842]   - Field: ‘state’
[13:19:57.842] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.842] - Launch lazy future ...
[13:19:57.843] Packages needed by the future expression (n = 0): <none>
[13:19:57.843] Packages needed by future strategies (n = 0): <none>
[13:19:57.844] {
[13:19:57.844]     {
[13:19:57.844]         {
[13:19:57.844]             ...future.startTime <- base::Sys.time()
[13:19:57.844]             {
[13:19:57.844]                 {
[13:19:57.844]                   {
[13:19:57.844]                     {
[13:19:57.844]                       base::local({
[13:19:57.844]                         has_future <- base::requireNamespace("future", 
[13:19:57.844]                           quietly = TRUE)
[13:19:57.844]                         if (has_future) {
[13:19:57.844]                           ns <- base::getNamespace("future")
[13:19:57.844]                           version <- ns[[".package"]][["version"]]
[13:19:57.844]                           if (is.null(version)) 
[13:19:57.844]                             version <- utils::packageVersion("future")
[13:19:57.844]                         }
[13:19:57.844]                         else {
[13:19:57.844]                           version <- NULL
[13:19:57.844]                         }
[13:19:57.844]                         if (!has_future || version < "1.8.0") {
[13:19:57.844]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.844]                             "", base::R.version$version.string), 
[13:19:57.844]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:57.844]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.844]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.844]                               "release", "version")], collapse = " "), 
[13:19:57.844]                             hostname = base::Sys.info()[["nodename"]])
[13:19:57.844]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.844]                             info)
[13:19:57.844]                           info <- base::paste(info, collapse = "; ")
[13:19:57.844]                           if (!has_future) {
[13:19:57.844]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.844]                               info)
[13:19:57.844]                           }
[13:19:57.844]                           else {
[13:19:57.844]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.844]                               info, version)
[13:19:57.844]                           }
[13:19:57.844]                           base::stop(msg)
[13:19:57.844]                         }
[13:19:57.844]                       })
[13:19:57.844]                     }
[13:19:57.844]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.844]                     base::options(mc.cores = 1L)
[13:19:57.844]                   }
[13:19:57.844]                   options(future.plan = NULL)
[13:19:57.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.844]                 }
[13:19:57.844]                 ...future.workdir <- getwd()
[13:19:57.844]             }
[13:19:57.844]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.844]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.844]         }
[13:19:57.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.844]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.844]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.844]             base::names(...future.oldOptions))
[13:19:57.844]     }
[13:19:57.844]     if (FALSE) {
[13:19:57.844]     }
[13:19:57.844]     else {
[13:19:57.844]         if (TRUE) {
[13:19:57.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.844]                 open = "w")
[13:19:57.844]         }
[13:19:57.844]         else {
[13:19:57.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.844]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.844]         }
[13:19:57.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.844]             base::sink(type = "output", split = FALSE)
[13:19:57.844]             base::close(...future.stdout)
[13:19:57.844]         }, add = TRUE)
[13:19:57.844]     }
[13:19:57.844]     ...future.frame <- base::sys.nframe()
[13:19:57.844]     ...future.conditions <- base::list()
[13:19:57.844]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.844]     if (FALSE) {
[13:19:57.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.844]     }
[13:19:57.844]     ...future.result <- base::tryCatch({
[13:19:57.844]         base::withCallingHandlers({
[13:19:57.844]             ...future.value <- base::withVisible(base::local({
[13:19:57.844]                 withCallingHandlers({
[13:19:57.844]                   {
[13:19:57.844]                     do.call(function(...) {
[13:19:57.844]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.844]                       if (!identical(...future.globals.maxSize.org, 
[13:19:57.844]                         ...future.globals.maxSize)) {
[13:19:57.844]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.844]                         on.exit(options(oopts), add = TRUE)
[13:19:57.844]                       }
[13:19:57.844]                       {
[13:19:57.844]                         lapply(seq_along(...future.elements_ii), 
[13:19:57.844]                           FUN = function(jj) {
[13:19:57.844]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.844]                             ...future.FUN(...future.X_jj, ...)
[13:19:57.844]                           })
[13:19:57.844]                       }
[13:19:57.844]                     }, args = future.call.arguments)
[13:19:57.844]                   }
[13:19:57.844]                 }, immediateCondition = function(cond) {
[13:19:57.844]                   save_rds <- function (object, pathname, ...) 
[13:19:57.844]                   {
[13:19:57.844]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.844]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.844]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.844]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.844]                         fi_tmp[["mtime"]])
[13:19:57.844]                     }
[13:19:57.844]                     tryCatch({
[13:19:57.844]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.844]                     }, error = function(ex) {
[13:19:57.844]                       msg <- conditionMessage(ex)
[13:19:57.844]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.844]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.844]                         fi_tmp[["mtime"]], msg)
[13:19:57.844]                       ex$message <- msg
[13:19:57.844]                       stop(ex)
[13:19:57.844]                     })
[13:19:57.844]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.844]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.844]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.844]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.844]                       fi <- file.info(pathname)
[13:19:57.844]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.844]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.844]                         fi[["size"]], fi[["mtime"]])
[13:19:57.844]                       stop(msg)
[13:19:57.844]                     }
[13:19:57.844]                     invisible(pathname)
[13:19:57.844]                   }
[13:19:57.844]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.844]                     rootPath = tempdir()) 
[13:19:57.844]                   {
[13:19:57.844]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.844]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.844]                       tmpdir = path, fileext = ".rds")
[13:19:57.844]                     save_rds(obj, file)
[13:19:57.844]                   }
[13:19:57.844]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:57.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.844]                   {
[13:19:57.844]                     inherits <- base::inherits
[13:19:57.844]                     invokeRestart <- base::invokeRestart
[13:19:57.844]                     is.null <- base::is.null
[13:19:57.844]                     muffled <- FALSE
[13:19:57.844]                     if (inherits(cond, "message")) {
[13:19:57.844]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.844]                       if (muffled) 
[13:19:57.844]                         invokeRestart("muffleMessage")
[13:19:57.844]                     }
[13:19:57.844]                     else if (inherits(cond, "warning")) {
[13:19:57.844]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.844]                       if (muffled) 
[13:19:57.844]                         invokeRestart("muffleWarning")
[13:19:57.844]                     }
[13:19:57.844]                     else if (inherits(cond, "condition")) {
[13:19:57.844]                       if (!is.null(pattern)) {
[13:19:57.844]                         computeRestarts <- base::computeRestarts
[13:19:57.844]                         grepl <- base::grepl
[13:19:57.844]                         restarts <- computeRestarts(cond)
[13:19:57.844]                         for (restart in restarts) {
[13:19:57.844]                           name <- restart$name
[13:19:57.844]                           if (is.null(name)) 
[13:19:57.844]                             next
[13:19:57.844]                           if (!grepl(pattern, name)) 
[13:19:57.844]                             next
[13:19:57.844]                           invokeRestart(restart)
[13:19:57.844]                           muffled <- TRUE
[13:19:57.844]                           break
[13:19:57.844]                         }
[13:19:57.844]                       }
[13:19:57.844]                     }
[13:19:57.844]                     invisible(muffled)
[13:19:57.844]                   }
[13:19:57.844]                   muffleCondition(cond)
[13:19:57.844]                 })
[13:19:57.844]             }))
[13:19:57.844]             future::FutureResult(value = ...future.value$value, 
[13:19:57.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.844]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.844]                     ...future.globalenv.names))
[13:19:57.844]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.844]         }, condition = base::local({
[13:19:57.844]             c <- base::c
[13:19:57.844]             inherits <- base::inherits
[13:19:57.844]             invokeRestart <- base::invokeRestart
[13:19:57.844]             length <- base::length
[13:19:57.844]             list <- base::list
[13:19:57.844]             seq.int <- base::seq.int
[13:19:57.844]             signalCondition <- base::signalCondition
[13:19:57.844]             sys.calls <- base::sys.calls
[13:19:57.844]             `[[` <- base::`[[`
[13:19:57.844]             `+` <- base::`+`
[13:19:57.844]             `<<-` <- base::`<<-`
[13:19:57.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.844]                   3L)]
[13:19:57.844]             }
[13:19:57.844]             function(cond) {
[13:19:57.844]                 is_error <- inherits(cond, "error")
[13:19:57.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.844]                   NULL)
[13:19:57.844]                 if (is_error) {
[13:19:57.844]                   sessionInformation <- function() {
[13:19:57.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.844]                       search = base::search(), system = base::Sys.info())
[13:19:57.844]                   }
[13:19:57.844]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.844]                     cond$call), session = sessionInformation(), 
[13:19:57.844]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.844]                   signalCondition(cond)
[13:19:57.844]                 }
[13:19:57.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.844]                 "immediateCondition"))) {
[13:19:57.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.844]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.844]                   if (TRUE && !signal) {
[13:19:57.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.844]                     {
[13:19:57.844]                       inherits <- base::inherits
[13:19:57.844]                       invokeRestart <- base::invokeRestart
[13:19:57.844]                       is.null <- base::is.null
[13:19:57.844]                       muffled <- FALSE
[13:19:57.844]                       if (inherits(cond, "message")) {
[13:19:57.844]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.844]                         if (muffled) 
[13:19:57.844]                           invokeRestart("muffleMessage")
[13:19:57.844]                       }
[13:19:57.844]                       else if (inherits(cond, "warning")) {
[13:19:57.844]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.844]                         if (muffled) 
[13:19:57.844]                           invokeRestart("muffleWarning")
[13:19:57.844]                       }
[13:19:57.844]                       else if (inherits(cond, "condition")) {
[13:19:57.844]                         if (!is.null(pattern)) {
[13:19:57.844]                           computeRestarts <- base::computeRestarts
[13:19:57.844]                           grepl <- base::grepl
[13:19:57.844]                           restarts <- computeRestarts(cond)
[13:19:57.844]                           for (restart in restarts) {
[13:19:57.844]                             name <- restart$name
[13:19:57.844]                             if (is.null(name)) 
[13:19:57.844]                               next
[13:19:57.844]                             if (!grepl(pattern, name)) 
[13:19:57.844]                               next
[13:19:57.844]                             invokeRestart(restart)
[13:19:57.844]                             muffled <- TRUE
[13:19:57.844]                             break
[13:19:57.844]                           }
[13:19:57.844]                         }
[13:19:57.844]                       }
[13:19:57.844]                       invisible(muffled)
[13:19:57.844]                     }
[13:19:57.844]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.844]                   }
[13:19:57.844]                 }
[13:19:57.844]                 else {
[13:19:57.844]                   if (TRUE) {
[13:19:57.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.844]                     {
[13:19:57.844]                       inherits <- base::inherits
[13:19:57.844]                       invokeRestart <- base::invokeRestart
[13:19:57.844]                       is.null <- base::is.null
[13:19:57.844]                       muffled <- FALSE
[13:19:57.844]                       if (inherits(cond, "message")) {
[13:19:57.844]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.844]                         if (muffled) 
[13:19:57.844]                           invokeRestart("muffleMessage")
[13:19:57.844]                       }
[13:19:57.844]                       else if (inherits(cond, "warning")) {
[13:19:57.844]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.844]                         if (muffled) 
[13:19:57.844]                           invokeRestart("muffleWarning")
[13:19:57.844]                       }
[13:19:57.844]                       else if (inherits(cond, "condition")) {
[13:19:57.844]                         if (!is.null(pattern)) {
[13:19:57.844]                           computeRestarts <- base::computeRestarts
[13:19:57.844]                           grepl <- base::grepl
[13:19:57.844]                           restarts <- computeRestarts(cond)
[13:19:57.844]                           for (restart in restarts) {
[13:19:57.844]                             name <- restart$name
[13:19:57.844]                             if (is.null(name)) 
[13:19:57.844]                               next
[13:19:57.844]                             if (!grepl(pattern, name)) 
[13:19:57.844]                               next
[13:19:57.844]                             invokeRestart(restart)
[13:19:57.844]                             muffled <- TRUE
[13:19:57.844]                             break
[13:19:57.844]                           }
[13:19:57.844]                         }
[13:19:57.844]                       }
[13:19:57.844]                       invisible(muffled)
[13:19:57.844]                     }
[13:19:57.844]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.844]                   }
[13:19:57.844]                 }
[13:19:57.844]             }
[13:19:57.844]         }))
[13:19:57.844]     }, error = function(ex) {
[13:19:57.844]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.844]                 ...future.rng), started = ...future.startTime, 
[13:19:57.844]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.844]             version = "1.8"), class = "FutureResult")
[13:19:57.844]     }, finally = {
[13:19:57.844]         if (!identical(...future.workdir, getwd())) 
[13:19:57.844]             setwd(...future.workdir)
[13:19:57.844]         {
[13:19:57.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.844]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.844]             }
[13:19:57.844]             base::options(...future.oldOptions)
[13:19:57.844]             if (.Platform$OS.type == "windows") {
[13:19:57.844]                 old_names <- names(...future.oldEnvVars)
[13:19:57.844]                 envs <- base::Sys.getenv()
[13:19:57.844]                 names <- names(envs)
[13:19:57.844]                 common <- intersect(names, old_names)
[13:19:57.844]                 added <- setdiff(names, old_names)
[13:19:57.844]                 removed <- setdiff(old_names, names)
[13:19:57.844]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.844]                   envs[common]]
[13:19:57.844]                 NAMES <- toupper(changed)
[13:19:57.844]                 args <- list()
[13:19:57.844]                 for (kk in seq_along(NAMES)) {
[13:19:57.844]                   name <- changed[[kk]]
[13:19:57.844]                   NAME <- NAMES[[kk]]
[13:19:57.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.844]                     next
[13:19:57.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.844]                 }
[13:19:57.844]                 NAMES <- toupper(added)
[13:19:57.844]                 for (kk in seq_along(NAMES)) {
[13:19:57.844]                   name <- added[[kk]]
[13:19:57.844]                   NAME <- NAMES[[kk]]
[13:19:57.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.844]                     next
[13:19:57.844]                   args[[name]] <- ""
[13:19:57.844]                 }
[13:19:57.844]                 NAMES <- toupper(removed)
[13:19:57.844]                 for (kk in seq_along(NAMES)) {
[13:19:57.844]                   name <- removed[[kk]]
[13:19:57.844]                   NAME <- NAMES[[kk]]
[13:19:57.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.844]                     next
[13:19:57.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.844]                 }
[13:19:57.844]                 if (length(args) > 0) 
[13:19:57.844]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.844]             }
[13:19:57.844]             else {
[13:19:57.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.844]             }
[13:19:57.844]             {
[13:19:57.844]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.844]                   0L) {
[13:19:57.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.844]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.844]                   base::options(opts)
[13:19:57.844]                 }
[13:19:57.844]                 {
[13:19:57.844]                   {
[13:19:57.844]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.844]                     NULL
[13:19:57.844]                   }
[13:19:57.844]                   options(future.plan = NULL)
[13:19:57.844]                   if (is.na(NA_character_)) 
[13:19:57.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.844]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.844]                     envir = parent.frame()) 
[13:19:57.844]                   {
[13:19:57.844]                     default_workers <- missing(workers)
[13:19:57.844]                     if (is.function(workers)) 
[13:19:57.844]                       workers <- workers()
[13:19:57.844]                     workers <- structure(as.integer(workers), 
[13:19:57.844]                       class = class(workers))
[13:19:57.844]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.844]                       1L)
[13:19:57.844]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.844]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.844]                       if (default_workers) 
[13:19:57.844]                         supportsMulticore(warn = TRUE)
[13:19:57.844]                       return(sequential(..., envir = envir))
[13:19:57.844]                     }
[13:19:57.844]                     oopts <- options(mc.cores = workers)
[13:19:57.844]                     on.exit(options(oopts))
[13:19:57.844]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.844]                       envir = envir)
[13:19:57.844]                     if (!future$lazy) 
[13:19:57.844]                       future <- run(future)
[13:19:57.844]                     invisible(future)
[13:19:57.844]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.844]                 }
[13:19:57.844]             }
[13:19:57.844]         }
[13:19:57.844]     })
[13:19:57.844]     if (TRUE) {
[13:19:57.844]         base::sink(type = "output", split = FALSE)
[13:19:57.844]         if (TRUE) {
[13:19:57.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.844]         }
[13:19:57.844]         else {
[13:19:57.844]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.844]         }
[13:19:57.844]         base::close(...future.stdout)
[13:19:57.844]         ...future.stdout <- NULL
[13:19:57.844]     }
[13:19:57.844]     ...future.result$conditions <- ...future.conditions
[13:19:57.844]     ...future.result$finished <- base::Sys.time()
[13:19:57.844]     ...future.result
[13:19:57.844] }
[13:19:57.847] assign_globals() ...
[13:19:57.847] List of 5
[13:19:57.847]  $ future.call.arguments    : list()
[13:19:57.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.847]  $ ...future.FUN            :function (x)  
[13:19:57.847]  $ ...future.elements_ii    :List of 1
[13:19:57.847]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:19:57.847]  $ ...future.seeds_ii       : NULL
[13:19:57.847]  $ ...future.globals.maxSize: num Inf
[13:19:57.847]  - attr(*, "resolved")= logi FALSE
[13:19:57.847]  - attr(*, "total_size")= num NA
[13:19:57.847]  - attr(*, "where")=List of 5
[13:19:57.847]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.847]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.847]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.847]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.847]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.847]  - attr(*, "already-done")= logi TRUE
[13:19:57.853] - copied ‘future.call.arguments’ to environment
[13:19:57.853] - copied ‘...future.FUN’ to environment
[13:19:57.854] - copied ‘...future.elements_ii’ to environment
[13:19:57.854] - copied ‘...future.seeds_ii’ to environment
[13:19:57.854] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.854] assign_globals() ... done
[13:19:57.854] requestCore(): workers = 2
[13:19:57.856] MulticoreFuture started
[13:19:57.857] - Launch lazy future ... done
[13:19:57.857] run() for ‘MulticoreFuture’ ... done
[13:19:57.857] Created future:
[13:19:57.858] plan(): Setting new future strategy stack:
[13:19:57.858] List of future strategies:
[13:19:57.858] 1. sequential:
[13:19:57.858]    - args: function (..., envir = parent.frame())
[13:19:57.858]    - tweaked: FALSE
[13:19:57.858]    - call: NULL
[13:19:57.859] plan(): nbrOfWorkers() = 1
[13:19:57.861] plan(): Setting new future strategy stack:
[13:19:57.861] List of future strategies:
[13:19:57.861] 1. multicore:
[13:19:57.861]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.861]    - tweaked: FALSE
[13:19:57.861]    - call: plan(strategy)
[13:19:57.866] plan(): nbrOfWorkers() = 2
[13:19:57.858] MulticoreFuture:
[13:19:57.858] Label: ‘future_apply-2’
[13:19:57.858] Expression:
[13:19:57.858] {
[13:19:57.858]     do.call(function(...) {
[13:19:57.858]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.858]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.858]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.858]             on.exit(options(oopts), add = TRUE)
[13:19:57.858]         }
[13:19:57.858]         {
[13:19:57.858]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.858]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.858]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.858]             })
[13:19:57.858]         }
[13:19:57.858]     }, args = future.call.arguments)
[13:19:57.858] }
[13:19:57.858] Lazy evaluation: FALSE
[13:19:57.858] Asynchronous evaluation: TRUE
[13:19:57.858] Local evaluation: TRUE
[13:19:57.858] Environment: R_GlobalEnv
[13:19:57.858] Capture standard output: TRUE
[13:19:57.858] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.858] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.858] Packages: <none>
[13:19:57.858] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.858] Resolved: TRUE
[13:19:57.858] Value: <not collected>
[13:19:57.858] Conditions captured: <none>
[13:19:57.858] Early signaling: FALSE
[13:19:57.858] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.858] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.867] Chunk #2 of 2 ... DONE
[13:19:57.867] Launching 2 futures (chunks) ... DONE
[13:19:57.868] Resolving 2 futures (chunks) ...
[13:19:57.868] resolve() on list ...
[13:19:57.868]  recursive: 0
[13:19:57.868]  length: 2
[13:19:57.868] 
[13:19:57.869] Future #1
[13:19:57.869] result() for MulticoreFuture ...
[13:19:57.870] result() for MulticoreFuture ...
[13:19:57.870] result() for MulticoreFuture ... done
[13:19:57.870] result() for MulticoreFuture ... done
[13:19:57.870] result() for MulticoreFuture ...
[13:19:57.870] result() for MulticoreFuture ... done
[13:19:57.870] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:57.871] - nx: 2
[13:19:57.871] - relay: TRUE
[13:19:57.871] - stdout: TRUE
[13:19:57.871] - signal: TRUE
[13:19:57.871] - resignal: FALSE
[13:19:57.871] - force: TRUE
[13:19:57.871] - relayed: [n=2] FALSE, FALSE
[13:19:57.872] - queued futures: [n=2] FALSE, FALSE
[13:19:57.872]  - until=1
[13:19:57.872]  - relaying element #1
[13:19:57.872] result() for MulticoreFuture ...
[13:19:57.872] result() for MulticoreFuture ... done
[13:19:57.872] result() for MulticoreFuture ...
[13:19:57.873] result() for MulticoreFuture ... done
[13:19:57.873] result() for MulticoreFuture ...
[13:19:57.873] result() for MulticoreFuture ... done
[13:19:57.873] result() for MulticoreFuture ...
[13:19:57.873] result() for MulticoreFuture ... done
[13:19:57.873] - relayed: [n=2] TRUE, FALSE
[13:19:57.873] - queued futures: [n=2] TRUE, FALSE
[13:19:57.874] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:57.874]  length: 1 (resolved future 1)
[13:19:57.874] Future #2
[13:19:57.874] result() for MulticoreFuture ...
[13:19:57.875] result() for MulticoreFuture ...
[13:19:57.875] result() for MulticoreFuture ... done
[13:19:57.875] result() for MulticoreFuture ... done
[13:19:57.876] result() for MulticoreFuture ...
[13:19:57.876] result() for MulticoreFuture ... done
[13:19:57.876] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:57.876] - nx: 2
[13:19:57.876] - relay: TRUE
[13:19:57.877] - stdout: TRUE
[13:19:57.877] - signal: TRUE
[13:19:57.877] - resignal: FALSE
[13:19:57.877] - force: TRUE
[13:19:57.877] - relayed: [n=2] TRUE, FALSE
[13:19:57.877] - queued futures: [n=2] TRUE, FALSE
[13:19:57.878]  - until=2
[13:19:57.878]  - relaying element #2
[13:19:57.880] result() for MulticoreFuture ...
[13:19:57.881] result() for MulticoreFuture ... done
[13:19:57.881] result() for MulticoreFuture ...
[13:19:57.881] result() for MulticoreFuture ... done
[13:19:57.881] result() for MulticoreFuture ...
[13:19:57.882] result() for MulticoreFuture ... done
[13:19:57.882] result() for MulticoreFuture ...
[13:19:57.882] result() for MulticoreFuture ... done
[13:19:57.882] - relayed: [n=2] TRUE, TRUE
[13:19:57.882] - queued futures: [n=2] TRUE, TRUE
[13:19:57.882] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:57.883]  length: 0 (resolved future 2)
[13:19:57.883] Relaying remaining futures
[13:19:57.883] signalConditionsASAP(NULL, pos=0) ...
[13:19:57.883] - nx: 2
[13:19:57.883] - relay: TRUE
[13:19:57.883] - stdout: TRUE
[13:19:57.883] - signal: TRUE
[13:19:57.884] - resignal: FALSE
[13:19:57.884] - force: TRUE
[13:19:57.884] - relayed: [n=2] TRUE, TRUE
[13:19:57.884] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:57.884] - relayed: [n=2] TRUE, TRUE
[13:19:57.885] - queued futures: [n=2] TRUE, TRUE
[13:19:57.885] signalConditionsASAP(NULL, pos=0) ... done
[13:19:57.885] resolve() on list ... DONE
[13:19:57.885] result() for MulticoreFuture ...
[13:19:57.885] result() for MulticoreFuture ... done
[13:19:57.885] result() for MulticoreFuture ...
[13:19:57.885] result() for MulticoreFuture ... done
[13:19:57.886] result() for MulticoreFuture ...
[13:19:57.886] result() for MulticoreFuture ... done
[13:19:57.886] result() for MulticoreFuture ...
[13:19:57.886] result() for MulticoreFuture ... done
[13:19:57.886]  - Number of value chunks collected: 2
[13:19:57.886] Resolving 2 futures (chunks) ... DONE
[13:19:57.886] Reducing values from 2 chunks ...
[13:19:57.886]  - Number of values collected after concatenation: 2
[13:19:57.887]  - Number of values expected: 2
[13:19:57.887] Reducing values from 2 chunks ... DONE
[13:19:57.887] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[13:19:57.887] getGlobalsAndPackagesXApply() ...
[13:19:57.887]  - future.globals: TRUE
[13:19:57.888] getGlobalsAndPackages() ...
[13:19:57.888] Searching for globals...
[13:19:57.889] - globals found: [1] ‘FUN’
[13:19:57.889] Searching for globals ... DONE
[13:19:57.889] Resolving globals: FALSE
[13:19:57.890] The total size of the 1 globals is 848 bytes (848 bytes)
[13:19:57.890] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:19:57.890] - globals: [1] ‘FUN’
[13:19:57.890] 
[13:19:57.891] getGlobalsAndPackages() ... DONE
[13:19:57.891]  - globals found/used: [n=1] ‘FUN’
[13:19:57.891]  - needed namespaces: [n=0] 
[13:19:57.891] Finding globals ... DONE
[13:19:57.891]  - use_args: TRUE
[13:19:57.891]  - Getting '...' globals ...
[13:19:57.891] resolve() on list ...
[13:19:57.892]  recursive: 0
[13:19:57.892]  length: 1
[13:19:57.892]  elements: ‘...’
[13:19:57.892]  length: 0 (resolved future 1)
[13:19:57.892] resolve() on list ... DONE
[13:19:57.892]    - '...' content: [n=0] 
[13:19:57.892] List of 1
[13:19:57.892]  $ ...: list()
[13:19:57.892]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.892]  - attr(*, "where")=List of 1
[13:19:57.892]   ..$ ...:<environment: 0x555921d03b88> 
[13:19:57.892]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.892]  - attr(*, "resolved")= logi TRUE
[13:19:57.892]  - attr(*, "total_size")= num NA
[13:19:57.895]  - Getting '...' globals ... DONE
[13:19:57.895] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:57.896] List of 2
[13:19:57.896]  $ ...future.FUN:function (x)  
[13:19:57.896]  $ ...          : list()
[13:19:57.896]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.896]  - attr(*, "where")=List of 2
[13:19:57.896]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:57.896]   ..$ ...          :<environment: 0x555921d03b88> 
[13:19:57.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.896]  - attr(*, "resolved")= logi FALSE
[13:19:57.896]  - attr(*, "total_size")= num 848
[13:19:57.899] Packages to be attached in all futures: [n=0] 
[13:19:57.899] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.902] future_lapply() ...
[13:19:57.906] Number of chunks: 2
[13:19:57.906] getGlobalsAndPackagesXApply() ...
[13:19:57.907]  - future.globals: <name-value list> with names ‘list()’
[13:19:57.907]  - use_args: TRUE
[13:19:57.907] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:57.907] List of 2
[13:19:57.907]  $ ...          : list()
[13:19:57.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.907]  $ ...future.FUN:function (x)  
[13:19:57.907]  - attr(*, "where")=List of 2
[13:19:57.907]   ..$ ...          :<environment: 0x555921d03b88> 
[13:19:57.907]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:57.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.907]  - attr(*, "resolved")= logi FALSE
[13:19:57.907]  - attr(*, "total_size")= num NA
[13:19:57.912] Packages to be attached in all futures: [n=0] 
[13:19:57.912] getGlobalsAndPackagesXApply() ... DONE
[13:19:57.912] Number of futures (= number of chunks): 2
[13:19:57.913] Launching 2 futures (chunks) ...
[13:19:57.913] Chunk #1 of 2 ...
[13:19:57.913]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:57.913]  - seeds: <none>
[13:19:57.913]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.913] getGlobalsAndPackages() ...
[13:19:57.913] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.914] Resolving globals: FALSE
[13:19:57.914] Tweak future expression to call with '...' arguments ...
[13:19:57.914] {
[13:19:57.914]     do.call(function(...) {
[13:19:57.914]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.914]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.914]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.914]             on.exit(options(oopts), add = TRUE)
[13:19:57.914]         }
[13:19:57.914]         {
[13:19:57.914]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.914]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.914]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.914]             })
[13:19:57.914]         }
[13:19:57.914]     }, args = future.call.arguments)
[13:19:57.914] }
[13:19:57.914] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.915] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.915] 
[13:19:57.915] getGlobalsAndPackages() ... DONE
[13:19:57.915] run() for ‘Future’ ...
[13:19:57.915] - state: ‘created’
[13:19:57.916] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.919] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.920] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.920]   - Field: ‘label’
[13:19:57.920]   - Field: ‘local’
[13:19:57.920]   - Field: ‘owner’
[13:19:57.920]   - Field: ‘envir’
[13:19:57.920]   - Field: ‘workers’
[13:19:57.920]   - Field: ‘packages’
[13:19:57.920]   - Field: ‘gc’
[13:19:57.920]   - Field: ‘job’
[13:19:57.921]   - Field: ‘conditions’
[13:19:57.921]   - Field: ‘expr’
[13:19:57.921]   - Field: ‘uuid’
[13:19:57.921]   - Field: ‘seed’
[13:19:57.921]   - Field: ‘version’
[13:19:57.921]   - Field: ‘result’
[13:19:57.921]   - Field: ‘asynchronous’
[13:19:57.921]   - Field: ‘calls’
[13:19:57.921]   - Field: ‘globals’
[13:19:57.921]   - Field: ‘stdout’
[13:19:57.921]   - Field: ‘earlySignal’
[13:19:57.922]   - Field: ‘lazy’
[13:19:57.922]   - Field: ‘state’
[13:19:57.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.922] - Launch lazy future ...
[13:19:57.922] Packages needed by the future expression (n = 0): <none>
[13:19:57.922] Packages needed by future strategies (n = 0): <none>
[13:19:57.923] {
[13:19:57.923]     {
[13:19:57.923]         {
[13:19:57.923]             ...future.startTime <- base::Sys.time()
[13:19:57.923]             {
[13:19:57.923]                 {
[13:19:57.923]                   {
[13:19:57.923]                     {
[13:19:57.923]                       base::local({
[13:19:57.923]                         has_future <- base::requireNamespace("future", 
[13:19:57.923]                           quietly = TRUE)
[13:19:57.923]                         if (has_future) {
[13:19:57.923]                           ns <- base::getNamespace("future")
[13:19:57.923]                           version <- ns[[".package"]][["version"]]
[13:19:57.923]                           if (is.null(version)) 
[13:19:57.923]                             version <- utils::packageVersion("future")
[13:19:57.923]                         }
[13:19:57.923]                         else {
[13:19:57.923]                           version <- NULL
[13:19:57.923]                         }
[13:19:57.923]                         if (!has_future || version < "1.8.0") {
[13:19:57.923]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.923]                             "", base::R.version$version.string), 
[13:19:57.923]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:57.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.923]                               "release", "version")], collapse = " "), 
[13:19:57.923]                             hostname = base::Sys.info()[["nodename"]])
[13:19:57.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.923]                             info)
[13:19:57.923]                           info <- base::paste(info, collapse = "; ")
[13:19:57.923]                           if (!has_future) {
[13:19:57.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.923]                               info)
[13:19:57.923]                           }
[13:19:57.923]                           else {
[13:19:57.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.923]                               info, version)
[13:19:57.923]                           }
[13:19:57.923]                           base::stop(msg)
[13:19:57.923]                         }
[13:19:57.923]                       })
[13:19:57.923]                     }
[13:19:57.923]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.923]                     base::options(mc.cores = 1L)
[13:19:57.923]                   }
[13:19:57.923]                   options(future.plan = NULL)
[13:19:57.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.923]                 }
[13:19:57.923]                 ...future.workdir <- getwd()
[13:19:57.923]             }
[13:19:57.923]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.923]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.923]         }
[13:19:57.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.923]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.923]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.923]             base::names(...future.oldOptions))
[13:19:57.923]     }
[13:19:57.923]     if (FALSE) {
[13:19:57.923]     }
[13:19:57.923]     else {
[13:19:57.923]         if (TRUE) {
[13:19:57.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.923]                 open = "w")
[13:19:57.923]         }
[13:19:57.923]         else {
[13:19:57.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.923]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.923]         }
[13:19:57.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.923]             base::sink(type = "output", split = FALSE)
[13:19:57.923]             base::close(...future.stdout)
[13:19:57.923]         }, add = TRUE)
[13:19:57.923]     }
[13:19:57.923]     ...future.frame <- base::sys.nframe()
[13:19:57.923]     ...future.conditions <- base::list()
[13:19:57.923]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.923]     if (FALSE) {
[13:19:57.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.923]     }
[13:19:57.923]     ...future.result <- base::tryCatch({
[13:19:57.923]         base::withCallingHandlers({
[13:19:57.923]             ...future.value <- base::withVisible(base::local({
[13:19:57.923]                 withCallingHandlers({
[13:19:57.923]                   {
[13:19:57.923]                     do.call(function(...) {
[13:19:57.923]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.923]                       if (!identical(...future.globals.maxSize.org, 
[13:19:57.923]                         ...future.globals.maxSize)) {
[13:19:57.923]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.923]                         on.exit(options(oopts), add = TRUE)
[13:19:57.923]                       }
[13:19:57.923]                       {
[13:19:57.923]                         lapply(seq_along(...future.elements_ii), 
[13:19:57.923]                           FUN = function(jj) {
[13:19:57.923]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.923]                             ...future.FUN(...future.X_jj, ...)
[13:19:57.923]                           })
[13:19:57.923]                       }
[13:19:57.923]                     }, args = future.call.arguments)
[13:19:57.923]                   }
[13:19:57.923]                 }, immediateCondition = function(cond) {
[13:19:57.923]                   save_rds <- function (object, pathname, ...) 
[13:19:57.923]                   {
[13:19:57.923]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.923]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.923]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.923]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.923]                         fi_tmp[["mtime"]])
[13:19:57.923]                     }
[13:19:57.923]                     tryCatch({
[13:19:57.923]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.923]                     }, error = function(ex) {
[13:19:57.923]                       msg <- conditionMessage(ex)
[13:19:57.923]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.923]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.923]                         fi_tmp[["mtime"]], msg)
[13:19:57.923]                       ex$message <- msg
[13:19:57.923]                       stop(ex)
[13:19:57.923]                     })
[13:19:57.923]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.923]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.923]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.923]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.923]                       fi <- file.info(pathname)
[13:19:57.923]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.923]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.923]                         fi[["size"]], fi[["mtime"]])
[13:19:57.923]                       stop(msg)
[13:19:57.923]                     }
[13:19:57.923]                     invisible(pathname)
[13:19:57.923]                   }
[13:19:57.923]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.923]                     rootPath = tempdir()) 
[13:19:57.923]                   {
[13:19:57.923]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.923]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.923]                       tmpdir = path, fileext = ".rds")
[13:19:57.923]                     save_rds(obj, file)
[13:19:57.923]                   }
[13:19:57.923]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:57.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.923]                   {
[13:19:57.923]                     inherits <- base::inherits
[13:19:57.923]                     invokeRestart <- base::invokeRestart
[13:19:57.923]                     is.null <- base::is.null
[13:19:57.923]                     muffled <- FALSE
[13:19:57.923]                     if (inherits(cond, "message")) {
[13:19:57.923]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.923]                       if (muffled) 
[13:19:57.923]                         invokeRestart("muffleMessage")
[13:19:57.923]                     }
[13:19:57.923]                     else if (inherits(cond, "warning")) {
[13:19:57.923]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.923]                       if (muffled) 
[13:19:57.923]                         invokeRestart("muffleWarning")
[13:19:57.923]                     }
[13:19:57.923]                     else if (inherits(cond, "condition")) {
[13:19:57.923]                       if (!is.null(pattern)) {
[13:19:57.923]                         computeRestarts <- base::computeRestarts
[13:19:57.923]                         grepl <- base::grepl
[13:19:57.923]                         restarts <- computeRestarts(cond)
[13:19:57.923]                         for (restart in restarts) {
[13:19:57.923]                           name <- restart$name
[13:19:57.923]                           if (is.null(name)) 
[13:19:57.923]                             next
[13:19:57.923]                           if (!grepl(pattern, name)) 
[13:19:57.923]                             next
[13:19:57.923]                           invokeRestart(restart)
[13:19:57.923]                           muffled <- TRUE
[13:19:57.923]                           break
[13:19:57.923]                         }
[13:19:57.923]                       }
[13:19:57.923]                     }
[13:19:57.923]                     invisible(muffled)
[13:19:57.923]                   }
[13:19:57.923]                   muffleCondition(cond)
[13:19:57.923]                 })
[13:19:57.923]             }))
[13:19:57.923]             future::FutureResult(value = ...future.value$value, 
[13:19:57.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.923]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.923]                     ...future.globalenv.names))
[13:19:57.923]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.923]         }, condition = base::local({
[13:19:57.923]             c <- base::c
[13:19:57.923]             inherits <- base::inherits
[13:19:57.923]             invokeRestart <- base::invokeRestart
[13:19:57.923]             length <- base::length
[13:19:57.923]             list <- base::list
[13:19:57.923]             seq.int <- base::seq.int
[13:19:57.923]             signalCondition <- base::signalCondition
[13:19:57.923]             sys.calls <- base::sys.calls
[13:19:57.923]             `[[` <- base::`[[`
[13:19:57.923]             `+` <- base::`+`
[13:19:57.923]             `<<-` <- base::`<<-`
[13:19:57.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.923]                   3L)]
[13:19:57.923]             }
[13:19:57.923]             function(cond) {
[13:19:57.923]                 is_error <- inherits(cond, "error")
[13:19:57.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.923]                   NULL)
[13:19:57.923]                 if (is_error) {
[13:19:57.923]                   sessionInformation <- function() {
[13:19:57.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.923]                       search = base::search(), system = base::Sys.info())
[13:19:57.923]                   }
[13:19:57.923]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.923]                     cond$call), session = sessionInformation(), 
[13:19:57.923]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.923]                   signalCondition(cond)
[13:19:57.923]                 }
[13:19:57.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.923]                 "immediateCondition"))) {
[13:19:57.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.923]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.923]                   if (TRUE && !signal) {
[13:19:57.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.923]                     {
[13:19:57.923]                       inherits <- base::inherits
[13:19:57.923]                       invokeRestart <- base::invokeRestart
[13:19:57.923]                       is.null <- base::is.null
[13:19:57.923]                       muffled <- FALSE
[13:19:57.923]                       if (inherits(cond, "message")) {
[13:19:57.923]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.923]                         if (muffled) 
[13:19:57.923]                           invokeRestart("muffleMessage")
[13:19:57.923]                       }
[13:19:57.923]                       else if (inherits(cond, "warning")) {
[13:19:57.923]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.923]                         if (muffled) 
[13:19:57.923]                           invokeRestart("muffleWarning")
[13:19:57.923]                       }
[13:19:57.923]                       else if (inherits(cond, "condition")) {
[13:19:57.923]                         if (!is.null(pattern)) {
[13:19:57.923]                           computeRestarts <- base::computeRestarts
[13:19:57.923]                           grepl <- base::grepl
[13:19:57.923]                           restarts <- computeRestarts(cond)
[13:19:57.923]                           for (restart in restarts) {
[13:19:57.923]                             name <- restart$name
[13:19:57.923]                             if (is.null(name)) 
[13:19:57.923]                               next
[13:19:57.923]                             if (!grepl(pattern, name)) 
[13:19:57.923]                               next
[13:19:57.923]                             invokeRestart(restart)
[13:19:57.923]                             muffled <- TRUE
[13:19:57.923]                             break
[13:19:57.923]                           }
[13:19:57.923]                         }
[13:19:57.923]                       }
[13:19:57.923]                       invisible(muffled)
[13:19:57.923]                     }
[13:19:57.923]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.923]                   }
[13:19:57.923]                 }
[13:19:57.923]                 else {
[13:19:57.923]                   if (TRUE) {
[13:19:57.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.923]                     {
[13:19:57.923]                       inherits <- base::inherits
[13:19:57.923]                       invokeRestart <- base::invokeRestart
[13:19:57.923]                       is.null <- base::is.null
[13:19:57.923]                       muffled <- FALSE
[13:19:57.923]                       if (inherits(cond, "message")) {
[13:19:57.923]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.923]                         if (muffled) 
[13:19:57.923]                           invokeRestart("muffleMessage")
[13:19:57.923]                       }
[13:19:57.923]                       else if (inherits(cond, "warning")) {
[13:19:57.923]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.923]                         if (muffled) 
[13:19:57.923]                           invokeRestart("muffleWarning")
[13:19:57.923]                       }
[13:19:57.923]                       else if (inherits(cond, "condition")) {
[13:19:57.923]                         if (!is.null(pattern)) {
[13:19:57.923]                           computeRestarts <- base::computeRestarts
[13:19:57.923]                           grepl <- base::grepl
[13:19:57.923]                           restarts <- computeRestarts(cond)
[13:19:57.923]                           for (restart in restarts) {
[13:19:57.923]                             name <- restart$name
[13:19:57.923]                             if (is.null(name)) 
[13:19:57.923]                               next
[13:19:57.923]                             if (!grepl(pattern, name)) 
[13:19:57.923]                               next
[13:19:57.923]                             invokeRestart(restart)
[13:19:57.923]                             muffled <- TRUE
[13:19:57.923]                             break
[13:19:57.923]                           }
[13:19:57.923]                         }
[13:19:57.923]                       }
[13:19:57.923]                       invisible(muffled)
[13:19:57.923]                     }
[13:19:57.923]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.923]                   }
[13:19:57.923]                 }
[13:19:57.923]             }
[13:19:57.923]         }))
[13:19:57.923]     }, error = function(ex) {
[13:19:57.923]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.923]                 ...future.rng), started = ...future.startTime, 
[13:19:57.923]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.923]             version = "1.8"), class = "FutureResult")
[13:19:57.923]     }, finally = {
[13:19:57.923]         if (!identical(...future.workdir, getwd())) 
[13:19:57.923]             setwd(...future.workdir)
[13:19:57.923]         {
[13:19:57.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.923]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.923]             }
[13:19:57.923]             base::options(...future.oldOptions)
[13:19:57.923]             if (.Platform$OS.type == "windows") {
[13:19:57.923]                 old_names <- names(...future.oldEnvVars)
[13:19:57.923]                 envs <- base::Sys.getenv()
[13:19:57.923]                 names <- names(envs)
[13:19:57.923]                 common <- intersect(names, old_names)
[13:19:57.923]                 added <- setdiff(names, old_names)
[13:19:57.923]                 removed <- setdiff(old_names, names)
[13:19:57.923]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.923]                   envs[common]]
[13:19:57.923]                 NAMES <- toupper(changed)
[13:19:57.923]                 args <- list()
[13:19:57.923]                 for (kk in seq_along(NAMES)) {
[13:19:57.923]                   name <- changed[[kk]]
[13:19:57.923]                   NAME <- NAMES[[kk]]
[13:19:57.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.923]                     next
[13:19:57.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.923]                 }
[13:19:57.923]                 NAMES <- toupper(added)
[13:19:57.923]                 for (kk in seq_along(NAMES)) {
[13:19:57.923]                   name <- added[[kk]]
[13:19:57.923]                   NAME <- NAMES[[kk]]
[13:19:57.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.923]                     next
[13:19:57.923]                   args[[name]] <- ""
[13:19:57.923]                 }
[13:19:57.923]                 NAMES <- toupper(removed)
[13:19:57.923]                 for (kk in seq_along(NAMES)) {
[13:19:57.923]                   name <- removed[[kk]]
[13:19:57.923]                   NAME <- NAMES[[kk]]
[13:19:57.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.923]                     next
[13:19:57.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.923]                 }
[13:19:57.923]                 if (length(args) > 0) 
[13:19:57.923]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.923]             }
[13:19:57.923]             else {
[13:19:57.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.923]             }
[13:19:57.923]             {
[13:19:57.923]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.923]                   0L) {
[13:19:57.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.923]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.923]                   base::options(opts)
[13:19:57.923]                 }
[13:19:57.923]                 {
[13:19:57.923]                   {
[13:19:57.923]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.923]                     NULL
[13:19:57.923]                   }
[13:19:57.923]                   options(future.plan = NULL)
[13:19:57.923]                   if (is.na(NA_character_)) 
[13:19:57.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.923]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.923]                     envir = parent.frame()) 
[13:19:57.923]                   {
[13:19:57.923]                     default_workers <- missing(workers)
[13:19:57.923]                     if (is.function(workers)) 
[13:19:57.923]                       workers <- workers()
[13:19:57.923]                     workers <- structure(as.integer(workers), 
[13:19:57.923]                       class = class(workers))
[13:19:57.923]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.923]                       1L)
[13:19:57.923]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.923]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.923]                       if (default_workers) 
[13:19:57.923]                         supportsMulticore(warn = TRUE)
[13:19:57.923]                       return(sequential(..., envir = envir))
[13:19:57.923]                     }
[13:19:57.923]                     oopts <- options(mc.cores = workers)
[13:19:57.923]                     on.exit(options(oopts))
[13:19:57.923]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.923]                       envir = envir)
[13:19:57.923]                     if (!future$lazy) 
[13:19:57.923]                       future <- run(future)
[13:19:57.923]                     invisible(future)
[13:19:57.923]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.923]                 }
[13:19:57.923]             }
[13:19:57.923]         }
[13:19:57.923]     })
[13:19:57.923]     if (TRUE) {
[13:19:57.923]         base::sink(type = "output", split = FALSE)
[13:19:57.923]         if (TRUE) {
[13:19:57.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.923]         }
[13:19:57.923]         else {
[13:19:57.923]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.923]         }
[13:19:57.923]         base::close(...future.stdout)
[13:19:57.923]         ...future.stdout <- NULL
[13:19:57.923]     }
[13:19:57.923]     ...future.result$conditions <- ...future.conditions
[13:19:57.923]     ...future.result$finished <- base::Sys.time()
[13:19:57.923]     ...future.result
[13:19:57.923] }
[13:19:57.925] assign_globals() ...
[13:19:57.925] List of 5
[13:19:57.925]  $ future.call.arguments    : list()
[13:19:57.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.925]  $ ...future.FUN            :function (x)  
[13:19:57.925]  $ ...future.elements_ii    :List of 3
[13:19:57.925]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:19:57.925]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:19:57.925]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:19:57.925]  $ ...future.seeds_ii       : NULL
[13:19:57.925]  $ ...future.globals.maxSize: num Inf
[13:19:57.925]  - attr(*, "resolved")= logi FALSE
[13:19:57.925]  - attr(*, "total_size")= num NA
[13:19:57.925]  - attr(*, "where")=List of 5
[13:19:57.925]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.925]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.925]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.925]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.925]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.925]  - attr(*, "already-done")= logi TRUE
[13:19:57.931] - copied ‘future.call.arguments’ to environment
[13:19:57.931] - copied ‘...future.FUN’ to environment
[13:19:57.931] - copied ‘...future.elements_ii’ to environment
[13:19:57.931] - copied ‘...future.seeds_ii’ to environment
[13:19:57.931] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.932] assign_globals() ... done
[13:19:57.932] requestCore(): workers = 2
[13:19:57.934] MulticoreFuture started
[13:19:57.934] - Launch lazy future ... done
[13:19:57.934] run() for ‘MulticoreFuture’ ... done
[13:19:57.935] Created future:
[13:19:57.935] plan(): Setting new future strategy stack:
[13:19:57.935] List of future strategies:
[13:19:57.935] 1. sequential:
[13:19:57.935]    - args: function (..., envir = parent.frame())
[13:19:57.935]    - tweaked: FALSE
[13:19:57.935]    - call: NULL
[13:19:57.936] plan(): nbrOfWorkers() = 1
[13:19:57.938] plan(): Setting new future strategy stack:
[13:19:57.938] List of future strategies:
[13:19:57.938] 1. multicore:
[13:19:57.938]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.938]    - tweaked: FALSE
[13:19:57.938]    - call: plan(strategy)
[13:19:57.944] plan(): nbrOfWorkers() = 2
[13:19:57.935] MulticoreFuture:
[13:19:57.935] Label: ‘future_apply-1’
[13:19:57.935] Expression:
[13:19:57.935] {
[13:19:57.935]     do.call(function(...) {
[13:19:57.935]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.935]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.935]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.935]             on.exit(options(oopts), add = TRUE)
[13:19:57.935]         }
[13:19:57.935]         {
[13:19:57.935]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.935]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.935]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.935]             })
[13:19:57.935]         }
[13:19:57.935]     }, args = future.call.arguments)
[13:19:57.935] }
[13:19:57.935] Lazy evaluation: FALSE
[13:19:57.935] Asynchronous evaluation: TRUE
[13:19:57.935] Local evaluation: TRUE
[13:19:57.935] Environment: R_GlobalEnv
[13:19:57.935] Capture standard output: TRUE
[13:19:57.935] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.935] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.935] Packages: <none>
[13:19:57.935] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.935] Resolved: TRUE
[13:19:57.935] Value: <not collected>
[13:19:57.935] Conditions captured: <none>
[13:19:57.935] Early signaling: FALSE
[13:19:57.935] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.935] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.945] Chunk #1 of 2 ... DONE
[13:19:57.945] Chunk #2 of 2 ...
[13:19:57.945]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:57.946]  - seeds: <none>
[13:19:57.946]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.946] getGlobalsAndPackages() ...
[13:19:57.946] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.946] Resolving globals: FALSE
[13:19:57.946] Tweak future expression to call with '...' arguments ...
[13:19:57.947] {
[13:19:57.947]     do.call(function(...) {
[13:19:57.947]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.947]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.947]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.947]             on.exit(options(oopts), add = TRUE)
[13:19:57.947]         }
[13:19:57.947]         {
[13:19:57.947]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.947]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.947]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.947]             })
[13:19:57.947]         }
[13:19:57.947]     }, args = future.call.arguments)
[13:19:57.947] }
[13:19:57.947] Tweak future expression to call with '...' arguments ... DONE
[13:19:57.948] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:57.948] 
[13:19:57.948] getGlobalsAndPackages() ... DONE
[13:19:57.949] run() for ‘Future’ ...
[13:19:57.949] - state: ‘created’
[13:19:57.949] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.954] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.954]   - Field: ‘label’
[13:19:57.954]   - Field: ‘local’
[13:19:57.954]   - Field: ‘owner’
[13:19:57.954]   - Field: ‘envir’
[13:19:57.955]   - Field: ‘workers’
[13:19:57.958]   - Field: ‘packages’
[13:19:57.958]   - Field: ‘gc’
[13:19:57.959]   - Field: ‘job’
[13:19:57.959]   - Field: ‘conditions’
[13:19:57.959]   - Field: ‘expr’
[13:19:57.960]   - Field: ‘uuid’
[13:19:57.960]   - Field: ‘seed’
[13:19:57.960]   - Field: ‘version’
[13:19:57.961]   - Field: ‘result’
[13:19:57.961]   - Field: ‘asynchronous’
[13:19:57.961]   - Field: ‘calls’
[13:19:57.961]   - Field: ‘globals’
[13:19:57.962]   - Field: ‘stdout’
[13:19:57.962]   - Field: ‘earlySignal’
[13:19:57.962]   - Field: ‘lazy’
[13:19:57.962]   - Field: ‘state’
[13:19:57.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.963] - Launch lazy future ...
[13:19:57.963] Packages needed by the future expression (n = 0): <none>
[13:19:57.964] Packages needed by future strategies (n = 0): <none>
[13:19:57.965] {
[13:19:57.965]     {
[13:19:57.965]         {
[13:19:57.965]             ...future.startTime <- base::Sys.time()
[13:19:57.965]             {
[13:19:57.965]                 {
[13:19:57.965]                   {
[13:19:57.965]                     {
[13:19:57.965]                       base::local({
[13:19:57.965]                         has_future <- base::requireNamespace("future", 
[13:19:57.965]                           quietly = TRUE)
[13:19:57.965]                         if (has_future) {
[13:19:57.965]                           ns <- base::getNamespace("future")
[13:19:57.965]                           version <- ns[[".package"]][["version"]]
[13:19:57.965]                           if (is.null(version)) 
[13:19:57.965]                             version <- utils::packageVersion("future")
[13:19:57.965]                         }
[13:19:57.965]                         else {
[13:19:57.965]                           version <- NULL
[13:19:57.965]                         }
[13:19:57.965]                         if (!has_future || version < "1.8.0") {
[13:19:57.965]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.965]                             "", base::R.version$version.string), 
[13:19:57.965]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:57.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.965]                               "release", "version")], collapse = " "), 
[13:19:57.965]                             hostname = base::Sys.info()[["nodename"]])
[13:19:57.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.965]                             info)
[13:19:57.965]                           info <- base::paste(info, collapse = "; ")
[13:19:57.965]                           if (!has_future) {
[13:19:57.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.965]                               info)
[13:19:57.965]                           }
[13:19:57.965]                           else {
[13:19:57.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.965]                               info, version)
[13:19:57.965]                           }
[13:19:57.965]                           base::stop(msg)
[13:19:57.965]                         }
[13:19:57.965]                       })
[13:19:57.965]                     }
[13:19:57.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.965]                     base::options(mc.cores = 1L)
[13:19:57.965]                   }
[13:19:57.965]                   options(future.plan = NULL)
[13:19:57.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.965]                 }
[13:19:57.965]                 ...future.workdir <- getwd()
[13:19:57.965]             }
[13:19:57.965]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.965]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.965]         }
[13:19:57.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.965]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:57.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.965]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.965]             base::names(...future.oldOptions))
[13:19:57.965]     }
[13:19:57.965]     if (FALSE) {
[13:19:57.965]     }
[13:19:57.965]     else {
[13:19:57.965]         if (TRUE) {
[13:19:57.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.965]                 open = "w")
[13:19:57.965]         }
[13:19:57.965]         else {
[13:19:57.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.965]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.965]         }
[13:19:57.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.965]             base::sink(type = "output", split = FALSE)
[13:19:57.965]             base::close(...future.stdout)
[13:19:57.965]         }, add = TRUE)
[13:19:57.965]     }
[13:19:57.965]     ...future.frame <- base::sys.nframe()
[13:19:57.965]     ...future.conditions <- base::list()
[13:19:57.965]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.965]     if (FALSE) {
[13:19:57.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.965]     }
[13:19:57.965]     ...future.result <- base::tryCatch({
[13:19:57.965]         base::withCallingHandlers({
[13:19:57.965]             ...future.value <- base::withVisible(base::local({
[13:19:57.965]                 withCallingHandlers({
[13:19:57.965]                   {
[13:19:57.965]                     do.call(function(...) {
[13:19:57.965]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.965]                       if (!identical(...future.globals.maxSize.org, 
[13:19:57.965]                         ...future.globals.maxSize)) {
[13:19:57.965]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.965]                         on.exit(options(oopts), add = TRUE)
[13:19:57.965]                       }
[13:19:57.965]                       {
[13:19:57.965]                         lapply(seq_along(...future.elements_ii), 
[13:19:57.965]                           FUN = function(jj) {
[13:19:57.965]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.965]                             ...future.FUN(...future.X_jj, ...)
[13:19:57.965]                           })
[13:19:57.965]                       }
[13:19:57.965]                     }, args = future.call.arguments)
[13:19:57.965]                   }
[13:19:57.965]                 }, immediateCondition = function(cond) {
[13:19:57.965]                   save_rds <- function (object, pathname, ...) 
[13:19:57.965]                   {
[13:19:57.965]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.965]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.965]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.965]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.965]                         fi_tmp[["mtime"]])
[13:19:57.965]                     }
[13:19:57.965]                     tryCatch({
[13:19:57.965]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.965]                     }, error = function(ex) {
[13:19:57.965]                       msg <- conditionMessage(ex)
[13:19:57.965]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.965]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.965]                         fi_tmp[["mtime"]], msg)
[13:19:57.965]                       ex$message <- msg
[13:19:57.965]                       stop(ex)
[13:19:57.965]                     })
[13:19:57.965]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.965]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.965]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.965]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.965]                       fi <- file.info(pathname)
[13:19:57.965]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.965]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.965]                         fi[["size"]], fi[["mtime"]])
[13:19:57.965]                       stop(msg)
[13:19:57.965]                     }
[13:19:57.965]                     invisible(pathname)
[13:19:57.965]                   }
[13:19:57.965]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.965]                     rootPath = tempdir()) 
[13:19:57.965]                   {
[13:19:57.965]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.965]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.965]                       tmpdir = path, fileext = ".rds")
[13:19:57.965]                     save_rds(obj, file)
[13:19:57.965]                   }
[13:19:57.965]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:57.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.965]                   {
[13:19:57.965]                     inherits <- base::inherits
[13:19:57.965]                     invokeRestart <- base::invokeRestart
[13:19:57.965]                     is.null <- base::is.null
[13:19:57.965]                     muffled <- FALSE
[13:19:57.965]                     if (inherits(cond, "message")) {
[13:19:57.965]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.965]                       if (muffled) 
[13:19:57.965]                         invokeRestart("muffleMessage")
[13:19:57.965]                     }
[13:19:57.965]                     else if (inherits(cond, "warning")) {
[13:19:57.965]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.965]                       if (muffled) 
[13:19:57.965]                         invokeRestart("muffleWarning")
[13:19:57.965]                     }
[13:19:57.965]                     else if (inherits(cond, "condition")) {
[13:19:57.965]                       if (!is.null(pattern)) {
[13:19:57.965]                         computeRestarts <- base::computeRestarts
[13:19:57.965]                         grepl <- base::grepl
[13:19:57.965]                         restarts <- computeRestarts(cond)
[13:19:57.965]                         for (restart in restarts) {
[13:19:57.965]                           name <- restart$name
[13:19:57.965]                           if (is.null(name)) 
[13:19:57.965]                             next
[13:19:57.965]                           if (!grepl(pattern, name)) 
[13:19:57.965]                             next
[13:19:57.965]                           invokeRestart(restart)
[13:19:57.965]                           muffled <- TRUE
[13:19:57.965]                           break
[13:19:57.965]                         }
[13:19:57.965]                       }
[13:19:57.965]                     }
[13:19:57.965]                     invisible(muffled)
[13:19:57.965]                   }
[13:19:57.965]                   muffleCondition(cond)
[13:19:57.965]                 })
[13:19:57.965]             }))
[13:19:57.965]             future::FutureResult(value = ...future.value$value, 
[13:19:57.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.965]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.965]                     ...future.globalenv.names))
[13:19:57.965]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.965]         }, condition = base::local({
[13:19:57.965]             c <- base::c
[13:19:57.965]             inherits <- base::inherits
[13:19:57.965]             invokeRestart <- base::invokeRestart
[13:19:57.965]             length <- base::length
[13:19:57.965]             list <- base::list
[13:19:57.965]             seq.int <- base::seq.int
[13:19:57.965]             signalCondition <- base::signalCondition
[13:19:57.965]             sys.calls <- base::sys.calls
[13:19:57.965]             `[[` <- base::`[[`
[13:19:57.965]             `+` <- base::`+`
[13:19:57.965]             `<<-` <- base::`<<-`
[13:19:57.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.965]                   3L)]
[13:19:57.965]             }
[13:19:57.965]             function(cond) {
[13:19:57.965]                 is_error <- inherits(cond, "error")
[13:19:57.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.965]                   NULL)
[13:19:57.965]                 if (is_error) {
[13:19:57.965]                   sessionInformation <- function() {
[13:19:57.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.965]                       search = base::search(), system = base::Sys.info())
[13:19:57.965]                   }
[13:19:57.965]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.965]                     cond$call), session = sessionInformation(), 
[13:19:57.965]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.965]                   signalCondition(cond)
[13:19:57.965]                 }
[13:19:57.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.965]                 "immediateCondition"))) {
[13:19:57.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.965]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.965]                   if (TRUE && !signal) {
[13:19:57.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.965]                     {
[13:19:57.965]                       inherits <- base::inherits
[13:19:57.965]                       invokeRestart <- base::invokeRestart
[13:19:57.965]                       is.null <- base::is.null
[13:19:57.965]                       muffled <- FALSE
[13:19:57.965]                       if (inherits(cond, "message")) {
[13:19:57.965]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.965]                         if (muffled) 
[13:19:57.965]                           invokeRestart("muffleMessage")
[13:19:57.965]                       }
[13:19:57.965]                       else if (inherits(cond, "warning")) {
[13:19:57.965]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.965]                         if (muffled) 
[13:19:57.965]                           invokeRestart("muffleWarning")
[13:19:57.965]                       }
[13:19:57.965]                       else if (inherits(cond, "condition")) {
[13:19:57.965]                         if (!is.null(pattern)) {
[13:19:57.965]                           computeRestarts <- base::computeRestarts
[13:19:57.965]                           grepl <- base::grepl
[13:19:57.965]                           restarts <- computeRestarts(cond)
[13:19:57.965]                           for (restart in restarts) {
[13:19:57.965]                             name <- restart$name
[13:19:57.965]                             if (is.null(name)) 
[13:19:57.965]                               next
[13:19:57.965]                             if (!grepl(pattern, name)) 
[13:19:57.965]                               next
[13:19:57.965]                             invokeRestart(restart)
[13:19:57.965]                             muffled <- TRUE
[13:19:57.965]                             break
[13:19:57.965]                           }
[13:19:57.965]                         }
[13:19:57.965]                       }
[13:19:57.965]                       invisible(muffled)
[13:19:57.965]                     }
[13:19:57.965]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.965]                   }
[13:19:57.965]                 }
[13:19:57.965]                 else {
[13:19:57.965]                   if (TRUE) {
[13:19:57.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.965]                     {
[13:19:57.965]                       inherits <- base::inherits
[13:19:57.965]                       invokeRestart <- base::invokeRestart
[13:19:57.965]                       is.null <- base::is.null
[13:19:57.965]                       muffled <- FALSE
[13:19:57.965]                       if (inherits(cond, "message")) {
[13:19:57.965]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.965]                         if (muffled) 
[13:19:57.965]                           invokeRestart("muffleMessage")
[13:19:57.965]                       }
[13:19:57.965]                       else if (inherits(cond, "warning")) {
[13:19:57.965]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.965]                         if (muffled) 
[13:19:57.965]                           invokeRestart("muffleWarning")
[13:19:57.965]                       }
[13:19:57.965]                       else if (inherits(cond, "condition")) {
[13:19:57.965]                         if (!is.null(pattern)) {
[13:19:57.965]                           computeRestarts <- base::computeRestarts
[13:19:57.965]                           grepl <- base::grepl
[13:19:57.965]                           restarts <- computeRestarts(cond)
[13:19:57.965]                           for (restart in restarts) {
[13:19:57.965]                             name <- restart$name
[13:19:57.965]                             if (is.null(name)) 
[13:19:57.965]                               next
[13:19:57.965]                             if (!grepl(pattern, name)) 
[13:19:57.965]                               next
[13:19:57.965]                             invokeRestart(restart)
[13:19:57.965]                             muffled <- TRUE
[13:19:57.965]                             break
[13:19:57.965]                           }
[13:19:57.965]                         }
[13:19:57.965]                       }
[13:19:57.965]                       invisible(muffled)
[13:19:57.965]                     }
[13:19:57.965]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.965]                   }
[13:19:57.965]                 }
[13:19:57.965]             }
[13:19:57.965]         }))
[13:19:57.965]     }, error = function(ex) {
[13:19:57.965]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.965]                 ...future.rng), started = ...future.startTime, 
[13:19:57.965]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.965]             version = "1.8"), class = "FutureResult")
[13:19:57.965]     }, finally = {
[13:19:57.965]         if (!identical(...future.workdir, getwd())) 
[13:19:57.965]             setwd(...future.workdir)
[13:19:57.965]         {
[13:19:57.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.965]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.965]             }
[13:19:57.965]             base::options(...future.oldOptions)
[13:19:57.965]             if (.Platform$OS.type == "windows") {
[13:19:57.965]                 old_names <- names(...future.oldEnvVars)
[13:19:57.965]                 envs <- base::Sys.getenv()
[13:19:57.965]                 names <- names(envs)
[13:19:57.965]                 common <- intersect(names, old_names)
[13:19:57.965]                 added <- setdiff(names, old_names)
[13:19:57.965]                 removed <- setdiff(old_names, names)
[13:19:57.965]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.965]                   envs[common]]
[13:19:57.965]                 NAMES <- toupper(changed)
[13:19:57.965]                 args <- list()
[13:19:57.965]                 for (kk in seq_along(NAMES)) {
[13:19:57.965]                   name <- changed[[kk]]
[13:19:57.965]                   NAME <- NAMES[[kk]]
[13:19:57.965]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.965]                     next
[13:19:57.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.965]                 }
[13:19:57.965]                 NAMES <- toupper(added)
[13:19:57.965]                 for (kk in seq_along(NAMES)) {
[13:19:57.965]                   name <- added[[kk]]
[13:19:57.965]                   NAME <- NAMES[[kk]]
[13:19:57.965]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.965]                     next
[13:19:57.965]                   args[[name]] <- ""
[13:19:57.965]                 }
[13:19:57.965]                 NAMES <- toupper(removed)
[13:19:57.965]                 for (kk in seq_along(NAMES)) {
[13:19:57.965]                   name <- removed[[kk]]
[13:19:57.965]                   NAME <- NAMES[[kk]]
[13:19:57.965]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.965]                     next
[13:19:57.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.965]                 }
[13:19:57.965]                 if (length(args) > 0) 
[13:19:57.965]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.965]             }
[13:19:57.965]             else {
[13:19:57.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.965]             }
[13:19:57.965]             {
[13:19:57.965]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.965]                   0L) {
[13:19:57.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.965]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.965]                   base::options(opts)
[13:19:57.965]                 }
[13:19:57.965]                 {
[13:19:57.965]                   {
[13:19:57.965]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.965]                     NULL
[13:19:57.965]                   }
[13:19:57.965]                   options(future.plan = NULL)
[13:19:57.965]                   if (is.na(NA_character_)) 
[13:19:57.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.965]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.965]                     envir = parent.frame()) 
[13:19:57.965]                   {
[13:19:57.965]                     default_workers <- missing(workers)
[13:19:57.965]                     if (is.function(workers)) 
[13:19:57.965]                       workers <- workers()
[13:19:57.965]                     workers <- structure(as.integer(workers), 
[13:19:57.965]                       class = class(workers))
[13:19:57.965]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.965]                       1L)
[13:19:57.965]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.965]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.965]                       if (default_workers) 
[13:19:57.965]                         supportsMulticore(warn = TRUE)
[13:19:57.965]                       return(sequential(..., envir = envir))
[13:19:57.965]                     }
[13:19:57.965]                     oopts <- options(mc.cores = workers)
[13:19:57.965]                     on.exit(options(oopts))
[13:19:57.965]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.965]                       envir = envir)
[13:19:57.965]                     if (!future$lazy) 
[13:19:57.965]                       future <- run(future)
[13:19:57.965]                     invisible(future)
[13:19:57.965]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.965]                 }
[13:19:57.965]             }
[13:19:57.965]         }
[13:19:57.965]     })
[13:19:57.965]     if (TRUE) {
[13:19:57.965]         base::sink(type = "output", split = FALSE)
[13:19:57.965]         if (TRUE) {
[13:19:57.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.965]         }
[13:19:57.965]         else {
[13:19:57.965]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.965]         }
[13:19:57.965]         base::close(...future.stdout)
[13:19:57.965]         ...future.stdout <- NULL
[13:19:57.965]     }
[13:19:57.965]     ...future.result$conditions <- ...future.conditions
[13:19:57.965]     ...future.result$finished <- base::Sys.time()
[13:19:57.965]     ...future.result
[13:19:57.965] }
[13:19:57.968] assign_globals() ...
[13:19:57.968] List of 5
[13:19:57.968]  $ future.call.arguments    : list()
[13:19:57.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:57.968]  $ ...future.FUN            :function (x)  
[13:19:57.968]  $ ...future.elements_ii    :List of 3
[13:19:57.968]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:19:57.968]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:19:57.968]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:19:57.968]  $ ...future.seeds_ii       : NULL
[13:19:57.968]  $ ...future.globals.maxSize: num Inf
[13:19:57.968]  - attr(*, "resolved")= logi FALSE
[13:19:57.968]  - attr(*, "total_size")= num NA
[13:19:57.968]  - attr(*, "where")=List of 5
[13:19:57.968]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:57.968]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:57.968]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:57.968]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:57.968]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:57.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.968]  - attr(*, "already-done")= logi TRUE
[13:19:57.977] - copied ‘future.call.arguments’ to environment
[13:19:57.977] - copied ‘...future.FUN’ to environment
[13:19:57.977] - copied ‘...future.elements_ii’ to environment
[13:19:57.977] - copied ‘...future.seeds_ii’ to environment
[13:19:57.977] - copied ‘...future.globals.maxSize’ to environment
[13:19:57.978] assign_globals() ... done
[13:19:57.978] requestCore(): workers = 2
[13:19:57.980] MulticoreFuture started
[13:19:57.981] - Launch lazy future ... done
[13:19:57.981] run() for ‘MulticoreFuture’ ... done
[13:19:57.981] Created future:
[13:19:57.981] plan(): Setting new future strategy stack:
[13:19:57.982] List of future strategies:
[13:19:57.982] 1. sequential:
[13:19:57.982]    - args: function (..., envir = parent.frame())
[13:19:57.982]    - tweaked: FALSE
[13:19:57.982]    - call: NULL
[13:19:57.982] plan(): nbrOfWorkers() = 1
[13:19:57.984] plan(): Setting new future strategy stack:
[13:19:57.985] List of future strategies:
[13:19:57.985] 1. multicore:
[13:19:57.985]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.985]    - tweaked: FALSE
[13:19:57.985]    - call: plan(strategy)
[13:19:57.990] plan(): nbrOfWorkers() = 2
[13:19:57.981] MulticoreFuture:
[13:19:57.981] Label: ‘future_apply-2’
[13:19:57.981] Expression:
[13:19:57.981] {
[13:19:57.981]     do.call(function(...) {
[13:19:57.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:57.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:57.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:57.981]             on.exit(options(oopts), add = TRUE)
[13:19:57.981]         }
[13:19:57.981]         {
[13:19:57.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:57.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:57.981]                 ...future.FUN(...future.X_jj, ...)
[13:19:57.981]             })
[13:19:57.981]         }
[13:19:57.981]     }, args = future.call.arguments)
[13:19:57.981] }
[13:19:57.981] Lazy evaluation: FALSE
[13:19:57.981] Asynchronous evaluation: TRUE
[13:19:57.981] Local evaluation: TRUE
[13:19:57.981] Environment: R_GlobalEnv
[13:19:57.981] Capture standard output: TRUE
[13:19:57.981] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:57.981] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:57.981] Packages: <none>
[13:19:57.981] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:57.981] Resolved: TRUE
[13:19:57.981] Value: <not collected>
[13:19:57.981] Conditions captured: <none>
[13:19:57.981] Early signaling: FALSE
[13:19:57.981] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:57.981] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.991] Chunk #2 of 2 ... DONE
[13:19:57.992] Launching 2 futures (chunks) ... DONE
[13:19:57.992] Resolving 2 futures (chunks) ...
[13:19:57.992] resolve() on list ...
[13:19:57.992]  recursive: 0
[13:19:57.992]  length: 2
[13:19:57.992] 
[13:19:57.993] Future #1
[13:19:57.993] result() for MulticoreFuture ...
[13:19:57.994] result() for MulticoreFuture ...
[13:19:57.994] result() for MulticoreFuture ... done
[13:19:57.994] result() for MulticoreFuture ... done
[13:19:57.994] result() for MulticoreFuture ...
[13:19:57.995] result() for MulticoreFuture ... done
[13:19:57.995] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:57.995] - nx: 2
[13:19:57.995] - relay: TRUE
[13:19:57.995] - stdout: TRUE
[13:19:57.995] - signal: TRUE
[13:19:57.995] - resignal: FALSE
[13:19:57.996] - force: TRUE
[13:19:57.996] - relayed: [n=2] FALSE, FALSE
[13:19:57.996] - queued futures: [n=2] FALSE, FALSE
[13:19:57.996]  - until=1
[13:19:57.996]  - relaying element #1
[13:19:57.997] result() for MulticoreFuture ...
[13:19:57.997] result() for MulticoreFuture ... done
[13:19:57.997] result() for MulticoreFuture ...
[13:19:57.997] result() for MulticoreFuture ... done
[13:19:57.997] result() for MulticoreFuture ...
[13:19:57.997] result() for MulticoreFuture ... done
[13:19:57.998] result() for MulticoreFuture ...
[13:19:57.998] result() for MulticoreFuture ... done
[13:19:57.998] - relayed: [n=2] TRUE, FALSE
[13:19:57.998] - queued futures: [n=2] TRUE, FALSE
[13:19:57.998] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:57.998]  length: 1 (resolved future 1)
[13:19:57.999] Future #2
[13:19:57.999] result() for MulticoreFuture ...
[13:19:57.999] result() for MulticoreFuture ...
[13:19:58.000] result() for MulticoreFuture ... done
[13:19:58.000] result() for MulticoreFuture ... done
[13:19:58.000] result() for MulticoreFuture ...
[13:19:58.000] result() for MulticoreFuture ... done
[13:19:58.000] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:58.000] - nx: 2
[13:19:58.000] - relay: TRUE
[13:19:58.001] - stdout: TRUE
[13:19:58.001] - signal: TRUE
[13:19:58.001] - resignal: FALSE
[13:19:58.001] - force: TRUE
[13:19:58.001] - relayed: [n=2] TRUE, FALSE
[13:19:58.001] - queued futures: [n=2] TRUE, FALSE
[13:19:58.001]  - until=2
[13:19:58.002]  - relaying element #2
[13:19:58.002] result() for MulticoreFuture ...
[13:19:58.002] result() for MulticoreFuture ... done
[13:19:58.002] result() for MulticoreFuture ...
[13:19:58.002] result() for MulticoreFuture ... done
[13:19:58.002] result() for MulticoreFuture ...
[13:19:58.002] result() for MulticoreFuture ... done
[13:19:58.002] result() for MulticoreFuture ...
[13:19:58.003] result() for MulticoreFuture ... done
[13:19:58.003] - relayed: [n=2] TRUE, TRUE
[13:19:58.003] - queued futures: [n=2] TRUE, TRUE
[13:19:58.003] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:58.003]  length: 0 (resolved future 2)
[13:19:58.003] Relaying remaining futures
[13:19:58.003] signalConditionsASAP(NULL, pos=0) ...
[13:19:58.003] - nx: 2
[13:19:58.003] - relay: TRUE
[13:19:58.003] - stdout: TRUE
[13:19:58.004] - signal: TRUE
[13:19:58.004] - resignal: FALSE
[13:19:58.004] - force: TRUE
[13:19:58.004] - relayed: [n=2] TRUE, TRUE
[13:19:58.004] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:58.004] - relayed: [n=2] TRUE, TRUE
[13:19:58.004] - queued futures: [n=2] TRUE, TRUE
[13:19:58.004] signalConditionsASAP(NULL, pos=0) ... done
[13:19:58.005] resolve() on list ... DONE
[13:19:58.005] result() for MulticoreFuture ...
[13:19:58.007] result() for MulticoreFuture ... done
[13:19:58.007] result() for MulticoreFuture ...
[13:19:58.008] result() for MulticoreFuture ... done
[13:19:58.008] result() for MulticoreFuture ...
[13:19:58.008] result() for MulticoreFuture ... done
[13:19:58.008] result() for MulticoreFuture ...
[13:19:58.008] result() for MulticoreFuture ... done
[13:19:58.009]  - Number of value chunks collected: 2
[13:19:58.009] Resolving 2 futures (chunks) ... DONE
[13:19:58.009] Reducing values from 2 chunks ...
[13:19:58.009]  - Number of values collected after concatenation: 6
[13:19:58.009]  - Number of values expected: 6
[13:19:58.009] Reducing values from 2 chunks ... DONE
[13:19:58.009] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[13:19:58.010] getGlobalsAndPackagesXApply() ...
[13:19:58.010]  - future.globals: TRUE
[13:19:58.010] getGlobalsAndPackages() ...
[13:19:58.011] Searching for globals...
[13:19:58.013] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[13:19:58.013] Searching for globals ... DONE
[13:19:58.013] Resolving globals: FALSE
[13:19:58.014] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[13:19:58.014] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[13:19:58.014] - globals: [1] ‘FUN’
[13:19:58.014] 
[13:19:58.014] getGlobalsAndPackages() ... DONE
[13:19:58.014]  - globals found/used: [n=1] ‘FUN’
[13:19:58.015]  - needed namespaces: [n=0] 
[13:19:58.015] Finding globals ... DONE
[13:19:58.015]  - use_args: TRUE
[13:19:58.015]  - Getting '...' globals ...
[13:19:58.015] resolve() on list ...
[13:19:58.015]  recursive: 0
[13:19:58.016]  length: 1
[13:19:58.016]  elements: ‘...’
[13:19:58.016]  length: 0 (resolved future 1)
[13:19:58.016] resolve() on list ... DONE
[13:19:58.016]    - '...' content: [n=0] 
[13:19:58.016] List of 1
[13:19:58.016]  $ ...: list()
[13:19:58.016]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.016]  - attr(*, "where")=List of 1
[13:19:58.016]   ..$ ...:<environment: 0x555922ca1920> 
[13:19:58.016]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.016]  - attr(*, "resolved")= logi TRUE
[13:19:58.016]  - attr(*, "total_size")= num NA
[13:19:58.019]  - Getting '...' globals ... DONE
[13:19:58.020] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:58.020] List of 2
[13:19:58.020]  $ ...future.FUN:function (x)  
[13:19:58.020]  $ ...          : list()
[13:19:58.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.020]  - attr(*, "where")=List of 2
[13:19:58.020]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:58.020]   ..$ ...          :<environment: 0x555922ca1920> 
[13:19:58.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.020]  - attr(*, "resolved")= logi FALSE
[13:19:58.020]  - attr(*, "total_size")= num 1768
[13:19:58.023] Packages to be attached in all futures: [n=0] 
[13:19:58.023] getGlobalsAndPackagesXApply() ... DONE
[13:19:58.027] future_lapply() ...
[13:19:58.031] Number of chunks: 2
[13:19:58.031] getGlobalsAndPackagesXApply() ...
[13:19:58.031]  - future.globals: <name-value list> with names ‘list()’
[13:19:58.031]  - use_args: TRUE
[13:19:58.032] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:58.032] List of 2
[13:19:58.032]  $ ...          : list()
[13:19:58.032]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.032]  $ ...future.FUN:function (x)  
[13:19:58.032]  - attr(*, "where")=List of 2
[13:19:58.032]   ..$ ...          :<environment: 0x555922ca1920> 
[13:19:58.032]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:19:58.032]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.032]  - attr(*, "resolved")= logi FALSE
[13:19:58.032]  - attr(*, "total_size")= num NA
[13:19:58.035] Packages to be attached in all futures: [n=0] 
[13:19:58.035] getGlobalsAndPackagesXApply() ... DONE
[13:19:58.035] Number of futures (= number of chunks): 2
[13:19:58.035] Launching 2 futures (chunks) ...
[13:19:58.035] Chunk #1 of 2 ...
[13:19:58.035]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:58.035]  - seeds: <none>
[13:19:58.035]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.036] getGlobalsAndPackages() ...
[13:19:58.036] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.036] Resolving globals: FALSE
[13:19:58.036] Tweak future expression to call with '...' arguments ...
[13:19:58.036] {
[13:19:58.036]     do.call(function(...) {
[13:19:58.036]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.036]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.036]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.036]             on.exit(options(oopts), add = TRUE)
[13:19:58.036]         }
[13:19:58.036]         {
[13:19:58.036]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.036]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.036]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.036]             })
[13:19:58.036]         }
[13:19:58.036]     }, args = future.call.arguments)
[13:19:58.036] }
[13:19:58.036] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.039] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.039] 
[13:19:58.039] getGlobalsAndPackages() ... DONE
[13:19:58.039] run() for ‘Future’ ...
[13:19:58.039] - state: ‘created’
[13:19:58.040] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.043] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:58.044]   - Field: ‘label’
[13:19:58.044]   - Field: ‘local’
[13:19:58.044]   - Field: ‘owner’
[13:19:58.044]   - Field: ‘envir’
[13:19:58.044]   - Field: ‘workers’
[13:19:58.044]   - Field: ‘packages’
[13:19:58.045]   - Field: ‘gc’
[13:19:58.045]   - Field: ‘job’
[13:19:58.045]   - Field: ‘conditions’
[13:19:58.045]   - Field: ‘expr’
[13:19:58.045]   - Field: ‘uuid’
[13:19:58.045]   - Field: ‘seed’
[13:19:58.045]   - Field: ‘version’
[13:19:58.045]   - Field: ‘result’
[13:19:58.045]   - Field: ‘asynchronous’
[13:19:58.045]   - Field: ‘calls’
[13:19:58.046]   - Field: ‘globals’
[13:19:58.046]   - Field: ‘stdout’
[13:19:58.046]   - Field: ‘earlySignal’
[13:19:58.046]   - Field: ‘lazy’
[13:19:58.046]   - Field: ‘state’
[13:19:58.046] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:58.046] - Launch lazy future ...
[13:19:58.046] Packages needed by the future expression (n = 0): <none>
[13:19:58.046] Packages needed by future strategies (n = 0): <none>
[13:19:58.047] {
[13:19:58.047]     {
[13:19:58.047]         {
[13:19:58.047]             ...future.startTime <- base::Sys.time()
[13:19:58.047]             {
[13:19:58.047]                 {
[13:19:58.047]                   {
[13:19:58.047]                     {
[13:19:58.047]                       base::local({
[13:19:58.047]                         has_future <- base::requireNamespace("future", 
[13:19:58.047]                           quietly = TRUE)
[13:19:58.047]                         if (has_future) {
[13:19:58.047]                           ns <- base::getNamespace("future")
[13:19:58.047]                           version <- ns[[".package"]][["version"]]
[13:19:58.047]                           if (is.null(version)) 
[13:19:58.047]                             version <- utils::packageVersion("future")
[13:19:58.047]                         }
[13:19:58.047]                         else {
[13:19:58.047]                           version <- NULL
[13:19:58.047]                         }
[13:19:58.047]                         if (!has_future || version < "1.8.0") {
[13:19:58.047]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.047]                             "", base::R.version$version.string), 
[13:19:58.047]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:58.047]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.047]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.047]                               "release", "version")], collapse = " "), 
[13:19:58.047]                             hostname = base::Sys.info()[["nodename"]])
[13:19:58.047]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.047]                             info)
[13:19:58.047]                           info <- base::paste(info, collapse = "; ")
[13:19:58.047]                           if (!has_future) {
[13:19:58.047]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.047]                               info)
[13:19:58.047]                           }
[13:19:58.047]                           else {
[13:19:58.047]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.047]                               info, version)
[13:19:58.047]                           }
[13:19:58.047]                           base::stop(msg)
[13:19:58.047]                         }
[13:19:58.047]                       })
[13:19:58.047]                     }
[13:19:58.047]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.047]                     base::options(mc.cores = 1L)
[13:19:58.047]                   }
[13:19:58.047]                   options(future.plan = NULL)
[13:19:58.047]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.047]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.047]                 }
[13:19:58.047]                 ...future.workdir <- getwd()
[13:19:58.047]             }
[13:19:58.047]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.047]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.047]         }
[13:19:58.047]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.047]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:58.047]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.047]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.047]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.047]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.047]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.047]             base::names(...future.oldOptions))
[13:19:58.047]     }
[13:19:58.047]     if (FALSE) {
[13:19:58.047]     }
[13:19:58.047]     else {
[13:19:58.047]         if (TRUE) {
[13:19:58.047]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.047]                 open = "w")
[13:19:58.047]         }
[13:19:58.047]         else {
[13:19:58.047]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.047]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.047]         }
[13:19:58.047]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.047]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.047]             base::sink(type = "output", split = FALSE)
[13:19:58.047]             base::close(...future.stdout)
[13:19:58.047]         }, add = TRUE)
[13:19:58.047]     }
[13:19:58.047]     ...future.frame <- base::sys.nframe()
[13:19:58.047]     ...future.conditions <- base::list()
[13:19:58.047]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.047]     if (FALSE) {
[13:19:58.047]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.047]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.047]     }
[13:19:58.047]     ...future.result <- base::tryCatch({
[13:19:58.047]         base::withCallingHandlers({
[13:19:58.047]             ...future.value <- base::withVisible(base::local({
[13:19:58.047]                 withCallingHandlers({
[13:19:58.047]                   {
[13:19:58.047]                     do.call(function(...) {
[13:19:58.047]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.047]                       if (!identical(...future.globals.maxSize.org, 
[13:19:58.047]                         ...future.globals.maxSize)) {
[13:19:58.047]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.047]                         on.exit(options(oopts), add = TRUE)
[13:19:58.047]                       }
[13:19:58.047]                       {
[13:19:58.047]                         lapply(seq_along(...future.elements_ii), 
[13:19:58.047]                           FUN = function(jj) {
[13:19:58.047]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.047]                             ...future.FUN(...future.X_jj, ...)
[13:19:58.047]                           })
[13:19:58.047]                       }
[13:19:58.047]                     }, args = future.call.arguments)
[13:19:58.047]                   }
[13:19:58.047]                 }, immediateCondition = function(cond) {
[13:19:58.047]                   save_rds <- function (object, pathname, ...) 
[13:19:58.047]                   {
[13:19:58.047]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:58.047]                     if (file_test("-f", pathname_tmp)) {
[13:19:58.047]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.047]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:58.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.047]                         fi_tmp[["mtime"]])
[13:19:58.047]                     }
[13:19:58.047]                     tryCatch({
[13:19:58.047]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:58.047]                     }, error = function(ex) {
[13:19:58.047]                       msg <- conditionMessage(ex)
[13:19:58.047]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.047]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:58.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.047]                         fi_tmp[["mtime"]], msg)
[13:19:58.047]                       ex$message <- msg
[13:19:58.047]                       stop(ex)
[13:19:58.047]                     })
[13:19:58.047]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:58.047]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:58.047]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:58.047]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.047]                       fi <- file.info(pathname)
[13:19:58.047]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:58.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.047]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:58.047]                         fi[["size"]], fi[["mtime"]])
[13:19:58.047]                       stop(msg)
[13:19:58.047]                     }
[13:19:58.047]                     invisible(pathname)
[13:19:58.047]                   }
[13:19:58.047]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:58.047]                     rootPath = tempdir()) 
[13:19:58.047]                   {
[13:19:58.047]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:58.047]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:58.047]                       tmpdir = path, fileext = ".rds")
[13:19:58.047]                     save_rds(obj, file)
[13:19:58.047]                   }
[13:19:58.047]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:58.047]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.047]                   {
[13:19:58.047]                     inherits <- base::inherits
[13:19:58.047]                     invokeRestart <- base::invokeRestart
[13:19:58.047]                     is.null <- base::is.null
[13:19:58.047]                     muffled <- FALSE
[13:19:58.047]                     if (inherits(cond, "message")) {
[13:19:58.047]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.047]                       if (muffled) 
[13:19:58.047]                         invokeRestart("muffleMessage")
[13:19:58.047]                     }
[13:19:58.047]                     else if (inherits(cond, "warning")) {
[13:19:58.047]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.047]                       if (muffled) 
[13:19:58.047]                         invokeRestart("muffleWarning")
[13:19:58.047]                     }
[13:19:58.047]                     else if (inherits(cond, "condition")) {
[13:19:58.047]                       if (!is.null(pattern)) {
[13:19:58.047]                         computeRestarts <- base::computeRestarts
[13:19:58.047]                         grepl <- base::grepl
[13:19:58.047]                         restarts <- computeRestarts(cond)
[13:19:58.047]                         for (restart in restarts) {
[13:19:58.047]                           name <- restart$name
[13:19:58.047]                           if (is.null(name)) 
[13:19:58.047]                             next
[13:19:58.047]                           if (!grepl(pattern, name)) 
[13:19:58.047]                             next
[13:19:58.047]                           invokeRestart(restart)
[13:19:58.047]                           muffled <- TRUE
[13:19:58.047]                           break
[13:19:58.047]                         }
[13:19:58.047]                       }
[13:19:58.047]                     }
[13:19:58.047]                     invisible(muffled)
[13:19:58.047]                   }
[13:19:58.047]                   muffleCondition(cond)
[13:19:58.047]                 })
[13:19:58.047]             }))
[13:19:58.047]             future::FutureResult(value = ...future.value$value, 
[13:19:58.047]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.047]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.047]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.047]                     ...future.globalenv.names))
[13:19:58.047]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.047]         }, condition = base::local({
[13:19:58.047]             c <- base::c
[13:19:58.047]             inherits <- base::inherits
[13:19:58.047]             invokeRestart <- base::invokeRestart
[13:19:58.047]             length <- base::length
[13:19:58.047]             list <- base::list
[13:19:58.047]             seq.int <- base::seq.int
[13:19:58.047]             signalCondition <- base::signalCondition
[13:19:58.047]             sys.calls <- base::sys.calls
[13:19:58.047]             `[[` <- base::`[[`
[13:19:58.047]             `+` <- base::`+`
[13:19:58.047]             `<<-` <- base::`<<-`
[13:19:58.047]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.047]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.047]                   3L)]
[13:19:58.047]             }
[13:19:58.047]             function(cond) {
[13:19:58.047]                 is_error <- inherits(cond, "error")
[13:19:58.047]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.047]                   NULL)
[13:19:58.047]                 if (is_error) {
[13:19:58.047]                   sessionInformation <- function() {
[13:19:58.047]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.047]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.047]                       search = base::search(), system = base::Sys.info())
[13:19:58.047]                   }
[13:19:58.047]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.047]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.047]                     cond$call), session = sessionInformation(), 
[13:19:58.047]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.047]                   signalCondition(cond)
[13:19:58.047]                 }
[13:19:58.047]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.047]                 "immediateCondition"))) {
[13:19:58.047]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.047]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.047]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.047]                   if (TRUE && !signal) {
[13:19:58.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.047]                     {
[13:19:58.047]                       inherits <- base::inherits
[13:19:58.047]                       invokeRestart <- base::invokeRestart
[13:19:58.047]                       is.null <- base::is.null
[13:19:58.047]                       muffled <- FALSE
[13:19:58.047]                       if (inherits(cond, "message")) {
[13:19:58.047]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.047]                         if (muffled) 
[13:19:58.047]                           invokeRestart("muffleMessage")
[13:19:58.047]                       }
[13:19:58.047]                       else if (inherits(cond, "warning")) {
[13:19:58.047]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.047]                         if (muffled) 
[13:19:58.047]                           invokeRestart("muffleWarning")
[13:19:58.047]                       }
[13:19:58.047]                       else if (inherits(cond, "condition")) {
[13:19:58.047]                         if (!is.null(pattern)) {
[13:19:58.047]                           computeRestarts <- base::computeRestarts
[13:19:58.047]                           grepl <- base::grepl
[13:19:58.047]                           restarts <- computeRestarts(cond)
[13:19:58.047]                           for (restart in restarts) {
[13:19:58.047]                             name <- restart$name
[13:19:58.047]                             if (is.null(name)) 
[13:19:58.047]                               next
[13:19:58.047]                             if (!grepl(pattern, name)) 
[13:19:58.047]                               next
[13:19:58.047]                             invokeRestart(restart)
[13:19:58.047]                             muffled <- TRUE
[13:19:58.047]                             break
[13:19:58.047]                           }
[13:19:58.047]                         }
[13:19:58.047]                       }
[13:19:58.047]                       invisible(muffled)
[13:19:58.047]                     }
[13:19:58.047]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.047]                   }
[13:19:58.047]                 }
[13:19:58.047]                 else {
[13:19:58.047]                   if (TRUE) {
[13:19:58.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.047]                     {
[13:19:58.047]                       inherits <- base::inherits
[13:19:58.047]                       invokeRestart <- base::invokeRestart
[13:19:58.047]                       is.null <- base::is.null
[13:19:58.047]                       muffled <- FALSE
[13:19:58.047]                       if (inherits(cond, "message")) {
[13:19:58.047]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.047]                         if (muffled) 
[13:19:58.047]                           invokeRestart("muffleMessage")
[13:19:58.047]                       }
[13:19:58.047]                       else if (inherits(cond, "warning")) {
[13:19:58.047]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.047]                         if (muffled) 
[13:19:58.047]                           invokeRestart("muffleWarning")
[13:19:58.047]                       }
[13:19:58.047]                       else if (inherits(cond, "condition")) {
[13:19:58.047]                         if (!is.null(pattern)) {
[13:19:58.047]                           computeRestarts <- base::computeRestarts
[13:19:58.047]                           grepl <- base::grepl
[13:19:58.047]                           restarts <- computeRestarts(cond)
[13:19:58.047]                           for (restart in restarts) {
[13:19:58.047]                             name <- restart$name
[13:19:58.047]                             if (is.null(name)) 
[13:19:58.047]                               next
[13:19:58.047]                             if (!grepl(pattern, name)) 
[13:19:58.047]                               next
[13:19:58.047]                             invokeRestart(restart)
[13:19:58.047]                             muffled <- TRUE
[13:19:58.047]                             break
[13:19:58.047]                           }
[13:19:58.047]                         }
[13:19:58.047]                       }
[13:19:58.047]                       invisible(muffled)
[13:19:58.047]                     }
[13:19:58.047]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.047]                   }
[13:19:58.047]                 }
[13:19:58.047]             }
[13:19:58.047]         }))
[13:19:58.047]     }, error = function(ex) {
[13:19:58.047]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.047]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.047]                 ...future.rng), started = ...future.startTime, 
[13:19:58.047]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.047]             version = "1.8"), class = "FutureResult")
[13:19:58.047]     }, finally = {
[13:19:58.047]         if (!identical(...future.workdir, getwd())) 
[13:19:58.047]             setwd(...future.workdir)
[13:19:58.047]         {
[13:19:58.047]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.047]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.047]             }
[13:19:58.047]             base::options(...future.oldOptions)
[13:19:58.047]             if (.Platform$OS.type == "windows") {
[13:19:58.047]                 old_names <- names(...future.oldEnvVars)
[13:19:58.047]                 envs <- base::Sys.getenv()
[13:19:58.047]                 names <- names(envs)
[13:19:58.047]                 common <- intersect(names, old_names)
[13:19:58.047]                 added <- setdiff(names, old_names)
[13:19:58.047]                 removed <- setdiff(old_names, names)
[13:19:58.047]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.047]                   envs[common]]
[13:19:58.047]                 NAMES <- toupper(changed)
[13:19:58.047]                 args <- list()
[13:19:58.047]                 for (kk in seq_along(NAMES)) {
[13:19:58.047]                   name <- changed[[kk]]
[13:19:58.047]                   NAME <- NAMES[[kk]]
[13:19:58.047]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.047]                     next
[13:19:58.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.047]                 }
[13:19:58.047]                 NAMES <- toupper(added)
[13:19:58.047]                 for (kk in seq_along(NAMES)) {
[13:19:58.047]                   name <- added[[kk]]
[13:19:58.047]                   NAME <- NAMES[[kk]]
[13:19:58.047]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.047]                     next
[13:19:58.047]                   args[[name]] <- ""
[13:19:58.047]                 }
[13:19:58.047]                 NAMES <- toupper(removed)
[13:19:58.047]                 for (kk in seq_along(NAMES)) {
[13:19:58.047]                   name <- removed[[kk]]
[13:19:58.047]                   NAME <- NAMES[[kk]]
[13:19:58.047]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.047]                     next
[13:19:58.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.047]                 }
[13:19:58.047]                 if (length(args) > 0) 
[13:19:58.047]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.047]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.047]             }
[13:19:58.047]             else {
[13:19:58.047]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.047]             }
[13:19:58.047]             {
[13:19:58.047]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.047]                   0L) {
[13:19:58.047]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.047]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.047]                   base::options(opts)
[13:19:58.047]                 }
[13:19:58.047]                 {
[13:19:58.047]                   {
[13:19:58.047]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.047]                     NULL
[13:19:58.047]                   }
[13:19:58.047]                   options(future.plan = NULL)
[13:19:58.047]                   if (is.na(NA_character_)) 
[13:19:58.047]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.047]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.047]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:58.047]                     envir = parent.frame()) 
[13:19:58.047]                   {
[13:19:58.047]                     default_workers <- missing(workers)
[13:19:58.047]                     if (is.function(workers)) 
[13:19:58.047]                       workers <- workers()
[13:19:58.047]                     workers <- structure(as.integer(workers), 
[13:19:58.047]                       class = class(workers))
[13:19:58.047]                     stop_if_not(is.finite(workers), workers >= 
[13:19:58.047]                       1L)
[13:19:58.047]                     if ((workers == 1L && !inherits(workers, 
[13:19:58.047]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:58.047]                       if (default_workers) 
[13:19:58.047]                         supportsMulticore(warn = TRUE)
[13:19:58.047]                       return(sequential(..., envir = envir))
[13:19:58.047]                     }
[13:19:58.047]                     oopts <- options(mc.cores = workers)
[13:19:58.047]                     on.exit(options(oopts))
[13:19:58.047]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:58.047]                       envir = envir)
[13:19:58.047]                     if (!future$lazy) 
[13:19:58.047]                       future <- run(future)
[13:19:58.047]                     invisible(future)
[13:19:58.047]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.047]                 }
[13:19:58.047]             }
[13:19:58.047]         }
[13:19:58.047]     })
[13:19:58.047]     if (TRUE) {
[13:19:58.047]         base::sink(type = "output", split = FALSE)
[13:19:58.047]         if (TRUE) {
[13:19:58.047]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.047]         }
[13:19:58.047]         else {
[13:19:58.047]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.047]         }
[13:19:58.047]         base::close(...future.stdout)
[13:19:58.047]         ...future.stdout <- NULL
[13:19:58.047]     }
[13:19:58.047]     ...future.result$conditions <- ...future.conditions
[13:19:58.047]     ...future.result$finished <- base::Sys.time()
[13:19:58.047]     ...future.result
[13:19:58.047] }
[13:19:58.050] assign_globals() ...
[13:19:58.050] List of 5
[13:19:58.050]  $ future.call.arguments    : list()
[13:19:58.050]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.050]  $ ...future.FUN            :function (x)  
[13:19:58.050]  $ ...future.elements_ii    :List of 3
[13:19:58.050]   ..$ : int [1:4] 1 7 13 19
[13:19:58.050]   ..$ : int [1:4] 2 8 14 20
[13:19:58.050]   ..$ : int [1:4] 3 9 15 21
[13:19:58.050]  $ ...future.seeds_ii       : NULL
[13:19:58.050]  $ ...future.globals.maxSize: num Inf
[13:19:58.050]  - attr(*, "resolved")= logi FALSE
[13:19:58.050]  - attr(*, "total_size")= num NA
[13:19:58.050]  - attr(*, "where")=List of 5
[13:19:58.050]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:58.050]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:58.050]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:58.050]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:58.050]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:58.050]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.050]  - attr(*, "already-done")= logi TRUE
[13:19:58.055] - copied ‘future.call.arguments’ to environment
[13:19:58.055] - reassign environment for ‘...future.FUN’
[13:19:58.055] - copied ‘...future.FUN’ to environment
[13:19:58.055] - copied ‘...future.elements_ii’ to environment
[13:19:58.056] - copied ‘...future.seeds_ii’ to environment
[13:19:58.056] - copied ‘...future.globals.maxSize’ to environment
[13:19:58.056] assign_globals() ... done
[13:19:58.056] requestCore(): workers = 2
[13:19:58.058] MulticoreFuture started
[13:19:58.059] - Launch lazy future ... done
[13:19:58.059] run() for ‘MulticoreFuture’ ... done
[13:19:58.059] Created future:
[13:19:58.059] plan(): Setting new future strategy stack:
[13:19:58.060] List of future strategies:
[13:19:58.060] 1. sequential:
[13:19:58.060]    - args: function (..., envir = parent.frame())
[13:19:58.060]    - tweaked: FALSE
[13:19:58.060]    - call: NULL
[13:19:58.061] plan(): nbrOfWorkers() = 1
[13:19:58.063] plan(): Setting new future strategy stack:
[13:19:58.063] List of future strategies:
[13:19:58.063] 1. multicore:
[13:19:58.063]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:58.063]    - tweaked: FALSE
[13:19:58.063]    - call: plan(strategy)
[13:19:58.068] plan(): nbrOfWorkers() = 2
[13:19:58.059] MulticoreFuture:
[13:19:58.059] Label: ‘future_apply-1’
[13:19:58.059] Expression:
[13:19:58.059] {
[13:19:58.059]     do.call(function(...) {
[13:19:58.059]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.059]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.059]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.059]             on.exit(options(oopts), add = TRUE)
[13:19:58.059]         }
[13:19:58.059]         {
[13:19:58.059]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.059]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.059]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.059]             })
[13:19:58.059]         }
[13:19:58.059]     }, args = future.call.arguments)
[13:19:58.059] }
[13:19:58.059] Lazy evaluation: FALSE
[13:19:58.059] Asynchronous evaluation: TRUE
[13:19:58.059] Local evaluation: TRUE
[13:19:58.059] Environment: R_GlobalEnv
[13:19:58.059] Capture standard output: TRUE
[13:19:58.059] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:58.059] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:58.059] Packages: <none>
[13:19:58.059] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:58.059] Resolved: TRUE
[13:19:58.059] Value: <not collected>
[13:19:58.059] Conditions captured: <none>
[13:19:58.059] Early signaling: FALSE
[13:19:58.059] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:58.059] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.069] Chunk #1 of 2 ... DONE
[13:19:58.069] Chunk #2 of 2 ...
[13:19:58.070]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:58.070]  - seeds: <none>
[13:19:58.070]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.070] getGlobalsAndPackages() ...
[13:19:58.070] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.071] Resolving globals: FALSE
[13:19:58.071] Tweak future expression to call with '...' arguments ...
[13:19:58.071] {
[13:19:58.071]     do.call(function(...) {
[13:19:58.071]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.071]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.071]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.071]             on.exit(options(oopts), add = TRUE)
[13:19:58.071]         }
[13:19:58.071]         {
[13:19:58.071]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.071]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.071]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.071]             })
[13:19:58.071]         }
[13:19:58.071]     }, args = future.call.arguments)
[13:19:58.071] }
[13:19:58.071] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.072] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.072] 
[13:19:58.072] getGlobalsAndPackages() ... DONE
[13:19:58.073] run() for ‘Future’ ...
[13:19:58.073] - state: ‘created’
[13:19:58.073] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.078] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.078] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:58.078]   - Field: ‘label’
[13:19:58.078]   - Field: ‘local’
[13:19:58.079]   - Field: ‘owner’
[13:19:58.079]   - Field: ‘envir’
[13:19:58.079]   - Field: ‘workers’
[13:19:58.079]   - Field: ‘packages’
[13:19:58.079]   - Field: ‘gc’
[13:19:58.079]   - Field: ‘job’
[13:19:58.080]   - Field: ‘conditions’
[13:19:58.080]   - Field: ‘expr’
[13:19:58.080]   - Field: ‘uuid’
[13:19:58.080]   - Field: ‘seed’
[13:19:58.080]   - Field: ‘version’
[13:19:58.080]   - Field: ‘result’
[13:19:58.080]   - Field: ‘asynchronous’
[13:19:58.081]   - Field: ‘calls’
[13:19:58.081]   - Field: ‘globals’
[13:19:58.081]   - Field: ‘stdout’
[13:19:58.081]   - Field: ‘earlySignal’
[13:19:58.084]   - Field: ‘lazy’
[13:19:58.085]   - Field: ‘state’
[13:19:58.085] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:58.085] - Launch lazy future ...
[13:19:58.086] Packages needed by the future expression (n = 0): <none>
[13:19:58.087] Packages needed by future strategies (n = 0): <none>
[13:19:58.088] {
[13:19:58.088]     {
[13:19:58.088]         {
[13:19:58.088]             ...future.startTime <- base::Sys.time()
[13:19:58.088]             {
[13:19:58.088]                 {
[13:19:58.088]                   {
[13:19:58.088]                     {
[13:19:58.088]                       base::local({
[13:19:58.088]                         has_future <- base::requireNamespace("future", 
[13:19:58.088]                           quietly = TRUE)
[13:19:58.088]                         if (has_future) {
[13:19:58.088]                           ns <- base::getNamespace("future")
[13:19:58.088]                           version <- ns[[".package"]][["version"]]
[13:19:58.088]                           if (is.null(version)) 
[13:19:58.088]                             version <- utils::packageVersion("future")
[13:19:58.088]                         }
[13:19:58.088]                         else {
[13:19:58.088]                           version <- NULL
[13:19:58.088]                         }
[13:19:58.088]                         if (!has_future || version < "1.8.0") {
[13:19:58.088]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.088]                             "", base::R.version$version.string), 
[13:19:58.088]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:58.088]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.088]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.088]                               "release", "version")], collapse = " "), 
[13:19:58.088]                             hostname = base::Sys.info()[["nodename"]])
[13:19:58.088]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.088]                             info)
[13:19:58.088]                           info <- base::paste(info, collapse = "; ")
[13:19:58.088]                           if (!has_future) {
[13:19:58.088]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.088]                               info)
[13:19:58.088]                           }
[13:19:58.088]                           else {
[13:19:58.088]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.088]                               info, version)
[13:19:58.088]                           }
[13:19:58.088]                           base::stop(msg)
[13:19:58.088]                         }
[13:19:58.088]                       })
[13:19:58.088]                     }
[13:19:58.088]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.088]                     base::options(mc.cores = 1L)
[13:19:58.088]                   }
[13:19:58.088]                   options(future.plan = NULL)
[13:19:58.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.088]                 }
[13:19:58.088]                 ...future.workdir <- getwd()
[13:19:58.088]             }
[13:19:58.088]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.088]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.088]         }
[13:19:58.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.088]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:58.088]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.088]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.088]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.088]             base::names(...future.oldOptions))
[13:19:58.088]     }
[13:19:58.088]     if (FALSE) {
[13:19:58.088]     }
[13:19:58.088]     else {
[13:19:58.088]         if (TRUE) {
[13:19:58.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.088]                 open = "w")
[13:19:58.088]         }
[13:19:58.088]         else {
[13:19:58.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.088]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.088]         }
[13:19:58.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.088]             base::sink(type = "output", split = FALSE)
[13:19:58.088]             base::close(...future.stdout)
[13:19:58.088]         }, add = TRUE)
[13:19:58.088]     }
[13:19:58.088]     ...future.frame <- base::sys.nframe()
[13:19:58.088]     ...future.conditions <- base::list()
[13:19:58.088]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.088]     if (FALSE) {
[13:19:58.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.088]     }
[13:19:58.088]     ...future.result <- base::tryCatch({
[13:19:58.088]         base::withCallingHandlers({
[13:19:58.088]             ...future.value <- base::withVisible(base::local({
[13:19:58.088]                 withCallingHandlers({
[13:19:58.088]                   {
[13:19:58.088]                     do.call(function(...) {
[13:19:58.088]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.088]                       if (!identical(...future.globals.maxSize.org, 
[13:19:58.088]                         ...future.globals.maxSize)) {
[13:19:58.088]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.088]                         on.exit(options(oopts), add = TRUE)
[13:19:58.088]                       }
[13:19:58.088]                       {
[13:19:58.088]                         lapply(seq_along(...future.elements_ii), 
[13:19:58.088]                           FUN = function(jj) {
[13:19:58.088]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.088]                             ...future.FUN(...future.X_jj, ...)
[13:19:58.088]                           })
[13:19:58.088]                       }
[13:19:58.088]                     }, args = future.call.arguments)
[13:19:58.088]                   }
[13:19:58.088]                 }, immediateCondition = function(cond) {
[13:19:58.088]                   save_rds <- function (object, pathname, ...) 
[13:19:58.088]                   {
[13:19:58.088]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:58.088]                     if (file_test("-f", pathname_tmp)) {
[13:19:58.088]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.088]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:58.088]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.088]                         fi_tmp[["mtime"]])
[13:19:58.088]                     }
[13:19:58.088]                     tryCatch({
[13:19:58.088]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:58.088]                     }, error = function(ex) {
[13:19:58.088]                       msg <- conditionMessage(ex)
[13:19:58.088]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.088]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:58.088]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.088]                         fi_tmp[["mtime"]], msg)
[13:19:58.088]                       ex$message <- msg
[13:19:58.088]                       stop(ex)
[13:19:58.088]                     })
[13:19:58.088]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:58.088]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:58.088]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:58.088]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.088]                       fi <- file.info(pathname)
[13:19:58.088]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:58.088]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.088]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:58.088]                         fi[["size"]], fi[["mtime"]])
[13:19:58.088]                       stop(msg)
[13:19:58.088]                     }
[13:19:58.088]                     invisible(pathname)
[13:19:58.088]                   }
[13:19:58.088]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:58.088]                     rootPath = tempdir()) 
[13:19:58.088]                   {
[13:19:58.088]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:58.088]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:58.088]                       tmpdir = path, fileext = ".rds")
[13:19:58.088]                     save_rds(obj, file)
[13:19:58.088]                   }
[13:19:58.088]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:58.088]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.088]                   {
[13:19:58.088]                     inherits <- base::inherits
[13:19:58.088]                     invokeRestart <- base::invokeRestart
[13:19:58.088]                     is.null <- base::is.null
[13:19:58.088]                     muffled <- FALSE
[13:19:58.088]                     if (inherits(cond, "message")) {
[13:19:58.088]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.088]                       if (muffled) 
[13:19:58.088]                         invokeRestart("muffleMessage")
[13:19:58.088]                     }
[13:19:58.088]                     else if (inherits(cond, "warning")) {
[13:19:58.088]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.088]                       if (muffled) 
[13:19:58.088]                         invokeRestart("muffleWarning")
[13:19:58.088]                     }
[13:19:58.088]                     else if (inherits(cond, "condition")) {
[13:19:58.088]                       if (!is.null(pattern)) {
[13:19:58.088]                         computeRestarts <- base::computeRestarts
[13:19:58.088]                         grepl <- base::grepl
[13:19:58.088]                         restarts <- computeRestarts(cond)
[13:19:58.088]                         for (restart in restarts) {
[13:19:58.088]                           name <- restart$name
[13:19:58.088]                           if (is.null(name)) 
[13:19:58.088]                             next
[13:19:58.088]                           if (!grepl(pattern, name)) 
[13:19:58.088]                             next
[13:19:58.088]                           invokeRestart(restart)
[13:19:58.088]                           muffled <- TRUE
[13:19:58.088]                           break
[13:19:58.088]                         }
[13:19:58.088]                       }
[13:19:58.088]                     }
[13:19:58.088]                     invisible(muffled)
[13:19:58.088]                   }
[13:19:58.088]                   muffleCondition(cond)
[13:19:58.088]                 })
[13:19:58.088]             }))
[13:19:58.088]             future::FutureResult(value = ...future.value$value, 
[13:19:58.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.088]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.088]                     ...future.globalenv.names))
[13:19:58.088]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.088]         }, condition = base::local({
[13:19:58.088]             c <- base::c
[13:19:58.088]             inherits <- base::inherits
[13:19:58.088]             invokeRestart <- base::invokeRestart
[13:19:58.088]             length <- base::length
[13:19:58.088]             list <- base::list
[13:19:58.088]             seq.int <- base::seq.int
[13:19:58.088]             signalCondition <- base::signalCondition
[13:19:58.088]             sys.calls <- base::sys.calls
[13:19:58.088]             `[[` <- base::`[[`
[13:19:58.088]             `+` <- base::`+`
[13:19:58.088]             `<<-` <- base::`<<-`
[13:19:58.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.088]                   3L)]
[13:19:58.088]             }
[13:19:58.088]             function(cond) {
[13:19:58.088]                 is_error <- inherits(cond, "error")
[13:19:58.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.088]                   NULL)
[13:19:58.088]                 if (is_error) {
[13:19:58.088]                   sessionInformation <- function() {
[13:19:58.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.088]                       search = base::search(), system = base::Sys.info())
[13:19:58.088]                   }
[13:19:58.088]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.088]                     cond$call), session = sessionInformation(), 
[13:19:58.088]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.088]                   signalCondition(cond)
[13:19:58.088]                 }
[13:19:58.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.088]                 "immediateCondition"))) {
[13:19:58.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.088]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.088]                   if (TRUE && !signal) {
[13:19:58.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.088]                     {
[13:19:58.088]                       inherits <- base::inherits
[13:19:58.088]                       invokeRestart <- base::invokeRestart
[13:19:58.088]                       is.null <- base::is.null
[13:19:58.088]                       muffled <- FALSE
[13:19:58.088]                       if (inherits(cond, "message")) {
[13:19:58.088]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.088]                         if (muffled) 
[13:19:58.088]                           invokeRestart("muffleMessage")
[13:19:58.088]                       }
[13:19:58.088]                       else if (inherits(cond, "warning")) {
[13:19:58.088]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.088]                         if (muffled) 
[13:19:58.088]                           invokeRestart("muffleWarning")
[13:19:58.088]                       }
[13:19:58.088]                       else if (inherits(cond, "condition")) {
[13:19:58.088]                         if (!is.null(pattern)) {
[13:19:58.088]                           computeRestarts <- base::computeRestarts
[13:19:58.088]                           grepl <- base::grepl
[13:19:58.088]                           restarts <- computeRestarts(cond)
[13:19:58.088]                           for (restart in restarts) {
[13:19:58.088]                             name <- restart$name
[13:19:58.088]                             if (is.null(name)) 
[13:19:58.088]                               next
[13:19:58.088]                             if (!grepl(pattern, name)) 
[13:19:58.088]                               next
[13:19:58.088]                             invokeRestart(restart)
[13:19:58.088]                             muffled <- TRUE
[13:19:58.088]                             break
[13:19:58.088]                           }
[13:19:58.088]                         }
[13:19:58.088]                       }
[13:19:58.088]                       invisible(muffled)
[13:19:58.088]                     }
[13:19:58.088]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.088]                   }
[13:19:58.088]                 }
[13:19:58.088]                 else {
[13:19:58.088]                   if (TRUE) {
[13:19:58.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.088]                     {
[13:19:58.088]                       inherits <- base::inherits
[13:19:58.088]                       invokeRestart <- base::invokeRestart
[13:19:58.088]                       is.null <- base::is.null
[13:19:58.088]                       muffled <- FALSE
[13:19:58.088]                       if (inherits(cond, "message")) {
[13:19:58.088]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.088]                         if (muffled) 
[13:19:58.088]                           invokeRestart("muffleMessage")
[13:19:58.088]                       }
[13:19:58.088]                       else if (inherits(cond, "warning")) {
[13:19:58.088]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.088]                         if (muffled) 
[13:19:58.088]                           invokeRestart("muffleWarning")
[13:19:58.088]                       }
[13:19:58.088]                       else if (inherits(cond, "condition")) {
[13:19:58.088]                         if (!is.null(pattern)) {
[13:19:58.088]                           computeRestarts <- base::computeRestarts
[13:19:58.088]                           grepl <- base::grepl
[13:19:58.088]                           restarts <- computeRestarts(cond)
[13:19:58.088]                           for (restart in restarts) {
[13:19:58.088]                             name <- restart$name
[13:19:58.088]                             if (is.null(name)) 
[13:19:58.088]                               next
[13:19:58.088]                             if (!grepl(pattern, name)) 
[13:19:58.088]                               next
[13:19:58.088]                             invokeRestart(restart)
[13:19:58.088]                             muffled <- TRUE
[13:19:58.088]                             break
[13:19:58.088]                           }
[13:19:58.088]                         }
[13:19:58.088]                       }
[13:19:58.088]                       invisible(muffled)
[13:19:58.088]                     }
[13:19:58.088]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.088]                   }
[13:19:58.088]                 }
[13:19:58.088]             }
[13:19:58.088]         }))
[13:19:58.088]     }, error = function(ex) {
[13:19:58.088]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.088]                 ...future.rng), started = ...future.startTime, 
[13:19:58.088]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.088]             version = "1.8"), class = "FutureResult")
[13:19:58.088]     }, finally = {
[13:19:58.088]         if (!identical(...future.workdir, getwd())) 
[13:19:58.088]             setwd(...future.workdir)
[13:19:58.088]         {
[13:19:58.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.088]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.088]             }
[13:19:58.088]             base::options(...future.oldOptions)
[13:19:58.088]             if (.Platform$OS.type == "windows") {
[13:19:58.088]                 old_names <- names(...future.oldEnvVars)
[13:19:58.088]                 envs <- base::Sys.getenv()
[13:19:58.088]                 names <- names(envs)
[13:19:58.088]                 common <- intersect(names, old_names)
[13:19:58.088]                 added <- setdiff(names, old_names)
[13:19:58.088]                 removed <- setdiff(old_names, names)
[13:19:58.088]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.088]                   envs[common]]
[13:19:58.088]                 NAMES <- toupper(changed)
[13:19:58.088]                 args <- list()
[13:19:58.088]                 for (kk in seq_along(NAMES)) {
[13:19:58.088]                   name <- changed[[kk]]
[13:19:58.088]                   NAME <- NAMES[[kk]]
[13:19:58.088]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.088]                     next
[13:19:58.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.088]                 }
[13:19:58.088]                 NAMES <- toupper(added)
[13:19:58.088]                 for (kk in seq_along(NAMES)) {
[13:19:58.088]                   name <- added[[kk]]
[13:19:58.088]                   NAME <- NAMES[[kk]]
[13:19:58.088]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.088]                     next
[13:19:58.088]                   args[[name]] <- ""
[13:19:58.088]                 }
[13:19:58.088]                 NAMES <- toupper(removed)
[13:19:58.088]                 for (kk in seq_along(NAMES)) {
[13:19:58.088]                   name <- removed[[kk]]
[13:19:58.088]                   NAME <- NAMES[[kk]]
[13:19:58.088]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.088]                     next
[13:19:58.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.088]                 }
[13:19:58.088]                 if (length(args) > 0) 
[13:19:58.088]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.088]             }
[13:19:58.088]             else {
[13:19:58.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.088]             }
[13:19:58.088]             {
[13:19:58.088]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.088]                   0L) {
[13:19:58.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.088]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.088]                   base::options(opts)
[13:19:58.088]                 }
[13:19:58.088]                 {
[13:19:58.088]                   {
[13:19:58.088]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.088]                     NULL
[13:19:58.088]                   }
[13:19:58.088]                   options(future.plan = NULL)
[13:19:58.088]                   if (is.na(NA_character_)) 
[13:19:58.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.088]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:58.088]                     envir = parent.frame()) 
[13:19:58.088]                   {
[13:19:58.088]                     default_workers <- missing(workers)
[13:19:58.088]                     if (is.function(workers)) 
[13:19:58.088]                       workers <- workers()
[13:19:58.088]                     workers <- structure(as.integer(workers), 
[13:19:58.088]                       class = class(workers))
[13:19:58.088]                     stop_if_not(is.finite(workers), workers >= 
[13:19:58.088]                       1L)
[13:19:58.088]                     if ((workers == 1L && !inherits(workers, 
[13:19:58.088]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:58.088]                       if (default_workers) 
[13:19:58.088]                         supportsMulticore(warn = TRUE)
[13:19:58.088]                       return(sequential(..., envir = envir))
[13:19:58.088]                     }
[13:19:58.088]                     oopts <- options(mc.cores = workers)
[13:19:58.088]                     on.exit(options(oopts))
[13:19:58.088]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:58.088]                       envir = envir)
[13:19:58.088]                     if (!future$lazy) 
[13:19:58.088]                       future <- run(future)
[13:19:58.088]                     invisible(future)
[13:19:58.088]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.088]                 }
[13:19:58.088]             }
[13:19:58.088]         }
[13:19:58.088]     })
[13:19:58.088]     if (TRUE) {
[13:19:58.088]         base::sink(type = "output", split = FALSE)
[13:19:58.088]         if (TRUE) {
[13:19:58.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.088]         }
[13:19:58.088]         else {
[13:19:58.088]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.088]         }
[13:19:58.088]         base::close(...future.stdout)
[13:19:58.088]         ...future.stdout <- NULL
[13:19:58.088]     }
[13:19:58.088]     ...future.result$conditions <- ...future.conditions
[13:19:58.088]     ...future.result$finished <- base::Sys.time()
[13:19:58.088]     ...future.result
[13:19:58.088] }
[13:19:58.091] assign_globals() ...
[13:19:58.091] List of 5
[13:19:58.091]  $ future.call.arguments    : list()
[13:19:58.091]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.091]  $ ...future.FUN            :function (x)  
[13:19:58.091]  $ ...future.elements_ii    :List of 3
[13:19:58.091]   ..$ : int [1:4] 4 10 16 22
[13:19:58.091]   ..$ : int [1:4] 5 11 17 23
[13:19:58.091]   ..$ : int [1:4] 6 12 18 24
[13:19:58.091]  $ ...future.seeds_ii       : NULL
[13:19:58.091]  $ ...future.globals.maxSize: num Inf
[13:19:58.091]  - attr(*, "resolved")= logi FALSE
[13:19:58.091]  - attr(*, "total_size")= num NA
[13:19:58.091]  - attr(*, "where")=List of 5
[13:19:58.091]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:58.091]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:58.091]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:58.091]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:58.091]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:58.091]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.091]  - attr(*, "already-done")= logi TRUE
[13:19:58.101] - copied ‘future.call.arguments’ to environment
[13:19:58.101] - reassign environment for ‘...future.FUN’
[13:19:58.101] - copied ‘...future.FUN’ to environment
[13:19:58.102] - copied ‘...future.elements_ii’ to environment
[13:19:58.102] - copied ‘...future.seeds_ii’ to environment
[13:19:58.102] - copied ‘...future.globals.maxSize’ to environment
[13:19:58.102] assign_globals() ... done
[13:19:58.102] requestCore(): workers = 2
[13:19:58.104] MulticoreFuture started
[13:19:58.105] - Launch lazy future ... done
[13:19:58.105] run() for ‘MulticoreFuture’ ... done
[13:19:58.105] Created future:
[13:19:58.106] plan(): Setting new future strategy stack:
[13:19:58.106] List of future strategies:
[13:19:58.106] 1. sequential:
[13:19:58.106]    - args: function (..., envir = parent.frame())
[13:19:58.106]    - tweaked: FALSE
[13:19:58.106]    - call: NULL
[13:19:58.107] plan(): nbrOfWorkers() = 1
[13:19:58.109] plan(): Setting new future strategy stack:
[13:19:58.109] List of future strategies:
[13:19:58.109] 1. multicore:
[13:19:58.109]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:58.109]    - tweaked: FALSE
[13:19:58.109]    - call: plan(strategy)
[13:19:58.115] plan(): nbrOfWorkers() = 2
[13:19:58.106] MulticoreFuture:
[13:19:58.106] Label: ‘future_apply-2’
[13:19:58.106] Expression:
[13:19:58.106] {
[13:19:58.106]     do.call(function(...) {
[13:19:58.106]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.106]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.106]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.106]             on.exit(options(oopts), add = TRUE)
[13:19:58.106]         }
[13:19:58.106]         {
[13:19:58.106]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.106]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.106]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.106]             })
[13:19:58.106]         }
[13:19:58.106]     }, args = future.call.arguments)
[13:19:58.106] }
[13:19:58.106] Lazy evaluation: FALSE
[13:19:58.106] Asynchronous evaluation: TRUE
[13:19:58.106] Local evaluation: TRUE
[13:19:58.106] Environment: R_GlobalEnv
[13:19:58.106] Capture standard output: TRUE
[13:19:58.106] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:58.106] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:58.106] Packages: <none>
[13:19:58.106] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:58.106] Resolved: TRUE
[13:19:58.106] Value: <not collected>
[13:19:58.106] Conditions captured: <none>
[13:19:58.106] Early signaling: FALSE
[13:19:58.106] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:58.106] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.116] Chunk #2 of 2 ... DONE
[13:19:58.116] Launching 2 futures (chunks) ... DONE
[13:19:58.116] Resolving 2 futures (chunks) ...
[13:19:58.117] resolve() on list ...
[13:19:58.117]  recursive: 0
[13:19:58.117]  length: 2
[13:19:58.117] 
[13:19:58.117] Future #1
[13:19:58.118] result() for MulticoreFuture ...
[13:19:58.119] result() for MulticoreFuture ...
[13:19:58.119] result() for MulticoreFuture ... done
[13:19:58.119] result() for MulticoreFuture ... done
[13:19:58.119] result() for MulticoreFuture ...
[13:19:58.119] result() for MulticoreFuture ... done
[13:19:58.119] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:58.120] - nx: 2
[13:19:58.120] - relay: TRUE
[13:19:58.120] - stdout: TRUE
[13:19:58.120] - signal: TRUE
[13:19:58.120] - resignal: FALSE
[13:19:58.120] - force: TRUE
[13:19:58.120] - relayed: [n=2] FALSE, FALSE
[13:19:58.121] - queued futures: [n=2] FALSE, FALSE
[13:19:58.121]  - until=1
[13:19:58.121]  - relaying element #1
[13:19:58.121] result() for MulticoreFuture ...
[13:19:58.121] result() for MulticoreFuture ... done
[13:19:58.121] result() for MulticoreFuture ...
[13:19:58.121] result() for MulticoreFuture ... done
[13:19:58.122] result() for MulticoreFuture ...
[13:19:58.122] result() for MulticoreFuture ... done
[13:19:58.122] result() for MulticoreFuture ...
[13:19:58.122] result() for MulticoreFuture ... done
[13:19:58.122] - relayed: [n=2] TRUE, FALSE
[13:19:58.122] - queued futures: [n=2] TRUE, FALSE
[13:19:58.123] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:58.123]  length: 1 (resolved future 1)
[13:19:58.123] Future #2
[13:19:58.123] result() for MulticoreFuture ...
[13:19:58.124] result() for MulticoreFuture ...
[13:19:58.124] result() for MulticoreFuture ... done
[13:19:58.125] result() for MulticoreFuture ... done
[13:19:58.125] result() for MulticoreFuture ...
[13:19:58.125] result() for MulticoreFuture ... done
[13:19:58.125] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:58.125] - nx: 2
[13:19:58.125] - relay: TRUE
[13:19:58.125] - stdout: TRUE
[13:19:58.125] - signal: TRUE
[13:19:58.126] - resignal: FALSE
[13:19:58.126] - force: TRUE
[13:19:58.126] - relayed: [n=2] TRUE, FALSE
[13:19:58.126] - queued futures: [n=2] TRUE, FALSE
[13:19:58.126]  - until=2
[13:19:58.126]  - relaying element #2
[13:19:58.126] result() for MulticoreFuture ...
[13:19:58.126] result() for MulticoreFuture ... done
[13:19:58.127] result() for MulticoreFuture ...
[13:19:58.127] result() for MulticoreFuture ... done
[13:19:58.127] result() for MulticoreFuture ...
[13:19:58.127] result() for MulticoreFuture ... done
[13:19:58.127] result() for MulticoreFuture ...
[13:19:58.127] result() for MulticoreFuture ... done
[13:19:58.127] - relayed: [n=2] TRUE, TRUE
[13:19:58.127] - queued futures: [n=2] TRUE, TRUE
[13:19:58.128] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:58.128]  length: 0 (resolved future 2)
[13:19:58.128] Relaying remaining futures
[13:19:58.128] signalConditionsASAP(NULL, pos=0) ...
[13:19:58.128] - nx: 2
[13:19:58.128] - relay: TRUE
[13:19:58.128] - stdout: TRUE
[13:19:58.128] - signal: TRUE
[13:19:58.128] - resignal: FALSE
[13:19:58.128] - force: TRUE
[13:19:58.129] - relayed: [n=2] TRUE, TRUE
[13:19:58.129] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:58.129] - relayed: [n=2] TRUE, TRUE
[13:19:58.129] - queued futures: [n=2] TRUE, TRUE
[13:19:58.129] signalConditionsASAP(NULL, pos=0) ... done
[13:19:58.129] resolve() on list ... DONE
[13:19:58.129] result() for MulticoreFuture ...
[13:19:58.129] result() for MulticoreFuture ... done
[13:19:58.130] result() for MulticoreFuture ...
[13:19:58.130] result() for MulticoreFuture ... done
[13:19:58.130] result() for MulticoreFuture ...
[13:19:58.130] result() for MulticoreFuture ... done
[13:19:58.130] result() for MulticoreFuture ...
[13:19:58.130] result() for MulticoreFuture ... done
[13:19:58.130]  - Number of value chunks collected: 2
[13:19:58.130] Resolving 2 futures (chunks) ... DONE
[13:19:58.131] Reducing values from 2 chunks ...
[13:19:58.133]  - Number of values collected after concatenation: 6
[13:19:58.133]  - Number of values expected: 6
[13:19:58.133] Reducing values from 2 chunks ... DONE
[13:19:58.134] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[13:19:58.134] getGlobalsAndPackagesXApply() ...
[13:19:58.134]  - future.globals: TRUE
[13:19:58.135] getGlobalsAndPackages() ...
[13:19:58.135] Searching for globals...
[13:19:58.136] - globals found: [1] ‘FUN’
[13:19:58.137] Searching for globals ... DONE
[13:19:58.137] Resolving globals: FALSE
[13:19:58.137] The total size of the 1 globals is 848 bytes (848 bytes)
[13:19:58.138] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:19:58.138] - globals: [1] ‘FUN’
[13:19:58.138] 
[13:19:58.138] getGlobalsAndPackages() ... DONE
[13:19:58.139]  - globals found/used: [n=1] ‘FUN’
[13:19:58.139]  - needed namespaces: [n=0] 
[13:19:58.139] Finding globals ... DONE
[13:19:58.139]  - use_args: TRUE
[13:19:58.139]  - Getting '...' globals ...
[13:19:58.139] resolve() on list ...
[13:19:58.139]  recursive: 0
[13:19:58.140]  length: 1
[13:19:58.140]  elements: ‘...’
[13:19:58.140]  length: 0 (resolved future 1)
[13:19:58.140] resolve() on list ... DONE
[13:19:58.140]    - '...' content: [n=0] 
[13:19:58.140] List of 1
[13:19:58.140]  $ ...: list()
[13:19:58.140]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.140]  - attr(*, "where")=List of 1
[13:19:58.140]   ..$ ...:<environment: 0x555922f2bf78> 
[13:19:58.140]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.140]  - attr(*, "resolved")= logi TRUE
[13:19:58.140]  - attr(*, "total_size")= num NA
[13:19:58.144]  - Getting '...' globals ... DONE
[13:19:58.144] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:58.144] List of 2
[13:19:58.144]  $ ...future.FUN:function (x)  
[13:19:58.144]  $ ...          : list()
[13:19:58.144]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.144]  - attr(*, "where")=List of 2
[13:19:58.144]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:58.144]   ..$ ...          :<environment: 0x555922f2bf78> 
[13:19:58.144]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.144]  - attr(*, "resolved")= logi FALSE
[13:19:58.144]  - attr(*, "total_size")= num 848
[13:19:58.147] Packages to be attached in all futures: [n=0] 
[13:19:58.147] getGlobalsAndPackagesXApply() ... DONE
[13:19:58.151] future_lapply() ...
[13:19:58.155] Number of chunks: 2
[13:19:58.155] getGlobalsAndPackagesXApply() ...
[13:19:58.155]  - future.globals: <name-value list> with names ‘list()’
[13:19:58.155]  - use_args: TRUE
[13:19:58.155] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:58.155] List of 2
[13:19:58.155]  $ ...          : list()
[13:19:58.155]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.155]  $ ...future.FUN:function (x)  
[13:19:58.155]  - attr(*, "where")=List of 2
[13:19:58.155]   ..$ ...          :<environment: 0x555922f2bf78> 
[13:19:58.155]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:58.155]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.155]  - attr(*, "resolved")= logi FALSE
[13:19:58.155]  - attr(*, "total_size")= num NA
[13:19:58.159] Packages to be attached in all futures: [n=0] 
[13:19:58.159] getGlobalsAndPackagesXApply() ... DONE
[13:19:58.159] Number of futures (= number of chunks): 2
[13:19:58.159] Launching 2 futures (chunks) ...
[13:19:58.159] Chunk #1 of 2 ...
[13:19:58.159]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:58.160]  - seeds: <none>
[13:19:58.160]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.160] getGlobalsAndPackages() ...
[13:19:58.160] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.160] Resolving globals: FALSE
[13:19:58.160] Tweak future expression to call with '...' arguments ...
[13:19:58.160] {
[13:19:58.160]     do.call(function(...) {
[13:19:58.160]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.160]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.160]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.160]             on.exit(options(oopts), add = TRUE)
[13:19:58.160]         }
[13:19:58.160]         {
[13:19:58.160]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.160]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.160]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.160]             })
[13:19:58.160]         }
[13:19:58.160]     }, args = future.call.arguments)
[13:19:58.160] }
[13:19:58.161] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.161] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.161] 
[13:19:58.161] getGlobalsAndPackages() ... DONE
[13:19:58.162] run() for ‘Future’ ...
[13:19:58.162] - state: ‘created’
[13:19:58.162] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.167] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.167] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:58.168]   - Field: ‘label’
[13:19:58.168]   - Field: ‘local’
[13:19:58.168]   - Field: ‘owner’
[13:19:58.168]   - Field: ‘envir’
[13:19:58.168]   - Field: ‘workers’
[13:19:58.168]   - Field: ‘packages’
[13:19:58.168]   - Field: ‘gc’
[13:19:58.169]   - Field: ‘job’
[13:19:58.169]   - Field: ‘conditions’
[13:19:58.169]   - Field: ‘expr’
[13:19:58.169]   - Field: ‘uuid’
[13:19:58.169]   - Field: ‘seed’
[13:19:58.169]   - Field: ‘version’
[13:19:58.169]   - Field: ‘result’
[13:19:58.169]   - Field: ‘asynchronous’
[13:19:58.170]   - Field: ‘calls’
[13:19:58.170]   - Field: ‘globals’
[13:19:58.170]   - Field: ‘stdout’
[13:19:58.170]   - Field: ‘earlySignal’
[13:19:58.170]   - Field: ‘lazy’
[13:19:58.170]   - Field: ‘state’
[13:19:58.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:58.170] - Launch lazy future ...
[13:19:58.171] Packages needed by the future expression (n = 0): <none>
[13:19:58.171] Packages needed by future strategies (n = 0): <none>
[13:19:58.171] {
[13:19:58.171]     {
[13:19:58.171]         {
[13:19:58.171]             ...future.startTime <- base::Sys.time()
[13:19:58.171]             {
[13:19:58.171]                 {
[13:19:58.171]                   {
[13:19:58.171]                     {
[13:19:58.171]                       base::local({
[13:19:58.171]                         has_future <- base::requireNamespace("future", 
[13:19:58.171]                           quietly = TRUE)
[13:19:58.171]                         if (has_future) {
[13:19:58.171]                           ns <- base::getNamespace("future")
[13:19:58.171]                           version <- ns[[".package"]][["version"]]
[13:19:58.171]                           if (is.null(version)) 
[13:19:58.171]                             version <- utils::packageVersion("future")
[13:19:58.171]                         }
[13:19:58.171]                         else {
[13:19:58.171]                           version <- NULL
[13:19:58.171]                         }
[13:19:58.171]                         if (!has_future || version < "1.8.0") {
[13:19:58.171]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.171]                             "", base::R.version$version.string), 
[13:19:58.171]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:58.171]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.171]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.171]                               "release", "version")], collapse = " "), 
[13:19:58.171]                             hostname = base::Sys.info()[["nodename"]])
[13:19:58.171]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.171]                             info)
[13:19:58.171]                           info <- base::paste(info, collapse = "; ")
[13:19:58.171]                           if (!has_future) {
[13:19:58.171]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.171]                               info)
[13:19:58.171]                           }
[13:19:58.171]                           else {
[13:19:58.171]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.171]                               info, version)
[13:19:58.171]                           }
[13:19:58.171]                           base::stop(msg)
[13:19:58.171]                         }
[13:19:58.171]                       })
[13:19:58.171]                     }
[13:19:58.171]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.171]                     base::options(mc.cores = 1L)
[13:19:58.171]                   }
[13:19:58.171]                   options(future.plan = NULL)
[13:19:58.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.171]                 }
[13:19:58.171]                 ...future.workdir <- getwd()
[13:19:58.171]             }
[13:19:58.171]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.171]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.171]         }
[13:19:58.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.171]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:58.171]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.171]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.171]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.171]             base::names(...future.oldOptions))
[13:19:58.171]     }
[13:19:58.171]     if (FALSE) {
[13:19:58.171]     }
[13:19:58.171]     else {
[13:19:58.171]         if (TRUE) {
[13:19:58.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.171]                 open = "w")
[13:19:58.171]         }
[13:19:58.171]         else {
[13:19:58.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.171]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.171]         }
[13:19:58.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.171]             base::sink(type = "output", split = FALSE)
[13:19:58.171]             base::close(...future.stdout)
[13:19:58.171]         }, add = TRUE)
[13:19:58.171]     }
[13:19:58.171]     ...future.frame <- base::sys.nframe()
[13:19:58.171]     ...future.conditions <- base::list()
[13:19:58.171]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.171]     if (FALSE) {
[13:19:58.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.171]     }
[13:19:58.171]     ...future.result <- base::tryCatch({
[13:19:58.171]         base::withCallingHandlers({
[13:19:58.171]             ...future.value <- base::withVisible(base::local({
[13:19:58.171]                 withCallingHandlers({
[13:19:58.171]                   {
[13:19:58.171]                     do.call(function(...) {
[13:19:58.171]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.171]                       if (!identical(...future.globals.maxSize.org, 
[13:19:58.171]                         ...future.globals.maxSize)) {
[13:19:58.171]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.171]                         on.exit(options(oopts), add = TRUE)
[13:19:58.171]                       }
[13:19:58.171]                       {
[13:19:58.171]                         lapply(seq_along(...future.elements_ii), 
[13:19:58.171]                           FUN = function(jj) {
[13:19:58.171]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.171]                             ...future.FUN(...future.X_jj, ...)
[13:19:58.171]                           })
[13:19:58.171]                       }
[13:19:58.171]                     }, args = future.call.arguments)
[13:19:58.171]                   }
[13:19:58.171]                 }, immediateCondition = function(cond) {
[13:19:58.171]                   save_rds <- function (object, pathname, ...) 
[13:19:58.171]                   {
[13:19:58.171]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:58.171]                     if (file_test("-f", pathname_tmp)) {
[13:19:58.171]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.171]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:58.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.171]                         fi_tmp[["mtime"]])
[13:19:58.171]                     }
[13:19:58.171]                     tryCatch({
[13:19:58.171]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:58.171]                     }, error = function(ex) {
[13:19:58.171]                       msg <- conditionMessage(ex)
[13:19:58.171]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.171]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:58.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.171]                         fi_tmp[["mtime"]], msg)
[13:19:58.171]                       ex$message <- msg
[13:19:58.171]                       stop(ex)
[13:19:58.171]                     })
[13:19:58.171]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:58.171]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:58.171]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:58.171]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.171]                       fi <- file.info(pathname)
[13:19:58.171]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:58.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.171]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:58.171]                         fi[["size"]], fi[["mtime"]])
[13:19:58.171]                       stop(msg)
[13:19:58.171]                     }
[13:19:58.171]                     invisible(pathname)
[13:19:58.171]                   }
[13:19:58.171]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:58.171]                     rootPath = tempdir()) 
[13:19:58.171]                   {
[13:19:58.171]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:58.171]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:58.171]                       tmpdir = path, fileext = ".rds")
[13:19:58.171]                     save_rds(obj, file)
[13:19:58.171]                   }
[13:19:58.171]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:58.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.171]                   {
[13:19:58.171]                     inherits <- base::inherits
[13:19:58.171]                     invokeRestart <- base::invokeRestart
[13:19:58.171]                     is.null <- base::is.null
[13:19:58.171]                     muffled <- FALSE
[13:19:58.171]                     if (inherits(cond, "message")) {
[13:19:58.171]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.171]                       if (muffled) 
[13:19:58.171]                         invokeRestart("muffleMessage")
[13:19:58.171]                     }
[13:19:58.171]                     else if (inherits(cond, "warning")) {
[13:19:58.171]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.171]                       if (muffled) 
[13:19:58.171]                         invokeRestart("muffleWarning")
[13:19:58.171]                     }
[13:19:58.171]                     else if (inherits(cond, "condition")) {
[13:19:58.171]                       if (!is.null(pattern)) {
[13:19:58.171]                         computeRestarts <- base::computeRestarts
[13:19:58.171]                         grepl <- base::grepl
[13:19:58.171]                         restarts <- computeRestarts(cond)
[13:19:58.171]                         for (restart in restarts) {
[13:19:58.171]                           name <- restart$name
[13:19:58.171]                           if (is.null(name)) 
[13:19:58.171]                             next
[13:19:58.171]                           if (!grepl(pattern, name)) 
[13:19:58.171]                             next
[13:19:58.171]                           invokeRestart(restart)
[13:19:58.171]                           muffled <- TRUE
[13:19:58.171]                           break
[13:19:58.171]                         }
[13:19:58.171]                       }
[13:19:58.171]                     }
[13:19:58.171]                     invisible(muffled)
[13:19:58.171]                   }
[13:19:58.171]                   muffleCondition(cond)
[13:19:58.171]                 })
[13:19:58.171]             }))
[13:19:58.171]             future::FutureResult(value = ...future.value$value, 
[13:19:58.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.171]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.171]                     ...future.globalenv.names))
[13:19:58.171]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.171]         }, condition = base::local({
[13:19:58.171]             c <- base::c
[13:19:58.171]             inherits <- base::inherits
[13:19:58.171]             invokeRestart <- base::invokeRestart
[13:19:58.171]             length <- base::length
[13:19:58.171]             list <- base::list
[13:19:58.171]             seq.int <- base::seq.int
[13:19:58.171]             signalCondition <- base::signalCondition
[13:19:58.171]             sys.calls <- base::sys.calls
[13:19:58.171]             `[[` <- base::`[[`
[13:19:58.171]             `+` <- base::`+`
[13:19:58.171]             `<<-` <- base::`<<-`
[13:19:58.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.171]                   3L)]
[13:19:58.171]             }
[13:19:58.171]             function(cond) {
[13:19:58.171]                 is_error <- inherits(cond, "error")
[13:19:58.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.171]                   NULL)
[13:19:58.171]                 if (is_error) {
[13:19:58.171]                   sessionInformation <- function() {
[13:19:58.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.171]                       search = base::search(), system = base::Sys.info())
[13:19:58.171]                   }
[13:19:58.171]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.171]                     cond$call), session = sessionInformation(), 
[13:19:58.171]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.171]                   signalCondition(cond)
[13:19:58.171]                 }
[13:19:58.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.171]                 "immediateCondition"))) {
[13:19:58.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.171]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.171]                   if (TRUE && !signal) {
[13:19:58.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.171]                     {
[13:19:58.171]                       inherits <- base::inherits
[13:19:58.171]                       invokeRestart <- base::invokeRestart
[13:19:58.171]                       is.null <- base::is.null
[13:19:58.171]                       muffled <- FALSE
[13:19:58.171]                       if (inherits(cond, "message")) {
[13:19:58.171]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.171]                         if (muffled) 
[13:19:58.171]                           invokeRestart("muffleMessage")
[13:19:58.171]                       }
[13:19:58.171]                       else if (inherits(cond, "warning")) {
[13:19:58.171]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.171]                         if (muffled) 
[13:19:58.171]                           invokeRestart("muffleWarning")
[13:19:58.171]                       }
[13:19:58.171]                       else if (inherits(cond, "condition")) {
[13:19:58.171]                         if (!is.null(pattern)) {
[13:19:58.171]                           computeRestarts <- base::computeRestarts
[13:19:58.171]                           grepl <- base::grepl
[13:19:58.171]                           restarts <- computeRestarts(cond)
[13:19:58.171]                           for (restart in restarts) {
[13:19:58.171]                             name <- restart$name
[13:19:58.171]                             if (is.null(name)) 
[13:19:58.171]                               next
[13:19:58.171]                             if (!grepl(pattern, name)) 
[13:19:58.171]                               next
[13:19:58.171]                             invokeRestart(restart)
[13:19:58.171]                             muffled <- TRUE
[13:19:58.171]                             break
[13:19:58.171]                           }
[13:19:58.171]                         }
[13:19:58.171]                       }
[13:19:58.171]                       invisible(muffled)
[13:19:58.171]                     }
[13:19:58.171]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.171]                   }
[13:19:58.171]                 }
[13:19:58.171]                 else {
[13:19:58.171]                   if (TRUE) {
[13:19:58.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.171]                     {
[13:19:58.171]                       inherits <- base::inherits
[13:19:58.171]                       invokeRestart <- base::invokeRestart
[13:19:58.171]                       is.null <- base::is.null
[13:19:58.171]                       muffled <- FALSE
[13:19:58.171]                       if (inherits(cond, "message")) {
[13:19:58.171]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.171]                         if (muffled) 
[13:19:58.171]                           invokeRestart("muffleMessage")
[13:19:58.171]                       }
[13:19:58.171]                       else if (inherits(cond, "warning")) {
[13:19:58.171]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.171]                         if (muffled) 
[13:19:58.171]                           invokeRestart("muffleWarning")
[13:19:58.171]                       }
[13:19:58.171]                       else if (inherits(cond, "condition")) {
[13:19:58.171]                         if (!is.null(pattern)) {
[13:19:58.171]                           computeRestarts <- base::computeRestarts
[13:19:58.171]                           grepl <- base::grepl
[13:19:58.171]                           restarts <- computeRestarts(cond)
[13:19:58.171]                           for (restart in restarts) {
[13:19:58.171]                             name <- restart$name
[13:19:58.171]                             if (is.null(name)) 
[13:19:58.171]                               next
[13:19:58.171]                             if (!grepl(pattern, name)) 
[13:19:58.171]                               next
[13:19:58.171]                             invokeRestart(restart)
[13:19:58.171]                             muffled <- TRUE
[13:19:58.171]                             break
[13:19:58.171]                           }
[13:19:58.171]                         }
[13:19:58.171]                       }
[13:19:58.171]                       invisible(muffled)
[13:19:58.171]                     }
[13:19:58.171]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.171]                   }
[13:19:58.171]                 }
[13:19:58.171]             }
[13:19:58.171]         }))
[13:19:58.171]     }, error = function(ex) {
[13:19:58.171]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.171]                 ...future.rng), started = ...future.startTime, 
[13:19:58.171]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.171]             version = "1.8"), class = "FutureResult")
[13:19:58.171]     }, finally = {
[13:19:58.171]         if (!identical(...future.workdir, getwd())) 
[13:19:58.171]             setwd(...future.workdir)
[13:19:58.171]         {
[13:19:58.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.171]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.171]             }
[13:19:58.171]             base::options(...future.oldOptions)
[13:19:58.171]             if (.Platform$OS.type == "windows") {
[13:19:58.171]                 old_names <- names(...future.oldEnvVars)
[13:19:58.171]                 envs <- base::Sys.getenv()
[13:19:58.171]                 names <- names(envs)
[13:19:58.171]                 common <- intersect(names, old_names)
[13:19:58.171]                 added <- setdiff(names, old_names)
[13:19:58.171]                 removed <- setdiff(old_names, names)
[13:19:58.171]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.171]                   envs[common]]
[13:19:58.171]                 NAMES <- toupper(changed)
[13:19:58.171]                 args <- list()
[13:19:58.171]                 for (kk in seq_along(NAMES)) {
[13:19:58.171]                   name <- changed[[kk]]
[13:19:58.171]                   NAME <- NAMES[[kk]]
[13:19:58.171]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.171]                     next
[13:19:58.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.171]                 }
[13:19:58.171]                 NAMES <- toupper(added)
[13:19:58.171]                 for (kk in seq_along(NAMES)) {
[13:19:58.171]                   name <- added[[kk]]
[13:19:58.171]                   NAME <- NAMES[[kk]]
[13:19:58.171]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.171]                     next
[13:19:58.171]                   args[[name]] <- ""
[13:19:58.171]                 }
[13:19:58.171]                 NAMES <- toupper(removed)
[13:19:58.171]                 for (kk in seq_along(NAMES)) {
[13:19:58.171]                   name <- removed[[kk]]
[13:19:58.171]                   NAME <- NAMES[[kk]]
[13:19:58.171]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.171]                     next
[13:19:58.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.171]                 }
[13:19:58.171]                 if (length(args) > 0) 
[13:19:58.171]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.171]             }
[13:19:58.171]             else {
[13:19:58.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.171]             }
[13:19:58.171]             {
[13:19:58.171]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.171]                   0L) {
[13:19:58.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.171]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.171]                   base::options(opts)
[13:19:58.171]                 }
[13:19:58.171]                 {
[13:19:58.171]                   {
[13:19:58.171]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.171]                     NULL
[13:19:58.171]                   }
[13:19:58.171]                   options(future.plan = NULL)
[13:19:58.171]                   if (is.na(NA_character_)) 
[13:19:58.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.171]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:58.171]                     envir = parent.frame()) 
[13:19:58.171]                   {
[13:19:58.171]                     default_workers <- missing(workers)
[13:19:58.171]                     if (is.function(workers)) 
[13:19:58.171]                       workers <- workers()
[13:19:58.171]                     workers <- structure(as.integer(workers), 
[13:19:58.171]                       class = class(workers))
[13:19:58.171]                     stop_if_not(is.finite(workers), workers >= 
[13:19:58.171]                       1L)
[13:19:58.171]                     if ((workers == 1L && !inherits(workers, 
[13:19:58.171]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:58.171]                       if (default_workers) 
[13:19:58.171]                         supportsMulticore(warn = TRUE)
[13:19:58.171]                       return(sequential(..., envir = envir))
[13:19:58.171]                     }
[13:19:58.171]                     oopts <- options(mc.cores = workers)
[13:19:58.171]                     on.exit(options(oopts))
[13:19:58.171]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:58.171]                       envir = envir)
[13:19:58.171]                     if (!future$lazy) 
[13:19:58.171]                       future <- run(future)
[13:19:58.171]                     invisible(future)
[13:19:58.171]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.171]                 }
[13:19:58.171]             }
[13:19:58.171]         }
[13:19:58.171]     })
[13:19:58.171]     if (TRUE) {
[13:19:58.171]         base::sink(type = "output", split = FALSE)
[13:19:58.171]         if (TRUE) {
[13:19:58.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.171]         }
[13:19:58.171]         else {
[13:19:58.171]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.171]         }
[13:19:58.171]         base::close(...future.stdout)
[13:19:58.171]         ...future.stdout <- NULL
[13:19:58.171]     }
[13:19:58.171]     ...future.result$conditions <- ...future.conditions
[13:19:58.171]     ...future.result$finished <- base::Sys.time()
[13:19:58.171]     ...future.result
[13:19:58.171] }
[13:19:58.174] assign_globals() ...
[13:19:58.174] List of 5
[13:19:58.174]  $ future.call.arguments    : list()
[13:19:58.174]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.174]  $ ...future.FUN            :function (x)  
[13:19:58.174]  $ ...future.elements_ii    :List of 1
[13:19:58.174]   ..$ : int 1
[13:19:58.174]  $ ...future.seeds_ii       : NULL
[13:19:58.174]  $ ...future.globals.maxSize: num Inf
[13:19:58.174]  - attr(*, "resolved")= logi FALSE
[13:19:58.174]  - attr(*, "total_size")= num NA
[13:19:58.174]  - attr(*, "where")=List of 5
[13:19:58.174]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:58.174]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:58.174]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:58.174]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:58.174]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:58.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.174]  - attr(*, "already-done")= logi TRUE
[13:19:58.179] - copied ‘future.call.arguments’ to environment
[13:19:58.179] - copied ‘...future.FUN’ to environment
[13:19:58.179] - copied ‘...future.elements_ii’ to environment
[13:19:58.179] - copied ‘...future.seeds_ii’ to environment
[13:19:58.179] - copied ‘...future.globals.maxSize’ to environment
[13:19:58.179] assign_globals() ... done
[13:19:58.179] requestCore(): workers = 2
[13:19:58.182] MulticoreFuture started
[13:19:58.182] - Launch lazy future ... done
[13:19:58.182] run() for ‘MulticoreFuture’ ... done
[13:19:58.183] Created future:
[13:19:58.183] plan(): Setting new future strategy stack:
[13:19:58.183] List of future strategies:
[13:19:58.183] 1. sequential:
[13:19:58.183]    - args: function (..., envir = parent.frame())
[13:19:58.183]    - tweaked: FALSE
[13:19:58.183]    - call: NULL
[13:19:58.184] plan(): nbrOfWorkers() = 1
[13:19:58.186] plan(): Setting new future strategy stack:
[13:19:58.186] List of future strategies:
[13:19:58.186] 1. multicore:
[13:19:58.186]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:58.186]    - tweaked: FALSE
[13:19:58.186]    - call: plan(strategy)
[13:19:58.191] plan(): nbrOfWorkers() = 2
[13:19:58.183] MulticoreFuture:
[13:19:58.183] Label: ‘future_apply-1’
[13:19:58.183] Expression:
[13:19:58.183] {
[13:19:58.183]     do.call(function(...) {
[13:19:58.183]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.183]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.183]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.183]             on.exit(options(oopts), add = TRUE)
[13:19:58.183]         }
[13:19:58.183]         {
[13:19:58.183]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.183]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.183]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.183]             })
[13:19:58.183]         }
[13:19:58.183]     }, args = future.call.arguments)
[13:19:58.183] }
[13:19:58.183] Lazy evaluation: FALSE
[13:19:58.183] Asynchronous evaluation: TRUE
[13:19:58.183] Local evaluation: TRUE
[13:19:58.183] Environment: R_GlobalEnv
[13:19:58.183] Capture standard output: TRUE
[13:19:58.183] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:58.183] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:58.183] Packages: <none>
[13:19:58.183] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:58.183] Resolved: TRUE
[13:19:58.183] Value: <not collected>
[13:19:58.183] Conditions captured: <none>
[13:19:58.183] Early signaling: FALSE
[13:19:58.183] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:58.183] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.193] Chunk #1 of 2 ... DONE
[13:19:58.193] Chunk #2 of 2 ...
[13:19:58.193]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:58.193]  - seeds: <none>
[13:19:58.193]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.194] getGlobalsAndPackages() ...
[13:19:58.194] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.194] Resolving globals: FALSE
[13:19:58.194] Tweak future expression to call with '...' arguments ...
[13:19:58.194] {
[13:19:58.194]     do.call(function(...) {
[13:19:58.194]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.194]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.194]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.194]             on.exit(options(oopts), add = TRUE)
[13:19:58.194]         }
[13:19:58.194]         {
[13:19:58.194]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.194]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.194]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.194]             })
[13:19:58.194]         }
[13:19:58.194]     }, args = future.call.arguments)
[13:19:58.194] }
[13:19:58.195] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.195] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.196] 
[13:19:58.196] getGlobalsAndPackages() ... DONE
[13:19:58.196] run() for ‘Future’ ...
[13:19:58.197] - state: ‘created’
[13:19:58.197] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.201] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.201] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:58.202]   - Field: ‘label’
[13:19:58.202]   - Field: ‘local’
[13:19:58.202]   - Field: ‘owner’
[13:19:58.202]   - Field: ‘envir’
[13:19:58.202]   - Field: ‘workers’
[13:19:58.202]   - Field: ‘packages’
[13:19:58.203]   - Field: ‘gc’
[13:19:58.203]   - Field: ‘job’
[13:19:58.203]   - Field: ‘conditions’
[13:19:58.203]   - Field: ‘expr’
[13:19:58.203]   - Field: ‘uuid’
[13:19:58.203]   - Field: ‘seed’
[13:19:58.203]   - Field: ‘version’
[13:19:58.204]   - Field: ‘result’
[13:19:58.204]   - Field: ‘asynchronous’
[13:19:58.204]   - Field: ‘calls’
[13:19:58.204]   - Field: ‘globals’
[13:19:58.204]   - Field: ‘stdout’
[13:19:58.204]   - Field: ‘earlySignal’
[13:19:58.204]   - Field: ‘lazy’
[13:19:58.205]   - Field: ‘state’
[13:19:58.205] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:58.205] - Launch lazy future ...
[13:19:58.205] Packages needed by the future expression (n = 0): <none>
[13:19:58.206] Packages needed by future strategies (n = 0): <none>
[13:19:58.206] {
[13:19:58.206]     {
[13:19:58.206]         {
[13:19:58.206]             ...future.startTime <- base::Sys.time()
[13:19:58.206]             {
[13:19:58.206]                 {
[13:19:58.206]                   {
[13:19:58.206]                     {
[13:19:58.206]                       base::local({
[13:19:58.206]                         has_future <- base::requireNamespace("future", 
[13:19:58.206]                           quietly = TRUE)
[13:19:58.206]                         if (has_future) {
[13:19:58.206]                           ns <- base::getNamespace("future")
[13:19:58.206]                           version <- ns[[".package"]][["version"]]
[13:19:58.206]                           if (is.null(version)) 
[13:19:58.206]                             version <- utils::packageVersion("future")
[13:19:58.206]                         }
[13:19:58.206]                         else {
[13:19:58.206]                           version <- NULL
[13:19:58.206]                         }
[13:19:58.206]                         if (!has_future || version < "1.8.0") {
[13:19:58.206]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.206]                             "", base::R.version$version.string), 
[13:19:58.206]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:58.206]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.206]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.206]                               "release", "version")], collapse = " "), 
[13:19:58.206]                             hostname = base::Sys.info()[["nodename"]])
[13:19:58.206]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.206]                             info)
[13:19:58.206]                           info <- base::paste(info, collapse = "; ")
[13:19:58.206]                           if (!has_future) {
[13:19:58.206]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.206]                               info)
[13:19:58.206]                           }
[13:19:58.206]                           else {
[13:19:58.206]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.206]                               info, version)
[13:19:58.206]                           }
[13:19:58.206]                           base::stop(msg)
[13:19:58.206]                         }
[13:19:58.206]                       })
[13:19:58.206]                     }
[13:19:58.206]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.206]                     base::options(mc.cores = 1L)
[13:19:58.206]                   }
[13:19:58.206]                   options(future.plan = NULL)
[13:19:58.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.206]                 }
[13:19:58.206]                 ...future.workdir <- getwd()
[13:19:58.206]             }
[13:19:58.206]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.206]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.206]         }
[13:19:58.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.206]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:58.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.206]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.206]             base::names(...future.oldOptions))
[13:19:58.206]     }
[13:19:58.206]     if (FALSE) {
[13:19:58.206]     }
[13:19:58.206]     else {
[13:19:58.206]         if (TRUE) {
[13:19:58.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.206]                 open = "w")
[13:19:58.206]         }
[13:19:58.206]         else {
[13:19:58.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.206]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.206]         }
[13:19:58.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.206]             base::sink(type = "output", split = FALSE)
[13:19:58.206]             base::close(...future.stdout)
[13:19:58.206]         }, add = TRUE)
[13:19:58.206]     }
[13:19:58.206]     ...future.frame <- base::sys.nframe()
[13:19:58.206]     ...future.conditions <- base::list()
[13:19:58.206]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.206]     if (FALSE) {
[13:19:58.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.206]     }
[13:19:58.206]     ...future.result <- base::tryCatch({
[13:19:58.206]         base::withCallingHandlers({
[13:19:58.206]             ...future.value <- base::withVisible(base::local({
[13:19:58.206]                 withCallingHandlers({
[13:19:58.206]                   {
[13:19:58.206]                     do.call(function(...) {
[13:19:58.206]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.206]                       if (!identical(...future.globals.maxSize.org, 
[13:19:58.206]                         ...future.globals.maxSize)) {
[13:19:58.206]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.206]                         on.exit(options(oopts), add = TRUE)
[13:19:58.206]                       }
[13:19:58.206]                       {
[13:19:58.206]                         lapply(seq_along(...future.elements_ii), 
[13:19:58.206]                           FUN = function(jj) {
[13:19:58.206]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.206]                             ...future.FUN(...future.X_jj, ...)
[13:19:58.206]                           })
[13:19:58.206]                       }
[13:19:58.206]                     }, args = future.call.arguments)
[13:19:58.206]                   }
[13:19:58.206]                 }, immediateCondition = function(cond) {
[13:19:58.206]                   save_rds <- function (object, pathname, ...) 
[13:19:58.206]                   {
[13:19:58.206]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:58.206]                     if (file_test("-f", pathname_tmp)) {
[13:19:58.206]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.206]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:58.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.206]                         fi_tmp[["mtime"]])
[13:19:58.206]                     }
[13:19:58.206]                     tryCatch({
[13:19:58.206]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:58.206]                     }, error = function(ex) {
[13:19:58.206]                       msg <- conditionMessage(ex)
[13:19:58.206]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.206]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:58.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.206]                         fi_tmp[["mtime"]], msg)
[13:19:58.206]                       ex$message <- msg
[13:19:58.206]                       stop(ex)
[13:19:58.206]                     })
[13:19:58.206]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:58.206]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:58.206]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:58.206]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.206]                       fi <- file.info(pathname)
[13:19:58.206]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:58.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.206]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:58.206]                         fi[["size"]], fi[["mtime"]])
[13:19:58.206]                       stop(msg)
[13:19:58.206]                     }
[13:19:58.206]                     invisible(pathname)
[13:19:58.206]                   }
[13:19:58.206]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:58.206]                     rootPath = tempdir()) 
[13:19:58.206]                   {
[13:19:58.206]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:58.206]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:58.206]                       tmpdir = path, fileext = ".rds")
[13:19:58.206]                     save_rds(obj, file)
[13:19:58.206]                   }
[13:19:58.206]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:58.206]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.206]                   {
[13:19:58.206]                     inherits <- base::inherits
[13:19:58.206]                     invokeRestart <- base::invokeRestart
[13:19:58.206]                     is.null <- base::is.null
[13:19:58.206]                     muffled <- FALSE
[13:19:58.206]                     if (inherits(cond, "message")) {
[13:19:58.206]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.206]                       if (muffled) 
[13:19:58.206]                         invokeRestart("muffleMessage")
[13:19:58.206]                     }
[13:19:58.206]                     else if (inherits(cond, "warning")) {
[13:19:58.206]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.206]                       if (muffled) 
[13:19:58.206]                         invokeRestart("muffleWarning")
[13:19:58.206]                     }
[13:19:58.206]                     else if (inherits(cond, "condition")) {
[13:19:58.206]                       if (!is.null(pattern)) {
[13:19:58.206]                         computeRestarts <- base::computeRestarts
[13:19:58.206]                         grepl <- base::grepl
[13:19:58.206]                         restarts <- computeRestarts(cond)
[13:19:58.206]                         for (restart in restarts) {
[13:19:58.206]                           name <- restart$name
[13:19:58.206]                           if (is.null(name)) 
[13:19:58.206]                             next
[13:19:58.206]                           if (!grepl(pattern, name)) 
[13:19:58.206]                             next
[13:19:58.206]                           invokeRestart(restart)
[13:19:58.206]                           muffled <- TRUE
[13:19:58.206]                           break
[13:19:58.206]                         }
[13:19:58.206]                       }
[13:19:58.206]                     }
[13:19:58.206]                     invisible(muffled)
[13:19:58.206]                   }
[13:19:58.206]                   muffleCondition(cond)
[13:19:58.206]                 })
[13:19:58.206]             }))
[13:19:58.206]             future::FutureResult(value = ...future.value$value, 
[13:19:58.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.206]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.206]                     ...future.globalenv.names))
[13:19:58.206]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.206]         }, condition = base::local({
[13:19:58.206]             c <- base::c
[13:19:58.206]             inherits <- base::inherits
[13:19:58.206]             invokeRestart <- base::invokeRestart
[13:19:58.206]             length <- base::length
[13:19:58.206]             list <- base::list
[13:19:58.206]             seq.int <- base::seq.int
[13:19:58.206]             signalCondition <- base::signalCondition
[13:19:58.206]             sys.calls <- base::sys.calls
[13:19:58.206]             `[[` <- base::`[[`
[13:19:58.206]             `+` <- base::`+`
[13:19:58.206]             `<<-` <- base::`<<-`
[13:19:58.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.206]                   3L)]
[13:19:58.206]             }
[13:19:58.206]             function(cond) {
[13:19:58.206]                 is_error <- inherits(cond, "error")
[13:19:58.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.206]                   NULL)
[13:19:58.206]                 if (is_error) {
[13:19:58.206]                   sessionInformation <- function() {
[13:19:58.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.206]                       search = base::search(), system = base::Sys.info())
[13:19:58.206]                   }
[13:19:58.206]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.206]                     cond$call), session = sessionInformation(), 
[13:19:58.206]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.206]                   signalCondition(cond)
[13:19:58.206]                 }
[13:19:58.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.206]                 "immediateCondition"))) {
[13:19:58.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.206]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.206]                   if (TRUE && !signal) {
[13:19:58.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.206]                     {
[13:19:58.206]                       inherits <- base::inherits
[13:19:58.206]                       invokeRestart <- base::invokeRestart
[13:19:58.206]                       is.null <- base::is.null
[13:19:58.206]                       muffled <- FALSE
[13:19:58.206]                       if (inherits(cond, "message")) {
[13:19:58.206]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.206]                         if (muffled) 
[13:19:58.206]                           invokeRestart("muffleMessage")
[13:19:58.206]                       }
[13:19:58.206]                       else if (inherits(cond, "warning")) {
[13:19:58.206]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.206]                         if (muffled) 
[13:19:58.206]                           invokeRestart("muffleWarning")
[13:19:58.206]                       }
[13:19:58.206]                       else if (inherits(cond, "condition")) {
[13:19:58.206]                         if (!is.null(pattern)) {
[13:19:58.206]                           computeRestarts <- base::computeRestarts
[13:19:58.206]                           grepl <- base::grepl
[13:19:58.206]                           restarts <- computeRestarts(cond)
[13:19:58.206]                           for (restart in restarts) {
[13:19:58.206]                             name <- restart$name
[13:19:58.206]                             if (is.null(name)) 
[13:19:58.206]                               next
[13:19:58.206]                             if (!grepl(pattern, name)) 
[13:19:58.206]                               next
[13:19:58.206]                             invokeRestart(restart)
[13:19:58.206]                             muffled <- TRUE
[13:19:58.206]                             break
[13:19:58.206]                           }
[13:19:58.206]                         }
[13:19:58.206]                       }
[13:19:58.206]                       invisible(muffled)
[13:19:58.206]                     }
[13:19:58.206]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.206]                   }
[13:19:58.206]                 }
[13:19:58.206]                 else {
[13:19:58.206]                   if (TRUE) {
[13:19:58.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.206]                     {
[13:19:58.206]                       inherits <- base::inherits
[13:19:58.206]                       invokeRestart <- base::invokeRestart
[13:19:58.206]                       is.null <- base::is.null
[13:19:58.206]                       muffled <- FALSE
[13:19:58.206]                       if (inherits(cond, "message")) {
[13:19:58.206]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.206]                         if (muffled) 
[13:19:58.206]                           invokeRestart("muffleMessage")
[13:19:58.206]                       }
[13:19:58.206]                       else if (inherits(cond, "warning")) {
[13:19:58.206]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.206]                         if (muffled) 
[13:19:58.206]                           invokeRestart("muffleWarning")
[13:19:58.206]                       }
[13:19:58.206]                       else if (inherits(cond, "condition")) {
[13:19:58.206]                         if (!is.null(pattern)) {
[13:19:58.206]                           computeRestarts <- base::computeRestarts
[13:19:58.206]                           grepl <- base::grepl
[13:19:58.206]                           restarts <- computeRestarts(cond)
[13:19:58.206]                           for (restart in restarts) {
[13:19:58.206]                             name <- restart$name
[13:19:58.206]                             if (is.null(name)) 
[13:19:58.206]                               next
[13:19:58.206]                             if (!grepl(pattern, name)) 
[13:19:58.206]                               next
[13:19:58.206]                             invokeRestart(restart)
[13:19:58.206]                             muffled <- TRUE
[13:19:58.206]                             break
[13:19:58.206]                           }
[13:19:58.206]                         }
[13:19:58.206]                       }
[13:19:58.206]                       invisible(muffled)
[13:19:58.206]                     }
[13:19:58.206]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.206]                   }
[13:19:58.206]                 }
[13:19:58.206]             }
[13:19:58.206]         }))
[13:19:58.206]     }, error = function(ex) {
[13:19:58.206]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.206]                 ...future.rng), started = ...future.startTime, 
[13:19:58.206]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.206]             version = "1.8"), class = "FutureResult")
[13:19:58.206]     }, finally = {
[13:19:58.206]         if (!identical(...future.workdir, getwd())) 
[13:19:58.206]             setwd(...future.workdir)
[13:19:58.206]         {
[13:19:58.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.206]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.206]             }
[13:19:58.206]             base::options(...future.oldOptions)
[13:19:58.206]             if (.Platform$OS.type == "windows") {
[13:19:58.206]                 old_names <- names(...future.oldEnvVars)
[13:19:58.206]                 envs <- base::Sys.getenv()
[13:19:58.206]                 names <- names(envs)
[13:19:58.206]                 common <- intersect(names, old_names)
[13:19:58.206]                 added <- setdiff(names, old_names)
[13:19:58.206]                 removed <- setdiff(old_names, names)
[13:19:58.206]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.206]                   envs[common]]
[13:19:58.206]                 NAMES <- toupper(changed)
[13:19:58.206]                 args <- list()
[13:19:58.206]                 for (kk in seq_along(NAMES)) {
[13:19:58.206]                   name <- changed[[kk]]
[13:19:58.206]                   NAME <- NAMES[[kk]]
[13:19:58.206]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.206]                     next
[13:19:58.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.206]                 }
[13:19:58.206]                 NAMES <- toupper(added)
[13:19:58.206]                 for (kk in seq_along(NAMES)) {
[13:19:58.206]                   name <- added[[kk]]
[13:19:58.206]                   NAME <- NAMES[[kk]]
[13:19:58.206]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.206]                     next
[13:19:58.206]                   args[[name]] <- ""
[13:19:58.206]                 }
[13:19:58.206]                 NAMES <- toupper(removed)
[13:19:58.206]                 for (kk in seq_along(NAMES)) {
[13:19:58.206]                   name <- removed[[kk]]
[13:19:58.206]                   NAME <- NAMES[[kk]]
[13:19:58.206]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.206]                     next
[13:19:58.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.206]                 }
[13:19:58.206]                 if (length(args) > 0) 
[13:19:58.206]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.206]             }
[13:19:58.206]             else {
[13:19:58.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.206]             }
[13:19:58.206]             {
[13:19:58.206]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.206]                   0L) {
[13:19:58.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.206]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.206]                   base::options(opts)
[13:19:58.206]                 }
[13:19:58.206]                 {
[13:19:58.206]                   {
[13:19:58.206]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.206]                     NULL
[13:19:58.206]                   }
[13:19:58.206]                   options(future.plan = NULL)
[13:19:58.206]                   if (is.na(NA_character_)) 
[13:19:58.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.206]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:58.206]                     envir = parent.frame()) 
[13:19:58.206]                   {
[13:19:58.206]                     default_workers <- missing(workers)
[13:19:58.206]                     if (is.function(workers)) 
[13:19:58.206]                       workers <- workers()
[13:19:58.206]                     workers <- structure(as.integer(workers), 
[13:19:58.206]                       class = class(workers))
[13:19:58.206]                     stop_if_not(is.finite(workers), workers >= 
[13:19:58.206]                       1L)
[13:19:58.206]                     if ((workers == 1L && !inherits(workers, 
[13:19:58.206]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:58.206]                       if (default_workers) 
[13:19:58.206]                         supportsMulticore(warn = TRUE)
[13:19:58.206]                       return(sequential(..., envir = envir))
[13:19:58.206]                     }
[13:19:58.206]                     oopts <- options(mc.cores = workers)
[13:19:58.206]                     on.exit(options(oopts))
[13:19:58.206]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:58.206]                       envir = envir)
[13:19:58.206]                     if (!future$lazy) 
[13:19:58.206]                       future <- run(future)
[13:19:58.206]                     invisible(future)
[13:19:58.206]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.206]                 }
[13:19:58.206]             }
[13:19:58.206]         }
[13:19:58.206]     })
[13:19:58.206]     if (TRUE) {
[13:19:58.206]         base::sink(type = "output", split = FALSE)
[13:19:58.206]         if (TRUE) {
[13:19:58.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.206]         }
[13:19:58.206]         else {
[13:19:58.206]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.206]         }
[13:19:58.206]         base::close(...future.stdout)
[13:19:58.206]         ...future.stdout <- NULL
[13:19:58.206]     }
[13:19:58.206]     ...future.result$conditions <- ...future.conditions
[13:19:58.206]     ...future.result$finished <- base::Sys.time()
[13:19:58.206]     ...future.result
[13:19:58.206] }
[13:19:58.210] assign_globals() ...
[13:19:58.210] List of 5
[13:19:58.210]  $ future.call.arguments    : list()
[13:19:58.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.210]  $ ...future.FUN            :function (x)  
[13:19:58.210]  $ ...future.elements_ii    :List of 1
[13:19:58.210]   ..$ : int 2
[13:19:58.210]  $ ...future.seeds_ii       : NULL
[13:19:58.210]  $ ...future.globals.maxSize: num Inf
[13:19:58.210]  - attr(*, "resolved")= logi FALSE
[13:19:58.210]  - attr(*, "total_size")= num NA
[13:19:58.210]  - attr(*, "where")=List of 5
[13:19:58.210]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:58.210]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:58.210]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:58.210]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:58.210]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:58.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.210]  - attr(*, "already-done")= logi TRUE
[13:19:58.223] - copied ‘future.call.arguments’ to environment
[13:19:58.223] - copied ‘...future.FUN’ to environment
[13:19:58.224] - copied ‘...future.elements_ii’ to environment
[13:19:58.224] - copied ‘...future.seeds_ii’ to environment
[13:19:58.224] - copied ‘...future.globals.maxSize’ to environment
[13:19:58.224] assign_globals() ... done
[13:19:58.224] requestCore(): workers = 2
[13:19:58.227] MulticoreFuture started
[13:19:58.227] - Launch lazy future ... done
[13:19:58.227] run() for ‘MulticoreFuture’ ... done
[13:19:58.228] Created future:
[13:19:58.228] plan(): Setting new future strategy stack:
[13:19:58.228] List of future strategies:
[13:19:58.228] 1. sequential:
[13:19:58.228]    - args: function (..., envir = parent.frame())
[13:19:58.228]    - tweaked: FALSE
[13:19:58.228]    - call: NULL
[13:19:58.229] plan(): nbrOfWorkers() = 1
[13:19:58.231] plan(): Setting new future strategy stack:
[13:19:58.232] List of future strategies:
[13:19:58.232] 1. multicore:
[13:19:58.232]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:58.232]    - tweaked: FALSE
[13:19:58.232]    - call: plan(strategy)
[13:19:58.237] plan(): nbrOfWorkers() = 2
[13:19:58.228] MulticoreFuture:
[13:19:58.228] Label: ‘future_apply-2’
[13:19:58.228] Expression:
[13:19:58.228] {
[13:19:58.228]     do.call(function(...) {
[13:19:58.228]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.228]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.228]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.228]             on.exit(options(oopts), add = TRUE)
[13:19:58.228]         }
[13:19:58.228]         {
[13:19:58.228]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.228]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.228]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.228]             })
[13:19:58.228]         }
[13:19:58.228]     }, args = future.call.arguments)
[13:19:58.228] }
[13:19:58.228] Lazy evaluation: FALSE
[13:19:58.228] Asynchronous evaluation: TRUE
[13:19:58.228] Local evaluation: TRUE
[13:19:58.228] Environment: R_GlobalEnv
[13:19:58.228] Capture standard output: TRUE
[13:19:58.228] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:58.228] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:58.228] Packages: <none>
[13:19:58.228] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:58.228] Resolved: TRUE
[13:19:58.228] Value: <not collected>
[13:19:58.228] Conditions captured: <none>
[13:19:58.228] Early signaling: FALSE
[13:19:58.228] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:58.228] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.238] Chunk #2 of 2 ... DONE
[13:19:58.238] Launching 2 futures (chunks) ... DONE
[13:19:58.238] Resolving 2 futures (chunks) ...
[13:19:58.239] resolve() on list ...
[13:19:58.239]  recursive: 0
[13:19:58.239]  length: 2
[13:19:58.239] 
[13:19:58.239] Future #1
[13:19:58.240] result() for MulticoreFuture ...
[13:19:58.241] result() for MulticoreFuture ...
[13:19:58.241] result() for MulticoreFuture ... done
[13:19:58.241] result() for MulticoreFuture ... done
[13:19:58.241] result() for MulticoreFuture ...
[13:19:58.241] result() for MulticoreFuture ... done
[13:19:58.241] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:58.242] - nx: 2
[13:19:58.242] - relay: TRUE
[13:19:58.242] - stdout: TRUE
[13:19:58.242] - signal: TRUE
[13:19:58.242] - resignal: FALSE
[13:19:58.242] - force: TRUE
[13:19:58.242] - relayed: [n=2] FALSE, FALSE
[13:19:58.243] - queued futures: [n=2] FALSE, FALSE
[13:19:58.243]  - until=1
[13:19:58.243]  - relaying element #1
[13:19:58.243] result() for MulticoreFuture ...
[13:19:58.243] result() for MulticoreFuture ... done
[13:19:58.243] result() for MulticoreFuture ...
[13:19:58.243] result() for MulticoreFuture ... done
[13:19:58.244] result() for MulticoreFuture ...
[13:19:58.244] result() for MulticoreFuture ... done
[13:19:58.244] result() for MulticoreFuture ...
[13:19:58.244] result() for MulticoreFuture ... done
[13:19:58.244] - relayed: [n=2] TRUE, FALSE
[13:19:58.245] - queued futures: [n=2] TRUE, FALSE
[13:19:58.245] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:58.245]  length: 1 (resolved future 1)
[13:19:58.245] Future #2
[13:19:58.245] result() for MulticoreFuture ...
[13:19:58.246] result() for MulticoreFuture ...
[13:19:58.246] result() for MulticoreFuture ... done
[13:19:58.247] result() for MulticoreFuture ... done
[13:19:58.247] result() for MulticoreFuture ...
[13:19:58.247] result() for MulticoreFuture ... done
[13:19:58.247] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:58.247] - nx: 2
[13:19:58.247] - relay: TRUE
[13:19:58.247] - stdout: TRUE
[13:19:58.248] - signal: TRUE
[13:19:58.248] - resignal: FALSE
[13:19:58.248] - force: TRUE
[13:19:58.248] - relayed: [n=2] TRUE, FALSE
[13:19:58.248] - queued futures: [n=2] TRUE, FALSE
[13:19:58.248]  - until=2
[13:19:58.248]  - relaying element #2
[13:19:58.249] result() for MulticoreFuture ...
[13:19:58.249] result() for MulticoreFuture ... done
[13:19:58.249] result() for MulticoreFuture ...
[13:19:58.249] result() for MulticoreFuture ... done
[13:19:58.249] result() for MulticoreFuture ...
[13:19:58.249] result() for MulticoreFuture ... done
[13:19:58.249] result() for MulticoreFuture ...
[13:19:58.249] result() for MulticoreFuture ... done
[13:19:58.250] - relayed: [n=2] TRUE, TRUE
[13:19:58.250] - queued futures: [n=2] TRUE, TRUE
[13:19:58.250] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:58.250]  length: 0 (resolved future 2)
[13:19:58.250] Relaying remaining futures
[13:19:58.250] signalConditionsASAP(NULL, pos=0) ...
[13:19:58.250] - nx: 2
[13:19:58.250] - relay: TRUE
[13:19:58.250] - stdout: TRUE
[13:19:58.251] - signal: TRUE
[13:19:58.251] - resignal: FALSE
[13:19:58.251] - force: TRUE
[13:19:58.251] - relayed: [n=2] TRUE, TRUE
[13:19:58.251] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:58.251] - relayed: [n=2] TRUE, TRUE
[13:19:58.251] - queued futures: [n=2] TRUE, TRUE
[13:19:58.251] signalConditionsASAP(NULL, pos=0) ... done
[13:19:58.251] resolve() on list ... DONE
[13:19:58.252] result() for MulticoreFuture ...
[13:19:58.252] result() for MulticoreFuture ... done
[13:19:58.252] result() for MulticoreFuture ...
[13:19:58.252] result() for MulticoreFuture ... done
[13:19:58.252] result() for MulticoreFuture ...
[13:19:58.252] result() for MulticoreFuture ... done
[13:19:58.252] result() for MulticoreFuture ...
[13:19:58.252] result() for MulticoreFuture ... done
[13:19:58.253]  - Number of value chunks collected: 2
[13:19:58.253] Resolving 2 futures (chunks) ... DONE
[13:19:58.253] Reducing values from 2 chunks ...
[13:19:58.253]  - Number of values collected after concatenation: 2
[13:19:58.253]  - Number of values expected: 2
[13:19:58.253] Reducing values from 2 chunks ... DONE
[13:19:58.253] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[13:19:58.254] getGlobalsAndPackagesXApply() ...
[13:19:58.254]  - future.globals: TRUE
[13:19:58.254] getGlobalsAndPackages() ...
[13:19:58.254] Searching for globals...
[13:19:58.255] - globals found: [1] ‘FUN’
[13:19:58.256] Searching for globals ... DONE
[13:19:58.258] Resolving globals: FALSE
[13:19:58.258] The total size of the 1 globals is 848 bytes (848 bytes)
[13:19:58.259] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:19:58.259] - globals: [1] ‘FUN’
[13:19:58.259] 
[13:19:58.259] getGlobalsAndPackages() ... DONE
[13:19:58.260]  - globals found/used: [n=1] ‘FUN’
[13:19:58.260]  - needed namespaces: [n=0] 
[13:19:58.260] Finding globals ... DONE
[13:19:58.260]  - use_args: TRUE
[13:19:58.260]  - Getting '...' globals ...
[13:19:58.261] resolve() on list ...
[13:19:58.261]  recursive: 0
[13:19:58.261]  length: 1
[13:19:58.261]  elements: ‘...’
[13:19:58.261]  length: 0 (resolved future 1)
[13:19:58.262] resolve() on list ... DONE
[13:19:58.262]    - '...' content: [n=0] 
[13:19:58.262] List of 1
[13:19:58.262]  $ ...: list()
[13:19:58.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.262]  - attr(*, "where")=List of 1
[13:19:58.262]   ..$ ...:<environment: 0x555922b6f1f8> 
[13:19:58.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.262]  - attr(*, "resolved")= logi TRUE
[13:19:58.262]  - attr(*, "total_size")= num NA
[13:19:58.265]  - Getting '...' globals ... DONE
[13:19:58.266] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:58.266] List of 2
[13:19:58.266]  $ ...future.FUN:function (x)  
[13:19:58.266]  $ ...          : list()
[13:19:58.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.266]  - attr(*, "where")=List of 2
[13:19:58.266]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:58.266]   ..$ ...          :<environment: 0x555922b6f1f8> 
[13:19:58.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.266]  - attr(*, "resolved")= logi FALSE
[13:19:58.266]  - attr(*, "total_size")= num 848
[13:19:58.269] Packages to be attached in all futures: [n=0] 
[13:19:58.269] getGlobalsAndPackagesXApply() ... DONE
[13:19:58.273] future_lapply() ...
[13:19:58.277] Number of chunks: 2
[13:19:58.277] getGlobalsAndPackagesXApply() ...
[13:19:58.277]  - future.globals: <name-value list> with names ‘list()’
[13:19:58.278]  - use_args: TRUE
[13:19:58.278] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:58.278] List of 2
[13:19:58.278]  $ ...          : list()
[13:19:58.278]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.278]  $ ...future.FUN:function (x)  
[13:19:58.278]  - attr(*, "where")=List of 2
[13:19:58.278]   ..$ ...          :<environment: 0x555922b6f1f8> 
[13:19:58.278]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:58.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.278]  - attr(*, "resolved")= logi FALSE
[13:19:58.278]  - attr(*, "total_size")= num NA
[13:19:58.281] Packages to be attached in all futures: [n=0] 
[13:19:58.282] getGlobalsAndPackagesXApply() ... DONE
[13:19:58.282] Number of futures (= number of chunks): 2
[13:19:58.282] Launching 2 futures (chunks) ...
[13:19:58.282] Chunk #1 of 2 ...
[13:19:58.282]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:58.282]  - seeds: <none>
[13:19:58.282]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.282] getGlobalsAndPackages() ...
[13:19:58.283] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.283] Resolving globals: FALSE
[13:19:58.283] Tweak future expression to call with '...' arguments ...
[13:19:58.283] {
[13:19:58.283]     do.call(function(...) {
[13:19:58.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.283]             on.exit(options(oopts), add = TRUE)
[13:19:58.283]         }
[13:19:58.283]         {
[13:19:58.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.283]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.283]             })
[13:19:58.283]         }
[13:19:58.283]     }, args = future.call.arguments)
[13:19:58.283] }
[13:19:58.283] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.284] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.284] 
[13:19:58.284] getGlobalsAndPackages() ... DONE
[13:19:58.284] run() for ‘Future’ ...
[13:19:58.284] - state: ‘created’
[13:19:58.284] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:58.288]   - Field: ‘label’
[13:19:58.288]   - Field: ‘local’
[13:19:58.289]   - Field: ‘owner’
[13:19:58.289]   - Field: ‘envir’
[13:19:58.291]   - Field: ‘workers’
[13:19:58.291]   - Field: ‘packages’
[13:19:58.291]   - Field: ‘gc’
[13:19:58.291]   - Field: ‘job’
[13:19:58.291]   - Field: ‘conditions’
[13:19:58.291]   - Field: ‘expr’
[13:19:58.291]   - Field: ‘uuid’
[13:19:58.292]   - Field: ‘seed’
[13:19:58.292]   - Field: ‘version’
[13:19:58.292]   - Field: ‘result’
[13:19:58.292]   - Field: ‘asynchronous’
[13:19:58.292]   - Field: ‘calls’
[13:19:58.292]   - Field: ‘globals’
[13:19:58.292]   - Field: ‘stdout’
[13:19:58.293]   - Field: ‘earlySignal’
[13:19:58.293]   - Field: ‘lazy’
[13:19:58.293]   - Field: ‘state’
[13:19:58.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:58.293] - Launch lazy future ...
[13:19:58.293] Packages needed by the future expression (n = 0): <none>
[13:19:58.294] Packages needed by future strategies (n = 0): <none>
[13:19:58.294] {
[13:19:58.294]     {
[13:19:58.294]         {
[13:19:58.294]             ...future.startTime <- base::Sys.time()
[13:19:58.294]             {
[13:19:58.294]                 {
[13:19:58.294]                   {
[13:19:58.294]                     {
[13:19:58.294]                       base::local({
[13:19:58.294]                         has_future <- base::requireNamespace("future", 
[13:19:58.294]                           quietly = TRUE)
[13:19:58.294]                         if (has_future) {
[13:19:58.294]                           ns <- base::getNamespace("future")
[13:19:58.294]                           version <- ns[[".package"]][["version"]]
[13:19:58.294]                           if (is.null(version)) 
[13:19:58.294]                             version <- utils::packageVersion("future")
[13:19:58.294]                         }
[13:19:58.294]                         else {
[13:19:58.294]                           version <- NULL
[13:19:58.294]                         }
[13:19:58.294]                         if (!has_future || version < "1.8.0") {
[13:19:58.294]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.294]                             "", base::R.version$version.string), 
[13:19:58.294]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:58.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.294]                               "release", "version")], collapse = " "), 
[13:19:58.294]                             hostname = base::Sys.info()[["nodename"]])
[13:19:58.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.294]                             info)
[13:19:58.294]                           info <- base::paste(info, collapse = "; ")
[13:19:58.294]                           if (!has_future) {
[13:19:58.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.294]                               info)
[13:19:58.294]                           }
[13:19:58.294]                           else {
[13:19:58.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.294]                               info, version)
[13:19:58.294]                           }
[13:19:58.294]                           base::stop(msg)
[13:19:58.294]                         }
[13:19:58.294]                       })
[13:19:58.294]                     }
[13:19:58.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.294]                     base::options(mc.cores = 1L)
[13:19:58.294]                   }
[13:19:58.294]                   options(future.plan = NULL)
[13:19:58.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.294]                 }
[13:19:58.294]                 ...future.workdir <- getwd()
[13:19:58.294]             }
[13:19:58.294]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.294]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.294]         }
[13:19:58.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.294]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:58.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.294]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.294]             base::names(...future.oldOptions))
[13:19:58.294]     }
[13:19:58.294]     if (FALSE) {
[13:19:58.294]     }
[13:19:58.294]     else {
[13:19:58.294]         if (TRUE) {
[13:19:58.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.294]                 open = "w")
[13:19:58.294]         }
[13:19:58.294]         else {
[13:19:58.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.294]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.294]         }
[13:19:58.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.294]             base::sink(type = "output", split = FALSE)
[13:19:58.294]             base::close(...future.stdout)
[13:19:58.294]         }, add = TRUE)
[13:19:58.294]     }
[13:19:58.294]     ...future.frame <- base::sys.nframe()
[13:19:58.294]     ...future.conditions <- base::list()
[13:19:58.294]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.294]     if (FALSE) {
[13:19:58.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.294]     }
[13:19:58.294]     ...future.result <- base::tryCatch({
[13:19:58.294]         base::withCallingHandlers({
[13:19:58.294]             ...future.value <- base::withVisible(base::local({
[13:19:58.294]                 withCallingHandlers({
[13:19:58.294]                   {
[13:19:58.294]                     do.call(function(...) {
[13:19:58.294]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.294]                       if (!identical(...future.globals.maxSize.org, 
[13:19:58.294]                         ...future.globals.maxSize)) {
[13:19:58.294]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.294]                         on.exit(options(oopts), add = TRUE)
[13:19:58.294]                       }
[13:19:58.294]                       {
[13:19:58.294]                         lapply(seq_along(...future.elements_ii), 
[13:19:58.294]                           FUN = function(jj) {
[13:19:58.294]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.294]                             ...future.FUN(...future.X_jj, ...)
[13:19:58.294]                           })
[13:19:58.294]                       }
[13:19:58.294]                     }, args = future.call.arguments)
[13:19:58.294]                   }
[13:19:58.294]                 }, immediateCondition = function(cond) {
[13:19:58.294]                   save_rds <- function (object, pathname, ...) 
[13:19:58.294]                   {
[13:19:58.294]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:58.294]                     if (file_test("-f", pathname_tmp)) {
[13:19:58.294]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.294]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:58.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.294]                         fi_tmp[["mtime"]])
[13:19:58.294]                     }
[13:19:58.294]                     tryCatch({
[13:19:58.294]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:58.294]                     }, error = function(ex) {
[13:19:58.294]                       msg <- conditionMessage(ex)
[13:19:58.294]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.294]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:58.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.294]                         fi_tmp[["mtime"]], msg)
[13:19:58.294]                       ex$message <- msg
[13:19:58.294]                       stop(ex)
[13:19:58.294]                     })
[13:19:58.294]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:58.294]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:58.294]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:58.294]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.294]                       fi <- file.info(pathname)
[13:19:58.294]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:58.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.294]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:58.294]                         fi[["size"]], fi[["mtime"]])
[13:19:58.294]                       stop(msg)
[13:19:58.294]                     }
[13:19:58.294]                     invisible(pathname)
[13:19:58.294]                   }
[13:19:58.294]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:58.294]                     rootPath = tempdir()) 
[13:19:58.294]                   {
[13:19:58.294]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:58.294]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:58.294]                       tmpdir = path, fileext = ".rds")
[13:19:58.294]                     save_rds(obj, file)
[13:19:58.294]                   }
[13:19:58.294]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:58.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.294]                   {
[13:19:58.294]                     inherits <- base::inherits
[13:19:58.294]                     invokeRestart <- base::invokeRestart
[13:19:58.294]                     is.null <- base::is.null
[13:19:58.294]                     muffled <- FALSE
[13:19:58.294]                     if (inherits(cond, "message")) {
[13:19:58.294]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.294]                       if (muffled) 
[13:19:58.294]                         invokeRestart("muffleMessage")
[13:19:58.294]                     }
[13:19:58.294]                     else if (inherits(cond, "warning")) {
[13:19:58.294]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.294]                       if (muffled) 
[13:19:58.294]                         invokeRestart("muffleWarning")
[13:19:58.294]                     }
[13:19:58.294]                     else if (inherits(cond, "condition")) {
[13:19:58.294]                       if (!is.null(pattern)) {
[13:19:58.294]                         computeRestarts <- base::computeRestarts
[13:19:58.294]                         grepl <- base::grepl
[13:19:58.294]                         restarts <- computeRestarts(cond)
[13:19:58.294]                         for (restart in restarts) {
[13:19:58.294]                           name <- restart$name
[13:19:58.294]                           if (is.null(name)) 
[13:19:58.294]                             next
[13:19:58.294]                           if (!grepl(pattern, name)) 
[13:19:58.294]                             next
[13:19:58.294]                           invokeRestart(restart)
[13:19:58.294]                           muffled <- TRUE
[13:19:58.294]                           break
[13:19:58.294]                         }
[13:19:58.294]                       }
[13:19:58.294]                     }
[13:19:58.294]                     invisible(muffled)
[13:19:58.294]                   }
[13:19:58.294]                   muffleCondition(cond)
[13:19:58.294]                 })
[13:19:58.294]             }))
[13:19:58.294]             future::FutureResult(value = ...future.value$value, 
[13:19:58.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.294]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.294]                     ...future.globalenv.names))
[13:19:58.294]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.294]         }, condition = base::local({
[13:19:58.294]             c <- base::c
[13:19:58.294]             inherits <- base::inherits
[13:19:58.294]             invokeRestart <- base::invokeRestart
[13:19:58.294]             length <- base::length
[13:19:58.294]             list <- base::list
[13:19:58.294]             seq.int <- base::seq.int
[13:19:58.294]             signalCondition <- base::signalCondition
[13:19:58.294]             sys.calls <- base::sys.calls
[13:19:58.294]             `[[` <- base::`[[`
[13:19:58.294]             `+` <- base::`+`
[13:19:58.294]             `<<-` <- base::`<<-`
[13:19:58.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.294]                   3L)]
[13:19:58.294]             }
[13:19:58.294]             function(cond) {
[13:19:58.294]                 is_error <- inherits(cond, "error")
[13:19:58.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.294]                   NULL)
[13:19:58.294]                 if (is_error) {
[13:19:58.294]                   sessionInformation <- function() {
[13:19:58.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.294]                       search = base::search(), system = base::Sys.info())
[13:19:58.294]                   }
[13:19:58.294]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.294]                     cond$call), session = sessionInformation(), 
[13:19:58.294]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.294]                   signalCondition(cond)
[13:19:58.294]                 }
[13:19:58.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.294]                 "immediateCondition"))) {
[13:19:58.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.294]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.294]                   if (TRUE && !signal) {
[13:19:58.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.294]                     {
[13:19:58.294]                       inherits <- base::inherits
[13:19:58.294]                       invokeRestart <- base::invokeRestart
[13:19:58.294]                       is.null <- base::is.null
[13:19:58.294]                       muffled <- FALSE
[13:19:58.294]                       if (inherits(cond, "message")) {
[13:19:58.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.294]                         if (muffled) 
[13:19:58.294]                           invokeRestart("muffleMessage")
[13:19:58.294]                       }
[13:19:58.294]                       else if (inherits(cond, "warning")) {
[13:19:58.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.294]                         if (muffled) 
[13:19:58.294]                           invokeRestart("muffleWarning")
[13:19:58.294]                       }
[13:19:58.294]                       else if (inherits(cond, "condition")) {
[13:19:58.294]                         if (!is.null(pattern)) {
[13:19:58.294]                           computeRestarts <- base::computeRestarts
[13:19:58.294]                           grepl <- base::grepl
[13:19:58.294]                           restarts <- computeRestarts(cond)
[13:19:58.294]                           for (restart in restarts) {
[13:19:58.294]                             name <- restart$name
[13:19:58.294]                             if (is.null(name)) 
[13:19:58.294]                               next
[13:19:58.294]                             if (!grepl(pattern, name)) 
[13:19:58.294]                               next
[13:19:58.294]                             invokeRestart(restart)
[13:19:58.294]                             muffled <- TRUE
[13:19:58.294]                             break
[13:19:58.294]                           }
[13:19:58.294]                         }
[13:19:58.294]                       }
[13:19:58.294]                       invisible(muffled)
[13:19:58.294]                     }
[13:19:58.294]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.294]                   }
[13:19:58.294]                 }
[13:19:58.294]                 else {
[13:19:58.294]                   if (TRUE) {
[13:19:58.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.294]                     {
[13:19:58.294]                       inherits <- base::inherits
[13:19:58.294]                       invokeRestart <- base::invokeRestart
[13:19:58.294]                       is.null <- base::is.null
[13:19:58.294]                       muffled <- FALSE
[13:19:58.294]                       if (inherits(cond, "message")) {
[13:19:58.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.294]                         if (muffled) 
[13:19:58.294]                           invokeRestart("muffleMessage")
[13:19:58.294]                       }
[13:19:58.294]                       else if (inherits(cond, "warning")) {
[13:19:58.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.294]                         if (muffled) 
[13:19:58.294]                           invokeRestart("muffleWarning")
[13:19:58.294]                       }
[13:19:58.294]                       else if (inherits(cond, "condition")) {
[13:19:58.294]                         if (!is.null(pattern)) {
[13:19:58.294]                           computeRestarts <- base::computeRestarts
[13:19:58.294]                           grepl <- base::grepl
[13:19:58.294]                           restarts <- computeRestarts(cond)
[13:19:58.294]                           for (restart in restarts) {
[13:19:58.294]                             name <- restart$name
[13:19:58.294]                             if (is.null(name)) 
[13:19:58.294]                               next
[13:19:58.294]                             if (!grepl(pattern, name)) 
[13:19:58.294]                               next
[13:19:58.294]                             invokeRestart(restart)
[13:19:58.294]                             muffled <- TRUE
[13:19:58.294]                             break
[13:19:58.294]                           }
[13:19:58.294]                         }
[13:19:58.294]                       }
[13:19:58.294]                       invisible(muffled)
[13:19:58.294]                     }
[13:19:58.294]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.294]                   }
[13:19:58.294]                 }
[13:19:58.294]             }
[13:19:58.294]         }))
[13:19:58.294]     }, error = function(ex) {
[13:19:58.294]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.294]                 ...future.rng), started = ...future.startTime, 
[13:19:58.294]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.294]             version = "1.8"), class = "FutureResult")
[13:19:58.294]     }, finally = {
[13:19:58.294]         if (!identical(...future.workdir, getwd())) 
[13:19:58.294]             setwd(...future.workdir)
[13:19:58.294]         {
[13:19:58.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.294]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.294]             }
[13:19:58.294]             base::options(...future.oldOptions)
[13:19:58.294]             if (.Platform$OS.type == "windows") {
[13:19:58.294]                 old_names <- names(...future.oldEnvVars)
[13:19:58.294]                 envs <- base::Sys.getenv()
[13:19:58.294]                 names <- names(envs)
[13:19:58.294]                 common <- intersect(names, old_names)
[13:19:58.294]                 added <- setdiff(names, old_names)
[13:19:58.294]                 removed <- setdiff(old_names, names)
[13:19:58.294]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.294]                   envs[common]]
[13:19:58.294]                 NAMES <- toupper(changed)
[13:19:58.294]                 args <- list()
[13:19:58.294]                 for (kk in seq_along(NAMES)) {
[13:19:58.294]                   name <- changed[[kk]]
[13:19:58.294]                   NAME <- NAMES[[kk]]
[13:19:58.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.294]                     next
[13:19:58.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.294]                 }
[13:19:58.294]                 NAMES <- toupper(added)
[13:19:58.294]                 for (kk in seq_along(NAMES)) {
[13:19:58.294]                   name <- added[[kk]]
[13:19:58.294]                   NAME <- NAMES[[kk]]
[13:19:58.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.294]                     next
[13:19:58.294]                   args[[name]] <- ""
[13:19:58.294]                 }
[13:19:58.294]                 NAMES <- toupper(removed)
[13:19:58.294]                 for (kk in seq_along(NAMES)) {
[13:19:58.294]                   name <- removed[[kk]]
[13:19:58.294]                   NAME <- NAMES[[kk]]
[13:19:58.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.294]                     next
[13:19:58.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.294]                 }
[13:19:58.294]                 if (length(args) > 0) 
[13:19:58.294]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.294]             }
[13:19:58.294]             else {
[13:19:58.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.294]             }
[13:19:58.294]             {
[13:19:58.294]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.294]                   0L) {
[13:19:58.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.294]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.294]                   base::options(opts)
[13:19:58.294]                 }
[13:19:58.294]                 {
[13:19:58.294]                   {
[13:19:58.294]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.294]                     NULL
[13:19:58.294]                   }
[13:19:58.294]                   options(future.plan = NULL)
[13:19:58.294]                   if (is.na(NA_character_)) 
[13:19:58.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.294]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:58.294]                     envir = parent.frame()) 
[13:19:58.294]                   {
[13:19:58.294]                     default_workers <- missing(workers)
[13:19:58.294]                     if (is.function(workers)) 
[13:19:58.294]                       workers <- workers()
[13:19:58.294]                     workers <- structure(as.integer(workers), 
[13:19:58.294]                       class = class(workers))
[13:19:58.294]                     stop_if_not(is.finite(workers), workers >= 
[13:19:58.294]                       1L)
[13:19:58.294]                     if ((workers == 1L && !inherits(workers, 
[13:19:58.294]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:58.294]                       if (default_workers) 
[13:19:58.294]                         supportsMulticore(warn = TRUE)
[13:19:58.294]                       return(sequential(..., envir = envir))
[13:19:58.294]                     }
[13:19:58.294]                     oopts <- options(mc.cores = workers)
[13:19:58.294]                     on.exit(options(oopts))
[13:19:58.294]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:58.294]                       envir = envir)
[13:19:58.294]                     if (!future$lazy) 
[13:19:58.294]                       future <- run(future)
[13:19:58.294]                     invisible(future)
[13:19:58.294]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.294]                 }
[13:19:58.294]             }
[13:19:58.294]         }
[13:19:58.294]     })
[13:19:58.294]     if (TRUE) {
[13:19:58.294]         base::sink(type = "output", split = FALSE)
[13:19:58.294]         if (TRUE) {
[13:19:58.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.294]         }
[13:19:58.294]         else {
[13:19:58.294]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.294]         }
[13:19:58.294]         base::close(...future.stdout)
[13:19:58.294]         ...future.stdout <- NULL
[13:19:58.294]     }
[13:19:58.294]     ...future.result$conditions <- ...future.conditions
[13:19:58.294]     ...future.result$finished <- base::Sys.time()
[13:19:58.294]     ...future.result
[13:19:58.294] }
[13:19:58.297] assign_globals() ...
[13:19:58.297] List of 5
[13:19:58.297]  $ future.call.arguments    : list()
[13:19:58.297]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.297]  $ ...future.FUN            :function (x)  
[13:19:58.297]  $ ...future.elements_ii    :List of 1
[13:19:58.297]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[13:19:58.297]  $ ...future.seeds_ii       : NULL
[13:19:58.297]  $ ...future.globals.maxSize: num Inf
[13:19:58.297]  - attr(*, "resolved")= logi FALSE
[13:19:58.297]  - attr(*, "total_size")= num NA
[13:19:58.297]  - attr(*, "where")=List of 5
[13:19:58.297]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:58.297]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:58.297]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:58.297]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:58.297]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:58.297]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.297]  - attr(*, "already-done")= logi TRUE
[13:19:58.302] - copied ‘future.call.arguments’ to environment
[13:19:58.302] - copied ‘...future.FUN’ to environment
[13:19:58.302] - copied ‘...future.elements_ii’ to environment
[13:19:58.302] - copied ‘...future.seeds_ii’ to environment
[13:19:58.303] - copied ‘...future.globals.maxSize’ to environment
[13:19:58.303] assign_globals() ... done
[13:19:58.303] requestCore(): workers = 2
[13:19:58.305] MulticoreFuture started
[13:19:58.305] - Launch lazy future ... done
[13:19:58.306] run() for ‘MulticoreFuture’ ... done
[13:19:58.306] Created future:
[13:19:58.306] plan(): Setting new future strategy stack:
[13:19:58.306] List of future strategies:
[13:19:58.306] 1. sequential:
[13:19:58.306]    - args: function (..., envir = parent.frame())
[13:19:58.306]    - tweaked: FALSE
[13:19:58.306]    - call: NULL
[13:19:58.307] plan(): nbrOfWorkers() = 1
[13:19:58.309] plan(): Setting new future strategy stack:
[13:19:58.309] List of future strategies:
[13:19:58.309] 1. multicore:
[13:19:58.309]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:58.309]    - tweaked: FALSE
[13:19:58.309]    - call: plan(strategy)
[13:19:58.315] plan(): nbrOfWorkers() = 2
[13:19:58.306] MulticoreFuture:
[13:19:58.306] Label: ‘future_apply-1’
[13:19:58.306] Expression:
[13:19:58.306] {
[13:19:58.306]     do.call(function(...) {
[13:19:58.306]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.306]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.306]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.306]             on.exit(options(oopts), add = TRUE)
[13:19:58.306]         }
[13:19:58.306]         {
[13:19:58.306]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.306]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.306]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.306]             })
[13:19:58.306]         }
[13:19:58.306]     }, args = future.call.arguments)
[13:19:58.306] }
[13:19:58.306] Lazy evaluation: FALSE
[13:19:58.306] Asynchronous evaluation: TRUE
[13:19:58.306] Local evaluation: TRUE
[13:19:58.306] Environment: R_GlobalEnv
[13:19:58.306] Capture standard output: TRUE
[13:19:58.306] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:58.306] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:58.306] Packages: <none>
[13:19:58.306] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:58.306] Resolved: TRUE
[13:19:58.306] Value: <not collected>
[13:19:58.306] Conditions captured: <none>
[13:19:58.306] Early signaling: FALSE
[13:19:58.306] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:58.306] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.316] Chunk #1 of 2 ... DONE
[13:19:58.316] Chunk #2 of 2 ...
[13:19:58.316]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:58.316]  - seeds: <none>
[13:19:58.317]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.317] getGlobalsAndPackages() ...
[13:19:58.317] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.317] Resolving globals: FALSE
[13:19:58.317] Tweak future expression to call with '...' arguments ...
[13:19:58.317] {
[13:19:58.317]     do.call(function(...) {
[13:19:58.317]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.317]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.317]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.317]             on.exit(options(oopts), add = TRUE)
[13:19:58.317]         }
[13:19:58.317]         {
[13:19:58.317]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.317]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.317]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.317]             })
[13:19:58.317]         }
[13:19:58.317]     }, args = future.call.arguments)
[13:19:58.317] }
[13:19:58.318] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.319] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.319] 
[13:19:58.319] getGlobalsAndPackages() ... DONE
[13:19:58.319] run() for ‘Future’ ...
[13:19:58.320] - state: ‘created’
[13:19:58.320] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.325] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.325] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:58.325]   - Field: ‘label’
[13:19:58.325]   - Field: ‘local’
[13:19:58.325]   - Field: ‘owner’
[13:19:58.325]   - Field: ‘envir’
[13:19:58.326]   - Field: ‘workers’
[13:19:58.326]   - Field: ‘packages’
[13:19:58.326]   - Field: ‘gc’
[13:19:58.326]   - Field: ‘job’
[13:19:58.326]   - Field: ‘conditions’
[13:19:58.326]   - Field: ‘expr’
[13:19:58.326]   - Field: ‘uuid’
[13:19:58.327]   - Field: ‘seed’
[13:19:58.327]   - Field: ‘version’
[13:19:58.327]   - Field: ‘result’
[13:19:58.327]   - Field: ‘asynchronous’
[13:19:58.327]   - Field: ‘calls’
[13:19:58.327]   - Field: ‘globals’
[13:19:58.327]   - Field: ‘stdout’
[13:19:58.328]   - Field: ‘earlySignal’
[13:19:58.328]   - Field: ‘lazy’
[13:19:58.328]   - Field: ‘state’
[13:19:58.328] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:58.328] - Launch lazy future ...
[13:19:58.329] Packages needed by the future expression (n = 0): <none>
[13:19:58.329] Packages needed by future strategies (n = 0): <none>
[13:19:58.330] {
[13:19:58.330]     {
[13:19:58.330]         {
[13:19:58.330]             ...future.startTime <- base::Sys.time()
[13:19:58.330]             {
[13:19:58.330]                 {
[13:19:58.330]                   {
[13:19:58.330]                     {
[13:19:58.330]                       base::local({
[13:19:58.330]                         has_future <- base::requireNamespace("future", 
[13:19:58.330]                           quietly = TRUE)
[13:19:58.330]                         if (has_future) {
[13:19:58.330]                           ns <- base::getNamespace("future")
[13:19:58.330]                           version <- ns[[".package"]][["version"]]
[13:19:58.330]                           if (is.null(version)) 
[13:19:58.330]                             version <- utils::packageVersion("future")
[13:19:58.330]                         }
[13:19:58.330]                         else {
[13:19:58.330]                           version <- NULL
[13:19:58.330]                         }
[13:19:58.330]                         if (!has_future || version < "1.8.0") {
[13:19:58.330]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.330]                             "", base::R.version$version.string), 
[13:19:58.330]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:58.330]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.330]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.330]                               "release", "version")], collapse = " "), 
[13:19:58.330]                             hostname = base::Sys.info()[["nodename"]])
[13:19:58.330]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.330]                             info)
[13:19:58.330]                           info <- base::paste(info, collapse = "; ")
[13:19:58.330]                           if (!has_future) {
[13:19:58.330]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.330]                               info)
[13:19:58.330]                           }
[13:19:58.330]                           else {
[13:19:58.330]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.330]                               info, version)
[13:19:58.330]                           }
[13:19:58.330]                           base::stop(msg)
[13:19:58.330]                         }
[13:19:58.330]                       })
[13:19:58.330]                     }
[13:19:58.330]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.330]                     base::options(mc.cores = 1L)
[13:19:58.330]                   }
[13:19:58.330]                   options(future.plan = NULL)
[13:19:58.330]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.330]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.330]                 }
[13:19:58.330]                 ...future.workdir <- getwd()
[13:19:58.330]             }
[13:19:58.330]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.330]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.330]         }
[13:19:58.330]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.330]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:58.330]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.330]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.330]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.330]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.330]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.330]             base::names(...future.oldOptions))
[13:19:58.330]     }
[13:19:58.330]     if (FALSE) {
[13:19:58.330]     }
[13:19:58.330]     else {
[13:19:58.330]         if (TRUE) {
[13:19:58.330]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.330]                 open = "w")
[13:19:58.330]         }
[13:19:58.330]         else {
[13:19:58.330]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.330]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.330]         }
[13:19:58.330]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.330]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.330]             base::sink(type = "output", split = FALSE)
[13:19:58.330]             base::close(...future.stdout)
[13:19:58.330]         }, add = TRUE)
[13:19:58.330]     }
[13:19:58.330]     ...future.frame <- base::sys.nframe()
[13:19:58.330]     ...future.conditions <- base::list()
[13:19:58.330]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.330]     if (FALSE) {
[13:19:58.330]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.330]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.330]     }
[13:19:58.330]     ...future.result <- base::tryCatch({
[13:19:58.330]         base::withCallingHandlers({
[13:19:58.330]             ...future.value <- base::withVisible(base::local({
[13:19:58.330]                 withCallingHandlers({
[13:19:58.330]                   {
[13:19:58.330]                     do.call(function(...) {
[13:19:58.330]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.330]                       if (!identical(...future.globals.maxSize.org, 
[13:19:58.330]                         ...future.globals.maxSize)) {
[13:19:58.330]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.330]                         on.exit(options(oopts), add = TRUE)
[13:19:58.330]                       }
[13:19:58.330]                       {
[13:19:58.330]                         lapply(seq_along(...future.elements_ii), 
[13:19:58.330]                           FUN = function(jj) {
[13:19:58.330]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.330]                             ...future.FUN(...future.X_jj, ...)
[13:19:58.330]                           })
[13:19:58.330]                       }
[13:19:58.330]                     }, args = future.call.arguments)
[13:19:58.330]                   }
[13:19:58.330]                 }, immediateCondition = function(cond) {
[13:19:58.330]                   save_rds <- function (object, pathname, ...) 
[13:19:58.330]                   {
[13:19:58.330]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:58.330]                     if (file_test("-f", pathname_tmp)) {
[13:19:58.330]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.330]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:58.330]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.330]                         fi_tmp[["mtime"]])
[13:19:58.330]                     }
[13:19:58.330]                     tryCatch({
[13:19:58.330]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:58.330]                     }, error = function(ex) {
[13:19:58.330]                       msg <- conditionMessage(ex)
[13:19:58.330]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.330]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:58.330]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.330]                         fi_tmp[["mtime"]], msg)
[13:19:58.330]                       ex$message <- msg
[13:19:58.330]                       stop(ex)
[13:19:58.330]                     })
[13:19:58.330]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:58.330]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:58.330]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:58.330]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.330]                       fi <- file.info(pathname)
[13:19:58.330]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:58.330]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.330]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:58.330]                         fi[["size"]], fi[["mtime"]])
[13:19:58.330]                       stop(msg)
[13:19:58.330]                     }
[13:19:58.330]                     invisible(pathname)
[13:19:58.330]                   }
[13:19:58.330]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:58.330]                     rootPath = tempdir()) 
[13:19:58.330]                   {
[13:19:58.330]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:58.330]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:58.330]                       tmpdir = path, fileext = ".rds")
[13:19:58.330]                     save_rds(obj, file)
[13:19:58.330]                   }
[13:19:58.330]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:58.330]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.330]                   {
[13:19:58.330]                     inherits <- base::inherits
[13:19:58.330]                     invokeRestart <- base::invokeRestart
[13:19:58.330]                     is.null <- base::is.null
[13:19:58.330]                     muffled <- FALSE
[13:19:58.330]                     if (inherits(cond, "message")) {
[13:19:58.330]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.330]                       if (muffled) 
[13:19:58.330]                         invokeRestart("muffleMessage")
[13:19:58.330]                     }
[13:19:58.330]                     else if (inherits(cond, "warning")) {
[13:19:58.330]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.330]                       if (muffled) 
[13:19:58.330]                         invokeRestart("muffleWarning")
[13:19:58.330]                     }
[13:19:58.330]                     else if (inherits(cond, "condition")) {
[13:19:58.330]                       if (!is.null(pattern)) {
[13:19:58.330]                         computeRestarts <- base::computeRestarts
[13:19:58.330]                         grepl <- base::grepl
[13:19:58.330]                         restarts <- computeRestarts(cond)
[13:19:58.330]                         for (restart in restarts) {
[13:19:58.330]                           name <- restart$name
[13:19:58.330]                           if (is.null(name)) 
[13:19:58.330]                             next
[13:19:58.330]                           if (!grepl(pattern, name)) 
[13:19:58.330]                             next
[13:19:58.330]                           invokeRestart(restart)
[13:19:58.330]                           muffled <- TRUE
[13:19:58.330]                           break
[13:19:58.330]                         }
[13:19:58.330]                       }
[13:19:58.330]                     }
[13:19:58.330]                     invisible(muffled)
[13:19:58.330]                   }
[13:19:58.330]                   muffleCondition(cond)
[13:19:58.330]                 })
[13:19:58.330]             }))
[13:19:58.330]             future::FutureResult(value = ...future.value$value, 
[13:19:58.330]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.330]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.330]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.330]                     ...future.globalenv.names))
[13:19:58.330]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.330]         }, condition = base::local({
[13:19:58.330]             c <- base::c
[13:19:58.330]             inherits <- base::inherits
[13:19:58.330]             invokeRestart <- base::invokeRestart
[13:19:58.330]             length <- base::length
[13:19:58.330]             list <- base::list
[13:19:58.330]             seq.int <- base::seq.int
[13:19:58.330]             signalCondition <- base::signalCondition
[13:19:58.330]             sys.calls <- base::sys.calls
[13:19:58.330]             `[[` <- base::`[[`
[13:19:58.330]             `+` <- base::`+`
[13:19:58.330]             `<<-` <- base::`<<-`
[13:19:58.330]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.330]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.330]                   3L)]
[13:19:58.330]             }
[13:19:58.330]             function(cond) {
[13:19:58.330]                 is_error <- inherits(cond, "error")
[13:19:58.330]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.330]                   NULL)
[13:19:58.330]                 if (is_error) {
[13:19:58.330]                   sessionInformation <- function() {
[13:19:58.330]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.330]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.330]                       search = base::search(), system = base::Sys.info())
[13:19:58.330]                   }
[13:19:58.330]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.330]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.330]                     cond$call), session = sessionInformation(), 
[13:19:58.330]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.330]                   signalCondition(cond)
[13:19:58.330]                 }
[13:19:58.330]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.330]                 "immediateCondition"))) {
[13:19:58.330]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.330]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.330]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.330]                   if (TRUE && !signal) {
[13:19:58.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.330]                     {
[13:19:58.330]                       inherits <- base::inherits
[13:19:58.330]                       invokeRestart <- base::invokeRestart
[13:19:58.330]                       is.null <- base::is.null
[13:19:58.330]                       muffled <- FALSE
[13:19:58.330]                       if (inherits(cond, "message")) {
[13:19:58.330]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.330]                         if (muffled) 
[13:19:58.330]                           invokeRestart("muffleMessage")
[13:19:58.330]                       }
[13:19:58.330]                       else if (inherits(cond, "warning")) {
[13:19:58.330]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.330]                         if (muffled) 
[13:19:58.330]                           invokeRestart("muffleWarning")
[13:19:58.330]                       }
[13:19:58.330]                       else if (inherits(cond, "condition")) {
[13:19:58.330]                         if (!is.null(pattern)) {
[13:19:58.330]                           computeRestarts <- base::computeRestarts
[13:19:58.330]                           grepl <- base::grepl
[13:19:58.330]                           restarts <- computeRestarts(cond)
[13:19:58.330]                           for (restart in restarts) {
[13:19:58.330]                             name <- restart$name
[13:19:58.330]                             if (is.null(name)) 
[13:19:58.330]                               next
[13:19:58.330]                             if (!grepl(pattern, name)) 
[13:19:58.330]                               next
[13:19:58.330]                             invokeRestart(restart)
[13:19:58.330]                             muffled <- TRUE
[13:19:58.330]                             break
[13:19:58.330]                           }
[13:19:58.330]                         }
[13:19:58.330]                       }
[13:19:58.330]                       invisible(muffled)
[13:19:58.330]                     }
[13:19:58.330]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.330]                   }
[13:19:58.330]                 }
[13:19:58.330]                 else {
[13:19:58.330]                   if (TRUE) {
[13:19:58.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.330]                     {
[13:19:58.330]                       inherits <- base::inherits
[13:19:58.330]                       invokeRestart <- base::invokeRestart
[13:19:58.330]                       is.null <- base::is.null
[13:19:58.330]                       muffled <- FALSE
[13:19:58.330]                       if (inherits(cond, "message")) {
[13:19:58.330]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.330]                         if (muffled) 
[13:19:58.330]                           invokeRestart("muffleMessage")
[13:19:58.330]                       }
[13:19:58.330]                       else if (inherits(cond, "warning")) {
[13:19:58.330]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.330]                         if (muffled) 
[13:19:58.330]                           invokeRestart("muffleWarning")
[13:19:58.330]                       }
[13:19:58.330]                       else if (inherits(cond, "condition")) {
[13:19:58.330]                         if (!is.null(pattern)) {
[13:19:58.330]                           computeRestarts <- base::computeRestarts
[13:19:58.330]                           grepl <- base::grepl
[13:19:58.330]                           restarts <- computeRestarts(cond)
[13:19:58.330]                           for (restart in restarts) {
[13:19:58.330]                             name <- restart$name
[13:19:58.330]                             if (is.null(name)) 
[13:19:58.330]                               next
[13:19:58.330]                             if (!grepl(pattern, name)) 
[13:19:58.330]                               next
[13:19:58.330]                             invokeRestart(restart)
[13:19:58.330]                             muffled <- TRUE
[13:19:58.330]                             break
[13:19:58.330]                           }
[13:19:58.330]                         }
[13:19:58.330]                       }
[13:19:58.330]                       invisible(muffled)
[13:19:58.330]                     }
[13:19:58.330]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.330]                   }
[13:19:58.330]                 }
[13:19:58.330]             }
[13:19:58.330]         }))
[13:19:58.330]     }, error = function(ex) {
[13:19:58.330]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.330]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.330]                 ...future.rng), started = ...future.startTime, 
[13:19:58.330]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.330]             version = "1.8"), class = "FutureResult")
[13:19:58.330]     }, finally = {
[13:19:58.330]         if (!identical(...future.workdir, getwd())) 
[13:19:58.330]             setwd(...future.workdir)
[13:19:58.330]         {
[13:19:58.330]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.330]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.330]             }
[13:19:58.330]             base::options(...future.oldOptions)
[13:19:58.330]             if (.Platform$OS.type == "windows") {
[13:19:58.330]                 old_names <- names(...future.oldEnvVars)
[13:19:58.330]                 envs <- base::Sys.getenv()
[13:19:58.330]                 names <- names(envs)
[13:19:58.330]                 common <- intersect(names, old_names)
[13:19:58.330]                 added <- setdiff(names, old_names)
[13:19:58.330]                 removed <- setdiff(old_names, names)
[13:19:58.330]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.330]                   envs[common]]
[13:19:58.330]                 NAMES <- toupper(changed)
[13:19:58.330]                 args <- list()
[13:19:58.330]                 for (kk in seq_along(NAMES)) {
[13:19:58.330]                   name <- changed[[kk]]
[13:19:58.330]                   NAME <- NAMES[[kk]]
[13:19:58.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.330]                     next
[13:19:58.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.330]                 }
[13:19:58.330]                 NAMES <- toupper(added)
[13:19:58.330]                 for (kk in seq_along(NAMES)) {
[13:19:58.330]                   name <- added[[kk]]
[13:19:58.330]                   NAME <- NAMES[[kk]]
[13:19:58.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.330]                     next
[13:19:58.330]                   args[[name]] <- ""
[13:19:58.330]                 }
[13:19:58.330]                 NAMES <- toupper(removed)
[13:19:58.330]                 for (kk in seq_along(NAMES)) {
[13:19:58.330]                   name <- removed[[kk]]
[13:19:58.330]                   NAME <- NAMES[[kk]]
[13:19:58.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.330]                     next
[13:19:58.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.330]                 }
[13:19:58.330]                 if (length(args) > 0) 
[13:19:58.330]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.330]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.330]             }
[13:19:58.330]             else {
[13:19:58.330]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.330]             }
[13:19:58.330]             {
[13:19:58.330]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.330]                   0L) {
[13:19:58.330]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.330]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.330]                   base::options(opts)
[13:19:58.330]                 }
[13:19:58.330]                 {
[13:19:58.330]                   {
[13:19:58.330]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.330]                     NULL
[13:19:58.330]                   }
[13:19:58.330]                   options(future.plan = NULL)
[13:19:58.330]                   if (is.na(NA_character_)) 
[13:19:58.330]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.330]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.330]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:58.330]                     envir = parent.frame()) 
[13:19:58.330]                   {
[13:19:58.330]                     default_workers <- missing(workers)
[13:19:58.330]                     if (is.function(workers)) 
[13:19:58.330]                       workers <- workers()
[13:19:58.330]                     workers <- structure(as.integer(workers), 
[13:19:58.330]                       class = class(workers))
[13:19:58.330]                     stop_if_not(is.finite(workers), workers >= 
[13:19:58.330]                       1L)
[13:19:58.330]                     if ((workers == 1L && !inherits(workers, 
[13:19:58.330]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:58.330]                       if (default_workers) 
[13:19:58.330]                         supportsMulticore(warn = TRUE)
[13:19:58.330]                       return(sequential(..., envir = envir))
[13:19:58.330]                     }
[13:19:58.330]                     oopts <- options(mc.cores = workers)
[13:19:58.330]                     on.exit(options(oopts))
[13:19:58.330]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:58.330]                       envir = envir)
[13:19:58.330]                     if (!future$lazy) 
[13:19:58.330]                       future <- run(future)
[13:19:58.330]                     invisible(future)
[13:19:58.330]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.330]                 }
[13:19:58.330]             }
[13:19:58.330]         }
[13:19:58.330]     })
[13:19:58.330]     if (TRUE) {
[13:19:58.330]         base::sink(type = "output", split = FALSE)
[13:19:58.330]         if (TRUE) {
[13:19:58.330]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.330]         }
[13:19:58.330]         else {
[13:19:58.330]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.330]         }
[13:19:58.330]         base::close(...future.stdout)
[13:19:58.330]         ...future.stdout <- NULL
[13:19:58.330]     }
[13:19:58.330]     ...future.result$conditions <- ...future.conditions
[13:19:58.330]     ...future.result$finished <- base::Sys.time()
[13:19:58.330]     ...future.result
[13:19:58.330] }
[13:19:58.333] assign_globals() ...
[13:19:58.333] List of 5
[13:19:58.333]  $ future.call.arguments    : list()
[13:19:58.333]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.333]  $ ...future.FUN            :function (x)  
[13:19:58.333]  $ ...future.elements_ii    :List of 1
[13:19:58.333]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[13:19:58.333]  $ ...future.seeds_ii       : NULL
[13:19:58.333]  $ ...future.globals.maxSize: num Inf
[13:19:58.333]  - attr(*, "resolved")= logi FALSE
[13:19:58.333]  - attr(*, "total_size")= num NA
[13:19:58.333]  - attr(*, "where")=List of 5
[13:19:58.333]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:58.333]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:58.333]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:58.333]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:58.333]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:58.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.333]  - attr(*, "already-done")= logi TRUE
[13:19:58.347] - copied ‘future.call.arguments’ to environment
[13:19:58.347] - copied ‘...future.FUN’ to environment
[13:19:58.347] - copied ‘...future.elements_ii’ to environment
[13:19:58.347] - copied ‘...future.seeds_ii’ to environment
[13:19:58.347] - copied ‘...future.globals.maxSize’ to environment
[13:19:58.347] assign_globals() ... done
[13:19:58.348] requestCore(): workers = 2
[13:19:58.350] MulticoreFuture started
[13:19:58.351] - Launch lazy future ... done
[13:19:58.351] run() for ‘MulticoreFuture’ ... done
[13:19:58.351] Created future:
[13:19:58.351] plan(): Setting new future strategy stack:
[13:19:58.352] List of future strategies:
[13:19:58.352] 1. sequential:
[13:19:58.352]    - args: function (..., envir = parent.frame())
[13:19:58.352]    - tweaked: FALSE
[13:19:58.352]    - call: NULL
[13:19:58.353] plan(): nbrOfWorkers() = 1
[13:19:58.355] plan(): Setting new future strategy stack:
[13:19:58.355] List of future strategies:
[13:19:58.355] 1. multicore:
[13:19:58.355]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:58.355]    - tweaked: FALSE
[13:19:58.355]    - call: plan(strategy)
[13:19:58.361] plan(): nbrOfWorkers() = 2
[13:19:58.351] MulticoreFuture:
[13:19:58.351] Label: ‘future_apply-2’
[13:19:58.351] Expression:
[13:19:58.351] {
[13:19:58.351]     do.call(function(...) {
[13:19:58.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.351]             on.exit(options(oopts), add = TRUE)
[13:19:58.351]         }
[13:19:58.351]         {
[13:19:58.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.351]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.351]             })
[13:19:58.351]         }
[13:19:58.351]     }, args = future.call.arguments)
[13:19:58.351] }
[13:19:58.351] Lazy evaluation: FALSE
[13:19:58.351] Asynchronous evaluation: TRUE
[13:19:58.351] Local evaluation: TRUE
[13:19:58.351] Environment: R_GlobalEnv
[13:19:58.351] Capture standard output: TRUE
[13:19:58.351] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:58.351] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:58.351] Packages: <none>
[13:19:58.351] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:58.351] Resolved: TRUE
[13:19:58.351] Value: <not collected>
[13:19:58.351] Conditions captured: <none>
[13:19:58.351] Early signaling: FALSE
[13:19:58.351] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:58.351] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.362] Chunk #2 of 2 ... DONE
[13:19:58.362] Launching 2 futures (chunks) ... DONE
[13:19:58.362] Resolving 2 futures (chunks) ...
[13:19:58.363] resolve() on list ...
[13:19:58.363]  recursive: 0
[13:19:58.363]  length: 2
[13:19:58.363] 
[13:19:58.364] Future #1
[13:19:58.364] result() for MulticoreFuture ...
[13:19:58.365] result() for MulticoreFuture ...
[13:19:58.365] result() for MulticoreFuture ... done
[13:19:58.365] result() for MulticoreFuture ... done
[13:19:58.365] result() for MulticoreFuture ...
[13:19:58.365] result() for MulticoreFuture ... done
[13:19:58.366] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:58.366] - nx: 2
[13:19:58.366] - relay: TRUE
[13:19:58.366] - stdout: TRUE
[13:19:58.366] - signal: TRUE
[13:19:58.366] - resignal: FALSE
[13:19:58.367] - force: TRUE
[13:19:58.367] - relayed: [n=2] FALSE, FALSE
[13:19:58.367] - queued futures: [n=2] FALSE, FALSE
[13:19:58.367]  - until=1
[13:19:58.367]  - relaying element #1
[13:19:58.367] result() for MulticoreFuture ...
[13:19:58.367] result() for MulticoreFuture ... done
[13:19:58.368] result() for MulticoreFuture ...
[13:19:58.368] result() for MulticoreFuture ... done
[13:19:58.368] result() for MulticoreFuture ...
[13:19:58.368] result() for MulticoreFuture ... done
[13:19:58.368] result() for MulticoreFuture ...
[13:19:58.368] result() for MulticoreFuture ... done
[13:19:58.369] - relayed: [n=2] TRUE, FALSE
[13:19:58.369] - queued futures: [n=2] TRUE, FALSE
[13:19:58.369] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:58.369]  length: 1 (resolved future 1)
[13:19:58.369] Future #2
[13:19:58.370] result() for MulticoreFuture ...
[13:19:58.370] result() for MulticoreFuture ...
[13:19:58.370] result() for MulticoreFuture ... done
[13:19:58.371] result() for MulticoreFuture ... done
[13:19:58.371] result() for MulticoreFuture ...
[13:19:58.371] result() for MulticoreFuture ... done
[13:19:58.371] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:58.371] - nx: 2
[13:19:58.371] - relay: TRUE
[13:19:58.372] - stdout: TRUE
[13:19:58.372] - signal: TRUE
[13:19:58.372] - resignal: FALSE
[13:19:58.372] - force: TRUE
[13:19:58.372] - relayed: [n=2] TRUE, FALSE
[13:19:58.372] - queued futures: [n=2] TRUE, FALSE
[13:19:58.372]  - until=2
[13:19:58.372]  - relaying element #2
[13:19:58.373] result() for MulticoreFuture ...
[13:19:58.373] result() for MulticoreFuture ... done
[13:19:58.373] result() for MulticoreFuture ...
[13:19:58.373] result() for MulticoreFuture ... done
[13:19:58.373] result() for MulticoreFuture ...
[13:19:58.373] result() for MulticoreFuture ... done
[13:19:58.373] result() for MulticoreFuture ...
[13:19:58.373] result() for MulticoreFuture ... done
[13:19:58.374] - relayed: [n=2] TRUE, TRUE
[13:19:58.374] - queued futures: [n=2] TRUE, TRUE
[13:19:58.374] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:58.374]  length: 0 (resolved future 2)
[13:19:58.374] Relaying remaining futures
[13:19:58.374] signalConditionsASAP(NULL, pos=0) ...
[13:19:58.374] - nx: 2
[13:19:58.374] - relay: TRUE
[13:19:58.375] - stdout: TRUE
[13:19:58.375] - signal: TRUE
[13:19:58.375] - resignal: FALSE
[13:19:58.375] - force: TRUE
[13:19:58.375] - relayed: [n=2] TRUE, TRUE
[13:19:58.375] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:58.375] - relayed: [n=2] TRUE, TRUE
[13:19:58.375] - queued futures: [n=2] TRUE, TRUE
[13:19:58.375] signalConditionsASAP(NULL, pos=0) ... done
[13:19:58.376] resolve() on list ... DONE
[13:19:58.376] result() for MulticoreFuture ...
[13:19:58.376] result() for MulticoreFuture ... done
[13:19:58.376] result() for MulticoreFuture ...
[13:19:58.376] result() for MulticoreFuture ... done
[13:19:58.376] result() for MulticoreFuture ...
[13:19:58.376] result() for MulticoreFuture ... done
[13:19:58.376] result() for MulticoreFuture ...
[13:19:58.377] result() for MulticoreFuture ... done
[13:19:58.377]  - Number of value chunks collected: 2
[13:19:58.377] Resolving 2 futures (chunks) ... DONE
[13:19:58.377] Reducing values from 2 chunks ...
[13:19:58.377]  - Number of values collected after concatenation: 2
[13:19:58.377]  - Number of values expected: 2
[13:19:58.377] Reducing values from 2 chunks ... DONE
[13:19:58.377] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[13:19:58.378] getGlobalsAndPackagesXApply() ...
[13:19:58.378]  - future.globals: TRUE
[13:19:58.378] getGlobalsAndPackages() ...
[13:19:58.378] Searching for globals...
[13:19:58.384] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[13:19:58.384] Searching for globals ... DONE
[13:19:58.385] Resolving globals: FALSE
[13:19:58.385] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[13:19:58.386] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[13:19:58.386] - globals: [1] ‘FUN’
[13:19:58.386] 
[13:19:58.386] getGlobalsAndPackages() ... DONE
[13:19:58.387]  - globals found/used: [n=1] ‘FUN’
[13:19:58.387]  - needed namespaces: [n=0] 
[13:19:58.387] Finding globals ... DONE
[13:19:58.387]  - use_args: TRUE
[13:19:58.387]  - Getting '...' globals ...
[13:19:58.387] resolve() on list ...
[13:19:58.388]  recursive: 0
[13:19:58.388]  length: 1
[13:19:58.388]  elements: ‘...’
[13:19:58.388]  length: 0 (resolved future 1)
[13:19:58.388] resolve() on list ... DONE
[13:19:58.388]    - '...' content: [n=0] 
[13:19:58.388] List of 1
[13:19:58.388]  $ ...: list()
[13:19:58.388]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.388]  - attr(*, "where")=List of 1
[13:19:58.388]   ..$ ...:<environment: 0x555922ad1978> 
[13:19:58.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.388]  - attr(*, "resolved")= logi TRUE
[13:19:58.388]  - attr(*, "total_size")= num NA
[13:19:58.391]  - Getting '...' globals ... DONE
[13:19:58.391] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:58.392] List of 2
[13:19:58.392]  $ ...future.FUN:function (x)  
[13:19:58.392]  $ ...          : list()
[13:19:58.392]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.392]  - attr(*, "where")=List of 2
[13:19:58.392]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:58.392]   ..$ ...          :<environment: 0x555922ad1978> 
[13:19:58.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.392]  - attr(*, "resolved")= logi FALSE
[13:19:58.392]  - attr(*, "total_size")= num 9888
[13:19:58.394] Packages to be attached in all futures: [n=0] 
[13:19:58.394] getGlobalsAndPackagesXApply() ... DONE
[13:19:58.398] future_lapply() ...
[13:19:58.403] Number of chunks: 2
[13:19:58.403] getGlobalsAndPackagesXApply() ...
[13:19:58.403]  - future.globals: <name-value list> with names ‘list()’
[13:19:58.403]  - use_args: TRUE
[13:19:58.404] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:58.404] List of 2
[13:19:58.404]  $ ...          : list()
[13:19:58.404]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.404]  $ ...future.FUN:function (x)  
[13:19:58.404]  - attr(*, "where")=List of 2
[13:19:58.404]   ..$ ...          :<environment: 0x555922ad1978> 
[13:19:58.404]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:19:58.404]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.404]  - attr(*, "resolved")= logi FALSE
[13:19:58.404]  - attr(*, "total_size")= num NA
[13:19:58.407] Packages to be attached in all futures: [n=0] 
[13:19:58.407] getGlobalsAndPackagesXApply() ... DONE
[13:19:58.407] Number of futures (= number of chunks): 2
[13:19:58.407] Launching 2 futures (chunks) ...
[13:19:58.407] Chunk #1 of 2 ...
[13:19:58.407]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:58.407]  - seeds: <none>
[13:19:58.408]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.408] getGlobalsAndPackages() ...
[13:19:58.408] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.411] Resolving globals: FALSE
[13:19:58.411] Tweak future expression to call with '...' arguments ...
[13:19:58.411] {
[13:19:58.411]     do.call(function(...) {
[13:19:58.411]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.411]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.411]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.411]             on.exit(options(oopts), add = TRUE)
[13:19:58.411]         }
[13:19:58.411]         {
[13:19:58.411]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.411]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.411]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.411]             })
[13:19:58.411]         }
[13:19:58.411]     }, args = future.call.arguments)
[13:19:58.411] }
[13:19:58.412] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.413] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.413] 
[13:19:58.413] getGlobalsAndPackages() ... DONE
[13:19:58.413] run() for ‘Future’ ...
[13:19:58.414] - state: ‘created’
[13:19:58.414] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.418] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.418] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:58.419]   - Field: ‘label’
[13:19:58.419]   - Field: ‘local’
[13:19:58.419]   - Field: ‘owner’
[13:19:58.419]   - Field: ‘envir’
[13:19:58.419]   - Field: ‘workers’
[13:19:58.419]   - Field: ‘packages’
[13:19:58.419]   - Field: ‘gc’
[13:19:58.419]   - Field: ‘job’
[13:19:58.419]   - Field: ‘conditions’
[13:19:58.420]   - Field: ‘expr’
[13:19:58.420]   - Field: ‘uuid’
[13:19:58.420]   - Field: ‘seed’
[13:19:58.420]   - Field: ‘version’
[13:19:58.420]   - Field: ‘result’
[13:19:58.420]   - Field: ‘asynchronous’
[13:19:58.420]   - Field: ‘calls’
[13:19:58.420]   - Field: ‘globals’
[13:19:58.420]   - Field: ‘stdout’
[13:19:58.421]   - Field: ‘earlySignal’
[13:19:58.421]   - Field: ‘lazy’
[13:19:58.421]   - Field: ‘state’
[13:19:58.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:58.421] - Launch lazy future ...
[13:19:58.421] Packages needed by the future expression (n = 0): <none>
[13:19:58.421] Packages needed by future strategies (n = 0): <none>
[13:19:58.422] {
[13:19:58.422]     {
[13:19:58.422]         {
[13:19:58.422]             ...future.startTime <- base::Sys.time()
[13:19:58.422]             {
[13:19:58.422]                 {
[13:19:58.422]                   {
[13:19:58.422]                     {
[13:19:58.422]                       base::local({
[13:19:58.422]                         has_future <- base::requireNamespace("future", 
[13:19:58.422]                           quietly = TRUE)
[13:19:58.422]                         if (has_future) {
[13:19:58.422]                           ns <- base::getNamespace("future")
[13:19:58.422]                           version <- ns[[".package"]][["version"]]
[13:19:58.422]                           if (is.null(version)) 
[13:19:58.422]                             version <- utils::packageVersion("future")
[13:19:58.422]                         }
[13:19:58.422]                         else {
[13:19:58.422]                           version <- NULL
[13:19:58.422]                         }
[13:19:58.422]                         if (!has_future || version < "1.8.0") {
[13:19:58.422]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.422]                             "", base::R.version$version.string), 
[13:19:58.422]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:58.422]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.422]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.422]                               "release", "version")], collapse = " "), 
[13:19:58.422]                             hostname = base::Sys.info()[["nodename"]])
[13:19:58.422]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.422]                             info)
[13:19:58.422]                           info <- base::paste(info, collapse = "; ")
[13:19:58.422]                           if (!has_future) {
[13:19:58.422]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.422]                               info)
[13:19:58.422]                           }
[13:19:58.422]                           else {
[13:19:58.422]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.422]                               info, version)
[13:19:58.422]                           }
[13:19:58.422]                           base::stop(msg)
[13:19:58.422]                         }
[13:19:58.422]                       })
[13:19:58.422]                     }
[13:19:58.422]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.422]                     base::options(mc.cores = 1L)
[13:19:58.422]                   }
[13:19:58.422]                   options(future.plan = NULL)
[13:19:58.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.422]                 }
[13:19:58.422]                 ...future.workdir <- getwd()
[13:19:58.422]             }
[13:19:58.422]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.422]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.422]         }
[13:19:58.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.422]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:58.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.422]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.422]             base::names(...future.oldOptions))
[13:19:58.422]     }
[13:19:58.422]     if (FALSE) {
[13:19:58.422]     }
[13:19:58.422]     else {
[13:19:58.422]         if (TRUE) {
[13:19:58.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.422]                 open = "w")
[13:19:58.422]         }
[13:19:58.422]         else {
[13:19:58.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.422]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.422]         }
[13:19:58.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.422]             base::sink(type = "output", split = FALSE)
[13:19:58.422]             base::close(...future.stdout)
[13:19:58.422]         }, add = TRUE)
[13:19:58.422]     }
[13:19:58.422]     ...future.frame <- base::sys.nframe()
[13:19:58.422]     ...future.conditions <- base::list()
[13:19:58.422]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.422]     if (FALSE) {
[13:19:58.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.422]     }
[13:19:58.422]     ...future.result <- base::tryCatch({
[13:19:58.422]         base::withCallingHandlers({
[13:19:58.422]             ...future.value <- base::withVisible(base::local({
[13:19:58.422]                 withCallingHandlers({
[13:19:58.422]                   {
[13:19:58.422]                     do.call(function(...) {
[13:19:58.422]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.422]                       if (!identical(...future.globals.maxSize.org, 
[13:19:58.422]                         ...future.globals.maxSize)) {
[13:19:58.422]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.422]                         on.exit(options(oopts), add = TRUE)
[13:19:58.422]                       }
[13:19:58.422]                       {
[13:19:58.422]                         lapply(seq_along(...future.elements_ii), 
[13:19:58.422]                           FUN = function(jj) {
[13:19:58.422]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.422]                             ...future.FUN(...future.X_jj, ...)
[13:19:58.422]                           })
[13:19:58.422]                       }
[13:19:58.422]                     }, args = future.call.arguments)
[13:19:58.422]                   }
[13:19:58.422]                 }, immediateCondition = function(cond) {
[13:19:58.422]                   save_rds <- function (object, pathname, ...) 
[13:19:58.422]                   {
[13:19:58.422]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:58.422]                     if (file_test("-f", pathname_tmp)) {
[13:19:58.422]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.422]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:58.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.422]                         fi_tmp[["mtime"]])
[13:19:58.422]                     }
[13:19:58.422]                     tryCatch({
[13:19:58.422]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:58.422]                     }, error = function(ex) {
[13:19:58.422]                       msg <- conditionMessage(ex)
[13:19:58.422]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.422]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:58.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.422]                         fi_tmp[["mtime"]], msg)
[13:19:58.422]                       ex$message <- msg
[13:19:58.422]                       stop(ex)
[13:19:58.422]                     })
[13:19:58.422]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:58.422]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:58.422]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:58.422]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.422]                       fi <- file.info(pathname)
[13:19:58.422]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:58.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.422]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:58.422]                         fi[["size"]], fi[["mtime"]])
[13:19:58.422]                       stop(msg)
[13:19:58.422]                     }
[13:19:58.422]                     invisible(pathname)
[13:19:58.422]                   }
[13:19:58.422]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:58.422]                     rootPath = tempdir()) 
[13:19:58.422]                   {
[13:19:58.422]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:58.422]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:58.422]                       tmpdir = path, fileext = ".rds")
[13:19:58.422]                     save_rds(obj, file)
[13:19:58.422]                   }
[13:19:58.422]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:58.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.422]                   {
[13:19:58.422]                     inherits <- base::inherits
[13:19:58.422]                     invokeRestart <- base::invokeRestart
[13:19:58.422]                     is.null <- base::is.null
[13:19:58.422]                     muffled <- FALSE
[13:19:58.422]                     if (inherits(cond, "message")) {
[13:19:58.422]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.422]                       if (muffled) 
[13:19:58.422]                         invokeRestart("muffleMessage")
[13:19:58.422]                     }
[13:19:58.422]                     else if (inherits(cond, "warning")) {
[13:19:58.422]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.422]                       if (muffled) 
[13:19:58.422]                         invokeRestart("muffleWarning")
[13:19:58.422]                     }
[13:19:58.422]                     else if (inherits(cond, "condition")) {
[13:19:58.422]                       if (!is.null(pattern)) {
[13:19:58.422]                         computeRestarts <- base::computeRestarts
[13:19:58.422]                         grepl <- base::grepl
[13:19:58.422]                         restarts <- computeRestarts(cond)
[13:19:58.422]                         for (restart in restarts) {
[13:19:58.422]                           name <- restart$name
[13:19:58.422]                           if (is.null(name)) 
[13:19:58.422]                             next
[13:19:58.422]                           if (!grepl(pattern, name)) 
[13:19:58.422]                             next
[13:19:58.422]                           invokeRestart(restart)
[13:19:58.422]                           muffled <- TRUE
[13:19:58.422]                           break
[13:19:58.422]                         }
[13:19:58.422]                       }
[13:19:58.422]                     }
[13:19:58.422]                     invisible(muffled)
[13:19:58.422]                   }
[13:19:58.422]                   muffleCondition(cond)
[13:19:58.422]                 })
[13:19:58.422]             }))
[13:19:58.422]             future::FutureResult(value = ...future.value$value, 
[13:19:58.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.422]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.422]                     ...future.globalenv.names))
[13:19:58.422]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.422]         }, condition = base::local({
[13:19:58.422]             c <- base::c
[13:19:58.422]             inherits <- base::inherits
[13:19:58.422]             invokeRestart <- base::invokeRestart
[13:19:58.422]             length <- base::length
[13:19:58.422]             list <- base::list
[13:19:58.422]             seq.int <- base::seq.int
[13:19:58.422]             signalCondition <- base::signalCondition
[13:19:58.422]             sys.calls <- base::sys.calls
[13:19:58.422]             `[[` <- base::`[[`
[13:19:58.422]             `+` <- base::`+`
[13:19:58.422]             `<<-` <- base::`<<-`
[13:19:58.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.422]                   3L)]
[13:19:58.422]             }
[13:19:58.422]             function(cond) {
[13:19:58.422]                 is_error <- inherits(cond, "error")
[13:19:58.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.422]                   NULL)
[13:19:58.422]                 if (is_error) {
[13:19:58.422]                   sessionInformation <- function() {
[13:19:58.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.422]                       search = base::search(), system = base::Sys.info())
[13:19:58.422]                   }
[13:19:58.422]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.422]                     cond$call), session = sessionInformation(), 
[13:19:58.422]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.422]                   signalCondition(cond)
[13:19:58.422]                 }
[13:19:58.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.422]                 "immediateCondition"))) {
[13:19:58.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.422]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.422]                   if (TRUE && !signal) {
[13:19:58.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.422]                     {
[13:19:58.422]                       inherits <- base::inherits
[13:19:58.422]                       invokeRestart <- base::invokeRestart
[13:19:58.422]                       is.null <- base::is.null
[13:19:58.422]                       muffled <- FALSE
[13:19:58.422]                       if (inherits(cond, "message")) {
[13:19:58.422]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.422]                         if (muffled) 
[13:19:58.422]                           invokeRestart("muffleMessage")
[13:19:58.422]                       }
[13:19:58.422]                       else if (inherits(cond, "warning")) {
[13:19:58.422]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.422]                         if (muffled) 
[13:19:58.422]                           invokeRestart("muffleWarning")
[13:19:58.422]                       }
[13:19:58.422]                       else if (inherits(cond, "condition")) {
[13:19:58.422]                         if (!is.null(pattern)) {
[13:19:58.422]                           computeRestarts <- base::computeRestarts
[13:19:58.422]                           grepl <- base::grepl
[13:19:58.422]                           restarts <- computeRestarts(cond)
[13:19:58.422]                           for (restart in restarts) {
[13:19:58.422]                             name <- restart$name
[13:19:58.422]                             if (is.null(name)) 
[13:19:58.422]                               next
[13:19:58.422]                             if (!grepl(pattern, name)) 
[13:19:58.422]                               next
[13:19:58.422]                             invokeRestart(restart)
[13:19:58.422]                             muffled <- TRUE
[13:19:58.422]                             break
[13:19:58.422]                           }
[13:19:58.422]                         }
[13:19:58.422]                       }
[13:19:58.422]                       invisible(muffled)
[13:19:58.422]                     }
[13:19:58.422]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.422]                   }
[13:19:58.422]                 }
[13:19:58.422]                 else {
[13:19:58.422]                   if (TRUE) {
[13:19:58.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.422]                     {
[13:19:58.422]                       inherits <- base::inherits
[13:19:58.422]                       invokeRestart <- base::invokeRestart
[13:19:58.422]                       is.null <- base::is.null
[13:19:58.422]                       muffled <- FALSE
[13:19:58.422]                       if (inherits(cond, "message")) {
[13:19:58.422]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.422]                         if (muffled) 
[13:19:58.422]                           invokeRestart("muffleMessage")
[13:19:58.422]                       }
[13:19:58.422]                       else if (inherits(cond, "warning")) {
[13:19:58.422]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.422]                         if (muffled) 
[13:19:58.422]                           invokeRestart("muffleWarning")
[13:19:58.422]                       }
[13:19:58.422]                       else if (inherits(cond, "condition")) {
[13:19:58.422]                         if (!is.null(pattern)) {
[13:19:58.422]                           computeRestarts <- base::computeRestarts
[13:19:58.422]                           grepl <- base::grepl
[13:19:58.422]                           restarts <- computeRestarts(cond)
[13:19:58.422]                           for (restart in restarts) {
[13:19:58.422]                             name <- restart$name
[13:19:58.422]                             if (is.null(name)) 
[13:19:58.422]                               next
[13:19:58.422]                             if (!grepl(pattern, name)) 
[13:19:58.422]                               next
[13:19:58.422]                             invokeRestart(restart)
[13:19:58.422]                             muffled <- TRUE
[13:19:58.422]                             break
[13:19:58.422]                           }
[13:19:58.422]                         }
[13:19:58.422]                       }
[13:19:58.422]                       invisible(muffled)
[13:19:58.422]                     }
[13:19:58.422]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.422]                   }
[13:19:58.422]                 }
[13:19:58.422]             }
[13:19:58.422]         }))
[13:19:58.422]     }, error = function(ex) {
[13:19:58.422]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.422]                 ...future.rng), started = ...future.startTime, 
[13:19:58.422]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.422]             version = "1.8"), class = "FutureResult")
[13:19:58.422]     }, finally = {
[13:19:58.422]         if (!identical(...future.workdir, getwd())) 
[13:19:58.422]             setwd(...future.workdir)
[13:19:58.422]         {
[13:19:58.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.422]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.422]             }
[13:19:58.422]             base::options(...future.oldOptions)
[13:19:58.422]             if (.Platform$OS.type == "windows") {
[13:19:58.422]                 old_names <- names(...future.oldEnvVars)
[13:19:58.422]                 envs <- base::Sys.getenv()
[13:19:58.422]                 names <- names(envs)
[13:19:58.422]                 common <- intersect(names, old_names)
[13:19:58.422]                 added <- setdiff(names, old_names)
[13:19:58.422]                 removed <- setdiff(old_names, names)
[13:19:58.422]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.422]                   envs[common]]
[13:19:58.422]                 NAMES <- toupper(changed)
[13:19:58.422]                 args <- list()
[13:19:58.422]                 for (kk in seq_along(NAMES)) {
[13:19:58.422]                   name <- changed[[kk]]
[13:19:58.422]                   NAME <- NAMES[[kk]]
[13:19:58.422]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.422]                     next
[13:19:58.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.422]                 }
[13:19:58.422]                 NAMES <- toupper(added)
[13:19:58.422]                 for (kk in seq_along(NAMES)) {
[13:19:58.422]                   name <- added[[kk]]
[13:19:58.422]                   NAME <- NAMES[[kk]]
[13:19:58.422]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.422]                     next
[13:19:58.422]                   args[[name]] <- ""
[13:19:58.422]                 }
[13:19:58.422]                 NAMES <- toupper(removed)
[13:19:58.422]                 for (kk in seq_along(NAMES)) {
[13:19:58.422]                   name <- removed[[kk]]
[13:19:58.422]                   NAME <- NAMES[[kk]]
[13:19:58.422]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.422]                     next
[13:19:58.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.422]                 }
[13:19:58.422]                 if (length(args) > 0) 
[13:19:58.422]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.422]             }
[13:19:58.422]             else {
[13:19:58.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.422]             }
[13:19:58.422]             {
[13:19:58.422]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.422]                   0L) {
[13:19:58.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.422]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.422]                   base::options(opts)
[13:19:58.422]                 }
[13:19:58.422]                 {
[13:19:58.422]                   {
[13:19:58.422]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.422]                     NULL
[13:19:58.422]                   }
[13:19:58.422]                   options(future.plan = NULL)
[13:19:58.422]                   if (is.na(NA_character_)) 
[13:19:58.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.422]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:58.422]                     envir = parent.frame()) 
[13:19:58.422]                   {
[13:19:58.422]                     default_workers <- missing(workers)
[13:19:58.422]                     if (is.function(workers)) 
[13:19:58.422]                       workers <- workers()
[13:19:58.422]                     workers <- structure(as.integer(workers), 
[13:19:58.422]                       class = class(workers))
[13:19:58.422]                     stop_if_not(is.finite(workers), workers >= 
[13:19:58.422]                       1L)
[13:19:58.422]                     if ((workers == 1L && !inherits(workers, 
[13:19:58.422]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:58.422]                       if (default_workers) 
[13:19:58.422]                         supportsMulticore(warn = TRUE)
[13:19:58.422]                       return(sequential(..., envir = envir))
[13:19:58.422]                     }
[13:19:58.422]                     oopts <- options(mc.cores = workers)
[13:19:58.422]                     on.exit(options(oopts))
[13:19:58.422]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:58.422]                       envir = envir)
[13:19:58.422]                     if (!future$lazy) 
[13:19:58.422]                       future <- run(future)
[13:19:58.422]                     invisible(future)
[13:19:58.422]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.422]                 }
[13:19:58.422]             }
[13:19:58.422]         }
[13:19:58.422]     })
[13:19:58.422]     if (TRUE) {
[13:19:58.422]         base::sink(type = "output", split = FALSE)
[13:19:58.422]         if (TRUE) {
[13:19:58.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.422]         }
[13:19:58.422]         else {
[13:19:58.422]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.422]         }
[13:19:58.422]         base::close(...future.stdout)
[13:19:58.422]         ...future.stdout <- NULL
[13:19:58.422]     }
[13:19:58.422]     ...future.result$conditions <- ...future.conditions
[13:19:58.422]     ...future.result$finished <- base::Sys.time()
[13:19:58.422]     ...future.result
[13:19:58.422] }
[13:19:58.425] assign_globals() ...
[13:19:58.425] List of 5
[13:19:58.425]  $ future.call.arguments    : list()
[13:19:58.425]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.425]  $ ...future.FUN            :function (x)  
[13:19:58.425]  $ ...future.elements_ii    :List of 1
[13:19:58.425]   ..$ : int [1:2] 1 3
[13:19:58.425]  $ ...future.seeds_ii       : NULL
[13:19:58.425]  $ ...future.globals.maxSize: num Inf
[13:19:58.425]  - attr(*, "resolved")= logi FALSE
[13:19:58.425]  - attr(*, "total_size")= num NA
[13:19:58.425]  - attr(*, "where")=List of 5
[13:19:58.425]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:58.425]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:58.425]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:58.425]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:58.425]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:58.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.425]  - attr(*, "already-done")= logi TRUE
[13:19:58.430] - copied ‘future.call.arguments’ to environment
[13:19:58.430] - reassign environment for ‘...future.FUN’
[13:19:58.430] - copied ‘...future.FUN’ to environment
[13:19:58.430] - copied ‘...future.elements_ii’ to environment
[13:19:58.430] - copied ‘...future.seeds_ii’ to environment
[13:19:58.430] - copied ‘...future.globals.maxSize’ to environment
[13:19:58.430] assign_globals() ... done
[13:19:58.431] requestCore(): workers = 2
[13:19:58.433] MulticoreFuture started
[13:19:58.433] - Launch lazy future ... done
[13:19:58.433] run() for ‘MulticoreFuture’ ... done
[13:19:58.434] Created future:
[13:19:58.434] plan(): Setting new future strategy stack:
[13:19:58.434] List of future strategies:
[13:19:58.434] 1. sequential:
[13:19:58.434]    - args: function (..., envir = parent.frame())
[13:19:58.434]    - tweaked: FALSE
[13:19:58.434]    - call: NULL
[13:19:58.435] plan(): nbrOfWorkers() = 1
[13:19:58.437] plan(): Setting new future strategy stack:
[13:19:58.438] List of future strategies:
[13:19:58.438] 1. multicore:
[13:19:58.438]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:58.438]    - tweaked: FALSE
[13:19:58.438]    - call: plan(strategy)
[13:19:58.443] plan(): nbrOfWorkers() = 2
[13:19:58.434] MulticoreFuture:
[13:19:58.434] Label: ‘future_apply-1’
[13:19:58.434] Expression:
[13:19:58.434] {
[13:19:58.434]     do.call(function(...) {
[13:19:58.434]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.434]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.434]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.434]             on.exit(options(oopts), add = TRUE)
[13:19:58.434]         }
[13:19:58.434]         {
[13:19:58.434]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.434]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.434]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.434]             })
[13:19:58.434]         }
[13:19:58.434]     }, args = future.call.arguments)
[13:19:58.434] }
[13:19:58.434] Lazy evaluation: FALSE
[13:19:58.434] Asynchronous evaluation: TRUE
[13:19:58.434] Local evaluation: TRUE
[13:19:58.434] Environment: R_GlobalEnv
[13:19:58.434] Capture standard output: TRUE
[13:19:58.434] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:58.434] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:58.434] Packages: <none>
[13:19:58.434] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:58.434] Resolved: TRUE
[13:19:58.434] Value: <not collected>
[13:19:58.434] Conditions captured: <none>
[13:19:58.434] Early signaling: FALSE
[13:19:58.434] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:58.434] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.445] Chunk #1 of 2 ... DONE
[13:19:58.445] Chunk #2 of 2 ...
[13:19:58.445]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:58.445]  - seeds: <none>
[13:19:58.445]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.446] getGlobalsAndPackages() ...
[13:19:58.446] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.446] Resolving globals: FALSE
[13:19:58.446] Tweak future expression to call with '...' arguments ...
[13:19:58.446] {
[13:19:58.446]     do.call(function(...) {
[13:19:58.446]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.446]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.446]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.446]             on.exit(options(oopts), add = TRUE)
[13:19:58.446]         }
[13:19:58.446]         {
[13:19:58.446]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.446]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.446]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.446]             })
[13:19:58.446]         }
[13:19:58.446]     }, args = future.call.arguments)
[13:19:58.446] }
[13:19:58.447] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.447] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.447] 
[13:19:58.448] getGlobalsAndPackages() ... DONE
[13:19:58.448] run() for ‘Future’ ...
[13:19:58.448] - state: ‘created’
[13:19:58.449] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.453] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.453] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:58.454]   - Field: ‘label’
[13:19:58.454]   - Field: ‘local’
[13:19:58.454]   - Field: ‘owner’
[13:19:58.454]   - Field: ‘envir’
[13:19:58.454]   - Field: ‘workers’
[13:19:58.454]   - Field: ‘packages’
[13:19:58.455]   - Field: ‘gc’
[13:19:58.455]   - Field: ‘job’
[13:19:58.455]   - Field: ‘conditions’
[13:19:58.458]   - Field: ‘expr’
[13:19:58.459]   - Field: ‘uuid’
[13:19:58.459]   - Field: ‘seed’
[13:19:58.459]   - Field: ‘version’
[13:19:58.460]   - Field: ‘result’
[13:19:58.460]   - Field: ‘asynchronous’
[13:19:58.461]   - Field: ‘calls’
[13:19:58.461]   - Field: ‘globals’
[13:19:58.461]   - Field: ‘stdout’
[13:19:58.461]   - Field: ‘earlySignal’
[13:19:58.462]   - Field: ‘lazy’
[13:19:58.462]   - Field: ‘state’
[13:19:58.462] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:58.462] - Launch lazy future ...
[13:19:58.463] Packages needed by the future expression (n = 0): <none>
[13:19:58.463] Packages needed by future strategies (n = 0): <none>
[13:19:58.464] {
[13:19:58.464]     {
[13:19:58.464]         {
[13:19:58.464]             ...future.startTime <- base::Sys.time()
[13:19:58.464]             {
[13:19:58.464]                 {
[13:19:58.464]                   {
[13:19:58.464]                     {
[13:19:58.464]                       base::local({
[13:19:58.464]                         has_future <- base::requireNamespace("future", 
[13:19:58.464]                           quietly = TRUE)
[13:19:58.464]                         if (has_future) {
[13:19:58.464]                           ns <- base::getNamespace("future")
[13:19:58.464]                           version <- ns[[".package"]][["version"]]
[13:19:58.464]                           if (is.null(version)) 
[13:19:58.464]                             version <- utils::packageVersion("future")
[13:19:58.464]                         }
[13:19:58.464]                         else {
[13:19:58.464]                           version <- NULL
[13:19:58.464]                         }
[13:19:58.464]                         if (!has_future || version < "1.8.0") {
[13:19:58.464]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.464]                             "", base::R.version$version.string), 
[13:19:58.464]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:58.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.464]                               "release", "version")], collapse = " "), 
[13:19:58.464]                             hostname = base::Sys.info()[["nodename"]])
[13:19:58.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.464]                             info)
[13:19:58.464]                           info <- base::paste(info, collapse = "; ")
[13:19:58.464]                           if (!has_future) {
[13:19:58.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.464]                               info)
[13:19:58.464]                           }
[13:19:58.464]                           else {
[13:19:58.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.464]                               info, version)
[13:19:58.464]                           }
[13:19:58.464]                           base::stop(msg)
[13:19:58.464]                         }
[13:19:58.464]                       })
[13:19:58.464]                     }
[13:19:58.464]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.464]                     base::options(mc.cores = 1L)
[13:19:58.464]                   }
[13:19:58.464]                   options(future.plan = NULL)
[13:19:58.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.464]                 }
[13:19:58.464]                 ...future.workdir <- getwd()
[13:19:58.464]             }
[13:19:58.464]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.464]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.464]         }
[13:19:58.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.464]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:58.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.464]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.464]             base::names(...future.oldOptions))
[13:19:58.464]     }
[13:19:58.464]     if (FALSE) {
[13:19:58.464]     }
[13:19:58.464]     else {
[13:19:58.464]         if (TRUE) {
[13:19:58.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.464]                 open = "w")
[13:19:58.464]         }
[13:19:58.464]         else {
[13:19:58.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.464]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.464]         }
[13:19:58.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.464]             base::sink(type = "output", split = FALSE)
[13:19:58.464]             base::close(...future.stdout)
[13:19:58.464]         }, add = TRUE)
[13:19:58.464]     }
[13:19:58.464]     ...future.frame <- base::sys.nframe()
[13:19:58.464]     ...future.conditions <- base::list()
[13:19:58.464]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.464]     if (FALSE) {
[13:19:58.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.464]     }
[13:19:58.464]     ...future.result <- base::tryCatch({
[13:19:58.464]         base::withCallingHandlers({
[13:19:58.464]             ...future.value <- base::withVisible(base::local({
[13:19:58.464]                 withCallingHandlers({
[13:19:58.464]                   {
[13:19:58.464]                     do.call(function(...) {
[13:19:58.464]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.464]                       if (!identical(...future.globals.maxSize.org, 
[13:19:58.464]                         ...future.globals.maxSize)) {
[13:19:58.464]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.464]                         on.exit(options(oopts), add = TRUE)
[13:19:58.464]                       }
[13:19:58.464]                       {
[13:19:58.464]                         lapply(seq_along(...future.elements_ii), 
[13:19:58.464]                           FUN = function(jj) {
[13:19:58.464]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.464]                             ...future.FUN(...future.X_jj, ...)
[13:19:58.464]                           })
[13:19:58.464]                       }
[13:19:58.464]                     }, args = future.call.arguments)
[13:19:58.464]                   }
[13:19:58.464]                 }, immediateCondition = function(cond) {
[13:19:58.464]                   save_rds <- function (object, pathname, ...) 
[13:19:58.464]                   {
[13:19:58.464]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:58.464]                     if (file_test("-f", pathname_tmp)) {
[13:19:58.464]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.464]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:58.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.464]                         fi_tmp[["mtime"]])
[13:19:58.464]                     }
[13:19:58.464]                     tryCatch({
[13:19:58.464]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:58.464]                     }, error = function(ex) {
[13:19:58.464]                       msg <- conditionMessage(ex)
[13:19:58.464]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.464]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:58.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.464]                         fi_tmp[["mtime"]], msg)
[13:19:58.464]                       ex$message <- msg
[13:19:58.464]                       stop(ex)
[13:19:58.464]                     })
[13:19:58.464]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:58.464]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:58.464]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:58.464]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.464]                       fi <- file.info(pathname)
[13:19:58.464]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:58.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.464]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:58.464]                         fi[["size"]], fi[["mtime"]])
[13:19:58.464]                       stop(msg)
[13:19:58.464]                     }
[13:19:58.464]                     invisible(pathname)
[13:19:58.464]                   }
[13:19:58.464]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:58.464]                     rootPath = tempdir()) 
[13:19:58.464]                   {
[13:19:58.464]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:58.464]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:58.464]                       tmpdir = path, fileext = ".rds")
[13:19:58.464]                     save_rds(obj, file)
[13:19:58.464]                   }
[13:19:58.464]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:58.464]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.464]                   {
[13:19:58.464]                     inherits <- base::inherits
[13:19:58.464]                     invokeRestart <- base::invokeRestart
[13:19:58.464]                     is.null <- base::is.null
[13:19:58.464]                     muffled <- FALSE
[13:19:58.464]                     if (inherits(cond, "message")) {
[13:19:58.464]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.464]                       if (muffled) 
[13:19:58.464]                         invokeRestart("muffleMessage")
[13:19:58.464]                     }
[13:19:58.464]                     else if (inherits(cond, "warning")) {
[13:19:58.464]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.464]                       if (muffled) 
[13:19:58.464]                         invokeRestart("muffleWarning")
[13:19:58.464]                     }
[13:19:58.464]                     else if (inherits(cond, "condition")) {
[13:19:58.464]                       if (!is.null(pattern)) {
[13:19:58.464]                         computeRestarts <- base::computeRestarts
[13:19:58.464]                         grepl <- base::grepl
[13:19:58.464]                         restarts <- computeRestarts(cond)
[13:19:58.464]                         for (restart in restarts) {
[13:19:58.464]                           name <- restart$name
[13:19:58.464]                           if (is.null(name)) 
[13:19:58.464]                             next
[13:19:58.464]                           if (!grepl(pattern, name)) 
[13:19:58.464]                             next
[13:19:58.464]                           invokeRestart(restart)
[13:19:58.464]                           muffled <- TRUE
[13:19:58.464]                           break
[13:19:58.464]                         }
[13:19:58.464]                       }
[13:19:58.464]                     }
[13:19:58.464]                     invisible(muffled)
[13:19:58.464]                   }
[13:19:58.464]                   muffleCondition(cond)
[13:19:58.464]                 })
[13:19:58.464]             }))
[13:19:58.464]             future::FutureResult(value = ...future.value$value, 
[13:19:58.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.464]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.464]                     ...future.globalenv.names))
[13:19:58.464]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.464]         }, condition = base::local({
[13:19:58.464]             c <- base::c
[13:19:58.464]             inherits <- base::inherits
[13:19:58.464]             invokeRestart <- base::invokeRestart
[13:19:58.464]             length <- base::length
[13:19:58.464]             list <- base::list
[13:19:58.464]             seq.int <- base::seq.int
[13:19:58.464]             signalCondition <- base::signalCondition
[13:19:58.464]             sys.calls <- base::sys.calls
[13:19:58.464]             `[[` <- base::`[[`
[13:19:58.464]             `+` <- base::`+`
[13:19:58.464]             `<<-` <- base::`<<-`
[13:19:58.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.464]                   3L)]
[13:19:58.464]             }
[13:19:58.464]             function(cond) {
[13:19:58.464]                 is_error <- inherits(cond, "error")
[13:19:58.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.464]                   NULL)
[13:19:58.464]                 if (is_error) {
[13:19:58.464]                   sessionInformation <- function() {
[13:19:58.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.464]                       search = base::search(), system = base::Sys.info())
[13:19:58.464]                   }
[13:19:58.464]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.464]                     cond$call), session = sessionInformation(), 
[13:19:58.464]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.464]                   signalCondition(cond)
[13:19:58.464]                 }
[13:19:58.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.464]                 "immediateCondition"))) {
[13:19:58.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.464]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.464]                   if (TRUE && !signal) {
[13:19:58.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.464]                     {
[13:19:58.464]                       inherits <- base::inherits
[13:19:58.464]                       invokeRestart <- base::invokeRestart
[13:19:58.464]                       is.null <- base::is.null
[13:19:58.464]                       muffled <- FALSE
[13:19:58.464]                       if (inherits(cond, "message")) {
[13:19:58.464]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.464]                         if (muffled) 
[13:19:58.464]                           invokeRestart("muffleMessage")
[13:19:58.464]                       }
[13:19:58.464]                       else if (inherits(cond, "warning")) {
[13:19:58.464]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.464]                         if (muffled) 
[13:19:58.464]                           invokeRestart("muffleWarning")
[13:19:58.464]                       }
[13:19:58.464]                       else if (inherits(cond, "condition")) {
[13:19:58.464]                         if (!is.null(pattern)) {
[13:19:58.464]                           computeRestarts <- base::computeRestarts
[13:19:58.464]                           grepl <- base::grepl
[13:19:58.464]                           restarts <- computeRestarts(cond)
[13:19:58.464]                           for (restart in restarts) {
[13:19:58.464]                             name <- restart$name
[13:19:58.464]                             if (is.null(name)) 
[13:19:58.464]                               next
[13:19:58.464]                             if (!grepl(pattern, name)) 
[13:19:58.464]                               next
[13:19:58.464]                             invokeRestart(restart)
[13:19:58.464]                             muffled <- TRUE
[13:19:58.464]                             break
[13:19:58.464]                           }
[13:19:58.464]                         }
[13:19:58.464]                       }
[13:19:58.464]                       invisible(muffled)
[13:19:58.464]                     }
[13:19:58.464]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.464]                   }
[13:19:58.464]                 }
[13:19:58.464]                 else {
[13:19:58.464]                   if (TRUE) {
[13:19:58.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.464]                     {
[13:19:58.464]                       inherits <- base::inherits
[13:19:58.464]                       invokeRestart <- base::invokeRestart
[13:19:58.464]                       is.null <- base::is.null
[13:19:58.464]                       muffled <- FALSE
[13:19:58.464]                       if (inherits(cond, "message")) {
[13:19:58.464]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.464]                         if (muffled) 
[13:19:58.464]                           invokeRestart("muffleMessage")
[13:19:58.464]                       }
[13:19:58.464]                       else if (inherits(cond, "warning")) {
[13:19:58.464]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.464]                         if (muffled) 
[13:19:58.464]                           invokeRestart("muffleWarning")
[13:19:58.464]                       }
[13:19:58.464]                       else if (inherits(cond, "condition")) {
[13:19:58.464]                         if (!is.null(pattern)) {
[13:19:58.464]                           computeRestarts <- base::computeRestarts
[13:19:58.464]                           grepl <- base::grepl
[13:19:58.464]                           restarts <- computeRestarts(cond)
[13:19:58.464]                           for (restart in restarts) {
[13:19:58.464]                             name <- restart$name
[13:19:58.464]                             if (is.null(name)) 
[13:19:58.464]                               next
[13:19:58.464]                             if (!grepl(pattern, name)) 
[13:19:58.464]                               next
[13:19:58.464]                             invokeRestart(restart)
[13:19:58.464]                             muffled <- TRUE
[13:19:58.464]                             break
[13:19:58.464]                           }
[13:19:58.464]                         }
[13:19:58.464]                       }
[13:19:58.464]                       invisible(muffled)
[13:19:58.464]                     }
[13:19:58.464]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.464]                   }
[13:19:58.464]                 }
[13:19:58.464]             }
[13:19:58.464]         }))
[13:19:58.464]     }, error = function(ex) {
[13:19:58.464]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.464]                 ...future.rng), started = ...future.startTime, 
[13:19:58.464]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.464]             version = "1.8"), class = "FutureResult")
[13:19:58.464]     }, finally = {
[13:19:58.464]         if (!identical(...future.workdir, getwd())) 
[13:19:58.464]             setwd(...future.workdir)
[13:19:58.464]         {
[13:19:58.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.464]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.464]             }
[13:19:58.464]             base::options(...future.oldOptions)
[13:19:58.464]             if (.Platform$OS.type == "windows") {
[13:19:58.464]                 old_names <- names(...future.oldEnvVars)
[13:19:58.464]                 envs <- base::Sys.getenv()
[13:19:58.464]                 names <- names(envs)
[13:19:58.464]                 common <- intersect(names, old_names)
[13:19:58.464]                 added <- setdiff(names, old_names)
[13:19:58.464]                 removed <- setdiff(old_names, names)
[13:19:58.464]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.464]                   envs[common]]
[13:19:58.464]                 NAMES <- toupper(changed)
[13:19:58.464]                 args <- list()
[13:19:58.464]                 for (kk in seq_along(NAMES)) {
[13:19:58.464]                   name <- changed[[kk]]
[13:19:58.464]                   NAME <- NAMES[[kk]]
[13:19:58.464]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.464]                     next
[13:19:58.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.464]                 }
[13:19:58.464]                 NAMES <- toupper(added)
[13:19:58.464]                 for (kk in seq_along(NAMES)) {
[13:19:58.464]                   name <- added[[kk]]
[13:19:58.464]                   NAME <- NAMES[[kk]]
[13:19:58.464]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.464]                     next
[13:19:58.464]                   args[[name]] <- ""
[13:19:58.464]                 }
[13:19:58.464]                 NAMES <- toupper(removed)
[13:19:58.464]                 for (kk in seq_along(NAMES)) {
[13:19:58.464]                   name <- removed[[kk]]
[13:19:58.464]                   NAME <- NAMES[[kk]]
[13:19:58.464]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.464]                     next
[13:19:58.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.464]                 }
[13:19:58.464]                 if (length(args) > 0) 
[13:19:58.464]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.464]             }
[13:19:58.464]             else {
[13:19:58.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.464]             }
[13:19:58.464]             {
[13:19:58.464]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.464]                   0L) {
[13:19:58.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.464]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.464]                   base::options(opts)
[13:19:58.464]                 }
[13:19:58.464]                 {
[13:19:58.464]                   {
[13:19:58.464]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.464]                     NULL
[13:19:58.464]                   }
[13:19:58.464]                   options(future.plan = NULL)
[13:19:58.464]                   if (is.na(NA_character_)) 
[13:19:58.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.464]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:58.464]                     envir = parent.frame()) 
[13:19:58.464]                   {
[13:19:58.464]                     default_workers <- missing(workers)
[13:19:58.464]                     if (is.function(workers)) 
[13:19:58.464]                       workers <- workers()
[13:19:58.464]                     workers <- structure(as.integer(workers), 
[13:19:58.464]                       class = class(workers))
[13:19:58.464]                     stop_if_not(is.finite(workers), workers >= 
[13:19:58.464]                       1L)
[13:19:58.464]                     if ((workers == 1L && !inherits(workers, 
[13:19:58.464]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:58.464]                       if (default_workers) 
[13:19:58.464]                         supportsMulticore(warn = TRUE)
[13:19:58.464]                       return(sequential(..., envir = envir))
[13:19:58.464]                     }
[13:19:58.464]                     oopts <- options(mc.cores = workers)
[13:19:58.464]                     on.exit(options(oopts))
[13:19:58.464]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:58.464]                       envir = envir)
[13:19:58.464]                     if (!future$lazy) 
[13:19:58.464]                       future <- run(future)
[13:19:58.464]                     invisible(future)
[13:19:58.464]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.464]                 }
[13:19:58.464]             }
[13:19:58.464]         }
[13:19:58.464]     })
[13:19:58.464]     if (TRUE) {
[13:19:58.464]         base::sink(type = "output", split = FALSE)
[13:19:58.464]         if (TRUE) {
[13:19:58.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.464]         }
[13:19:58.464]         else {
[13:19:58.464]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.464]         }
[13:19:58.464]         base::close(...future.stdout)
[13:19:58.464]         ...future.stdout <- NULL
[13:19:58.464]     }
[13:19:58.464]     ...future.result$conditions <- ...future.conditions
[13:19:58.464]     ...future.result$finished <- base::Sys.time()
[13:19:58.464]     ...future.result
[13:19:58.464] }
[13:19:58.468] assign_globals() ...
[13:19:58.468] List of 5
[13:19:58.468]  $ future.call.arguments    : list()
[13:19:58.468]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.468]  $ ...future.FUN            :function (x)  
[13:19:58.468]  $ ...future.elements_ii    :List of 1
[13:19:58.468]   ..$ : int [1:2] 2 4
[13:19:58.468]  $ ...future.seeds_ii       : NULL
[13:19:58.468]  $ ...future.globals.maxSize: num Inf
[13:19:58.468]  - attr(*, "resolved")= logi FALSE
[13:19:58.468]  - attr(*, "total_size")= num NA
[13:19:58.468]  - attr(*, "where")=List of 5
[13:19:58.468]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:58.468]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:58.468]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:58.468]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:58.468]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:58.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.468]  - attr(*, "already-done")= logi TRUE
[13:19:58.476] - copied ‘future.call.arguments’ to environment
[13:19:58.476] - reassign environment for ‘...future.FUN’
[13:19:58.476] - copied ‘...future.FUN’ to environment
[13:19:58.476] - copied ‘...future.elements_ii’ to environment
[13:19:58.476] - copied ‘...future.seeds_ii’ to environment
[13:19:58.477] - copied ‘...future.globals.maxSize’ to environment
[13:19:58.477] assign_globals() ... done
[13:19:58.477] requestCore(): workers = 2
[13:19:58.479] MulticoreFuture started
[13:19:58.480] - Launch lazy future ... done
[13:19:58.480] run() for ‘MulticoreFuture’ ... done
[13:19:58.480] Created future:
[13:19:58.480] plan(): Setting new future strategy stack:
[13:19:58.481] List of future strategies:
[13:19:58.481] 1. sequential:
[13:19:58.481]    - args: function (..., envir = parent.frame())
[13:19:58.481]    - tweaked: FALSE
[13:19:58.481]    - call: NULL
[13:19:58.481] plan(): nbrOfWorkers() = 1
[13:19:58.484] plan(): Setting new future strategy stack:
[13:19:58.484] List of future strategies:
[13:19:58.484] 1. multicore:
[13:19:58.484]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:58.484]    - tweaked: FALSE
[13:19:58.484]    - call: plan(strategy)
[13:19:58.489] plan(): nbrOfWorkers() = 2
[13:19:58.480] MulticoreFuture:
[13:19:58.480] Label: ‘future_apply-2’
[13:19:58.480] Expression:
[13:19:58.480] {
[13:19:58.480]     do.call(function(...) {
[13:19:58.480]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.480]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.480]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.480]             on.exit(options(oopts), add = TRUE)
[13:19:58.480]         }
[13:19:58.480]         {
[13:19:58.480]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.480]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.480]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.480]             })
[13:19:58.480]         }
[13:19:58.480]     }, args = future.call.arguments)
[13:19:58.480] }
[13:19:58.480] Lazy evaluation: FALSE
[13:19:58.480] Asynchronous evaluation: TRUE
[13:19:58.480] Local evaluation: TRUE
[13:19:58.480] Environment: R_GlobalEnv
[13:19:58.480] Capture standard output: TRUE
[13:19:58.480] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:58.480] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:58.480] Packages: <none>
[13:19:58.480] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:58.480] Resolved: TRUE
[13:19:58.480] Value: <not collected>
[13:19:58.480] Conditions captured: <none>
[13:19:58.480] Early signaling: FALSE
[13:19:58.480] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:58.480] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.490] Chunk #2 of 2 ... DONE
[13:19:58.490] Launching 2 futures (chunks) ... DONE
[13:19:58.490] Resolving 2 futures (chunks) ...
[13:19:58.491] resolve() on list ...
[13:19:58.491]  recursive: 0
[13:19:58.491]  length: 2
[13:19:58.491] 
[13:19:58.491] Future #1
[13:19:58.491] result() for MulticoreFuture ...
[13:19:58.493] result() for MulticoreFuture ...
[13:19:58.493] result() for MulticoreFuture ... done
[13:19:58.493] result() for MulticoreFuture ... done
[13:19:58.493] result() for MulticoreFuture ...
[13:19:58.493] result() for MulticoreFuture ... done
[13:19:58.493] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:58.494] - nx: 2
[13:19:58.494] - relay: TRUE
[13:19:58.494] - stdout: TRUE
[13:19:58.494] - signal: TRUE
[13:19:58.494] - resignal: FALSE
[13:19:58.494] - force: TRUE
[13:19:58.494] - relayed: [n=2] FALSE, FALSE
[13:19:58.494] - queued futures: [n=2] FALSE, FALSE
[13:19:58.495]  - until=1
[13:19:58.495]  - relaying element #1
[13:19:58.495] result() for MulticoreFuture ...
[13:19:58.495] result() for MulticoreFuture ... done
[13:19:58.495] result() for MulticoreFuture ...
[13:19:58.495] result() for MulticoreFuture ... done
[13:19:58.496] result() for MulticoreFuture ...
[13:19:58.496] result() for MulticoreFuture ... done
[13:19:58.496] result() for MulticoreFuture ...
[13:19:58.496] result() for MulticoreFuture ... done
[13:19:58.496] - relayed: [n=2] TRUE, FALSE
[13:19:58.497] - queued futures: [n=2] TRUE, FALSE
[13:19:58.497] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:58.497]  length: 1 (resolved future 1)
[13:19:58.497] Future #2
[13:19:58.497] result() for MulticoreFuture ...
[13:19:58.498] result() for MulticoreFuture ...
[13:19:58.498] result() for MulticoreFuture ... done
[13:19:58.498] result() for MulticoreFuture ... done
[13:19:58.499] result() for MulticoreFuture ...
[13:19:58.499] result() for MulticoreFuture ... done
[13:19:58.499] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:58.499] - nx: 2
[13:19:58.499] - relay: TRUE
[13:19:58.499] - stdout: TRUE
[13:19:58.499] - signal: TRUE
[13:19:58.499] - resignal: FALSE
[13:19:58.500] - force: TRUE
[13:19:58.500] - relayed: [n=2] TRUE, FALSE
[13:19:58.500] - queued futures: [n=2] TRUE, FALSE
[13:19:58.500]  - until=2
[13:19:58.500]  - relaying element #2
[13:19:58.500] result() for MulticoreFuture ...
[13:19:58.500] result() for MulticoreFuture ... done
[13:19:58.501] result() for MulticoreFuture ...
[13:19:58.501] result() for MulticoreFuture ... done
[13:19:58.501] result() for MulticoreFuture ...
[13:19:58.501] result() for MulticoreFuture ... done
[13:19:58.501] result() for MulticoreFuture ...
[13:19:58.501] result() for MulticoreFuture ... done
[13:19:58.501] - relayed: [n=2] TRUE, TRUE
[13:19:58.501] - queued futures: [n=2] TRUE, TRUE
[13:19:58.502] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:58.502]  length: 0 (resolved future 2)
[13:19:58.502] Relaying remaining futures
[13:19:58.502] signalConditionsASAP(NULL, pos=0) ...
[13:19:58.502] - nx: 2
[13:19:58.502] - relay: TRUE
[13:19:58.502] - stdout: TRUE
[13:19:58.502] - signal: TRUE
[13:19:58.502] - resignal: FALSE
[13:19:58.502] - force: TRUE
[13:19:58.503] - relayed: [n=2] TRUE, TRUE
[13:19:58.503] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:58.505] - relayed: [n=2] TRUE, TRUE
[13:19:58.506] - queued futures: [n=2] TRUE, TRUE
[13:19:58.506] signalConditionsASAP(NULL, pos=0) ... done
[13:19:58.506] resolve() on list ... DONE
[13:19:58.506] result() for MulticoreFuture ...
[13:19:58.506] result() for MulticoreFuture ... done
[13:19:58.507] result() for MulticoreFuture ...
[13:19:58.507] result() for MulticoreFuture ... done
[13:19:58.507] result() for MulticoreFuture ...
[13:19:58.507] result() for MulticoreFuture ... done
[13:19:58.507] result() for MulticoreFuture ...
[13:19:58.507] result() for MulticoreFuture ... done
[13:19:58.508]  - Number of value chunks collected: 2
[13:19:58.508] Resolving 2 futures (chunks) ... DONE
[13:19:58.508] Reducing values from 2 chunks ...
[13:19:58.508]  - Number of values collected after concatenation: 2
[13:19:58.508]  - Number of values expected: 2
[13:19:58.508] Reducing values from 2 chunks ... DONE
[13:19:58.509] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[13:19:58.509] getGlobalsAndPackagesXApply() ...
[13:19:58.509]  - future.globals: TRUE
[13:19:58.509] getGlobalsAndPackages() ...
[13:19:58.510] Searching for globals...
[13:19:58.514] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[13:19:58.514] Searching for globals ... DONE
[13:19:58.514] Resolving globals: FALSE
[13:19:58.515] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[13:19:58.515] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[13:19:58.515] - globals: [1] ‘FUN’
[13:19:58.515] 
[13:19:58.515] getGlobalsAndPackages() ... DONE
[13:19:58.516]  - globals found/used: [n=1] ‘FUN’
[13:19:58.516]  - needed namespaces: [n=0] 
[13:19:58.516] Finding globals ... DONE
[13:19:58.516]  - use_args: TRUE
[13:19:58.516]  - Getting '...' globals ...
[13:19:58.516] resolve() on list ...
[13:19:58.516]  recursive: 0
[13:19:58.517]  length: 1
[13:19:58.517]  elements: ‘...’
[13:19:58.517]  length: 0 (resolved future 1)
[13:19:58.517] resolve() on list ... DONE
[13:19:58.517]    - '...' content: [n=0] 
[13:19:58.517] List of 1
[13:19:58.517]  $ ...: list()
[13:19:58.517]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.517]  - attr(*, "where")=List of 1
[13:19:58.517]   ..$ ...:<environment: 0x555922f8f0b0> 
[13:19:58.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.517]  - attr(*, "resolved")= logi TRUE
[13:19:58.517]  - attr(*, "total_size")= num NA
[13:19:58.520]  - Getting '...' globals ... DONE
[13:19:58.520] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:58.520] List of 2
[13:19:58.520]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:19:58.520]  $ ...          : list()
[13:19:58.520]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.520]  - attr(*, "where")=List of 2
[13:19:58.520]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:58.520]   ..$ ...          :<environment: 0x555922f8f0b0> 
[13:19:58.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.520]  - attr(*, "resolved")= logi FALSE
[13:19:58.520]  - attr(*, "total_size")= num 36296
[13:19:58.523] Packages to be attached in all futures: [n=0] 
[13:19:58.523] getGlobalsAndPackagesXApply() ... DONE
[13:19:58.527] future_lapply() ...
[13:19:58.530] Generating random seeds ...
[13:19:58.534] Generating random seed streams for 2 elements ...
[13:19:58.534] Generating random seed streams for 2 elements ... DONE
[13:19:58.534] Generating random seeds ... DONE
[13:19:58.534] Will set RNG state on exit: 10407, -437060613, 1614658720, 870086122, -1450170233, -280200198, 198656393
[13:19:58.538] Number of chunks: 2
[13:19:58.538] getGlobalsAndPackagesXApply() ...
[13:19:58.539]  - future.globals: <name-value list> with names ‘list()’
[13:19:58.539]  - use_args: TRUE
[13:19:58.539] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:58.539] List of 2
[13:19:58.539]  $ ...          : list()
[13:19:58.539]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.539]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:19:58.539]  - attr(*, "where")=List of 2
[13:19:58.539]   ..$ ...          :<environment: 0x555922f8f0b0> 
[13:19:58.539]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:58.539]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.539]  - attr(*, "resolved")= logi FALSE
[13:19:58.539]  - attr(*, "total_size")= num NA
[13:19:58.543] Packages to be attached in all futures: [n=0] 
[13:19:58.543] getGlobalsAndPackagesXApply() ... DONE
[13:19:58.544] Number of futures (= number of chunks): 2
[13:19:58.544] Launching 2 futures (chunks) ...
[13:19:58.544] Chunk #1 of 2 ...
[13:19:58.544]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:58.544]  - seeds: [1] <seeds>
[13:19:58.544]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.544] getGlobalsAndPackages() ...
[13:19:58.545] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.545] Resolving globals: FALSE
[13:19:58.545] Tweak future expression to call with '...' arguments ...
[13:19:58.545] {
[13:19:58.545]     do.call(function(...) {
[13:19:58.545]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.545]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.545]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.545]             on.exit(options(oopts), add = TRUE)
[13:19:58.545]         }
[13:19:58.545]         {
[13:19:58.545]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.545]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.545]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:19:58.545]                   envir = globalenv(), inherits = FALSE)
[13:19:58.545]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.545]             })
[13:19:58.545]         }
[13:19:58.545]     }, args = future.call.arguments)
[13:19:58.545] }
[13:19:58.545] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.546] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.546] 
[13:19:58.546] getGlobalsAndPackages() ... DONE
[13:19:58.546] run() for ‘Future’ ...
[13:19:58.546] - state: ‘created’
[13:19:58.546] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.550] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.550] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:58.550]   - Field: ‘label’
[13:19:58.551]   - Field: ‘local’
[13:19:58.551]   - Field: ‘owner’
[13:19:58.551]   - Field: ‘envir’
[13:19:58.551]   - Field: ‘workers’
[13:19:58.551]   - Field: ‘packages’
[13:19:58.551]   - Field: ‘gc’
[13:19:58.551]   - Field: ‘job’
[13:19:58.551]   - Field: ‘conditions’
[13:19:58.551]   - Field: ‘expr’
[13:19:58.551]   - Field: ‘uuid’
[13:19:58.552]   - Field: ‘seed’
[13:19:58.552]   - Field: ‘version’
[13:19:58.552]   - Field: ‘result’
[13:19:58.552]   - Field: ‘asynchronous’
[13:19:58.552]   - Field: ‘calls’
[13:19:58.552]   - Field: ‘globals’
[13:19:58.552]   - Field: ‘stdout’
[13:19:58.552]   - Field: ‘earlySignal’
[13:19:58.552]   - Field: ‘lazy’
[13:19:58.553]   - Field: ‘state’
[13:19:58.553] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:58.553] - Launch lazy future ...
[13:19:58.553] Packages needed by the future expression (n = 0): <none>
[13:19:58.553] Packages needed by future strategies (n = 0): <none>
[13:19:58.554] {
[13:19:58.554]     {
[13:19:58.554]         {
[13:19:58.554]             ...future.startTime <- base::Sys.time()
[13:19:58.554]             {
[13:19:58.554]                 {
[13:19:58.554]                   {
[13:19:58.554]                     {
[13:19:58.554]                       base::local({
[13:19:58.554]                         has_future <- base::requireNamespace("future", 
[13:19:58.554]                           quietly = TRUE)
[13:19:58.554]                         if (has_future) {
[13:19:58.554]                           ns <- base::getNamespace("future")
[13:19:58.554]                           version <- ns[[".package"]][["version"]]
[13:19:58.554]                           if (is.null(version)) 
[13:19:58.554]                             version <- utils::packageVersion("future")
[13:19:58.554]                         }
[13:19:58.554]                         else {
[13:19:58.554]                           version <- NULL
[13:19:58.554]                         }
[13:19:58.554]                         if (!has_future || version < "1.8.0") {
[13:19:58.554]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.554]                             "", base::R.version$version.string), 
[13:19:58.554]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:58.554]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.554]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.554]                               "release", "version")], collapse = " "), 
[13:19:58.554]                             hostname = base::Sys.info()[["nodename"]])
[13:19:58.554]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.554]                             info)
[13:19:58.554]                           info <- base::paste(info, collapse = "; ")
[13:19:58.554]                           if (!has_future) {
[13:19:58.554]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.554]                               info)
[13:19:58.554]                           }
[13:19:58.554]                           else {
[13:19:58.554]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.554]                               info, version)
[13:19:58.554]                           }
[13:19:58.554]                           base::stop(msg)
[13:19:58.554]                         }
[13:19:58.554]                       })
[13:19:58.554]                     }
[13:19:58.554]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.554]                     base::options(mc.cores = 1L)
[13:19:58.554]                   }
[13:19:58.554]                   options(future.plan = NULL)
[13:19:58.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.554]                 }
[13:19:58.554]                 ...future.workdir <- getwd()
[13:19:58.554]             }
[13:19:58.554]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.554]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.554]         }
[13:19:58.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.554]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:58.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.554]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.554]             base::names(...future.oldOptions))
[13:19:58.554]     }
[13:19:58.554]     if (FALSE) {
[13:19:58.554]     }
[13:19:58.554]     else {
[13:19:58.554]         if (TRUE) {
[13:19:58.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.554]                 open = "w")
[13:19:58.554]         }
[13:19:58.554]         else {
[13:19:58.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.554]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.554]         }
[13:19:58.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.554]             base::sink(type = "output", split = FALSE)
[13:19:58.554]             base::close(...future.stdout)
[13:19:58.554]         }, add = TRUE)
[13:19:58.554]     }
[13:19:58.554]     ...future.frame <- base::sys.nframe()
[13:19:58.554]     ...future.conditions <- base::list()
[13:19:58.554]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.554]     if (FALSE) {
[13:19:58.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.554]     }
[13:19:58.554]     ...future.result <- base::tryCatch({
[13:19:58.554]         base::withCallingHandlers({
[13:19:58.554]             ...future.value <- base::withVisible(base::local({
[13:19:58.554]                 withCallingHandlers({
[13:19:58.554]                   {
[13:19:58.554]                     do.call(function(...) {
[13:19:58.554]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.554]                       if (!identical(...future.globals.maxSize.org, 
[13:19:58.554]                         ...future.globals.maxSize)) {
[13:19:58.554]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.554]                         on.exit(options(oopts), add = TRUE)
[13:19:58.554]                       }
[13:19:58.554]                       {
[13:19:58.554]                         lapply(seq_along(...future.elements_ii), 
[13:19:58.554]                           FUN = function(jj) {
[13:19:58.554]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.554]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:19:58.554]                               envir = globalenv(), inherits = FALSE)
[13:19:58.554]                             ...future.FUN(...future.X_jj, ...)
[13:19:58.554]                           })
[13:19:58.554]                       }
[13:19:58.554]                     }, args = future.call.arguments)
[13:19:58.554]                   }
[13:19:58.554]                 }, immediateCondition = function(cond) {
[13:19:58.554]                   save_rds <- function (object, pathname, ...) 
[13:19:58.554]                   {
[13:19:58.554]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:58.554]                     if (file_test("-f", pathname_tmp)) {
[13:19:58.554]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.554]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:58.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.554]                         fi_tmp[["mtime"]])
[13:19:58.554]                     }
[13:19:58.554]                     tryCatch({
[13:19:58.554]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:58.554]                     }, error = function(ex) {
[13:19:58.554]                       msg <- conditionMessage(ex)
[13:19:58.554]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.554]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:58.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.554]                         fi_tmp[["mtime"]], msg)
[13:19:58.554]                       ex$message <- msg
[13:19:58.554]                       stop(ex)
[13:19:58.554]                     })
[13:19:58.554]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:58.554]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:58.554]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:58.554]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.554]                       fi <- file.info(pathname)
[13:19:58.554]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:58.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.554]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:58.554]                         fi[["size"]], fi[["mtime"]])
[13:19:58.554]                       stop(msg)
[13:19:58.554]                     }
[13:19:58.554]                     invisible(pathname)
[13:19:58.554]                   }
[13:19:58.554]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:58.554]                     rootPath = tempdir()) 
[13:19:58.554]                   {
[13:19:58.554]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:58.554]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:58.554]                       tmpdir = path, fileext = ".rds")
[13:19:58.554]                     save_rds(obj, file)
[13:19:58.554]                   }
[13:19:58.554]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:58.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.554]                   {
[13:19:58.554]                     inherits <- base::inherits
[13:19:58.554]                     invokeRestart <- base::invokeRestart
[13:19:58.554]                     is.null <- base::is.null
[13:19:58.554]                     muffled <- FALSE
[13:19:58.554]                     if (inherits(cond, "message")) {
[13:19:58.554]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.554]                       if (muffled) 
[13:19:58.554]                         invokeRestart("muffleMessage")
[13:19:58.554]                     }
[13:19:58.554]                     else if (inherits(cond, "warning")) {
[13:19:58.554]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.554]                       if (muffled) 
[13:19:58.554]                         invokeRestart("muffleWarning")
[13:19:58.554]                     }
[13:19:58.554]                     else if (inherits(cond, "condition")) {
[13:19:58.554]                       if (!is.null(pattern)) {
[13:19:58.554]                         computeRestarts <- base::computeRestarts
[13:19:58.554]                         grepl <- base::grepl
[13:19:58.554]                         restarts <- computeRestarts(cond)
[13:19:58.554]                         for (restart in restarts) {
[13:19:58.554]                           name <- restart$name
[13:19:58.554]                           if (is.null(name)) 
[13:19:58.554]                             next
[13:19:58.554]                           if (!grepl(pattern, name)) 
[13:19:58.554]                             next
[13:19:58.554]                           invokeRestart(restart)
[13:19:58.554]                           muffled <- TRUE
[13:19:58.554]                           break
[13:19:58.554]                         }
[13:19:58.554]                       }
[13:19:58.554]                     }
[13:19:58.554]                     invisible(muffled)
[13:19:58.554]                   }
[13:19:58.554]                   muffleCondition(cond)
[13:19:58.554]                 })
[13:19:58.554]             }))
[13:19:58.554]             future::FutureResult(value = ...future.value$value, 
[13:19:58.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.554]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.554]                     ...future.globalenv.names))
[13:19:58.554]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.554]         }, condition = base::local({
[13:19:58.554]             c <- base::c
[13:19:58.554]             inherits <- base::inherits
[13:19:58.554]             invokeRestart <- base::invokeRestart
[13:19:58.554]             length <- base::length
[13:19:58.554]             list <- base::list
[13:19:58.554]             seq.int <- base::seq.int
[13:19:58.554]             signalCondition <- base::signalCondition
[13:19:58.554]             sys.calls <- base::sys.calls
[13:19:58.554]             `[[` <- base::`[[`
[13:19:58.554]             `+` <- base::`+`
[13:19:58.554]             `<<-` <- base::`<<-`
[13:19:58.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.554]                   3L)]
[13:19:58.554]             }
[13:19:58.554]             function(cond) {
[13:19:58.554]                 is_error <- inherits(cond, "error")
[13:19:58.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.554]                   NULL)
[13:19:58.554]                 if (is_error) {
[13:19:58.554]                   sessionInformation <- function() {
[13:19:58.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.554]                       search = base::search(), system = base::Sys.info())
[13:19:58.554]                   }
[13:19:58.554]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.554]                     cond$call), session = sessionInformation(), 
[13:19:58.554]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.554]                   signalCondition(cond)
[13:19:58.554]                 }
[13:19:58.554]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:19:58.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.554]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.554]                   if (TRUE && !signal) {
[13:19:58.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.554]                     {
[13:19:58.554]                       inherits <- base::inherits
[13:19:58.554]                       invokeRestart <- base::invokeRestart
[13:19:58.554]                       is.null <- base::is.null
[13:19:58.554]                       muffled <- FALSE
[13:19:58.554]                       if (inherits(cond, "message")) {
[13:19:58.554]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.554]                         if (muffled) 
[13:19:58.554]                           invokeRestart("muffleMessage")
[13:19:58.554]                       }
[13:19:58.554]                       else if (inherits(cond, "warning")) {
[13:19:58.554]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.554]                         if (muffled) 
[13:19:58.554]                           invokeRestart("muffleWarning")
[13:19:58.554]                       }
[13:19:58.554]                       else if (inherits(cond, "condition")) {
[13:19:58.554]                         if (!is.null(pattern)) {
[13:19:58.554]                           computeRestarts <- base::computeRestarts
[13:19:58.554]                           grepl <- base::grepl
[13:19:58.554]                           restarts <- computeRestarts(cond)
[13:19:58.554]                           for (restart in restarts) {
[13:19:58.554]                             name <- restart$name
[13:19:58.554]                             if (is.null(name)) 
[13:19:58.554]                               next
[13:19:58.554]                             if (!grepl(pattern, name)) 
[13:19:58.554]                               next
[13:19:58.554]                             invokeRestart(restart)
[13:19:58.554]                             muffled <- TRUE
[13:19:58.554]                             break
[13:19:58.554]                           }
[13:19:58.554]                         }
[13:19:58.554]                       }
[13:19:58.554]                       invisible(muffled)
[13:19:58.554]                     }
[13:19:58.554]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.554]                   }
[13:19:58.554]                 }
[13:19:58.554]                 else {
[13:19:58.554]                   if (TRUE) {
[13:19:58.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.554]                     {
[13:19:58.554]                       inherits <- base::inherits
[13:19:58.554]                       invokeRestart <- base::invokeRestart
[13:19:58.554]                       is.null <- base::is.null
[13:19:58.554]                       muffled <- FALSE
[13:19:58.554]                       if (inherits(cond, "message")) {
[13:19:58.554]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.554]                         if (muffled) 
[13:19:58.554]                           invokeRestart("muffleMessage")
[13:19:58.554]                       }
[13:19:58.554]                       else if (inherits(cond, "warning")) {
[13:19:58.554]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.554]                         if (muffled) 
[13:19:58.554]                           invokeRestart("muffleWarning")
[13:19:58.554]                       }
[13:19:58.554]                       else if (inherits(cond, "condition")) {
[13:19:58.554]                         if (!is.null(pattern)) {
[13:19:58.554]                           computeRestarts <- base::computeRestarts
[13:19:58.554]                           grepl <- base::grepl
[13:19:58.554]                           restarts <- computeRestarts(cond)
[13:19:58.554]                           for (restart in restarts) {
[13:19:58.554]                             name <- restart$name
[13:19:58.554]                             if (is.null(name)) 
[13:19:58.554]                               next
[13:19:58.554]                             if (!grepl(pattern, name)) 
[13:19:58.554]                               next
[13:19:58.554]                             invokeRestart(restart)
[13:19:58.554]                             muffled <- TRUE
[13:19:58.554]                             break
[13:19:58.554]                           }
[13:19:58.554]                         }
[13:19:58.554]                       }
[13:19:58.554]                       invisible(muffled)
[13:19:58.554]                     }
[13:19:58.554]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.554]                   }
[13:19:58.554]                 }
[13:19:58.554]             }
[13:19:58.554]         }))
[13:19:58.554]     }, error = function(ex) {
[13:19:58.554]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.554]                 ...future.rng), started = ...future.startTime, 
[13:19:58.554]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.554]             version = "1.8"), class = "FutureResult")
[13:19:58.554]     }, finally = {
[13:19:58.554]         if (!identical(...future.workdir, getwd())) 
[13:19:58.554]             setwd(...future.workdir)
[13:19:58.554]         {
[13:19:58.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.554]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.554]             }
[13:19:58.554]             base::options(...future.oldOptions)
[13:19:58.554]             if (.Platform$OS.type == "windows") {
[13:19:58.554]                 old_names <- names(...future.oldEnvVars)
[13:19:58.554]                 envs <- base::Sys.getenv()
[13:19:58.554]                 names <- names(envs)
[13:19:58.554]                 common <- intersect(names, old_names)
[13:19:58.554]                 added <- setdiff(names, old_names)
[13:19:58.554]                 removed <- setdiff(old_names, names)
[13:19:58.554]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.554]                   envs[common]]
[13:19:58.554]                 NAMES <- toupper(changed)
[13:19:58.554]                 args <- list()
[13:19:58.554]                 for (kk in seq_along(NAMES)) {
[13:19:58.554]                   name <- changed[[kk]]
[13:19:58.554]                   NAME <- NAMES[[kk]]
[13:19:58.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.554]                     next
[13:19:58.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.554]                 }
[13:19:58.554]                 NAMES <- toupper(added)
[13:19:58.554]                 for (kk in seq_along(NAMES)) {
[13:19:58.554]                   name <- added[[kk]]
[13:19:58.554]                   NAME <- NAMES[[kk]]
[13:19:58.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.554]                     next
[13:19:58.554]                   args[[name]] <- ""
[13:19:58.554]                 }
[13:19:58.554]                 NAMES <- toupper(removed)
[13:19:58.554]                 for (kk in seq_along(NAMES)) {
[13:19:58.554]                   name <- removed[[kk]]
[13:19:58.554]                   NAME <- NAMES[[kk]]
[13:19:58.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.554]                     next
[13:19:58.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.554]                 }
[13:19:58.554]                 if (length(args) > 0) 
[13:19:58.554]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.554]             }
[13:19:58.554]             else {
[13:19:58.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.554]             }
[13:19:58.554]             {
[13:19:58.554]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.554]                   0L) {
[13:19:58.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.554]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.554]                   base::options(opts)
[13:19:58.554]                 }
[13:19:58.554]                 {
[13:19:58.554]                   {
[13:19:58.554]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.554]                     NULL
[13:19:58.554]                   }
[13:19:58.554]                   options(future.plan = NULL)
[13:19:58.554]                   if (is.na(NA_character_)) 
[13:19:58.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.554]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:58.554]                     envir = parent.frame()) 
[13:19:58.554]                   {
[13:19:58.554]                     default_workers <- missing(workers)
[13:19:58.554]                     if (is.function(workers)) 
[13:19:58.554]                       workers <- workers()
[13:19:58.554]                     workers <- structure(as.integer(workers), 
[13:19:58.554]                       class = class(workers))
[13:19:58.554]                     stop_if_not(is.finite(workers), workers >= 
[13:19:58.554]                       1L)
[13:19:58.554]                     if ((workers == 1L && !inherits(workers, 
[13:19:58.554]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:58.554]                       if (default_workers) 
[13:19:58.554]                         supportsMulticore(warn = TRUE)
[13:19:58.554]                       return(sequential(..., envir = envir))
[13:19:58.554]                     }
[13:19:58.554]                     oopts <- options(mc.cores = workers)
[13:19:58.554]                     on.exit(options(oopts))
[13:19:58.554]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:58.554]                       envir = envir)
[13:19:58.554]                     if (!future$lazy) 
[13:19:58.554]                       future <- run(future)
[13:19:58.554]                     invisible(future)
[13:19:58.554]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.554]                 }
[13:19:58.554]             }
[13:19:58.554]         }
[13:19:58.554]     })
[13:19:58.554]     if (TRUE) {
[13:19:58.554]         base::sink(type = "output", split = FALSE)
[13:19:58.554]         if (TRUE) {
[13:19:58.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.554]         }
[13:19:58.554]         else {
[13:19:58.554]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.554]         }
[13:19:58.554]         base::close(...future.stdout)
[13:19:58.554]         ...future.stdout <- NULL
[13:19:58.554]     }
[13:19:58.554]     ...future.result$conditions <- ...future.conditions
[13:19:58.554]     ...future.result$finished <- base::Sys.time()
[13:19:58.554]     ...future.result
[13:19:58.554] }
[13:19:58.556] assign_globals() ...
[13:19:58.556] List of 5
[13:19:58.556]  $ future.call.arguments    : list()
[13:19:58.556]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.556]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[13:19:58.556]  $ ...future.elements_ii    :List of 1
[13:19:58.556]   ..$ : int [1:2] 1 3
[13:19:58.556]  $ ...future.seeds_ii       :List of 1
[13:19:58.556]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[13:19:58.556]  $ ...future.globals.maxSize: num Inf
[13:19:58.556]  - attr(*, "resolved")= logi FALSE
[13:19:58.556]  - attr(*, "total_size")= num NA
[13:19:58.556]  - attr(*, "where")=List of 5
[13:19:58.556]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:58.556]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:58.556]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:58.556]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:58.556]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:58.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.556]  - attr(*, "already-done")= logi TRUE
[13:19:58.562] - copied ‘future.call.arguments’ to environment
[13:19:58.562] - copied ‘...future.FUN’ to environment
[13:19:58.562] - copied ‘...future.elements_ii’ to environment
[13:19:58.562] - copied ‘...future.seeds_ii’ to environment
[13:19:58.562] - copied ‘...future.globals.maxSize’ to environment
[13:19:58.562] assign_globals() ... done
[13:19:58.562] requestCore(): workers = 2
[13:19:58.565] MulticoreFuture started
[13:19:58.565] - Launch lazy future ... done
[13:19:58.565] run() for ‘MulticoreFuture’ ... done
[13:19:58.565] Created future:
[13:19:58.566] plan(): Setting new future strategy stack:
[13:19:58.566] List of future strategies:
[13:19:58.566] 1. sequential:
[13:19:58.566]    - args: function (..., envir = parent.frame())
[13:19:58.566]    - tweaked: FALSE
[13:19:58.566]    - call: NULL
[13:19:58.570] plan(): nbrOfWorkers() = 1
[13:19:58.573] plan(): Setting new future strategy stack:
[13:19:58.573] List of future strategies:
[13:19:58.573] 1. multicore:
[13:19:58.573]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:58.573]    - tweaked: FALSE
[13:19:58.573]    - call: plan(strategy)
[13:19:58.581] plan(): nbrOfWorkers() = 2
[13:19:58.566] MulticoreFuture:
[13:19:58.566] Label: ‘future_apply-1’
[13:19:58.566] Expression:
[13:19:58.566] {
[13:19:58.566]     do.call(function(...) {
[13:19:58.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.566]             on.exit(options(oopts), add = TRUE)
[13:19:58.566]         }
[13:19:58.566]         {
[13:19:58.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.566]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:19:58.566]                   envir = globalenv(), inherits = FALSE)
[13:19:58.566]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.566]             })
[13:19:58.566]         }
[13:19:58.566]     }, args = future.call.arguments)
[13:19:58.566] }
[13:19:58.566] Lazy evaluation: FALSE
[13:19:58.566] Asynchronous evaluation: TRUE
[13:19:58.566] Local evaluation: TRUE
[13:19:58.566] Environment: R_GlobalEnv
[13:19:58.566] Capture standard output: TRUE
[13:19:58.566] Capture condition classes: <none>
[13:19:58.566] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:58.566] Packages: <none>
[13:19:58.566] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:19:58.566] Resolved: TRUE
[13:19:58.566] Value: <not collected>
[13:19:58.566] Conditions captured: <none>
[13:19:58.566] Early signaling: FALSE
[13:19:58.566] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:58.566] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.582] Chunk #1 of 2 ... DONE
[13:19:58.582] Chunk #2 of 2 ...
[13:19:58.583]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:58.583]  - seeds: [1] <seeds>
[13:19:58.583]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.583] getGlobalsAndPackages() ...
[13:19:58.584] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.584] Resolving globals: FALSE
[13:19:58.584] Tweak future expression to call with '...' arguments ...
[13:19:58.584] {
[13:19:58.584]     do.call(function(...) {
[13:19:58.584]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.584]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.584]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.584]             on.exit(options(oopts), add = TRUE)
[13:19:58.584]         }
[13:19:58.584]         {
[13:19:58.584]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.584]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.584]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:19:58.584]                   envir = globalenv(), inherits = FALSE)
[13:19:58.584]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.584]             })
[13:19:58.584]         }
[13:19:58.584]     }, args = future.call.arguments)
[13:19:58.584] }
[13:19:58.585] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.586] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:58.586] 
[13:19:58.586] getGlobalsAndPackages() ... DONE
[13:19:58.587] run() for ‘Future’ ...
[13:19:58.587] - state: ‘created’
[13:19:58.588] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.593] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.593] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:58.594]   - Field: ‘label’
[13:19:58.594]   - Field: ‘local’
[13:19:58.594]   - Field: ‘owner’
[13:19:58.594]   - Field: ‘envir’
[13:19:58.594]   - Field: ‘workers’
[13:19:58.594]   - Field: ‘packages’
[13:19:58.595]   - Field: ‘gc’
[13:19:58.595]   - Field: ‘job’
[13:19:58.595]   - Field: ‘conditions’
[13:19:58.595]   - Field: ‘expr’
[13:19:58.595]   - Field: ‘uuid’
[13:19:58.595]   - Field: ‘seed’
[13:19:58.595]   - Field: ‘version’
[13:19:58.596]   - Field: ‘result’
[13:19:58.596]   - Field: ‘asynchronous’
[13:19:58.596]   - Field: ‘calls’
[13:19:58.596]   - Field: ‘globals’
[13:19:58.597]   - Field: ‘stdout’
[13:19:58.597]   - Field: ‘earlySignal’
[13:19:58.597]   - Field: ‘lazy’
[13:19:58.597]   - Field: ‘state’
[13:19:58.597] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:58.597] - Launch lazy future ...
[13:19:58.598] Packages needed by the future expression (n = 0): <none>
[13:19:58.598] Packages needed by future strategies (n = 0): <none>
[13:19:58.599] {
[13:19:58.599]     {
[13:19:58.599]         {
[13:19:58.599]             ...future.startTime <- base::Sys.time()
[13:19:58.599]             {
[13:19:58.599]                 {
[13:19:58.599]                   {
[13:19:58.599]                     {
[13:19:58.599]                       base::local({
[13:19:58.599]                         has_future <- base::requireNamespace("future", 
[13:19:58.599]                           quietly = TRUE)
[13:19:58.599]                         if (has_future) {
[13:19:58.599]                           ns <- base::getNamespace("future")
[13:19:58.599]                           version <- ns[[".package"]][["version"]]
[13:19:58.599]                           if (is.null(version)) 
[13:19:58.599]                             version <- utils::packageVersion("future")
[13:19:58.599]                         }
[13:19:58.599]                         else {
[13:19:58.599]                           version <- NULL
[13:19:58.599]                         }
[13:19:58.599]                         if (!has_future || version < "1.8.0") {
[13:19:58.599]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.599]                             "", base::R.version$version.string), 
[13:19:58.599]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:58.599]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.599]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.599]                               "release", "version")], collapse = " "), 
[13:19:58.599]                             hostname = base::Sys.info()[["nodename"]])
[13:19:58.599]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.599]                             info)
[13:19:58.599]                           info <- base::paste(info, collapse = "; ")
[13:19:58.599]                           if (!has_future) {
[13:19:58.599]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.599]                               info)
[13:19:58.599]                           }
[13:19:58.599]                           else {
[13:19:58.599]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.599]                               info, version)
[13:19:58.599]                           }
[13:19:58.599]                           base::stop(msg)
[13:19:58.599]                         }
[13:19:58.599]                       })
[13:19:58.599]                     }
[13:19:58.599]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.599]                     base::options(mc.cores = 1L)
[13:19:58.599]                   }
[13:19:58.599]                   options(future.plan = NULL)
[13:19:58.599]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.599]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.599]                 }
[13:19:58.599]                 ...future.workdir <- getwd()
[13:19:58.599]             }
[13:19:58.599]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.599]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.599]         }
[13:19:58.599]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.599]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:58.599]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.599]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.599]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.599]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.599]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.599]             base::names(...future.oldOptions))
[13:19:58.599]     }
[13:19:58.599]     if (FALSE) {
[13:19:58.599]     }
[13:19:58.599]     else {
[13:19:58.599]         if (TRUE) {
[13:19:58.599]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.599]                 open = "w")
[13:19:58.599]         }
[13:19:58.599]         else {
[13:19:58.599]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.599]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.599]         }
[13:19:58.599]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.599]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.599]             base::sink(type = "output", split = FALSE)
[13:19:58.599]             base::close(...future.stdout)
[13:19:58.599]         }, add = TRUE)
[13:19:58.599]     }
[13:19:58.599]     ...future.frame <- base::sys.nframe()
[13:19:58.599]     ...future.conditions <- base::list()
[13:19:58.599]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.599]     if (FALSE) {
[13:19:58.599]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.599]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.599]     }
[13:19:58.599]     ...future.result <- base::tryCatch({
[13:19:58.599]         base::withCallingHandlers({
[13:19:58.599]             ...future.value <- base::withVisible(base::local({
[13:19:58.599]                 withCallingHandlers({
[13:19:58.599]                   {
[13:19:58.599]                     do.call(function(...) {
[13:19:58.599]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.599]                       if (!identical(...future.globals.maxSize.org, 
[13:19:58.599]                         ...future.globals.maxSize)) {
[13:19:58.599]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.599]                         on.exit(options(oopts), add = TRUE)
[13:19:58.599]                       }
[13:19:58.599]                       {
[13:19:58.599]                         lapply(seq_along(...future.elements_ii), 
[13:19:58.599]                           FUN = function(jj) {
[13:19:58.599]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.599]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:19:58.599]                               envir = globalenv(), inherits = FALSE)
[13:19:58.599]                             ...future.FUN(...future.X_jj, ...)
[13:19:58.599]                           })
[13:19:58.599]                       }
[13:19:58.599]                     }, args = future.call.arguments)
[13:19:58.599]                   }
[13:19:58.599]                 }, immediateCondition = function(cond) {
[13:19:58.599]                   save_rds <- function (object, pathname, ...) 
[13:19:58.599]                   {
[13:19:58.599]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:58.599]                     if (file_test("-f", pathname_tmp)) {
[13:19:58.599]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.599]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:58.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.599]                         fi_tmp[["mtime"]])
[13:19:58.599]                     }
[13:19:58.599]                     tryCatch({
[13:19:58.599]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:58.599]                     }, error = function(ex) {
[13:19:58.599]                       msg <- conditionMessage(ex)
[13:19:58.599]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.599]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:58.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.599]                         fi_tmp[["mtime"]], msg)
[13:19:58.599]                       ex$message <- msg
[13:19:58.599]                       stop(ex)
[13:19:58.599]                     })
[13:19:58.599]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:58.599]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:58.599]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:58.599]                       fi_tmp <- file.info(pathname_tmp)
[13:19:58.599]                       fi <- file.info(pathname)
[13:19:58.599]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:58.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:58.599]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:58.599]                         fi[["size"]], fi[["mtime"]])
[13:19:58.599]                       stop(msg)
[13:19:58.599]                     }
[13:19:58.599]                     invisible(pathname)
[13:19:58.599]                   }
[13:19:58.599]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:58.599]                     rootPath = tempdir()) 
[13:19:58.599]                   {
[13:19:58.599]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:58.599]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:58.599]                       tmpdir = path, fileext = ".rds")
[13:19:58.599]                     save_rds(obj, file)
[13:19:58.599]                   }
[13:19:58.599]                   saveImmediateCondition(cond, path = "/tmp/RtmpkIm7zZ/.future/immediateConditions")
[13:19:58.599]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.599]                   {
[13:19:58.599]                     inherits <- base::inherits
[13:19:58.599]                     invokeRestart <- base::invokeRestart
[13:19:58.599]                     is.null <- base::is.null
[13:19:58.599]                     muffled <- FALSE
[13:19:58.599]                     if (inherits(cond, "message")) {
[13:19:58.599]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.599]                       if (muffled) 
[13:19:58.599]                         invokeRestart("muffleMessage")
[13:19:58.599]                     }
[13:19:58.599]                     else if (inherits(cond, "warning")) {
[13:19:58.599]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.599]                       if (muffled) 
[13:19:58.599]                         invokeRestart("muffleWarning")
[13:19:58.599]                     }
[13:19:58.599]                     else if (inherits(cond, "condition")) {
[13:19:58.599]                       if (!is.null(pattern)) {
[13:19:58.599]                         computeRestarts <- base::computeRestarts
[13:19:58.599]                         grepl <- base::grepl
[13:19:58.599]                         restarts <- computeRestarts(cond)
[13:19:58.599]                         for (restart in restarts) {
[13:19:58.599]                           name <- restart$name
[13:19:58.599]                           if (is.null(name)) 
[13:19:58.599]                             next
[13:19:58.599]                           if (!grepl(pattern, name)) 
[13:19:58.599]                             next
[13:19:58.599]                           invokeRestart(restart)
[13:19:58.599]                           muffled <- TRUE
[13:19:58.599]                           break
[13:19:58.599]                         }
[13:19:58.599]                       }
[13:19:58.599]                     }
[13:19:58.599]                     invisible(muffled)
[13:19:58.599]                   }
[13:19:58.599]                   muffleCondition(cond)
[13:19:58.599]                 })
[13:19:58.599]             }))
[13:19:58.599]             future::FutureResult(value = ...future.value$value, 
[13:19:58.599]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.599]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.599]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.599]                     ...future.globalenv.names))
[13:19:58.599]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.599]         }, condition = base::local({
[13:19:58.599]             c <- base::c
[13:19:58.599]             inherits <- base::inherits
[13:19:58.599]             invokeRestart <- base::invokeRestart
[13:19:58.599]             length <- base::length
[13:19:58.599]             list <- base::list
[13:19:58.599]             seq.int <- base::seq.int
[13:19:58.599]             signalCondition <- base::signalCondition
[13:19:58.599]             sys.calls <- base::sys.calls
[13:19:58.599]             `[[` <- base::`[[`
[13:19:58.599]             `+` <- base::`+`
[13:19:58.599]             `<<-` <- base::`<<-`
[13:19:58.599]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.599]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.599]                   3L)]
[13:19:58.599]             }
[13:19:58.599]             function(cond) {
[13:19:58.599]                 is_error <- inherits(cond, "error")
[13:19:58.599]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.599]                   NULL)
[13:19:58.599]                 if (is_error) {
[13:19:58.599]                   sessionInformation <- function() {
[13:19:58.599]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.599]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.599]                       search = base::search(), system = base::Sys.info())
[13:19:58.599]                   }
[13:19:58.599]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.599]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.599]                     cond$call), session = sessionInformation(), 
[13:19:58.599]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.599]                   signalCondition(cond)
[13:19:58.599]                 }
[13:19:58.599]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:19:58.599]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.599]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.599]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.599]                   if (TRUE && !signal) {
[13:19:58.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.599]                     {
[13:19:58.599]                       inherits <- base::inherits
[13:19:58.599]                       invokeRestart <- base::invokeRestart
[13:19:58.599]                       is.null <- base::is.null
[13:19:58.599]                       muffled <- FALSE
[13:19:58.599]                       if (inherits(cond, "message")) {
[13:19:58.599]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.599]                         if (muffled) 
[13:19:58.599]                           invokeRestart("muffleMessage")
[13:19:58.599]                       }
[13:19:58.599]                       else if (inherits(cond, "warning")) {
[13:19:58.599]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.599]                         if (muffled) 
[13:19:58.599]                           invokeRestart("muffleWarning")
[13:19:58.599]                       }
[13:19:58.599]                       else if (inherits(cond, "condition")) {
[13:19:58.599]                         if (!is.null(pattern)) {
[13:19:58.599]                           computeRestarts <- base::computeRestarts
[13:19:58.599]                           grepl <- base::grepl
[13:19:58.599]                           restarts <- computeRestarts(cond)
[13:19:58.599]                           for (restart in restarts) {
[13:19:58.599]                             name <- restart$name
[13:19:58.599]                             if (is.null(name)) 
[13:19:58.599]                               next
[13:19:58.599]                             if (!grepl(pattern, name)) 
[13:19:58.599]                               next
[13:19:58.599]                             invokeRestart(restart)
[13:19:58.599]                             muffled <- TRUE
[13:19:58.599]                             break
[13:19:58.599]                           }
[13:19:58.599]                         }
[13:19:58.599]                       }
[13:19:58.599]                       invisible(muffled)
[13:19:58.599]                     }
[13:19:58.599]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.599]                   }
[13:19:58.599]                 }
[13:19:58.599]                 else {
[13:19:58.599]                   if (TRUE) {
[13:19:58.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.599]                     {
[13:19:58.599]                       inherits <- base::inherits
[13:19:58.599]                       invokeRestart <- base::invokeRestart
[13:19:58.599]                       is.null <- base::is.null
[13:19:58.599]                       muffled <- FALSE
[13:19:58.599]                       if (inherits(cond, "message")) {
[13:19:58.599]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.599]                         if (muffled) 
[13:19:58.599]                           invokeRestart("muffleMessage")
[13:19:58.599]                       }
[13:19:58.599]                       else if (inherits(cond, "warning")) {
[13:19:58.599]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.599]                         if (muffled) 
[13:19:58.599]                           invokeRestart("muffleWarning")
[13:19:58.599]                       }
[13:19:58.599]                       else if (inherits(cond, "condition")) {
[13:19:58.599]                         if (!is.null(pattern)) {
[13:19:58.599]                           computeRestarts <- base::computeRestarts
[13:19:58.599]                           grepl <- base::grepl
[13:19:58.599]                           restarts <- computeRestarts(cond)
[13:19:58.599]                           for (restart in restarts) {
[13:19:58.599]                             name <- restart$name
[13:19:58.599]                             if (is.null(name)) 
[13:19:58.599]                               next
[13:19:58.599]                             if (!grepl(pattern, name)) 
[13:19:58.599]                               next
[13:19:58.599]                             invokeRestart(restart)
[13:19:58.599]                             muffled <- TRUE
[13:19:58.599]                             break
[13:19:58.599]                           }
[13:19:58.599]                         }
[13:19:58.599]                       }
[13:19:58.599]                       invisible(muffled)
[13:19:58.599]                     }
[13:19:58.599]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.599]                   }
[13:19:58.599]                 }
[13:19:58.599]             }
[13:19:58.599]         }))
[13:19:58.599]     }, error = function(ex) {
[13:19:58.599]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.599]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.599]                 ...future.rng), started = ...future.startTime, 
[13:19:58.599]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.599]             version = "1.8"), class = "FutureResult")
[13:19:58.599]     }, finally = {
[13:19:58.599]         if (!identical(...future.workdir, getwd())) 
[13:19:58.599]             setwd(...future.workdir)
[13:19:58.599]         {
[13:19:58.599]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.599]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.599]             }
[13:19:58.599]             base::options(...future.oldOptions)
[13:19:58.599]             if (.Platform$OS.type == "windows") {
[13:19:58.599]                 old_names <- names(...future.oldEnvVars)
[13:19:58.599]                 envs <- base::Sys.getenv()
[13:19:58.599]                 names <- names(envs)
[13:19:58.599]                 common <- intersect(names, old_names)
[13:19:58.599]                 added <- setdiff(names, old_names)
[13:19:58.599]                 removed <- setdiff(old_names, names)
[13:19:58.599]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.599]                   envs[common]]
[13:19:58.599]                 NAMES <- toupper(changed)
[13:19:58.599]                 args <- list()
[13:19:58.599]                 for (kk in seq_along(NAMES)) {
[13:19:58.599]                   name <- changed[[kk]]
[13:19:58.599]                   NAME <- NAMES[[kk]]
[13:19:58.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.599]                     next
[13:19:58.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.599]                 }
[13:19:58.599]                 NAMES <- toupper(added)
[13:19:58.599]                 for (kk in seq_along(NAMES)) {
[13:19:58.599]                   name <- added[[kk]]
[13:19:58.599]                   NAME <- NAMES[[kk]]
[13:19:58.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.599]                     next
[13:19:58.599]                   args[[name]] <- ""
[13:19:58.599]                 }
[13:19:58.599]                 NAMES <- toupper(removed)
[13:19:58.599]                 for (kk in seq_along(NAMES)) {
[13:19:58.599]                   name <- removed[[kk]]
[13:19:58.599]                   NAME <- NAMES[[kk]]
[13:19:58.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.599]                     next
[13:19:58.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.599]                 }
[13:19:58.599]                 if (length(args) > 0) 
[13:19:58.599]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.599]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.599]             }
[13:19:58.599]             else {
[13:19:58.599]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.599]             }
[13:19:58.599]             {
[13:19:58.599]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.599]                   0L) {
[13:19:58.599]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.599]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.599]                   base::options(opts)
[13:19:58.599]                 }
[13:19:58.599]                 {
[13:19:58.599]                   {
[13:19:58.599]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.599]                     NULL
[13:19:58.599]                   }
[13:19:58.599]                   options(future.plan = NULL)
[13:19:58.599]                   if (is.na(NA_character_)) 
[13:19:58.599]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.599]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.599]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:58.599]                     envir = parent.frame()) 
[13:19:58.599]                   {
[13:19:58.599]                     default_workers <- missing(workers)
[13:19:58.599]                     if (is.function(workers)) 
[13:19:58.599]                       workers <- workers()
[13:19:58.599]                     workers <- structure(as.integer(workers), 
[13:19:58.599]                       class = class(workers))
[13:19:58.599]                     stop_if_not(is.finite(workers), workers >= 
[13:19:58.599]                       1L)
[13:19:58.599]                     if ((workers == 1L && !inherits(workers, 
[13:19:58.599]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:58.599]                       if (default_workers) 
[13:19:58.599]                         supportsMulticore(warn = TRUE)
[13:19:58.599]                       return(sequential(..., envir = envir))
[13:19:58.599]                     }
[13:19:58.599]                     oopts <- options(mc.cores = workers)
[13:19:58.599]                     on.exit(options(oopts))
[13:19:58.599]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:58.599]                       envir = envir)
[13:19:58.599]                     if (!future$lazy) 
[13:19:58.599]                       future <- run(future)
[13:19:58.599]                     invisible(future)
[13:19:58.599]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.599]                 }
[13:19:58.599]             }
[13:19:58.599]         }
[13:19:58.599]     })
[13:19:58.599]     if (TRUE) {
[13:19:58.599]         base::sink(type = "output", split = FALSE)
[13:19:58.599]         if (TRUE) {
[13:19:58.599]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.599]         }
[13:19:58.599]         else {
[13:19:58.599]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.599]         }
[13:19:58.599]         base::close(...future.stdout)
[13:19:58.599]         ...future.stdout <- NULL
[13:19:58.599]     }
[13:19:58.599]     ...future.result$conditions <- ...future.conditions
[13:19:58.599]     ...future.result$finished <- base::Sys.time()
[13:19:58.599]     ...future.result
[13:19:58.599] }
[13:19:58.602] assign_globals() ...
[13:19:58.602] List of 5
[13:19:58.602]  $ future.call.arguments    : list()
[13:19:58.602]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.602]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[13:19:58.602]  $ ...future.elements_ii    :List of 1
[13:19:58.602]   ..$ : int [1:2] 2 4
[13:19:58.602]  $ ...future.seeds_ii       :List of 1
[13:19:58.602]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[13:19:58.602]  $ ...future.globals.maxSize: num Inf
[13:19:58.602]  - attr(*, "resolved")= logi FALSE
[13:19:58.602]  - attr(*, "total_size")= num NA
[13:19:58.602]  - attr(*, "where")=List of 5
[13:19:58.602]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:58.602]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:58.602]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:58.602]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:58.602]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:58.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.602]  - attr(*, "already-done")= logi TRUE
[13:19:58.609] - copied ‘future.call.arguments’ to environment
[13:19:58.609] - copied ‘...future.FUN’ to environment
[13:19:58.609] - copied ‘...future.elements_ii’ to environment
[13:19:58.609] - copied ‘...future.seeds_ii’ to environment
[13:19:58.609] - copied ‘...future.globals.maxSize’ to environment
[13:19:58.609] assign_globals() ... done
[13:19:58.609] requestCore(): workers = 2
[13:19:58.612] MulticoreFuture started
[13:19:58.612] - Launch lazy future ... done
[13:19:58.612] run() for ‘MulticoreFuture’ ... done
[13:19:58.613] Created future:
[13:19:58.613] plan(): Setting new future strategy stack:
[13:19:58.613] List of future strategies:
[13:19:58.613] 1. sequential:
[13:19:58.613]    - args: function (..., envir = parent.frame())
[13:19:58.613]    - tweaked: FALSE
[13:19:58.613]    - call: NULL
[13:19:58.614] plan(): nbrOfWorkers() = 1
[13:19:58.616] plan(): Setting new future strategy stack:
[13:19:58.616] List of future strategies:
[13:19:58.616] 1. multicore:
[13:19:58.616]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:58.616]    - tweaked: FALSE
[13:19:58.616]    - call: plan(strategy)
[13:19:58.622] plan(): nbrOfWorkers() = 2
[13:19:58.613] MulticoreFuture:
[13:19:58.613] Label: ‘future_apply-2’
[13:19:58.613] Expression:
[13:19:58.613] {
[13:19:58.613]     do.call(function(...) {
[13:19:58.613]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:58.613]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:58.613]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:58.613]             on.exit(options(oopts), add = TRUE)
[13:19:58.613]         }
[13:19:58.613]         {
[13:19:58.613]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:58.613]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:58.613]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:19:58.613]                   envir = globalenv(), inherits = FALSE)
[13:19:58.613]                 ...future.FUN(...future.X_jj, ...)
[13:19:58.613]             })
[13:19:58.613]         }
[13:19:58.613]     }, args = future.call.arguments)
[13:19:58.613] }
[13:19:58.613] Lazy evaluation: FALSE
[13:19:58.613] Asynchronous evaluation: TRUE
[13:19:58.613] Local evaluation: TRUE
[13:19:58.613] Environment: R_GlobalEnv
[13:19:58.613] Capture standard output: TRUE
[13:19:58.613] Capture condition classes: <none>
[13:19:58.613] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:58.613] Packages: <none>
[13:19:58.613] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:19:58.613] Resolved: TRUE
[13:19:58.613] Value: <not collected>
[13:19:58.613] Conditions captured: <none>
[13:19:58.613] Early signaling: FALSE
[13:19:58.613] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:58.613] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.623] Chunk #2 of 2 ... DONE
[13:19:58.623] Launching 2 futures (chunks) ... DONE
[13:19:58.623] Resolving 2 futures (chunks) ...
[13:19:58.623] resolve() on list ...
[13:19:58.623]  recursive: 0
[13:19:58.623]  length: 2
[13:19:58.624] 
[13:19:58.624] Future #1
[13:19:58.624] result() for MulticoreFuture ...
[13:19:58.625] result() for MulticoreFuture ...
[13:19:58.625] result() for MulticoreFuture ... done
[13:19:58.625] result() for MulticoreFuture ... done
[13:19:58.625] result() for MulticoreFuture ...
[13:19:58.626] result() for MulticoreFuture ... done
[13:19:58.626] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:58.626] - nx: 2
[13:19:58.626] - relay: TRUE
[13:19:58.626] - stdout: TRUE
[13:19:58.626] - signal: TRUE
[13:19:58.627] - resignal: FALSE
[13:19:58.627] - force: TRUE
[13:19:58.627] - relayed: [n=2] FALSE, FALSE
[13:19:58.627] - queued futures: [n=2] FALSE, FALSE
[13:19:58.627]  - until=1
[13:19:58.627]  - relaying element #1
[13:19:58.627] result() for MulticoreFuture ...
[13:19:58.628] result() for MulticoreFuture ... done
[13:19:58.628] result() for MulticoreFuture ...
[13:19:58.628] result() for MulticoreFuture ... done
[13:19:58.628] result() for MulticoreFuture ...
[13:19:58.628] result() for MulticoreFuture ... done
[13:19:58.628] result() for MulticoreFuture ...
[13:19:58.629] result() for MulticoreFuture ... done
[13:19:58.629] - relayed: [n=2] TRUE, FALSE
[13:19:58.629] - queued futures: [n=2] TRUE, FALSE
[13:19:58.629] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:58.629]  length: 1 (resolved future 1)
[13:19:58.633] Future #2
[13:19:58.634] result() for MulticoreFuture ...
[13:19:58.635] result() for MulticoreFuture ...
[13:19:58.636] result() for MulticoreFuture ... done
[13:19:58.636] result() for MulticoreFuture ... done
[13:19:58.636] result() for MulticoreFuture ...
[13:19:58.637] result() for MulticoreFuture ... done
[13:19:58.637] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:58.637] - nx: 2
[13:19:58.637] - relay: TRUE
[13:19:58.638] - stdout: TRUE
[13:19:58.638] - signal: TRUE
[13:19:58.638] - resignal: FALSE
[13:19:58.638] - force: TRUE
[13:19:58.638] - relayed: [n=2] TRUE, FALSE
[13:19:58.638] - queued futures: [n=2] TRUE, FALSE
[13:19:58.639]  - until=2
[13:19:58.639]  - relaying element #2
[13:19:58.639] result() for MulticoreFuture ...
[13:19:58.639] result() for MulticoreFuture ... done
[13:19:58.639] result() for MulticoreFuture ...
[13:19:58.639] result() for MulticoreFuture ... done
[13:19:58.640] result() for MulticoreFuture ...
[13:19:58.640] result() for MulticoreFuture ... done
[13:19:58.640] result() for MulticoreFuture ...
[13:19:58.640] result() for MulticoreFuture ... done
[13:19:58.640] - relayed: [n=2] TRUE, TRUE
[13:19:58.640] - queued futures: [n=2] TRUE, TRUE
[13:19:58.641] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:58.641]  length: 0 (resolved future 2)
[13:19:58.641] Relaying remaining futures
[13:19:58.641] signalConditionsASAP(NULL, pos=0) ...
[13:19:58.641] - nx: 2
[13:19:58.641] - relay: TRUE
[13:19:58.642] - stdout: TRUE
[13:19:58.642] - signal: TRUE
[13:19:58.642] - resignal: FALSE
[13:19:58.642] - force: TRUE
[13:19:58.642] - relayed: [n=2] TRUE, TRUE
[13:19:58.642] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:58.642] - relayed: [n=2] TRUE, TRUE
[13:19:58.643] - queued futures: [n=2] TRUE, TRUE
[13:19:58.643] signalConditionsASAP(NULL, pos=0) ... done
[13:19:58.643] resolve() on list ... DONE
[13:19:58.643] result() for MulticoreFuture ...
[13:19:58.643] result() for MulticoreFuture ... done
[13:19:58.643] result() for MulticoreFuture ...
[13:19:58.643] result() for MulticoreFuture ... done
[13:19:58.643] result() for MulticoreFuture ...
[13:19:58.644] result() for MulticoreFuture ... done
[13:19:58.644] result() for MulticoreFuture ...
[13:19:58.644] result() for MulticoreFuture ... done
[13:19:58.644]  - Number of value chunks collected: 2
[13:19:58.644] Resolving 2 futures (chunks) ... DONE
[13:19:58.644] Reducing values from 2 chunks ...
[13:19:58.644]  - Number of values collected after concatenation: 2
[13:19:58.644]  - Number of values expected: 2
[13:19:58.645] Reducing values from 2 chunks ... DONE
[13:19:58.645] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[13:19:58.645] plan(): Setting new future strategy stack:
[13:19:58.645] List of future strategies:
[13:19:58.645] 1. sequential:
[13:19:58.645]    - args: function (..., envir = parent.frame())
[13:19:58.645]    - tweaked: FALSE
[13:19:58.645]    - call: plan(sequential)
[13:19:58.646] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[13:19:58.646] plan(): Setting new future strategy stack:
[13:19:58.646] List of future strategies:
[13:19:58.646] 1. multisession:
[13:19:58.646]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:58.646]    - tweaked: FALSE
[13:19:58.646]    - call: plan(strategy)
[13:19:58.647] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:19:58.647] multisession:
[13:19:58.647] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:58.647] - tweaked: FALSE
[13:19:58.647] - call: plan(strategy)
[13:19:58.654] getGlobalsAndPackages() ...
[13:19:58.654] Not searching for globals
[13:19:58.654] - globals: [0] <none>
[13:19:58.654] getGlobalsAndPackages() ... DONE
[13:19:58.655] [local output] makeClusterPSOCK() ...
[13:19:58.702] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:19:58.703] [local output] Base port: 11497
[13:19:58.703] [local output] Getting setup options for 2 cluster nodes ...
[13:19:58.703] [local output]  - Node 1 of 2 ...
[13:19:58.704] [local output] localMachine=TRUE => revtunnel=FALSE

[13:19:58.704] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpkIm7zZ/worker.rank=1.parallelly.parent=69288.10ea8237cd21d.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpkIm7zZ/worker.rank=1.parallelly.parent=69288.10ea8237cd21d.pid")'’
[13:19:58.902] - Possible to infer worker's PID: TRUE
[13:19:58.902] [local output] Rscript port: 11497

[13:19:58.902] [local output]  - Node 2 of 2 ...
[13:19:58.903] [local output] localMachine=TRUE => revtunnel=FALSE

[13:19:58.903] [local output] Rscript port: 11497

[13:19:58.904] [local output] Getting setup options for 2 cluster nodes ... done
[13:19:58.904] [local output]  - Parallel setup requested for some PSOCK nodes
[13:19:58.904] [local output] Setting up PSOCK nodes in parallel
[13:19:58.905] List of 36
[13:19:58.905]  $ worker          : chr "localhost"
[13:19:58.905]   ..- attr(*, "localhost")= logi TRUE
[13:19:58.905]  $ master          : chr "localhost"
[13:19:58.905]  $ port            : int 11497
[13:19:58.905]  $ connectTimeout  : num 120
[13:19:58.905]  $ timeout         : num 2592000
[13:19:58.905]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:19:58.905]  $ homogeneous     : logi TRUE
[13:19:58.905]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:19:58.905]  $ rscript_envs    : NULL
[13:19:58.905]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:19:58.905]  $ rscript_startup : NULL
[13:19:58.905]  $ rscript_sh      : chr "sh"
[13:19:58.905]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:19:58.905]  $ methods         : logi TRUE
[13:19:58.905]  $ socketOptions   : chr "no-delay"
[13:19:58.905]  $ useXDR          : logi FALSE
[13:19:58.905]  $ outfile         : chr "/dev/null"
[13:19:58.905]  $ renice          : int NA
[13:19:58.905]  $ rshcmd          : NULL
[13:19:58.905]  $ user            : chr(0) 
[13:19:58.905]  $ revtunnel       : logi FALSE
[13:19:58.905]  $ rshlogfile      : NULL
[13:19:58.905]  $ rshopts         : chr(0) 
[13:19:58.905]  $ rank            : int 1
[13:19:58.905]  $ manual          : logi FALSE
[13:19:58.905]  $ dryrun          : logi FALSE
[13:19:58.905]  $ quiet           : logi FALSE
[13:19:58.905]  $ setup_strategy  : chr "parallel"
[13:19:58.905]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:19:58.905]  $ pidfile         : chr "/tmp/RtmpkIm7zZ/worker.rank=1.parallelly.parent=69288.10ea8237cd21d.pid"
[13:19:58.905]  $ rshcmd_label    : NULL
[13:19:58.905]  $ rsh_call        : NULL
[13:19:58.905]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:19:58.905]  $ localMachine    : logi TRUE
[13:19:58.905]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:19:58.905]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:19:58.905]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:19:58.905]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:19:58.905]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:19:58.905]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:19:58.905]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:19:58.905]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:19:58.905]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:19:58.905]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:19:58.905]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:19:58.905]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:19:58.905]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:19:58.905]  $ arguments       :List of 28
[13:19:58.905]   ..$ worker          : chr "localhost"
[13:19:58.905]   ..$ master          : NULL
[13:19:58.905]   ..$ port            : int 11497
[13:19:58.905]   ..$ connectTimeout  : num 120
[13:19:58.905]   ..$ timeout         : num 2592000
[13:19:58.905]   ..$ rscript         : NULL
[13:19:58.905]   ..$ homogeneous     : NULL
[13:19:58.905]   ..$ rscript_args    : NULL
[13:19:58.905]   ..$ rscript_envs    : NULL
[13:19:58.905]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:19:58.905]   ..$ rscript_startup : NULL
[13:19:58.905]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:19:58.905]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:19:58.905]   ..$ methods         : logi TRUE
[13:19:58.905]   ..$ socketOptions   : chr "no-delay"
[13:19:58.905]   ..$ useXDR          : logi FALSE
[13:19:58.905]   ..$ outfile         : chr "/dev/null"
[13:19:58.905]   ..$ renice          : int NA
[13:19:58.905]   ..$ rshcmd          : NULL
[13:19:58.905]   ..$ user            : NULL
[13:19:58.905]   ..$ revtunnel       : logi NA
[13:19:58.905]   ..$ rshlogfile      : NULL
[13:19:58.905]   ..$ rshopts         : NULL
[13:19:58.905]   ..$ rank            : int 1
[13:19:58.905]   ..$ manual          : logi FALSE
[13:19:58.905]   ..$ dryrun          : logi FALSE
[13:19:58.905]   ..$ quiet           : logi FALSE
[13:19:58.905]   ..$ setup_strategy  : chr "parallel"
[13:19:58.905]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:19:58.922] [local output] System call to launch all workers:
[13:19:58.922] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpkIm7zZ/worker.rank=1.parallelly.parent=69288.10ea8237cd21d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11497 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:19:58.922] [local output] Starting PSOCK main server
[13:19:58.928] [local output] Workers launched
[13:19:58.928] [local output] Waiting for workers to connect back
[13:19:58.928]  - [local output] 0 workers out of 2 ready
[13:19:59.178]  - [local output] 0 workers out of 2 ready
[13:19:59.179]  - [local output] 1 workers out of 2 ready
[13:19:59.179]  - [local output] 2 workers out of 2 ready
[13:19:59.179] [local output] Launching of workers completed
[13:19:59.179] [local output] Collecting session information from workers
[13:19:59.180] [local output]  - Worker #1 of 2
[13:19:59.181] [local output]  - Worker #2 of 2
[13:19:59.181] [local output] makeClusterPSOCK() ... done
[13:19:59.192] Packages needed by the future expression (n = 0): <none>
[13:19:59.192] Packages needed by future strategies (n = 0): <none>
[13:19:59.193] {
[13:19:59.193]     {
[13:19:59.193]         {
[13:19:59.193]             ...future.startTime <- base::Sys.time()
[13:19:59.193]             {
[13:19:59.193]                 {
[13:19:59.193]                   {
[13:19:59.193]                     {
[13:19:59.193]                       base::local({
[13:19:59.193]                         has_future <- base::requireNamespace("future", 
[13:19:59.193]                           quietly = TRUE)
[13:19:59.193]                         if (has_future) {
[13:19:59.193]                           ns <- base::getNamespace("future")
[13:19:59.193]                           version <- ns[[".package"]][["version"]]
[13:19:59.193]                           if (is.null(version)) 
[13:19:59.193]                             version <- utils::packageVersion("future")
[13:19:59.193]                         }
[13:19:59.193]                         else {
[13:19:59.193]                           version <- NULL
[13:19:59.193]                         }
[13:19:59.193]                         if (!has_future || version < "1.8.0") {
[13:19:59.193]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.193]                             "", base::R.version$version.string), 
[13:19:59.193]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.193]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.193]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.193]                               "release", "version")], collapse = " "), 
[13:19:59.193]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.193]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.193]                             info)
[13:19:59.193]                           info <- base::paste(info, collapse = "; ")
[13:19:59.193]                           if (!has_future) {
[13:19:59.193]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.193]                               info)
[13:19:59.193]                           }
[13:19:59.193]                           else {
[13:19:59.193]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.193]                               info, version)
[13:19:59.193]                           }
[13:19:59.193]                           base::stop(msg)
[13:19:59.193]                         }
[13:19:59.193]                       })
[13:19:59.193]                     }
[13:19:59.193]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.193]                     base::options(mc.cores = 1L)
[13:19:59.193]                   }
[13:19:59.193]                   options(future.plan = NULL)
[13:19:59.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.193]                 }
[13:19:59.193]                 ...future.workdir <- getwd()
[13:19:59.193]             }
[13:19:59.193]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.193]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.193]         }
[13:19:59.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.193]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:59.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.193]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.193]             base::names(...future.oldOptions))
[13:19:59.193]     }
[13:19:59.193]     if (FALSE) {
[13:19:59.193]     }
[13:19:59.193]     else {
[13:19:59.193]         if (TRUE) {
[13:19:59.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.193]                 open = "w")
[13:19:59.193]         }
[13:19:59.193]         else {
[13:19:59.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.193]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.193]         }
[13:19:59.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.193]             base::sink(type = "output", split = FALSE)
[13:19:59.193]             base::close(...future.stdout)
[13:19:59.193]         }, add = TRUE)
[13:19:59.193]     }
[13:19:59.193]     ...future.frame <- base::sys.nframe()
[13:19:59.193]     ...future.conditions <- base::list()
[13:19:59.193]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.193]     if (FALSE) {
[13:19:59.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.193]     }
[13:19:59.193]     ...future.result <- base::tryCatch({
[13:19:59.193]         base::withCallingHandlers({
[13:19:59.193]             ...future.value <- base::withVisible(base::local({
[13:19:59.193]                 ...future.makeSendCondition <- base::local({
[13:19:59.193]                   sendCondition <- NULL
[13:19:59.193]                   function(frame = 1L) {
[13:19:59.193]                     if (is.function(sendCondition)) 
[13:19:59.193]                       return(sendCondition)
[13:19:59.193]                     ns <- getNamespace("parallel")
[13:19:59.193]                     if (exists("sendData", mode = "function", 
[13:19:59.193]                       envir = ns)) {
[13:19:59.193]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:59.193]                         envir = ns)
[13:19:59.193]                       envir <- sys.frame(frame)
[13:19:59.193]                       master <- NULL
[13:19:59.193]                       while (!identical(envir, .GlobalEnv) && 
[13:19:59.193]                         !identical(envir, emptyenv())) {
[13:19:59.193]                         if (exists("master", mode = "list", envir = envir, 
[13:19:59.193]                           inherits = FALSE)) {
[13:19:59.193]                           master <- get("master", mode = "list", 
[13:19:59.193]                             envir = envir, inherits = FALSE)
[13:19:59.193]                           if (inherits(master, c("SOCKnode", 
[13:19:59.193]                             "SOCK0node"))) {
[13:19:59.193]                             sendCondition <<- function(cond) {
[13:19:59.193]                               data <- list(type = "VALUE", value = cond, 
[13:19:59.193]                                 success = TRUE)
[13:19:59.193]                               parallel_sendData(master, data)
[13:19:59.193]                             }
[13:19:59.193]                             return(sendCondition)
[13:19:59.193]                           }
[13:19:59.193]                         }
[13:19:59.193]                         frame <- frame + 1L
[13:19:59.193]                         envir <- sys.frame(frame)
[13:19:59.193]                       }
[13:19:59.193]                     }
[13:19:59.193]                     sendCondition <<- function(cond) NULL
[13:19:59.193]                   }
[13:19:59.193]                 })
[13:19:59.193]                 withCallingHandlers({
[13:19:59.193]                   NA
[13:19:59.193]                 }, immediateCondition = function(cond) {
[13:19:59.193]                   sendCondition <- ...future.makeSendCondition()
[13:19:59.193]                   sendCondition(cond)
[13:19:59.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.193]                   {
[13:19:59.193]                     inherits <- base::inherits
[13:19:59.193]                     invokeRestart <- base::invokeRestart
[13:19:59.193]                     is.null <- base::is.null
[13:19:59.193]                     muffled <- FALSE
[13:19:59.193]                     if (inherits(cond, "message")) {
[13:19:59.193]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.193]                       if (muffled) 
[13:19:59.193]                         invokeRestart("muffleMessage")
[13:19:59.193]                     }
[13:19:59.193]                     else if (inherits(cond, "warning")) {
[13:19:59.193]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.193]                       if (muffled) 
[13:19:59.193]                         invokeRestart("muffleWarning")
[13:19:59.193]                     }
[13:19:59.193]                     else if (inherits(cond, "condition")) {
[13:19:59.193]                       if (!is.null(pattern)) {
[13:19:59.193]                         computeRestarts <- base::computeRestarts
[13:19:59.193]                         grepl <- base::grepl
[13:19:59.193]                         restarts <- computeRestarts(cond)
[13:19:59.193]                         for (restart in restarts) {
[13:19:59.193]                           name <- restart$name
[13:19:59.193]                           if (is.null(name)) 
[13:19:59.193]                             next
[13:19:59.193]                           if (!grepl(pattern, name)) 
[13:19:59.193]                             next
[13:19:59.193]                           invokeRestart(restart)
[13:19:59.193]                           muffled <- TRUE
[13:19:59.193]                           break
[13:19:59.193]                         }
[13:19:59.193]                       }
[13:19:59.193]                     }
[13:19:59.193]                     invisible(muffled)
[13:19:59.193]                   }
[13:19:59.193]                   muffleCondition(cond)
[13:19:59.193]                 })
[13:19:59.193]             }))
[13:19:59.193]             future::FutureResult(value = ...future.value$value, 
[13:19:59.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.193]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.193]                     ...future.globalenv.names))
[13:19:59.193]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.193]         }, condition = base::local({
[13:19:59.193]             c <- base::c
[13:19:59.193]             inherits <- base::inherits
[13:19:59.193]             invokeRestart <- base::invokeRestart
[13:19:59.193]             length <- base::length
[13:19:59.193]             list <- base::list
[13:19:59.193]             seq.int <- base::seq.int
[13:19:59.193]             signalCondition <- base::signalCondition
[13:19:59.193]             sys.calls <- base::sys.calls
[13:19:59.193]             `[[` <- base::`[[`
[13:19:59.193]             `+` <- base::`+`
[13:19:59.193]             `<<-` <- base::`<<-`
[13:19:59.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.193]                   3L)]
[13:19:59.193]             }
[13:19:59.193]             function(cond) {
[13:19:59.193]                 is_error <- inherits(cond, "error")
[13:19:59.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.193]                   NULL)
[13:19:59.193]                 if (is_error) {
[13:19:59.193]                   sessionInformation <- function() {
[13:19:59.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.193]                       search = base::search(), system = base::Sys.info())
[13:19:59.193]                   }
[13:19:59.193]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.193]                     cond$call), session = sessionInformation(), 
[13:19:59.193]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.193]                   signalCondition(cond)
[13:19:59.193]                 }
[13:19:59.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.193]                 "immediateCondition"))) {
[13:19:59.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.193]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.193]                   if (TRUE && !signal) {
[13:19:59.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.193]                     {
[13:19:59.193]                       inherits <- base::inherits
[13:19:59.193]                       invokeRestart <- base::invokeRestart
[13:19:59.193]                       is.null <- base::is.null
[13:19:59.193]                       muffled <- FALSE
[13:19:59.193]                       if (inherits(cond, "message")) {
[13:19:59.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.193]                         if (muffled) 
[13:19:59.193]                           invokeRestart("muffleMessage")
[13:19:59.193]                       }
[13:19:59.193]                       else if (inherits(cond, "warning")) {
[13:19:59.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.193]                         if (muffled) 
[13:19:59.193]                           invokeRestart("muffleWarning")
[13:19:59.193]                       }
[13:19:59.193]                       else if (inherits(cond, "condition")) {
[13:19:59.193]                         if (!is.null(pattern)) {
[13:19:59.193]                           computeRestarts <- base::computeRestarts
[13:19:59.193]                           grepl <- base::grepl
[13:19:59.193]                           restarts <- computeRestarts(cond)
[13:19:59.193]                           for (restart in restarts) {
[13:19:59.193]                             name <- restart$name
[13:19:59.193]                             if (is.null(name)) 
[13:19:59.193]                               next
[13:19:59.193]                             if (!grepl(pattern, name)) 
[13:19:59.193]                               next
[13:19:59.193]                             invokeRestart(restart)
[13:19:59.193]                             muffled <- TRUE
[13:19:59.193]                             break
[13:19:59.193]                           }
[13:19:59.193]                         }
[13:19:59.193]                       }
[13:19:59.193]                       invisible(muffled)
[13:19:59.193]                     }
[13:19:59.193]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.193]                   }
[13:19:59.193]                 }
[13:19:59.193]                 else {
[13:19:59.193]                   if (TRUE) {
[13:19:59.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.193]                     {
[13:19:59.193]                       inherits <- base::inherits
[13:19:59.193]                       invokeRestart <- base::invokeRestart
[13:19:59.193]                       is.null <- base::is.null
[13:19:59.193]                       muffled <- FALSE
[13:19:59.193]                       if (inherits(cond, "message")) {
[13:19:59.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.193]                         if (muffled) 
[13:19:59.193]                           invokeRestart("muffleMessage")
[13:19:59.193]                       }
[13:19:59.193]                       else if (inherits(cond, "warning")) {
[13:19:59.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.193]                         if (muffled) 
[13:19:59.193]                           invokeRestart("muffleWarning")
[13:19:59.193]                       }
[13:19:59.193]                       else if (inherits(cond, "condition")) {
[13:19:59.193]                         if (!is.null(pattern)) {
[13:19:59.193]                           computeRestarts <- base::computeRestarts
[13:19:59.193]                           grepl <- base::grepl
[13:19:59.193]                           restarts <- computeRestarts(cond)
[13:19:59.193]                           for (restart in restarts) {
[13:19:59.193]                             name <- restart$name
[13:19:59.193]                             if (is.null(name)) 
[13:19:59.193]                               next
[13:19:59.193]                             if (!grepl(pattern, name)) 
[13:19:59.193]                               next
[13:19:59.193]                             invokeRestart(restart)
[13:19:59.193]                             muffled <- TRUE
[13:19:59.193]                             break
[13:19:59.193]                           }
[13:19:59.193]                         }
[13:19:59.193]                       }
[13:19:59.193]                       invisible(muffled)
[13:19:59.193]                     }
[13:19:59.193]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.193]                   }
[13:19:59.193]                 }
[13:19:59.193]             }
[13:19:59.193]         }))
[13:19:59.193]     }, error = function(ex) {
[13:19:59.193]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.193]                 ...future.rng), started = ...future.startTime, 
[13:19:59.193]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.193]             version = "1.8"), class = "FutureResult")
[13:19:59.193]     }, finally = {
[13:19:59.193]         if (!identical(...future.workdir, getwd())) 
[13:19:59.193]             setwd(...future.workdir)
[13:19:59.193]         {
[13:19:59.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.193]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.193]             }
[13:19:59.193]             base::options(...future.oldOptions)
[13:19:59.193]             if (.Platform$OS.type == "windows") {
[13:19:59.193]                 old_names <- names(...future.oldEnvVars)
[13:19:59.193]                 envs <- base::Sys.getenv()
[13:19:59.193]                 names <- names(envs)
[13:19:59.193]                 common <- intersect(names, old_names)
[13:19:59.193]                 added <- setdiff(names, old_names)
[13:19:59.193]                 removed <- setdiff(old_names, names)
[13:19:59.193]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.193]                   envs[common]]
[13:19:59.193]                 NAMES <- toupper(changed)
[13:19:59.193]                 args <- list()
[13:19:59.193]                 for (kk in seq_along(NAMES)) {
[13:19:59.193]                   name <- changed[[kk]]
[13:19:59.193]                   NAME <- NAMES[[kk]]
[13:19:59.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.193]                     next
[13:19:59.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.193]                 }
[13:19:59.193]                 NAMES <- toupper(added)
[13:19:59.193]                 for (kk in seq_along(NAMES)) {
[13:19:59.193]                   name <- added[[kk]]
[13:19:59.193]                   NAME <- NAMES[[kk]]
[13:19:59.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.193]                     next
[13:19:59.193]                   args[[name]] <- ""
[13:19:59.193]                 }
[13:19:59.193]                 NAMES <- toupper(removed)
[13:19:59.193]                 for (kk in seq_along(NAMES)) {
[13:19:59.193]                   name <- removed[[kk]]
[13:19:59.193]                   NAME <- NAMES[[kk]]
[13:19:59.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.193]                     next
[13:19:59.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.193]                 }
[13:19:59.193]                 if (length(args) > 0) 
[13:19:59.193]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.193]             }
[13:19:59.193]             else {
[13:19:59.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.193]             }
[13:19:59.193]             {
[13:19:59.193]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.193]                   0L) {
[13:19:59.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.193]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.193]                   base::options(opts)
[13:19:59.193]                 }
[13:19:59.193]                 {
[13:19:59.193]                   {
[13:19:59.193]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.193]                     NULL
[13:19:59.193]                   }
[13:19:59.193]                   options(future.plan = NULL)
[13:19:59.193]                   if (is.na(NA_character_)) 
[13:19:59.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.193]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:59.193]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:59.193]                     envir = parent.frame()) 
[13:19:59.193]                   {
[13:19:59.193]                     if (is.function(workers)) 
[13:19:59.193]                       workers <- workers()
[13:19:59.193]                     workers <- structure(as.integer(workers), 
[13:19:59.193]                       class = class(workers))
[13:19:59.193]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:59.193]                       workers >= 1)
[13:19:59.193]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:59.193]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:59.193]                     }
[13:19:59.193]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:59.193]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:59.193]                       envir = envir)
[13:19:59.193]                     if (!future$lazy) 
[13:19:59.193]                       future <- run(future)
[13:19:59.193]                     invisible(future)
[13:19:59.193]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.193]                 }
[13:19:59.193]             }
[13:19:59.193]         }
[13:19:59.193]     })
[13:19:59.193]     if (TRUE) {
[13:19:59.193]         base::sink(type = "output", split = FALSE)
[13:19:59.193]         if (TRUE) {
[13:19:59.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.193]         }
[13:19:59.193]         else {
[13:19:59.193]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.193]         }
[13:19:59.193]         base::close(...future.stdout)
[13:19:59.193]         ...future.stdout <- NULL
[13:19:59.193]     }
[13:19:59.193]     ...future.result$conditions <- ...future.conditions
[13:19:59.193]     ...future.result$finished <- base::Sys.time()
[13:19:59.193]     ...future.result
[13:19:59.193] }
[13:19:59.248] MultisessionFuture started
[13:19:59.248] result() for ClusterFuture ...
[13:19:59.249] receiveMessageFromWorker() for ClusterFuture ...
[13:19:59.249] - Validating connection of MultisessionFuture
[13:19:59.293] - received message: FutureResult
[13:19:59.293] - Received FutureResult
[13:19:59.294] - Erased future from FutureRegistry
[13:19:59.294] result() for ClusterFuture ...
[13:19:59.294] - result already collected: FutureResult
[13:19:59.294] result() for ClusterFuture ... done
[13:19:59.294] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:59.294] result() for ClusterFuture ... done
[13:19:59.294] result() for ClusterFuture ...
[13:19:59.295] - result already collected: FutureResult
[13:19:59.295] result() for ClusterFuture ... done
[13:19:59.295] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:19:59.299] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[13:19:59.299] getGlobalsAndPackagesXApply() ...
[13:19:59.299]  - future.globals: TRUE
[13:19:59.300] getGlobalsAndPackages() ...
[13:19:59.300] Searching for globals...
[13:19:59.344] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:19:59.344] Searching for globals ... DONE
[13:19:59.344] Resolving globals: FALSE
[13:19:59.346] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:19:59.346] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:19:59.346] - globals: [1] ‘FUN’
[13:19:59.346] 
[13:19:59.346] getGlobalsAndPackages() ... DONE
[13:19:59.347]  - globals found/used: [n=1] ‘FUN’
[13:19:59.347]  - needed namespaces: [n=0] 
[13:19:59.347] Finding globals ... DONE
[13:19:59.347]  - use_args: TRUE
[13:19:59.347]  - Getting '...' globals ...
[13:19:59.347] resolve() on list ...
[13:19:59.347]  recursive: 0
[13:19:59.347]  length: 1
[13:19:59.348]  elements: ‘...’
[13:19:59.348]  length: 0 (resolved future 1)
[13:19:59.348] resolve() on list ... DONE
[13:19:59.348]    - '...' content: [n=0] 
[13:19:59.348] List of 1
[13:19:59.348]  $ ...: list()
[13:19:59.348]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:59.348]  - attr(*, "where")=List of 1
[13:19:59.348]   ..$ ...:<environment: 0x555923a593a0> 
[13:19:59.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.348]  - attr(*, "resolved")= logi TRUE
[13:19:59.348]  - attr(*, "total_size")= num NA
[13:19:59.351]  - Getting '...' globals ... DONE
[13:19:59.351] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:59.351] List of 2
[13:19:59.351]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:59.351]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:59.351]  $ ...          : list()
[13:19:59.351]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:59.351]  - attr(*, "where")=List of 2
[13:19:59.351]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:59.351]   ..$ ...          :<environment: 0x555923a593a0> 
[13:19:59.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.351]  - attr(*, "resolved")= logi FALSE
[13:19:59.351]  - attr(*, "total_size")= num 354224
[13:19:59.353] Packages to be attached in all futures: [n=0] 
[13:19:59.353] getGlobalsAndPackagesXApply() ... DONE
[13:19:59.357] future_lapply() ...
[13:19:59.391] Number of chunks: 2
[13:19:59.391] getGlobalsAndPackagesXApply() ...
[13:19:59.392]  - future.globals: <name-value list> with names ‘list()’
[13:19:59.392]  - use_args: TRUE
[13:19:59.392] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:59.392] List of 2
[13:19:59.392]  $ ...          : list()
[13:19:59.392]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:59.392]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:59.392]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:59.392]  - attr(*, "where")=List of 2
[13:19:59.392]   ..$ ...          :<environment: 0x555923a593a0> 
[13:19:59.392]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:59.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.392]  - attr(*, "resolved")= logi FALSE
[13:19:59.392]  - attr(*, "total_size")= num NA
[13:19:59.396] Packages to be attached in all futures: [n=0] 
[13:19:59.396] getGlobalsAndPackagesXApply() ... DONE
[13:19:59.396] Number of futures (= number of chunks): 2
[13:19:59.396] Launching 2 futures (chunks) ...
[13:19:59.396] Chunk #1 of 2 ...
[13:19:59.396]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:59.396]  - seeds: <none>
[13:19:59.397]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.397] getGlobalsAndPackages() ...
[13:19:59.397] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.397] Resolving globals: FALSE
[13:19:59.397] Tweak future expression to call with '...' arguments ...
[13:19:59.397] {
[13:19:59.397]     do.call(function(...) {
[13:19:59.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:59.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.397]             on.exit(options(oopts), add = TRUE)
[13:19:59.397]         }
[13:19:59.397]         {
[13:19:59.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:59.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.397]                 ...future.FUN(...future.X_jj, ...)
[13:19:59.397]             })
[13:19:59.397]         }
[13:19:59.397]     }, args = future.call.arguments)
[13:19:59.397] }
[13:19:59.397] Tweak future expression to call with '...' arguments ... DONE
[13:19:59.398] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.398] 
[13:19:59.398] getGlobalsAndPackages() ... DONE
[13:19:59.398] run() for ‘Future’ ...
[13:19:59.398] - state: ‘created’
[13:19:59.399] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.413] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:59.413]   - Field: ‘node’
[13:19:59.413]   - Field: ‘label’
[13:19:59.413]   - Field: ‘local’
[13:19:59.413]   - Field: ‘owner’
[13:19:59.413]   - Field: ‘envir’
[13:19:59.413]   - Field: ‘workers’
[13:19:59.414]   - Field: ‘packages’
[13:19:59.414]   - Field: ‘gc’
[13:19:59.414]   - Field: ‘conditions’
[13:19:59.414]   - Field: ‘persistent’
[13:19:59.414]   - Field: ‘expr’
[13:19:59.414]   - Field: ‘uuid’
[13:19:59.414]   - Field: ‘seed’
[13:19:59.414]   - Field: ‘version’
[13:19:59.414]   - Field: ‘result’
[13:19:59.414]   - Field: ‘asynchronous’
[13:19:59.415]   - Field: ‘calls’
[13:19:59.415]   - Field: ‘globals’
[13:19:59.415]   - Field: ‘stdout’
[13:19:59.415]   - Field: ‘earlySignal’
[13:19:59.415]   - Field: ‘lazy’
[13:19:59.415]   - Field: ‘state’
[13:19:59.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:59.415] - Launch lazy future ...
[13:19:59.415] Packages needed by the future expression (n = 0): <none>
[13:19:59.416] Packages needed by future strategies (n = 0): <none>
[13:19:59.416] {
[13:19:59.416]     {
[13:19:59.416]         {
[13:19:59.416]             ...future.startTime <- base::Sys.time()
[13:19:59.416]             {
[13:19:59.416]                 {
[13:19:59.416]                   {
[13:19:59.416]                     {
[13:19:59.416]                       base::local({
[13:19:59.416]                         has_future <- base::requireNamespace("future", 
[13:19:59.416]                           quietly = TRUE)
[13:19:59.416]                         if (has_future) {
[13:19:59.416]                           ns <- base::getNamespace("future")
[13:19:59.416]                           version <- ns[[".package"]][["version"]]
[13:19:59.416]                           if (is.null(version)) 
[13:19:59.416]                             version <- utils::packageVersion("future")
[13:19:59.416]                         }
[13:19:59.416]                         else {
[13:19:59.416]                           version <- NULL
[13:19:59.416]                         }
[13:19:59.416]                         if (!has_future || version < "1.8.0") {
[13:19:59.416]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.416]                             "", base::R.version$version.string), 
[13:19:59.416]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.416]                               "release", "version")], collapse = " "), 
[13:19:59.416]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.416]                             info)
[13:19:59.416]                           info <- base::paste(info, collapse = "; ")
[13:19:59.416]                           if (!has_future) {
[13:19:59.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.416]                               info)
[13:19:59.416]                           }
[13:19:59.416]                           else {
[13:19:59.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.416]                               info, version)
[13:19:59.416]                           }
[13:19:59.416]                           base::stop(msg)
[13:19:59.416]                         }
[13:19:59.416]                       })
[13:19:59.416]                     }
[13:19:59.416]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.416]                     base::options(mc.cores = 1L)
[13:19:59.416]                   }
[13:19:59.416]                   options(future.plan = NULL)
[13:19:59.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.416]                 }
[13:19:59.416]                 ...future.workdir <- getwd()
[13:19:59.416]             }
[13:19:59.416]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.416]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.416]         }
[13:19:59.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.416]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:59.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.416]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.416]             base::names(...future.oldOptions))
[13:19:59.416]     }
[13:19:59.416]     if (FALSE) {
[13:19:59.416]     }
[13:19:59.416]     else {
[13:19:59.416]         if (TRUE) {
[13:19:59.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.416]                 open = "w")
[13:19:59.416]         }
[13:19:59.416]         else {
[13:19:59.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.416]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.416]         }
[13:19:59.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.416]             base::sink(type = "output", split = FALSE)
[13:19:59.416]             base::close(...future.stdout)
[13:19:59.416]         }, add = TRUE)
[13:19:59.416]     }
[13:19:59.416]     ...future.frame <- base::sys.nframe()
[13:19:59.416]     ...future.conditions <- base::list()
[13:19:59.416]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.416]     if (FALSE) {
[13:19:59.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.416]     }
[13:19:59.416]     ...future.result <- base::tryCatch({
[13:19:59.416]         base::withCallingHandlers({
[13:19:59.416]             ...future.value <- base::withVisible(base::local({
[13:19:59.416]                 ...future.makeSendCondition <- base::local({
[13:19:59.416]                   sendCondition <- NULL
[13:19:59.416]                   function(frame = 1L) {
[13:19:59.416]                     if (is.function(sendCondition)) 
[13:19:59.416]                       return(sendCondition)
[13:19:59.416]                     ns <- getNamespace("parallel")
[13:19:59.416]                     if (exists("sendData", mode = "function", 
[13:19:59.416]                       envir = ns)) {
[13:19:59.416]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:59.416]                         envir = ns)
[13:19:59.416]                       envir <- sys.frame(frame)
[13:19:59.416]                       master <- NULL
[13:19:59.416]                       while (!identical(envir, .GlobalEnv) && 
[13:19:59.416]                         !identical(envir, emptyenv())) {
[13:19:59.416]                         if (exists("master", mode = "list", envir = envir, 
[13:19:59.416]                           inherits = FALSE)) {
[13:19:59.416]                           master <- get("master", mode = "list", 
[13:19:59.416]                             envir = envir, inherits = FALSE)
[13:19:59.416]                           if (inherits(master, c("SOCKnode", 
[13:19:59.416]                             "SOCK0node"))) {
[13:19:59.416]                             sendCondition <<- function(cond) {
[13:19:59.416]                               data <- list(type = "VALUE", value = cond, 
[13:19:59.416]                                 success = TRUE)
[13:19:59.416]                               parallel_sendData(master, data)
[13:19:59.416]                             }
[13:19:59.416]                             return(sendCondition)
[13:19:59.416]                           }
[13:19:59.416]                         }
[13:19:59.416]                         frame <- frame + 1L
[13:19:59.416]                         envir <- sys.frame(frame)
[13:19:59.416]                       }
[13:19:59.416]                     }
[13:19:59.416]                     sendCondition <<- function(cond) NULL
[13:19:59.416]                   }
[13:19:59.416]                 })
[13:19:59.416]                 withCallingHandlers({
[13:19:59.416]                   {
[13:19:59.416]                     do.call(function(...) {
[13:19:59.416]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.416]                       if (!identical(...future.globals.maxSize.org, 
[13:19:59.416]                         ...future.globals.maxSize)) {
[13:19:59.416]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.416]                         on.exit(options(oopts), add = TRUE)
[13:19:59.416]                       }
[13:19:59.416]                       {
[13:19:59.416]                         lapply(seq_along(...future.elements_ii), 
[13:19:59.416]                           FUN = function(jj) {
[13:19:59.416]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.416]                             ...future.FUN(...future.X_jj, ...)
[13:19:59.416]                           })
[13:19:59.416]                       }
[13:19:59.416]                     }, args = future.call.arguments)
[13:19:59.416]                   }
[13:19:59.416]                 }, immediateCondition = function(cond) {
[13:19:59.416]                   sendCondition <- ...future.makeSendCondition()
[13:19:59.416]                   sendCondition(cond)
[13:19:59.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.416]                   {
[13:19:59.416]                     inherits <- base::inherits
[13:19:59.416]                     invokeRestart <- base::invokeRestart
[13:19:59.416]                     is.null <- base::is.null
[13:19:59.416]                     muffled <- FALSE
[13:19:59.416]                     if (inherits(cond, "message")) {
[13:19:59.416]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.416]                       if (muffled) 
[13:19:59.416]                         invokeRestart("muffleMessage")
[13:19:59.416]                     }
[13:19:59.416]                     else if (inherits(cond, "warning")) {
[13:19:59.416]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.416]                       if (muffled) 
[13:19:59.416]                         invokeRestart("muffleWarning")
[13:19:59.416]                     }
[13:19:59.416]                     else if (inherits(cond, "condition")) {
[13:19:59.416]                       if (!is.null(pattern)) {
[13:19:59.416]                         computeRestarts <- base::computeRestarts
[13:19:59.416]                         grepl <- base::grepl
[13:19:59.416]                         restarts <- computeRestarts(cond)
[13:19:59.416]                         for (restart in restarts) {
[13:19:59.416]                           name <- restart$name
[13:19:59.416]                           if (is.null(name)) 
[13:19:59.416]                             next
[13:19:59.416]                           if (!grepl(pattern, name)) 
[13:19:59.416]                             next
[13:19:59.416]                           invokeRestart(restart)
[13:19:59.416]                           muffled <- TRUE
[13:19:59.416]                           break
[13:19:59.416]                         }
[13:19:59.416]                       }
[13:19:59.416]                     }
[13:19:59.416]                     invisible(muffled)
[13:19:59.416]                   }
[13:19:59.416]                   muffleCondition(cond)
[13:19:59.416]                 })
[13:19:59.416]             }))
[13:19:59.416]             future::FutureResult(value = ...future.value$value, 
[13:19:59.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.416]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.416]                     ...future.globalenv.names))
[13:19:59.416]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.416]         }, condition = base::local({
[13:19:59.416]             c <- base::c
[13:19:59.416]             inherits <- base::inherits
[13:19:59.416]             invokeRestart <- base::invokeRestart
[13:19:59.416]             length <- base::length
[13:19:59.416]             list <- base::list
[13:19:59.416]             seq.int <- base::seq.int
[13:19:59.416]             signalCondition <- base::signalCondition
[13:19:59.416]             sys.calls <- base::sys.calls
[13:19:59.416]             `[[` <- base::`[[`
[13:19:59.416]             `+` <- base::`+`
[13:19:59.416]             `<<-` <- base::`<<-`
[13:19:59.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.416]                   3L)]
[13:19:59.416]             }
[13:19:59.416]             function(cond) {
[13:19:59.416]                 is_error <- inherits(cond, "error")
[13:19:59.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.416]                   NULL)
[13:19:59.416]                 if (is_error) {
[13:19:59.416]                   sessionInformation <- function() {
[13:19:59.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.416]                       search = base::search(), system = base::Sys.info())
[13:19:59.416]                   }
[13:19:59.416]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.416]                     cond$call), session = sessionInformation(), 
[13:19:59.416]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.416]                   signalCondition(cond)
[13:19:59.416]                 }
[13:19:59.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.416]                 "immediateCondition"))) {
[13:19:59.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.416]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.416]                   if (TRUE && !signal) {
[13:19:59.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.416]                     {
[13:19:59.416]                       inherits <- base::inherits
[13:19:59.416]                       invokeRestart <- base::invokeRestart
[13:19:59.416]                       is.null <- base::is.null
[13:19:59.416]                       muffled <- FALSE
[13:19:59.416]                       if (inherits(cond, "message")) {
[13:19:59.416]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.416]                         if (muffled) 
[13:19:59.416]                           invokeRestart("muffleMessage")
[13:19:59.416]                       }
[13:19:59.416]                       else if (inherits(cond, "warning")) {
[13:19:59.416]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.416]                         if (muffled) 
[13:19:59.416]                           invokeRestart("muffleWarning")
[13:19:59.416]                       }
[13:19:59.416]                       else if (inherits(cond, "condition")) {
[13:19:59.416]                         if (!is.null(pattern)) {
[13:19:59.416]                           computeRestarts <- base::computeRestarts
[13:19:59.416]                           grepl <- base::grepl
[13:19:59.416]                           restarts <- computeRestarts(cond)
[13:19:59.416]                           for (restart in restarts) {
[13:19:59.416]                             name <- restart$name
[13:19:59.416]                             if (is.null(name)) 
[13:19:59.416]                               next
[13:19:59.416]                             if (!grepl(pattern, name)) 
[13:19:59.416]                               next
[13:19:59.416]                             invokeRestart(restart)
[13:19:59.416]                             muffled <- TRUE
[13:19:59.416]                             break
[13:19:59.416]                           }
[13:19:59.416]                         }
[13:19:59.416]                       }
[13:19:59.416]                       invisible(muffled)
[13:19:59.416]                     }
[13:19:59.416]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.416]                   }
[13:19:59.416]                 }
[13:19:59.416]                 else {
[13:19:59.416]                   if (TRUE) {
[13:19:59.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.416]                     {
[13:19:59.416]                       inherits <- base::inherits
[13:19:59.416]                       invokeRestart <- base::invokeRestart
[13:19:59.416]                       is.null <- base::is.null
[13:19:59.416]                       muffled <- FALSE
[13:19:59.416]                       if (inherits(cond, "message")) {
[13:19:59.416]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.416]                         if (muffled) 
[13:19:59.416]                           invokeRestart("muffleMessage")
[13:19:59.416]                       }
[13:19:59.416]                       else if (inherits(cond, "warning")) {
[13:19:59.416]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.416]                         if (muffled) 
[13:19:59.416]                           invokeRestart("muffleWarning")
[13:19:59.416]                       }
[13:19:59.416]                       else if (inherits(cond, "condition")) {
[13:19:59.416]                         if (!is.null(pattern)) {
[13:19:59.416]                           computeRestarts <- base::computeRestarts
[13:19:59.416]                           grepl <- base::grepl
[13:19:59.416]                           restarts <- computeRestarts(cond)
[13:19:59.416]                           for (restart in restarts) {
[13:19:59.416]                             name <- restart$name
[13:19:59.416]                             if (is.null(name)) 
[13:19:59.416]                               next
[13:19:59.416]                             if (!grepl(pattern, name)) 
[13:19:59.416]                               next
[13:19:59.416]                             invokeRestart(restart)
[13:19:59.416]                             muffled <- TRUE
[13:19:59.416]                             break
[13:19:59.416]                           }
[13:19:59.416]                         }
[13:19:59.416]                       }
[13:19:59.416]                       invisible(muffled)
[13:19:59.416]                     }
[13:19:59.416]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.416]                   }
[13:19:59.416]                 }
[13:19:59.416]             }
[13:19:59.416]         }))
[13:19:59.416]     }, error = function(ex) {
[13:19:59.416]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.416]                 ...future.rng), started = ...future.startTime, 
[13:19:59.416]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.416]             version = "1.8"), class = "FutureResult")
[13:19:59.416]     }, finally = {
[13:19:59.416]         if (!identical(...future.workdir, getwd())) 
[13:19:59.416]             setwd(...future.workdir)
[13:19:59.416]         {
[13:19:59.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.416]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.416]             }
[13:19:59.416]             base::options(...future.oldOptions)
[13:19:59.416]             if (.Platform$OS.type == "windows") {
[13:19:59.416]                 old_names <- names(...future.oldEnvVars)
[13:19:59.416]                 envs <- base::Sys.getenv()
[13:19:59.416]                 names <- names(envs)
[13:19:59.416]                 common <- intersect(names, old_names)
[13:19:59.416]                 added <- setdiff(names, old_names)
[13:19:59.416]                 removed <- setdiff(old_names, names)
[13:19:59.416]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.416]                   envs[common]]
[13:19:59.416]                 NAMES <- toupper(changed)
[13:19:59.416]                 args <- list()
[13:19:59.416]                 for (kk in seq_along(NAMES)) {
[13:19:59.416]                   name <- changed[[kk]]
[13:19:59.416]                   NAME <- NAMES[[kk]]
[13:19:59.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.416]                     next
[13:19:59.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.416]                 }
[13:19:59.416]                 NAMES <- toupper(added)
[13:19:59.416]                 for (kk in seq_along(NAMES)) {
[13:19:59.416]                   name <- added[[kk]]
[13:19:59.416]                   NAME <- NAMES[[kk]]
[13:19:59.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.416]                     next
[13:19:59.416]                   args[[name]] <- ""
[13:19:59.416]                 }
[13:19:59.416]                 NAMES <- toupper(removed)
[13:19:59.416]                 for (kk in seq_along(NAMES)) {
[13:19:59.416]                   name <- removed[[kk]]
[13:19:59.416]                   NAME <- NAMES[[kk]]
[13:19:59.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.416]                     next
[13:19:59.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.416]                 }
[13:19:59.416]                 if (length(args) > 0) 
[13:19:59.416]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.416]             }
[13:19:59.416]             else {
[13:19:59.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.416]             }
[13:19:59.416]             {
[13:19:59.416]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.416]                   0L) {
[13:19:59.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.416]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.416]                   base::options(opts)
[13:19:59.416]                 }
[13:19:59.416]                 {
[13:19:59.416]                   {
[13:19:59.416]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.416]                     NULL
[13:19:59.416]                   }
[13:19:59.416]                   options(future.plan = NULL)
[13:19:59.416]                   if (is.na(NA_character_)) 
[13:19:59.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.416]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:59.416]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:59.416]                     envir = parent.frame()) 
[13:19:59.416]                   {
[13:19:59.416]                     if (is.function(workers)) 
[13:19:59.416]                       workers <- workers()
[13:19:59.416]                     workers <- structure(as.integer(workers), 
[13:19:59.416]                       class = class(workers))
[13:19:59.416]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:59.416]                       workers >= 1)
[13:19:59.416]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:59.416]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:59.416]                     }
[13:19:59.416]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:59.416]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:59.416]                       envir = envir)
[13:19:59.416]                     if (!future$lazy) 
[13:19:59.416]                       future <- run(future)
[13:19:59.416]                     invisible(future)
[13:19:59.416]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.416]                 }
[13:19:59.416]             }
[13:19:59.416]         }
[13:19:59.416]     })
[13:19:59.416]     if (TRUE) {
[13:19:59.416]         base::sink(type = "output", split = FALSE)
[13:19:59.416]         if (TRUE) {
[13:19:59.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.416]         }
[13:19:59.416]         else {
[13:19:59.416]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.416]         }
[13:19:59.416]         base::close(...future.stdout)
[13:19:59.416]         ...future.stdout <- NULL
[13:19:59.416]     }
[13:19:59.416]     ...future.result$conditions <- ...future.conditions
[13:19:59.416]     ...future.result$finished <- base::Sys.time()
[13:19:59.416]     ...future.result
[13:19:59.416] }
[13:19:59.419] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[13:19:59.420] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:59.420] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:59.420] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[13:19:59.464] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[13:19:59.465] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[13:19:59.465] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[13:19:59.465] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:59.466] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:59.466] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:19:59.466] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:19:59.466] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[13:19:59.467] MultisessionFuture started
[13:19:59.467] - Launch lazy future ... done
[13:19:59.467] run() for ‘MultisessionFuture’ ... done
[13:19:59.467] Created future:
[13:19:59.467] MultisessionFuture:
[13:19:59.467] Label: ‘future_apply-1’
[13:19:59.467] Expression:
[13:19:59.467] {
[13:19:59.467]     do.call(function(...) {
[13:19:59.467]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.467]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:59.467]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.467]             on.exit(options(oopts), add = TRUE)
[13:19:59.467]         }
[13:19:59.467]         {
[13:19:59.467]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:59.467]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.467]                 ...future.FUN(...future.X_jj, ...)
[13:19:59.467]             })
[13:19:59.467]         }
[13:19:59.467]     }, args = future.call.arguments)
[13:19:59.467] }
[13:19:59.467] Lazy evaluation: FALSE
[13:19:59.467] Asynchronous evaluation: TRUE
[13:19:59.467] Local evaluation: TRUE
[13:19:59.467] Environment: R_GlobalEnv
[13:19:59.467] Capture standard output: TRUE
[13:19:59.467] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:59.467] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:59.467] Packages: <none>
[13:19:59.467] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:59.467] Resolved: FALSE
[13:19:59.467] Value: <not collected>
[13:19:59.467] Conditions captured: <none>
[13:19:59.467] Early signaling: FALSE
[13:19:59.467] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:59.467] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.479] Chunk #1 of 2 ... DONE
[13:19:59.479] Chunk #2 of 2 ...
[13:19:59.480]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:59.480]  - seeds: <none>
[13:19:59.480]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.480] getGlobalsAndPackages() ...
[13:19:59.480] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.480] Resolving globals: FALSE
[13:19:59.480] Tweak future expression to call with '...' arguments ...
[13:19:59.480] {
[13:19:59.480]     do.call(function(...) {
[13:19:59.480]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.480]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:59.480]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.480]             on.exit(options(oopts), add = TRUE)
[13:19:59.480]         }
[13:19:59.480]         {
[13:19:59.480]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:59.480]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.480]                 ...future.FUN(...future.X_jj, ...)
[13:19:59.480]             })
[13:19:59.480]         }
[13:19:59.480]     }, args = future.call.arguments)
[13:19:59.480] }
[13:19:59.481] Tweak future expression to call with '...' arguments ... DONE
[13:19:59.481] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.481] 
[13:19:59.481] getGlobalsAndPackages() ... DONE
[13:19:59.482] run() for ‘Future’ ...
[13:19:59.482] - state: ‘created’
[13:19:59.482] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.496] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.496] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:59.497]   - Field: ‘node’
[13:19:59.497]   - Field: ‘label’
[13:19:59.497]   - Field: ‘local’
[13:19:59.497]   - Field: ‘owner’
[13:19:59.497]   - Field: ‘envir’
[13:19:59.497]   - Field: ‘workers’
[13:19:59.497]   - Field: ‘packages’
[13:19:59.497]   - Field: ‘gc’
[13:19:59.499]   - Field: ‘conditions’
[13:19:59.499]   - Field: ‘persistent’
[13:19:59.500]   - Field: ‘expr’
[13:19:59.500]   - Field: ‘uuid’
[13:19:59.500]   - Field: ‘seed’
[13:19:59.500]   - Field: ‘version’
[13:19:59.500]   - Field: ‘result’
[13:19:59.500]   - Field: ‘asynchronous’
[13:19:59.500]   - Field: ‘calls’
[13:19:59.500]   - Field: ‘globals’
[13:19:59.500]   - Field: ‘stdout’
[13:19:59.500]   - Field: ‘earlySignal’
[13:19:59.500]   - Field: ‘lazy’
[13:19:59.501]   - Field: ‘state’
[13:19:59.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:59.501] - Launch lazy future ...
[13:19:59.501] Packages needed by the future expression (n = 0): <none>
[13:19:59.501] Packages needed by future strategies (n = 0): <none>
[13:19:59.502] {
[13:19:59.502]     {
[13:19:59.502]         {
[13:19:59.502]             ...future.startTime <- base::Sys.time()
[13:19:59.502]             {
[13:19:59.502]                 {
[13:19:59.502]                   {
[13:19:59.502]                     {
[13:19:59.502]                       base::local({
[13:19:59.502]                         has_future <- base::requireNamespace("future", 
[13:19:59.502]                           quietly = TRUE)
[13:19:59.502]                         if (has_future) {
[13:19:59.502]                           ns <- base::getNamespace("future")
[13:19:59.502]                           version <- ns[[".package"]][["version"]]
[13:19:59.502]                           if (is.null(version)) 
[13:19:59.502]                             version <- utils::packageVersion("future")
[13:19:59.502]                         }
[13:19:59.502]                         else {
[13:19:59.502]                           version <- NULL
[13:19:59.502]                         }
[13:19:59.502]                         if (!has_future || version < "1.8.0") {
[13:19:59.502]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.502]                             "", base::R.version$version.string), 
[13:19:59.502]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.502]                               "release", "version")], collapse = " "), 
[13:19:59.502]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.502]                             info)
[13:19:59.502]                           info <- base::paste(info, collapse = "; ")
[13:19:59.502]                           if (!has_future) {
[13:19:59.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.502]                               info)
[13:19:59.502]                           }
[13:19:59.502]                           else {
[13:19:59.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.502]                               info, version)
[13:19:59.502]                           }
[13:19:59.502]                           base::stop(msg)
[13:19:59.502]                         }
[13:19:59.502]                       })
[13:19:59.502]                     }
[13:19:59.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.502]                     base::options(mc.cores = 1L)
[13:19:59.502]                   }
[13:19:59.502]                   options(future.plan = NULL)
[13:19:59.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.502]                 }
[13:19:59.502]                 ...future.workdir <- getwd()
[13:19:59.502]             }
[13:19:59.502]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.502]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.502]         }
[13:19:59.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.502]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:59.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.502]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.502]             base::names(...future.oldOptions))
[13:19:59.502]     }
[13:19:59.502]     if (FALSE) {
[13:19:59.502]     }
[13:19:59.502]     else {
[13:19:59.502]         if (TRUE) {
[13:19:59.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.502]                 open = "w")
[13:19:59.502]         }
[13:19:59.502]         else {
[13:19:59.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.502]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.502]         }
[13:19:59.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.502]             base::sink(type = "output", split = FALSE)
[13:19:59.502]             base::close(...future.stdout)
[13:19:59.502]         }, add = TRUE)
[13:19:59.502]     }
[13:19:59.502]     ...future.frame <- base::sys.nframe()
[13:19:59.502]     ...future.conditions <- base::list()
[13:19:59.502]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.502]     if (FALSE) {
[13:19:59.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.502]     }
[13:19:59.502]     ...future.result <- base::tryCatch({
[13:19:59.502]         base::withCallingHandlers({
[13:19:59.502]             ...future.value <- base::withVisible(base::local({
[13:19:59.502]                 ...future.makeSendCondition <- base::local({
[13:19:59.502]                   sendCondition <- NULL
[13:19:59.502]                   function(frame = 1L) {
[13:19:59.502]                     if (is.function(sendCondition)) 
[13:19:59.502]                       return(sendCondition)
[13:19:59.502]                     ns <- getNamespace("parallel")
[13:19:59.502]                     if (exists("sendData", mode = "function", 
[13:19:59.502]                       envir = ns)) {
[13:19:59.502]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:59.502]                         envir = ns)
[13:19:59.502]                       envir <- sys.frame(frame)
[13:19:59.502]                       master <- NULL
[13:19:59.502]                       while (!identical(envir, .GlobalEnv) && 
[13:19:59.502]                         !identical(envir, emptyenv())) {
[13:19:59.502]                         if (exists("master", mode = "list", envir = envir, 
[13:19:59.502]                           inherits = FALSE)) {
[13:19:59.502]                           master <- get("master", mode = "list", 
[13:19:59.502]                             envir = envir, inherits = FALSE)
[13:19:59.502]                           if (inherits(master, c("SOCKnode", 
[13:19:59.502]                             "SOCK0node"))) {
[13:19:59.502]                             sendCondition <<- function(cond) {
[13:19:59.502]                               data <- list(type = "VALUE", value = cond, 
[13:19:59.502]                                 success = TRUE)
[13:19:59.502]                               parallel_sendData(master, data)
[13:19:59.502]                             }
[13:19:59.502]                             return(sendCondition)
[13:19:59.502]                           }
[13:19:59.502]                         }
[13:19:59.502]                         frame <- frame + 1L
[13:19:59.502]                         envir <- sys.frame(frame)
[13:19:59.502]                       }
[13:19:59.502]                     }
[13:19:59.502]                     sendCondition <<- function(cond) NULL
[13:19:59.502]                   }
[13:19:59.502]                 })
[13:19:59.502]                 withCallingHandlers({
[13:19:59.502]                   {
[13:19:59.502]                     do.call(function(...) {
[13:19:59.502]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.502]                       if (!identical(...future.globals.maxSize.org, 
[13:19:59.502]                         ...future.globals.maxSize)) {
[13:19:59.502]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.502]                         on.exit(options(oopts), add = TRUE)
[13:19:59.502]                       }
[13:19:59.502]                       {
[13:19:59.502]                         lapply(seq_along(...future.elements_ii), 
[13:19:59.502]                           FUN = function(jj) {
[13:19:59.502]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.502]                             ...future.FUN(...future.X_jj, ...)
[13:19:59.502]                           })
[13:19:59.502]                       }
[13:19:59.502]                     }, args = future.call.arguments)
[13:19:59.502]                   }
[13:19:59.502]                 }, immediateCondition = function(cond) {
[13:19:59.502]                   sendCondition <- ...future.makeSendCondition()
[13:19:59.502]                   sendCondition(cond)
[13:19:59.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.502]                   {
[13:19:59.502]                     inherits <- base::inherits
[13:19:59.502]                     invokeRestart <- base::invokeRestart
[13:19:59.502]                     is.null <- base::is.null
[13:19:59.502]                     muffled <- FALSE
[13:19:59.502]                     if (inherits(cond, "message")) {
[13:19:59.502]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.502]                       if (muffled) 
[13:19:59.502]                         invokeRestart("muffleMessage")
[13:19:59.502]                     }
[13:19:59.502]                     else if (inherits(cond, "warning")) {
[13:19:59.502]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.502]                       if (muffled) 
[13:19:59.502]                         invokeRestart("muffleWarning")
[13:19:59.502]                     }
[13:19:59.502]                     else if (inherits(cond, "condition")) {
[13:19:59.502]                       if (!is.null(pattern)) {
[13:19:59.502]                         computeRestarts <- base::computeRestarts
[13:19:59.502]                         grepl <- base::grepl
[13:19:59.502]                         restarts <- computeRestarts(cond)
[13:19:59.502]                         for (restart in restarts) {
[13:19:59.502]                           name <- restart$name
[13:19:59.502]                           if (is.null(name)) 
[13:19:59.502]                             next
[13:19:59.502]                           if (!grepl(pattern, name)) 
[13:19:59.502]                             next
[13:19:59.502]                           invokeRestart(restart)
[13:19:59.502]                           muffled <- TRUE
[13:19:59.502]                           break
[13:19:59.502]                         }
[13:19:59.502]                       }
[13:19:59.502]                     }
[13:19:59.502]                     invisible(muffled)
[13:19:59.502]                   }
[13:19:59.502]                   muffleCondition(cond)
[13:19:59.502]                 })
[13:19:59.502]             }))
[13:19:59.502]             future::FutureResult(value = ...future.value$value, 
[13:19:59.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.502]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.502]                     ...future.globalenv.names))
[13:19:59.502]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.502]         }, condition = base::local({
[13:19:59.502]             c <- base::c
[13:19:59.502]             inherits <- base::inherits
[13:19:59.502]             invokeRestart <- base::invokeRestart
[13:19:59.502]             length <- base::length
[13:19:59.502]             list <- base::list
[13:19:59.502]             seq.int <- base::seq.int
[13:19:59.502]             signalCondition <- base::signalCondition
[13:19:59.502]             sys.calls <- base::sys.calls
[13:19:59.502]             `[[` <- base::`[[`
[13:19:59.502]             `+` <- base::`+`
[13:19:59.502]             `<<-` <- base::`<<-`
[13:19:59.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.502]                   3L)]
[13:19:59.502]             }
[13:19:59.502]             function(cond) {
[13:19:59.502]                 is_error <- inherits(cond, "error")
[13:19:59.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.502]                   NULL)
[13:19:59.502]                 if (is_error) {
[13:19:59.502]                   sessionInformation <- function() {
[13:19:59.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.502]                       search = base::search(), system = base::Sys.info())
[13:19:59.502]                   }
[13:19:59.502]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.502]                     cond$call), session = sessionInformation(), 
[13:19:59.502]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.502]                   signalCondition(cond)
[13:19:59.502]                 }
[13:19:59.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.502]                 "immediateCondition"))) {
[13:19:59.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.502]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.502]                   if (TRUE && !signal) {
[13:19:59.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.502]                     {
[13:19:59.502]                       inherits <- base::inherits
[13:19:59.502]                       invokeRestart <- base::invokeRestart
[13:19:59.502]                       is.null <- base::is.null
[13:19:59.502]                       muffled <- FALSE
[13:19:59.502]                       if (inherits(cond, "message")) {
[13:19:59.502]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.502]                         if (muffled) 
[13:19:59.502]                           invokeRestart("muffleMessage")
[13:19:59.502]                       }
[13:19:59.502]                       else if (inherits(cond, "warning")) {
[13:19:59.502]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.502]                         if (muffled) 
[13:19:59.502]                           invokeRestart("muffleWarning")
[13:19:59.502]                       }
[13:19:59.502]                       else if (inherits(cond, "condition")) {
[13:19:59.502]                         if (!is.null(pattern)) {
[13:19:59.502]                           computeRestarts <- base::computeRestarts
[13:19:59.502]                           grepl <- base::grepl
[13:19:59.502]                           restarts <- computeRestarts(cond)
[13:19:59.502]                           for (restart in restarts) {
[13:19:59.502]                             name <- restart$name
[13:19:59.502]                             if (is.null(name)) 
[13:19:59.502]                               next
[13:19:59.502]                             if (!grepl(pattern, name)) 
[13:19:59.502]                               next
[13:19:59.502]                             invokeRestart(restart)
[13:19:59.502]                             muffled <- TRUE
[13:19:59.502]                             break
[13:19:59.502]                           }
[13:19:59.502]                         }
[13:19:59.502]                       }
[13:19:59.502]                       invisible(muffled)
[13:19:59.502]                     }
[13:19:59.502]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.502]                   }
[13:19:59.502]                 }
[13:19:59.502]                 else {
[13:19:59.502]                   if (TRUE) {
[13:19:59.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.502]                     {
[13:19:59.502]                       inherits <- base::inherits
[13:19:59.502]                       invokeRestart <- base::invokeRestart
[13:19:59.502]                       is.null <- base::is.null
[13:19:59.502]                       muffled <- FALSE
[13:19:59.502]                       if (inherits(cond, "message")) {
[13:19:59.502]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.502]                         if (muffled) 
[13:19:59.502]                           invokeRestart("muffleMessage")
[13:19:59.502]                       }
[13:19:59.502]                       else if (inherits(cond, "warning")) {
[13:19:59.502]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.502]                         if (muffled) 
[13:19:59.502]                           invokeRestart("muffleWarning")
[13:19:59.502]                       }
[13:19:59.502]                       else if (inherits(cond, "condition")) {
[13:19:59.502]                         if (!is.null(pattern)) {
[13:19:59.502]                           computeRestarts <- base::computeRestarts
[13:19:59.502]                           grepl <- base::grepl
[13:19:59.502]                           restarts <- computeRestarts(cond)
[13:19:59.502]                           for (restart in restarts) {
[13:19:59.502]                             name <- restart$name
[13:19:59.502]                             if (is.null(name)) 
[13:19:59.502]                               next
[13:19:59.502]                             if (!grepl(pattern, name)) 
[13:19:59.502]                               next
[13:19:59.502]                             invokeRestart(restart)
[13:19:59.502]                             muffled <- TRUE
[13:19:59.502]                             break
[13:19:59.502]                           }
[13:19:59.502]                         }
[13:19:59.502]                       }
[13:19:59.502]                       invisible(muffled)
[13:19:59.502]                     }
[13:19:59.502]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.502]                   }
[13:19:59.502]                 }
[13:19:59.502]             }
[13:19:59.502]         }))
[13:19:59.502]     }, error = function(ex) {
[13:19:59.502]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.502]                 ...future.rng), started = ...future.startTime, 
[13:19:59.502]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.502]             version = "1.8"), class = "FutureResult")
[13:19:59.502]     }, finally = {
[13:19:59.502]         if (!identical(...future.workdir, getwd())) 
[13:19:59.502]             setwd(...future.workdir)
[13:19:59.502]         {
[13:19:59.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.502]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.502]             }
[13:19:59.502]             base::options(...future.oldOptions)
[13:19:59.502]             if (.Platform$OS.type == "windows") {
[13:19:59.502]                 old_names <- names(...future.oldEnvVars)
[13:19:59.502]                 envs <- base::Sys.getenv()
[13:19:59.502]                 names <- names(envs)
[13:19:59.502]                 common <- intersect(names, old_names)
[13:19:59.502]                 added <- setdiff(names, old_names)
[13:19:59.502]                 removed <- setdiff(old_names, names)
[13:19:59.502]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.502]                   envs[common]]
[13:19:59.502]                 NAMES <- toupper(changed)
[13:19:59.502]                 args <- list()
[13:19:59.502]                 for (kk in seq_along(NAMES)) {
[13:19:59.502]                   name <- changed[[kk]]
[13:19:59.502]                   NAME <- NAMES[[kk]]
[13:19:59.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.502]                     next
[13:19:59.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.502]                 }
[13:19:59.502]                 NAMES <- toupper(added)
[13:19:59.502]                 for (kk in seq_along(NAMES)) {
[13:19:59.502]                   name <- added[[kk]]
[13:19:59.502]                   NAME <- NAMES[[kk]]
[13:19:59.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.502]                     next
[13:19:59.502]                   args[[name]] <- ""
[13:19:59.502]                 }
[13:19:59.502]                 NAMES <- toupper(removed)
[13:19:59.502]                 for (kk in seq_along(NAMES)) {
[13:19:59.502]                   name <- removed[[kk]]
[13:19:59.502]                   NAME <- NAMES[[kk]]
[13:19:59.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.502]                     next
[13:19:59.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.502]                 }
[13:19:59.502]                 if (length(args) > 0) 
[13:19:59.502]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.502]             }
[13:19:59.502]             else {
[13:19:59.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.502]             }
[13:19:59.502]             {
[13:19:59.502]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.502]                   0L) {
[13:19:59.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.502]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.502]                   base::options(opts)
[13:19:59.502]                 }
[13:19:59.502]                 {
[13:19:59.502]                   {
[13:19:59.502]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.502]                     NULL
[13:19:59.502]                   }
[13:19:59.502]                   options(future.plan = NULL)
[13:19:59.502]                   if (is.na(NA_character_)) 
[13:19:59.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.502]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:59.502]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:59.502]                     envir = parent.frame()) 
[13:19:59.502]                   {
[13:19:59.502]                     if (is.function(workers)) 
[13:19:59.502]                       workers <- workers()
[13:19:59.502]                     workers <- structure(as.integer(workers), 
[13:19:59.502]                       class = class(workers))
[13:19:59.502]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:59.502]                       workers >= 1)
[13:19:59.502]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:59.502]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:59.502]                     }
[13:19:59.502]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:59.502]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:59.502]                       envir = envir)
[13:19:59.502]                     if (!future$lazy) 
[13:19:59.502]                       future <- run(future)
[13:19:59.502]                     invisible(future)
[13:19:59.502]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.502]                 }
[13:19:59.502]             }
[13:19:59.502]         }
[13:19:59.502]     })
[13:19:59.502]     if (TRUE) {
[13:19:59.502]         base::sink(type = "output", split = FALSE)
[13:19:59.502]         if (TRUE) {
[13:19:59.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.502]         }
[13:19:59.502]         else {
[13:19:59.502]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.502]         }
[13:19:59.502]         base::close(...future.stdout)
[13:19:59.502]         ...future.stdout <- NULL
[13:19:59.502]     }
[13:19:59.502]     ...future.result$conditions <- ...future.conditions
[13:19:59.502]     ...future.result$finished <- base::Sys.time()
[13:19:59.502]     ...future.result
[13:19:59.502] }
[13:19:59.556] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[13:19:59.557] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:59.557] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:59.557] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[13:19:59.600] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[13:19:59.601] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[13:19:59.601] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[13:19:59.601] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:59.602] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:59.602] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:19:59.602] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:19:59.602] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[13:19:59.603] MultisessionFuture started
[13:19:59.603] - Launch lazy future ... done
[13:19:59.603] run() for ‘MultisessionFuture’ ... done
[13:19:59.603] Created future:
[13:19:59.603] MultisessionFuture:
[13:19:59.603] Label: ‘future_apply-2’
[13:19:59.603] Expression:
[13:19:59.603] {
[13:19:59.603]     do.call(function(...) {
[13:19:59.603]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.603]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:59.603]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.603]             on.exit(options(oopts), add = TRUE)
[13:19:59.603]         }
[13:19:59.603]         {
[13:19:59.603]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:59.603]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.603]                 ...future.FUN(...future.X_jj, ...)
[13:19:59.603]             })
[13:19:59.603]         }
[13:19:59.603]     }, args = future.call.arguments)
[13:19:59.603] }
[13:19:59.603] Lazy evaluation: FALSE
[13:19:59.603] Asynchronous evaluation: TRUE
[13:19:59.603] Local evaluation: TRUE
[13:19:59.603] Environment: R_GlobalEnv
[13:19:59.603] Capture standard output: TRUE
[13:19:59.603] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:59.603] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:59.603] Packages: <none>
[13:19:59.603] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:59.603] Resolved: FALSE
[13:19:59.603] Value: <not collected>
[13:19:59.603] Conditions captured: <none>
[13:19:59.603] Early signaling: FALSE
[13:19:59.603] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:59.603] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.615] Chunk #2 of 2 ... DONE
[13:19:59.615] Launching 2 futures (chunks) ... DONE
[13:19:59.615] Resolving 2 futures (chunks) ...
[13:19:59.616] resolve() on list ...
[13:19:59.616]  recursive: 0
[13:19:59.616]  length: 2
[13:19:59.616] 
[13:19:59.616] receiveMessageFromWorker() for ClusterFuture ...
[13:19:59.617] - Validating connection of MultisessionFuture
[13:19:59.617] - received message: FutureResult
[13:19:59.617] - Received FutureResult
[13:19:59.617] - Erased future from FutureRegistry
[13:19:59.617] result() for ClusterFuture ...
[13:19:59.617] - result already collected: FutureResult
[13:19:59.617] result() for ClusterFuture ... done
[13:19:59.617] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:59.617] Future #1
[13:19:59.618] result() for ClusterFuture ...
[13:19:59.618] - result already collected: FutureResult
[13:19:59.618] result() for ClusterFuture ... done
[13:19:59.618] result() for ClusterFuture ...
[13:19:59.618] - result already collected: FutureResult
[13:19:59.618] result() for ClusterFuture ... done
[13:19:59.618] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:59.618] - nx: 2
[13:19:59.618] - relay: TRUE
[13:19:59.618] - stdout: TRUE
[13:19:59.618] - signal: TRUE
[13:19:59.618] - resignal: FALSE
[13:19:59.619] - force: TRUE
[13:19:59.619] - relayed: [n=2] FALSE, FALSE
[13:19:59.619] - queued futures: [n=2] FALSE, FALSE
[13:19:59.619]  - until=1
[13:19:59.619]  - relaying element #1
[13:19:59.619] result() for ClusterFuture ...
[13:19:59.619] - result already collected: FutureResult
[13:19:59.619] result() for ClusterFuture ... done
[13:19:59.619] result() for ClusterFuture ...
[13:19:59.619] - result already collected: FutureResult
[13:19:59.619] result() for ClusterFuture ... done
[13:19:59.620] result() for ClusterFuture ...
[13:19:59.620] - result already collected: FutureResult
[13:19:59.620] result() for ClusterFuture ... done
[13:19:59.620] result() for ClusterFuture ...
[13:19:59.620] - result already collected: FutureResult
[13:19:59.620] result() for ClusterFuture ... done
[13:19:59.620] - relayed: [n=2] TRUE, FALSE
[13:19:59.620] - queued futures: [n=2] TRUE, FALSE
[13:19:59.620] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:59.620]  length: 1 (resolved future 1)
[13:19:59.689] receiveMessageFromWorker() for ClusterFuture ...
[13:19:59.690] - Validating connection of MultisessionFuture
[13:19:59.690] - received message: FutureResult
[13:19:59.690] - Received FutureResult
[13:19:59.690] - Erased future from FutureRegistry
[13:19:59.690] result() for ClusterFuture ...
[13:19:59.690] - result already collected: FutureResult
[13:19:59.691] result() for ClusterFuture ... done
[13:19:59.691] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:59.691] Future #2
[13:19:59.691] result() for ClusterFuture ...
[13:19:59.691] - result already collected: FutureResult
[13:19:59.691] result() for ClusterFuture ... done
[13:19:59.691] result() for ClusterFuture ...
[13:19:59.691] - result already collected: FutureResult
[13:19:59.691] result() for ClusterFuture ... done
[13:19:59.691] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:59.691] - nx: 2
[13:19:59.692] - relay: TRUE
[13:19:59.692] - stdout: TRUE
[13:19:59.692] - signal: TRUE
[13:19:59.692] - resignal: FALSE
[13:19:59.692] - force: TRUE
[13:19:59.692] - relayed: [n=2] TRUE, FALSE
[13:19:59.692] - queued futures: [n=2] TRUE, FALSE
[13:19:59.692]  - until=2
[13:19:59.692]  - relaying element #2
[13:19:59.692] result() for ClusterFuture ...
[13:19:59.693] - result already collected: FutureResult
[13:19:59.693] result() for ClusterFuture ... done
[13:19:59.693] result() for ClusterFuture ...
[13:19:59.693] - result already collected: FutureResult
[13:19:59.693] result() for ClusterFuture ... done
[13:19:59.693] result() for ClusterFuture ...
[13:19:59.693] - result already collected: FutureResult
[13:19:59.693] result() for ClusterFuture ... done
[13:19:59.693] result() for ClusterFuture ...
[13:19:59.693] - result already collected: FutureResult
[13:19:59.693] result() for ClusterFuture ... done
[13:19:59.694] - relayed: [n=2] TRUE, TRUE
[13:19:59.694] - queued futures: [n=2] TRUE, TRUE
[13:19:59.694] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:59.694]  length: 0 (resolved future 2)
[13:19:59.694] Relaying remaining futures
[13:19:59.694] signalConditionsASAP(NULL, pos=0) ...
[13:19:59.694] - nx: 2
[13:19:59.694] - relay: TRUE
[13:19:59.694] - stdout: TRUE
[13:19:59.694] - signal: TRUE
[13:19:59.694] - resignal: FALSE
[13:19:59.694] - force: TRUE
[13:19:59.695] - relayed: [n=2] TRUE, TRUE
[13:19:59.695] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:59.695] - relayed: [n=2] TRUE, TRUE
[13:19:59.695] - queued futures: [n=2] TRUE, TRUE
[13:19:59.695] signalConditionsASAP(NULL, pos=0) ... done
[13:19:59.695] resolve() on list ... DONE
[13:19:59.695] result() for ClusterFuture ...
[13:19:59.695] - result already collected: FutureResult
[13:19:59.695] result() for ClusterFuture ... done
[13:19:59.695] result() for ClusterFuture ...
[13:19:59.695] - result already collected: FutureResult
[13:19:59.696] result() for ClusterFuture ... done
[13:19:59.696] result() for ClusterFuture ...
[13:19:59.696] - result already collected: FutureResult
[13:19:59.696] result() for ClusterFuture ... done
[13:19:59.696] result() for ClusterFuture ...
[13:19:59.696] - result already collected: FutureResult
[13:19:59.696] result() for ClusterFuture ... done
[13:19:59.696]  - Number of value chunks collected: 2
[13:19:59.696] Resolving 2 futures (chunks) ... DONE
[13:19:59.696] Reducing values from 2 chunks ...
[13:19:59.697]  - Number of values collected after concatenation: 2
[13:19:59.697]  - Number of values expected: 2
[13:19:59.697] Reducing values from 2 chunks ... DONE
[13:19:59.697] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:19:59.697] getGlobalsAndPackagesXApply() ...
[13:19:59.697]  - future.globals: TRUE
[13:19:59.698] getGlobalsAndPackages() ...
[13:19:59.698] Searching for globals...
[13:19:59.730] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:19:59.730] Searching for globals ... DONE
[13:19:59.730] Resolving globals: FALSE
[13:19:59.732] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:19:59.732] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:19:59.733] - globals: [1] ‘FUN’
[13:19:59.733] 
[13:19:59.733] getGlobalsAndPackages() ... DONE
[13:19:59.733]  - globals found/used: [n=1] ‘FUN’
[13:19:59.733]  - needed namespaces: [n=0] 
[13:19:59.733] Finding globals ... DONE
[13:19:59.733]  - use_args: TRUE
[13:19:59.733]  - Getting '...' globals ...
[13:19:59.734] resolve() on list ...
[13:19:59.734]  recursive: 0
[13:19:59.734]  length: 1
[13:19:59.734]  elements: ‘...’
[13:19:59.734]  length: 0 (resolved future 1)
[13:19:59.734] resolve() on list ... DONE
[13:19:59.734]    - '...' content: [n=0] 
[13:19:59.734] List of 1
[13:19:59.734]  $ ...: list()
[13:19:59.734]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:59.734]  - attr(*, "where")=List of 1
[13:19:59.734]   ..$ ...:<environment: 0x555921dc1ea8> 
[13:19:59.734]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.734]  - attr(*, "resolved")= logi TRUE
[13:19:59.734]  - attr(*, "total_size")= num NA
[13:19:59.737]  - Getting '...' globals ... DONE
[13:19:59.737] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:59.737] List of 2
[13:19:59.737]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:59.737]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:59.737]  $ ...          : list()
[13:19:59.737]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:59.737]  - attr(*, "where")=List of 2
[13:19:59.737]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:59.737]   ..$ ...          :<environment: 0x555921dc1ea8> 
[13:19:59.737]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.737]  - attr(*, "resolved")= logi FALSE
[13:19:59.737]  - attr(*, "total_size")= num 354224
[13:19:59.740] Packages to be attached in all futures: [n=0] 
[13:19:59.740] getGlobalsAndPackagesXApply() ... DONE
[13:19:59.745] future_lapply() ...
[13:19:59.779] Number of chunks: 2
[13:19:59.779] getGlobalsAndPackagesXApply() ...
[13:19:59.779]  - future.globals: <name-value list> with names ‘list()’
[13:19:59.780]  - use_args: TRUE
[13:19:59.780] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:19:59.780] List of 2
[13:19:59.780]  $ ...          : list()
[13:19:59.780]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:59.780]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:19:59.780]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:19:59.780]  - attr(*, "where")=List of 2
[13:19:59.780]   ..$ ...          :<environment: 0x555921dc1ea8> 
[13:19:59.780]   ..$ ...future.FUN:<environment: namespace:base> 
[13:19:59.780]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.780]  - attr(*, "resolved")= logi FALSE
[13:19:59.780]  - attr(*, "total_size")= num NA
[13:19:59.783] Packages to be attached in all futures: [n=0] 
[13:19:59.784] getGlobalsAndPackagesXApply() ... DONE
[13:19:59.784] Number of futures (= number of chunks): 2
[13:19:59.784] Launching 2 futures (chunks) ...
[13:19:59.784] Chunk #1 of 2 ...
[13:19:59.784]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:59.784]  - seeds: <none>
[13:19:59.784]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.784] getGlobalsAndPackages() ...
[13:19:59.785] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.785] Resolving globals: FALSE
[13:19:59.785] Tweak future expression to call with '...' arguments ...
[13:19:59.785] {
[13:19:59.785]     do.call(function(...) {
[13:19:59.785]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.785]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:59.785]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.785]             on.exit(options(oopts), add = TRUE)
[13:19:59.785]         }
[13:19:59.785]         {
[13:19:59.785]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:59.785]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.785]                 ...future.FUN(...future.X_jj, ...)
[13:19:59.785]             })
[13:19:59.785]         }
[13:19:59.785]     }, args = future.call.arguments)
[13:19:59.785] }
[13:19:59.785] Tweak future expression to call with '...' arguments ... DONE
[13:19:59.786] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.786] 
[13:19:59.786] getGlobalsAndPackages() ... DONE
[13:19:59.786] run() for ‘Future’ ...
[13:19:59.786] - state: ‘created’
[13:19:59.786] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.800] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.800] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:59.800]   - Field: ‘node’
[13:19:59.801]   - Field: ‘label’
[13:19:59.801]   - Field: ‘local’
[13:19:59.801]   - Field: ‘owner’
[13:19:59.801]   - Field: ‘envir’
[13:19:59.801]   - Field: ‘workers’
[13:19:59.801]   - Field: ‘packages’
[13:19:59.801]   - Field: ‘gc’
[13:19:59.801]   - Field: ‘conditions’
[13:19:59.801]   - Field: ‘persistent’
[13:19:59.801]   - Field: ‘expr’
[13:19:59.802]   - Field: ‘uuid’
[13:19:59.802]   - Field: ‘seed’
[13:19:59.802]   - Field: ‘version’
[13:19:59.802]   - Field: ‘result’
[13:19:59.802]   - Field: ‘asynchronous’
[13:19:59.802]   - Field: ‘calls’
[13:19:59.802]   - Field: ‘globals’
[13:19:59.802]   - Field: ‘stdout’
[13:19:59.802]   - Field: ‘earlySignal’
[13:19:59.802]   - Field: ‘lazy’
[13:19:59.803]   - Field: ‘state’
[13:19:59.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:59.803] - Launch lazy future ...
[13:19:59.803] Packages needed by the future expression (n = 0): <none>
[13:19:59.803] Packages needed by future strategies (n = 0): <none>
[13:19:59.804] {
[13:19:59.804]     {
[13:19:59.804]         {
[13:19:59.804]             ...future.startTime <- base::Sys.time()
[13:19:59.804]             {
[13:19:59.804]                 {
[13:19:59.804]                   {
[13:19:59.804]                     {
[13:19:59.804]                       base::local({
[13:19:59.804]                         has_future <- base::requireNamespace("future", 
[13:19:59.804]                           quietly = TRUE)
[13:19:59.804]                         if (has_future) {
[13:19:59.804]                           ns <- base::getNamespace("future")
[13:19:59.804]                           version <- ns[[".package"]][["version"]]
[13:19:59.804]                           if (is.null(version)) 
[13:19:59.804]                             version <- utils::packageVersion("future")
[13:19:59.804]                         }
[13:19:59.804]                         else {
[13:19:59.804]                           version <- NULL
[13:19:59.804]                         }
[13:19:59.804]                         if (!has_future || version < "1.8.0") {
[13:19:59.804]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.804]                             "", base::R.version$version.string), 
[13:19:59.804]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.804]                               "release", "version")], collapse = " "), 
[13:19:59.804]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.804]                             info)
[13:19:59.804]                           info <- base::paste(info, collapse = "; ")
[13:19:59.804]                           if (!has_future) {
[13:19:59.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.804]                               info)
[13:19:59.804]                           }
[13:19:59.804]                           else {
[13:19:59.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.804]                               info, version)
[13:19:59.804]                           }
[13:19:59.804]                           base::stop(msg)
[13:19:59.804]                         }
[13:19:59.804]                       })
[13:19:59.804]                     }
[13:19:59.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.804]                     base::options(mc.cores = 1L)
[13:19:59.804]                   }
[13:19:59.804]                   options(future.plan = NULL)
[13:19:59.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.804]                 }
[13:19:59.804]                 ...future.workdir <- getwd()
[13:19:59.804]             }
[13:19:59.804]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.804]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.804]         }
[13:19:59.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.804]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:59.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.804]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.804]             base::names(...future.oldOptions))
[13:19:59.804]     }
[13:19:59.804]     if (FALSE) {
[13:19:59.804]     }
[13:19:59.804]     else {
[13:19:59.804]         if (TRUE) {
[13:19:59.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.804]                 open = "w")
[13:19:59.804]         }
[13:19:59.804]         else {
[13:19:59.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.804]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.804]         }
[13:19:59.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.804]             base::sink(type = "output", split = FALSE)
[13:19:59.804]             base::close(...future.stdout)
[13:19:59.804]         }, add = TRUE)
[13:19:59.804]     }
[13:19:59.804]     ...future.frame <- base::sys.nframe()
[13:19:59.804]     ...future.conditions <- base::list()
[13:19:59.804]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.804]     if (FALSE) {
[13:19:59.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.804]     }
[13:19:59.804]     ...future.result <- base::tryCatch({
[13:19:59.804]         base::withCallingHandlers({
[13:19:59.804]             ...future.value <- base::withVisible(base::local({
[13:19:59.804]                 ...future.makeSendCondition <- base::local({
[13:19:59.804]                   sendCondition <- NULL
[13:19:59.804]                   function(frame = 1L) {
[13:19:59.804]                     if (is.function(sendCondition)) 
[13:19:59.804]                       return(sendCondition)
[13:19:59.804]                     ns <- getNamespace("parallel")
[13:19:59.804]                     if (exists("sendData", mode = "function", 
[13:19:59.804]                       envir = ns)) {
[13:19:59.804]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:59.804]                         envir = ns)
[13:19:59.804]                       envir <- sys.frame(frame)
[13:19:59.804]                       master <- NULL
[13:19:59.804]                       while (!identical(envir, .GlobalEnv) && 
[13:19:59.804]                         !identical(envir, emptyenv())) {
[13:19:59.804]                         if (exists("master", mode = "list", envir = envir, 
[13:19:59.804]                           inherits = FALSE)) {
[13:19:59.804]                           master <- get("master", mode = "list", 
[13:19:59.804]                             envir = envir, inherits = FALSE)
[13:19:59.804]                           if (inherits(master, c("SOCKnode", 
[13:19:59.804]                             "SOCK0node"))) {
[13:19:59.804]                             sendCondition <<- function(cond) {
[13:19:59.804]                               data <- list(type = "VALUE", value = cond, 
[13:19:59.804]                                 success = TRUE)
[13:19:59.804]                               parallel_sendData(master, data)
[13:19:59.804]                             }
[13:19:59.804]                             return(sendCondition)
[13:19:59.804]                           }
[13:19:59.804]                         }
[13:19:59.804]                         frame <- frame + 1L
[13:19:59.804]                         envir <- sys.frame(frame)
[13:19:59.804]                       }
[13:19:59.804]                     }
[13:19:59.804]                     sendCondition <<- function(cond) NULL
[13:19:59.804]                   }
[13:19:59.804]                 })
[13:19:59.804]                 withCallingHandlers({
[13:19:59.804]                   {
[13:19:59.804]                     do.call(function(...) {
[13:19:59.804]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.804]                       if (!identical(...future.globals.maxSize.org, 
[13:19:59.804]                         ...future.globals.maxSize)) {
[13:19:59.804]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.804]                         on.exit(options(oopts), add = TRUE)
[13:19:59.804]                       }
[13:19:59.804]                       {
[13:19:59.804]                         lapply(seq_along(...future.elements_ii), 
[13:19:59.804]                           FUN = function(jj) {
[13:19:59.804]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.804]                             ...future.FUN(...future.X_jj, ...)
[13:19:59.804]                           })
[13:19:59.804]                       }
[13:19:59.804]                     }, args = future.call.arguments)
[13:19:59.804]                   }
[13:19:59.804]                 }, immediateCondition = function(cond) {
[13:19:59.804]                   sendCondition <- ...future.makeSendCondition()
[13:19:59.804]                   sendCondition(cond)
[13:19:59.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.804]                   {
[13:19:59.804]                     inherits <- base::inherits
[13:19:59.804]                     invokeRestart <- base::invokeRestart
[13:19:59.804]                     is.null <- base::is.null
[13:19:59.804]                     muffled <- FALSE
[13:19:59.804]                     if (inherits(cond, "message")) {
[13:19:59.804]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.804]                       if (muffled) 
[13:19:59.804]                         invokeRestart("muffleMessage")
[13:19:59.804]                     }
[13:19:59.804]                     else if (inherits(cond, "warning")) {
[13:19:59.804]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.804]                       if (muffled) 
[13:19:59.804]                         invokeRestart("muffleWarning")
[13:19:59.804]                     }
[13:19:59.804]                     else if (inherits(cond, "condition")) {
[13:19:59.804]                       if (!is.null(pattern)) {
[13:19:59.804]                         computeRestarts <- base::computeRestarts
[13:19:59.804]                         grepl <- base::grepl
[13:19:59.804]                         restarts <- computeRestarts(cond)
[13:19:59.804]                         for (restart in restarts) {
[13:19:59.804]                           name <- restart$name
[13:19:59.804]                           if (is.null(name)) 
[13:19:59.804]                             next
[13:19:59.804]                           if (!grepl(pattern, name)) 
[13:19:59.804]                             next
[13:19:59.804]                           invokeRestart(restart)
[13:19:59.804]                           muffled <- TRUE
[13:19:59.804]                           break
[13:19:59.804]                         }
[13:19:59.804]                       }
[13:19:59.804]                     }
[13:19:59.804]                     invisible(muffled)
[13:19:59.804]                   }
[13:19:59.804]                   muffleCondition(cond)
[13:19:59.804]                 })
[13:19:59.804]             }))
[13:19:59.804]             future::FutureResult(value = ...future.value$value, 
[13:19:59.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.804]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.804]                     ...future.globalenv.names))
[13:19:59.804]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.804]         }, condition = base::local({
[13:19:59.804]             c <- base::c
[13:19:59.804]             inherits <- base::inherits
[13:19:59.804]             invokeRestart <- base::invokeRestart
[13:19:59.804]             length <- base::length
[13:19:59.804]             list <- base::list
[13:19:59.804]             seq.int <- base::seq.int
[13:19:59.804]             signalCondition <- base::signalCondition
[13:19:59.804]             sys.calls <- base::sys.calls
[13:19:59.804]             `[[` <- base::`[[`
[13:19:59.804]             `+` <- base::`+`
[13:19:59.804]             `<<-` <- base::`<<-`
[13:19:59.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.804]                   3L)]
[13:19:59.804]             }
[13:19:59.804]             function(cond) {
[13:19:59.804]                 is_error <- inherits(cond, "error")
[13:19:59.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.804]                   NULL)
[13:19:59.804]                 if (is_error) {
[13:19:59.804]                   sessionInformation <- function() {
[13:19:59.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.804]                       search = base::search(), system = base::Sys.info())
[13:19:59.804]                   }
[13:19:59.804]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.804]                     cond$call), session = sessionInformation(), 
[13:19:59.804]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.804]                   signalCondition(cond)
[13:19:59.804]                 }
[13:19:59.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.804]                 "immediateCondition"))) {
[13:19:59.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.804]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.804]                   if (TRUE && !signal) {
[13:19:59.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.804]                     {
[13:19:59.804]                       inherits <- base::inherits
[13:19:59.804]                       invokeRestart <- base::invokeRestart
[13:19:59.804]                       is.null <- base::is.null
[13:19:59.804]                       muffled <- FALSE
[13:19:59.804]                       if (inherits(cond, "message")) {
[13:19:59.804]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.804]                         if (muffled) 
[13:19:59.804]                           invokeRestart("muffleMessage")
[13:19:59.804]                       }
[13:19:59.804]                       else if (inherits(cond, "warning")) {
[13:19:59.804]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.804]                         if (muffled) 
[13:19:59.804]                           invokeRestart("muffleWarning")
[13:19:59.804]                       }
[13:19:59.804]                       else if (inherits(cond, "condition")) {
[13:19:59.804]                         if (!is.null(pattern)) {
[13:19:59.804]                           computeRestarts <- base::computeRestarts
[13:19:59.804]                           grepl <- base::grepl
[13:19:59.804]                           restarts <- computeRestarts(cond)
[13:19:59.804]                           for (restart in restarts) {
[13:19:59.804]                             name <- restart$name
[13:19:59.804]                             if (is.null(name)) 
[13:19:59.804]                               next
[13:19:59.804]                             if (!grepl(pattern, name)) 
[13:19:59.804]                               next
[13:19:59.804]                             invokeRestart(restart)
[13:19:59.804]                             muffled <- TRUE
[13:19:59.804]                             break
[13:19:59.804]                           }
[13:19:59.804]                         }
[13:19:59.804]                       }
[13:19:59.804]                       invisible(muffled)
[13:19:59.804]                     }
[13:19:59.804]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.804]                   }
[13:19:59.804]                 }
[13:19:59.804]                 else {
[13:19:59.804]                   if (TRUE) {
[13:19:59.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.804]                     {
[13:19:59.804]                       inherits <- base::inherits
[13:19:59.804]                       invokeRestart <- base::invokeRestart
[13:19:59.804]                       is.null <- base::is.null
[13:19:59.804]                       muffled <- FALSE
[13:19:59.804]                       if (inherits(cond, "message")) {
[13:19:59.804]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.804]                         if (muffled) 
[13:19:59.804]                           invokeRestart("muffleMessage")
[13:19:59.804]                       }
[13:19:59.804]                       else if (inherits(cond, "warning")) {
[13:19:59.804]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.804]                         if (muffled) 
[13:19:59.804]                           invokeRestart("muffleWarning")
[13:19:59.804]                       }
[13:19:59.804]                       else if (inherits(cond, "condition")) {
[13:19:59.804]                         if (!is.null(pattern)) {
[13:19:59.804]                           computeRestarts <- base::computeRestarts
[13:19:59.804]                           grepl <- base::grepl
[13:19:59.804]                           restarts <- computeRestarts(cond)
[13:19:59.804]                           for (restart in restarts) {
[13:19:59.804]                             name <- restart$name
[13:19:59.804]                             if (is.null(name)) 
[13:19:59.804]                               next
[13:19:59.804]                             if (!grepl(pattern, name)) 
[13:19:59.804]                               next
[13:19:59.804]                             invokeRestart(restart)
[13:19:59.804]                             muffled <- TRUE
[13:19:59.804]                             break
[13:19:59.804]                           }
[13:19:59.804]                         }
[13:19:59.804]                       }
[13:19:59.804]                       invisible(muffled)
[13:19:59.804]                     }
[13:19:59.804]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.804]                   }
[13:19:59.804]                 }
[13:19:59.804]             }
[13:19:59.804]         }))
[13:19:59.804]     }, error = function(ex) {
[13:19:59.804]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.804]                 ...future.rng), started = ...future.startTime, 
[13:19:59.804]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.804]             version = "1.8"), class = "FutureResult")
[13:19:59.804]     }, finally = {
[13:19:59.804]         if (!identical(...future.workdir, getwd())) 
[13:19:59.804]             setwd(...future.workdir)
[13:19:59.804]         {
[13:19:59.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.804]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.804]             }
[13:19:59.804]             base::options(...future.oldOptions)
[13:19:59.804]             if (.Platform$OS.type == "windows") {
[13:19:59.804]                 old_names <- names(...future.oldEnvVars)
[13:19:59.804]                 envs <- base::Sys.getenv()
[13:19:59.804]                 names <- names(envs)
[13:19:59.804]                 common <- intersect(names, old_names)
[13:19:59.804]                 added <- setdiff(names, old_names)
[13:19:59.804]                 removed <- setdiff(old_names, names)
[13:19:59.804]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.804]                   envs[common]]
[13:19:59.804]                 NAMES <- toupper(changed)
[13:19:59.804]                 args <- list()
[13:19:59.804]                 for (kk in seq_along(NAMES)) {
[13:19:59.804]                   name <- changed[[kk]]
[13:19:59.804]                   NAME <- NAMES[[kk]]
[13:19:59.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.804]                     next
[13:19:59.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.804]                 }
[13:19:59.804]                 NAMES <- toupper(added)
[13:19:59.804]                 for (kk in seq_along(NAMES)) {
[13:19:59.804]                   name <- added[[kk]]
[13:19:59.804]                   NAME <- NAMES[[kk]]
[13:19:59.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.804]                     next
[13:19:59.804]                   args[[name]] <- ""
[13:19:59.804]                 }
[13:19:59.804]                 NAMES <- toupper(removed)
[13:19:59.804]                 for (kk in seq_along(NAMES)) {
[13:19:59.804]                   name <- removed[[kk]]
[13:19:59.804]                   NAME <- NAMES[[kk]]
[13:19:59.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.804]                     next
[13:19:59.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.804]                 }
[13:19:59.804]                 if (length(args) > 0) 
[13:19:59.804]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.804]             }
[13:19:59.804]             else {
[13:19:59.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.804]             }
[13:19:59.804]             {
[13:19:59.804]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.804]                   0L) {
[13:19:59.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.804]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.804]                   base::options(opts)
[13:19:59.804]                 }
[13:19:59.804]                 {
[13:19:59.804]                   {
[13:19:59.804]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.804]                     NULL
[13:19:59.804]                   }
[13:19:59.804]                   options(future.plan = NULL)
[13:19:59.804]                   if (is.na(NA_character_)) 
[13:19:59.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.804]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:59.804]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:59.804]                     envir = parent.frame()) 
[13:19:59.804]                   {
[13:19:59.804]                     if (is.function(workers)) 
[13:19:59.804]                       workers <- workers()
[13:19:59.804]                     workers <- structure(as.integer(workers), 
[13:19:59.804]                       class = class(workers))
[13:19:59.804]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:59.804]                       workers >= 1)
[13:19:59.804]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:59.804]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:59.804]                     }
[13:19:59.804]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:59.804]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:59.804]                       envir = envir)
[13:19:59.804]                     if (!future$lazy) 
[13:19:59.804]                       future <- run(future)
[13:19:59.804]                     invisible(future)
[13:19:59.804]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.804]                 }
[13:19:59.804]             }
[13:19:59.804]         }
[13:19:59.804]     })
[13:19:59.804]     if (TRUE) {
[13:19:59.804]         base::sink(type = "output", split = FALSE)
[13:19:59.804]         if (TRUE) {
[13:19:59.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.804]         }
[13:19:59.804]         else {
[13:19:59.804]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.804]         }
[13:19:59.804]         base::close(...future.stdout)
[13:19:59.804]         ...future.stdout <- NULL
[13:19:59.804]     }
[13:19:59.804]     ...future.result$conditions <- ...future.conditions
[13:19:59.804]     ...future.result$finished <- base::Sys.time()
[13:19:59.804]     ...future.result
[13:19:59.804] }
[13:19:59.807] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[13:19:59.807] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:59.808] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:59.808] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[13:19:59.852] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[13:19:59.853] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[13:19:59.853] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[13:19:59.853] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:59.854] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:59.854] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:19:59.854] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:19:59.854] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[13:19:59.855] MultisessionFuture started
[13:19:59.855] - Launch lazy future ... done
[13:19:59.855] run() for ‘MultisessionFuture’ ... done
[13:19:59.855] Created future:
[13:19:59.855] MultisessionFuture:
[13:19:59.855] Label: ‘future_apply-1’
[13:19:59.855] Expression:
[13:19:59.855] {
[13:19:59.855]     do.call(function(...) {
[13:19:59.855]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.855]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:59.855]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.855]             on.exit(options(oopts), add = TRUE)
[13:19:59.855]         }
[13:19:59.855]         {
[13:19:59.855]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:59.855]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.855]                 ...future.FUN(...future.X_jj, ...)
[13:19:59.855]             })
[13:19:59.855]         }
[13:19:59.855]     }, args = future.call.arguments)
[13:19:59.855] }
[13:19:59.855] Lazy evaluation: FALSE
[13:19:59.855] Asynchronous evaluation: TRUE
[13:19:59.855] Local evaluation: TRUE
[13:19:59.855] Environment: R_GlobalEnv
[13:19:59.855] Capture standard output: TRUE
[13:19:59.855] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:59.855] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:59.855] Packages: <none>
[13:19:59.855] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:59.855] Resolved: FALSE
[13:19:59.855] Value: <not collected>
[13:19:59.855] Conditions captured: <none>
[13:19:59.855] Early signaling: FALSE
[13:19:59.855] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:59.855] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.867] Chunk #1 of 2 ... DONE
[13:19:59.867] Chunk #2 of 2 ...
[13:19:59.867]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:19:59.867]  - seeds: <none>
[13:19:59.868]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.868] getGlobalsAndPackages() ...
[13:19:59.868] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.868] Resolving globals: FALSE
[13:19:59.868] Tweak future expression to call with '...' arguments ...
[13:19:59.868] {
[13:19:59.868]     do.call(function(...) {
[13:19:59.868]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.868]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:59.868]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.868]             on.exit(options(oopts), add = TRUE)
[13:19:59.868]         }
[13:19:59.868]         {
[13:19:59.868]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:59.868]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.868]                 ...future.FUN(...future.X_jj, ...)
[13:19:59.868]             })
[13:19:59.868]         }
[13:19:59.868]     }, args = future.call.arguments)
[13:19:59.868] }
[13:19:59.868] Tweak future expression to call with '...' arguments ... DONE
[13:19:59.869] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:59.869] 
[13:19:59.869] getGlobalsAndPackages() ... DONE
[13:19:59.869] run() for ‘Future’ ...
[13:19:59.869] - state: ‘created’
[13:19:59.870] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.884] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:59.884]   - Field: ‘node’
[13:19:59.884]   - Field: ‘label’
[13:19:59.884]   - Field: ‘local’
[13:19:59.885]   - Field: ‘owner’
[13:19:59.885]   - Field: ‘envir’
[13:19:59.885]   - Field: ‘workers’
[13:19:59.885]   - Field: ‘packages’
[13:19:59.885]   - Field: ‘gc’
[13:19:59.885]   - Field: ‘conditions’
[13:19:59.885]   - Field: ‘persistent’
[13:19:59.885]   - Field: ‘expr’
[13:19:59.885]   - Field: ‘uuid’
[13:19:59.885]   - Field: ‘seed’
[13:19:59.885]   - Field: ‘version’
[13:19:59.886]   - Field: ‘result’
[13:19:59.886]   - Field: ‘asynchronous’
[13:19:59.886]   - Field: ‘calls’
[13:19:59.886]   - Field: ‘globals’
[13:19:59.886]   - Field: ‘stdout’
[13:19:59.886]   - Field: ‘earlySignal’
[13:19:59.886]   - Field: ‘lazy’
[13:19:59.886]   - Field: ‘state’
[13:19:59.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:59.886] - Launch lazy future ...
[13:19:59.887] Packages needed by the future expression (n = 0): <none>
[13:19:59.887] Packages needed by future strategies (n = 0): <none>
[13:19:59.887] {
[13:19:59.887]     {
[13:19:59.887]         {
[13:19:59.887]             ...future.startTime <- base::Sys.time()
[13:19:59.887]             {
[13:19:59.887]                 {
[13:19:59.887]                   {
[13:19:59.887]                     {
[13:19:59.887]                       base::local({
[13:19:59.887]                         has_future <- base::requireNamespace("future", 
[13:19:59.887]                           quietly = TRUE)
[13:19:59.887]                         if (has_future) {
[13:19:59.887]                           ns <- base::getNamespace("future")
[13:19:59.887]                           version <- ns[[".package"]][["version"]]
[13:19:59.887]                           if (is.null(version)) 
[13:19:59.887]                             version <- utils::packageVersion("future")
[13:19:59.887]                         }
[13:19:59.887]                         else {
[13:19:59.887]                           version <- NULL
[13:19:59.887]                         }
[13:19:59.887]                         if (!has_future || version < "1.8.0") {
[13:19:59.887]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.887]                             "", base::R.version$version.string), 
[13:19:59.887]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.887]                               "release", "version")], collapse = " "), 
[13:19:59.887]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.887]                             info)
[13:19:59.887]                           info <- base::paste(info, collapse = "; ")
[13:19:59.887]                           if (!has_future) {
[13:19:59.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.887]                               info)
[13:19:59.887]                           }
[13:19:59.887]                           else {
[13:19:59.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.887]                               info, version)
[13:19:59.887]                           }
[13:19:59.887]                           base::stop(msg)
[13:19:59.887]                         }
[13:19:59.887]                       })
[13:19:59.887]                     }
[13:19:59.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.887]                     base::options(mc.cores = 1L)
[13:19:59.887]                   }
[13:19:59.887]                   options(future.plan = NULL)
[13:19:59.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.887]                 }
[13:19:59.887]                 ...future.workdir <- getwd()
[13:19:59.887]             }
[13:19:59.887]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.887]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.887]         }
[13:19:59.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.887]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:19:59.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.887]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.887]             base::names(...future.oldOptions))
[13:19:59.887]     }
[13:19:59.887]     if (FALSE) {
[13:19:59.887]     }
[13:19:59.887]     else {
[13:19:59.887]         if (TRUE) {
[13:19:59.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.887]                 open = "w")
[13:19:59.887]         }
[13:19:59.887]         else {
[13:19:59.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.887]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.887]         }
[13:19:59.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.887]             base::sink(type = "output", split = FALSE)
[13:19:59.887]             base::close(...future.stdout)
[13:19:59.887]         }, add = TRUE)
[13:19:59.887]     }
[13:19:59.887]     ...future.frame <- base::sys.nframe()
[13:19:59.887]     ...future.conditions <- base::list()
[13:19:59.887]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.887]     if (FALSE) {
[13:19:59.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.887]     }
[13:19:59.887]     ...future.result <- base::tryCatch({
[13:19:59.887]         base::withCallingHandlers({
[13:19:59.887]             ...future.value <- base::withVisible(base::local({
[13:19:59.887]                 ...future.makeSendCondition <- base::local({
[13:19:59.887]                   sendCondition <- NULL
[13:19:59.887]                   function(frame = 1L) {
[13:19:59.887]                     if (is.function(sendCondition)) 
[13:19:59.887]                       return(sendCondition)
[13:19:59.887]                     ns <- getNamespace("parallel")
[13:19:59.887]                     if (exists("sendData", mode = "function", 
[13:19:59.887]                       envir = ns)) {
[13:19:59.887]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:59.887]                         envir = ns)
[13:19:59.887]                       envir <- sys.frame(frame)
[13:19:59.887]                       master <- NULL
[13:19:59.887]                       while (!identical(envir, .GlobalEnv) && 
[13:19:59.887]                         !identical(envir, emptyenv())) {
[13:19:59.887]                         if (exists("master", mode = "list", envir = envir, 
[13:19:59.887]                           inherits = FALSE)) {
[13:19:59.887]                           master <- get("master", mode = "list", 
[13:19:59.887]                             envir = envir, inherits = FALSE)
[13:19:59.887]                           if (inherits(master, c("SOCKnode", 
[13:19:59.887]                             "SOCK0node"))) {
[13:19:59.887]                             sendCondition <<- function(cond) {
[13:19:59.887]                               data <- list(type = "VALUE", value = cond, 
[13:19:59.887]                                 success = TRUE)
[13:19:59.887]                               parallel_sendData(master, data)
[13:19:59.887]                             }
[13:19:59.887]                             return(sendCondition)
[13:19:59.887]                           }
[13:19:59.887]                         }
[13:19:59.887]                         frame <- frame + 1L
[13:19:59.887]                         envir <- sys.frame(frame)
[13:19:59.887]                       }
[13:19:59.887]                     }
[13:19:59.887]                     sendCondition <<- function(cond) NULL
[13:19:59.887]                   }
[13:19:59.887]                 })
[13:19:59.887]                 withCallingHandlers({
[13:19:59.887]                   {
[13:19:59.887]                     do.call(function(...) {
[13:19:59.887]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.887]                       if (!identical(...future.globals.maxSize.org, 
[13:19:59.887]                         ...future.globals.maxSize)) {
[13:19:59.887]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.887]                         on.exit(options(oopts), add = TRUE)
[13:19:59.887]                       }
[13:19:59.887]                       {
[13:19:59.887]                         lapply(seq_along(...future.elements_ii), 
[13:19:59.887]                           FUN = function(jj) {
[13:19:59.887]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.887]                             ...future.FUN(...future.X_jj, ...)
[13:19:59.887]                           })
[13:19:59.887]                       }
[13:19:59.887]                     }, args = future.call.arguments)
[13:19:59.887]                   }
[13:19:59.887]                 }, immediateCondition = function(cond) {
[13:19:59.887]                   sendCondition <- ...future.makeSendCondition()
[13:19:59.887]                   sendCondition(cond)
[13:19:59.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.887]                   {
[13:19:59.887]                     inherits <- base::inherits
[13:19:59.887]                     invokeRestart <- base::invokeRestart
[13:19:59.887]                     is.null <- base::is.null
[13:19:59.887]                     muffled <- FALSE
[13:19:59.887]                     if (inherits(cond, "message")) {
[13:19:59.887]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.887]                       if (muffled) 
[13:19:59.887]                         invokeRestart("muffleMessage")
[13:19:59.887]                     }
[13:19:59.887]                     else if (inherits(cond, "warning")) {
[13:19:59.887]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.887]                       if (muffled) 
[13:19:59.887]                         invokeRestart("muffleWarning")
[13:19:59.887]                     }
[13:19:59.887]                     else if (inherits(cond, "condition")) {
[13:19:59.887]                       if (!is.null(pattern)) {
[13:19:59.887]                         computeRestarts <- base::computeRestarts
[13:19:59.887]                         grepl <- base::grepl
[13:19:59.887]                         restarts <- computeRestarts(cond)
[13:19:59.887]                         for (restart in restarts) {
[13:19:59.887]                           name <- restart$name
[13:19:59.887]                           if (is.null(name)) 
[13:19:59.887]                             next
[13:19:59.887]                           if (!grepl(pattern, name)) 
[13:19:59.887]                             next
[13:19:59.887]                           invokeRestart(restart)
[13:19:59.887]                           muffled <- TRUE
[13:19:59.887]                           break
[13:19:59.887]                         }
[13:19:59.887]                       }
[13:19:59.887]                     }
[13:19:59.887]                     invisible(muffled)
[13:19:59.887]                   }
[13:19:59.887]                   muffleCondition(cond)
[13:19:59.887]                 })
[13:19:59.887]             }))
[13:19:59.887]             future::FutureResult(value = ...future.value$value, 
[13:19:59.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.887]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.887]                     ...future.globalenv.names))
[13:19:59.887]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.887]         }, condition = base::local({
[13:19:59.887]             c <- base::c
[13:19:59.887]             inherits <- base::inherits
[13:19:59.887]             invokeRestart <- base::invokeRestart
[13:19:59.887]             length <- base::length
[13:19:59.887]             list <- base::list
[13:19:59.887]             seq.int <- base::seq.int
[13:19:59.887]             signalCondition <- base::signalCondition
[13:19:59.887]             sys.calls <- base::sys.calls
[13:19:59.887]             `[[` <- base::`[[`
[13:19:59.887]             `+` <- base::`+`
[13:19:59.887]             `<<-` <- base::`<<-`
[13:19:59.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.887]                   3L)]
[13:19:59.887]             }
[13:19:59.887]             function(cond) {
[13:19:59.887]                 is_error <- inherits(cond, "error")
[13:19:59.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.887]                   NULL)
[13:19:59.887]                 if (is_error) {
[13:19:59.887]                   sessionInformation <- function() {
[13:19:59.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.887]                       search = base::search(), system = base::Sys.info())
[13:19:59.887]                   }
[13:19:59.887]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.887]                     cond$call), session = sessionInformation(), 
[13:19:59.887]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.887]                   signalCondition(cond)
[13:19:59.887]                 }
[13:19:59.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.887]                 "immediateCondition"))) {
[13:19:59.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.887]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.887]                   if (TRUE && !signal) {
[13:19:59.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.887]                     {
[13:19:59.887]                       inherits <- base::inherits
[13:19:59.887]                       invokeRestart <- base::invokeRestart
[13:19:59.887]                       is.null <- base::is.null
[13:19:59.887]                       muffled <- FALSE
[13:19:59.887]                       if (inherits(cond, "message")) {
[13:19:59.887]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.887]                         if (muffled) 
[13:19:59.887]                           invokeRestart("muffleMessage")
[13:19:59.887]                       }
[13:19:59.887]                       else if (inherits(cond, "warning")) {
[13:19:59.887]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.887]                         if (muffled) 
[13:19:59.887]                           invokeRestart("muffleWarning")
[13:19:59.887]                       }
[13:19:59.887]                       else if (inherits(cond, "condition")) {
[13:19:59.887]                         if (!is.null(pattern)) {
[13:19:59.887]                           computeRestarts <- base::computeRestarts
[13:19:59.887]                           grepl <- base::grepl
[13:19:59.887]                           restarts <- computeRestarts(cond)
[13:19:59.887]                           for (restart in restarts) {
[13:19:59.887]                             name <- restart$name
[13:19:59.887]                             if (is.null(name)) 
[13:19:59.887]                               next
[13:19:59.887]                             if (!grepl(pattern, name)) 
[13:19:59.887]                               next
[13:19:59.887]                             invokeRestart(restart)
[13:19:59.887]                             muffled <- TRUE
[13:19:59.887]                             break
[13:19:59.887]                           }
[13:19:59.887]                         }
[13:19:59.887]                       }
[13:19:59.887]                       invisible(muffled)
[13:19:59.887]                     }
[13:19:59.887]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.887]                   }
[13:19:59.887]                 }
[13:19:59.887]                 else {
[13:19:59.887]                   if (TRUE) {
[13:19:59.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.887]                     {
[13:19:59.887]                       inherits <- base::inherits
[13:19:59.887]                       invokeRestart <- base::invokeRestart
[13:19:59.887]                       is.null <- base::is.null
[13:19:59.887]                       muffled <- FALSE
[13:19:59.887]                       if (inherits(cond, "message")) {
[13:19:59.887]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.887]                         if (muffled) 
[13:19:59.887]                           invokeRestart("muffleMessage")
[13:19:59.887]                       }
[13:19:59.887]                       else if (inherits(cond, "warning")) {
[13:19:59.887]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.887]                         if (muffled) 
[13:19:59.887]                           invokeRestart("muffleWarning")
[13:19:59.887]                       }
[13:19:59.887]                       else if (inherits(cond, "condition")) {
[13:19:59.887]                         if (!is.null(pattern)) {
[13:19:59.887]                           computeRestarts <- base::computeRestarts
[13:19:59.887]                           grepl <- base::grepl
[13:19:59.887]                           restarts <- computeRestarts(cond)
[13:19:59.887]                           for (restart in restarts) {
[13:19:59.887]                             name <- restart$name
[13:19:59.887]                             if (is.null(name)) 
[13:19:59.887]                               next
[13:19:59.887]                             if (!grepl(pattern, name)) 
[13:19:59.887]                               next
[13:19:59.887]                             invokeRestart(restart)
[13:19:59.887]                             muffled <- TRUE
[13:19:59.887]                             break
[13:19:59.887]                           }
[13:19:59.887]                         }
[13:19:59.887]                       }
[13:19:59.887]                       invisible(muffled)
[13:19:59.887]                     }
[13:19:59.887]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.887]                   }
[13:19:59.887]                 }
[13:19:59.887]             }
[13:19:59.887]         }))
[13:19:59.887]     }, error = function(ex) {
[13:19:59.887]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.887]                 ...future.rng), started = ...future.startTime, 
[13:19:59.887]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.887]             version = "1.8"), class = "FutureResult")
[13:19:59.887]     }, finally = {
[13:19:59.887]         if (!identical(...future.workdir, getwd())) 
[13:19:59.887]             setwd(...future.workdir)
[13:19:59.887]         {
[13:19:59.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.887]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.887]             }
[13:19:59.887]             base::options(...future.oldOptions)
[13:19:59.887]             if (.Platform$OS.type == "windows") {
[13:19:59.887]                 old_names <- names(...future.oldEnvVars)
[13:19:59.887]                 envs <- base::Sys.getenv()
[13:19:59.887]                 names <- names(envs)
[13:19:59.887]                 common <- intersect(names, old_names)
[13:19:59.887]                 added <- setdiff(names, old_names)
[13:19:59.887]                 removed <- setdiff(old_names, names)
[13:19:59.887]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.887]                   envs[common]]
[13:19:59.887]                 NAMES <- toupper(changed)
[13:19:59.887]                 args <- list()
[13:19:59.887]                 for (kk in seq_along(NAMES)) {
[13:19:59.887]                   name <- changed[[kk]]
[13:19:59.887]                   NAME <- NAMES[[kk]]
[13:19:59.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.887]                     next
[13:19:59.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.887]                 }
[13:19:59.887]                 NAMES <- toupper(added)
[13:19:59.887]                 for (kk in seq_along(NAMES)) {
[13:19:59.887]                   name <- added[[kk]]
[13:19:59.887]                   NAME <- NAMES[[kk]]
[13:19:59.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.887]                     next
[13:19:59.887]                   args[[name]] <- ""
[13:19:59.887]                 }
[13:19:59.887]                 NAMES <- toupper(removed)
[13:19:59.887]                 for (kk in seq_along(NAMES)) {
[13:19:59.887]                   name <- removed[[kk]]
[13:19:59.887]                   NAME <- NAMES[[kk]]
[13:19:59.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.887]                     next
[13:19:59.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.887]                 }
[13:19:59.887]                 if (length(args) > 0) 
[13:19:59.887]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.887]             }
[13:19:59.887]             else {
[13:19:59.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.887]             }
[13:19:59.887]             {
[13:19:59.887]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.887]                   0L) {
[13:19:59.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.887]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.887]                   base::options(opts)
[13:19:59.887]                 }
[13:19:59.887]                 {
[13:19:59.887]                   {
[13:19:59.887]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.887]                     NULL
[13:19:59.887]                   }
[13:19:59.887]                   options(future.plan = NULL)
[13:19:59.887]                   if (is.na(NA_character_)) 
[13:19:59.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.887]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:59.887]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:59.887]                     envir = parent.frame()) 
[13:19:59.887]                   {
[13:19:59.887]                     if (is.function(workers)) 
[13:19:59.887]                       workers <- workers()
[13:19:59.887]                     workers <- structure(as.integer(workers), 
[13:19:59.887]                       class = class(workers))
[13:19:59.887]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:59.887]                       workers >= 1)
[13:19:59.887]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:59.887]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:59.887]                     }
[13:19:59.887]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:59.887]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:59.887]                       envir = envir)
[13:19:59.887]                     if (!future$lazy) 
[13:19:59.887]                       future <- run(future)
[13:19:59.887]                     invisible(future)
[13:19:59.887]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.887]                 }
[13:19:59.887]             }
[13:19:59.887]         }
[13:19:59.887]     })
[13:19:59.887]     if (TRUE) {
[13:19:59.887]         base::sink(type = "output", split = FALSE)
[13:19:59.887]         if (TRUE) {
[13:19:59.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.887]         }
[13:19:59.887]         else {
[13:19:59.887]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.887]         }
[13:19:59.887]         base::close(...future.stdout)
[13:19:59.887]         ...future.stdout <- NULL
[13:19:59.887]     }
[13:19:59.887]     ...future.result$conditions <- ...future.conditions
[13:19:59.887]     ...future.result$finished <- base::Sys.time()
[13:19:59.887]     ...future.result
[13:19:59.887] }
[13:19:59.891] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[13:19:59.891] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:59.891] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:59.891] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[13:19:59.932] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[13:19:59.933] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[13:19:59.933] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[13:19:59.933] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:59.934] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:59.934] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:19:59.934] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:19:59.934] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[13:19:59.935] MultisessionFuture started
[13:19:59.935] - Launch lazy future ... done
[13:19:59.935] run() for ‘MultisessionFuture’ ... done
[13:19:59.935] Created future:
[13:19:59.935] MultisessionFuture:
[13:19:59.935] Label: ‘future_apply-2’
[13:19:59.935] Expression:
[13:19:59.935] {
[13:19:59.935]     do.call(function(...) {
[13:19:59.935]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:59.935]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:59.935]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:59.935]             on.exit(options(oopts), add = TRUE)
[13:19:59.935]         }
[13:19:59.935]         {
[13:19:59.935]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:59.935]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:59.935]                 ...future.FUN(...future.X_jj, ...)
[13:19:59.935]             })
[13:19:59.935]         }
[13:19:59.935]     }, args = future.call.arguments)
[13:19:59.935] }
[13:19:59.935] Lazy evaluation: FALSE
[13:19:59.935] Asynchronous evaluation: TRUE
[13:19:59.935] Local evaluation: TRUE
[13:19:59.935] Environment: R_GlobalEnv
[13:19:59.935] Capture standard output: TRUE
[13:19:59.935] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:59.935] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:19:59.935] Packages: <none>
[13:19:59.935] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:59.935] Resolved: FALSE
[13:19:59.935] Value: <not collected>
[13:19:59.935] Conditions captured: <none>
[13:19:59.935] Early signaling: FALSE
[13:19:59.935] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:19:59.935] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.947] Chunk #2 of 2 ... DONE
[13:19:59.947] Launching 2 futures (chunks) ... DONE
[13:19:59.947] Resolving 2 futures (chunks) ...
[13:19:59.947] resolve() on list ...
[13:19:59.947]  recursive: 0
[13:19:59.948]  length: 2
[13:19:59.948] 
[13:19:59.948] receiveMessageFromWorker() for ClusterFuture ...
[13:19:59.948] - Validating connection of MultisessionFuture
[13:19:59.949] - received message: FutureResult
[13:19:59.949] - Received FutureResult
[13:19:59.949] - Erased future from FutureRegistry
[13:19:59.949] result() for ClusterFuture ...
[13:19:59.949] - result already collected: FutureResult
[13:19:59.949] result() for ClusterFuture ... done
[13:19:59.949] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:59.949] Future #1
[13:19:59.949] result() for ClusterFuture ...
[13:19:59.950] - result already collected: FutureResult
[13:19:59.950] result() for ClusterFuture ... done
[13:19:59.950] result() for ClusterFuture ...
[13:19:59.950] - result already collected: FutureResult
[13:19:59.950] result() for ClusterFuture ... done
[13:19:59.950] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:59.950] - nx: 2
[13:19:59.950] - relay: TRUE
[13:19:59.950] - stdout: TRUE
[13:19:59.950] - signal: TRUE
[13:19:59.950] - resignal: FALSE
[13:19:59.951] - force: TRUE
[13:19:59.951] - relayed: [n=2] FALSE, FALSE
[13:19:59.951] - queued futures: [n=2] FALSE, FALSE
[13:19:59.951]  - until=1
[13:19:59.951]  - relaying element #1
[13:19:59.951] result() for ClusterFuture ...
[13:19:59.951] - result already collected: FutureResult
[13:19:59.951] result() for ClusterFuture ... done
[13:19:59.951] result() for ClusterFuture ...
[13:19:59.951] - result already collected: FutureResult
[13:19:59.951] result() for ClusterFuture ... done
[13:19:59.952] result() for ClusterFuture ...
[13:19:59.952] - result already collected: FutureResult
[13:19:59.952] result() for ClusterFuture ... done
[13:19:59.954] result() for ClusterFuture ...
[13:19:59.954] - result already collected: FutureResult
[13:19:59.954] result() for ClusterFuture ... done
[13:19:59.954] - relayed: [n=2] TRUE, FALSE
[13:19:59.954] - queued futures: [n=2] TRUE, FALSE
[13:19:59.954] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:59.954]  length: 1 (resolved future 1)
[13:19:59.981] receiveMessageFromWorker() for ClusterFuture ...
[13:19:59.981] - Validating connection of MultisessionFuture
[13:19:59.981] - received message: FutureResult
[13:19:59.982] - Received FutureResult
[13:19:59.982] - Erased future from FutureRegistry
[13:19:59.982] result() for ClusterFuture ...
[13:19:59.982] - result already collected: FutureResult
[13:19:59.982] result() for ClusterFuture ... done
[13:19:59.982] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:59.982] Future #2
[13:19:59.982] result() for ClusterFuture ...
[13:19:59.982] - result already collected: FutureResult
[13:19:59.982] result() for ClusterFuture ... done
[13:19:59.982] result() for ClusterFuture ...
[13:19:59.983] - result already collected: FutureResult
[13:19:59.983] result() for ClusterFuture ... done
[13:19:59.983] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:59.983] - nx: 2
[13:19:59.983] - relay: TRUE
[13:19:59.983] - stdout: TRUE
[13:19:59.983] - signal: TRUE
[13:19:59.983] - resignal: FALSE
[13:19:59.983] - force: TRUE
[13:19:59.983] - relayed: [n=2] TRUE, FALSE
[13:19:59.983] - queued futures: [n=2] TRUE, FALSE
[13:19:59.983]  - until=2
[13:19:59.984]  - relaying element #2
[13:19:59.984] result() for ClusterFuture ...
[13:19:59.984] - result already collected: FutureResult
[13:19:59.984] result() for ClusterFuture ... done
[13:19:59.984] result() for ClusterFuture ...
[13:19:59.984] - result already collected: FutureResult
[13:19:59.984] result() for ClusterFuture ... done
[13:19:59.984] result() for ClusterFuture ...
[13:19:59.984] - result already collected: FutureResult
[13:19:59.984] result() for ClusterFuture ... done
[13:19:59.985] result() for ClusterFuture ...
[13:19:59.985] - result already collected: FutureResult
[13:19:59.985] result() for ClusterFuture ... done
[13:19:59.985] - relayed: [n=2] TRUE, TRUE
[13:19:59.985] - queued futures: [n=2] TRUE, TRUE
[13:19:59.985] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:59.985]  length: 0 (resolved future 2)
[13:19:59.985] Relaying remaining futures
[13:19:59.985] signalConditionsASAP(NULL, pos=0) ...
[13:19:59.985] - nx: 2
[13:19:59.985] - relay: TRUE
[13:19:59.985] - stdout: TRUE
[13:19:59.986] - signal: TRUE
[13:19:59.986] - resignal: FALSE
[13:19:59.986] - force: TRUE
[13:19:59.986] - relayed: [n=2] TRUE, TRUE
[13:19:59.986] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:59.986] - relayed: [n=2] TRUE, TRUE
[13:19:59.986] - queued futures: [n=2] TRUE, TRUE
[13:19:59.986] signalConditionsASAP(NULL, pos=0) ... done
[13:19:59.986] resolve() on list ... DONE
[13:19:59.986] result() for ClusterFuture ...
[13:19:59.986] - result already collected: FutureResult
[13:19:59.987] result() for ClusterFuture ... done
[13:19:59.987] result() for ClusterFuture ...
[13:19:59.987] - result already collected: FutureResult
[13:19:59.987] result() for ClusterFuture ... done
[13:19:59.987] result() for ClusterFuture ...
[13:19:59.987] - result already collected: FutureResult
[13:19:59.987] result() for ClusterFuture ... done
[13:19:59.987] result() for ClusterFuture ...
[13:19:59.987] - result already collected: FutureResult
[13:19:59.987] result() for ClusterFuture ... done
[13:19:59.987]  - Number of value chunks collected: 2
[13:19:59.988] Resolving 2 futures (chunks) ... DONE
[13:19:59.988] Reducing values from 2 chunks ...
[13:19:59.988]  - Number of values collected after concatenation: 2
[13:19:59.988]  - Number of values expected: 2
[13:19:59.988] Reducing values from 2 chunks ... DONE
[13:19:59.988] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:19:59.989] getGlobalsAndPackagesXApply() ...
[13:19:59.989]  - future.globals: TRUE
[13:19:59.989] getGlobalsAndPackages() ...
[13:19:59.989] Searching for globals...
[13:19:59.990] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:19:59.990] Searching for globals ... DONE
[13:19:59.991] Resolving globals: FALSE
[13:19:59.991] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:19:59.991] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:19:59.991] - globals: [1] ‘FUN’
[13:19:59.992] - packages: [1] ‘stats’
[13:19:59.992] getGlobalsAndPackages() ... DONE
[13:19:59.992]  - globals found/used: [n=1] ‘FUN’
[13:19:59.992]  - needed namespaces: [n=1] ‘stats’
[13:19:59.992] Finding globals ... DONE
[13:19:59.992]  - use_args: TRUE
[13:19:59.992]  - Getting '...' globals ...
[13:19:59.993] resolve() on list ...
[13:19:59.993]  recursive: 0
[13:19:59.993]  length: 1
[13:19:59.993]  elements: ‘...’
[13:19:59.993]  length: 0 (resolved future 1)
[13:19:59.993] resolve() on list ... DONE
[13:19:59.993]    - '...' content: [n=0] 
[13:19:59.993] List of 1
[13:19:59.993]  $ ...: list()
[13:19:59.993]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:59.993]  - attr(*, "where")=List of 1
[13:19:59.993]   ..$ ...:<environment: 0x555922b70f58> 
[13:19:59.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.993]  - attr(*, "resolved")= logi TRUE
[13:19:59.993]  - attr(*, "total_size")= num NA
[13:19:59.996]  - Getting '...' globals ... DONE
[13:19:59.996] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:59.996] List of 2
[13:19:59.996]  $ ...future.FUN:function (x, ...)  
[13:19:59.996]  $ ...          : list()
[13:19:59.996]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:59.996]  - attr(*, "where")=List of 2
[13:19:59.996]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:59.996]   ..$ ...          :<environment: 0x555922b70f58> 
[13:19:59.996]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.996]  - attr(*, "resolved")= logi FALSE
[13:19:59.996]  - attr(*, "total_size")= num 1248
[13:19:59.999] Packages to be attached in all futures: [n=1] ‘stats’
[13:19:59.999] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.003] future_lapply() ...
[13:20:00.006] Number of chunks: 2
[13:20:00.007] getGlobalsAndPackagesXApply() ...
[13:20:00.007]  - future.globals: <name-value list> with names ‘list()’
[13:20:00.007]  - use_args: TRUE
[13:20:00.007] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:20:00.007] List of 2
[13:20:00.007]  $ ...          : list()
[13:20:00.007]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.007]  $ ...future.FUN:function (x, ...)  
[13:20:00.007]  - attr(*, "where")=List of 2
[13:20:00.007]   ..$ ...          :<environment: 0x555922b70f58> 
[13:20:00.007]   ..$ ...future.FUN:<environment: namespace:stats> 
[13:20:00.007]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.007]  - attr(*, "resolved")= logi FALSE
[13:20:00.007]  - attr(*, "total_size")= num NA
[13:20:00.010] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:00.010] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.010] Number of futures (= number of chunks): 2
[13:20:00.011] Launching 2 futures (chunks) ...
[13:20:00.011] Chunk #1 of 2 ...
[13:20:00.011]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.011]  - seeds: <none>
[13:20:00.011]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.011] getGlobalsAndPackages() ...
[13:20:00.011] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.011] Resolving globals: FALSE
[13:20:00.011] Tweak future expression to call with '...' arguments ...
[13:20:00.012] {
[13:20:00.012]     do.call(function(...) {
[13:20:00.012]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.012]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.012]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.012]             on.exit(options(oopts), add = TRUE)
[13:20:00.012]         }
[13:20:00.012]         {
[13:20:00.012]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.012]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.012]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.012]             })
[13:20:00.012]         }
[13:20:00.012]     }, args = future.call.arguments)
[13:20:00.012] }
[13:20:00.012] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.012] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.012] - packages: [1] ‘stats’
[13:20:00.013] getGlobalsAndPackages() ... DONE
[13:20:00.013] run() for ‘Future’ ...
[13:20:00.013] - state: ‘created’
[13:20:00.013] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.027] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.027]   - Field: ‘node’
[13:20:00.027]   - Field: ‘label’
[13:20:00.027]   - Field: ‘local’
[13:20:00.027]   - Field: ‘owner’
[13:20:00.028]   - Field: ‘envir’
[13:20:00.028]   - Field: ‘workers’
[13:20:00.028]   - Field: ‘packages’
[13:20:00.028]   - Field: ‘gc’
[13:20:00.028]   - Field: ‘conditions’
[13:20:00.028]   - Field: ‘persistent’
[13:20:00.028]   - Field: ‘expr’
[13:20:00.028]   - Field: ‘uuid’
[13:20:00.028]   - Field: ‘seed’
[13:20:00.028]   - Field: ‘version’
[13:20:00.029]   - Field: ‘result’
[13:20:00.029]   - Field: ‘asynchronous’
[13:20:00.029]   - Field: ‘calls’
[13:20:00.029]   - Field: ‘globals’
[13:20:00.029]   - Field: ‘stdout’
[13:20:00.029]   - Field: ‘earlySignal’
[13:20:00.029]   - Field: ‘lazy’
[13:20:00.029]   - Field: ‘state’
[13:20:00.029] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.029] - Launch lazy future ...
[13:20:00.030] Packages needed by the future expression (n = 1): ‘stats’
[13:20:00.030] Packages needed by future strategies (n = 0): <none>
[13:20:00.030] {
[13:20:00.030]     {
[13:20:00.030]         {
[13:20:00.030]             ...future.startTime <- base::Sys.time()
[13:20:00.030]             {
[13:20:00.030]                 {
[13:20:00.030]                   {
[13:20:00.030]                     {
[13:20:00.030]                       {
[13:20:00.030]                         base::local({
[13:20:00.030]                           has_future <- base::requireNamespace("future", 
[13:20:00.030]                             quietly = TRUE)
[13:20:00.030]                           if (has_future) {
[13:20:00.030]                             ns <- base::getNamespace("future")
[13:20:00.030]                             version <- ns[[".package"]][["version"]]
[13:20:00.030]                             if (is.null(version)) 
[13:20:00.030]                               version <- utils::packageVersion("future")
[13:20:00.030]                           }
[13:20:00.030]                           else {
[13:20:00.030]                             version <- NULL
[13:20:00.030]                           }
[13:20:00.030]                           if (!has_future || version < "1.8.0") {
[13:20:00.030]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.030]                               "", base::R.version$version.string), 
[13:20:00.030]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:00.030]                                 base::R.version$platform, 8 * 
[13:20:00.030]                                   base::.Machine$sizeof.pointer), 
[13:20:00.030]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.030]                                 "release", "version")], collapse = " "), 
[13:20:00.030]                               hostname = base::Sys.info()[["nodename"]])
[13:20:00.030]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.030]                               info)
[13:20:00.030]                             info <- base::paste(info, collapse = "; ")
[13:20:00.030]                             if (!has_future) {
[13:20:00.030]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.030]                                 info)
[13:20:00.030]                             }
[13:20:00.030]                             else {
[13:20:00.030]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.030]                                 info, version)
[13:20:00.030]                             }
[13:20:00.030]                             base::stop(msg)
[13:20:00.030]                           }
[13:20:00.030]                         })
[13:20:00.030]                       }
[13:20:00.030]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.030]                       base::options(mc.cores = 1L)
[13:20:00.030]                     }
[13:20:00.030]                     base::local({
[13:20:00.030]                       for (pkg in "stats") {
[13:20:00.030]                         base::loadNamespace(pkg)
[13:20:00.030]                         base::library(pkg, character.only = TRUE)
[13:20:00.030]                       }
[13:20:00.030]                     })
[13:20:00.030]                   }
[13:20:00.030]                   options(future.plan = NULL)
[13:20:00.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.030]                 }
[13:20:00.030]                 ...future.workdir <- getwd()
[13:20:00.030]             }
[13:20:00.030]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.030]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.030]         }
[13:20:00.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.030]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.030]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.030]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.030]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.030]             base::names(...future.oldOptions))
[13:20:00.030]     }
[13:20:00.030]     if (FALSE) {
[13:20:00.030]     }
[13:20:00.030]     else {
[13:20:00.030]         if (TRUE) {
[13:20:00.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.030]                 open = "w")
[13:20:00.030]         }
[13:20:00.030]         else {
[13:20:00.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.030]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.030]         }
[13:20:00.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.030]             base::sink(type = "output", split = FALSE)
[13:20:00.030]             base::close(...future.stdout)
[13:20:00.030]         }, add = TRUE)
[13:20:00.030]     }
[13:20:00.030]     ...future.frame <- base::sys.nframe()
[13:20:00.030]     ...future.conditions <- base::list()
[13:20:00.030]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.030]     if (FALSE) {
[13:20:00.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.030]     }
[13:20:00.030]     ...future.result <- base::tryCatch({
[13:20:00.030]         base::withCallingHandlers({
[13:20:00.030]             ...future.value <- base::withVisible(base::local({
[13:20:00.030]                 ...future.makeSendCondition <- base::local({
[13:20:00.030]                   sendCondition <- NULL
[13:20:00.030]                   function(frame = 1L) {
[13:20:00.030]                     if (is.function(sendCondition)) 
[13:20:00.030]                       return(sendCondition)
[13:20:00.030]                     ns <- getNamespace("parallel")
[13:20:00.030]                     if (exists("sendData", mode = "function", 
[13:20:00.030]                       envir = ns)) {
[13:20:00.030]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.030]                         envir = ns)
[13:20:00.030]                       envir <- sys.frame(frame)
[13:20:00.030]                       master <- NULL
[13:20:00.030]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.030]                         !identical(envir, emptyenv())) {
[13:20:00.030]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.030]                           inherits = FALSE)) {
[13:20:00.030]                           master <- get("master", mode = "list", 
[13:20:00.030]                             envir = envir, inherits = FALSE)
[13:20:00.030]                           if (inherits(master, c("SOCKnode", 
[13:20:00.030]                             "SOCK0node"))) {
[13:20:00.030]                             sendCondition <<- function(cond) {
[13:20:00.030]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.030]                                 success = TRUE)
[13:20:00.030]                               parallel_sendData(master, data)
[13:20:00.030]                             }
[13:20:00.030]                             return(sendCondition)
[13:20:00.030]                           }
[13:20:00.030]                         }
[13:20:00.030]                         frame <- frame + 1L
[13:20:00.030]                         envir <- sys.frame(frame)
[13:20:00.030]                       }
[13:20:00.030]                     }
[13:20:00.030]                     sendCondition <<- function(cond) NULL
[13:20:00.030]                   }
[13:20:00.030]                 })
[13:20:00.030]                 withCallingHandlers({
[13:20:00.030]                   {
[13:20:00.030]                     do.call(function(...) {
[13:20:00.030]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.030]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.030]                         ...future.globals.maxSize)) {
[13:20:00.030]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.030]                         on.exit(options(oopts), add = TRUE)
[13:20:00.030]                       }
[13:20:00.030]                       {
[13:20:00.030]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.030]                           FUN = function(jj) {
[13:20:00.030]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.030]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.030]                           })
[13:20:00.030]                       }
[13:20:00.030]                     }, args = future.call.arguments)
[13:20:00.030]                   }
[13:20:00.030]                 }, immediateCondition = function(cond) {
[13:20:00.030]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.030]                   sendCondition(cond)
[13:20:00.030]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.030]                   {
[13:20:00.030]                     inherits <- base::inherits
[13:20:00.030]                     invokeRestart <- base::invokeRestart
[13:20:00.030]                     is.null <- base::is.null
[13:20:00.030]                     muffled <- FALSE
[13:20:00.030]                     if (inherits(cond, "message")) {
[13:20:00.030]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.030]                       if (muffled) 
[13:20:00.030]                         invokeRestart("muffleMessage")
[13:20:00.030]                     }
[13:20:00.030]                     else if (inherits(cond, "warning")) {
[13:20:00.030]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.030]                       if (muffled) 
[13:20:00.030]                         invokeRestart("muffleWarning")
[13:20:00.030]                     }
[13:20:00.030]                     else if (inherits(cond, "condition")) {
[13:20:00.030]                       if (!is.null(pattern)) {
[13:20:00.030]                         computeRestarts <- base::computeRestarts
[13:20:00.030]                         grepl <- base::grepl
[13:20:00.030]                         restarts <- computeRestarts(cond)
[13:20:00.030]                         for (restart in restarts) {
[13:20:00.030]                           name <- restart$name
[13:20:00.030]                           if (is.null(name)) 
[13:20:00.030]                             next
[13:20:00.030]                           if (!grepl(pattern, name)) 
[13:20:00.030]                             next
[13:20:00.030]                           invokeRestart(restart)
[13:20:00.030]                           muffled <- TRUE
[13:20:00.030]                           break
[13:20:00.030]                         }
[13:20:00.030]                       }
[13:20:00.030]                     }
[13:20:00.030]                     invisible(muffled)
[13:20:00.030]                   }
[13:20:00.030]                   muffleCondition(cond)
[13:20:00.030]                 })
[13:20:00.030]             }))
[13:20:00.030]             future::FutureResult(value = ...future.value$value, 
[13:20:00.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.030]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.030]                     ...future.globalenv.names))
[13:20:00.030]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.030]         }, condition = base::local({
[13:20:00.030]             c <- base::c
[13:20:00.030]             inherits <- base::inherits
[13:20:00.030]             invokeRestart <- base::invokeRestart
[13:20:00.030]             length <- base::length
[13:20:00.030]             list <- base::list
[13:20:00.030]             seq.int <- base::seq.int
[13:20:00.030]             signalCondition <- base::signalCondition
[13:20:00.030]             sys.calls <- base::sys.calls
[13:20:00.030]             `[[` <- base::`[[`
[13:20:00.030]             `+` <- base::`+`
[13:20:00.030]             `<<-` <- base::`<<-`
[13:20:00.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.030]                   3L)]
[13:20:00.030]             }
[13:20:00.030]             function(cond) {
[13:20:00.030]                 is_error <- inherits(cond, "error")
[13:20:00.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.030]                   NULL)
[13:20:00.030]                 if (is_error) {
[13:20:00.030]                   sessionInformation <- function() {
[13:20:00.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.030]                       search = base::search(), system = base::Sys.info())
[13:20:00.030]                   }
[13:20:00.030]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.030]                     cond$call), session = sessionInformation(), 
[13:20:00.030]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.030]                   signalCondition(cond)
[13:20:00.030]                 }
[13:20:00.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.030]                 "immediateCondition"))) {
[13:20:00.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.030]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.030]                   if (TRUE && !signal) {
[13:20:00.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.030]                     {
[13:20:00.030]                       inherits <- base::inherits
[13:20:00.030]                       invokeRestart <- base::invokeRestart
[13:20:00.030]                       is.null <- base::is.null
[13:20:00.030]                       muffled <- FALSE
[13:20:00.030]                       if (inherits(cond, "message")) {
[13:20:00.030]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.030]                         if (muffled) 
[13:20:00.030]                           invokeRestart("muffleMessage")
[13:20:00.030]                       }
[13:20:00.030]                       else if (inherits(cond, "warning")) {
[13:20:00.030]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.030]                         if (muffled) 
[13:20:00.030]                           invokeRestart("muffleWarning")
[13:20:00.030]                       }
[13:20:00.030]                       else if (inherits(cond, "condition")) {
[13:20:00.030]                         if (!is.null(pattern)) {
[13:20:00.030]                           computeRestarts <- base::computeRestarts
[13:20:00.030]                           grepl <- base::grepl
[13:20:00.030]                           restarts <- computeRestarts(cond)
[13:20:00.030]                           for (restart in restarts) {
[13:20:00.030]                             name <- restart$name
[13:20:00.030]                             if (is.null(name)) 
[13:20:00.030]                               next
[13:20:00.030]                             if (!grepl(pattern, name)) 
[13:20:00.030]                               next
[13:20:00.030]                             invokeRestart(restart)
[13:20:00.030]                             muffled <- TRUE
[13:20:00.030]                             break
[13:20:00.030]                           }
[13:20:00.030]                         }
[13:20:00.030]                       }
[13:20:00.030]                       invisible(muffled)
[13:20:00.030]                     }
[13:20:00.030]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.030]                   }
[13:20:00.030]                 }
[13:20:00.030]                 else {
[13:20:00.030]                   if (TRUE) {
[13:20:00.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.030]                     {
[13:20:00.030]                       inherits <- base::inherits
[13:20:00.030]                       invokeRestart <- base::invokeRestart
[13:20:00.030]                       is.null <- base::is.null
[13:20:00.030]                       muffled <- FALSE
[13:20:00.030]                       if (inherits(cond, "message")) {
[13:20:00.030]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.030]                         if (muffled) 
[13:20:00.030]                           invokeRestart("muffleMessage")
[13:20:00.030]                       }
[13:20:00.030]                       else if (inherits(cond, "warning")) {
[13:20:00.030]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.030]                         if (muffled) 
[13:20:00.030]                           invokeRestart("muffleWarning")
[13:20:00.030]                       }
[13:20:00.030]                       else if (inherits(cond, "condition")) {
[13:20:00.030]                         if (!is.null(pattern)) {
[13:20:00.030]                           computeRestarts <- base::computeRestarts
[13:20:00.030]                           grepl <- base::grepl
[13:20:00.030]                           restarts <- computeRestarts(cond)
[13:20:00.030]                           for (restart in restarts) {
[13:20:00.030]                             name <- restart$name
[13:20:00.030]                             if (is.null(name)) 
[13:20:00.030]                               next
[13:20:00.030]                             if (!grepl(pattern, name)) 
[13:20:00.030]                               next
[13:20:00.030]                             invokeRestart(restart)
[13:20:00.030]                             muffled <- TRUE
[13:20:00.030]                             break
[13:20:00.030]                           }
[13:20:00.030]                         }
[13:20:00.030]                       }
[13:20:00.030]                       invisible(muffled)
[13:20:00.030]                     }
[13:20:00.030]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.030]                   }
[13:20:00.030]                 }
[13:20:00.030]             }
[13:20:00.030]         }))
[13:20:00.030]     }, error = function(ex) {
[13:20:00.030]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.030]                 ...future.rng), started = ...future.startTime, 
[13:20:00.030]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.030]             version = "1.8"), class = "FutureResult")
[13:20:00.030]     }, finally = {
[13:20:00.030]         if (!identical(...future.workdir, getwd())) 
[13:20:00.030]             setwd(...future.workdir)
[13:20:00.030]         {
[13:20:00.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.030]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.030]             }
[13:20:00.030]             base::options(...future.oldOptions)
[13:20:00.030]             if (.Platform$OS.type == "windows") {
[13:20:00.030]                 old_names <- names(...future.oldEnvVars)
[13:20:00.030]                 envs <- base::Sys.getenv()
[13:20:00.030]                 names <- names(envs)
[13:20:00.030]                 common <- intersect(names, old_names)
[13:20:00.030]                 added <- setdiff(names, old_names)
[13:20:00.030]                 removed <- setdiff(old_names, names)
[13:20:00.030]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.030]                   envs[common]]
[13:20:00.030]                 NAMES <- toupper(changed)
[13:20:00.030]                 args <- list()
[13:20:00.030]                 for (kk in seq_along(NAMES)) {
[13:20:00.030]                   name <- changed[[kk]]
[13:20:00.030]                   NAME <- NAMES[[kk]]
[13:20:00.030]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.030]                     next
[13:20:00.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.030]                 }
[13:20:00.030]                 NAMES <- toupper(added)
[13:20:00.030]                 for (kk in seq_along(NAMES)) {
[13:20:00.030]                   name <- added[[kk]]
[13:20:00.030]                   NAME <- NAMES[[kk]]
[13:20:00.030]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.030]                     next
[13:20:00.030]                   args[[name]] <- ""
[13:20:00.030]                 }
[13:20:00.030]                 NAMES <- toupper(removed)
[13:20:00.030]                 for (kk in seq_along(NAMES)) {
[13:20:00.030]                   name <- removed[[kk]]
[13:20:00.030]                   NAME <- NAMES[[kk]]
[13:20:00.030]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.030]                     next
[13:20:00.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.030]                 }
[13:20:00.030]                 if (length(args) > 0) 
[13:20:00.030]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.030]             }
[13:20:00.030]             else {
[13:20:00.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.030]             }
[13:20:00.030]             {
[13:20:00.030]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.030]                   0L) {
[13:20:00.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.030]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.030]                   base::options(opts)
[13:20:00.030]                 }
[13:20:00.030]                 {
[13:20:00.030]                   {
[13:20:00.030]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.030]                     NULL
[13:20:00.030]                   }
[13:20:00.030]                   options(future.plan = NULL)
[13:20:00.030]                   if (is.na(NA_character_)) 
[13:20:00.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.030]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.030]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.030]                     envir = parent.frame()) 
[13:20:00.030]                   {
[13:20:00.030]                     if (is.function(workers)) 
[13:20:00.030]                       workers <- workers()
[13:20:00.030]                     workers <- structure(as.integer(workers), 
[13:20:00.030]                       class = class(workers))
[13:20:00.030]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.030]                       workers >= 1)
[13:20:00.030]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.030]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.030]                     }
[13:20:00.030]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.030]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.030]                       envir = envir)
[13:20:00.030]                     if (!future$lazy) 
[13:20:00.030]                       future <- run(future)
[13:20:00.030]                     invisible(future)
[13:20:00.030]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.030]                 }
[13:20:00.030]             }
[13:20:00.030]         }
[13:20:00.030]     })
[13:20:00.030]     if (TRUE) {
[13:20:00.030]         base::sink(type = "output", split = FALSE)
[13:20:00.030]         if (TRUE) {
[13:20:00.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.030]         }
[13:20:00.030]         else {
[13:20:00.030]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.030]         }
[13:20:00.030]         base::close(...future.stdout)
[13:20:00.030]         ...future.stdout <- NULL
[13:20:00.030]     }
[13:20:00.030]     ...future.result$conditions <- ...future.conditions
[13:20:00.030]     ...future.result$finished <- base::Sys.time()
[13:20:00.030]     ...future.result
[13:20:00.030] }
[13:20:00.034] Exporting 5 global objects (1.35 KiB) to cluster node #1 ...
[13:20:00.034] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:00.034] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.034] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:20:00.035] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:20:00.035] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[13:20:00.035] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[13:20:00.035] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:00.036] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.036] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:20:00.036] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.036] Exporting 5 global objects (1.35 KiB) to cluster node #1 ... DONE
[13:20:00.037] MultisessionFuture started
[13:20:00.037] - Launch lazy future ... done
[13:20:00.037] run() for ‘MultisessionFuture’ ... done
[13:20:00.038] Created future:
[13:20:00.038] MultisessionFuture:
[13:20:00.038] Label: ‘future_apply-1’
[13:20:00.038] Expression:
[13:20:00.038] {
[13:20:00.038]     do.call(function(...) {
[13:20:00.038]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.038]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.038]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.038]             on.exit(options(oopts), add = TRUE)
[13:20:00.038]         }
[13:20:00.038]         {
[13:20:00.038]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.038]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.038]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.038]             })
[13:20:00.038]         }
[13:20:00.038]     }, args = future.call.arguments)
[13:20:00.038] }
[13:20:00.038] Lazy evaluation: FALSE
[13:20:00.038] Asynchronous evaluation: TRUE
[13:20:00.038] Local evaluation: TRUE
[13:20:00.038] Environment: R_GlobalEnv
[13:20:00.038] Capture standard output: TRUE
[13:20:00.038] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.038] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.038] Packages: 1 packages (‘stats’)
[13:20:00.038] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.038] Resolved: FALSE
[13:20:00.038] Value: <not collected>
[13:20:00.038] Conditions captured: <none>
[13:20:00.038] Early signaling: FALSE
[13:20:00.038] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.038] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.049] Chunk #1 of 2 ... DONE
[13:20:00.049] Chunk #2 of 2 ...
[13:20:00.050]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.050]  - seeds: <none>
[13:20:00.050]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.050] getGlobalsAndPackages() ...
[13:20:00.050] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.050] Resolving globals: FALSE
[13:20:00.050] Tweak future expression to call with '...' arguments ...
[13:20:00.050] {
[13:20:00.050]     do.call(function(...) {
[13:20:00.050]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.050]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.050]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.050]             on.exit(options(oopts), add = TRUE)
[13:20:00.050]         }
[13:20:00.050]         {
[13:20:00.050]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.050]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.050]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.050]             })
[13:20:00.050]         }
[13:20:00.050]     }, args = future.call.arguments)
[13:20:00.050] }
[13:20:00.051] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.051] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.051] - packages: [1] ‘stats’
[13:20:00.051] getGlobalsAndPackages() ... DONE
[13:20:00.052] run() for ‘Future’ ...
[13:20:00.052] - state: ‘created’
[13:20:00.052] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.066] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.066] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.066]   - Field: ‘node’
[13:20:00.066]   - Field: ‘label’
[13:20:00.066]   - Field: ‘local’
[13:20:00.066]   - Field: ‘owner’
[13:20:00.066]   - Field: ‘envir’
[13:20:00.066]   - Field: ‘workers’
[13:20:00.066]   - Field: ‘packages’
[13:20:00.067]   - Field: ‘gc’
[13:20:00.067]   - Field: ‘conditions’
[13:20:00.067]   - Field: ‘persistent’
[13:20:00.067]   - Field: ‘expr’
[13:20:00.067]   - Field: ‘uuid’
[13:20:00.067]   - Field: ‘seed’
[13:20:00.067]   - Field: ‘version’
[13:20:00.067]   - Field: ‘result’
[13:20:00.067]   - Field: ‘asynchronous’
[13:20:00.067]   - Field: ‘calls’
[13:20:00.067]   - Field: ‘globals’
[13:20:00.068]   - Field: ‘stdout’
[13:20:00.068]   - Field: ‘earlySignal’
[13:20:00.068]   - Field: ‘lazy’
[13:20:00.068]   - Field: ‘state’
[13:20:00.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.068] - Launch lazy future ...
[13:20:00.068] Packages needed by the future expression (n = 1): ‘stats’
[13:20:00.069] Packages needed by future strategies (n = 0): <none>
[13:20:00.069] {
[13:20:00.069]     {
[13:20:00.069]         {
[13:20:00.069]             ...future.startTime <- base::Sys.time()
[13:20:00.069]             {
[13:20:00.069]                 {
[13:20:00.069]                   {
[13:20:00.069]                     {
[13:20:00.069]                       {
[13:20:00.069]                         base::local({
[13:20:00.069]                           has_future <- base::requireNamespace("future", 
[13:20:00.069]                             quietly = TRUE)
[13:20:00.069]                           if (has_future) {
[13:20:00.069]                             ns <- base::getNamespace("future")
[13:20:00.069]                             version <- ns[[".package"]][["version"]]
[13:20:00.069]                             if (is.null(version)) 
[13:20:00.069]                               version <- utils::packageVersion("future")
[13:20:00.069]                           }
[13:20:00.069]                           else {
[13:20:00.069]                             version <- NULL
[13:20:00.069]                           }
[13:20:00.069]                           if (!has_future || version < "1.8.0") {
[13:20:00.069]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.069]                               "", base::R.version$version.string), 
[13:20:00.069]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:00.069]                                 base::R.version$platform, 8 * 
[13:20:00.069]                                   base::.Machine$sizeof.pointer), 
[13:20:00.069]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.069]                                 "release", "version")], collapse = " "), 
[13:20:00.069]                               hostname = base::Sys.info()[["nodename"]])
[13:20:00.069]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.069]                               info)
[13:20:00.069]                             info <- base::paste(info, collapse = "; ")
[13:20:00.069]                             if (!has_future) {
[13:20:00.069]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.069]                                 info)
[13:20:00.069]                             }
[13:20:00.069]                             else {
[13:20:00.069]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.069]                                 info, version)
[13:20:00.069]                             }
[13:20:00.069]                             base::stop(msg)
[13:20:00.069]                           }
[13:20:00.069]                         })
[13:20:00.069]                       }
[13:20:00.069]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.069]                       base::options(mc.cores = 1L)
[13:20:00.069]                     }
[13:20:00.069]                     base::local({
[13:20:00.069]                       for (pkg in "stats") {
[13:20:00.069]                         base::loadNamespace(pkg)
[13:20:00.069]                         base::library(pkg, character.only = TRUE)
[13:20:00.069]                       }
[13:20:00.069]                     })
[13:20:00.069]                   }
[13:20:00.069]                   options(future.plan = NULL)
[13:20:00.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.069]                 }
[13:20:00.069]                 ...future.workdir <- getwd()
[13:20:00.069]             }
[13:20:00.069]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.069]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.069]         }
[13:20:00.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.069]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.069]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.069]             base::names(...future.oldOptions))
[13:20:00.069]     }
[13:20:00.069]     if (FALSE) {
[13:20:00.069]     }
[13:20:00.069]     else {
[13:20:00.069]         if (TRUE) {
[13:20:00.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.069]                 open = "w")
[13:20:00.069]         }
[13:20:00.069]         else {
[13:20:00.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.069]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.069]         }
[13:20:00.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.069]             base::sink(type = "output", split = FALSE)
[13:20:00.069]             base::close(...future.stdout)
[13:20:00.069]         }, add = TRUE)
[13:20:00.069]     }
[13:20:00.069]     ...future.frame <- base::sys.nframe()
[13:20:00.069]     ...future.conditions <- base::list()
[13:20:00.069]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.069]     if (FALSE) {
[13:20:00.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.069]     }
[13:20:00.069]     ...future.result <- base::tryCatch({
[13:20:00.069]         base::withCallingHandlers({
[13:20:00.069]             ...future.value <- base::withVisible(base::local({
[13:20:00.069]                 ...future.makeSendCondition <- base::local({
[13:20:00.069]                   sendCondition <- NULL
[13:20:00.069]                   function(frame = 1L) {
[13:20:00.069]                     if (is.function(sendCondition)) 
[13:20:00.069]                       return(sendCondition)
[13:20:00.069]                     ns <- getNamespace("parallel")
[13:20:00.069]                     if (exists("sendData", mode = "function", 
[13:20:00.069]                       envir = ns)) {
[13:20:00.069]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.069]                         envir = ns)
[13:20:00.069]                       envir <- sys.frame(frame)
[13:20:00.069]                       master <- NULL
[13:20:00.069]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.069]                         !identical(envir, emptyenv())) {
[13:20:00.069]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.069]                           inherits = FALSE)) {
[13:20:00.069]                           master <- get("master", mode = "list", 
[13:20:00.069]                             envir = envir, inherits = FALSE)
[13:20:00.069]                           if (inherits(master, c("SOCKnode", 
[13:20:00.069]                             "SOCK0node"))) {
[13:20:00.069]                             sendCondition <<- function(cond) {
[13:20:00.069]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.069]                                 success = TRUE)
[13:20:00.069]                               parallel_sendData(master, data)
[13:20:00.069]                             }
[13:20:00.069]                             return(sendCondition)
[13:20:00.069]                           }
[13:20:00.069]                         }
[13:20:00.069]                         frame <- frame + 1L
[13:20:00.069]                         envir <- sys.frame(frame)
[13:20:00.069]                       }
[13:20:00.069]                     }
[13:20:00.069]                     sendCondition <<- function(cond) NULL
[13:20:00.069]                   }
[13:20:00.069]                 })
[13:20:00.069]                 withCallingHandlers({
[13:20:00.069]                   {
[13:20:00.069]                     do.call(function(...) {
[13:20:00.069]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.069]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.069]                         ...future.globals.maxSize)) {
[13:20:00.069]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.069]                         on.exit(options(oopts), add = TRUE)
[13:20:00.069]                       }
[13:20:00.069]                       {
[13:20:00.069]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.069]                           FUN = function(jj) {
[13:20:00.069]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.069]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.069]                           })
[13:20:00.069]                       }
[13:20:00.069]                     }, args = future.call.arguments)
[13:20:00.069]                   }
[13:20:00.069]                 }, immediateCondition = function(cond) {
[13:20:00.069]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.069]                   sendCondition(cond)
[13:20:00.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.069]                   {
[13:20:00.069]                     inherits <- base::inherits
[13:20:00.069]                     invokeRestart <- base::invokeRestart
[13:20:00.069]                     is.null <- base::is.null
[13:20:00.069]                     muffled <- FALSE
[13:20:00.069]                     if (inherits(cond, "message")) {
[13:20:00.069]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.069]                       if (muffled) 
[13:20:00.069]                         invokeRestart("muffleMessage")
[13:20:00.069]                     }
[13:20:00.069]                     else if (inherits(cond, "warning")) {
[13:20:00.069]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.069]                       if (muffled) 
[13:20:00.069]                         invokeRestart("muffleWarning")
[13:20:00.069]                     }
[13:20:00.069]                     else if (inherits(cond, "condition")) {
[13:20:00.069]                       if (!is.null(pattern)) {
[13:20:00.069]                         computeRestarts <- base::computeRestarts
[13:20:00.069]                         grepl <- base::grepl
[13:20:00.069]                         restarts <- computeRestarts(cond)
[13:20:00.069]                         for (restart in restarts) {
[13:20:00.069]                           name <- restart$name
[13:20:00.069]                           if (is.null(name)) 
[13:20:00.069]                             next
[13:20:00.069]                           if (!grepl(pattern, name)) 
[13:20:00.069]                             next
[13:20:00.069]                           invokeRestart(restart)
[13:20:00.069]                           muffled <- TRUE
[13:20:00.069]                           break
[13:20:00.069]                         }
[13:20:00.069]                       }
[13:20:00.069]                     }
[13:20:00.069]                     invisible(muffled)
[13:20:00.069]                   }
[13:20:00.069]                   muffleCondition(cond)
[13:20:00.069]                 })
[13:20:00.069]             }))
[13:20:00.069]             future::FutureResult(value = ...future.value$value, 
[13:20:00.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.069]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.069]                     ...future.globalenv.names))
[13:20:00.069]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.069]         }, condition = base::local({
[13:20:00.069]             c <- base::c
[13:20:00.069]             inherits <- base::inherits
[13:20:00.069]             invokeRestart <- base::invokeRestart
[13:20:00.069]             length <- base::length
[13:20:00.069]             list <- base::list
[13:20:00.069]             seq.int <- base::seq.int
[13:20:00.069]             signalCondition <- base::signalCondition
[13:20:00.069]             sys.calls <- base::sys.calls
[13:20:00.069]             `[[` <- base::`[[`
[13:20:00.069]             `+` <- base::`+`
[13:20:00.069]             `<<-` <- base::`<<-`
[13:20:00.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.069]                   3L)]
[13:20:00.069]             }
[13:20:00.069]             function(cond) {
[13:20:00.069]                 is_error <- inherits(cond, "error")
[13:20:00.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.069]                   NULL)
[13:20:00.069]                 if (is_error) {
[13:20:00.069]                   sessionInformation <- function() {
[13:20:00.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.069]                       search = base::search(), system = base::Sys.info())
[13:20:00.069]                   }
[13:20:00.069]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.069]                     cond$call), session = sessionInformation(), 
[13:20:00.069]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.069]                   signalCondition(cond)
[13:20:00.069]                 }
[13:20:00.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.069]                 "immediateCondition"))) {
[13:20:00.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.069]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.069]                   if (TRUE && !signal) {
[13:20:00.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.069]                     {
[13:20:00.069]                       inherits <- base::inherits
[13:20:00.069]                       invokeRestart <- base::invokeRestart
[13:20:00.069]                       is.null <- base::is.null
[13:20:00.069]                       muffled <- FALSE
[13:20:00.069]                       if (inherits(cond, "message")) {
[13:20:00.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.069]                         if (muffled) 
[13:20:00.069]                           invokeRestart("muffleMessage")
[13:20:00.069]                       }
[13:20:00.069]                       else if (inherits(cond, "warning")) {
[13:20:00.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.069]                         if (muffled) 
[13:20:00.069]                           invokeRestart("muffleWarning")
[13:20:00.069]                       }
[13:20:00.069]                       else if (inherits(cond, "condition")) {
[13:20:00.069]                         if (!is.null(pattern)) {
[13:20:00.069]                           computeRestarts <- base::computeRestarts
[13:20:00.069]                           grepl <- base::grepl
[13:20:00.069]                           restarts <- computeRestarts(cond)
[13:20:00.069]                           for (restart in restarts) {
[13:20:00.069]                             name <- restart$name
[13:20:00.069]                             if (is.null(name)) 
[13:20:00.069]                               next
[13:20:00.069]                             if (!grepl(pattern, name)) 
[13:20:00.069]                               next
[13:20:00.069]                             invokeRestart(restart)
[13:20:00.069]                             muffled <- TRUE
[13:20:00.069]                             break
[13:20:00.069]                           }
[13:20:00.069]                         }
[13:20:00.069]                       }
[13:20:00.069]                       invisible(muffled)
[13:20:00.069]                     }
[13:20:00.069]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.069]                   }
[13:20:00.069]                 }
[13:20:00.069]                 else {
[13:20:00.069]                   if (TRUE) {
[13:20:00.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.069]                     {
[13:20:00.069]                       inherits <- base::inherits
[13:20:00.069]                       invokeRestart <- base::invokeRestart
[13:20:00.069]                       is.null <- base::is.null
[13:20:00.069]                       muffled <- FALSE
[13:20:00.069]                       if (inherits(cond, "message")) {
[13:20:00.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.069]                         if (muffled) 
[13:20:00.069]                           invokeRestart("muffleMessage")
[13:20:00.069]                       }
[13:20:00.069]                       else if (inherits(cond, "warning")) {
[13:20:00.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.069]                         if (muffled) 
[13:20:00.069]                           invokeRestart("muffleWarning")
[13:20:00.069]                       }
[13:20:00.069]                       else if (inherits(cond, "condition")) {
[13:20:00.069]                         if (!is.null(pattern)) {
[13:20:00.069]                           computeRestarts <- base::computeRestarts
[13:20:00.069]                           grepl <- base::grepl
[13:20:00.069]                           restarts <- computeRestarts(cond)
[13:20:00.069]                           for (restart in restarts) {
[13:20:00.069]                             name <- restart$name
[13:20:00.069]                             if (is.null(name)) 
[13:20:00.069]                               next
[13:20:00.069]                             if (!grepl(pattern, name)) 
[13:20:00.069]                               next
[13:20:00.069]                             invokeRestart(restart)
[13:20:00.069]                             muffled <- TRUE
[13:20:00.069]                             break
[13:20:00.069]                           }
[13:20:00.069]                         }
[13:20:00.069]                       }
[13:20:00.069]                       invisible(muffled)
[13:20:00.069]                     }
[13:20:00.069]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.069]                   }
[13:20:00.069]                 }
[13:20:00.069]             }
[13:20:00.069]         }))
[13:20:00.069]     }, error = function(ex) {
[13:20:00.069]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.069]                 ...future.rng), started = ...future.startTime, 
[13:20:00.069]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.069]             version = "1.8"), class = "FutureResult")
[13:20:00.069]     }, finally = {
[13:20:00.069]         if (!identical(...future.workdir, getwd())) 
[13:20:00.069]             setwd(...future.workdir)
[13:20:00.069]         {
[13:20:00.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.069]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.069]             }
[13:20:00.069]             base::options(...future.oldOptions)
[13:20:00.069]             if (.Platform$OS.type == "windows") {
[13:20:00.069]                 old_names <- names(...future.oldEnvVars)
[13:20:00.069]                 envs <- base::Sys.getenv()
[13:20:00.069]                 names <- names(envs)
[13:20:00.069]                 common <- intersect(names, old_names)
[13:20:00.069]                 added <- setdiff(names, old_names)
[13:20:00.069]                 removed <- setdiff(old_names, names)
[13:20:00.069]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.069]                   envs[common]]
[13:20:00.069]                 NAMES <- toupper(changed)
[13:20:00.069]                 args <- list()
[13:20:00.069]                 for (kk in seq_along(NAMES)) {
[13:20:00.069]                   name <- changed[[kk]]
[13:20:00.069]                   NAME <- NAMES[[kk]]
[13:20:00.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.069]                     next
[13:20:00.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.069]                 }
[13:20:00.069]                 NAMES <- toupper(added)
[13:20:00.069]                 for (kk in seq_along(NAMES)) {
[13:20:00.069]                   name <- added[[kk]]
[13:20:00.069]                   NAME <- NAMES[[kk]]
[13:20:00.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.069]                     next
[13:20:00.069]                   args[[name]] <- ""
[13:20:00.069]                 }
[13:20:00.069]                 NAMES <- toupper(removed)
[13:20:00.069]                 for (kk in seq_along(NAMES)) {
[13:20:00.069]                   name <- removed[[kk]]
[13:20:00.069]                   NAME <- NAMES[[kk]]
[13:20:00.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.069]                     next
[13:20:00.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.069]                 }
[13:20:00.069]                 if (length(args) > 0) 
[13:20:00.069]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.069]             }
[13:20:00.069]             else {
[13:20:00.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.069]             }
[13:20:00.069]             {
[13:20:00.069]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.069]                   0L) {
[13:20:00.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.069]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.069]                   base::options(opts)
[13:20:00.069]                 }
[13:20:00.069]                 {
[13:20:00.069]                   {
[13:20:00.069]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.069]                     NULL
[13:20:00.069]                   }
[13:20:00.069]                   options(future.plan = NULL)
[13:20:00.069]                   if (is.na(NA_character_)) 
[13:20:00.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.069]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.069]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.069]                     envir = parent.frame()) 
[13:20:00.069]                   {
[13:20:00.069]                     if (is.function(workers)) 
[13:20:00.069]                       workers <- workers()
[13:20:00.069]                     workers <- structure(as.integer(workers), 
[13:20:00.069]                       class = class(workers))
[13:20:00.069]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.069]                       workers >= 1)
[13:20:00.069]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.069]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.069]                     }
[13:20:00.069]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.069]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.069]                       envir = envir)
[13:20:00.069]                     if (!future$lazy) 
[13:20:00.069]                       future <- run(future)
[13:20:00.069]                     invisible(future)
[13:20:00.069]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.069]                 }
[13:20:00.069]             }
[13:20:00.069]         }
[13:20:00.069]     })
[13:20:00.069]     if (TRUE) {
[13:20:00.069]         base::sink(type = "output", split = FALSE)
[13:20:00.069]         if (TRUE) {
[13:20:00.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.069]         }
[13:20:00.069]         else {
[13:20:00.069]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.069]         }
[13:20:00.069]         base::close(...future.stdout)
[13:20:00.069]         ...future.stdout <- NULL
[13:20:00.069]     }
[13:20:00.069]     ...future.result$conditions <- ...future.conditions
[13:20:00.069]     ...future.result$finished <- base::Sys.time()
[13:20:00.069]     ...future.result
[13:20:00.069] }
[13:20:00.072] Exporting 5 global objects (1.35 KiB) to cluster node #2 ...
[13:20:00.073] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:00.073] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.073] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:20:00.073] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:20:00.073] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[13:20:00.074] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[13:20:00.074] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:00.074] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.074] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:20:00.075] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:20:00.075] Exporting 5 global objects (1.35 KiB) to cluster node #2 ... DONE
[13:20:00.075] MultisessionFuture started
[13:20:00.075] - Launch lazy future ... done
[13:20:00.075] run() for ‘MultisessionFuture’ ... done
[13:20:00.076] Created future:
[13:20:00.076] MultisessionFuture:
[13:20:00.076] Label: ‘future_apply-2’
[13:20:00.076] Expression:
[13:20:00.076] {
[13:20:00.076]     do.call(function(...) {
[13:20:00.076]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.076]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.076]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.076]             on.exit(options(oopts), add = TRUE)
[13:20:00.076]         }
[13:20:00.076]         {
[13:20:00.076]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.076]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.076]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.076]             })
[13:20:00.076]         }
[13:20:00.076]     }, args = future.call.arguments)
[13:20:00.076] }
[13:20:00.076] Lazy evaluation: FALSE
[13:20:00.076] Asynchronous evaluation: TRUE
[13:20:00.076] Local evaluation: TRUE
[13:20:00.076] Environment: R_GlobalEnv
[13:20:00.076] Capture standard output: TRUE
[13:20:00.076] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.076] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.076] Packages: 1 packages (‘stats’)
[13:20:00.076] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.076] Resolved: FALSE
[13:20:00.076] Value: <not collected>
[13:20:00.076] Conditions captured: <none>
[13:20:00.076] Early signaling: FALSE
[13:20:00.076] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.076] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.087] Chunk #2 of 2 ... DONE
[13:20:00.087] Launching 2 futures (chunks) ... DONE
[13:20:00.088] Resolving 2 futures (chunks) ...
[13:20:00.088] resolve() on list ...
[13:20:00.088]  recursive: 0
[13:20:00.088]  length: 2
[13:20:00.088] 
[13:20:00.088] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.089] - Validating connection of MultisessionFuture
[13:20:00.089] - received message: FutureResult
[13:20:00.089] - Received FutureResult
[13:20:00.089] - Erased future from FutureRegistry
[13:20:00.089] result() for ClusterFuture ...
[13:20:00.089] - result already collected: FutureResult
[13:20:00.089] result() for ClusterFuture ... done
[13:20:00.089] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.090] Future #1
[13:20:00.090] result() for ClusterFuture ...
[13:20:00.090] - result already collected: FutureResult
[13:20:00.090] result() for ClusterFuture ... done
[13:20:00.090] result() for ClusterFuture ...
[13:20:00.090] - result already collected: FutureResult
[13:20:00.090] result() for ClusterFuture ... done
[13:20:00.090] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:00.090] - nx: 2
[13:20:00.090] - relay: TRUE
[13:20:00.090] - stdout: TRUE
[13:20:00.090] - signal: TRUE
[13:20:00.091] - resignal: FALSE
[13:20:00.091] - force: TRUE
[13:20:00.091] - relayed: [n=2] FALSE, FALSE
[13:20:00.091] - queued futures: [n=2] FALSE, FALSE
[13:20:00.091]  - until=1
[13:20:00.091]  - relaying element #1
[13:20:00.091] result() for ClusterFuture ...
[13:20:00.091] - result already collected: FutureResult
[13:20:00.091] result() for ClusterFuture ... done
[13:20:00.091] result() for ClusterFuture ...
[13:20:00.091] - result already collected: FutureResult
[13:20:00.092] result() for ClusterFuture ... done
[13:20:00.092] result() for ClusterFuture ...
[13:20:00.092] - result already collected: FutureResult
[13:20:00.092] result() for ClusterFuture ... done
[13:20:00.092] result() for ClusterFuture ...
[13:20:00.092] - result already collected: FutureResult
[13:20:00.092] result() for ClusterFuture ... done
[13:20:00.092] - relayed: [n=2] TRUE, FALSE
[13:20:00.092] - queued futures: [n=2] TRUE, FALSE
[13:20:00.092] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:00.093]  length: 1 (resolved future 1)
[13:20:00.123] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.123] - Validating connection of MultisessionFuture
[13:20:00.124] - received message: FutureResult
[13:20:00.124] - Received FutureResult
[13:20:00.124] - Erased future from FutureRegistry
[13:20:00.124] result() for ClusterFuture ...
[13:20:00.124] - result already collected: FutureResult
[13:20:00.124] result() for ClusterFuture ... done
[13:20:00.124] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.124] Future #2
[13:20:00.125] result() for ClusterFuture ...
[13:20:00.125] - result already collected: FutureResult
[13:20:00.125] result() for ClusterFuture ... done
[13:20:00.125] result() for ClusterFuture ...
[13:20:00.125] - result already collected: FutureResult
[13:20:00.125] result() for ClusterFuture ... done
[13:20:00.125] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:00.125] - nx: 2
[13:20:00.125] - relay: TRUE
[13:20:00.125] - stdout: TRUE
[13:20:00.126] - signal: TRUE
[13:20:00.126] - resignal: FALSE
[13:20:00.126] - force: TRUE
[13:20:00.126] - relayed: [n=2] TRUE, FALSE
[13:20:00.126] - queued futures: [n=2] TRUE, FALSE
[13:20:00.126]  - until=2
[13:20:00.126]  - relaying element #2
[13:20:00.126] result() for ClusterFuture ...
[13:20:00.126] - result already collected: FutureResult
[13:20:00.126] result() for ClusterFuture ... done
[13:20:00.126] result() for ClusterFuture ...
[13:20:00.127] - result already collected: FutureResult
[13:20:00.127] result() for ClusterFuture ... done
[13:20:00.127] result() for ClusterFuture ...
[13:20:00.127] - result already collected: FutureResult
[13:20:00.127] result() for ClusterFuture ... done
[13:20:00.127] result() for ClusterFuture ...
[13:20:00.127] - result already collected: FutureResult
[13:20:00.127] result() for ClusterFuture ... done
[13:20:00.127] - relayed: [n=2] TRUE, TRUE
[13:20:00.127] - queued futures: [n=2] TRUE, TRUE
[13:20:00.128] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:00.128]  length: 0 (resolved future 2)
[13:20:00.128] Relaying remaining futures
[13:20:00.128] signalConditionsASAP(NULL, pos=0) ...
[13:20:00.128] - nx: 2
[13:20:00.128] - relay: TRUE
[13:20:00.128] - stdout: TRUE
[13:20:00.128] - signal: TRUE
[13:20:00.128] - resignal: FALSE
[13:20:00.128] - force: TRUE
[13:20:00.128] - relayed: [n=2] TRUE, TRUE
[13:20:00.128] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:00.129] - relayed: [n=2] TRUE, TRUE
[13:20:00.129] - queued futures: [n=2] TRUE, TRUE
[13:20:00.129] signalConditionsASAP(NULL, pos=0) ... done
[13:20:00.129] resolve() on list ... DONE
[13:20:00.129] result() for ClusterFuture ...
[13:20:00.129] - result already collected: FutureResult
[13:20:00.129] result() for ClusterFuture ... done
[13:20:00.129] result() for ClusterFuture ...
[13:20:00.129] - result already collected: FutureResult
[13:20:00.129] result() for ClusterFuture ... done
[13:20:00.130] result() for ClusterFuture ...
[13:20:00.130] - result already collected: FutureResult
[13:20:00.130] result() for ClusterFuture ... done
[13:20:00.130] result() for ClusterFuture ...
[13:20:00.130] - result already collected: FutureResult
[13:20:00.130] result() for ClusterFuture ... done
[13:20:00.130]  - Number of value chunks collected: 2
[13:20:00.130] Resolving 2 futures (chunks) ... DONE
[13:20:00.130] Reducing values from 2 chunks ...
[13:20:00.130]  - Number of values collected after concatenation: 2
[13:20:00.130]  - Number of values expected: 2
[13:20:00.131] Reducing values from 2 chunks ... DONE
[13:20:00.131] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[13:20:00.131] getGlobalsAndPackagesXApply() ...
[13:20:00.131]  - future.globals: TRUE
[13:20:00.131] getGlobalsAndPackages() ...
[13:20:00.132] Searching for globals...
[13:20:00.133] - globals found: [1] ‘FUN’
[13:20:00.133] Searching for globals ... DONE
[13:20:00.133] Resolving globals: FALSE
[13:20:00.133] The total size of the 1 globals is 848 bytes (848 bytes)
[13:20:00.134] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:20:00.134] - globals: [1] ‘FUN’
[13:20:00.134] 
[13:20:00.134] getGlobalsAndPackages() ... DONE
[13:20:00.134]  - globals found/used: [n=1] ‘FUN’
[13:20:00.134]  - needed namespaces: [n=0] 
[13:20:00.134] Finding globals ... DONE
[13:20:00.134]  - use_args: TRUE
[13:20:00.134]  - Getting '...' globals ...
[13:20:00.135] resolve() on list ...
[13:20:00.135]  recursive: 0
[13:20:00.135]  length: 1
[13:20:00.135]  elements: ‘...’
[13:20:00.135]  length: 0 (resolved future 1)
[13:20:00.135] resolve() on list ... DONE
[13:20:00.135]    - '...' content: [n=0] 
[13:20:00.135] List of 1
[13:20:00.135]  $ ...: list()
[13:20:00.135]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.135]  - attr(*, "where")=List of 1
[13:20:00.135]   ..$ ...:<environment: 0x555924732bb8> 
[13:20:00.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.135]  - attr(*, "resolved")= logi TRUE
[13:20:00.135]  - attr(*, "total_size")= num NA
[13:20:00.138]  - Getting '...' globals ... DONE
[13:20:00.138] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:00.138] List of 2
[13:20:00.138]  $ ...future.FUN:function (x)  
[13:20:00.138]  $ ...          : list()
[13:20:00.138]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.138]  - attr(*, "where")=List of 2
[13:20:00.138]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:00.138]   ..$ ...          :<environment: 0x555924732bb8> 
[13:20:00.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.138]  - attr(*, "resolved")= logi FALSE
[13:20:00.138]  - attr(*, "total_size")= num 848
[13:20:00.141] Packages to be attached in all futures: [n=0] 
[13:20:00.141] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.147] future_lapply() ...
[13:20:00.151] Number of chunks: 2
[13:20:00.151] getGlobalsAndPackagesXApply() ...
[13:20:00.151]  - future.globals: <name-value list> with names ‘list()’
[13:20:00.151]  - use_args: TRUE
[13:20:00.151] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:20:00.151] List of 2
[13:20:00.151]  $ ...          : list()
[13:20:00.151]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.151]  $ ...future.FUN:function (x)  
[13:20:00.151]  - attr(*, "where")=List of 2
[13:20:00.151]   ..$ ...          :<environment: 0x555924732bb8> 
[13:20:00.151]   ..$ ...future.FUN:<environment: namespace:base> 
[13:20:00.151]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.151]  - attr(*, "resolved")= logi FALSE
[13:20:00.151]  - attr(*, "total_size")= num NA
[13:20:00.155] Packages to be attached in all futures: [n=0] 
[13:20:00.155] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.155] Number of futures (= number of chunks): 2
[13:20:00.155] Launching 2 futures (chunks) ...
[13:20:00.155] Chunk #1 of 2 ...
[13:20:00.155]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.155]  - seeds: <none>
[13:20:00.155]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.156] getGlobalsAndPackages() ...
[13:20:00.156] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.156] Resolving globals: FALSE
[13:20:00.156] Tweak future expression to call with '...' arguments ...
[13:20:00.156] {
[13:20:00.156]     do.call(function(...) {
[13:20:00.156]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.156]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.156]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.156]             on.exit(options(oopts), add = TRUE)
[13:20:00.156]         }
[13:20:00.156]         {
[13:20:00.156]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.156]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.156]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.156]             })
[13:20:00.156]         }
[13:20:00.156]     }, args = future.call.arguments)
[13:20:00.156] }
[13:20:00.156] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.157] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.157] 
[13:20:00.157] getGlobalsAndPackages() ... DONE
[13:20:00.157] run() for ‘Future’ ...
[13:20:00.157] - state: ‘created’
[13:20:00.157] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.171] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.172]   - Field: ‘node’
[13:20:00.172]   - Field: ‘label’
[13:20:00.172]   - Field: ‘local’
[13:20:00.172]   - Field: ‘owner’
[13:20:00.172]   - Field: ‘envir’
[13:20:00.172]   - Field: ‘workers’
[13:20:00.172]   - Field: ‘packages’
[13:20:00.172]   - Field: ‘gc’
[13:20:00.172]   - Field: ‘conditions’
[13:20:00.173]   - Field: ‘persistent’
[13:20:00.173]   - Field: ‘expr’
[13:20:00.173]   - Field: ‘uuid’
[13:20:00.173]   - Field: ‘seed’
[13:20:00.173]   - Field: ‘version’
[13:20:00.173]   - Field: ‘result’
[13:20:00.173]   - Field: ‘asynchronous’
[13:20:00.173]   - Field: ‘calls’
[13:20:00.173]   - Field: ‘globals’
[13:20:00.173]   - Field: ‘stdout’
[13:20:00.174]   - Field: ‘earlySignal’
[13:20:00.174]   - Field: ‘lazy’
[13:20:00.174]   - Field: ‘state’
[13:20:00.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.174] - Launch lazy future ...
[13:20:00.174] Packages needed by the future expression (n = 0): <none>
[13:20:00.174] Packages needed by future strategies (n = 0): <none>
[13:20:00.175] {
[13:20:00.175]     {
[13:20:00.175]         {
[13:20:00.175]             ...future.startTime <- base::Sys.time()
[13:20:00.175]             {
[13:20:00.175]                 {
[13:20:00.175]                   {
[13:20:00.175]                     {
[13:20:00.175]                       base::local({
[13:20:00.175]                         has_future <- base::requireNamespace("future", 
[13:20:00.175]                           quietly = TRUE)
[13:20:00.175]                         if (has_future) {
[13:20:00.175]                           ns <- base::getNamespace("future")
[13:20:00.175]                           version <- ns[[".package"]][["version"]]
[13:20:00.175]                           if (is.null(version)) 
[13:20:00.175]                             version <- utils::packageVersion("future")
[13:20:00.175]                         }
[13:20:00.175]                         else {
[13:20:00.175]                           version <- NULL
[13:20:00.175]                         }
[13:20:00.175]                         if (!has_future || version < "1.8.0") {
[13:20:00.175]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.175]                             "", base::R.version$version.string), 
[13:20:00.175]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.175]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.175]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.175]                               "release", "version")], collapse = " "), 
[13:20:00.175]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.175]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.175]                             info)
[13:20:00.175]                           info <- base::paste(info, collapse = "; ")
[13:20:00.175]                           if (!has_future) {
[13:20:00.175]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.175]                               info)
[13:20:00.175]                           }
[13:20:00.175]                           else {
[13:20:00.175]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.175]                               info, version)
[13:20:00.175]                           }
[13:20:00.175]                           base::stop(msg)
[13:20:00.175]                         }
[13:20:00.175]                       })
[13:20:00.175]                     }
[13:20:00.175]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.175]                     base::options(mc.cores = 1L)
[13:20:00.175]                   }
[13:20:00.175]                   options(future.plan = NULL)
[13:20:00.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.175]                 }
[13:20:00.175]                 ...future.workdir <- getwd()
[13:20:00.175]             }
[13:20:00.175]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.175]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.175]         }
[13:20:00.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.175]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.175]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.175]             base::names(...future.oldOptions))
[13:20:00.175]     }
[13:20:00.175]     if (FALSE) {
[13:20:00.175]     }
[13:20:00.175]     else {
[13:20:00.175]         if (TRUE) {
[13:20:00.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.175]                 open = "w")
[13:20:00.175]         }
[13:20:00.175]         else {
[13:20:00.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.175]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.175]         }
[13:20:00.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.175]             base::sink(type = "output", split = FALSE)
[13:20:00.175]             base::close(...future.stdout)
[13:20:00.175]         }, add = TRUE)
[13:20:00.175]     }
[13:20:00.175]     ...future.frame <- base::sys.nframe()
[13:20:00.175]     ...future.conditions <- base::list()
[13:20:00.175]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.175]     if (FALSE) {
[13:20:00.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.175]     }
[13:20:00.175]     ...future.result <- base::tryCatch({
[13:20:00.175]         base::withCallingHandlers({
[13:20:00.175]             ...future.value <- base::withVisible(base::local({
[13:20:00.175]                 ...future.makeSendCondition <- base::local({
[13:20:00.175]                   sendCondition <- NULL
[13:20:00.175]                   function(frame = 1L) {
[13:20:00.175]                     if (is.function(sendCondition)) 
[13:20:00.175]                       return(sendCondition)
[13:20:00.175]                     ns <- getNamespace("parallel")
[13:20:00.175]                     if (exists("sendData", mode = "function", 
[13:20:00.175]                       envir = ns)) {
[13:20:00.175]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.175]                         envir = ns)
[13:20:00.175]                       envir <- sys.frame(frame)
[13:20:00.175]                       master <- NULL
[13:20:00.175]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.175]                         !identical(envir, emptyenv())) {
[13:20:00.175]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.175]                           inherits = FALSE)) {
[13:20:00.175]                           master <- get("master", mode = "list", 
[13:20:00.175]                             envir = envir, inherits = FALSE)
[13:20:00.175]                           if (inherits(master, c("SOCKnode", 
[13:20:00.175]                             "SOCK0node"))) {
[13:20:00.175]                             sendCondition <<- function(cond) {
[13:20:00.175]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.175]                                 success = TRUE)
[13:20:00.175]                               parallel_sendData(master, data)
[13:20:00.175]                             }
[13:20:00.175]                             return(sendCondition)
[13:20:00.175]                           }
[13:20:00.175]                         }
[13:20:00.175]                         frame <- frame + 1L
[13:20:00.175]                         envir <- sys.frame(frame)
[13:20:00.175]                       }
[13:20:00.175]                     }
[13:20:00.175]                     sendCondition <<- function(cond) NULL
[13:20:00.175]                   }
[13:20:00.175]                 })
[13:20:00.175]                 withCallingHandlers({
[13:20:00.175]                   {
[13:20:00.175]                     do.call(function(...) {
[13:20:00.175]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.175]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.175]                         ...future.globals.maxSize)) {
[13:20:00.175]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.175]                         on.exit(options(oopts), add = TRUE)
[13:20:00.175]                       }
[13:20:00.175]                       {
[13:20:00.175]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.175]                           FUN = function(jj) {
[13:20:00.175]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.175]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.175]                           })
[13:20:00.175]                       }
[13:20:00.175]                     }, args = future.call.arguments)
[13:20:00.175]                   }
[13:20:00.175]                 }, immediateCondition = function(cond) {
[13:20:00.175]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.175]                   sendCondition(cond)
[13:20:00.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.175]                   {
[13:20:00.175]                     inherits <- base::inherits
[13:20:00.175]                     invokeRestart <- base::invokeRestart
[13:20:00.175]                     is.null <- base::is.null
[13:20:00.175]                     muffled <- FALSE
[13:20:00.175]                     if (inherits(cond, "message")) {
[13:20:00.175]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.175]                       if (muffled) 
[13:20:00.175]                         invokeRestart("muffleMessage")
[13:20:00.175]                     }
[13:20:00.175]                     else if (inherits(cond, "warning")) {
[13:20:00.175]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.175]                       if (muffled) 
[13:20:00.175]                         invokeRestart("muffleWarning")
[13:20:00.175]                     }
[13:20:00.175]                     else if (inherits(cond, "condition")) {
[13:20:00.175]                       if (!is.null(pattern)) {
[13:20:00.175]                         computeRestarts <- base::computeRestarts
[13:20:00.175]                         grepl <- base::grepl
[13:20:00.175]                         restarts <- computeRestarts(cond)
[13:20:00.175]                         for (restart in restarts) {
[13:20:00.175]                           name <- restart$name
[13:20:00.175]                           if (is.null(name)) 
[13:20:00.175]                             next
[13:20:00.175]                           if (!grepl(pattern, name)) 
[13:20:00.175]                             next
[13:20:00.175]                           invokeRestart(restart)
[13:20:00.175]                           muffled <- TRUE
[13:20:00.175]                           break
[13:20:00.175]                         }
[13:20:00.175]                       }
[13:20:00.175]                     }
[13:20:00.175]                     invisible(muffled)
[13:20:00.175]                   }
[13:20:00.175]                   muffleCondition(cond)
[13:20:00.175]                 })
[13:20:00.175]             }))
[13:20:00.175]             future::FutureResult(value = ...future.value$value, 
[13:20:00.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.175]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.175]                     ...future.globalenv.names))
[13:20:00.175]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.175]         }, condition = base::local({
[13:20:00.175]             c <- base::c
[13:20:00.175]             inherits <- base::inherits
[13:20:00.175]             invokeRestart <- base::invokeRestart
[13:20:00.175]             length <- base::length
[13:20:00.175]             list <- base::list
[13:20:00.175]             seq.int <- base::seq.int
[13:20:00.175]             signalCondition <- base::signalCondition
[13:20:00.175]             sys.calls <- base::sys.calls
[13:20:00.175]             `[[` <- base::`[[`
[13:20:00.175]             `+` <- base::`+`
[13:20:00.175]             `<<-` <- base::`<<-`
[13:20:00.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.175]                   3L)]
[13:20:00.175]             }
[13:20:00.175]             function(cond) {
[13:20:00.175]                 is_error <- inherits(cond, "error")
[13:20:00.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.175]                   NULL)
[13:20:00.175]                 if (is_error) {
[13:20:00.175]                   sessionInformation <- function() {
[13:20:00.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.175]                       search = base::search(), system = base::Sys.info())
[13:20:00.175]                   }
[13:20:00.175]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.175]                     cond$call), session = sessionInformation(), 
[13:20:00.175]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.175]                   signalCondition(cond)
[13:20:00.175]                 }
[13:20:00.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.175]                 "immediateCondition"))) {
[13:20:00.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.175]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.175]                   if (TRUE && !signal) {
[13:20:00.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.175]                     {
[13:20:00.175]                       inherits <- base::inherits
[13:20:00.175]                       invokeRestart <- base::invokeRestart
[13:20:00.175]                       is.null <- base::is.null
[13:20:00.175]                       muffled <- FALSE
[13:20:00.175]                       if (inherits(cond, "message")) {
[13:20:00.175]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.175]                         if (muffled) 
[13:20:00.175]                           invokeRestart("muffleMessage")
[13:20:00.175]                       }
[13:20:00.175]                       else if (inherits(cond, "warning")) {
[13:20:00.175]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.175]                         if (muffled) 
[13:20:00.175]                           invokeRestart("muffleWarning")
[13:20:00.175]                       }
[13:20:00.175]                       else if (inherits(cond, "condition")) {
[13:20:00.175]                         if (!is.null(pattern)) {
[13:20:00.175]                           computeRestarts <- base::computeRestarts
[13:20:00.175]                           grepl <- base::grepl
[13:20:00.175]                           restarts <- computeRestarts(cond)
[13:20:00.175]                           for (restart in restarts) {
[13:20:00.175]                             name <- restart$name
[13:20:00.175]                             if (is.null(name)) 
[13:20:00.175]                               next
[13:20:00.175]                             if (!grepl(pattern, name)) 
[13:20:00.175]                               next
[13:20:00.175]                             invokeRestart(restart)
[13:20:00.175]                             muffled <- TRUE
[13:20:00.175]                             break
[13:20:00.175]                           }
[13:20:00.175]                         }
[13:20:00.175]                       }
[13:20:00.175]                       invisible(muffled)
[13:20:00.175]                     }
[13:20:00.175]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.175]                   }
[13:20:00.175]                 }
[13:20:00.175]                 else {
[13:20:00.175]                   if (TRUE) {
[13:20:00.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.175]                     {
[13:20:00.175]                       inherits <- base::inherits
[13:20:00.175]                       invokeRestart <- base::invokeRestart
[13:20:00.175]                       is.null <- base::is.null
[13:20:00.175]                       muffled <- FALSE
[13:20:00.175]                       if (inherits(cond, "message")) {
[13:20:00.175]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.175]                         if (muffled) 
[13:20:00.175]                           invokeRestart("muffleMessage")
[13:20:00.175]                       }
[13:20:00.175]                       else if (inherits(cond, "warning")) {
[13:20:00.175]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.175]                         if (muffled) 
[13:20:00.175]                           invokeRestart("muffleWarning")
[13:20:00.175]                       }
[13:20:00.175]                       else if (inherits(cond, "condition")) {
[13:20:00.175]                         if (!is.null(pattern)) {
[13:20:00.175]                           computeRestarts <- base::computeRestarts
[13:20:00.175]                           grepl <- base::grepl
[13:20:00.175]                           restarts <- computeRestarts(cond)
[13:20:00.175]                           for (restart in restarts) {
[13:20:00.175]                             name <- restart$name
[13:20:00.175]                             if (is.null(name)) 
[13:20:00.175]                               next
[13:20:00.175]                             if (!grepl(pattern, name)) 
[13:20:00.175]                               next
[13:20:00.175]                             invokeRestart(restart)
[13:20:00.175]                             muffled <- TRUE
[13:20:00.175]                             break
[13:20:00.175]                           }
[13:20:00.175]                         }
[13:20:00.175]                       }
[13:20:00.175]                       invisible(muffled)
[13:20:00.175]                     }
[13:20:00.175]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.175]                   }
[13:20:00.175]                 }
[13:20:00.175]             }
[13:20:00.175]         }))
[13:20:00.175]     }, error = function(ex) {
[13:20:00.175]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.175]                 ...future.rng), started = ...future.startTime, 
[13:20:00.175]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.175]             version = "1.8"), class = "FutureResult")
[13:20:00.175]     }, finally = {
[13:20:00.175]         if (!identical(...future.workdir, getwd())) 
[13:20:00.175]             setwd(...future.workdir)
[13:20:00.175]         {
[13:20:00.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.175]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.175]             }
[13:20:00.175]             base::options(...future.oldOptions)
[13:20:00.175]             if (.Platform$OS.type == "windows") {
[13:20:00.175]                 old_names <- names(...future.oldEnvVars)
[13:20:00.175]                 envs <- base::Sys.getenv()
[13:20:00.175]                 names <- names(envs)
[13:20:00.175]                 common <- intersect(names, old_names)
[13:20:00.175]                 added <- setdiff(names, old_names)
[13:20:00.175]                 removed <- setdiff(old_names, names)
[13:20:00.175]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.175]                   envs[common]]
[13:20:00.175]                 NAMES <- toupper(changed)
[13:20:00.175]                 args <- list()
[13:20:00.175]                 for (kk in seq_along(NAMES)) {
[13:20:00.175]                   name <- changed[[kk]]
[13:20:00.175]                   NAME <- NAMES[[kk]]
[13:20:00.175]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.175]                     next
[13:20:00.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.175]                 }
[13:20:00.175]                 NAMES <- toupper(added)
[13:20:00.175]                 for (kk in seq_along(NAMES)) {
[13:20:00.175]                   name <- added[[kk]]
[13:20:00.175]                   NAME <- NAMES[[kk]]
[13:20:00.175]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.175]                     next
[13:20:00.175]                   args[[name]] <- ""
[13:20:00.175]                 }
[13:20:00.175]                 NAMES <- toupper(removed)
[13:20:00.175]                 for (kk in seq_along(NAMES)) {
[13:20:00.175]                   name <- removed[[kk]]
[13:20:00.175]                   NAME <- NAMES[[kk]]
[13:20:00.175]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.175]                     next
[13:20:00.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.175]                 }
[13:20:00.175]                 if (length(args) > 0) 
[13:20:00.175]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.175]             }
[13:20:00.175]             else {
[13:20:00.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.175]             }
[13:20:00.175]             {
[13:20:00.175]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.175]                   0L) {
[13:20:00.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.175]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.175]                   base::options(opts)
[13:20:00.175]                 }
[13:20:00.175]                 {
[13:20:00.175]                   {
[13:20:00.175]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.175]                     NULL
[13:20:00.175]                   }
[13:20:00.175]                   options(future.plan = NULL)
[13:20:00.175]                   if (is.na(NA_character_)) 
[13:20:00.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.175]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.175]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.175]                     envir = parent.frame()) 
[13:20:00.175]                   {
[13:20:00.175]                     if (is.function(workers)) 
[13:20:00.175]                       workers <- workers()
[13:20:00.175]                     workers <- structure(as.integer(workers), 
[13:20:00.175]                       class = class(workers))
[13:20:00.175]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.175]                       workers >= 1)
[13:20:00.175]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.175]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.175]                     }
[13:20:00.175]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.175]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.175]                       envir = envir)
[13:20:00.175]                     if (!future$lazy) 
[13:20:00.175]                       future <- run(future)
[13:20:00.175]                     invisible(future)
[13:20:00.175]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.175]                 }
[13:20:00.175]             }
[13:20:00.175]         }
[13:20:00.175]     })
[13:20:00.175]     if (TRUE) {
[13:20:00.175]         base::sink(type = "output", split = FALSE)
[13:20:00.175]         if (TRUE) {
[13:20:00.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.175]         }
[13:20:00.175]         else {
[13:20:00.175]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.175]         }
[13:20:00.175]         base::close(...future.stdout)
[13:20:00.175]         ...future.stdout <- NULL
[13:20:00.175]     }
[13:20:00.175]     ...future.result$conditions <- ...future.conditions
[13:20:00.175]     ...future.result$finished <- base::Sys.time()
[13:20:00.175]     ...future.result
[13:20:00.175] }
[13:20:00.178] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[13:20:00.178] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:00.179] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.179] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:20:00.179] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:20:00.179] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:20:00.180] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:20:00.180] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:00.180] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.180] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:20:00.181] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.181] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[13:20:00.181] MultisessionFuture started
[13:20:00.181] - Launch lazy future ... done
[13:20:00.181] run() for ‘MultisessionFuture’ ... done
[13:20:00.182] Created future:
[13:20:00.182] MultisessionFuture:
[13:20:00.182] Label: ‘future_apply-1’
[13:20:00.182] Expression:
[13:20:00.182] {
[13:20:00.182]     do.call(function(...) {
[13:20:00.182]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.182]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.182]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.182]             on.exit(options(oopts), add = TRUE)
[13:20:00.182]         }
[13:20:00.182]         {
[13:20:00.182]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.182]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.182]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.182]             })
[13:20:00.182]         }
[13:20:00.182]     }, args = future.call.arguments)
[13:20:00.182] }
[13:20:00.182] Lazy evaluation: FALSE
[13:20:00.182] Asynchronous evaluation: TRUE
[13:20:00.182] Local evaluation: TRUE
[13:20:00.182] Environment: R_GlobalEnv
[13:20:00.182] Capture standard output: TRUE
[13:20:00.182] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.182] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.182] Packages: <none>
[13:20:00.182] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.182] Resolved: FALSE
[13:20:00.182] Value: <not collected>
[13:20:00.182] Conditions captured: <none>
[13:20:00.182] Early signaling: FALSE
[13:20:00.182] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.182] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.193] Chunk #1 of 2 ... DONE
[13:20:00.193] Chunk #2 of 2 ...
[13:20:00.194]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.194]  - seeds: <none>
[13:20:00.194]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.194] getGlobalsAndPackages() ...
[13:20:00.194] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.194] Resolving globals: FALSE
[13:20:00.194] Tweak future expression to call with '...' arguments ...
[13:20:00.194] {
[13:20:00.194]     do.call(function(...) {
[13:20:00.194]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.194]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.194]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.194]             on.exit(options(oopts), add = TRUE)
[13:20:00.194]         }
[13:20:00.194]         {
[13:20:00.194]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.194]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.194]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.194]             })
[13:20:00.194]         }
[13:20:00.194]     }, args = future.call.arguments)
[13:20:00.194] }
[13:20:00.195] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.195] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.195] 
[13:20:00.195] getGlobalsAndPackages() ... DONE
[13:20:00.196] run() for ‘Future’ ...
[13:20:00.196] - state: ‘created’
[13:20:00.196] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.211] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.211]   - Field: ‘node’
[13:20:00.211]   - Field: ‘label’
[13:20:00.211]   - Field: ‘local’
[13:20:00.211]   - Field: ‘owner’
[13:20:00.211]   - Field: ‘envir’
[13:20:00.212]   - Field: ‘workers’
[13:20:00.212]   - Field: ‘packages’
[13:20:00.212]   - Field: ‘gc’
[13:20:00.212]   - Field: ‘conditions’
[13:20:00.212]   - Field: ‘persistent’
[13:20:00.212]   - Field: ‘expr’
[13:20:00.212]   - Field: ‘uuid’
[13:20:00.212]   - Field: ‘seed’
[13:20:00.212]   - Field: ‘version’
[13:20:00.212]   - Field: ‘result’
[13:20:00.213]   - Field: ‘asynchronous’
[13:20:00.213]   - Field: ‘calls’
[13:20:00.213]   - Field: ‘globals’
[13:20:00.213]   - Field: ‘stdout’
[13:20:00.213]   - Field: ‘earlySignal’
[13:20:00.213]   - Field: ‘lazy’
[13:20:00.213]   - Field: ‘state’
[13:20:00.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.213] - Launch lazy future ...
[13:20:00.214] Packages needed by the future expression (n = 0): <none>
[13:20:00.214] Packages needed by future strategies (n = 0): <none>
[13:20:00.214] {
[13:20:00.214]     {
[13:20:00.214]         {
[13:20:00.214]             ...future.startTime <- base::Sys.time()
[13:20:00.214]             {
[13:20:00.214]                 {
[13:20:00.214]                   {
[13:20:00.214]                     {
[13:20:00.214]                       base::local({
[13:20:00.214]                         has_future <- base::requireNamespace("future", 
[13:20:00.214]                           quietly = TRUE)
[13:20:00.214]                         if (has_future) {
[13:20:00.214]                           ns <- base::getNamespace("future")
[13:20:00.214]                           version <- ns[[".package"]][["version"]]
[13:20:00.214]                           if (is.null(version)) 
[13:20:00.214]                             version <- utils::packageVersion("future")
[13:20:00.214]                         }
[13:20:00.214]                         else {
[13:20:00.214]                           version <- NULL
[13:20:00.214]                         }
[13:20:00.214]                         if (!has_future || version < "1.8.0") {
[13:20:00.214]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.214]                             "", base::R.version$version.string), 
[13:20:00.214]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.214]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.214]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.214]                               "release", "version")], collapse = " "), 
[13:20:00.214]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.214]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.214]                             info)
[13:20:00.214]                           info <- base::paste(info, collapse = "; ")
[13:20:00.214]                           if (!has_future) {
[13:20:00.214]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.214]                               info)
[13:20:00.214]                           }
[13:20:00.214]                           else {
[13:20:00.214]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.214]                               info, version)
[13:20:00.214]                           }
[13:20:00.214]                           base::stop(msg)
[13:20:00.214]                         }
[13:20:00.214]                       })
[13:20:00.214]                     }
[13:20:00.214]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.214]                     base::options(mc.cores = 1L)
[13:20:00.214]                   }
[13:20:00.214]                   options(future.plan = NULL)
[13:20:00.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.214]                 }
[13:20:00.214]                 ...future.workdir <- getwd()
[13:20:00.214]             }
[13:20:00.214]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.214]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.214]         }
[13:20:00.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.214]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.214]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.214]             base::names(...future.oldOptions))
[13:20:00.214]     }
[13:20:00.214]     if (FALSE) {
[13:20:00.214]     }
[13:20:00.214]     else {
[13:20:00.214]         if (TRUE) {
[13:20:00.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.214]                 open = "w")
[13:20:00.214]         }
[13:20:00.214]         else {
[13:20:00.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.214]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.214]         }
[13:20:00.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.214]             base::sink(type = "output", split = FALSE)
[13:20:00.214]             base::close(...future.stdout)
[13:20:00.214]         }, add = TRUE)
[13:20:00.214]     }
[13:20:00.214]     ...future.frame <- base::sys.nframe()
[13:20:00.214]     ...future.conditions <- base::list()
[13:20:00.214]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.214]     if (FALSE) {
[13:20:00.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.214]     }
[13:20:00.214]     ...future.result <- base::tryCatch({
[13:20:00.214]         base::withCallingHandlers({
[13:20:00.214]             ...future.value <- base::withVisible(base::local({
[13:20:00.214]                 ...future.makeSendCondition <- base::local({
[13:20:00.214]                   sendCondition <- NULL
[13:20:00.214]                   function(frame = 1L) {
[13:20:00.214]                     if (is.function(sendCondition)) 
[13:20:00.214]                       return(sendCondition)
[13:20:00.214]                     ns <- getNamespace("parallel")
[13:20:00.214]                     if (exists("sendData", mode = "function", 
[13:20:00.214]                       envir = ns)) {
[13:20:00.214]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.214]                         envir = ns)
[13:20:00.214]                       envir <- sys.frame(frame)
[13:20:00.214]                       master <- NULL
[13:20:00.214]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.214]                         !identical(envir, emptyenv())) {
[13:20:00.214]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.214]                           inherits = FALSE)) {
[13:20:00.214]                           master <- get("master", mode = "list", 
[13:20:00.214]                             envir = envir, inherits = FALSE)
[13:20:00.214]                           if (inherits(master, c("SOCKnode", 
[13:20:00.214]                             "SOCK0node"))) {
[13:20:00.214]                             sendCondition <<- function(cond) {
[13:20:00.214]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.214]                                 success = TRUE)
[13:20:00.214]                               parallel_sendData(master, data)
[13:20:00.214]                             }
[13:20:00.214]                             return(sendCondition)
[13:20:00.214]                           }
[13:20:00.214]                         }
[13:20:00.214]                         frame <- frame + 1L
[13:20:00.214]                         envir <- sys.frame(frame)
[13:20:00.214]                       }
[13:20:00.214]                     }
[13:20:00.214]                     sendCondition <<- function(cond) NULL
[13:20:00.214]                   }
[13:20:00.214]                 })
[13:20:00.214]                 withCallingHandlers({
[13:20:00.214]                   {
[13:20:00.214]                     do.call(function(...) {
[13:20:00.214]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.214]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.214]                         ...future.globals.maxSize)) {
[13:20:00.214]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.214]                         on.exit(options(oopts), add = TRUE)
[13:20:00.214]                       }
[13:20:00.214]                       {
[13:20:00.214]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.214]                           FUN = function(jj) {
[13:20:00.214]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.214]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.214]                           })
[13:20:00.214]                       }
[13:20:00.214]                     }, args = future.call.arguments)
[13:20:00.214]                   }
[13:20:00.214]                 }, immediateCondition = function(cond) {
[13:20:00.214]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.214]                   sendCondition(cond)
[13:20:00.214]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.214]                   {
[13:20:00.214]                     inherits <- base::inherits
[13:20:00.214]                     invokeRestart <- base::invokeRestart
[13:20:00.214]                     is.null <- base::is.null
[13:20:00.214]                     muffled <- FALSE
[13:20:00.214]                     if (inherits(cond, "message")) {
[13:20:00.214]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.214]                       if (muffled) 
[13:20:00.214]                         invokeRestart("muffleMessage")
[13:20:00.214]                     }
[13:20:00.214]                     else if (inherits(cond, "warning")) {
[13:20:00.214]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.214]                       if (muffled) 
[13:20:00.214]                         invokeRestart("muffleWarning")
[13:20:00.214]                     }
[13:20:00.214]                     else if (inherits(cond, "condition")) {
[13:20:00.214]                       if (!is.null(pattern)) {
[13:20:00.214]                         computeRestarts <- base::computeRestarts
[13:20:00.214]                         grepl <- base::grepl
[13:20:00.214]                         restarts <- computeRestarts(cond)
[13:20:00.214]                         for (restart in restarts) {
[13:20:00.214]                           name <- restart$name
[13:20:00.214]                           if (is.null(name)) 
[13:20:00.214]                             next
[13:20:00.214]                           if (!grepl(pattern, name)) 
[13:20:00.214]                             next
[13:20:00.214]                           invokeRestart(restart)
[13:20:00.214]                           muffled <- TRUE
[13:20:00.214]                           break
[13:20:00.214]                         }
[13:20:00.214]                       }
[13:20:00.214]                     }
[13:20:00.214]                     invisible(muffled)
[13:20:00.214]                   }
[13:20:00.214]                   muffleCondition(cond)
[13:20:00.214]                 })
[13:20:00.214]             }))
[13:20:00.214]             future::FutureResult(value = ...future.value$value, 
[13:20:00.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.214]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.214]                     ...future.globalenv.names))
[13:20:00.214]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.214]         }, condition = base::local({
[13:20:00.214]             c <- base::c
[13:20:00.214]             inherits <- base::inherits
[13:20:00.214]             invokeRestart <- base::invokeRestart
[13:20:00.214]             length <- base::length
[13:20:00.214]             list <- base::list
[13:20:00.214]             seq.int <- base::seq.int
[13:20:00.214]             signalCondition <- base::signalCondition
[13:20:00.214]             sys.calls <- base::sys.calls
[13:20:00.214]             `[[` <- base::`[[`
[13:20:00.214]             `+` <- base::`+`
[13:20:00.214]             `<<-` <- base::`<<-`
[13:20:00.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.214]                   3L)]
[13:20:00.214]             }
[13:20:00.214]             function(cond) {
[13:20:00.214]                 is_error <- inherits(cond, "error")
[13:20:00.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.214]                   NULL)
[13:20:00.214]                 if (is_error) {
[13:20:00.214]                   sessionInformation <- function() {
[13:20:00.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.214]                       search = base::search(), system = base::Sys.info())
[13:20:00.214]                   }
[13:20:00.214]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.214]                     cond$call), session = sessionInformation(), 
[13:20:00.214]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.214]                   signalCondition(cond)
[13:20:00.214]                 }
[13:20:00.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.214]                 "immediateCondition"))) {
[13:20:00.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.214]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.214]                   if (TRUE && !signal) {
[13:20:00.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.214]                     {
[13:20:00.214]                       inherits <- base::inherits
[13:20:00.214]                       invokeRestart <- base::invokeRestart
[13:20:00.214]                       is.null <- base::is.null
[13:20:00.214]                       muffled <- FALSE
[13:20:00.214]                       if (inherits(cond, "message")) {
[13:20:00.214]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.214]                         if (muffled) 
[13:20:00.214]                           invokeRestart("muffleMessage")
[13:20:00.214]                       }
[13:20:00.214]                       else if (inherits(cond, "warning")) {
[13:20:00.214]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.214]                         if (muffled) 
[13:20:00.214]                           invokeRestart("muffleWarning")
[13:20:00.214]                       }
[13:20:00.214]                       else if (inherits(cond, "condition")) {
[13:20:00.214]                         if (!is.null(pattern)) {
[13:20:00.214]                           computeRestarts <- base::computeRestarts
[13:20:00.214]                           grepl <- base::grepl
[13:20:00.214]                           restarts <- computeRestarts(cond)
[13:20:00.214]                           for (restart in restarts) {
[13:20:00.214]                             name <- restart$name
[13:20:00.214]                             if (is.null(name)) 
[13:20:00.214]                               next
[13:20:00.214]                             if (!grepl(pattern, name)) 
[13:20:00.214]                               next
[13:20:00.214]                             invokeRestart(restart)
[13:20:00.214]                             muffled <- TRUE
[13:20:00.214]                             break
[13:20:00.214]                           }
[13:20:00.214]                         }
[13:20:00.214]                       }
[13:20:00.214]                       invisible(muffled)
[13:20:00.214]                     }
[13:20:00.214]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.214]                   }
[13:20:00.214]                 }
[13:20:00.214]                 else {
[13:20:00.214]                   if (TRUE) {
[13:20:00.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.214]                     {
[13:20:00.214]                       inherits <- base::inherits
[13:20:00.214]                       invokeRestart <- base::invokeRestart
[13:20:00.214]                       is.null <- base::is.null
[13:20:00.214]                       muffled <- FALSE
[13:20:00.214]                       if (inherits(cond, "message")) {
[13:20:00.214]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.214]                         if (muffled) 
[13:20:00.214]                           invokeRestart("muffleMessage")
[13:20:00.214]                       }
[13:20:00.214]                       else if (inherits(cond, "warning")) {
[13:20:00.214]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.214]                         if (muffled) 
[13:20:00.214]                           invokeRestart("muffleWarning")
[13:20:00.214]                       }
[13:20:00.214]                       else if (inherits(cond, "condition")) {
[13:20:00.214]                         if (!is.null(pattern)) {
[13:20:00.214]                           computeRestarts <- base::computeRestarts
[13:20:00.214]                           grepl <- base::grepl
[13:20:00.214]                           restarts <- computeRestarts(cond)
[13:20:00.214]                           for (restart in restarts) {
[13:20:00.214]                             name <- restart$name
[13:20:00.214]                             if (is.null(name)) 
[13:20:00.214]                               next
[13:20:00.214]                             if (!grepl(pattern, name)) 
[13:20:00.214]                               next
[13:20:00.214]                             invokeRestart(restart)
[13:20:00.214]                             muffled <- TRUE
[13:20:00.214]                             break
[13:20:00.214]                           }
[13:20:00.214]                         }
[13:20:00.214]                       }
[13:20:00.214]                       invisible(muffled)
[13:20:00.214]                     }
[13:20:00.214]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.214]                   }
[13:20:00.214]                 }
[13:20:00.214]             }
[13:20:00.214]         }))
[13:20:00.214]     }, error = function(ex) {
[13:20:00.214]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.214]                 ...future.rng), started = ...future.startTime, 
[13:20:00.214]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.214]             version = "1.8"), class = "FutureResult")
[13:20:00.214]     }, finally = {
[13:20:00.214]         if (!identical(...future.workdir, getwd())) 
[13:20:00.214]             setwd(...future.workdir)
[13:20:00.214]         {
[13:20:00.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.214]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.214]             }
[13:20:00.214]             base::options(...future.oldOptions)
[13:20:00.214]             if (.Platform$OS.type == "windows") {
[13:20:00.214]                 old_names <- names(...future.oldEnvVars)
[13:20:00.214]                 envs <- base::Sys.getenv()
[13:20:00.214]                 names <- names(envs)
[13:20:00.214]                 common <- intersect(names, old_names)
[13:20:00.214]                 added <- setdiff(names, old_names)
[13:20:00.214]                 removed <- setdiff(old_names, names)
[13:20:00.214]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.214]                   envs[common]]
[13:20:00.214]                 NAMES <- toupper(changed)
[13:20:00.214]                 args <- list()
[13:20:00.214]                 for (kk in seq_along(NAMES)) {
[13:20:00.214]                   name <- changed[[kk]]
[13:20:00.214]                   NAME <- NAMES[[kk]]
[13:20:00.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.214]                     next
[13:20:00.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.214]                 }
[13:20:00.214]                 NAMES <- toupper(added)
[13:20:00.214]                 for (kk in seq_along(NAMES)) {
[13:20:00.214]                   name <- added[[kk]]
[13:20:00.214]                   NAME <- NAMES[[kk]]
[13:20:00.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.214]                     next
[13:20:00.214]                   args[[name]] <- ""
[13:20:00.214]                 }
[13:20:00.214]                 NAMES <- toupper(removed)
[13:20:00.214]                 for (kk in seq_along(NAMES)) {
[13:20:00.214]                   name <- removed[[kk]]
[13:20:00.214]                   NAME <- NAMES[[kk]]
[13:20:00.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.214]                     next
[13:20:00.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.214]                 }
[13:20:00.214]                 if (length(args) > 0) 
[13:20:00.214]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.214]             }
[13:20:00.214]             else {
[13:20:00.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.214]             }
[13:20:00.214]             {
[13:20:00.214]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.214]                   0L) {
[13:20:00.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.214]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.214]                   base::options(opts)
[13:20:00.214]                 }
[13:20:00.214]                 {
[13:20:00.214]                   {
[13:20:00.214]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.214]                     NULL
[13:20:00.214]                   }
[13:20:00.214]                   options(future.plan = NULL)
[13:20:00.214]                   if (is.na(NA_character_)) 
[13:20:00.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.214]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.214]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.214]                     envir = parent.frame()) 
[13:20:00.214]                   {
[13:20:00.214]                     if (is.function(workers)) 
[13:20:00.214]                       workers <- workers()
[13:20:00.214]                     workers <- structure(as.integer(workers), 
[13:20:00.214]                       class = class(workers))
[13:20:00.214]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.214]                       workers >= 1)
[13:20:00.214]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.214]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.214]                     }
[13:20:00.214]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.214]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.214]                       envir = envir)
[13:20:00.214]                     if (!future$lazy) 
[13:20:00.214]                       future <- run(future)
[13:20:00.214]                     invisible(future)
[13:20:00.214]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.214]                 }
[13:20:00.214]             }
[13:20:00.214]         }
[13:20:00.214]     })
[13:20:00.214]     if (TRUE) {
[13:20:00.214]         base::sink(type = "output", split = FALSE)
[13:20:00.214]         if (TRUE) {
[13:20:00.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.214]         }
[13:20:00.214]         else {
[13:20:00.214]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.214]         }
[13:20:00.214]         base::close(...future.stdout)
[13:20:00.214]         ...future.stdout <- NULL
[13:20:00.214]     }
[13:20:00.214]     ...future.result$conditions <- ...future.conditions
[13:20:00.214]     ...future.result$finished <- base::Sys.time()
[13:20:00.214]     ...future.result
[13:20:00.214] }
[13:20:00.217] Exporting 5 global objects (0.99 KiB) to cluster node #2 ...
[13:20:00.218] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:00.218] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.218] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:20:00.218] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:20:00.219] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:20:00.219] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:20:00.219] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:00.219] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.219] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:20:00.220] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:20:00.220] Exporting 5 global objects (0.99 KiB) to cluster node #2 ... DONE
[13:20:00.220] MultisessionFuture started
[13:20:00.220] - Launch lazy future ... done
[13:20:00.221] run() for ‘MultisessionFuture’ ... done
[13:20:00.221] Created future:
[13:20:00.221] MultisessionFuture:
[13:20:00.221] Label: ‘future_apply-2’
[13:20:00.221] Expression:
[13:20:00.221] {
[13:20:00.221]     do.call(function(...) {
[13:20:00.221]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.221]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.221]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.221]             on.exit(options(oopts), add = TRUE)
[13:20:00.221]         }
[13:20:00.221]         {
[13:20:00.221]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.221]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.221]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.221]             })
[13:20:00.221]         }
[13:20:00.221]     }, args = future.call.arguments)
[13:20:00.221] }
[13:20:00.221] Lazy evaluation: FALSE
[13:20:00.221] Asynchronous evaluation: TRUE
[13:20:00.221] Local evaluation: TRUE
[13:20:00.221] Environment: R_GlobalEnv
[13:20:00.221] Capture standard output: TRUE
[13:20:00.221] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.221] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.221] Packages: <none>
[13:20:00.221] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.221] Resolved: FALSE
[13:20:00.221] Value: <not collected>
[13:20:00.221] Conditions captured: <none>
[13:20:00.221] Early signaling: FALSE
[13:20:00.221] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.221] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.232] Chunk #2 of 2 ... DONE
[13:20:00.232] Launching 2 futures (chunks) ... DONE
[13:20:00.233] Resolving 2 futures (chunks) ...
[13:20:00.233] resolve() on list ...
[13:20:00.233]  recursive: 0
[13:20:00.233]  length: 2
[13:20:00.233] 
[13:20:00.234] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.234] - Validating connection of MultisessionFuture
[13:20:00.234] - received message: FutureResult
[13:20:00.234] - Received FutureResult
[13:20:00.234] - Erased future from FutureRegistry
[13:20:00.234] result() for ClusterFuture ...
[13:20:00.234] - result already collected: FutureResult
[13:20:00.234] result() for ClusterFuture ... done
[13:20:00.235] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.235] Future #1
[13:20:00.235] result() for ClusterFuture ...
[13:20:00.235] - result already collected: FutureResult
[13:20:00.235] result() for ClusterFuture ... done
[13:20:00.235] result() for ClusterFuture ...
[13:20:00.235] - result already collected: FutureResult
[13:20:00.235] result() for ClusterFuture ... done
[13:20:00.235] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:00.235] - nx: 2
[13:20:00.235] - relay: TRUE
[13:20:00.236] - stdout: TRUE
[13:20:00.236] - signal: TRUE
[13:20:00.236] - resignal: FALSE
[13:20:00.236] - force: TRUE
[13:20:00.236] - relayed: [n=2] FALSE, FALSE
[13:20:00.236] - queued futures: [n=2] FALSE, FALSE
[13:20:00.236]  - until=1
[13:20:00.236]  - relaying element #1
[13:20:00.236] result() for ClusterFuture ...
[13:20:00.236] - result already collected: FutureResult
[13:20:00.236] result() for ClusterFuture ... done
[13:20:00.237] result() for ClusterFuture ...
[13:20:00.237] - result already collected: FutureResult
[13:20:00.237] result() for ClusterFuture ... done
[13:20:00.237] result() for ClusterFuture ...
[13:20:00.237] - result already collected: FutureResult
[13:20:00.237] result() for ClusterFuture ... done
[13:20:00.237] result() for ClusterFuture ...
[13:20:00.237] - result already collected: FutureResult
[13:20:00.237] result() for ClusterFuture ... done
[13:20:00.237] - relayed: [n=2] TRUE, FALSE
[13:20:00.237] - queued futures: [n=2] TRUE, FALSE
[13:20:00.238] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:00.238]  length: 1 (resolved future 1)
[13:20:00.269] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.269] - Validating connection of MultisessionFuture
[13:20:00.269] - received message: FutureResult
[13:20:00.269] - Received FutureResult
[13:20:00.269] - Erased future from FutureRegistry
[13:20:00.270] result() for ClusterFuture ...
[13:20:00.270] - result already collected: FutureResult
[13:20:00.270] result() for ClusterFuture ... done
[13:20:00.270] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.270] Future #2
[13:20:00.270] result() for ClusterFuture ...
[13:20:00.270] - result already collected: FutureResult
[13:20:00.270] result() for ClusterFuture ... done
[13:20:00.270] result() for ClusterFuture ...
[13:20:00.270] - result already collected: FutureResult
[13:20:00.270] result() for ClusterFuture ... done
[13:20:00.271] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:00.271] - nx: 2
[13:20:00.271] - relay: TRUE
[13:20:00.271] - stdout: TRUE
[13:20:00.271] - signal: TRUE
[13:20:00.271] - resignal: FALSE
[13:20:00.271] - force: TRUE
[13:20:00.271] - relayed: [n=2] TRUE, FALSE
[13:20:00.271] - queued futures: [n=2] TRUE, FALSE
[13:20:00.271]  - until=2
[13:20:00.271]  - relaying element #2
[13:20:00.272] result() for ClusterFuture ...
[13:20:00.272] - result already collected: FutureResult
[13:20:00.272] result() for ClusterFuture ... done
[13:20:00.272] result() for ClusterFuture ...
[13:20:00.272] - result already collected: FutureResult
[13:20:00.272] result() for ClusterFuture ... done
[13:20:00.272] result() for ClusterFuture ...
[13:20:00.272] - result already collected: FutureResult
[13:20:00.272] result() for ClusterFuture ... done
[13:20:00.272] result() for ClusterFuture ...
[13:20:00.272] - result already collected: FutureResult
[13:20:00.273] result() for ClusterFuture ... done
[13:20:00.273] - relayed: [n=2] TRUE, TRUE
[13:20:00.273] - queued futures: [n=2] TRUE, TRUE
[13:20:00.273] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:00.273]  length: 0 (resolved future 2)
[13:20:00.273] Relaying remaining futures
[13:20:00.273] signalConditionsASAP(NULL, pos=0) ...
[13:20:00.273] - nx: 2
[13:20:00.273] - relay: TRUE
[13:20:00.273] - stdout: TRUE
[13:20:00.273] - signal: TRUE
[13:20:00.274] - resignal: FALSE
[13:20:00.274] - force: TRUE
[13:20:00.274] - relayed: [n=2] TRUE, TRUE
[13:20:00.274] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:00.274] - relayed: [n=2] TRUE, TRUE
[13:20:00.274] - queued futures: [n=2] TRUE, TRUE
[13:20:00.274] signalConditionsASAP(NULL, pos=0) ... done
[13:20:00.274] resolve() on list ... DONE
[13:20:00.274] result() for ClusterFuture ...
[13:20:00.274] - result already collected: FutureResult
[13:20:00.274] result() for ClusterFuture ... done
[13:20:00.275] result() for ClusterFuture ...
[13:20:00.275] - result already collected: FutureResult
[13:20:00.275] result() for ClusterFuture ... done
[13:20:00.275] result() for ClusterFuture ...
[13:20:00.275] - result already collected: FutureResult
[13:20:00.275] result() for ClusterFuture ... done
[13:20:00.275] result() for ClusterFuture ...
[13:20:00.275] - result already collected: FutureResult
[13:20:00.275] result() for ClusterFuture ... done
[13:20:00.275]  - Number of value chunks collected: 2
[13:20:00.275] Resolving 2 futures (chunks) ... DONE
[13:20:00.276] Reducing values from 2 chunks ...
[13:20:00.276]  - Number of values collected after concatenation: 2
[13:20:00.276]  - Number of values expected: 2
[13:20:00.276] Reducing values from 2 chunks ... DONE
[13:20:00.276] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[13:20:00.276] getGlobalsAndPackagesXApply() ...
[13:20:00.276]  - future.globals: TRUE
[13:20:00.277] getGlobalsAndPackages() ...
[13:20:00.277] Searching for globals...
[13:20:00.278] - globals found: [1] ‘FUN’
[13:20:00.278] Searching for globals ... DONE
[13:20:00.278] Resolving globals: FALSE
[13:20:00.278] The total size of the 1 globals is 848 bytes (848 bytes)
[13:20:00.279] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:20:00.279] - globals: [1] ‘FUN’
[13:20:00.279] 
[13:20:00.279] getGlobalsAndPackages() ... DONE
[13:20:00.279]  - globals found/used: [n=1] ‘FUN’
[13:20:00.279]  - needed namespaces: [n=0] 
[13:20:00.279] Finding globals ... DONE
[13:20:00.279]  - use_args: TRUE
[13:20:00.279]  - Getting '...' globals ...
[13:20:00.280] resolve() on list ...
[13:20:00.280]  recursive: 0
[13:20:00.280]  length: 1
[13:20:00.280]  elements: ‘...’
[13:20:00.280]  length: 0 (resolved future 1)
[13:20:00.280] resolve() on list ... DONE
[13:20:00.280]    - '...' content: [n=0] 
[13:20:00.281] List of 1
[13:20:00.281]  $ ...: list()
[13:20:00.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.281]  - attr(*, "where")=List of 1
[13:20:00.281]   ..$ ...:<environment: 0x555923e88588> 
[13:20:00.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.281]  - attr(*, "resolved")= logi TRUE
[13:20:00.281]  - attr(*, "total_size")= num NA
[13:20:00.283]  - Getting '...' globals ... DONE
[13:20:00.283] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:00.283] List of 2
[13:20:00.283]  $ ...future.FUN:function (x)  
[13:20:00.283]  $ ...          : list()
[13:20:00.283]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.283]  - attr(*, "where")=List of 2
[13:20:00.283]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:00.283]   ..$ ...          :<environment: 0x555923e88588> 
[13:20:00.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.283]  - attr(*, "resolved")= logi FALSE
[13:20:00.283]  - attr(*, "total_size")= num 848
[13:20:00.286] Packages to be attached in all futures: [n=0] 
[13:20:00.286] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.290] future_lapply() ...
[13:20:00.294] Number of chunks: 2
[13:20:00.294] getGlobalsAndPackagesXApply() ...
[13:20:00.294]  - future.globals: <name-value list> with names ‘list()’
[13:20:00.294]  - use_args: TRUE
[13:20:00.294] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:20:00.294] List of 2
[13:20:00.294]  $ ...          : list()
[13:20:00.294]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.294]  $ ...future.FUN:function (x)  
[13:20:00.294]  - attr(*, "where")=List of 2
[13:20:00.294]   ..$ ...          :<environment: 0x555923e88588> 
[13:20:00.294]   ..$ ...future.FUN:<environment: namespace:base> 
[13:20:00.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.294]  - attr(*, "resolved")= logi FALSE
[13:20:00.294]  - attr(*, "total_size")= num NA
[13:20:00.298] Packages to be attached in all futures: [n=0] 
[13:20:00.298] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.298] Number of futures (= number of chunks): 2
[13:20:00.298] Launching 2 futures (chunks) ...
[13:20:00.298] Chunk #1 of 2 ...
[13:20:00.298]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.299]  - seeds: <none>
[13:20:00.299]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.299] getGlobalsAndPackages() ...
[13:20:00.299] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.299] Resolving globals: FALSE
[13:20:00.299] Tweak future expression to call with '...' arguments ...
[13:20:00.299] {
[13:20:00.299]     do.call(function(...) {
[13:20:00.299]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.299]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.299]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.299]             on.exit(options(oopts), add = TRUE)
[13:20:00.299]         }
[13:20:00.299]         {
[13:20:00.299]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.299]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.299]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.299]             })
[13:20:00.299]         }
[13:20:00.299]     }, args = future.call.arguments)
[13:20:00.299] }
[13:20:00.299] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.300] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.300] 
[13:20:00.300] getGlobalsAndPackages() ... DONE
[13:20:00.300] run() for ‘Future’ ...
[13:20:00.301] - state: ‘created’
[13:20:00.301] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.315] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.315] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.315]   - Field: ‘node’
[13:20:00.315]   - Field: ‘label’
[13:20:00.315]   - Field: ‘local’
[13:20:00.315]   - Field: ‘owner’
[13:20:00.316]   - Field: ‘envir’
[13:20:00.316]   - Field: ‘workers’
[13:20:00.316]   - Field: ‘packages’
[13:20:00.316]   - Field: ‘gc’
[13:20:00.316]   - Field: ‘conditions’
[13:20:00.316]   - Field: ‘persistent’
[13:20:00.316]   - Field: ‘expr’
[13:20:00.316]   - Field: ‘uuid’
[13:20:00.316]   - Field: ‘seed’
[13:20:00.316]   - Field: ‘version’
[13:20:00.316]   - Field: ‘result’
[13:20:00.317]   - Field: ‘asynchronous’
[13:20:00.317]   - Field: ‘calls’
[13:20:00.317]   - Field: ‘globals’
[13:20:00.317]   - Field: ‘stdout’
[13:20:00.317]   - Field: ‘earlySignal’
[13:20:00.317]   - Field: ‘lazy’
[13:20:00.317]   - Field: ‘state’
[13:20:00.317] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.317] - Launch lazy future ...
[13:20:00.318] Packages needed by the future expression (n = 0): <none>
[13:20:00.318] Packages needed by future strategies (n = 0): <none>
[13:20:00.318] {
[13:20:00.318]     {
[13:20:00.318]         {
[13:20:00.318]             ...future.startTime <- base::Sys.time()
[13:20:00.318]             {
[13:20:00.318]                 {
[13:20:00.318]                   {
[13:20:00.318]                     {
[13:20:00.318]                       base::local({
[13:20:00.318]                         has_future <- base::requireNamespace("future", 
[13:20:00.318]                           quietly = TRUE)
[13:20:00.318]                         if (has_future) {
[13:20:00.318]                           ns <- base::getNamespace("future")
[13:20:00.318]                           version <- ns[[".package"]][["version"]]
[13:20:00.318]                           if (is.null(version)) 
[13:20:00.318]                             version <- utils::packageVersion("future")
[13:20:00.318]                         }
[13:20:00.318]                         else {
[13:20:00.318]                           version <- NULL
[13:20:00.318]                         }
[13:20:00.318]                         if (!has_future || version < "1.8.0") {
[13:20:00.318]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.318]                             "", base::R.version$version.string), 
[13:20:00.318]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.318]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.318]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.318]                               "release", "version")], collapse = " "), 
[13:20:00.318]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.318]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.318]                             info)
[13:20:00.318]                           info <- base::paste(info, collapse = "; ")
[13:20:00.318]                           if (!has_future) {
[13:20:00.318]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.318]                               info)
[13:20:00.318]                           }
[13:20:00.318]                           else {
[13:20:00.318]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.318]                               info, version)
[13:20:00.318]                           }
[13:20:00.318]                           base::stop(msg)
[13:20:00.318]                         }
[13:20:00.318]                       })
[13:20:00.318]                     }
[13:20:00.318]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.318]                     base::options(mc.cores = 1L)
[13:20:00.318]                   }
[13:20:00.318]                   options(future.plan = NULL)
[13:20:00.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.318]                 }
[13:20:00.318]                 ...future.workdir <- getwd()
[13:20:00.318]             }
[13:20:00.318]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.318]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.318]         }
[13:20:00.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.318]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.318]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.318]             base::names(...future.oldOptions))
[13:20:00.318]     }
[13:20:00.318]     if (FALSE) {
[13:20:00.318]     }
[13:20:00.318]     else {
[13:20:00.318]         if (TRUE) {
[13:20:00.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.318]                 open = "w")
[13:20:00.318]         }
[13:20:00.318]         else {
[13:20:00.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.318]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.318]         }
[13:20:00.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.318]             base::sink(type = "output", split = FALSE)
[13:20:00.318]             base::close(...future.stdout)
[13:20:00.318]         }, add = TRUE)
[13:20:00.318]     }
[13:20:00.318]     ...future.frame <- base::sys.nframe()
[13:20:00.318]     ...future.conditions <- base::list()
[13:20:00.318]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.318]     if (FALSE) {
[13:20:00.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.318]     }
[13:20:00.318]     ...future.result <- base::tryCatch({
[13:20:00.318]         base::withCallingHandlers({
[13:20:00.318]             ...future.value <- base::withVisible(base::local({
[13:20:00.318]                 ...future.makeSendCondition <- base::local({
[13:20:00.318]                   sendCondition <- NULL
[13:20:00.318]                   function(frame = 1L) {
[13:20:00.318]                     if (is.function(sendCondition)) 
[13:20:00.318]                       return(sendCondition)
[13:20:00.318]                     ns <- getNamespace("parallel")
[13:20:00.318]                     if (exists("sendData", mode = "function", 
[13:20:00.318]                       envir = ns)) {
[13:20:00.318]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.318]                         envir = ns)
[13:20:00.318]                       envir <- sys.frame(frame)
[13:20:00.318]                       master <- NULL
[13:20:00.318]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.318]                         !identical(envir, emptyenv())) {
[13:20:00.318]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.318]                           inherits = FALSE)) {
[13:20:00.318]                           master <- get("master", mode = "list", 
[13:20:00.318]                             envir = envir, inherits = FALSE)
[13:20:00.318]                           if (inherits(master, c("SOCKnode", 
[13:20:00.318]                             "SOCK0node"))) {
[13:20:00.318]                             sendCondition <<- function(cond) {
[13:20:00.318]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.318]                                 success = TRUE)
[13:20:00.318]                               parallel_sendData(master, data)
[13:20:00.318]                             }
[13:20:00.318]                             return(sendCondition)
[13:20:00.318]                           }
[13:20:00.318]                         }
[13:20:00.318]                         frame <- frame + 1L
[13:20:00.318]                         envir <- sys.frame(frame)
[13:20:00.318]                       }
[13:20:00.318]                     }
[13:20:00.318]                     sendCondition <<- function(cond) NULL
[13:20:00.318]                   }
[13:20:00.318]                 })
[13:20:00.318]                 withCallingHandlers({
[13:20:00.318]                   {
[13:20:00.318]                     do.call(function(...) {
[13:20:00.318]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.318]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.318]                         ...future.globals.maxSize)) {
[13:20:00.318]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.318]                         on.exit(options(oopts), add = TRUE)
[13:20:00.318]                       }
[13:20:00.318]                       {
[13:20:00.318]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.318]                           FUN = function(jj) {
[13:20:00.318]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.318]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.318]                           })
[13:20:00.318]                       }
[13:20:00.318]                     }, args = future.call.arguments)
[13:20:00.318]                   }
[13:20:00.318]                 }, immediateCondition = function(cond) {
[13:20:00.318]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.318]                   sendCondition(cond)
[13:20:00.318]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.318]                   {
[13:20:00.318]                     inherits <- base::inherits
[13:20:00.318]                     invokeRestart <- base::invokeRestart
[13:20:00.318]                     is.null <- base::is.null
[13:20:00.318]                     muffled <- FALSE
[13:20:00.318]                     if (inherits(cond, "message")) {
[13:20:00.318]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.318]                       if (muffled) 
[13:20:00.318]                         invokeRestart("muffleMessage")
[13:20:00.318]                     }
[13:20:00.318]                     else if (inherits(cond, "warning")) {
[13:20:00.318]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.318]                       if (muffled) 
[13:20:00.318]                         invokeRestart("muffleWarning")
[13:20:00.318]                     }
[13:20:00.318]                     else if (inherits(cond, "condition")) {
[13:20:00.318]                       if (!is.null(pattern)) {
[13:20:00.318]                         computeRestarts <- base::computeRestarts
[13:20:00.318]                         grepl <- base::grepl
[13:20:00.318]                         restarts <- computeRestarts(cond)
[13:20:00.318]                         for (restart in restarts) {
[13:20:00.318]                           name <- restart$name
[13:20:00.318]                           if (is.null(name)) 
[13:20:00.318]                             next
[13:20:00.318]                           if (!grepl(pattern, name)) 
[13:20:00.318]                             next
[13:20:00.318]                           invokeRestart(restart)
[13:20:00.318]                           muffled <- TRUE
[13:20:00.318]                           break
[13:20:00.318]                         }
[13:20:00.318]                       }
[13:20:00.318]                     }
[13:20:00.318]                     invisible(muffled)
[13:20:00.318]                   }
[13:20:00.318]                   muffleCondition(cond)
[13:20:00.318]                 })
[13:20:00.318]             }))
[13:20:00.318]             future::FutureResult(value = ...future.value$value, 
[13:20:00.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.318]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.318]                     ...future.globalenv.names))
[13:20:00.318]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.318]         }, condition = base::local({
[13:20:00.318]             c <- base::c
[13:20:00.318]             inherits <- base::inherits
[13:20:00.318]             invokeRestart <- base::invokeRestart
[13:20:00.318]             length <- base::length
[13:20:00.318]             list <- base::list
[13:20:00.318]             seq.int <- base::seq.int
[13:20:00.318]             signalCondition <- base::signalCondition
[13:20:00.318]             sys.calls <- base::sys.calls
[13:20:00.318]             `[[` <- base::`[[`
[13:20:00.318]             `+` <- base::`+`
[13:20:00.318]             `<<-` <- base::`<<-`
[13:20:00.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.318]                   3L)]
[13:20:00.318]             }
[13:20:00.318]             function(cond) {
[13:20:00.318]                 is_error <- inherits(cond, "error")
[13:20:00.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.318]                   NULL)
[13:20:00.318]                 if (is_error) {
[13:20:00.318]                   sessionInformation <- function() {
[13:20:00.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.318]                       search = base::search(), system = base::Sys.info())
[13:20:00.318]                   }
[13:20:00.318]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.318]                     cond$call), session = sessionInformation(), 
[13:20:00.318]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.318]                   signalCondition(cond)
[13:20:00.318]                 }
[13:20:00.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.318]                 "immediateCondition"))) {
[13:20:00.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.318]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.318]                   if (TRUE && !signal) {
[13:20:00.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.318]                     {
[13:20:00.318]                       inherits <- base::inherits
[13:20:00.318]                       invokeRestart <- base::invokeRestart
[13:20:00.318]                       is.null <- base::is.null
[13:20:00.318]                       muffled <- FALSE
[13:20:00.318]                       if (inherits(cond, "message")) {
[13:20:00.318]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.318]                         if (muffled) 
[13:20:00.318]                           invokeRestart("muffleMessage")
[13:20:00.318]                       }
[13:20:00.318]                       else if (inherits(cond, "warning")) {
[13:20:00.318]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.318]                         if (muffled) 
[13:20:00.318]                           invokeRestart("muffleWarning")
[13:20:00.318]                       }
[13:20:00.318]                       else if (inherits(cond, "condition")) {
[13:20:00.318]                         if (!is.null(pattern)) {
[13:20:00.318]                           computeRestarts <- base::computeRestarts
[13:20:00.318]                           grepl <- base::grepl
[13:20:00.318]                           restarts <- computeRestarts(cond)
[13:20:00.318]                           for (restart in restarts) {
[13:20:00.318]                             name <- restart$name
[13:20:00.318]                             if (is.null(name)) 
[13:20:00.318]                               next
[13:20:00.318]                             if (!grepl(pattern, name)) 
[13:20:00.318]                               next
[13:20:00.318]                             invokeRestart(restart)
[13:20:00.318]                             muffled <- TRUE
[13:20:00.318]                             break
[13:20:00.318]                           }
[13:20:00.318]                         }
[13:20:00.318]                       }
[13:20:00.318]                       invisible(muffled)
[13:20:00.318]                     }
[13:20:00.318]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.318]                   }
[13:20:00.318]                 }
[13:20:00.318]                 else {
[13:20:00.318]                   if (TRUE) {
[13:20:00.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.318]                     {
[13:20:00.318]                       inherits <- base::inherits
[13:20:00.318]                       invokeRestart <- base::invokeRestart
[13:20:00.318]                       is.null <- base::is.null
[13:20:00.318]                       muffled <- FALSE
[13:20:00.318]                       if (inherits(cond, "message")) {
[13:20:00.318]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.318]                         if (muffled) 
[13:20:00.318]                           invokeRestart("muffleMessage")
[13:20:00.318]                       }
[13:20:00.318]                       else if (inherits(cond, "warning")) {
[13:20:00.318]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.318]                         if (muffled) 
[13:20:00.318]                           invokeRestart("muffleWarning")
[13:20:00.318]                       }
[13:20:00.318]                       else if (inherits(cond, "condition")) {
[13:20:00.318]                         if (!is.null(pattern)) {
[13:20:00.318]                           computeRestarts <- base::computeRestarts
[13:20:00.318]                           grepl <- base::grepl
[13:20:00.318]                           restarts <- computeRestarts(cond)
[13:20:00.318]                           for (restart in restarts) {
[13:20:00.318]                             name <- restart$name
[13:20:00.318]                             if (is.null(name)) 
[13:20:00.318]                               next
[13:20:00.318]                             if (!grepl(pattern, name)) 
[13:20:00.318]                               next
[13:20:00.318]                             invokeRestart(restart)
[13:20:00.318]                             muffled <- TRUE
[13:20:00.318]                             break
[13:20:00.318]                           }
[13:20:00.318]                         }
[13:20:00.318]                       }
[13:20:00.318]                       invisible(muffled)
[13:20:00.318]                     }
[13:20:00.318]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.318]                   }
[13:20:00.318]                 }
[13:20:00.318]             }
[13:20:00.318]         }))
[13:20:00.318]     }, error = function(ex) {
[13:20:00.318]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.318]                 ...future.rng), started = ...future.startTime, 
[13:20:00.318]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.318]             version = "1.8"), class = "FutureResult")
[13:20:00.318]     }, finally = {
[13:20:00.318]         if (!identical(...future.workdir, getwd())) 
[13:20:00.318]             setwd(...future.workdir)
[13:20:00.318]         {
[13:20:00.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.318]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.318]             }
[13:20:00.318]             base::options(...future.oldOptions)
[13:20:00.318]             if (.Platform$OS.type == "windows") {
[13:20:00.318]                 old_names <- names(...future.oldEnvVars)
[13:20:00.318]                 envs <- base::Sys.getenv()
[13:20:00.318]                 names <- names(envs)
[13:20:00.318]                 common <- intersect(names, old_names)
[13:20:00.318]                 added <- setdiff(names, old_names)
[13:20:00.318]                 removed <- setdiff(old_names, names)
[13:20:00.318]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.318]                   envs[common]]
[13:20:00.318]                 NAMES <- toupper(changed)
[13:20:00.318]                 args <- list()
[13:20:00.318]                 for (kk in seq_along(NAMES)) {
[13:20:00.318]                   name <- changed[[kk]]
[13:20:00.318]                   NAME <- NAMES[[kk]]
[13:20:00.318]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.318]                     next
[13:20:00.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.318]                 }
[13:20:00.318]                 NAMES <- toupper(added)
[13:20:00.318]                 for (kk in seq_along(NAMES)) {
[13:20:00.318]                   name <- added[[kk]]
[13:20:00.318]                   NAME <- NAMES[[kk]]
[13:20:00.318]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.318]                     next
[13:20:00.318]                   args[[name]] <- ""
[13:20:00.318]                 }
[13:20:00.318]                 NAMES <- toupper(removed)
[13:20:00.318]                 for (kk in seq_along(NAMES)) {
[13:20:00.318]                   name <- removed[[kk]]
[13:20:00.318]                   NAME <- NAMES[[kk]]
[13:20:00.318]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.318]                     next
[13:20:00.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.318]                 }
[13:20:00.318]                 if (length(args) > 0) 
[13:20:00.318]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.318]             }
[13:20:00.318]             else {
[13:20:00.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.318]             }
[13:20:00.318]             {
[13:20:00.318]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.318]                   0L) {
[13:20:00.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.318]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.318]                   base::options(opts)
[13:20:00.318]                 }
[13:20:00.318]                 {
[13:20:00.318]                   {
[13:20:00.318]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.318]                     NULL
[13:20:00.318]                   }
[13:20:00.318]                   options(future.plan = NULL)
[13:20:00.318]                   if (is.na(NA_character_)) 
[13:20:00.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.318]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.318]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.318]                     envir = parent.frame()) 
[13:20:00.318]                   {
[13:20:00.318]                     if (is.function(workers)) 
[13:20:00.318]                       workers <- workers()
[13:20:00.318]                     workers <- structure(as.integer(workers), 
[13:20:00.318]                       class = class(workers))
[13:20:00.318]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.318]                       workers >= 1)
[13:20:00.318]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.318]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.318]                     }
[13:20:00.318]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.318]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.318]                       envir = envir)
[13:20:00.318]                     if (!future$lazy) 
[13:20:00.318]                       future <- run(future)
[13:20:00.318]                     invisible(future)
[13:20:00.318]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.318]                 }
[13:20:00.318]             }
[13:20:00.318]         }
[13:20:00.318]     })
[13:20:00.318]     if (TRUE) {
[13:20:00.318]         base::sink(type = "output", split = FALSE)
[13:20:00.318]         if (TRUE) {
[13:20:00.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.318]         }
[13:20:00.318]         else {
[13:20:00.318]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.318]         }
[13:20:00.318]         base::close(...future.stdout)
[13:20:00.318]         ...future.stdout <- NULL
[13:20:00.318]     }
[13:20:00.318]     ...future.result$conditions <- ...future.conditions
[13:20:00.318]     ...future.result$finished <- base::Sys.time()
[13:20:00.318]     ...future.result
[13:20:00.318] }
[13:20:00.322] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:20:00.322] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:00.322] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.322] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:20:00.323] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:20:00.323] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[13:20:00.323] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[13:20:00.323] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:00.324] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.324] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:20:00.324] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.324] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:20:00.325] MultisessionFuture started
[13:20:00.325] - Launch lazy future ... done
[13:20:00.325] run() for ‘MultisessionFuture’ ... done
[13:20:00.326] Created future:
[13:20:00.326] MultisessionFuture:
[13:20:00.326] Label: ‘future_apply-1’
[13:20:00.326] Expression:
[13:20:00.326] {
[13:20:00.326]     do.call(function(...) {
[13:20:00.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.326]             on.exit(options(oopts), add = TRUE)
[13:20:00.326]         }
[13:20:00.326]         {
[13:20:00.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.326]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.326]             })
[13:20:00.326]         }
[13:20:00.326]     }, args = future.call.arguments)
[13:20:00.326] }
[13:20:00.326] Lazy evaluation: FALSE
[13:20:00.326] Asynchronous evaluation: TRUE
[13:20:00.326] Local evaluation: TRUE
[13:20:00.326] Environment: R_GlobalEnv
[13:20:00.326] Capture standard output: TRUE
[13:20:00.326] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.326] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.326] Packages: <none>
[13:20:00.326] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.326] Resolved: FALSE
[13:20:00.326] Value: <not collected>
[13:20:00.326] Conditions captured: <none>
[13:20:00.326] Early signaling: FALSE
[13:20:00.326] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.326] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.337] Chunk #1 of 2 ... DONE
[13:20:00.337] Chunk #2 of 2 ...
[13:20:00.338]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.338]  - seeds: <none>
[13:20:00.338]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.338] getGlobalsAndPackages() ...
[13:20:00.338] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.338] Resolving globals: FALSE
[13:20:00.341] Tweak future expression to call with '...' arguments ...
[13:20:00.341] {
[13:20:00.341]     do.call(function(...) {
[13:20:00.341]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.341]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.341]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.341]             on.exit(options(oopts), add = TRUE)
[13:20:00.341]         }
[13:20:00.341]         {
[13:20:00.341]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.341]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.341]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.341]             })
[13:20:00.341]         }
[13:20:00.341]     }, args = future.call.arguments)
[13:20:00.341] }
[13:20:00.341] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.341] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.342] 
[13:20:00.342] getGlobalsAndPackages() ... DONE
[13:20:00.342] run() for ‘Future’ ...
[13:20:00.342] - state: ‘created’
[13:20:00.342] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.357] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.357] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.357]   - Field: ‘node’
[13:20:00.357]   - Field: ‘label’
[13:20:00.357]   - Field: ‘local’
[13:20:00.357]   - Field: ‘owner’
[13:20:00.357]   - Field: ‘envir’
[13:20:00.357]   - Field: ‘workers’
[13:20:00.357]   - Field: ‘packages’
[13:20:00.357]   - Field: ‘gc’
[13:20:00.358]   - Field: ‘conditions’
[13:20:00.358]   - Field: ‘persistent’
[13:20:00.358]   - Field: ‘expr’
[13:20:00.358]   - Field: ‘uuid’
[13:20:00.358]   - Field: ‘seed’
[13:20:00.358]   - Field: ‘version’
[13:20:00.358]   - Field: ‘result’
[13:20:00.358]   - Field: ‘asynchronous’
[13:20:00.358]   - Field: ‘calls’
[13:20:00.358]   - Field: ‘globals’
[13:20:00.358]   - Field: ‘stdout’
[13:20:00.359]   - Field: ‘earlySignal’
[13:20:00.359]   - Field: ‘lazy’
[13:20:00.359]   - Field: ‘state’
[13:20:00.359] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.359] - Launch lazy future ...
[13:20:00.359] Packages needed by the future expression (n = 0): <none>
[13:20:00.359] Packages needed by future strategies (n = 0): <none>
[13:20:00.360] {
[13:20:00.360]     {
[13:20:00.360]         {
[13:20:00.360]             ...future.startTime <- base::Sys.time()
[13:20:00.360]             {
[13:20:00.360]                 {
[13:20:00.360]                   {
[13:20:00.360]                     {
[13:20:00.360]                       base::local({
[13:20:00.360]                         has_future <- base::requireNamespace("future", 
[13:20:00.360]                           quietly = TRUE)
[13:20:00.360]                         if (has_future) {
[13:20:00.360]                           ns <- base::getNamespace("future")
[13:20:00.360]                           version <- ns[[".package"]][["version"]]
[13:20:00.360]                           if (is.null(version)) 
[13:20:00.360]                             version <- utils::packageVersion("future")
[13:20:00.360]                         }
[13:20:00.360]                         else {
[13:20:00.360]                           version <- NULL
[13:20:00.360]                         }
[13:20:00.360]                         if (!has_future || version < "1.8.0") {
[13:20:00.360]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.360]                             "", base::R.version$version.string), 
[13:20:00.360]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.360]                               "release", "version")], collapse = " "), 
[13:20:00.360]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.360]                             info)
[13:20:00.360]                           info <- base::paste(info, collapse = "; ")
[13:20:00.360]                           if (!has_future) {
[13:20:00.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.360]                               info)
[13:20:00.360]                           }
[13:20:00.360]                           else {
[13:20:00.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.360]                               info, version)
[13:20:00.360]                           }
[13:20:00.360]                           base::stop(msg)
[13:20:00.360]                         }
[13:20:00.360]                       })
[13:20:00.360]                     }
[13:20:00.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.360]                     base::options(mc.cores = 1L)
[13:20:00.360]                   }
[13:20:00.360]                   options(future.plan = NULL)
[13:20:00.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.360]                 }
[13:20:00.360]                 ...future.workdir <- getwd()
[13:20:00.360]             }
[13:20:00.360]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.360]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.360]         }
[13:20:00.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.360]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.360]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.360]             base::names(...future.oldOptions))
[13:20:00.360]     }
[13:20:00.360]     if (FALSE) {
[13:20:00.360]     }
[13:20:00.360]     else {
[13:20:00.360]         if (TRUE) {
[13:20:00.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.360]                 open = "w")
[13:20:00.360]         }
[13:20:00.360]         else {
[13:20:00.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.360]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.360]         }
[13:20:00.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.360]             base::sink(type = "output", split = FALSE)
[13:20:00.360]             base::close(...future.stdout)
[13:20:00.360]         }, add = TRUE)
[13:20:00.360]     }
[13:20:00.360]     ...future.frame <- base::sys.nframe()
[13:20:00.360]     ...future.conditions <- base::list()
[13:20:00.360]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.360]     if (FALSE) {
[13:20:00.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.360]     }
[13:20:00.360]     ...future.result <- base::tryCatch({
[13:20:00.360]         base::withCallingHandlers({
[13:20:00.360]             ...future.value <- base::withVisible(base::local({
[13:20:00.360]                 ...future.makeSendCondition <- base::local({
[13:20:00.360]                   sendCondition <- NULL
[13:20:00.360]                   function(frame = 1L) {
[13:20:00.360]                     if (is.function(sendCondition)) 
[13:20:00.360]                       return(sendCondition)
[13:20:00.360]                     ns <- getNamespace("parallel")
[13:20:00.360]                     if (exists("sendData", mode = "function", 
[13:20:00.360]                       envir = ns)) {
[13:20:00.360]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.360]                         envir = ns)
[13:20:00.360]                       envir <- sys.frame(frame)
[13:20:00.360]                       master <- NULL
[13:20:00.360]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.360]                         !identical(envir, emptyenv())) {
[13:20:00.360]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.360]                           inherits = FALSE)) {
[13:20:00.360]                           master <- get("master", mode = "list", 
[13:20:00.360]                             envir = envir, inherits = FALSE)
[13:20:00.360]                           if (inherits(master, c("SOCKnode", 
[13:20:00.360]                             "SOCK0node"))) {
[13:20:00.360]                             sendCondition <<- function(cond) {
[13:20:00.360]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.360]                                 success = TRUE)
[13:20:00.360]                               parallel_sendData(master, data)
[13:20:00.360]                             }
[13:20:00.360]                             return(sendCondition)
[13:20:00.360]                           }
[13:20:00.360]                         }
[13:20:00.360]                         frame <- frame + 1L
[13:20:00.360]                         envir <- sys.frame(frame)
[13:20:00.360]                       }
[13:20:00.360]                     }
[13:20:00.360]                     sendCondition <<- function(cond) NULL
[13:20:00.360]                   }
[13:20:00.360]                 })
[13:20:00.360]                 withCallingHandlers({
[13:20:00.360]                   {
[13:20:00.360]                     do.call(function(...) {
[13:20:00.360]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.360]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.360]                         ...future.globals.maxSize)) {
[13:20:00.360]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.360]                         on.exit(options(oopts), add = TRUE)
[13:20:00.360]                       }
[13:20:00.360]                       {
[13:20:00.360]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.360]                           FUN = function(jj) {
[13:20:00.360]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.360]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.360]                           })
[13:20:00.360]                       }
[13:20:00.360]                     }, args = future.call.arguments)
[13:20:00.360]                   }
[13:20:00.360]                 }, immediateCondition = function(cond) {
[13:20:00.360]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.360]                   sendCondition(cond)
[13:20:00.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.360]                   {
[13:20:00.360]                     inherits <- base::inherits
[13:20:00.360]                     invokeRestart <- base::invokeRestart
[13:20:00.360]                     is.null <- base::is.null
[13:20:00.360]                     muffled <- FALSE
[13:20:00.360]                     if (inherits(cond, "message")) {
[13:20:00.360]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.360]                       if (muffled) 
[13:20:00.360]                         invokeRestart("muffleMessage")
[13:20:00.360]                     }
[13:20:00.360]                     else if (inherits(cond, "warning")) {
[13:20:00.360]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.360]                       if (muffled) 
[13:20:00.360]                         invokeRestart("muffleWarning")
[13:20:00.360]                     }
[13:20:00.360]                     else if (inherits(cond, "condition")) {
[13:20:00.360]                       if (!is.null(pattern)) {
[13:20:00.360]                         computeRestarts <- base::computeRestarts
[13:20:00.360]                         grepl <- base::grepl
[13:20:00.360]                         restarts <- computeRestarts(cond)
[13:20:00.360]                         for (restart in restarts) {
[13:20:00.360]                           name <- restart$name
[13:20:00.360]                           if (is.null(name)) 
[13:20:00.360]                             next
[13:20:00.360]                           if (!grepl(pattern, name)) 
[13:20:00.360]                             next
[13:20:00.360]                           invokeRestart(restart)
[13:20:00.360]                           muffled <- TRUE
[13:20:00.360]                           break
[13:20:00.360]                         }
[13:20:00.360]                       }
[13:20:00.360]                     }
[13:20:00.360]                     invisible(muffled)
[13:20:00.360]                   }
[13:20:00.360]                   muffleCondition(cond)
[13:20:00.360]                 })
[13:20:00.360]             }))
[13:20:00.360]             future::FutureResult(value = ...future.value$value, 
[13:20:00.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.360]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.360]                     ...future.globalenv.names))
[13:20:00.360]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.360]         }, condition = base::local({
[13:20:00.360]             c <- base::c
[13:20:00.360]             inherits <- base::inherits
[13:20:00.360]             invokeRestart <- base::invokeRestart
[13:20:00.360]             length <- base::length
[13:20:00.360]             list <- base::list
[13:20:00.360]             seq.int <- base::seq.int
[13:20:00.360]             signalCondition <- base::signalCondition
[13:20:00.360]             sys.calls <- base::sys.calls
[13:20:00.360]             `[[` <- base::`[[`
[13:20:00.360]             `+` <- base::`+`
[13:20:00.360]             `<<-` <- base::`<<-`
[13:20:00.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.360]                   3L)]
[13:20:00.360]             }
[13:20:00.360]             function(cond) {
[13:20:00.360]                 is_error <- inherits(cond, "error")
[13:20:00.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.360]                   NULL)
[13:20:00.360]                 if (is_error) {
[13:20:00.360]                   sessionInformation <- function() {
[13:20:00.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.360]                       search = base::search(), system = base::Sys.info())
[13:20:00.360]                   }
[13:20:00.360]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.360]                     cond$call), session = sessionInformation(), 
[13:20:00.360]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.360]                   signalCondition(cond)
[13:20:00.360]                 }
[13:20:00.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.360]                 "immediateCondition"))) {
[13:20:00.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.360]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.360]                   if (TRUE && !signal) {
[13:20:00.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.360]                     {
[13:20:00.360]                       inherits <- base::inherits
[13:20:00.360]                       invokeRestart <- base::invokeRestart
[13:20:00.360]                       is.null <- base::is.null
[13:20:00.360]                       muffled <- FALSE
[13:20:00.360]                       if (inherits(cond, "message")) {
[13:20:00.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.360]                         if (muffled) 
[13:20:00.360]                           invokeRestart("muffleMessage")
[13:20:00.360]                       }
[13:20:00.360]                       else if (inherits(cond, "warning")) {
[13:20:00.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.360]                         if (muffled) 
[13:20:00.360]                           invokeRestart("muffleWarning")
[13:20:00.360]                       }
[13:20:00.360]                       else if (inherits(cond, "condition")) {
[13:20:00.360]                         if (!is.null(pattern)) {
[13:20:00.360]                           computeRestarts <- base::computeRestarts
[13:20:00.360]                           grepl <- base::grepl
[13:20:00.360]                           restarts <- computeRestarts(cond)
[13:20:00.360]                           for (restart in restarts) {
[13:20:00.360]                             name <- restart$name
[13:20:00.360]                             if (is.null(name)) 
[13:20:00.360]                               next
[13:20:00.360]                             if (!grepl(pattern, name)) 
[13:20:00.360]                               next
[13:20:00.360]                             invokeRestart(restart)
[13:20:00.360]                             muffled <- TRUE
[13:20:00.360]                             break
[13:20:00.360]                           }
[13:20:00.360]                         }
[13:20:00.360]                       }
[13:20:00.360]                       invisible(muffled)
[13:20:00.360]                     }
[13:20:00.360]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.360]                   }
[13:20:00.360]                 }
[13:20:00.360]                 else {
[13:20:00.360]                   if (TRUE) {
[13:20:00.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.360]                     {
[13:20:00.360]                       inherits <- base::inherits
[13:20:00.360]                       invokeRestart <- base::invokeRestart
[13:20:00.360]                       is.null <- base::is.null
[13:20:00.360]                       muffled <- FALSE
[13:20:00.360]                       if (inherits(cond, "message")) {
[13:20:00.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.360]                         if (muffled) 
[13:20:00.360]                           invokeRestart("muffleMessage")
[13:20:00.360]                       }
[13:20:00.360]                       else if (inherits(cond, "warning")) {
[13:20:00.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.360]                         if (muffled) 
[13:20:00.360]                           invokeRestart("muffleWarning")
[13:20:00.360]                       }
[13:20:00.360]                       else if (inherits(cond, "condition")) {
[13:20:00.360]                         if (!is.null(pattern)) {
[13:20:00.360]                           computeRestarts <- base::computeRestarts
[13:20:00.360]                           grepl <- base::grepl
[13:20:00.360]                           restarts <- computeRestarts(cond)
[13:20:00.360]                           for (restart in restarts) {
[13:20:00.360]                             name <- restart$name
[13:20:00.360]                             if (is.null(name)) 
[13:20:00.360]                               next
[13:20:00.360]                             if (!grepl(pattern, name)) 
[13:20:00.360]                               next
[13:20:00.360]                             invokeRestart(restart)
[13:20:00.360]                             muffled <- TRUE
[13:20:00.360]                             break
[13:20:00.360]                           }
[13:20:00.360]                         }
[13:20:00.360]                       }
[13:20:00.360]                       invisible(muffled)
[13:20:00.360]                     }
[13:20:00.360]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.360]                   }
[13:20:00.360]                 }
[13:20:00.360]             }
[13:20:00.360]         }))
[13:20:00.360]     }, error = function(ex) {
[13:20:00.360]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.360]                 ...future.rng), started = ...future.startTime, 
[13:20:00.360]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.360]             version = "1.8"), class = "FutureResult")
[13:20:00.360]     }, finally = {
[13:20:00.360]         if (!identical(...future.workdir, getwd())) 
[13:20:00.360]             setwd(...future.workdir)
[13:20:00.360]         {
[13:20:00.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.360]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.360]             }
[13:20:00.360]             base::options(...future.oldOptions)
[13:20:00.360]             if (.Platform$OS.type == "windows") {
[13:20:00.360]                 old_names <- names(...future.oldEnvVars)
[13:20:00.360]                 envs <- base::Sys.getenv()
[13:20:00.360]                 names <- names(envs)
[13:20:00.360]                 common <- intersect(names, old_names)
[13:20:00.360]                 added <- setdiff(names, old_names)
[13:20:00.360]                 removed <- setdiff(old_names, names)
[13:20:00.360]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.360]                   envs[common]]
[13:20:00.360]                 NAMES <- toupper(changed)
[13:20:00.360]                 args <- list()
[13:20:00.360]                 for (kk in seq_along(NAMES)) {
[13:20:00.360]                   name <- changed[[kk]]
[13:20:00.360]                   NAME <- NAMES[[kk]]
[13:20:00.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.360]                     next
[13:20:00.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.360]                 }
[13:20:00.360]                 NAMES <- toupper(added)
[13:20:00.360]                 for (kk in seq_along(NAMES)) {
[13:20:00.360]                   name <- added[[kk]]
[13:20:00.360]                   NAME <- NAMES[[kk]]
[13:20:00.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.360]                     next
[13:20:00.360]                   args[[name]] <- ""
[13:20:00.360]                 }
[13:20:00.360]                 NAMES <- toupper(removed)
[13:20:00.360]                 for (kk in seq_along(NAMES)) {
[13:20:00.360]                   name <- removed[[kk]]
[13:20:00.360]                   NAME <- NAMES[[kk]]
[13:20:00.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.360]                     next
[13:20:00.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.360]                 }
[13:20:00.360]                 if (length(args) > 0) 
[13:20:00.360]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.360]             }
[13:20:00.360]             else {
[13:20:00.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.360]             }
[13:20:00.360]             {
[13:20:00.360]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.360]                   0L) {
[13:20:00.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.360]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.360]                   base::options(opts)
[13:20:00.360]                 }
[13:20:00.360]                 {
[13:20:00.360]                   {
[13:20:00.360]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.360]                     NULL
[13:20:00.360]                   }
[13:20:00.360]                   options(future.plan = NULL)
[13:20:00.360]                   if (is.na(NA_character_)) 
[13:20:00.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.360]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.360]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.360]                     envir = parent.frame()) 
[13:20:00.360]                   {
[13:20:00.360]                     if (is.function(workers)) 
[13:20:00.360]                       workers <- workers()
[13:20:00.360]                     workers <- structure(as.integer(workers), 
[13:20:00.360]                       class = class(workers))
[13:20:00.360]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.360]                       workers >= 1)
[13:20:00.360]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.360]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.360]                     }
[13:20:00.360]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.360]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.360]                       envir = envir)
[13:20:00.360]                     if (!future$lazy) 
[13:20:00.360]                       future <- run(future)
[13:20:00.360]                     invisible(future)
[13:20:00.360]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.360]                 }
[13:20:00.360]             }
[13:20:00.360]         }
[13:20:00.360]     })
[13:20:00.360]     if (TRUE) {
[13:20:00.360]         base::sink(type = "output", split = FALSE)
[13:20:00.360]         if (TRUE) {
[13:20:00.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.360]         }
[13:20:00.360]         else {
[13:20:00.360]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.360]         }
[13:20:00.360]         base::close(...future.stdout)
[13:20:00.360]         ...future.stdout <- NULL
[13:20:00.360]     }
[13:20:00.360]     ...future.result$conditions <- ...future.conditions
[13:20:00.360]     ...future.result$finished <- base::Sys.time()
[13:20:00.360]     ...future.result
[13:20:00.360] }
[13:20:00.363] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:20:00.363] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:00.364] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.364] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:20:00.364] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:20:00.364] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[13:20:00.365] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[13:20:00.365] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:00.365] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.365] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:20:00.366] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:20:00.366] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:20:00.366] MultisessionFuture started
[13:20:00.366] - Launch lazy future ... done
[13:20:00.366] run() for ‘MultisessionFuture’ ... done
[13:20:00.366] Created future:
[13:20:00.367] MultisessionFuture:
[13:20:00.367] Label: ‘future_apply-2’
[13:20:00.367] Expression:
[13:20:00.367] {
[13:20:00.367]     do.call(function(...) {
[13:20:00.367]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.367]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.367]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.367]             on.exit(options(oopts), add = TRUE)
[13:20:00.367]         }
[13:20:00.367]         {
[13:20:00.367]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.367]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.367]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.367]             })
[13:20:00.367]         }
[13:20:00.367]     }, args = future.call.arguments)
[13:20:00.367] }
[13:20:00.367] Lazy evaluation: FALSE
[13:20:00.367] Asynchronous evaluation: TRUE
[13:20:00.367] Local evaluation: TRUE
[13:20:00.367] Environment: R_GlobalEnv
[13:20:00.367] Capture standard output: TRUE
[13:20:00.367] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.367] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.367] Packages: <none>
[13:20:00.367] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.367] Resolved: FALSE
[13:20:00.367] Value: <not collected>
[13:20:00.367] Conditions captured: <none>
[13:20:00.367] Early signaling: FALSE
[13:20:00.367] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.367] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.378] Chunk #2 of 2 ... DONE
[13:20:00.378] Launching 2 futures (chunks) ... DONE
[13:20:00.378] Resolving 2 futures (chunks) ...
[13:20:00.379] resolve() on list ...
[13:20:00.379]  recursive: 0
[13:20:00.379]  length: 2
[13:20:00.379] 
[13:20:00.379] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.380] - Validating connection of MultisessionFuture
[13:20:00.380] - received message: FutureResult
[13:20:00.380] - Received FutureResult
[13:20:00.380] - Erased future from FutureRegistry
[13:20:00.380] result() for ClusterFuture ...
[13:20:00.380] - result already collected: FutureResult
[13:20:00.380] result() for ClusterFuture ... done
[13:20:00.380] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.380] Future #1
[13:20:00.381] result() for ClusterFuture ...
[13:20:00.381] - result already collected: FutureResult
[13:20:00.381] result() for ClusterFuture ... done
[13:20:00.381] result() for ClusterFuture ...
[13:20:00.381] - result already collected: FutureResult
[13:20:00.381] result() for ClusterFuture ... done
[13:20:00.381] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:00.381] - nx: 2
[13:20:00.381] - relay: TRUE
[13:20:00.381] - stdout: TRUE
[13:20:00.381] - signal: TRUE
[13:20:00.382] - resignal: FALSE
[13:20:00.382] - force: TRUE
[13:20:00.382] - relayed: [n=2] FALSE, FALSE
[13:20:00.382] - queued futures: [n=2] FALSE, FALSE
[13:20:00.382]  - until=1
[13:20:00.382]  - relaying element #1
[13:20:00.382] result() for ClusterFuture ...
[13:20:00.382] - result already collected: FutureResult
[13:20:00.382] result() for ClusterFuture ... done
[13:20:00.382] result() for ClusterFuture ...
[13:20:00.382] - result already collected: FutureResult
[13:20:00.383] result() for ClusterFuture ... done
[13:20:00.383] result() for ClusterFuture ...
[13:20:00.383] - result already collected: FutureResult
[13:20:00.383] result() for ClusterFuture ... done
[13:20:00.383] result() for ClusterFuture ...
[13:20:00.383] - result already collected: FutureResult
[13:20:00.383] result() for ClusterFuture ... done
[13:20:00.383] - relayed: [n=2] TRUE, FALSE
[13:20:00.383] - queued futures: [n=2] TRUE, FALSE
[13:20:00.383] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:00.383]  length: 1 (resolved future 1)
[13:20:00.413] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.413] - Validating connection of MultisessionFuture
[13:20:00.413] - received message: FutureResult
[13:20:00.413] - Received FutureResult
[13:20:00.414] - Erased future from FutureRegistry
[13:20:00.414] result() for ClusterFuture ...
[13:20:00.414] - result already collected: FutureResult
[13:20:00.414] result() for ClusterFuture ... done
[13:20:00.414] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.414] Future #2
[13:20:00.414] result() for ClusterFuture ...
[13:20:00.414] - result already collected: FutureResult
[13:20:00.414] result() for ClusterFuture ... done
[13:20:00.414] result() for ClusterFuture ...
[13:20:00.414] - result already collected: FutureResult
[13:20:00.415] result() for ClusterFuture ... done
[13:20:00.415] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:00.415] - nx: 2
[13:20:00.415] - relay: TRUE
[13:20:00.415] - stdout: TRUE
[13:20:00.415] - signal: TRUE
[13:20:00.415] - resignal: FALSE
[13:20:00.415] - force: TRUE
[13:20:00.415] - relayed: [n=2] TRUE, FALSE
[13:20:00.415] - queued futures: [n=2] TRUE, FALSE
[13:20:00.415]  - until=2
[13:20:00.416]  - relaying element #2
[13:20:00.416] result() for ClusterFuture ...
[13:20:00.416] - result already collected: FutureResult
[13:20:00.416] result() for ClusterFuture ... done
[13:20:00.416] result() for ClusterFuture ...
[13:20:00.416] - result already collected: FutureResult
[13:20:00.416] result() for ClusterFuture ... done
[13:20:00.416] result() for ClusterFuture ...
[13:20:00.416] - result already collected: FutureResult
[13:20:00.416] result() for ClusterFuture ... done
[13:20:00.417] result() for ClusterFuture ...
[13:20:00.417] - result already collected: FutureResult
[13:20:00.417] result() for ClusterFuture ... done
[13:20:00.417] - relayed: [n=2] TRUE, TRUE
[13:20:00.417] - queued futures: [n=2] TRUE, TRUE
[13:20:00.417] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:00.417]  length: 0 (resolved future 2)
[13:20:00.417] Relaying remaining futures
[13:20:00.417] signalConditionsASAP(NULL, pos=0) ...
[13:20:00.417] - nx: 2
[13:20:00.417] - relay: TRUE
[13:20:00.418] - stdout: TRUE
[13:20:00.418] - signal: TRUE
[13:20:00.418] - resignal: FALSE
[13:20:00.418] - force: TRUE
[13:20:00.418] - relayed: [n=2] TRUE, TRUE
[13:20:00.418] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:00.418] - relayed: [n=2] TRUE, TRUE
[13:20:00.418] - queued futures: [n=2] TRUE, TRUE
[13:20:00.418] signalConditionsASAP(NULL, pos=0) ... done
[13:20:00.418] resolve() on list ... DONE
[13:20:00.419] result() for ClusterFuture ...
[13:20:00.419] - result already collected: FutureResult
[13:20:00.419] result() for ClusterFuture ... done
[13:20:00.419] result() for ClusterFuture ...
[13:20:00.419] - result already collected: FutureResult
[13:20:00.419] result() for ClusterFuture ... done
[13:20:00.419] result() for ClusterFuture ...
[13:20:00.419] - result already collected: FutureResult
[13:20:00.419] result() for ClusterFuture ... done
[13:20:00.419] result() for ClusterFuture ...
[13:20:00.419] - result already collected: FutureResult
[13:20:00.420] result() for ClusterFuture ... done
[13:20:00.420]  - Number of value chunks collected: 2
[13:20:00.420] Resolving 2 futures (chunks) ... DONE
[13:20:00.420] Reducing values from 2 chunks ...
[13:20:00.420]  - Number of values collected after concatenation: 6
[13:20:00.420]  - Number of values expected: 6
[13:20:00.420] Reducing values from 2 chunks ... DONE
[13:20:00.420] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[13:20:00.421] getGlobalsAndPackagesXApply() ...
[13:20:00.421]  - future.globals: TRUE
[13:20:00.421] getGlobalsAndPackages() ...
[13:20:00.421] Searching for globals...
[13:20:00.422] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[13:20:00.423] Searching for globals ... DONE
[13:20:00.423] Resolving globals: FALSE
[13:20:00.423] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[13:20:00.423] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[13:20:00.424] - globals: [1] ‘FUN’
[13:20:00.424] 
[13:20:00.424] getGlobalsAndPackages() ... DONE
[13:20:00.424]  - globals found/used: [n=1] ‘FUN’
[13:20:00.424]  - needed namespaces: [n=0] 
[13:20:00.424] Finding globals ... DONE
[13:20:00.424]  - use_args: TRUE
[13:20:00.424]  - Getting '...' globals ...
[13:20:00.425] resolve() on list ...
[13:20:00.425]  recursive: 0
[13:20:00.425]  length: 1
[13:20:00.425]  elements: ‘...’
[13:20:00.425]  length: 0 (resolved future 1)
[13:20:00.425] resolve() on list ... DONE
[13:20:00.425]    - '...' content: [n=0] 
[13:20:00.425] List of 1
[13:20:00.425]  $ ...: list()
[13:20:00.425]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.425]  - attr(*, "where")=List of 1
[13:20:00.425]   ..$ ...:<environment: 0x55592364a988> 
[13:20:00.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.425]  - attr(*, "resolved")= logi TRUE
[13:20:00.425]  - attr(*, "total_size")= num NA
[13:20:00.428]  - Getting '...' globals ... DONE
[13:20:00.428] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:00.428] List of 2
[13:20:00.428]  $ ...future.FUN:function (x)  
[13:20:00.428]  $ ...          : list()
[13:20:00.428]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.428]  - attr(*, "where")=List of 2
[13:20:00.428]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:00.428]   ..$ ...          :<environment: 0x55592364a988> 
[13:20:00.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.428]  - attr(*, "resolved")= logi FALSE
[13:20:00.428]  - attr(*, "total_size")= num 1768
[13:20:00.431] Packages to be attached in all futures: [n=0] 
[13:20:00.431] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.435] future_lapply() ...
[13:20:00.439] Number of chunks: 2
[13:20:00.439] getGlobalsAndPackagesXApply() ...
[13:20:00.439]  - future.globals: <name-value list> with names ‘list()’
[13:20:00.439]  - use_args: TRUE
[13:20:00.439] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:20:00.439] List of 2
[13:20:00.439]  $ ...          : list()
[13:20:00.439]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.439]  $ ...future.FUN:function (x)  
[13:20:00.439]  - attr(*, "where")=List of 2
[13:20:00.439]   ..$ ...          :<environment: 0x55592364a988> 
[13:20:00.439]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:20:00.439]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.439]  - attr(*, "resolved")= logi FALSE
[13:20:00.439]  - attr(*, "total_size")= num NA
[13:20:00.442] Packages to be attached in all futures: [n=0] 
[13:20:00.442] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.442] Number of futures (= number of chunks): 2
[13:20:00.443] Launching 2 futures (chunks) ...
[13:20:00.443] Chunk #1 of 2 ...
[13:20:00.443]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.443]  - seeds: <none>
[13:20:00.443]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.443] getGlobalsAndPackages() ...
[13:20:00.443] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.443] Resolving globals: FALSE
[13:20:00.443] Tweak future expression to call with '...' arguments ...
[13:20:00.444] {
[13:20:00.444]     do.call(function(...) {
[13:20:00.444]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.444]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.444]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.444]             on.exit(options(oopts), add = TRUE)
[13:20:00.444]         }
[13:20:00.444]         {
[13:20:00.444]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.444]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.444]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.444]             })
[13:20:00.444]         }
[13:20:00.444]     }, args = future.call.arguments)
[13:20:00.444] }
[13:20:00.444] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.444] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.444] 
[13:20:00.444] getGlobalsAndPackages() ... DONE
[13:20:00.445] run() for ‘Future’ ...
[13:20:00.445] - state: ‘created’
[13:20:00.445] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.459] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.459] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.459]   - Field: ‘node’
[13:20:00.459]   - Field: ‘label’
[13:20:00.459]   - Field: ‘local’
[13:20:00.460]   - Field: ‘owner’
[13:20:00.460]   - Field: ‘envir’
[13:20:00.460]   - Field: ‘workers’
[13:20:00.460]   - Field: ‘packages’
[13:20:00.460]   - Field: ‘gc’
[13:20:00.460]   - Field: ‘conditions’
[13:20:00.460]   - Field: ‘persistent’
[13:20:00.460]   - Field: ‘expr’
[13:20:00.460]   - Field: ‘uuid’
[13:20:00.460]   - Field: ‘seed’
[13:20:00.461]   - Field: ‘version’
[13:20:00.461]   - Field: ‘result’
[13:20:00.461]   - Field: ‘asynchronous’
[13:20:00.461]   - Field: ‘calls’
[13:20:00.461]   - Field: ‘globals’
[13:20:00.461]   - Field: ‘stdout’
[13:20:00.461]   - Field: ‘earlySignal’
[13:20:00.461]   - Field: ‘lazy’
[13:20:00.461]   - Field: ‘state’
[13:20:00.461] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.462] - Launch lazy future ...
[13:20:00.462] Packages needed by the future expression (n = 0): <none>
[13:20:00.462] Packages needed by future strategies (n = 0): <none>
[13:20:00.462] {
[13:20:00.462]     {
[13:20:00.462]         {
[13:20:00.462]             ...future.startTime <- base::Sys.time()
[13:20:00.462]             {
[13:20:00.462]                 {
[13:20:00.462]                   {
[13:20:00.462]                     {
[13:20:00.462]                       base::local({
[13:20:00.462]                         has_future <- base::requireNamespace("future", 
[13:20:00.462]                           quietly = TRUE)
[13:20:00.462]                         if (has_future) {
[13:20:00.462]                           ns <- base::getNamespace("future")
[13:20:00.462]                           version <- ns[[".package"]][["version"]]
[13:20:00.462]                           if (is.null(version)) 
[13:20:00.462]                             version <- utils::packageVersion("future")
[13:20:00.462]                         }
[13:20:00.462]                         else {
[13:20:00.462]                           version <- NULL
[13:20:00.462]                         }
[13:20:00.462]                         if (!has_future || version < "1.8.0") {
[13:20:00.462]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.462]                             "", base::R.version$version.string), 
[13:20:00.462]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.462]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.462]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.462]                               "release", "version")], collapse = " "), 
[13:20:00.462]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.462]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.462]                             info)
[13:20:00.462]                           info <- base::paste(info, collapse = "; ")
[13:20:00.462]                           if (!has_future) {
[13:20:00.462]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.462]                               info)
[13:20:00.462]                           }
[13:20:00.462]                           else {
[13:20:00.462]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.462]                               info, version)
[13:20:00.462]                           }
[13:20:00.462]                           base::stop(msg)
[13:20:00.462]                         }
[13:20:00.462]                       })
[13:20:00.462]                     }
[13:20:00.462]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.462]                     base::options(mc.cores = 1L)
[13:20:00.462]                   }
[13:20:00.462]                   options(future.plan = NULL)
[13:20:00.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.462]                 }
[13:20:00.462]                 ...future.workdir <- getwd()
[13:20:00.462]             }
[13:20:00.462]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.462]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.462]         }
[13:20:00.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.462]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.462]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.462]             base::names(...future.oldOptions))
[13:20:00.462]     }
[13:20:00.462]     if (FALSE) {
[13:20:00.462]     }
[13:20:00.462]     else {
[13:20:00.462]         if (TRUE) {
[13:20:00.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.462]                 open = "w")
[13:20:00.462]         }
[13:20:00.462]         else {
[13:20:00.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.462]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.462]         }
[13:20:00.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.462]             base::sink(type = "output", split = FALSE)
[13:20:00.462]             base::close(...future.stdout)
[13:20:00.462]         }, add = TRUE)
[13:20:00.462]     }
[13:20:00.462]     ...future.frame <- base::sys.nframe()
[13:20:00.462]     ...future.conditions <- base::list()
[13:20:00.462]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.462]     if (FALSE) {
[13:20:00.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.462]     }
[13:20:00.462]     ...future.result <- base::tryCatch({
[13:20:00.462]         base::withCallingHandlers({
[13:20:00.462]             ...future.value <- base::withVisible(base::local({
[13:20:00.462]                 ...future.makeSendCondition <- base::local({
[13:20:00.462]                   sendCondition <- NULL
[13:20:00.462]                   function(frame = 1L) {
[13:20:00.462]                     if (is.function(sendCondition)) 
[13:20:00.462]                       return(sendCondition)
[13:20:00.462]                     ns <- getNamespace("parallel")
[13:20:00.462]                     if (exists("sendData", mode = "function", 
[13:20:00.462]                       envir = ns)) {
[13:20:00.462]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.462]                         envir = ns)
[13:20:00.462]                       envir <- sys.frame(frame)
[13:20:00.462]                       master <- NULL
[13:20:00.462]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.462]                         !identical(envir, emptyenv())) {
[13:20:00.462]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.462]                           inherits = FALSE)) {
[13:20:00.462]                           master <- get("master", mode = "list", 
[13:20:00.462]                             envir = envir, inherits = FALSE)
[13:20:00.462]                           if (inherits(master, c("SOCKnode", 
[13:20:00.462]                             "SOCK0node"))) {
[13:20:00.462]                             sendCondition <<- function(cond) {
[13:20:00.462]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.462]                                 success = TRUE)
[13:20:00.462]                               parallel_sendData(master, data)
[13:20:00.462]                             }
[13:20:00.462]                             return(sendCondition)
[13:20:00.462]                           }
[13:20:00.462]                         }
[13:20:00.462]                         frame <- frame + 1L
[13:20:00.462]                         envir <- sys.frame(frame)
[13:20:00.462]                       }
[13:20:00.462]                     }
[13:20:00.462]                     sendCondition <<- function(cond) NULL
[13:20:00.462]                   }
[13:20:00.462]                 })
[13:20:00.462]                 withCallingHandlers({
[13:20:00.462]                   {
[13:20:00.462]                     do.call(function(...) {
[13:20:00.462]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.462]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.462]                         ...future.globals.maxSize)) {
[13:20:00.462]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.462]                         on.exit(options(oopts), add = TRUE)
[13:20:00.462]                       }
[13:20:00.462]                       {
[13:20:00.462]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.462]                           FUN = function(jj) {
[13:20:00.462]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.462]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.462]                           })
[13:20:00.462]                       }
[13:20:00.462]                     }, args = future.call.arguments)
[13:20:00.462]                   }
[13:20:00.462]                 }, immediateCondition = function(cond) {
[13:20:00.462]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.462]                   sendCondition(cond)
[13:20:00.462]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.462]                   {
[13:20:00.462]                     inherits <- base::inherits
[13:20:00.462]                     invokeRestart <- base::invokeRestart
[13:20:00.462]                     is.null <- base::is.null
[13:20:00.462]                     muffled <- FALSE
[13:20:00.462]                     if (inherits(cond, "message")) {
[13:20:00.462]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.462]                       if (muffled) 
[13:20:00.462]                         invokeRestart("muffleMessage")
[13:20:00.462]                     }
[13:20:00.462]                     else if (inherits(cond, "warning")) {
[13:20:00.462]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.462]                       if (muffled) 
[13:20:00.462]                         invokeRestart("muffleWarning")
[13:20:00.462]                     }
[13:20:00.462]                     else if (inherits(cond, "condition")) {
[13:20:00.462]                       if (!is.null(pattern)) {
[13:20:00.462]                         computeRestarts <- base::computeRestarts
[13:20:00.462]                         grepl <- base::grepl
[13:20:00.462]                         restarts <- computeRestarts(cond)
[13:20:00.462]                         for (restart in restarts) {
[13:20:00.462]                           name <- restart$name
[13:20:00.462]                           if (is.null(name)) 
[13:20:00.462]                             next
[13:20:00.462]                           if (!grepl(pattern, name)) 
[13:20:00.462]                             next
[13:20:00.462]                           invokeRestart(restart)
[13:20:00.462]                           muffled <- TRUE
[13:20:00.462]                           break
[13:20:00.462]                         }
[13:20:00.462]                       }
[13:20:00.462]                     }
[13:20:00.462]                     invisible(muffled)
[13:20:00.462]                   }
[13:20:00.462]                   muffleCondition(cond)
[13:20:00.462]                 })
[13:20:00.462]             }))
[13:20:00.462]             future::FutureResult(value = ...future.value$value, 
[13:20:00.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.462]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.462]                     ...future.globalenv.names))
[13:20:00.462]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.462]         }, condition = base::local({
[13:20:00.462]             c <- base::c
[13:20:00.462]             inherits <- base::inherits
[13:20:00.462]             invokeRestart <- base::invokeRestart
[13:20:00.462]             length <- base::length
[13:20:00.462]             list <- base::list
[13:20:00.462]             seq.int <- base::seq.int
[13:20:00.462]             signalCondition <- base::signalCondition
[13:20:00.462]             sys.calls <- base::sys.calls
[13:20:00.462]             `[[` <- base::`[[`
[13:20:00.462]             `+` <- base::`+`
[13:20:00.462]             `<<-` <- base::`<<-`
[13:20:00.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.462]                   3L)]
[13:20:00.462]             }
[13:20:00.462]             function(cond) {
[13:20:00.462]                 is_error <- inherits(cond, "error")
[13:20:00.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.462]                   NULL)
[13:20:00.462]                 if (is_error) {
[13:20:00.462]                   sessionInformation <- function() {
[13:20:00.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.462]                       search = base::search(), system = base::Sys.info())
[13:20:00.462]                   }
[13:20:00.462]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.462]                     cond$call), session = sessionInformation(), 
[13:20:00.462]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.462]                   signalCondition(cond)
[13:20:00.462]                 }
[13:20:00.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.462]                 "immediateCondition"))) {
[13:20:00.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.462]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.462]                   if (TRUE && !signal) {
[13:20:00.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.462]                     {
[13:20:00.462]                       inherits <- base::inherits
[13:20:00.462]                       invokeRestart <- base::invokeRestart
[13:20:00.462]                       is.null <- base::is.null
[13:20:00.462]                       muffled <- FALSE
[13:20:00.462]                       if (inherits(cond, "message")) {
[13:20:00.462]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.462]                         if (muffled) 
[13:20:00.462]                           invokeRestart("muffleMessage")
[13:20:00.462]                       }
[13:20:00.462]                       else if (inherits(cond, "warning")) {
[13:20:00.462]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.462]                         if (muffled) 
[13:20:00.462]                           invokeRestart("muffleWarning")
[13:20:00.462]                       }
[13:20:00.462]                       else if (inherits(cond, "condition")) {
[13:20:00.462]                         if (!is.null(pattern)) {
[13:20:00.462]                           computeRestarts <- base::computeRestarts
[13:20:00.462]                           grepl <- base::grepl
[13:20:00.462]                           restarts <- computeRestarts(cond)
[13:20:00.462]                           for (restart in restarts) {
[13:20:00.462]                             name <- restart$name
[13:20:00.462]                             if (is.null(name)) 
[13:20:00.462]                               next
[13:20:00.462]                             if (!grepl(pattern, name)) 
[13:20:00.462]                               next
[13:20:00.462]                             invokeRestart(restart)
[13:20:00.462]                             muffled <- TRUE
[13:20:00.462]                             break
[13:20:00.462]                           }
[13:20:00.462]                         }
[13:20:00.462]                       }
[13:20:00.462]                       invisible(muffled)
[13:20:00.462]                     }
[13:20:00.462]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.462]                   }
[13:20:00.462]                 }
[13:20:00.462]                 else {
[13:20:00.462]                   if (TRUE) {
[13:20:00.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.462]                     {
[13:20:00.462]                       inherits <- base::inherits
[13:20:00.462]                       invokeRestart <- base::invokeRestart
[13:20:00.462]                       is.null <- base::is.null
[13:20:00.462]                       muffled <- FALSE
[13:20:00.462]                       if (inherits(cond, "message")) {
[13:20:00.462]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.462]                         if (muffled) 
[13:20:00.462]                           invokeRestart("muffleMessage")
[13:20:00.462]                       }
[13:20:00.462]                       else if (inherits(cond, "warning")) {
[13:20:00.462]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.462]                         if (muffled) 
[13:20:00.462]                           invokeRestart("muffleWarning")
[13:20:00.462]                       }
[13:20:00.462]                       else if (inherits(cond, "condition")) {
[13:20:00.462]                         if (!is.null(pattern)) {
[13:20:00.462]                           computeRestarts <- base::computeRestarts
[13:20:00.462]                           grepl <- base::grepl
[13:20:00.462]                           restarts <- computeRestarts(cond)
[13:20:00.462]                           for (restart in restarts) {
[13:20:00.462]                             name <- restart$name
[13:20:00.462]                             if (is.null(name)) 
[13:20:00.462]                               next
[13:20:00.462]                             if (!grepl(pattern, name)) 
[13:20:00.462]                               next
[13:20:00.462]                             invokeRestart(restart)
[13:20:00.462]                             muffled <- TRUE
[13:20:00.462]                             break
[13:20:00.462]                           }
[13:20:00.462]                         }
[13:20:00.462]                       }
[13:20:00.462]                       invisible(muffled)
[13:20:00.462]                     }
[13:20:00.462]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.462]                   }
[13:20:00.462]                 }
[13:20:00.462]             }
[13:20:00.462]         }))
[13:20:00.462]     }, error = function(ex) {
[13:20:00.462]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.462]                 ...future.rng), started = ...future.startTime, 
[13:20:00.462]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.462]             version = "1.8"), class = "FutureResult")
[13:20:00.462]     }, finally = {
[13:20:00.462]         if (!identical(...future.workdir, getwd())) 
[13:20:00.462]             setwd(...future.workdir)
[13:20:00.462]         {
[13:20:00.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.462]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.462]             }
[13:20:00.462]             base::options(...future.oldOptions)
[13:20:00.462]             if (.Platform$OS.type == "windows") {
[13:20:00.462]                 old_names <- names(...future.oldEnvVars)
[13:20:00.462]                 envs <- base::Sys.getenv()
[13:20:00.462]                 names <- names(envs)
[13:20:00.462]                 common <- intersect(names, old_names)
[13:20:00.462]                 added <- setdiff(names, old_names)
[13:20:00.462]                 removed <- setdiff(old_names, names)
[13:20:00.462]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.462]                   envs[common]]
[13:20:00.462]                 NAMES <- toupper(changed)
[13:20:00.462]                 args <- list()
[13:20:00.462]                 for (kk in seq_along(NAMES)) {
[13:20:00.462]                   name <- changed[[kk]]
[13:20:00.462]                   NAME <- NAMES[[kk]]
[13:20:00.462]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.462]                     next
[13:20:00.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.462]                 }
[13:20:00.462]                 NAMES <- toupper(added)
[13:20:00.462]                 for (kk in seq_along(NAMES)) {
[13:20:00.462]                   name <- added[[kk]]
[13:20:00.462]                   NAME <- NAMES[[kk]]
[13:20:00.462]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.462]                     next
[13:20:00.462]                   args[[name]] <- ""
[13:20:00.462]                 }
[13:20:00.462]                 NAMES <- toupper(removed)
[13:20:00.462]                 for (kk in seq_along(NAMES)) {
[13:20:00.462]                   name <- removed[[kk]]
[13:20:00.462]                   NAME <- NAMES[[kk]]
[13:20:00.462]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.462]                     next
[13:20:00.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.462]                 }
[13:20:00.462]                 if (length(args) > 0) 
[13:20:00.462]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.462]             }
[13:20:00.462]             else {
[13:20:00.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.462]             }
[13:20:00.462]             {
[13:20:00.462]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.462]                   0L) {
[13:20:00.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.462]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.462]                   base::options(opts)
[13:20:00.462]                 }
[13:20:00.462]                 {
[13:20:00.462]                   {
[13:20:00.462]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.462]                     NULL
[13:20:00.462]                   }
[13:20:00.462]                   options(future.plan = NULL)
[13:20:00.462]                   if (is.na(NA_character_)) 
[13:20:00.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.462]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.462]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.462]                     envir = parent.frame()) 
[13:20:00.462]                   {
[13:20:00.462]                     if (is.function(workers)) 
[13:20:00.462]                       workers <- workers()
[13:20:00.462]                     workers <- structure(as.integer(workers), 
[13:20:00.462]                       class = class(workers))
[13:20:00.462]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.462]                       workers >= 1)
[13:20:00.462]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.462]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.462]                     }
[13:20:00.462]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.462]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.462]                       envir = envir)
[13:20:00.462]                     if (!future$lazy) 
[13:20:00.462]                       future <- run(future)
[13:20:00.462]                     invisible(future)
[13:20:00.462]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.462]                 }
[13:20:00.462]             }
[13:20:00.462]         }
[13:20:00.462]     })
[13:20:00.462]     if (TRUE) {
[13:20:00.462]         base::sink(type = "output", split = FALSE)
[13:20:00.462]         if (TRUE) {
[13:20:00.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.462]         }
[13:20:00.462]         else {
[13:20:00.462]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.462]         }
[13:20:00.462]         base::close(...future.stdout)
[13:20:00.462]         ...future.stdout <- NULL
[13:20:00.462]     }
[13:20:00.462]     ...future.result$conditions <- ...future.conditions
[13:20:00.462]     ...future.result$finished <- base::Sys.time()
[13:20:00.462]     ...future.result
[13:20:00.462] }
[13:20:00.466] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[13:20:00.466] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:00.466] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.466] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[13:20:00.467] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[13:20:00.467] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[13:20:00.467] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[13:20:00.467] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:00.468] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.468] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:20:00.468] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.468] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[13:20:00.469] MultisessionFuture started
[13:20:00.469] - Launch lazy future ... done
[13:20:00.469] run() for ‘MultisessionFuture’ ... done
[13:20:00.469] Created future:
[13:20:00.469] MultisessionFuture:
[13:20:00.469] Label: ‘future_apply-1’
[13:20:00.469] Expression:
[13:20:00.469] {
[13:20:00.469]     do.call(function(...) {
[13:20:00.469]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.469]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.469]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.469]             on.exit(options(oopts), add = TRUE)
[13:20:00.469]         }
[13:20:00.469]         {
[13:20:00.469]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.469]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.469]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.469]             })
[13:20:00.469]         }
[13:20:00.469]     }, args = future.call.arguments)
[13:20:00.469] }
[13:20:00.469] Lazy evaluation: FALSE
[13:20:00.469] Asynchronous evaluation: TRUE
[13:20:00.469] Local evaluation: TRUE
[13:20:00.469] Environment: R_GlobalEnv
[13:20:00.469] Capture standard output: TRUE
[13:20:00.469] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.469] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.469] Packages: <none>
[13:20:00.469] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.469] Resolved: FALSE
[13:20:00.469] Value: <not collected>
[13:20:00.469] Conditions captured: <none>
[13:20:00.469] Early signaling: FALSE
[13:20:00.469] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.469] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.481] Chunk #1 of 2 ... DONE
[13:20:00.481] Chunk #2 of 2 ...
[13:20:00.481]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.481]  - seeds: <none>
[13:20:00.481]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.481] getGlobalsAndPackages() ...
[13:20:00.481] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.481] Resolving globals: FALSE
[13:20:00.482] Tweak future expression to call with '...' arguments ...
[13:20:00.482] {
[13:20:00.482]     do.call(function(...) {
[13:20:00.482]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.482]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.482]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.482]             on.exit(options(oopts), add = TRUE)
[13:20:00.482]         }
[13:20:00.482]         {
[13:20:00.482]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.482]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.482]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.482]             })
[13:20:00.482]         }
[13:20:00.482]     }, args = future.call.arguments)
[13:20:00.482] }
[13:20:00.482] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.482] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.482] 
[13:20:00.483] getGlobalsAndPackages() ... DONE
[13:20:00.483] run() for ‘Future’ ...
[13:20:00.483] - state: ‘created’
[13:20:00.483] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.497] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.497] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.497]   - Field: ‘node’
[13:20:00.498]   - Field: ‘label’
[13:20:00.498]   - Field: ‘local’
[13:20:00.498]   - Field: ‘owner’
[13:20:00.498]   - Field: ‘envir’
[13:20:00.498]   - Field: ‘workers’
[13:20:00.498]   - Field: ‘packages’
[13:20:00.498]   - Field: ‘gc’
[13:20:00.498]   - Field: ‘conditions’
[13:20:00.498]   - Field: ‘persistent’
[13:20:00.498]   - Field: ‘expr’
[13:20:00.498]   - Field: ‘uuid’
[13:20:00.499]   - Field: ‘seed’
[13:20:00.499]   - Field: ‘version’
[13:20:00.499]   - Field: ‘result’
[13:20:00.499]   - Field: ‘asynchronous’
[13:20:00.499]   - Field: ‘calls’
[13:20:00.499]   - Field: ‘globals’
[13:20:00.499]   - Field: ‘stdout’
[13:20:00.499]   - Field: ‘earlySignal’
[13:20:00.499]   - Field: ‘lazy’
[13:20:00.499]   - Field: ‘state’
[13:20:00.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.500] - Launch lazy future ...
[13:20:00.500] Packages needed by the future expression (n = 0): <none>
[13:20:00.500] Packages needed by future strategies (n = 0): <none>
[13:20:00.500] {
[13:20:00.500]     {
[13:20:00.500]         {
[13:20:00.500]             ...future.startTime <- base::Sys.time()
[13:20:00.500]             {
[13:20:00.500]                 {
[13:20:00.500]                   {
[13:20:00.500]                     {
[13:20:00.500]                       base::local({
[13:20:00.500]                         has_future <- base::requireNamespace("future", 
[13:20:00.500]                           quietly = TRUE)
[13:20:00.500]                         if (has_future) {
[13:20:00.500]                           ns <- base::getNamespace("future")
[13:20:00.500]                           version <- ns[[".package"]][["version"]]
[13:20:00.500]                           if (is.null(version)) 
[13:20:00.500]                             version <- utils::packageVersion("future")
[13:20:00.500]                         }
[13:20:00.500]                         else {
[13:20:00.500]                           version <- NULL
[13:20:00.500]                         }
[13:20:00.500]                         if (!has_future || version < "1.8.0") {
[13:20:00.500]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.500]                             "", base::R.version$version.string), 
[13:20:00.500]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.500]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.500]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.500]                               "release", "version")], collapse = " "), 
[13:20:00.500]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.500]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.500]                             info)
[13:20:00.500]                           info <- base::paste(info, collapse = "; ")
[13:20:00.500]                           if (!has_future) {
[13:20:00.500]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.500]                               info)
[13:20:00.500]                           }
[13:20:00.500]                           else {
[13:20:00.500]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.500]                               info, version)
[13:20:00.500]                           }
[13:20:00.500]                           base::stop(msg)
[13:20:00.500]                         }
[13:20:00.500]                       })
[13:20:00.500]                     }
[13:20:00.500]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.500]                     base::options(mc.cores = 1L)
[13:20:00.500]                   }
[13:20:00.500]                   options(future.plan = NULL)
[13:20:00.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.500]                 }
[13:20:00.500]                 ...future.workdir <- getwd()
[13:20:00.500]             }
[13:20:00.500]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.500]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.500]         }
[13:20:00.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.500]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.500]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.500]             base::names(...future.oldOptions))
[13:20:00.500]     }
[13:20:00.500]     if (FALSE) {
[13:20:00.500]     }
[13:20:00.500]     else {
[13:20:00.500]         if (TRUE) {
[13:20:00.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.500]                 open = "w")
[13:20:00.500]         }
[13:20:00.500]         else {
[13:20:00.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.500]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.500]         }
[13:20:00.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.500]             base::sink(type = "output", split = FALSE)
[13:20:00.500]             base::close(...future.stdout)
[13:20:00.500]         }, add = TRUE)
[13:20:00.500]     }
[13:20:00.500]     ...future.frame <- base::sys.nframe()
[13:20:00.500]     ...future.conditions <- base::list()
[13:20:00.500]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.500]     if (FALSE) {
[13:20:00.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.500]     }
[13:20:00.500]     ...future.result <- base::tryCatch({
[13:20:00.500]         base::withCallingHandlers({
[13:20:00.500]             ...future.value <- base::withVisible(base::local({
[13:20:00.500]                 ...future.makeSendCondition <- base::local({
[13:20:00.500]                   sendCondition <- NULL
[13:20:00.500]                   function(frame = 1L) {
[13:20:00.500]                     if (is.function(sendCondition)) 
[13:20:00.500]                       return(sendCondition)
[13:20:00.500]                     ns <- getNamespace("parallel")
[13:20:00.500]                     if (exists("sendData", mode = "function", 
[13:20:00.500]                       envir = ns)) {
[13:20:00.500]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.500]                         envir = ns)
[13:20:00.500]                       envir <- sys.frame(frame)
[13:20:00.500]                       master <- NULL
[13:20:00.500]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.500]                         !identical(envir, emptyenv())) {
[13:20:00.500]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.500]                           inherits = FALSE)) {
[13:20:00.500]                           master <- get("master", mode = "list", 
[13:20:00.500]                             envir = envir, inherits = FALSE)
[13:20:00.500]                           if (inherits(master, c("SOCKnode", 
[13:20:00.500]                             "SOCK0node"))) {
[13:20:00.500]                             sendCondition <<- function(cond) {
[13:20:00.500]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.500]                                 success = TRUE)
[13:20:00.500]                               parallel_sendData(master, data)
[13:20:00.500]                             }
[13:20:00.500]                             return(sendCondition)
[13:20:00.500]                           }
[13:20:00.500]                         }
[13:20:00.500]                         frame <- frame + 1L
[13:20:00.500]                         envir <- sys.frame(frame)
[13:20:00.500]                       }
[13:20:00.500]                     }
[13:20:00.500]                     sendCondition <<- function(cond) NULL
[13:20:00.500]                   }
[13:20:00.500]                 })
[13:20:00.500]                 withCallingHandlers({
[13:20:00.500]                   {
[13:20:00.500]                     do.call(function(...) {
[13:20:00.500]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.500]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.500]                         ...future.globals.maxSize)) {
[13:20:00.500]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.500]                         on.exit(options(oopts), add = TRUE)
[13:20:00.500]                       }
[13:20:00.500]                       {
[13:20:00.500]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.500]                           FUN = function(jj) {
[13:20:00.500]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.500]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.500]                           })
[13:20:00.500]                       }
[13:20:00.500]                     }, args = future.call.arguments)
[13:20:00.500]                   }
[13:20:00.500]                 }, immediateCondition = function(cond) {
[13:20:00.500]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.500]                   sendCondition(cond)
[13:20:00.500]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.500]                   {
[13:20:00.500]                     inherits <- base::inherits
[13:20:00.500]                     invokeRestart <- base::invokeRestart
[13:20:00.500]                     is.null <- base::is.null
[13:20:00.500]                     muffled <- FALSE
[13:20:00.500]                     if (inherits(cond, "message")) {
[13:20:00.500]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.500]                       if (muffled) 
[13:20:00.500]                         invokeRestart("muffleMessage")
[13:20:00.500]                     }
[13:20:00.500]                     else if (inherits(cond, "warning")) {
[13:20:00.500]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.500]                       if (muffled) 
[13:20:00.500]                         invokeRestart("muffleWarning")
[13:20:00.500]                     }
[13:20:00.500]                     else if (inherits(cond, "condition")) {
[13:20:00.500]                       if (!is.null(pattern)) {
[13:20:00.500]                         computeRestarts <- base::computeRestarts
[13:20:00.500]                         grepl <- base::grepl
[13:20:00.500]                         restarts <- computeRestarts(cond)
[13:20:00.500]                         for (restart in restarts) {
[13:20:00.500]                           name <- restart$name
[13:20:00.500]                           if (is.null(name)) 
[13:20:00.500]                             next
[13:20:00.500]                           if (!grepl(pattern, name)) 
[13:20:00.500]                             next
[13:20:00.500]                           invokeRestart(restart)
[13:20:00.500]                           muffled <- TRUE
[13:20:00.500]                           break
[13:20:00.500]                         }
[13:20:00.500]                       }
[13:20:00.500]                     }
[13:20:00.500]                     invisible(muffled)
[13:20:00.500]                   }
[13:20:00.500]                   muffleCondition(cond)
[13:20:00.500]                 })
[13:20:00.500]             }))
[13:20:00.500]             future::FutureResult(value = ...future.value$value, 
[13:20:00.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.500]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.500]                     ...future.globalenv.names))
[13:20:00.500]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.500]         }, condition = base::local({
[13:20:00.500]             c <- base::c
[13:20:00.500]             inherits <- base::inherits
[13:20:00.500]             invokeRestart <- base::invokeRestart
[13:20:00.500]             length <- base::length
[13:20:00.500]             list <- base::list
[13:20:00.500]             seq.int <- base::seq.int
[13:20:00.500]             signalCondition <- base::signalCondition
[13:20:00.500]             sys.calls <- base::sys.calls
[13:20:00.500]             `[[` <- base::`[[`
[13:20:00.500]             `+` <- base::`+`
[13:20:00.500]             `<<-` <- base::`<<-`
[13:20:00.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.500]                   3L)]
[13:20:00.500]             }
[13:20:00.500]             function(cond) {
[13:20:00.500]                 is_error <- inherits(cond, "error")
[13:20:00.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.500]                   NULL)
[13:20:00.500]                 if (is_error) {
[13:20:00.500]                   sessionInformation <- function() {
[13:20:00.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.500]                       search = base::search(), system = base::Sys.info())
[13:20:00.500]                   }
[13:20:00.500]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.500]                     cond$call), session = sessionInformation(), 
[13:20:00.500]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.500]                   signalCondition(cond)
[13:20:00.500]                 }
[13:20:00.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.500]                 "immediateCondition"))) {
[13:20:00.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.500]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.500]                   if (TRUE && !signal) {
[13:20:00.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.500]                     {
[13:20:00.500]                       inherits <- base::inherits
[13:20:00.500]                       invokeRestart <- base::invokeRestart
[13:20:00.500]                       is.null <- base::is.null
[13:20:00.500]                       muffled <- FALSE
[13:20:00.500]                       if (inherits(cond, "message")) {
[13:20:00.500]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.500]                         if (muffled) 
[13:20:00.500]                           invokeRestart("muffleMessage")
[13:20:00.500]                       }
[13:20:00.500]                       else if (inherits(cond, "warning")) {
[13:20:00.500]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.500]                         if (muffled) 
[13:20:00.500]                           invokeRestart("muffleWarning")
[13:20:00.500]                       }
[13:20:00.500]                       else if (inherits(cond, "condition")) {
[13:20:00.500]                         if (!is.null(pattern)) {
[13:20:00.500]                           computeRestarts <- base::computeRestarts
[13:20:00.500]                           grepl <- base::grepl
[13:20:00.500]                           restarts <- computeRestarts(cond)
[13:20:00.500]                           for (restart in restarts) {
[13:20:00.500]                             name <- restart$name
[13:20:00.500]                             if (is.null(name)) 
[13:20:00.500]                               next
[13:20:00.500]                             if (!grepl(pattern, name)) 
[13:20:00.500]                               next
[13:20:00.500]                             invokeRestart(restart)
[13:20:00.500]                             muffled <- TRUE
[13:20:00.500]                             break
[13:20:00.500]                           }
[13:20:00.500]                         }
[13:20:00.500]                       }
[13:20:00.500]                       invisible(muffled)
[13:20:00.500]                     }
[13:20:00.500]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.500]                   }
[13:20:00.500]                 }
[13:20:00.500]                 else {
[13:20:00.500]                   if (TRUE) {
[13:20:00.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.500]                     {
[13:20:00.500]                       inherits <- base::inherits
[13:20:00.500]                       invokeRestart <- base::invokeRestart
[13:20:00.500]                       is.null <- base::is.null
[13:20:00.500]                       muffled <- FALSE
[13:20:00.500]                       if (inherits(cond, "message")) {
[13:20:00.500]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.500]                         if (muffled) 
[13:20:00.500]                           invokeRestart("muffleMessage")
[13:20:00.500]                       }
[13:20:00.500]                       else if (inherits(cond, "warning")) {
[13:20:00.500]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.500]                         if (muffled) 
[13:20:00.500]                           invokeRestart("muffleWarning")
[13:20:00.500]                       }
[13:20:00.500]                       else if (inherits(cond, "condition")) {
[13:20:00.500]                         if (!is.null(pattern)) {
[13:20:00.500]                           computeRestarts <- base::computeRestarts
[13:20:00.500]                           grepl <- base::grepl
[13:20:00.500]                           restarts <- computeRestarts(cond)
[13:20:00.500]                           for (restart in restarts) {
[13:20:00.500]                             name <- restart$name
[13:20:00.500]                             if (is.null(name)) 
[13:20:00.500]                               next
[13:20:00.500]                             if (!grepl(pattern, name)) 
[13:20:00.500]                               next
[13:20:00.500]                             invokeRestart(restart)
[13:20:00.500]                             muffled <- TRUE
[13:20:00.500]                             break
[13:20:00.500]                           }
[13:20:00.500]                         }
[13:20:00.500]                       }
[13:20:00.500]                       invisible(muffled)
[13:20:00.500]                     }
[13:20:00.500]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.500]                   }
[13:20:00.500]                 }
[13:20:00.500]             }
[13:20:00.500]         }))
[13:20:00.500]     }, error = function(ex) {
[13:20:00.500]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.500]                 ...future.rng), started = ...future.startTime, 
[13:20:00.500]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.500]             version = "1.8"), class = "FutureResult")
[13:20:00.500]     }, finally = {
[13:20:00.500]         if (!identical(...future.workdir, getwd())) 
[13:20:00.500]             setwd(...future.workdir)
[13:20:00.500]         {
[13:20:00.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.500]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.500]             }
[13:20:00.500]             base::options(...future.oldOptions)
[13:20:00.500]             if (.Platform$OS.type == "windows") {
[13:20:00.500]                 old_names <- names(...future.oldEnvVars)
[13:20:00.500]                 envs <- base::Sys.getenv()
[13:20:00.500]                 names <- names(envs)
[13:20:00.500]                 common <- intersect(names, old_names)
[13:20:00.500]                 added <- setdiff(names, old_names)
[13:20:00.500]                 removed <- setdiff(old_names, names)
[13:20:00.500]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.500]                   envs[common]]
[13:20:00.500]                 NAMES <- toupper(changed)
[13:20:00.500]                 args <- list()
[13:20:00.500]                 for (kk in seq_along(NAMES)) {
[13:20:00.500]                   name <- changed[[kk]]
[13:20:00.500]                   NAME <- NAMES[[kk]]
[13:20:00.500]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.500]                     next
[13:20:00.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.500]                 }
[13:20:00.500]                 NAMES <- toupper(added)
[13:20:00.500]                 for (kk in seq_along(NAMES)) {
[13:20:00.500]                   name <- added[[kk]]
[13:20:00.500]                   NAME <- NAMES[[kk]]
[13:20:00.500]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.500]                     next
[13:20:00.500]                   args[[name]] <- ""
[13:20:00.500]                 }
[13:20:00.500]                 NAMES <- toupper(removed)
[13:20:00.500]                 for (kk in seq_along(NAMES)) {
[13:20:00.500]                   name <- removed[[kk]]
[13:20:00.500]                   NAME <- NAMES[[kk]]
[13:20:00.500]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.500]                     next
[13:20:00.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.500]                 }
[13:20:00.500]                 if (length(args) > 0) 
[13:20:00.500]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.500]             }
[13:20:00.500]             else {
[13:20:00.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.500]             }
[13:20:00.500]             {
[13:20:00.500]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.500]                   0L) {
[13:20:00.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.500]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.500]                   base::options(opts)
[13:20:00.500]                 }
[13:20:00.500]                 {
[13:20:00.500]                   {
[13:20:00.500]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.500]                     NULL
[13:20:00.500]                   }
[13:20:00.500]                   options(future.plan = NULL)
[13:20:00.500]                   if (is.na(NA_character_)) 
[13:20:00.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.500]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.500]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.500]                     envir = parent.frame()) 
[13:20:00.500]                   {
[13:20:00.500]                     if (is.function(workers)) 
[13:20:00.500]                       workers <- workers()
[13:20:00.500]                     workers <- structure(as.integer(workers), 
[13:20:00.500]                       class = class(workers))
[13:20:00.500]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.500]                       workers >= 1)
[13:20:00.500]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.500]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.500]                     }
[13:20:00.500]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.500]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.500]                       envir = envir)
[13:20:00.500]                     if (!future$lazy) 
[13:20:00.500]                       future <- run(future)
[13:20:00.500]                     invisible(future)
[13:20:00.500]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.500]                 }
[13:20:00.500]             }
[13:20:00.500]         }
[13:20:00.500]     })
[13:20:00.500]     if (TRUE) {
[13:20:00.500]         base::sink(type = "output", split = FALSE)
[13:20:00.500]         if (TRUE) {
[13:20:00.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.500]         }
[13:20:00.500]         else {
[13:20:00.500]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.500]         }
[13:20:00.500]         base::close(...future.stdout)
[13:20:00.500]         ...future.stdout <- NULL
[13:20:00.500]     }
[13:20:00.500]     ...future.result$conditions <- ...future.conditions
[13:20:00.500]     ...future.result$finished <- base::Sys.time()
[13:20:00.500]     ...future.result
[13:20:00.500] }
[13:20:00.504] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[13:20:00.504] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:00.504] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.505] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[13:20:00.505] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[13:20:00.505] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[13:20:00.505] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[13:20:00.505] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:00.506] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.506] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:20:00.506] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:20:00.506] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[13:20:00.507] MultisessionFuture started
[13:20:00.507] - Launch lazy future ... done
[13:20:00.507] run() for ‘MultisessionFuture’ ... done
[13:20:00.507] Created future:
[13:20:00.507] MultisessionFuture:
[13:20:00.507] Label: ‘future_apply-2’
[13:20:00.507] Expression:
[13:20:00.507] {
[13:20:00.507]     do.call(function(...) {
[13:20:00.507]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.507]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.507]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.507]             on.exit(options(oopts), add = TRUE)
[13:20:00.507]         }
[13:20:00.507]         {
[13:20:00.507]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.507]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.507]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.507]             })
[13:20:00.507]         }
[13:20:00.507]     }, args = future.call.arguments)
[13:20:00.507] }
[13:20:00.507] Lazy evaluation: FALSE
[13:20:00.507] Asynchronous evaluation: TRUE
[13:20:00.507] Local evaluation: TRUE
[13:20:00.507] Environment: R_GlobalEnv
[13:20:00.507] Capture standard output: TRUE
[13:20:00.507] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.507] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.507] Packages: <none>
[13:20:00.507] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.507] Resolved: FALSE
[13:20:00.507] Value: <not collected>
[13:20:00.507] Conditions captured: <none>
[13:20:00.507] Early signaling: FALSE
[13:20:00.507] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.507] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.519] Chunk #2 of 2 ... DONE
[13:20:00.519] Launching 2 futures (chunks) ... DONE
[13:20:00.519] Resolving 2 futures (chunks) ...
[13:20:00.519] resolve() on list ...
[13:20:00.519]  recursive: 0
[13:20:00.520]  length: 2
[13:20:00.520] 
[13:20:00.520] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.520] - Validating connection of MultisessionFuture
[13:20:00.521] - received message: FutureResult
[13:20:00.521] - Received FutureResult
[13:20:00.521] - Erased future from FutureRegistry
[13:20:00.521] result() for ClusterFuture ...
[13:20:00.521] - result already collected: FutureResult
[13:20:00.521] result() for ClusterFuture ... done
[13:20:00.521] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.521] Future #1
[13:20:00.521] result() for ClusterFuture ...
[13:20:00.522] - result already collected: FutureResult
[13:20:00.522] result() for ClusterFuture ... done
[13:20:00.522] result() for ClusterFuture ...
[13:20:00.522] - result already collected: FutureResult
[13:20:00.522] result() for ClusterFuture ... done
[13:20:00.522] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:00.522] - nx: 2
[13:20:00.522] - relay: TRUE
[13:20:00.522] - stdout: TRUE
[13:20:00.522] - signal: TRUE
[13:20:00.522] - resignal: FALSE
[13:20:00.522] - force: TRUE
[13:20:00.523] - relayed: [n=2] FALSE, FALSE
[13:20:00.523] - queued futures: [n=2] FALSE, FALSE
[13:20:00.523]  - until=1
[13:20:00.523]  - relaying element #1
[13:20:00.523] result() for ClusterFuture ...
[13:20:00.523] - result already collected: FutureResult
[13:20:00.523] result() for ClusterFuture ... done
[13:20:00.523] result() for ClusterFuture ...
[13:20:00.523] - result already collected: FutureResult
[13:20:00.523] result() for ClusterFuture ... done
[13:20:00.524] result() for ClusterFuture ...
[13:20:00.524] - result already collected: FutureResult
[13:20:00.524] result() for ClusterFuture ... done
[13:20:00.524] result() for ClusterFuture ...
[13:20:00.524] - result already collected: FutureResult
[13:20:00.524] result() for ClusterFuture ... done
[13:20:00.524] - relayed: [n=2] TRUE, FALSE
[13:20:00.524] - queued futures: [n=2] TRUE, FALSE
[13:20:00.524] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:00.524]  length: 1 (resolved future 1)
[13:20:00.553] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.553] - Validating connection of MultisessionFuture
[13:20:00.553] - received message: FutureResult
[13:20:00.553] - Received FutureResult
[13:20:00.554] - Erased future from FutureRegistry
[13:20:00.554] result() for ClusterFuture ...
[13:20:00.554] - result already collected: FutureResult
[13:20:00.554] result() for ClusterFuture ... done
[13:20:00.554] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.554] Future #2
[13:20:00.554] result() for ClusterFuture ...
[13:20:00.554] - result already collected: FutureResult
[13:20:00.554] result() for ClusterFuture ... done
[13:20:00.554] result() for ClusterFuture ...
[13:20:00.555] - result already collected: FutureResult
[13:20:00.555] result() for ClusterFuture ... done
[13:20:00.555] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:00.557] - nx: 2
[13:20:00.557] - relay: TRUE
[13:20:00.557] - stdout: TRUE
[13:20:00.557] - signal: TRUE
[13:20:00.557] - resignal: FALSE
[13:20:00.558] - force: TRUE
[13:20:00.558] - relayed: [n=2] TRUE, FALSE
[13:20:00.558] - queued futures: [n=2] TRUE, FALSE
[13:20:00.558]  - until=2
[13:20:00.558]  - relaying element #2
[13:20:00.558] result() for ClusterFuture ...
[13:20:00.558] - result already collected: FutureResult
[13:20:00.558] result() for ClusterFuture ... done
[13:20:00.558] result() for ClusterFuture ...
[13:20:00.558] - result already collected: FutureResult
[13:20:00.558] result() for ClusterFuture ... done
[13:20:00.559] result() for ClusterFuture ...
[13:20:00.559] - result already collected: FutureResult
[13:20:00.559] result() for ClusterFuture ... done
[13:20:00.559] result() for ClusterFuture ...
[13:20:00.559] - result already collected: FutureResult
[13:20:00.559] result() for ClusterFuture ... done
[13:20:00.559] - relayed: [n=2] TRUE, TRUE
[13:20:00.559] - queued futures: [n=2] TRUE, TRUE
[13:20:00.559] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:00.559]  length: 0 (resolved future 2)
[13:20:00.559] Relaying remaining futures
[13:20:00.560] signalConditionsASAP(NULL, pos=0) ...
[13:20:00.560] - nx: 2
[13:20:00.560] - relay: TRUE
[13:20:00.560] - stdout: TRUE
[13:20:00.560] - signal: TRUE
[13:20:00.560] - resignal: FALSE
[13:20:00.560] - force: TRUE
[13:20:00.560] - relayed: [n=2] TRUE, TRUE
[13:20:00.560] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:00.560] - relayed: [n=2] TRUE, TRUE
[13:20:00.560] - queued futures: [n=2] TRUE, TRUE
[13:20:00.561] signalConditionsASAP(NULL, pos=0) ... done
[13:20:00.561] resolve() on list ... DONE
[13:20:00.561] result() for ClusterFuture ...
[13:20:00.561] - result already collected: FutureResult
[13:20:00.561] result() for ClusterFuture ... done
[13:20:00.561] result() for ClusterFuture ...
[13:20:00.561] - result already collected: FutureResult
[13:20:00.561] result() for ClusterFuture ... done
[13:20:00.561] result() for ClusterFuture ...
[13:20:00.561] - result already collected: FutureResult
[13:20:00.561] result() for ClusterFuture ... done
[13:20:00.561] result() for ClusterFuture ...
[13:20:00.562] - result already collected: FutureResult
[13:20:00.562] result() for ClusterFuture ... done
[13:20:00.562]  - Number of value chunks collected: 2
[13:20:00.562] Resolving 2 futures (chunks) ... DONE
[13:20:00.562] Reducing values from 2 chunks ...
[13:20:00.562]  - Number of values collected after concatenation: 6
[13:20:00.562]  - Number of values expected: 6
[13:20:00.562] Reducing values from 2 chunks ... DONE
[13:20:00.562] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[13:20:00.563] getGlobalsAndPackagesXApply() ...
[13:20:00.563]  - future.globals: TRUE
[13:20:00.563] getGlobalsAndPackages() ...
[13:20:00.563] Searching for globals...
[13:20:00.564] - globals found: [1] ‘FUN’
[13:20:00.564] Searching for globals ... DONE
[13:20:00.564] Resolving globals: FALSE
[13:20:00.565] The total size of the 1 globals is 848 bytes (848 bytes)
[13:20:00.565] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:20:00.565] - globals: [1] ‘FUN’
[13:20:00.565] 
[13:20:00.565] getGlobalsAndPackages() ... DONE
[13:20:00.565]  - globals found/used: [n=1] ‘FUN’
[13:20:00.565]  - needed namespaces: [n=0] 
[13:20:00.566] Finding globals ... DONE
[13:20:00.566]  - use_args: TRUE
[13:20:00.566]  - Getting '...' globals ...
[13:20:00.566] resolve() on list ...
[13:20:00.566]  recursive: 0
[13:20:00.566]  length: 1
[13:20:00.566]  elements: ‘...’
[13:20:00.566]  length: 0 (resolved future 1)
[13:20:00.567] resolve() on list ... DONE
[13:20:00.567]    - '...' content: [n=0] 
[13:20:00.567] List of 1
[13:20:00.567]  $ ...: list()
[13:20:00.567]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.567]  - attr(*, "where")=List of 1
[13:20:00.567]   ..$ ...:<environment: 0x555922e04228> 
[13:20:00.567]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.567]  - attr(*, "resolved")= logi TRUE
[13:20:00.567]  - attr(*, "total_size")= num NA
[13:20:00.569]  - Getting '...' globals ... DONE
[13:20:00.569] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:00.570] List of 2
[13:20:00.570]  $ ...future.FUN:function (x)  
[13:20:00.570]  $ ...          : list()
[13:20:00.570]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.570]  - attr(*, "where")=List of 2
[13:20:00.570]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:00.570]   ..$ ...          :<environment: 0x555922e04228> 
[13:20:00.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.570]  - attr(*, "resolved")= logi FALSE
[13:20:00.570]  - attr(*, "total_size")= num 848
[13:20:00.572] Packages to be attached in all futures: [n=0] 
[13:20:00.572] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.576] future_lapply() ...
[13:20:00.580] Number of chunks: 2
[13:20:00.580] getGlobalsAndPackagesXApply() ...
[13:20:00.580]  - future.globals: <name-value list> with names ‘list()’
[13:20:00.580]  - use_args: TRUE
[13:20:00.580] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:20:00.581] List of 2
[13:20:00.581]  $ ...          : list()
[13:20:00.581]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.581]  $ ...future.FUN:function (x)  
[13:20:00.581]  - attr(*, "where")=List of 2
[13:20:00.581]   ..$ ...          :<environment: 0x555922e04228> 
[13:20:00.581]   ..$ ...future.FUN:<environment: namespace:base> 
[13:20:00.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.581]  - attr(*, "resolved")= logi FALSE
[13:20:00.581]  - attr(*, "total_size")= num NA
[13:20:00.584] Packages to be attached in all futures: [n=0] 
[13:20:00.584] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.584] Number of futures (= number of chunks): 2
[13:20:00.584] Launching 2 futures (chunks) ...
[13:20:00.585] Chunk #1 of 2 ...
[13:20:00.585]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.585]  - seeds: <none>
[13:20:00.585]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.585] getGlobalsAndPackages() ...
[13:20:00.585] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.585] Resolving globals: FALSE
[13:20:00.585] Tweak future expression to call with '...' arguments ...
[13:20:00.585] {
[13:20:00.585]     do.call(function(...) {
[13:20:00.585]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.585]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.585]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.585]             on.exit(options(oopts), add = TRUE)
[13:20:00.585]         }
[13:20:00.585]         {
[13:20:00.585]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.585]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.585]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.585]             })
[13:20:00.585]         }
[13:20:00.585]     }, args = future.call.arguments)
[13:20:00.585] }
[13:20:00.586] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.586] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.586] 
[13:20:00.586] getGlobalsAndPackages() ... DONE
[13:20:00.587] run() for ‘Future’ ...
[13:20:00.587] - state: ‘created’
[13:20:00.587] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.601] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.601]   - Field: ‘node’
[13:20:00.601]   - Field: ‘label’
[13:20:00.602]   - Field: ‘local’
[13:20:00.602]   - Field: ‘owner’
[13:20:00.602]   - Field: ‘envir’
[13:20:00.602]   - Field: ‘workers’
[13:20:00.602]   - Field: ‘packages’
[13:20:00.602]   - Field: ‘gc’
[13:20:00.602]   - Field: ‘conditions’
[13:20:00.602]   - Field: ‘persistent’
[13:20:00.602]   - Field: ‘expr’
[13:20:00.602]   - Field: ‘uuid’
[13:20:00.602]   - Field: ‘seed’
[13:20:00.603]   - Field: ‘version’
[13:20:00.603]   - Field: ‘result’
[13:20:00.603]   - Field: ‘asynchronous’
[13:20:00.603]   - Field: ‘calls’
[13:20:00.603]   - Field: ‘globals’
[13:20:00.603]   - Field: ‘stdout’
[13:20:00.603]   - Field: ‘earlySignal’
[13:20:00.603]   - Field: ‘lazy’
[13:20:00.603]   - Field: ‘state’
[13:20:00.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.603] - Launch lazy future ...
[13:20:00.604] Packages needed by the future expression (n = 0): <none>
[13:20:00.604] Packages needed by future strategies (n = 0): <none>
[13:20:00.604] {
[13:20:00.604]     {
[13:20:00.604]         {
[13:20:00.604]             ...future.startTime <- base::Sys.time()
[13:20:00.604]             {
[13:20:00.604]                 {
[13:20:00.604]                   {
[13:20:00.604]                     {
[13:20:00.604]                       base::local({
[13:20:00.604]                         has_future <- base::requireNamespace("future", 
[13:20:00.604]                           quietly = TRUE)
[13:20:00.604]                         if (has_future) {
[13:20:00.604]                           ns <- base::getNamespace("future")
[13:20:00.604]                           version <- ns[[".package"]][["version"]]
[13:20:00.604]                           if (is.null(version)) 
[13:20:00.604]                             version <- utils::packageVersion("future")
[13:20:00.604]                         }
[13:20:00.604]                         else {
[13:20:00.604]                           version <- NULL
[13:20:00.604]                         }
[13:20:00.604]                         if (!has_future || version < "1.8.0") {
[13:20:00.604]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.604]                             "", base::R.version$version.string), 
[13:20:00.604]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.604]                               "release", "version")], collapse = " "), 
[13:20:00.604]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.604]                             info)
[13:20:00.604]                           info <- base::paste(info, collapse = "; ")
[13:20:00.604]                           if (!has_future) {
[13:20:00.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.604]                               info)
[13:20:00.604]                           }
[13:20:00.604]                           else {
[13:20:00.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.604]                               info, version)
[13:20:00.604]                           }
[13:20:00.604]                           base::stop(msg)
[13:20:00.604]                         }
[13:20:00.604]                       })
[13:20:00.604]                     }
[13:20:00.604]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.604]                     base::options(mc.cores = 1L)
[13:20:00.604]                   }
[13:20:00.604]                   options(future.plan = NULL)
[13:20:00.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.604]                 }
[13:20:00.604]                 ...future.workdir <- getwd()
[13:20:00.604]             }
[13:20:00.604]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.604]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.604]         }
[13:20:00.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.604]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.604]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.604]             base::names(...future.oldOptions))
[13:20:00.604]     }
[13:20:00.604]     if (FALSE) {
[13:20:00.604]     }
[13:20:00.604]     else {
[13:20:00.604]         if (TRUE) {
[13:20:00.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.604]                 open = "w")
[13:20:00.604]         }
[13:20:00.604]         else {
[13:20:00.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.604]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.604]         }
[13:20:00.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.604]             base::sink(type = "output", split = FALSE)
[13:20:00.604]             base::close(...future.stdout)
[13:20:00.604]         }, add = TRUE)
[13:20:00.604]     }
[13:20:00.604]     ...future.frame <- base::sys.nframe()
[13:20:00.604]     ...future.conditions <- base::list()
[13:20:00.604]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.604]     if (FALSE) {
[13:20:00.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.604]     }
[13:20:00.604]     ...future.result <- base::tryCatch({
[13:20:00.604]         base::withCallingHandlers({
[13:20:00.604]             ...future.value <- base::withVisible(base::local({
[13:20:00.604]                 ...future.makeSendCondition <- base::local({
[13:20:00.604]                   sendCondition <- NULL
[13:20:00.604]                   function(frame = 1L) {
[13:20:00.604]                     if (is.function(sendCondition)) 
[13:20:00.604]                       return(sendCondition)
[13:20:00.604]                     ns <- getNamespace("parallel")
[13:20:00.604]                     if (exists("sendData", mode = "function", 
[13:20:00.604]                       envir = ns)) {
[13:20:00.604]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.604]                         envir = ns)
[13:20:00.604]                       envir <- sys.frame(frame)
[13:20:00.604]                       master <- NULL
[13:20:00.604]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.604]                         !identical(envir, emptyenv())) {
[13:20:00.604]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.604]                           inherits = FALSE)) {
[13:20:00.604]                           master <- get("master", mode = "list", 
[13:20:00.604]                             envir = envir, inherits = FALSE)
[13:20:00.604]                           if (inherits(master, c("SOCKnode", 
[13:20:00.604]                             "SOCK0node"))) {
[13:20:00.604]                             sendCondition <<- function(cond) {
[13:20:00.604]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.604]                                 success = TRUE)
[13:20:00.604]                               parallel_sendData(master, data)
[13:20:00.604]                             }
[13:20:00.604]                             return(sendCondition)
[13:20:00.604]                           }
[13:20:00.604]                         }
[13:20:00.604]                         frame <- frame + 1L
[13:20:00.604]                         envir <- sys.frame(frame)
[13:20:00.604]                       }
[13:20:00.604]                     }
[13:20:00.604]                     sendCondition <<- function(cond) NULL
[13:20:00.604]                   }
[13:20:00.604]                 })
[13:20:00.604]                 withCallingHandlers({
[13:20:00.604]                   {
[13:20:00.604]                     do.call(function(...) {
[13:20:00.604]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.604]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.604]                         ...future.globals.maxSize)) {
[13:20:00.604]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.604]                         on.exit(options(oopts), add = TRUE)
[13:20:00.604]                       }
[13:20:00.604]                       {
[13:20:00.604]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.604]                           FUN = function(jj) {
[13:20:00.604]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.604]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.604]                           })
[13:20:00.604]                       }
[13:20:00.604]                     }, args = future.call.arguments)
[13:20:00.604]                   }
[13:20:00.604]                 }, immediateCondition = function(cond) {
[13:20:00.604]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.604]                   sendCondition(cond)
[13:20:00.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.604]                   {
[13:20:00.604]                     inherits <- base::inherits
[13:20:00.604]                     invokeRestart <- base::invokeRestart
[13:20:00.604]                     is.null <- base::is.null
[13:20:00.604]                     muffled <- FALSE
[13:20:00.604]                     if (inherits(cond, "message")) {
[13:20:00.604]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.604]                       if (muffled) 
[13:20:00.604]                         invokeRestart("muffleMessage")
[13:20:00.604]                     }
[13:20:00.604]                     else if (inherits(cond, "warning")) {
[13:20:00.604]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.604]                       if (muffled) 
[13:20:00.604]                         invokeRestart("muffleWarning")
[13:20:00.604]                     }
[13:20:00.604]                     else if (inherits(cond, "condition")) {
[13:20:00.604]                       if (!is.null(pattern)) {
[13:20:00.604]                         computeRestarts <- base::computeRestarts
[13:20:00.604]                         grepl <- base::grepl
[13:20:00.604]                         restarts <- computeRestarts(cond)
[13:20:00.604]                         for (restart in restarts) {
[13:20:00.604]                           name <- restart$name
[13:20:00.604]                           if (is.null(name)) 
[13:20:00.604]                             next
[13:20:00.604]                           if (!grepl(pattern, name)) 
[13:20:00.604]                             next
[13:20:00.604]                           invokeRestart(restart)
[13:20:00.604]                           muffled <- TRUE
[13:20:00.604]                           break
[13:20:00.604]                         }
[13:20:00.604]                       }
[13:20:00.604]                     }
[13:20:00.604]                     invisible(muffled)
[13:20:00.604]                   }
[13:20:00.604]                   muffleCondition(cond)
[13:20:00.604]                 })
[13:20:00.604]             }))
[13:20:00.604]             future::FutureResult(value = ...future.value$value, 
[13:20:00.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.604]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.604]                     ...future.globalenv.names))
[13:20:00.604]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.604]         }, condition = base::local({
[13:20:00.604]             c <- base::c
[13:20:00.604]             inherits <- base::inherits
[13:20:00.604]             invokeRestart <- base::invokeRestart
[13:20:00.604]             length <- base::length
[13:20:00.604]             list <- base::list
[13:20:00.604]             seq.int <- base::seq.int
[13:20:00.604]             signalCondition <- base::signalCondition
[13:20:00.604]             sys.calls <- base::sys.calls
[13:20:00.604]             `[[` <- base::`[[`
[13:20:00.604]             `+` <- base::`+`
[13:20:00.604]             `<<-` <- base::`<<-`
[13:20:00.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.604]                   3L)]
[13:20:00.604]             }
[13:20:00.604]             function(cond) {
[13:20:00.604]                 is_error <- inherits(cond, "error")
[13:20:00.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.604]                   NULL)
[13:20:00.604]                 if (is_error) {
[13:20:00.604]                   sessionInformation <- function() {
[13:20:00.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.604]                       search = base::search(), system = base::Sys.info())
[13:20:00.604]                   }
[13:20:00.604]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.604]                     cond$call), session = sessionInformation(), 
[13:20:00.604]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.604]                   signalCondition(cond)
[13:20:00.604]                 }
[13:20:00.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.604]                 "immediateCondition"))) {
[13:20:00.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.604]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.604]                   if (TRUE && !signal) {
[13:20:00.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.604]                     {
[13:20:00.604]                       inherits <- base::inherits
[13:20:00.604]                       invokeRestart <- base::invokeRestart
[13:20:00.604]                       is.null <- base::is.null
[13:20:00.604]                       muffled <- FALSE
[13:20:00.604]                       if (inherits(cond, "message")) {
[13:20:00.604]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.604]                         if (muffled) 
[13:20:00.604]                           invokeRestart("muffleMessage")
[13:20:00.604]                       }
[13:20:00.604]                       else if (inherits(cond, "warning")) {
[13:20:00.604]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.604]                         if (muffled) 
[13:20:00.604]                           invokeRestart("muffleWarning")
[13:20:00.604]                       }
[13:20:00.604]                       else if (inherits(cond, "condition")) {
[13:20:00.604]                         if (!is.null(pattern)) {
[13:20:00.604]                           computeRestarts <- base::computeRestarts
[13:20:00.604]                           grepl <- base::grepl
[13:20:00.604]                           restarts <- computeRestarts(cond)
[13:20:00.604]                           for (restart in restarts) {
[13:20:00.604]                             name <- restart$name
[13:20:00.604]                             if (is.null(name)) 
[13:20:00.604]                               next
[13:20:00.604]                             if (!grepl(pattern, name)) 
[13:20:00.604]                               next
[13:20:00.604]                             invokeRestart(restart)
[13:20:00.604]                             muffled <- TRUE
[13:20:00.604]                             break
[13:20:00.604]                           }
[13:20:00.604]                         }
[13:20:00.604]                       }
[13:20:00.604]                       invisible(muffled)
[13:20:00.604]                     }
[13:20:00.604]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.604]                   }
[13:20:00.604]                 }
[13:20:00.604]                 else {
[13:20:00.604]                   if (TRUE) {
[13:20:00.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.604]                     {
[13:20:00.604]                       inherits <- base::inherits
[13:20:00.604]                       invokeRestart <- base::invokeRestart
[13:20:00.604]                       is.null <- base::is.null
[13:20:00.604]                       muffled <- FALSE
[13:20:00.604]                       if (inherits(cond, "message")) {
[13:20:00.604]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.604]                         if (muffled) 
[13:20:00.604]                           invokeRestart("muffleMessage")
[13:20:00.604]                       }
[13:20:00.604]                       else if (inherits(cond, "warning")) {
[13:20:00.604]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.604]                         if (muffled) 
[13:20:00.604]                           invokeRestart("muffleWarning")
[13:20:00.604]                       }
[13:20:00.604]                       else if (inherits(cond, "condition")) {
[13:20:00.604]                         if (!is.null(pattern)) {
[13:20:00.604]                           computeRestarts <- base::computeRestarts
[13:20:00.604]                           grepl <- base::grepl
[13:20:00.604]                           restarts <- computeRestarts(cond)
[13:20:00.604]                           for (restart in restarts) {
[13:20:00.604]                             name <- restart$name
[13:20:00.604]                             if (is.null(name)) 
[13:20:00.604]                               next
[13:20:00.604]                             if (!grepl(pattern, name)) 
[13:20:00.604]                               next
[13:20:00.604]                             invokeRestart(restart)
[13:20:00.604]                             muffled <- TRUE
[13:20:00.604]                             break
[13:20:00.604]                           }
[13:20:00.604]                         }
[13:20:00.604]                       }
[13:20:00.604]                       invisible(muffled)
[13:20:00.604]                     }
[13:20:00.604]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.604]                   }
[13:20:00.604]                 }
[13:20:00.604]             }
[13:20:00.604]         }))
[13:20:00.604]     }, error = function(ex) {
[13:20:00.604]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.604]                 ...future.rng), started = ...future.startTime, 
[13:20:00.604]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.604]             version = "1.8"), class = "FutureResult")
[13:20:00.604]     }, finally = {
[13:20:00.604]         if (!identical(...future.workdir, getwd())) 
[13:20:00.604]             setwd(...future.workdir)
[13:20:00.604]         {
[13:20:00.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.604]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.604]             }
[13:20:00.604]             base::options(...future.oldOptions)
[13:20:00.604]             if (.Platform$OS.type == "windows") {
[13:20:00.604]                 old_names <- names(...future.oldEnvVars)
[13:20:00.604]                 envs <- base::Sys.getenv()
[13:20:00.604]                 names <- names(envs)
[13:20:00.604]                 common <- intersect(names, old_names)
[13:20:00.604]                 added <- setdiff(names, old_names)
[13:20:00.604]                 removed <- setdiff(old_names, names)
[13:20:00.604]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.604]                   envs[common]]
[13:20:00.604]                 NAMES <- toupper(changed)
[13:20:00.604]                 args <- list()
[13:20:00.604]                 for (kk in seq_along(NAMES)) {
[13:20:00.604]                   name <- changed[[kk]]
[13:20:00.604]                   NAME <- NAMES[[kk]]
[13:20:00.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.604]                     next
[13:20:00.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.604]                 }
[13:20:00.604]                 NAMES <- toupper(added)
[13:20:00.604]                 for (kk in seq_along(NAMES)) {
[13:20:00.604]                   name <- added[[kk]]
[13:20:00.604]                   NAME <- NAMES[[kk]]
[13:20:00.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.604]                     next
[13:20:00.604]                   args[[name]] <- ""
[13:20:00.604]                 }
[13:20:00.604]                 NAMES <- toupper(removed)
[13:20:00.604]                 for (kk in seq_along(NAMES)) {
[13:20:00.604]                   name <- removed[[kk]]
[13:20:00.604]                   NAME <- NAMES[[kk]]
[13:20:00.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.604]                     next
[13:20:00.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.604]                 }
[13:20:00.604]                 if (length(args) > 0) 
[13:20:00.604]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.604]             }
[13:20:00.604]             else {
[13:20:00.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.604]             }
[13:20:00.604]             {
[13:20:00.604]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.604]                   0L) {
[13:20:00.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.604]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.604]                   base::options(opts)
[13:20:00.604]                 }
[13:20:00.604]                 {
[13:20:00.604]                   {
[13:20:00.604]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.604]                     NULL
[13:20:00.604]                   }
[13:20:00.604]                   options(future.plan = NULL)
[13:20:00.604]                   if (is.na(NA_character_)) 
[13:20:00.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.604]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.604]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.604]                     envir = parent.frame()) 
[13:20:00.604]                   {
[13:20:00.604]                     if (is.function(workers)) 
[13:20:00.604]                       workers <- workers()
[13:20:00.604]                     workers <- structure(as.integer(workers), 
[13:20:00.604]                       class = class(workers))
[13:20:00.604]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.604]                       workers >= 1)
[13:20:00.604]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.604]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.604]                     }
[13:20:00.604]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.604]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.604]                       envir = envir)
[13:20:00.604]                     if (!future$lazy) 
[13:20:00.604]                       future <- run(future)
[13:20:00.604]                     invisible(future)
[13:20:00.604]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.604]                 }
[13:20:00.604]             }
[13:20:00.604]         }
[13:20:00.604]     })
[13:20:00.604]     if (TRUE) {
[13:20:00.604]         base::sink(type = "output", split = FALSE)
[13:20:00.604]         if (TRUE) {
[13:20:00.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.604]         }
[13:20:00.604]         else {
[13:20:00.604]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.604]         }
[13:20:00.604]         base::close(...future.stdout)
[13:20:00.604]         ...future.stdout <- NULL
[13:20:00.604]     }
[13:20:00.604]     ...future.result$conditions <- ...future.conditions
[13:20:00.604]     ...future.result$finished <- base::Sys.time()
[13:20:00.604]     ...future.result
[13:20:00.604] }
[13:20:00.608] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[13:20:00.608] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:00.608] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.608] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:20:00.609] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:20:00.609] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:20:00.609] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.609] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:00.610] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.610] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:20:00.610] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.610] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[13:20:00.611] MultisessionFuture started
[13:20:00.611] - Launch lazy future ... done
[13:20:00.611] run() for ‘MultisessionFuture’ ... done
[13:20:00.611] Created future:
[13:20:00.611] MultisessionFuture:
[13:20:00.611] Label: ‘future_apply-1’
[13:20:00.611] Expression:
[13:20:00.611] {
[13:20:00.611]     do.call(function(...) {
[13:20:00.611]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.611]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.611]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.611]             on.exit(options(oopts), add = TRUE)
[13:20:00.611]         }
[13:20:00.611]         {
[13:20:00.611]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.611]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.611]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.611]             })
[13:20:00.611]         }
[13:20:00.611]     }, args = future.call.arguments)
[13:20:00.611] }
[13:20:00.611] Lazy evaluation: FALSE
[13:20:00.611] Asynchronous evaluation: TRUE
[13:20:00.611] Local evaluation: TRUE
[13:20:00.611] Environment: R_GlobalEnv
[13:20:00.611] Capture standard output: TRUE
[13:20:00.611] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.611] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.611] Packages: <none>
[13:20:00.611] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.611] Resolved: FALSE
[13:20:00.611] Value: <not collected>
[13:20:00.611] Conditions captured: <none>
[13:20:00.611] Early signaling: FALSE
[13:20:00.611] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.611] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.623] Chunk #1 of 2 ... DONE
[13:20:00.623] Chunk #2 of 2 ...
[13:20:00.623]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.623]  - seeds: <none>
[13:20:00.623]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.623] getGlobalsAndPackages() ...
[13:20:00.623] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.624] Resolving globals: FALSE
[13:20:00.624] Tweak future expression to call with '...' arguments ...
[13:20:00.624] {
[13:20:00.624]     do.call(function(...) {
[13:20:00.624]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.624]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.624]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.624]             on.exit(options(oopts), add = TRUE)
[13:20:00.624]         }
[13:20:00.624]         {
[13:20:00.624]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.624]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.624]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.624]             })
[13:20:00.624]         }
[13:20:00.624]     }, args = future.call.arguments)
[13:20:00.624] }
[13:20:00.624] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.625] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.625] 
[13:20:00.625] getGlobalsAndPackages() ... DONE
[13:20:00.625] run() for ‘Future’ ...
[13:20:00.625] - state: ‘created’
[13:20:00.625] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.639] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.640]   - Field: ‘node’
[13:20:00.640]   - Field: ‘label’
[13:20:00.640]   - Field: ‘local’
[13:20:00.640]   - Field: ‘owner’
[13:20:00.640]   - Field: ‘envir’
[13:20:00.640]   - Field: ‘workers’
[13:20:00.640]   - Field: ‘packages’
[13:20:00.641]   - Field: ‘gc’
[13:20:00.641]   - Field: ‘conditions’
[13:20:00.641]   - Field: ‘persistent’
[13:20:00.641]   - Field: ‘expr’
[13:20:00.641]   - Field: ‘uuid’
[13:20:00.641]   - Field: ‘seed’
[13:20:00.641]   - Field: ‘version’
[13:20:00.641]   - Field: ‘result’
[13:20:00.641]   - Field: ‘asynchronous’
[13:20:00.641]   - Field: ‘calls’
[13:20:00.641]   - Field: ‘globals’
[13:20:00.642]   - Field: ‘stdout’
[13:20:00.642]   - Field: ‘earlySignal’
[13:20:00.642]   - Field: ‘lazy’
[13:20:00.642]   - Field: ‘state’
[13:20:00.642] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.642] - Launch lazy future ...
[13:20:00.642] Packages needed by the future expression (n = 0): <none>
[13:20:00.643] Packages needed by future strategies (n = 0): <none>
[13:20:00.643] {
[13:20:00.643]     {
[13:20:00.643]         {
[13:20:00.643]             ...future.startTime <- base::Sys.time()
[13:20:00.643]             {
[13:20:00.643]                 {
[13:20:00.643]                   {
[13:20:00.643]                     {
[13:20:00.643]                       base::local({
[13:20:00.643]                         has_future <- base::requireNamespace("future", 
[13:20:00.643]                           quietly = TRUE)
[13:20:00.643]                         if (has_future) {
[13:20:00.643]                           ns <- base::getNamespace("future")
[13:20:00.643]                           version <- ns[[".package"]][["version"]]
[13:20:00.643]                           if (is.null(version)) 
[13:20:00.643]                             version <- utils::packageVersion("future")
[13:20:00.643]                         }
[13:20:00.643]                         else {
[13:20:00.643]                           version <- NULL
[13:20:00.643]                         }
[13:20:00.643]                         if (!has_future || version < "1.8.0") {
[13:20:00.643]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.643]                             "", base::R.version$version.string), 
[13:20:00.643]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.643]                               "release", "version")], collapse = " "), 
[13:20:00.643]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.643]                             info)
[13:20:00.643]                           info <- base::paste(info, collapse = "; ")
[13:20:00.643]                           if (!has_future) {
[13:20:00.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.643]                               info)
[13:20:00.643]                           }
[13:20:00.643]                           else {
[13:20:00.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.643]                               info, version)
[13:20:00.643]                           }
[13:20:00.643]                           base::stop(msg)
[13:20:00.643]                         }
[13:20:00.643]                       })
[13:20:00.643]                     }
[13:20:00.643]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.643]                     base::options(mc.cores = 1L)
[13:20:00.643]                   }
[13:20:00.643]                   options(future.plan = NULL)
[13:20:00.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.643]                 }
[13:20:00.643]                 ...future.workdir <- getwd()
[13:20:00.643]             }
[13:20:00.643]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.643]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.643]         }
[13:20:00.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.643]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.643]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.643]             base::names(...future.oldOptions))
[13:20:00.643]     }
[13:20:00.643]     if (FALSE) {
[13:20:00.643]     }
[13:20:00.643]     else {
[13:20:00.643]         if (TRUE) {
[13:20:00.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.643]                 open = "w")
[13:20:00.643]         }
[13:20:00.643]         else {
[13:20:00.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.643]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.643]         }
[13:20:00.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.643]             base::sink(type = "output", split = FALSE)
[13:20:00.643]             base::close(...future.stdout)
[13:20:00.643]         }, add = TRUE)
[13:20:00.643]     }
[13:20:00.643]     ...future.frame <- base::sys.nframe()
[13:20:00.643]     ...future.conditions <- base::list()
[13:20:00.643]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.643]     if (FALSE) {
[13:20:00.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.643]     }
[13:20:00.643]     ...future.result <- base::tryCatch({
[13:20:00.643]         base::withCallingHandlers({
[13:20:00.643]             ...future.value <- base::withVisible(base::local({
[13:20:00.643]                 ...future.makeSendCondition <- base::local({
[13:20:00.643]                   sendCondition <- NULL
[13:20:00.643]                   function(frame = 1L) {
[13:20:00.643]                     if (is.function(sendCondition)) 
[13:20:00.643]                       return(sendCondition)
[13:20:00.643]                     ns <- getNamespace("parallel")
[13:20:00.643]                     if (exists("sendData", mode = "function", 
[13:20:00.643]                       envir = ns)) {
[13:20:00.643]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.643]                         envir = ns)
[13:20:00.643]                       envir <- sys.frame(frame)
[13:20:00.643]                       master <- NULL
[13:20:00.643]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.643]                         !identical(envir, emptyenv())) {
[13:20:00.643]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.643]                           inherits = FALSE)) {
[13:20:00.643]                           master <- get("master", mode = "list", 
[13:20:00.643]                             envir = envir, inherits = FALSE)
[13:20:00.643]                           if (inherits(master, c("SOCKnode", 
[13:20:00.643]                             "SOCK0node"))) {
[13:20:00.643]                             sendCondition <<- function(cond) {
[13:20:00.643]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.643]                                 success = TRUE)
[13:20:00.643]                               parallel_sendData(master, data)
[13:20:00.643]                             }
[13:20:00.643]                             return(sendCondition)
[13:20:00.643]                           }
[13:20:00.643]                         }
[13:20:00.643]                         frame <- frame + 1L
[13:20:00.643]                         envir <- sys.frame(frame)
[13:20:00.643]                       }
[13:20:00.643]                     }
[13:20:00.643]                     sendCondition <<- function(cond) NULL
[13:20:00.643]                   }
[13:20:00.643]                 })
[13:20:00.643]                 withCallingHandlers({
[13:20:00.643]                   {
[13:20:00.643]                     do.call(function(...) {
[13:20:00.643]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.643]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.643]                         ...future.globals.maxSize)) {
[13:20:00.643]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.643]                         on.exit(options(oopts), add = TRUE)
[13:20:00.643]                       }
[13:20:00.643]                       {
[13:20:00.643]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.643]                           FUN = function(jj) {
[13:20:00.643]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.643]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.643]                           })
[13:20:00.643]                       }
[13:20:00.643]                     }, args = future.call.arguments)
[13:20:00.643]                   }
[13:20:00.643]                 }, immediateCondition = function(cond) {
[13:20:00.643]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.643]                   sendCondition(cond)
[13:20:00.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.643]                   {
[13:20:00.643]                     inherits <- base::inherits
[13:20:00.643]                     invokeRestart <- base::invokeRestart
[13:20:00.643]                     is.null <- base::is.null
[13:20:00.643]                     muffled <- FALSE
[13:20:00.643]                     if (inherits(cond, "message")) {
[13:20:00.643]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.643]                       if (muffled) 
[13:20:00.643]                         invokeRestart("muffleMessage")
[13:20:00.643]                     }
[13:20:00.643]                     else if (inherits(cond, "warning")) {
[13:20:00.643]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.643]                       if (muffled) 
[13:20:00.643]                         invokeRestart("muffleWarning")
[13:20:00.643]                     }
[13:20:00.643]                     else if (inherits(cond, "condition")) {
[13:20:00.643]                       if (!is.null(pattern)) {
[13:20:00.643]                         computeRestarts <- base::computeRestarts
[13:20:00.643]                         grepl <- base::grepl
[13:20:00.643]                         restarts <- computeRestarts(cond)
[13:20:00.643]                         for (restart in restarts) {
[13:20:00.643]                           name <- restart$name
[13:20:00.643]                           if (is.null(name)) 
[13:20:00.643]                             next
[13:20:00.643]                           if (!grepl(pattern, name)) 
[13:20:00.643]                             next
[13:20:00.643]                           invokeRestart(restart)
[13:20:00.643]                           muffled <- TRUE
[13:20:00.643]                           break
[13:20:00.643]                         }
[13:20:00.643]                       }
[13:20:00.643]                     }
[13:20:00.643]                     invisible(muffled)
[13:20:00.643]                   }
[13:20:00.643]                   muffleCondition(cond)
[13:20:00.643]                 })
[13:20:00.643]             }))
[13:20:00.643]             future::FutureResult(value = ...future.value$value, 
[13:20:00.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.643]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.643]                     ...future.globalenv.names))
[13:20:00.643]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.643]         }, condition = base::local({
[13:20:00.643]             c <- base::c
[13:20:00.643]             inherits <- base::inherits
[13:20:00.643]             invokeRestart <- base::invokeRestart
[13:20:00.643]             length <- base::length
[13:20:00.643]             list <- base::list
[13:20:00.643]             seq.int <- base::seq.int
[13:20:00.643]             signalCondition <- base::signalCondition
[13:20:00.643]             sys.calls <- base::sys.calls
[13:20:00.643]             `[[` <- base::`[[`
[13:20:00.643]             `+` <- base::`+`
[13:20:00.643]             `<<-` <- base::`<<-`
[13:20:00.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.643]                   3L)]
[13:20:00.643]             }
[13:20:00.643]             function(cond) {
[13:20:00.643]                 is_error <- inherits(cond, "error")
[13:20:00.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.643]                   NULL)
[13:20:00.643]                 if (is_error) {
[13:20:00.643]                   sessionInformation <- function() {
[13:20:00.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.643]                       search = base::search(), system = base::Sys.info())
[13:20:00.643]                   }
[13:20:00.643]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.643]                     cond$call), session = sessionInformation(), 
[13:20:00.643]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.643]                   signalCondition(cond)
[13:20:00.643]                 }
[13:20:00.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.643]                 "immediateCondition"))) {
[13:20:00.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.643]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.643]                   if (TRUE && !signal) {
[13:20:00.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.643]                     {
[13:20:00.643]                       inherits <- base::inherits
[13:20:00.643]                       invokeRestart <- base::invokeRestart
[13:20:00.643]                       is.null <- base::is.null
[13:20:00.643]                       muffled <- FALSE
[13:20:00.643]                       if (inherits(cond, "message")) {
[13:20:00.643]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.643]                         if (muffled) 
[13:20:00.643]                           invokeRestart("muffleMessage")
[13:20:00.643]                       }
[13:20:00.643]                       else if (inherits(cond, "warning")) {
[13:20:00.643]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.643]                         if (muffled) 
[13:20:00.643]                           invokeRestart("muffleWarning")
[13:20:00.643]                       }
[13:20:00.643]                       else if (inherits(cond, "condition")) {
[13:20:00.643]                         if (!is.null(pattern)) {
[13:20:00.643]                           computeRestarts <- base::computeRestarts
[13:20:00.643]                           grepl <- base::grepl
[13:20:00.643]                           restarts <- computeRestarts(cond)
[13:20:00.643]                           for (restart in restarts) {
[13:20:00.643]                             name <- restart$name
[13:20:00.643]                             if (is.null(name)) 
[13:20:00.643]                               next
[13:20:00.643]                             if (!grepl(pattern, name)) 
[13:20:00.643]                               next
[13:20:00.643]                             invokeRestart(restart)
[13:20:00.643]                             muffled <- TRUE
[13:20:00.643]                             break
[13:20:00.643]                           }
[13:20:00.643]                         }
[13:20:00.643]                       }
[13:20:00.643]                       invisible(muffled)
[13:20:00.643]                     }
[13:20:00.643]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.643]                   }
[13:20:00.643]                 }
[13:20:00.643]                 else {
[13:20:00.643]                   if (TRUE) {
[13:20:00.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.643]                     {
[13:20:00.643]                       inherits <- base::inherits
[13:20:00.643]                       invokeRestart <- base::invokeRestart
[13:20:00.643]                       is.null <- base::is.null
[13:20:00.643]                       muffled <- FALSE
[13:20:00.643]                       if (inherits(cond, "message")) {
[13:20:00.643]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.643]                         if (muffled) 
[13:20:00.643]                           invokeRestart("muffleMessage")
[13:20:00.643]                       }
[13:20:00.643]                       else if (inherits(cond, "warning")) {
[13:20:00.643]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.643]                         if (muffled) 
[13:20:00.643]                           invokeRestart("muffleWarning")
[13:20:00.643]                       }
[13:20:00.643]                       else if (inherits(cond, "condition")) {
[13:20:00.643]                         if (!is.null(pattern)) {
[13:20:00.643]                           computeRestarts <- base::computeRestarts
[13:20:00.643]                           grepl <- base::grepl
[13:20:00.643]                           restarts <- computeRestarts(cond)
[13:20:00.643]                           for (restart in restarts) {
[13:20:00.643]                             name <- restart$name
[13:20:00.643]                             if (is.null(name)) 
[13:20:00.643]                               next
[13:20:00.643]                             if (!grepl(pattern, name)) 
[13:20:00.643]                               next
[13:20:00.643]                             invokeRestart(restart)
[13:20:00.643]                             muffled <- TRUE
[13:20:00.643]                             break
[13:20:00.643]                           }
[13:20:00.643]                         }
[13:20:00.643]                       }
[13:20:00.643]                       invisible(muffled)
[13:20:00.643]                     }
[13:20:00.643]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.643]                   }
[13:20:00.643]                 }
[13:20:00.643]             }
[13:20:00.643]         }))
[13:20:00.643]     }, error = function(ex) {
[13:20:00.643]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.643]                 ...future.rng), started = ...future.startTime, 
[13:20:00.643]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.643]             version = "1.8"), class = "FutureResult")
[13:20:00.643]     }, finally = {
[13:20:00.643]         if (!identical(...future.workdir, getwd())) 
[13:20:00.643]             setwd(...future.workdir)
[13:20:00.643]         {
[13:20:00.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.643]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.643]             }
[13:20:00.643]             base::options(...future.oldOptions)
[13:20:00.643]             if (.Platform$OS.type == "windows") {
[13:20:00.643]                 old_names <- names(...future.oldEnvVars)
[13:20:00.643]                 envs <- base::Sys.getenv()
[13:20:00.643]                 names <- names(envs)
[13:20:00.643]                 common <- intersect(names, old_names)
[13:20:00.643]                 added <- setdiff(names, old_names)
[13:20:00.643]                 removed <- setdiff(old_names, names)
[13:20:00.643]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.643]                   envs[common]]
[13:20:00.643]                 NAMES <- toupper(changed)
[13:20:00.643]                 args <- list()
[13:20:00.643]                 for (kk in seq_along(NAMES)) {
[13:20:00.643]                   name <- changed[[kk]]
[13:20:00.643]                   NAME <- NAMES[[kk]]
[13:20:00.643]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.643]                     next
[13:20:00.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.643]                 }
[13:20:00.643]                 NAMES <- toupper(added)
[13:20:00.643]                 for (kk in seq_along(NAMES)) {
[13:20:00.643]                   name <- added[[kk]]
[13:20:00.643]                   NAME <- NAMES[[kk]]
[13:20:00.643]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.643]                     next
[13:20:00.643]                   args[[name]] <- ""
[13:20:00.643]                 }
[13:20:00.643]                 NAMES <- toupper(removed)
[13:20:00.643]                 for (kk in seq_along(NAMES)) {
[13:20:00.643]                   name <- removed[[kk]]
[13:20:00.643]                   NAME <- NAMES[[kk]]
[13:20:00.643]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.643]                     next
[13:20:00.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.643]                 }
[13:20:00.643]                 if (length(args) > 0) 
[13:20:00.643]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.643]             }
[13:20:00.643]             else {
[13:20:00.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.643]             }
[13:20:00.643]             {
[13:20:00.643]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.643]                   0L) {
[13:20:00.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.643]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.643]                   base::options(opts)
[13:20:00.643]                 }
[13:20:00.643]                 {
[13:20:00.643]                   {
[13:20:00.643]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.643]                     NULL
[13:20:00.643]                   }
[13:20:00.643]                   options(future.plan = NULL)
[13:20:00.643]                   if (is.na(NA_character_)) 
[13:20:00.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.643]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.643]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.643]                     envir = parent.frame()) 
[13:20:00.643]                   {
[13:20:00.643]                     if (is.function(workers)) 
[13:20:00.643]                       workers <- workers()
[13:20:00.643]                     workers <- structure(as.integer(workers), 
[13:20:00.643]                       class = class(workers))
[13:20:00.643]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.643]                       workers >= 1)
[13:20:00.643]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.643]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.643]                     }
[13:20:00.643]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.643]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.643]                       envir = envir)
[13:20:00.643]                     if (!future$lazy) 
[13:20:00.643]                       future <- run(future)
[13:20:00.643]                     invisible(future)
[13:20:00.643]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.643]                 }
[13:20:00.643]             }
[13:20:00.643]         }
[13:20:00.643]     })
[13:20:00.643]     if (TRUE) {
[13:20:00.643]         base::sink(type = "output", split = FALSE)
[13:20:00.643]         if (TRUE) {
[13:20:00.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.643]         }
[13:20:00.643]         else {
[13:20:00.643]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.643]         }
[13:20:00.643]         base::close(...future.stdout)
[13:20:00.643]         ...future.stdout <- NULL
[13:20:00.643]     }
[13:20:00.643]     ...future.result$conditions <- ...future.conditions
[13:20:00.643]     ...future.result$finished <- base::Sys.time()
[13:20:00.643]     ...future.result
[13:20:00.643] }
[13:20:00.646] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[13:20:00.647] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:00.647] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.647] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:20:00.647] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:20:00.648] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:20:00.648] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:20:00.648] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:00.648] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.648] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:20:00.649] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:20:00.649] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[13:20:00.649] MultisessionFuture started
[13:20:00.649] - Launch lazy future ... done
[13:20:00.650] run() for ‘MultisessionFuture’ ... done
[13:20:00.650] Created future:
[13:20:00.650] MultisessionFuture:
[13:20:00.650] Label: ‘future_apply-2’
[13:20:00.650] Expression:
[13:20:00.650] {
[13:20:00.650]     do.call(function(...) {
[13:20:00.650]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.650]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.650]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.650]             on.exit(options(oopts), add = TRUE)
[13:20:00.650]         }
[13:20:00.650]         {
[13:20:00.650]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.650]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.650]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.650]             })
[13:20:00.650]         }
[13:20:00.650]     }, args = future.call.arguments)
[13:20:00.650] }
[13:20:00.650] Lazy evaluation: FALSE
[13:20:00.650] Asynchronous evaluation: TRUE
[13:20:00.650] Local evaluation: TRUE
[13:20:00.650] Environment: R_GlobalEnv
[13:20:00.650] Capture standard output: TRUE
[13:20:00.650] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.650] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.650] Packages: <none>
[13:20:00.650] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.650] Resolved: FALSE
[13:20:00.650] Value: <not collected>
[13:20:00.650] Conditions captured: <none>
[13:20:00.650] Early signaling: FALSE
[13:20:00.650] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.650] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.661] Chunk #2 of 2 ... DONE
[13:20:00.662] Launching 2 futures (chunks) ... DONE
[13:20:00.662] Resolving 2 futures (chunks) ...
[13:20:00.662] resolve() on list ...
[13:20:00.662]  recursive: 0
[13:20:00.662]  length: 2
[13:20:00.662] 
[13:20:00.663] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.663] - Validating connection of MultisessionFuture
[13:20:00.663] - received message: FutureResult
[13:20:00.663] - Received FutureResult
[13:20:00.663] - Erased future from FutureRegistry
[13:20:00.663] result() for ClusterFuture ...
[13:20:00.663] - result already collected: FutureResult
[13:20:00.663] result() for ClusterFuture ... done
[13:20:00.664] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.664] Future #1
[13:20:00.664] result() for ClusterFuture ...
[13:20:00.664] - result already collected: FutureResult
[13:20:00.664] result() for ClusterFuture ... done
[13:20:00.664] result() for ClusterFuture ...
[13:20:00.664] - result already collected: FutureResult
[13:20:00.664] result() for ClusterFuture ... done
[13:20:00.664] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:00.664] - nx: 2
[13:20:00.665] - relay: TRUE
[13:20:00.665] - stdout: TRUE
[13:20:00.665] - signal: TRUE
[13:20:00.665] - resignal: FALSE
[13:20:00.665] - force: TRUE
[13:20:00.665] - relayed: [n=2] FALSE, FALSE
[13:20:00.665] - queued futures: [n=2] FALSE, FALSE
[13:20:00.665]  - until=1
[13:20:00.665]  - relaying element #1
[13:20:00.665] result() for ClusterFuture ...
[13:20:00.665] - result already collected: FutureResult
[13:20:00.665] result() for ClusterFuture ... done
[13:20:00.666] result() for ClusterFuture ...
[13:20:00.666] - result already collected: FutureResult
[13:20:00.666] result() for ClusterFuture ... done
[13:20:00.666] result() for ClusterFuture ...
[13:20:00.666] - result already collected: FutureResult
[13:20:00.666] result() for ClusterFuture ... done
[13:20:00.666] result() for ClusterFuture ...
[13:20:00.666] - result already collected: FutureResult
[13:20:00.666] result() for ClusterFuture ... done
[13:20:00.666] - relayed: [n=2] TRUE, FALSE
[13:20:00.666] - queued futures: [n=2] TRUE, FALSE
[13:20:00.667] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:00.667]  length: 1 (resolved future 1)
[13:20:00.697] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.697] - Validating connection of MultisessionFuture
[13:20:00.698] - received message: FutureResult
[13:20:00.698] - Received FutureResult
[13:20:00.698] - Erased future from FutureRegistry
[13:20:00.698] result() for ClusterFuture ...
[13:20:00.698] - result already collected: FutureResult
[13:20:00.698] result() for ClusterFuture ... done
[13:20:00.698] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.698] Future #2
[13:20:00.699] result() for ClusterFuture ...
[13:20:00.699] - result already collected: FutureResult
[13:20:00.699] result() for ClusterFuture ... done
[13:20:00.699] result() for ClusterFuture ...
[13:20:00.699] - result already collected: FutureResult
[13:20:00.699] result() for ClusterFuture ... done
[13:20:00.699] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:00.699] - nx: 2
[13:20:00.699] - relay: TRUE
[13:20:00.699] - stdout: TRUE
[13:20:00.699] - signal: TRUE
[13:20:00.699] - resignal: FALSE
[13:20:00.700] - force: TRUE
[13:20:00.700] - relayed: [n=2] TRUE, FALSE
[13:20:00.700] - queued futures: [n=2] TRUE, FALSE
[13:20:00.700]  - until=2
[13:20:00.700]  - relaying element #2
[13:20:00.700] result() for ClusterFuture ...
[13:20:00.700] - result already collected: FutureResult
[13:20:00.700] result() for ClusterFuture ... done
[13:20:00.700] result() for ClusterFuture ...
[13:20:00.700] - result already collected: FutureResult
[13:20:00.701] result() for ClusterFuture ... done
[13:20:00.701] result() for ClusterFuture ...
[13:20:00.701] - result already collected: FutureResult
[13:20:00.701] result() for ClusterFuture ... done
[13:20:00.701] result() for ClusterFuture ...
[13:20:00.701] - result already collected: FutureResult
[13:20:00.701] result() for ClusterFuture ... done
[13:20:00.701] - relayed: [n=2] TRUE, TRUE
[13:20:00.701] - queued futures: [n=2] TRUE, TRUE
[13:20:00.701] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:00.701]  length: 0 (resolved future 2)
[13:20:00.702] Relaying remaining futures
[13:20:00.702] signalConditionsASAP(NULL, pos=0) ...
[13:20:00.702] - nx: 2
[13:20:00.702] - relay: TRUE
[13:20:00.702] - stdout: TRUE
[13:20:00.702] - signal: TRUE
[13:20:00.702] - resignal: FALSE
[13:20:00.702] - force: TRUE
[13:20:00.702] - relayed: [n=2] TRUE, TRUE
[13:20:00.702] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:00.702] - relayed: [n=2] TRUE, TRUE
[13:20:00.703] - queued futures: [n=2] TRUE, TRUE
[13:20:00.703] signalConditionsASAP(NULL, pos=0) ... done
[13:20:00.703] resolve() on list ... DONE
[13:20:00.703] result() for ClusterFuture ...
[13:20:00.703] - result already collected: FutureResult
[13:20:00.703] result() for ClusterFuture ... done
[13:20:00.703] result() for ClusterFuture ...
[13:20:00.703] - result already collected: FutureResult
[13:20:00.703] result() for ClusterFuture ... done
[13:20:00.703] result() for ClusterFuture ...
[13:20:00.703] - result already collected: FutureResult
[13:20:00.704] result() for ClusterFuture ... done
[13:20:00.704] result() for ClusterFuture ...
[13:20:00.704] - result already collected: FutureResult
[13:20:00.704] result() for ClusterFuture ... done
[13:20:00.704]  - Number of value chunks collected: 2
[13:20:00.704] Resolving 2 futures (chunks) ... DONE
[13:20:00.704] Reducing values from 2 chunks ...
[13:20:00.704]  - Number of values collected after concatenation: 2
[13:20:00.704]  - Number of values expected: 2
[13:20:00.704] Reducing values from 2 chunks ... DONE
[13:20:00.704] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[13:20:00.705] getGlobalsAndPackagesXApply() ...
[13:20:00.705]  - future.globals: TRUE
[13:20:00.705] getGlobalsAndPackages() ...
[13:20:00.705] Searching for globals...
[13:20:00.706] - globals found: [1] ‘FUN’
[13:20:00.706] Searching for globals ... DONE
[13:20:00.706] Resolving globals: FALSE
[13:20:00.707] The total size of the 1 globals is 848 bytes (848 bytes)
[13:20:00.707] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:20:00.707] - globals: [1] ‘FUN’
[13:20:00.707] 
[13:20:00.707] getGlobalsAndPackages() ... DONE
[13:20:00.707]  - globals found/used: [n=1] ‘FUN’
[13:20:00.708]  - needed namespaces: [n=0] 
[13:20:00.708] Finding globals ... DONE
[13:20:00.708]  - use_args: TRUE
[13:20:00.708]  - Getting '...' globals ...
[13:20:00.708] resolve() on list ...
[13:20:00.708]  recursive: 0
[13:20:00.708]  length: 1
[13:20:00.708]  elements: ‘...’
[13:20:00.709]  length: 0 (resolved future 1)
[13:20:00.709] resolve() on list ... DONE
[13:20:00.709]    - '...' content: [n=0] 
[13:20:00.709] List of 1
[13:20:00.709]  $ ...: list()
[13:20:00.709]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.709]  - attr(*, "where")=List of 1
[13:20:00.709]   ..$ ...:<environment: 0x555924579c98> 
[13:20:00.709]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.709]  - attr(*, "resolved")= logi TRUE
[13:20:00.709]  - attr(*, "total_size")= num NA
[13:20:00.711]  - Getting '...' globals ... DONE
[13:20:00.712] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:00.712] List of 2
[13:20:00.712]  $ ...future.FUN:function (x)  
[13:20:00.712]  $ ...          : list()
[13:20:00.712]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.712]  - attr(*, "where")=List of 2
[13:20:00.712]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:00.712]   ..$ ...          :<environment: 0x555924579c98> 
[13:20:00.712]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.712]  - attr(*, "resolved")= logi FALSE
[13:20:00.712]  - attr(*, "total_size")= num 848
[13:20:00.714] Packages to be attached in all futures: [n=0] 
[13:20:00.714] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.718] future_lapply() ...
[13:20:00.722] Number of chunks: 2
[13:20:00.722] getGlobalsAndPackagesXApply() ...
[13:20:00.722]  - future.globals: <name-value list> with names ‘list()’
[13:20:00.722]  - use_args: TRUE
[13:20:00.722] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:20:00.725] List of 2
[13:20:00.725]  $ ...          : list()
[13:20:00.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.725]  $ ...future.FUN:function (x)  
[13:20:00.725]  - attr(*, "where")=List of 2
[13:20:00.725]   ..$ ...          :<environment: 0x555924579c98> 
[13:20:00.725]   ..$ ...future.FUN:<environment: namespace:base> 
[13:20:00.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.725]  - attr(*, "resolved")= logi FALSE
[13:20:00.725]  - attr(*, "total_size")= num NA
[13:20:00.728] Packages to be attached in all futures: [n=0] 
[13:20:00.728] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.728] Number of futures (= number of chunks): 2
[13:20:00.728] Launching 2 futures (chunks) ...
[13:20:00.728] Chunk #1 of 2 ...
[13:20:00.729]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.729]  - seeds: <none>
[13:20:00.729]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.729] getGlobalsAndPackages() ...
[13:20:00.729] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.729] Resolving globals: FALSE
[13:20:00.729] Tweak future expression to call with '...' arguments ...
[13:20:00.729] {
[13:20:00.729]     do.call(function(...) {
[13:20:00.729]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.729]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.729]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.729]             on.exit(options(oopts), add = TRUE)
[13:20:00.729]         }
[13:20:00.729]         {
[13:20:00.729]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.729]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.729]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.729]             })
[13:20:00.729]         }
[13:20:00.729]     }, args = future.call.arguments)
[13:20:00.729] }
[13:20:00.730] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.730] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.730] 
[13:20:00.730] getGlobalsAndPackages() ... DONE
[13:20:00.730] run() for ‘Future’ ...
[13:20:00.731] - state: ‘created’
[13:20:00.731] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.744] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.745]   - Field: ‘node’
[13:20:00.745]   - Field: ‘label’
[13:20:00.745]   - Field: ‘local’
[13:20:00.745]   - Field: ‘owner’
[13:20:00.745]   - Field: ‘envir’
[13:20:00.745]   - Field: ‘workers’
[13:20:00.745]   - Field: ‘packages’
[13:20:00.745]   - Field: ‘gc’
[13:20:00.745]   - Field: ‘conditions’
[13:20:00.745]   - Field: ‘persistent’
[13:20:00.745]   - Field: ‘expr’
[13:20:00.746]   - Field: ‘uuid’
[13:20:00.746]   - Field: ‘seed’
[13:20:00.746]   - Field: ‘version’
[13:20:00.746]   - Field: ‘result’
[13:20:00.746]   - Field: ‘asynchronous’
[13:20:00.746]   - Field: ‘calls’
[13:20:00.746]   - Field: ‘globals’
[13:20:00.746]   - Field: ‘stdout’
[13:20:00.746]   - Field: ‘earlySignal’
[13:20:00.746]   - Field: ‘lazy’
[13:20:00.746]   - Field: ‘state’
[13:20:00.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.747] - Launch lazy future ...
[13:20:00.747] Packages needed by the future expression (n = 0): <none>
[13:20:00.747] Packages needed by future strategies (n = 0): <none>
[13:20:00.747] {
[13:20:00.747]     {
[13:20:00.747]         {
[13:20:00.747]             ...future.startTime <- base::Sys.time()
[13:20:00.747]             {
[13:20:00.747]                 {
[13:20:00.747]                   {
[13:20:00.747]                     {
[13:20:00.747]                       base::local({
[13:20:00.747]                         has_future <- base::requireNamespace("future", 
[13:20:00.747]                           quietly = TRUE)
[13:20:00.747]                         if (has_future) {
[13:20:00.747]                           ns <- base::getNamespace("future")
[13:20:00.747]                           version <- ns[[".package"]][["version"]]
[13:20:00.747]                           if (is.null(version)) 
[13:20:00.747]                             version <- utils::packageVersion("future")
[13:20:00.747]                         }
[13:20:00.747]                         else {
[13:20:00.747]                           version <- NULL
[13:20:00.747]                         }
[13:20:00.747]                         if (!has_future || version < "1.8.0") {
[13:20:00.747]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.747]                             "", base::R.version$version.string), 
[13:20:00.747]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.747]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.747]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.747]                               "release", "version")], collapse = " "), 
[13:20:00.747]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.747]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.747]                             info)
[13:20:00.747]                           info <- base::paste(info, collapse = "; ")
[13:20:00.747]                           if (!has_future) {
[13:20:00.747]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.747]                               info)
[13:20:00.747]                           }
[13:20:00.747]                           else {
[13:20:00.747]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.747]                               info, version)
[13:20:00.747]                           }
[13:20:00.747]                           base::stop(msg)
[13:20:00.747]                         }
[13:20:00.747]                       })
[13:20:00.747]                     }
[13:20:00.747]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.747]                     base::options(mc.cores = 1L)
[13:20:00.747]                   }
[13:20:00.747]                   options(future.plan = NULL)
[13:20:00.747]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.747]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.747]                 }
[13:20:00.747]                 ...future.workdir <- getwd()
[13:20:00.747]             }
[13:20:00.747]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.747]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.747]         }
[13:20:00.747]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.747]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.747]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.747]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.747]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.747]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.747]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.747]             base::names(...future.oldOptions))
[13:20:00.747]     }
[13:20:00.747]     if (FALSE) {
[13:20:00.747]     }
[13:20:00.747]     else {
[13:20:00.747]         if (TRUE) {
[13:20:00.747]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.747]                 open = "w")
[13:20:00.747]         }
[13:20:00.747]         else {
[13:20:00.747]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.747]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.747]         }
[13:20:00.747]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.747]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.747]             base::sink(type = "output", split = FALSE)
[13:20:00.747]             base::close(...future.stdout)
[13:20:00.747]         }, add = TRUE)
[13:20:00.747]     }
[13:20:00.747]     ...future.frame <- base::sys.nframe()
[13:20:00.747]     ...future.conditions <- base::list()
[13:20:00.747]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.747]     if (FALSE) {
[13:20:00.747]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.747]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.747]     }
[13:20:00.747]     ...future.result <- base::tryCatch({
[13:20:00.747]         base::withCallingHandlers({
[13:20:00.747]             ...future.value <- base::withVisible(base::local({
[13:20:00.747]                 ...future.makeSendCondition <- base::local({
[13:20:00.747]                   sendCondition <- NULL
[13:20:00.747]                   function(frame = 1L) {
[13:20:00.747]                     if (is.function(sendCondition)) 
[13:20:00.747]                       return(sendCondition)
[13:20:00.747]                     ns <- getNamespace("parallel")
[13:20:00.747]                     if (exists("sendData", mode = "function", 
[13:20:00.747]                       envir = ns)) {
[13:20:00.747]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.747]                         envir = ns)
[13:20:00.747]                       envir <- sys.frame(frame)
[13:20:00.747]                       master <- NULL
[13:20:00.747]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.747]                         !identical(envir, emptyenv())) {
[13:20:00.747]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.747]                           inherits = FALSE)) {
[13:20:00.747]                           master <- get("master", mode = "list", 
[13:20:00.747]                             envir = envir, inherits = FALSE)
[13:20:00.747]                           if (inherits(master, c("SOCKnode", 
[13:20:00.747]                             "SOCK0node"))) {
[13:20:00.747]                             sendCondition <<- function(cond) {
[13:20:00.747]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.747]                                 success = TRUE)
[13:20:00.747]                               parallel_sendData(master, data)
[13:20:00.747]                             }
[13:20:00.747]                             return(sendCondition)
[13:20:00.747]                           }
[13:20:00.747]                         }
[13:20:00.747]                         frame <- frame + 1L
[13:20:00.747]                         envir <- sys.frame(frame)
[13:20:00.747]                       }
[13:20:00.747]                     }
[13:20:00.747]                     sendCondition <<- function(cond) NULL
[13:20:00.747]                   }
[13:20:00.747]                 })
[13:20:00.747]                 withCallingHandlers({
[13:20:00.747]                   {
[13:20:00.747]                     do.call(function(...) {
[13:20:00.747]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.747]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.747]                         ...future.globals.maxSize)) {
[13:20:00.747]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.747]                         on.exit(options(oopts), add = TRUE)
[13:20:00.747]                       }
[13:20:00.747]                       {
[13:20:00.747]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.747]                           FUN = function(jj) {
[13:20:00.747]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.747]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.747]                           })
[13:20:00.747]                       }
[13:20:00.747]                     }, args = future.call.arguments)
[13:20:00.747]                   }
[13:20:00.747]                 }, immediateCondition = function(cond) {
[13:20:00.747]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.747]                   sendCondition(cond)
[13:20:00.747]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.747]                   {
[13:20:00.747]                     inherits <- base::inherits
[13:20:00.747]                     invokeRestart <- base::invokeRestart
[13:20:00.747]                     is.null <- base::is.null
[13:20:00.747]                     muffled <- FALSE
[13:20:00.747]                     if (inherits(cond, "message")) {
[13:20:00.747]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.747]                       if (muffled) 
[13:20:00.747]                         invokeRestart("muffleMessage")
[13:20:00.747]                     }
[13:20:00.747]                     else if (inherits(cond, "warning")) {
[13:20:00.747]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.747]                       if (muffled) 
[13:20:00.747]                         invokeRestart("muffleWarning")
[13:20:00.747]                     }
[13:20:00.747]                     else if (inherits(cond, "condition")) {
[13:20:00.747]                       if (!is.null(pattern)) {
[13:20:00.747]                         computeRestarts <- base::computeRestarts
[13:20:00.747]                         grepl <- base::grepl
[13:20:00.747]                         restarts <- computeRestarts(cond)
[13:20:00.747]                         for (restart in restarts) {
[13:20:00.747]                           name <- restart$name
[13:20:00.747]                           if (is.null(name)) 
[13:20:00.747]                             next
[13:20:00.747]                           if (!grepl(pattern, name)) 
[13:20:00.747]                             next
[13:20:00.747]                           invokeRestart(restart)
[13:20:00.747]                           muffled <- TRUE
[13:20:00.747]                           break
[13:20:00.747]                         }
[13:20:00.747]                       }
[13:20:00.747]                     }
[13:20:00.747]                     invisible(muffled)
[13:20:00.747]                   }
[13:20:00.747]                   muffleCondition(cond)
[13:20:00.747]                 })
[13:20:00.747]             }))
[13:20:00.747]             future::FutureResult(value = ...future.value$value, 
[13:20:00.747]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.747]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.747]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.747]                     ...future.globalenv.names))
[13:20:00.747]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.747]         }, condition = base::local({
[13:20:00.747]             c <- base::c
[13:20:00.747]             inherits <- base::inherits
[13:20:00.747]             invokeRestart <- base::invokeRestart
[13:20:00.747]             length <- base::length
[13:20:00.747]             list <- base::list
[13:20:00.747]             seq.int <- base::seq.int
[13:20:00.747]             signalCondition <- base::signalCondition
[13:20:00.747]             sys.calls <- base::sys.calls
[13:20:00.747]             `[[` <- base::`[[`
[13:20:00.747]             `+` <- base::`+`
[13:20:00.747]             `<<-` <- base::`<<-`
[13:20:00.747]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.747]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.747]                   3L)]
[13:20:00.747]             }
[13:20:00.747]             function(cond) {
[13:20:00.747]                 is_error <- inherits(cond, "error")
[13:20:00.747]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.747]                   NULL)
[13:20:00.747]                 if (is_error) {
[13:20:00.747]                   sessionInformation <- function() {
[13:20:00.747]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.747]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.747]                       search = base::search(), system = base::Sys.info())
[13:20:00.747]                   }
[13:20:00.747]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.747]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.747]                     cond$call), session = sessionInformation(), 
[13:20:00.747]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.747]                   signalCondition(cond)
[13:20:00.747]                 }
[13:20:00.747]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.747]                 "immediateCondition"))) {
[13:20:00.747]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.747]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.747]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.747]                   if (TRUE && !signal) {
[13:20:00.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.747]                     {
[13:20:00.747]                       inherits <- base::inherits
[13:20:00.747]                       invokeRestart <- base::invokeRestart
[13:20:00.747]                       is.null <- base::is.null
[13:20:00.747]                       muffled <- FALSE
[13:20:00.747]                       if (inherits(cond, "message")) {
[13:20:00.747]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.747]                         if (muffled) 
[13:20:00.747]                           invokeRestart("muffleMessage")
[13:20:00.747]                       }
[13:20:00.747]                       else if (inherits(cond, "warning")) {
[13:20:00.747]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.747]                         if (muffled) 
[13:20:00.747]                           invokeRestart("muffleWarning")
[13:20:00.747]                       }
[13:20:00.747]                       else if (inherits(cond, "condition")) {
[13:20:00.747]                         if (!is.null(pattern)) {
[13:20:00.747]                           computeRestarts <- base::computeRestarts
[13:20:00.747]                           grepl <- base::grepl
[13:20:00.747]                           restarts <- computeRestarts(cond)
[13:20:00.747]                           for (restart in restarts) {
[13:20:00.747]                             name <- restart$name
[13:20:00.747]                             if (is.null(name)) 
[13:20:00.747]                               next
[13:20:00.747]                             if (!grepl(pattern, name)) 
[13:20:00.747]                               next
[13:20:00.747]                             invokeRestart(restart)
[13:20:00.747]                             muffled <- TRUE
[13:20:00.747]                             break
[13:20:00.747]                           }
[13:20:00.747]                         }
[13:20:00.747]                       }
[13:20:00.747]                       invisible(muffled)
[13:20:00.747]                     }
[13:20:00.747]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.747]                   }
[13:20:00.747]                 }
[13:20:00.747]                 else {
[13:20:00.747]                   if (TRUE) {
[13:20:00.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.747]                     {
[13:20:00.747]                       inherits <- base::inherits
[13:20:00.747]                       invokeRestart <- base::invokeRestart
[13:20:00.747]                       is.null <- base::is.null
[13:20:00.747]                       muffled <- FALSE
[13:20:00.747]                       if (inherits(cond, "message")) {
[13:20:00.747]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.747]                         if (muffled) 
[13:20:00.747]                           invokeRestart("muffleMessage")
[13:20:00.747]                       }
[13:20:00.747]                       else if (inherits(cond, "warning")) {
[13:20:00.747]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.747]                         if (muffled) 
[13:20:00.747]                           invokeRestart("muffleWarning")
[13:20:00.747]                       }
[13:20:00.747]                       else if (inherits(cond, "condition")) {
[13:20:00.747]                         if (!is.null(pattern)) {
[13:20:00.747]                           computeRestarts <- base::computeRestarts
[13:20:00.747]                           grepl <- base::grepl
[13:20:00.747]                           restarts <- computeRestarts(cond)
[13:20:00.747]                           for (restart in restarts) {
[13:20:00.747]                             name <- restart$name
[13:20:00.747]                             if (is.null(name)) 
[13:20:00.747]                               next
[13:20:00.747]                             if (!grepl(pattern, name)) 
[13:20:00.747]                               next
[13:20:00.747]                             invokeRestart(restart)
[13:20:00.747]                             muffled <- TRUE
[13:20:00.747]                             break
[13:20:00.747]                           }
[13:20:00.747]                         }
[13:20:00.747]                       }
[13:20:00.747]                       invisible(muffled)
[13:20:00.747]                     }
[13:20:00.747]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.747]                   }
[13:20:00.747]                 }
[13:20:00.747]             }
[13:20:00.747]         }))
[13:20:00.747]     }, error = function(ex) {
[13:20:00.747]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.747]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.747]                 ...future.rng), started = ...future.startTime, 
[13:20:00.747]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.747]             version = "1.8"), class = "FutureResult")
[13:20:00.747]     }, finally = {
[13:20:00.747]         if (!identical(...future.workdir, getwd())) 
[13:20:00.747]             setwd(...future.workdir)
[13:20:00.747]         {
[13:20:00.747]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.747]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.747]             }
[13:20:00.747]             base::options(...future.oldOptions)
[13:20:00.747]             if (.Platform$OS.type == "windows") {
[13:20:00.747]                 old_names <- names(...future.oldEnvVars)
[13:20:00.747]                 envs <- base::Sys.getenv()
[13:20:00.747]                 names <- names(envs)
[13:20:00.747]                 common <- intersect(names, old_names)
[13:20:00.747]                 added <- setdiff(names, old_names)
[13:20:00.747]                 removed <- setdiff(old_names, names)
[13:20:00.747]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.747]                   envs[common]]
[13:20:00.747]                 NAMES <- toupper(changed)
[13:20:00.747]                 args <- list()
[13:20:00.747]                 for (kk in seq_along(NAMES)) {
[13:20:00.747]                   name <- changed[[kk]]
[13:20:00.747]                   NAME <- NAMES[[kk]]
[13:20:00.747]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.747]                     next
[13:20:00.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.747]                 }
[13:20:00.747]                 NAMES <- toupper(added)
[13:20:00.747]                 for (kk in seq_along(NAMES)) {
[13:20:00.747]                   name <- added[[kk]]
[13:20:00.747]                   NAME <- NAMES[[kk]]
[13:20:00.747]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.747]                     next
[13:20:00.747]                   args[[name]] <- ""
[13:20:00.747]                 }
[13:20:00.747]                 NAMES <- toupper(removed)
[13:20:00.747]                 for (kk in seq_along(NAMES)) {
[13:20:00.747]                   name <- removed[[kk]]
[13:20:00.747]                   NAME <- NAMES[[kk]]
[13:20:00.747]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.747]                     next
[13:20:00.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.747]                 }
[13:20:00.747]                 if (length(args) > 0) 
[13:20:00.747]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.747]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.747]             }
[13:20:00.747]             else {
[13:20:00.747]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.747]             }
[13:20:00.747]             {
[13:20:00.747]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.747]                   0L) {
[13:20:00.747]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.747]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.747]                   base::options(opts)
[13:20:00.747]                 }
[13:20:00.747]                 {
[13:20:00.747]                   {
[13:20:00.747]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.747]                     NULL
[13:20:00.747]                   }
[13:20:00.747]                   options(future.plan = NULL)
[13:20:00.747]                   if (is.na(NA_character_)) 
[13:20:00.747]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.747]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.747]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.747]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.747]                     envir = parent.frame()) 
[13:20:00.747]                   {
[13:20:00.747]                     if (is.function(workers)) 
[13:20:00.747]                       workers <- workers()
[13:20:00.747]                     workers <- structure(as.integer(workers), 
[13:20:00.747]                       class = class(workers))
[13:20:00.747]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.747]                       workers >= 1)
[13:20:00.747]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.747]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.747]                     }
[13:20:00.747]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.747]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.747]                       envir = envir)
[13:20:00.747]                     if (!future$lazy) 
[13:20:00.747]                       future <- run(future)
[13:20:00.747]                     invisible(future)
[13:20:00.747]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.747]                 }
[13:20:00.747]             }
[13:20:00.747]         }
[13:20:00.747]     })
[13:20:00.747]     if (TRUE) {
[13:20:00.747]         base::sink(type = "output", split = FALSE)
[13:20:00.747]         if (TRUE) {
[13:20:00.747]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.747]         }
[13:20:00.747]         else {
[13:20:00.747]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.747]         }
[13:20:00.747]         base::close(...future.stdout)
[13:20:00.747]         ...future.stdout <- NULL
[13:20:00.747]     }
[13:20:00.747]     ...future.result$conditions <- ...future.conditions
[13:20:00.747]     ...future.result$finished <- base::Sys.time()
[13:20:00.747]     ...future.result
[13:20:00.747] }
[13:20:00.751] Exporting 5 global objects (1.12 KiB) to cluster node #1 ...
[13:20:00.751] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:00.751] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.751] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:20:00.752] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:20:00.752] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[13:20:00.752] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[13:20:00.752] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:00.753] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.753] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:20:00.753] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.753] Exporting 5 global objects (1.12 KiB) to cluster node #1 ... DONE
[13:20:00.754] MultisessionFuture started
[13:20:00.754] - Launch lazy future ... done
[13:20:00.754] run() for ‘MultisessionFuture’ ... done
[13:20:00.754] Created future:
[13:20:00.754] MultisessionFuture:
[13:20:00.754] Label: ‘future_apply-1’
[13:20:00.754] Expression:
[13:20:00.754] {
[13:20:00.754]     do.call(function(...) {
[13:20:00.754]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.754]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.754]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.754]             on.exit(options(oopts), add = TRUE)
[13:20:00.754]         }
[13:20:00.754]         {
[13:20:00.754]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.754]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.754]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.754]             })
[13:20:00.754]         }
[13:20:00.754]     }, args = future.call.arguments)
[13:20:00.754] }
[13:20:00.754] Lazy evaluation: FALSE
[13:20:00.754] Asynchronous evaluation: TRUE
[13:20:00.754] Local evaluation: TRUE
[13:20:00.754] Environment: R_GlobalEnv
[13:20:00.754] Capture standard output: TRUE
[13:20:00.754] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.754] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.754] Packages: <none>
[13:20:00.754] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.754] Resolved: FALSE
[13:20:00.754] Value: <not collected>
[13:20:00.754] Conditions captured: <none>
[13:20:00.754] Early signaling: FALSE
[13:20:00.754] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.754] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.766] Chunk #1 of 2 ... DONE
[13:20:00.766] Chunk #2 of 2 ...
[13:20:00.766]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.766]  - seeds: <none>
[13:20:00.766]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.766] getGlobalsAndPackages() ...
[13:20:00.766] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.767] Resolving globals: FALSE
[13:20:00.767] Tweak future expression to call with '...' arguments ...
[13:20:00.767] {
[13:20:00.767]     do.call(function(...) {
[13:20:00.767]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.767]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.767]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.767]             on.exit(options(oopts), add = TRUE)
[13:20:00.767]         }
[13:20:00.767]         {
[13:20:00.767]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.767]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.767]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.767]             })
[13:20:00.767]         }
[13:20:00.767]     }, args = future.call.arguments)
[13:20:00.767] }
[13:20:00.767] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.767] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.768] 
[13:20:00.768] getGlobalsAndPackages() ... DONE
[13:20:00.768] run() for ‘Future’ ...
[13:20:00.768] - state: ‘created’
[13:20:00.768] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.783] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.783] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.783]   - Field: ‘node’
[13:20:00.783]   - Field: ‘label’
[13:20:00.783]   - Field: ‘local’
[13:20:00.783]   - Field: ‘owner’
[13:20:00.783]   - Field: ‘envir’
[13:20:00.783]   - Field: ‘workers’
[13:20:00.783]   - Field: ‘packages’
[13:20:00.784]   - Field: ‘gc’
[13:20:00.784]   - Field: ‘conditions’
[13:20:00.784]   - Field: ‘persistent’
[13:20:00.784]   - Field: ‘expr’
[13:20:00.784]   - Field: ‘uuid’
[13:20:00.784]   - Field: ‘seed’
[13:20:00.784]   - Field: ‘version’
[13:20:00.784]   - Field: ‘result’
[13:20:00.784]   - Field: ‘asynchronous’
[13:20:00.784]   - Field: ‘calls’
[13:20:00.785]   - Field: ‘globals’
[13:20:00.785]   - Field: ‘stdout’
[13:20:00.785]   - Field: ‘earlySignal’
[13:20:00.785]   - Field: ‘lazy’
[13:20:00.785]   - Field: ‘state’
[13:20:00.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.785] - Launch lazy future ...
[13:20:00.785] Packages needed by the future expression (n = 0): <none>
[13:20:00.786] Packages needed by future strategies (n = 0): <none>
[13:20:00.786] {
[13:20:00.786]     {
[13:20:00.786]         {
[13:20:00.786]             ...future.startTime <- base::Sys.time()
[13:20:00.786]             {
[13:20:00.786]                 {
[13:20:00.786]                   {
[13:20:00.786]                     {
[13:20:00.786]                       base::local({
[13:20:00.786]                         has_future <- base::requireNamespace("future", 
[13:20:00.786]                           quietly = TRUE)
[13:20:00.786]                         if (has_future) {
[13:20:00.786]                           ns <- base::getNamespace("future")
[13:20:00.786]                           version <- ns[[".package"]][["version"]]
[13:20:00.786]                           if (is.null(version)) 
[13:20:00.786]                             version <- utils::packageVersion("future")
[13:20:00.786]                         }
[13:20:00.786]                         else {
[13:20:00.786]                           version <- NULL
[13:20:00.786]                         }
[13:20:00.786]                         if (!has_future || version < "1.8.0") {
[13:20:00.786]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.786]                             "", base::R.version$version.string), 
[13:20:00.786]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.786]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.786]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.786]                               "release", "version")], collapse = " "), 
[13:20:00.786]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.786]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.786]                             info)
[13:20:00.786]                           info <- base::paste(info, collapse = "; ")
[13:20:00.786]                           if (!has_future) {
[13:20:00.786]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.786]                               info)
[13:20:00.786]                           }
[13:20:00.786]                           else {
[13:20:00.786]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.786]                               info, version)
[13:20:00.786]                           }
[13:20:00.786]                           base::stop(msg)
[13:20:00.786]                         }
[13:20:00.786]                       })
[13:20:00.786]                     }
[13:20:00.786]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.786]                     base::options(mc.cores = 1L)
[13:20:00.786]                   }
[13:20:00.786]                   options(future.plan = NULL)
[13:20:00.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.786]                 }
[13:20:00.786]                 ...future.workdir <- getwd()
[13:20:00.786]             }
[13:20:00.786]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.786]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.786]         }
[13:20:00.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.786]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.786]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.786]             base::names(...future.oldOptions))
[13:20:00.786]     }
[13:20:00.786]     if (FALSE) {
[13:20:00.786]     }
[13:20:00.786]     else {
[13:20:00.786]         if (TRUE) {
[13:20:00.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.786]                 open = "w")
[13:20:00.786]         }
[13:20:00.786]         else {
[13:20:00.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.786]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.786]         }
[13:20:00.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.786]             base::sink(type = "output", split = FALSE)
[13:20:00.786]             base::close(...future.stdout)
[13:20:00.786]         }, add = TRUE)
[13:20:00.786]     }
[13:20:00.786]     ...future.frame <- base::sys.nframe()
[13:20:00.786]     ...future.conditions <- base::list()
[13:20:00.786]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.786]     if (FALSE) {
[13:20:00.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.786]     }
[13:20:00.786]     ...future.result <- base::tryCatch({
[13:20:00.786]         base::withCallingHandlers({
[13:20:00.786]             ...future.value <- base::withVisible(base::local({
[13:20:00.786]                 ...future.makeSendCondition <- base::local({
[13:20:00.786]                   sendCondition <- NULL
[13:20:00.786]                   function(frame = 1L) {
[13:20:00.786]                     if (is.function(sendCondition)) 
[13:20:00.786]                       return(sendCondition)
[13:20:00.786]                     ns <- getNamespace("parallel")
[13:20:00.786]                     if (exists("sendData", mode = "function", 
[13:20:00.786]                       envir = ns)) {
[13:20:00.786]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.786]                         envir = ns)
[13:20:00.786]                       envir <- sys.frame(frame)
[13:20:00.786]                       master <- NULL
[13:20:00.786]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.786]                         !identical(envir, emptyenv())) {
[13:20:00.786]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.786]                           inherits = FALSE)) {
[13:20:00.786]                           master <- get("master", mode = "list", 
[13:20:00.786]                             envir = envir, inherits = FALSE)
[13:20:00.786]                           if (inherits(master, c("SOCKnode", 
[13:20:00.786]                             "SOCK0node"))) {
[13:20:00.786]                             sendCondition <<- function(cond) {
[13:20:00.786]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.786]                                 success = TRUE)
[13:20:00.786]                               parallel_sendData(master, data)
[13:20:00.786]                             }
[13:20:00.786]                             return(sendCondition)
[13:20:00.786]                           }
[13:20:00.786]                         }
[13:20:00.786]                         frame <- frame + 1L
[13:20:00.786]                         envir <- sys.frame(frame)
[13:20:00.786]                       }
[13:20:00.786]                     }
[13:20:00.786]                     sendCondition <<- function(cond) NULL
[13:20:00.786]                   }
[13:20:00.786]                 })
[13:20:00.786]                 withCallingHandlers({
[13:20:00.786]                   {
[13:20:00.786]                     do.call(function(...) {
[13:20:00.786]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.786]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.786]                         ...future.globals.maxSize)) {
[13:20:00.786]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.786]                         on.exit(options(oopts), add = TRUE)
[13:20:00.786]                       }
[13:20:00.786]                       {
[13:20:00.786]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.786]                           FUN = function(jj) {
[13:20:00.786]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.786]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.786]                           })
[13:20:00.786]                       }
[13:20:00.786]                     }, args = future.call.arguments)
[13:20:00.786]                   }
[13:20:00.786]                 }, immediateCondition = function(cond) {
[13:20:00.786]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.786]                   sendCondition(cond)
[13:20:00.786]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.786]                   {
[13:20:00.786]                     inherits <- base::inherits
[13:20:00.786]                     invokeRestart <- base::invokeRestart
[13:20:00.786]                     is.null <- base::is.null
[13:20:00.786]                     muffled <- FALSE
[13:20:00.786]                     if (inherits(cond, "message")) {
[13:20:00.786]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.786]                       if (muffled) 
[13:20:00.786]                         invokeRestart("muffleMessage")
[13:20:00.786]                     }
[13:20:00.786]                     else if (inherits(cond, "warning")) {
[13:20:00.786]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.786]                       if (muffled) 
[13:20:00.786]                         invokeRestart("muffleWarning")
[13:20:00.786]                     }
[13:20:00.786]                     else if (inherits(cond, "condition")) {
[13:20:00.786]                       if (!is.null(pattern)) {
[13:20:00.786]                         computeRestarts <- base::computeRestarts
[13:20:00.786]                         grepl <- base::grepl
[13:20:00.786]                         restarts <- computeRestarts(cond)
[13:20:00.786]                         for (restart in restarts) {
[13:20:00.786]                           name <- restart$name
[13:20:00.786]                           if (is.null(name)) 
[13:20:00.786]                             next
[13:20:00.786]                           if (!grepl(pattern, name)) 
[13:20:00.786]                             next
[13:20:00.786]                           invokeRestart(restart)
[13:20:00.786]                           muffled <- TRUE
[13:20:00.786]                           break
[13:20:00.786]                         }
[13:20:00.786]                       }
[13:20:00.786]                     }
[13:20:00.786]                     invisible(muffled)
[13:20:00.786]                   }
[13:20:00.786]                   muffleCondition(cond)
[13:20:00.786]                 })
[13:20:00.786]             }))
[13:20:00.786]             future::FutureResult(value = ...future.value$value, 
[13:20:00.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.786]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.786]                     ...future.globalenv.names))
[13:20:00.786]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.786]         }, condition = base::local({
[13:20:00.786]             c <- base::c
[13:20:00.786]             inherits <- base::inherits
[13:20:00.786]             invokeRestart <- base::invokeRestart
[13:20:00.786]             length <- base::length
[13:20:00.786]             list <- base::list
[13:20:00.786]             seq.int <- base::seq.int
[13:20:00.786]             signalCondition <- base::signalCondition
[13:20:00.786]             sys.calls <- base::sys.calls
[13:20:00.786]             `[[` <- base::`[[`
[13:20:00.786]             `+` <- base::`+`
[13:20:00.786]             `<<-` <- base::`<<-`
[13:20:00.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.786]                   3L)]
[13:20:00.786]             }
[13:20:00.786]             function(cond) {
[13:20:00.786]                 is_error <- inherits(cond, "error")
[13:20:00.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.786]                   NULL)
[13:20:00.786]                 if (is_error) {
[13:20:00.786]                   sessionInformation <- function() {
[13:20:00.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.786]                       search = base::search(), system = base::Sys.info())
[13:20:00.786]                   }
[13:20:00.786]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.786]                     cond$call), session = sessionInformation(), 
[13:20:00.786]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.786]                   signalCondition(cond)
[13:20:00.786]                 }
[13:20:00.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.786]                 "immediateCondition"))) {
[13:20:00.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.786]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.786]                   if (TRUE && !signal) {
[13:20:00.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.786]                     {
[13:20:00.786]                       inherits <- base::inherits
[13:20:00.786]                       invokeRestart <- base::invokeRestart
[13:20:00.786]                       is.null <- base::is.null
[13:20:00.786]                       muffled <- FALSE
[13:20:00.786]                       if (inherits(cond, "message")) {
[13:20:00.786]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.786]                         if (muffled) 
[13:20:00.786]                           invokeRestart("muffleMessage")
[13:20:00.786]                       }
[13:20:00.786]                       else if (inherits(cond, "warning")) {
[13:20:00.786]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.786]                         if (muffled) 
[13:20:00.786]                           invokeRestart("muffleWarning")
[13:20:00.786]                       }
[13:20:00.786]                       else if (inherits(cond, "condition")) {
[13:20:00.786]                         if (!is.null(pattern)) {
[13:20:00.786]                           computeRestarts <- base::computeRestarts
[13:20:00.786]                           grepl <- base::grepl
[13:20:00.786]                           restarts <- computeRestarts(cond)
[13:20:00.786]                           for (restart in restarts) {
[13:20:00.786]                             name <- restart$name
[13:20:00.786]                             if (is.null(name)) 
[13:20:00.786]                               next
[13:20:00.786]                             if (!grepl(pattern, name)) 
[13:20:00.786]                               next
[13:20:00.786]                             invokeRestart(restart)
[13:20:00.786]                             muffled <- TRUE
[13:20:00.786]                             break
[13:20:00.786]                           }
[13:20:00.786]                         }
[13:20:00.786]                       }
[13:20:00.786]                       invisible(muffled)
[13:20:00.786]                     }
[13:20:00.786]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.786]                   }
[13:20:00.786]                 }
[13:20:00.786]                 else {
[13:20:00.786]                   if (TRUE) {
[13:20:00.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.786]                     {
[13:20:00.786]                       inherits <- base::inherits
[13:20:00.786]                       invokeRestart <- base::invokeRestart
[13:20:00.786]                       is.null <- base::is.null
[13:20:00.786]                       muffled <- FALSE
[13:20:00.786]                       if (inherits(cond, "message")) {
[13:20:00.786]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.786]                         if (muffled) 
[13:20:00.786]                           invokeRestart("muffleMessage")
[13:20:00.786]                       }
[13:20:00.786]                       else if (inherits(cond, "warning")) {
[13:20:00.786]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.786]                         if (muffled) 
[13:20:00.786]                           invokeRestart("muffleWarning")
[13:20:00.786]                       }
[13:20:00.786]                       else if (inherits(cond, "condition")) {
[13:20:00.786]                         if (!is.null(pattern)) {
[13:20:00.786]                           computeRestarts <- base::computeRestarts
[13:20:00.786]                           grepl <- base::grepl
[13:20:00.786]                           restarts <- computeRestarts(cond)
[13:20:00.786]                           for (restart in restarts) {
[13:20:00.786]                             name <- restart$name
[13:20:00.786]                             if (is.null(name)) 
[13:20:00.786]                               next
[13:20:00.786]                             if (!grepl(pattern, name)) 
[13:20:00.786]                               next
[13:20:00.786]                             invokeRestart(restart)
[13:20:00.786]                             muffled <- TRUE
[13:20:00.786]                             break
[13:20:00.786]                           }
[13:20:00.786]                         }
[13:20:00.786]                       }
[13:20:00.786]                       invisible(muffled)
[13:20:00.786]                     }
[13:20:00.786]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.786]                   }
[13:20:00.786]                 }
[13:20:00.786]             }
[13:20:00.786]         }))
[13:20:00.786]     }, error = function(ex) {
[13:20:00.786]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.786]                 ...future.rng), started = ...future.startTime, 
[13:20:00.786]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.786]             version = "1.8"), class = "FutureResult")
[13:20:00.786]     }, finally = {
[13:20:00.786]         if (!identical(...future.workdir, getwd())) 
[13:20:00.786]             setwd(...future.workdir)
[13:20:00.786]         {
[13:20:00.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.786]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.786]             }
[13:20:00.786]             base::options(...future.oldOptions)
[13:20:00.786]             if (.Platform$OS.type == "windows") {
[13:20:00.786]                 old_names <- names(...future.oldEnvVars)
[13:20:00.786]                 envs <- base::Sys.getenv()
[13:20:00.786]                 names <- names(envs)
[13:20:00.786]                 common <- intersect(names, old_names)
[13:20:00.786]                 added <- setdiff(names, old_names)
[13:20:00.786]                 removed <- setdiff(old_names, names)
[13:20:00.786]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.786]                   envs[common]]
[13:20:00.786]                 NAMES <- toupper(changed)
[13:20:00.786]                 args <- list()
[13:20:00.786]                 for (kk in seq_along(NAMES)) {
[13:20:00.786]                   name <- changed[[kk]]
[13:20:00.786]                   NAME <- NAMES[[kk]]
[13:20:00.786]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.786]                     next
[13:20:00.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.786]                 }
[13:20:00.786]                 NAMES <- toupper(added)
[13:20:00.786]                 for (kk in seq_along(NAMES)) {
[13:20:00.786]                   name <- added[[kk]]
[13:20:00.786]                   NAME <- NAMES[[kk]]
[13:20:00.786]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.786]                     next
[13:20:00.786]                   args[[name]] <- ""
[13:20:00.786]                 }
[13:20:00.786]                 NAMES <- toupper(removed)
[13:20:00.786]                 for (kk in seq_along(NAMES)) {
[13:20:00.786]                   name <- removed[[kk]]
[13:20:00.786]                   NAME <- NAMES[[kk]]
[13:20:00.786]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.786]                     next
[13:20:00.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.786]                 }
[13:20:00.786]                 if (length(args) > 0) 
[13:20:00.786]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.786]             }
[13:20:00.786]             else {
[13:20:00.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.786]             }
[13:20:00.786]             {
[13:20:00.786]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.786]                   0L) {
[13:20:00.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.786]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.786]                   base::options(opts)
[13:20:00.786]                 }
[13:20:00.786]                 {
[13:20:00.786]                   {
[13:20:00.786]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.786]                     NULL
[13:20:00.786]                   }
[13:20:00.786]                   options(future.plan = NULL)
[13:20:00.786]                   if (is.na(NA_character_)) 
[13:20:00.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.786]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.786]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.786]                     envir = parent.frame()) 
[13:20:00.786]                   {
[13:20:00.786]                     if (is.function(workers)) 
[13:20:00.786]                       workers <- workers()
[13:20:00.786]                     workers <- structure(as.integer(workers), 
[13:20:00.786]                       class = class(workers))
[13:20:00.786]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.786]                       workers >= 1)
[13:20:00.786]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.786]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.786]                     }
[13:20:00.786]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.786]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.786]                       envir = envir)
[13:20:00.786]                     if (!future$lazy) 
[13:20:00.786]                       future <- run(future)
[13:20:00.786]                     invisible(future)
[13:20:00.786]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.786]                 }
[13:20:00.786]             }
[13:20:00.786]         }
[13:20:00.786]     })
[13:20:00.786]     if (TRUE) {
[13:20:00.786]         base::sink(type = "output", split = FALSE)
[13:20:00.786]         if (TRUE) {
[13:20:00.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.786]         }
[13:20:00.786]         else {
[13:20:00.786]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.786]         }
[13:20:00.786]         base::close(...future.stdout)
[13:20:00.786]         ...future.stdout <- NULL
[13:20:00.786]     }
[13:20:00.786]     ...future.result$conditions <- ...future.conditions
[13:20:00.786]     ...future.result$finished <- base::Sys.time()
[13:20:00.786]     ...future.result
[13:20:00.786] }
[13:20:00.789] Exporting 5 global objects (1.12 KiB) to cluster node #2 ...
[13:20:00.789] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:00.790] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.790] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:20:00.790] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:20:00.790] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[13:20:00.791] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[13:20:00.791] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:00.791] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.791] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:20:00.791] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:20:00.792] Exporting 5 global objects (1.12 KiB) to cluster node #2 ... DONE
[13:20:00.792] MultisessionFuture started
[13:20:00.792] - Launch lazy future ... done
[13:20:00.792] run() for ‘MultisessionFuture’ ... done
[13:20:00.792] Created future:
[13:20:00.793] MultisessionFuture:
[13:20:00.793] Label: ‘future_apply-2’
[13:20:00.793] Expression:
[13:20:00.793] {
[13:20:00.793]     do.call(function(...) {
[13:20:00.793]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.793]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.793]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.793]             on.exit(options(oopts), add = TRUE)
[13:20:00.793]         }
[13:20:00.793]         {
[13:20:00.793]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.793]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.793]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.793]             })
[13:20:00.793]         }
[13:20:00.793]     }, args = future.call.arguments)
[13:20:00.793] }
[13:20:00.793] Lazy evaluation: FALSE
[13:20:00.793] Asynchronous evaluation: TRUE
[13:20:00.793] Local evaluation: TRUE
[13:20:00.793] Environment: R_GlobalEnv
[13:20:00.793] Capture standard output: TRUE
[13:20:00.793] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.793] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.793] Packages: <none>
[13:20:00.793] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.793] Resolved: FALSE
[13:20:00.793] Value: <not collected>
[13:20:00.793] Conditions captured: <none>
[13:20:00.793] Early signaling: FALSE
[13:20:00.793] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.793] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.804] Chunk #2 of 2 ... DONE
[13:20:00.804] Launching 2 futures (chunks) ... DONE
[13:20:00.804] Resolving 2 futures (chunks) ...
[13:20:00.804] resolve() on list ...
[13:20:00.805]  recursive: 0
[13:20:00.805]  length: 2
[13:20:00.805] 
[13:20:00.805] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.805] - Validating connection of MultisessionFuture
[13:20:00.806] - received message: FutureResult
[13:20:00.806] - Received FutureResult
[13:20:00.806] - Erased future from FutureRegistry
[13:20:00.806] result() for ClusterFuture ...
[13:20:00.806] - result already collected: FutureResult
[13:20:00.806] result() for ClusterFuture ... done
[13:20:00.806] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.806] Future #1
[13:20:00.806] result() for ClusterFuture ...
[13:20:00.806] - result already collected: FutureResult
[13:20:00.806] result() for ClusterFuture ... done
[13:20:00.807] result() for ClusterFuture ...
[13:20:00.807] - result already collected: FutureResult
[13:20:00.807] result() for ClusterFuture ... done
[13:20:00.807] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:00.807] - nx: 2
[13:20:00.807] - relay: TRUE
[13:20:00.807] - stdout: TRUE
[13:20:00.807] - signal: TRUE
[13:20:00.807] - resignal: FALSE
[13:20:00.807] - force: TRUE
[13:20:00.807] - relayed: [n=2] FALSE, FALSE
[13:20:00.808] - queued futures: [n=2] FALSE, FALSE
[13:20:00.808]  - until=1
[13:20:00.808]  - relaying element #1
[13:20:00.808] result() for ClusterFuture ...
[13:20:00.808] - result already collected: FutureResult
[13:20:00.808] result() for ClusterFuture ... done
[13:20:00.808] result() for ClusterFuture ...
[13:20:00.808] - result already collected: FutureResult
[13:20:00.808] result() for ClusterFuture ... done
[13:20:00.808] result() for ClusterFuture ...
[13:20:00.808] - result already collected: FutureResult
[13:20:00.809] result() for ClusterFuture ... done
[13:20:00.809] result() for ClusterFuture ...
[13:20:00.809] - result already collected: FutureResult
[13:20:00.809] result() for ClusterFuture ... done
[13:20:00.809] - relayed: [n=2] TRUE, FALSE
[13:20:00.809] - queued futures: [n=2] TRUE, FALSE
[13:20:00.809] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:00.809]  length: 1 (resolved future 1)
[13:20:00.851] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.851] - Validating connection of MultisessionFuture
[13:20:00.851] - received message: FutureResult
[13:20:00.852] - Received FutureResult
[13:20:00.852] - Erased future from FutureRegistry
[13:20:00.852] result() for ClusterFuture ...
[13:20:00.852] - result already collected: FutureResult
[13:20:00.852] result() for ClusterFuture ... done
[13:20:00.852] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.852] Future #2
[13:20:00.852] result() for ClusterFuture ...
[13:20:00.852] - result already collected: FutureResult
[13:20:00.852] result() for ClusterFuture ... done
[13:20:00.853] result() for ClusterFuture ...
[13:20:00.853] - result already collected: FutureResult
[13:20:00.853] result() for ClusterFuture ... done
[13:20:00.853] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:00.853] - nx: 2
[13:20:00.853] - relay: TRUE
[13:20:00.853] - stdout: TRUE
[13:20:00.853] - signal: TRUE
[13:20:00.853] - resignal: FALSE
[13:20:00.853] - force: TRUE
[13:20:00.853] - relayed: [n=2] TRUE, FALSE
[13:20:00.854] - queued futures: [n=2] TRUE, FALSE
[13:20:00.854]  - until=2
[13:20:00.854]  - relaying element #2
[13:20:00.854] result() for ClusterFuture ...
[13:20:00.854] - result already collected: FutureResult
[13:20:00.854] result() for ClusterFuture ... done
[13:20:00.854] result() for ClusterFuture ...
[13:20:00.854] - result already collected: FutureResult
[13:20:00.854] result() for ClusterFuture ... done
[13:20:00.854] result() for ClusterFuture ...
[13:20:00.854] - result already collected: FutureResult
[13:20:00.855] result() for ClusterFuture ... done
[13:20:00.855] result() for ClusterFuture ...
[13:20:00.855] - result already collected: FutureResult
[13:20:00.855] result() for ClusterFuture ... done
[13:20:00.855] - relayed: [n=2] TRUE, TRUE
[13:20:00.855] - queued futures: [n=2] TRUE, TRUE
[13:20:00.855] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:00.855]  length: 0 (resolved future 2)
[13:20:00.855] Relaying remaining futures
[13:20:00.855] signalConditionsASAP(NULL, pos=0) ...
[13:20:00.855] - nx: 2
[13:20:00.856] - relay: TRUE
[13:20:00.856] - stdout: TRUE
[13:20:00.856] - signal: TRUE
[13:20:00.856] - resignal: FALSE
[13:20:00.856] - force: TRUE
[13:20:00.856] - relayed: [n=2] TRUE, TRUE
[13:20:00.856] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:00.856] - relayed: [n=2] TRUE, TRUE
[13:20:00.856] - queued futures: [n=2] TRUE, TRUE
[13:20:00.856] signalConditionsASAP(NULL, pos=0) ... done
[13:20:00.857] resolve() on list ... DONE
[13:20:00.857] result() for ClusterFuture ...
[13:20:00.857] - result already collected: FutureResult
[13:20:00.857] result() for ClusterFuture ... done
[13:20:00.857] result() for ClusterFuture ...
[13:20:00.857] - result already collected: FutureResult
[13:20:00.857] result() for ClusterFuture ... done
[13:20:00.857] result() for ClusterFuture ...
[13:20:00.857] - result already collected: FutureResult
[13:20:00.857] result() for ClusterFuture ... done
[13:20:00.857] result() for ClusterFuture ...
[13:20:00.857] - result already collected: FutureResult
[13:20:00.858] result() for ClusterFuture ... done
[13:20:00.858]  - Number of value chunks collected: 2
[13:20:00.858] Resolving 2 futures (chunks) ... DONE
[13:20:00.858] Reducing values from 2 chunks ...
[13:20:00.858]  - Number of values collected after concatenation: 2
[13:20:00.858]  - Number of values expected: 2
[13:20:00.858] Reducing values from 2 chunks ... DONE
[13:20:00.858] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[13:20:00.859] getGlobalsAndPackagesXApply() ...
[13:20:00.859]  - future.globals: TRUE
[13:20:00.859] getGlobalsAndPackages() ...
[13:20:00.859] Searching for globals...
[13:20:00.861] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[13:20:00.862] Searching for globals ... DONE
[13:20:00.862] Resolving globals: FALSE
[13:20:00.862] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[13:20:00.863] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[13:20:00.863] - globals: [1] ‘FUN’
[13:20:00.863] 
[13:20:00.863] getGlobalsAndPackages() ... DONE
[13:20:00.863]  - globals found/used: [n=1] ‘FUN’
[13:20:00.863]  - needed namespaces: [n=0] 
[13:20:00.863] Finding globals ... DONE
[13:20:00.863]  - use_args: TRUE
[13:20:00.863]  - Getting '...' globals ...
[13:20:00.864] resolve() on list ...
[13:20:00.864]  recursive: 0
[13:20:00.864]  length: 1
[13:20:00.864]  elements: ‘...’
[13:20:00.864]  length: 0 (resolved future 1)
[13:20:00.864] resolve() on list ... DONE
[13:20:00.864]    - '...' content: [n=0] 
[13:20:00.864] List of 1
[13:20:00.864]  $ ...: list()
[13:20:00.864]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.864]  - attr(*, "where")=List of 1
[13:20:00.864]   ..$ ...:<environment: 0x555923d726c0> 
[13:20:00.864]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.864]  - attr(*, "resolved")= logi TRUE
[13:20:00.864]  - attr(*, "total_size")= num NA
[13:20:00.867]  - Getting '...' globals ... DONE
[13:20:00.867] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:00.867] List of 2
[13:20:00.867]  $ ...future.FUN:function (x)  
[13:20:00.867]  $ ...          : list()
[13:20:00.867]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.867]  - attr(*, "where")=List of 2
[13:20:00.867]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:00.867]   ..$ ...          :<environment: 0x555923d726c0> 
[13:20:00.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.867]  - attr(*, "resolved")= logi FALSE
[13:20:00.867]  - attr(*, "total_size")= num 9888
[13:20:00.870] Packages to be attached in all futures: [n=0] 
[13:20:00.870] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.874] future_lapply() ...
[13:20:00.879] Number of chunks: 2
[13:20:00.879] getGlobalsAndPackagesXApply() ...
[13:20:00.879]  - future.globals: <name-value list> with names ‘list()’
[13:20:00.879]  - use_args: TRUE
[13:20:00.879] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:20:00.880] List of 2
[13:20:00.880]  $ ...          : list()
[13:20:00.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:00.880]  $ ...future.FUN:function (x)  
[13:20:00.880]  - attr(*, "where")=List of 2
[13:20:00.880]   ..$ ...          :<environment: 0x555923d726c0> 
[13:20:00.880]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:20:00.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:00.880]  - attr(*, "resolved")= logi FALSE
[13:20:00.880]  - attr(*, "total_size")= num NA
[13:20:00.882] Packages to be attached in all futures: [n=0] 
[13:20:00.882] getGlobalsAndPackagesXApply() ... DONE
[13:20:00.883] Number of futures (= number of chunks): 2
[13:20:00.883] Launching 2 futures (chunks) ...
[13:20:00.883] Chunk #1 of 2 ...
[13:20:00.883]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.883]  - seeds: <none>
[13:20:00.883]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.883] getGlobalsAndPackages() ...
[13:20:00.883] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.884] Resolving globals: FALSE
[13:20:00.884] Tweak future expression to call with '...' arguments ...
[13:20:00.884] {
[13:20:00.884]     do.call(function(...) {
[13:20:00.884]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.884]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.884]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.884]             on.exit(options(oopts), add = TRUE)
[13:20:00.884]         }
[13:20:00.884]         {
[13:20:00.884]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.884]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.884]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.884]             })
[13:20:00.884]         }
[13:20:00.884]     }, args = future.call.arguments)
[13:20:00.884] }
[13:20:00.884] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.884] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.885] 
[13:20:00.885] getGlobalsAndPackages() ... DONE
[13:20:00.885] run() for ‘Future’ ...
[13:20:00.885] - state: ‘created’
[13:20:00.885] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.899] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.899] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.900]   - Field: ‘node’
[13:20:00.900]   - Field: ‘label’
[13:20:00.900]   - Field: ‘local’
[13:20:00.900]   - Field: ‘owner’
[13:20:00.900]   - Field: ‘envir’
[13:20:00.900]   - Field: ‘workers’
[13:20:00.900]   - Field: ‘packages’
[13:20:00.900]   - Field: ‘gc’
[13:20:00.900]   - Field: ‘conditions’
[13:20:00.900]   - Field: ‘persistent’
[13:20:00.901]   - Field: ‘expr’
[13:20:00.901]   - Field: ‘uuid’
[13:20:00.901]   - Field: ‘seed’
[13:20:00.901]   - Field: ‘version’
[13:20:00.901]   - Field: ‘result’
[13:20:00.901]   - Field: ‘asynchronous’
[13:20:00.901]   - Field: ‘calls’
[13:20:00.901]   - Field: ‘globals’
[13:20:00.901]   - Field: ‘stdout’
[13:20:00.901]   - Field: ‘earlySignal’
[13:20:00.901]   - Field: ‘lazy’
[13:20:00.902]   - Field: ‘state’
[13:20:00.902] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.902] - Launch lazy future ...
[13:20:00.902] Packages needed by the future expression (n = 0): <none>
[13:20:00.902] Packages needed by future strategies (n = 0): <none>
[13:20:00.903] {
[13:20:00.903]     {
[13:20:00.903]         {
[13:20:00.903]             ...future.startTime <- base::Sys.time()
[13:20:00.903]             {
[13:20:00.903]                 {
[13:20:00.903]                   {
[13:20:00.903]                     {
[13:20:00.903]                       base::local({
[13:20:00.903]                         has_future <- base::requireNamespace("future", 
[13:20:00.903]                           quietly = TRUE)
[13:20:00.903]                         if (has_future) {
[13:20:00.903]                           ns <- base::getNamespace("future")
[13:20:00.903]                           version <- ns[[".package"]][["version"]]
[13:20:00.903]                           if (is.null(version)) 
[13:20:00.903]                             version <- utils::packageVersion("future")
[13:20:00.903]                         }
[13:20:00.903]                         else {
[13:20:00.903]                           version <- NULL
[13:20:00.903]                         }
[13:20:00.903]                         if (!has_future || version < "1.8.0") {
[13:20:00.903]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.903]                             "", base::R.version$version.string), 
[13:20:00.903]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.903]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.903]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.903]                               "release", "version")], collapse = " "), 
[13:20:00.903]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.903]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.903]                             info)
[13:20:00.903]                           info <- base::paste(info, collapse = "; ")
[13:20:00.903]                           if (!has_future) {
[13:20:00.903]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.903]                               info)
[13:20:00.903]                           }
[13:20:00.903]                           else {
[13:20:00.903]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.903]                               info, version)
[13:20:00.903]                           }
[13:20:00.903]                           base::stop(msg)
[13:20:00.903]                         }
[13:20:00.903]                       })
[13:20:00.903]                     }
[13:20:00.903]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.903]                     base::options(mc.cores = 1L)
[13:20:00.903]                   }
[13:20:00.903]                   options(future.plan = NULL)
[13:20:00.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.903]                 }
[13:20:00.903]                 ...future.workdir <- getwd()
[13:20:00.903]             }
[13:20:00.903]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.903]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.903]         }
[13:20:00.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.903]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.903]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.903]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.903]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.903]             base::names(...future.oldOptions))
[13:20:00.903]     }
[13:20:00.903]     if (FALSE) {
[13:20:00.903]     }
[13:20:00.903]     else {
[13:20:00.903]         if (TRUE) {
[13:20:00.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.903]                 open = "w")
[13:20:00.903]         }
[13:20:00.903]         else {
[13:20:00.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.903]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.903]         }
[13:20:00.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.903]             base::sink(type = "output", split = FALSE)
[13:20:00.903]             base::close(...future.stdout)
[13:20:00.903]         }, add = TRUE)
[13:20:00.903]     }
[13:20:00.903]     ...future.frame <- base::sys.nframe()
[13:20:00.903]     ...future.conditions <- base::list()
[13:20:00.903]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.903]     if (FALSE) {
[13:20:00.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.903]     }
[13:20:00.903]     ...future.result <- base::tryCatch({
[13:20:00.903]         base::withCallingHandlers({
[13:20:00.903]             ...future.value <- base::withVisible(base::local({
[13:20:00.903]                 ...future.makeSendCondition <- base::local({
[13:20:00.903]                   sendCondition <- NULL
[13:20:00.903]                   function(frame = 1L) {
[13:20:00.903]                     if (is.function(sendCondition)) 
[13:20:00.903]                       return(sendCondition)
[13:20:00.903]                     ns <- getNamespace("parallel")
[13:20:00.903]                     if (exists("sendData", mode = "function", 
[13:20:00.903]                       envir = ns)) {
[13:20:00.903]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.903]                         envir = ns)
[13:20:00.903]                       envir <- sys.frame(frame)
[13:20:00.903]                       master <- NULL
[13:20:00.903]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.903]                         !identical(envir, emptyenv())) {
[13:20:00.903]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.903]                           inherits = FALSE)) {
[13:20:00.903]                           master <- get("master", mode = "list", 
[13:20:00.903]                             envir = envir, inherits = FALSE)
[13:20:00.903]                           if (inherits(master, c("SOCKnode", 
[13:20:00.903]                             "SOCK0node"))) {
[13:20:00.903]                             sendCondition <<- function(cond) {
[13:20:00.903]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.903]                                 success = TRUE)
[13:20:00.903]                               parallel_sendData(master, data)
[13:20:00.903]                             }
[13:20:00.903]                             return(sendCondition)
[13:20:00.903]                           }
[13:20:00.903]                         }
[13:20:00.903]                         frame <- frame + 1L
[13:20:00.903]                         envir <- sys.frame(frame)
[13:20:00.903]                       }
[13:20:00.903]                     }
[13:20:00.903]                     sendCondition <<- function(cond) NULL
[13:20:00.903]                   }
[13:20:00.903]                 })
[13:20:00.903]                 withCallingHandlers({
[13:20:00.903]                   {
[13:20:00.903]                     do.call(function(...) {
[13:20:00.903]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.903]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.903]                         ...future.globals.maxSize)) {
[13:20:00.903]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.903]                         on.exit(options(oopts), add = TRUE)
[13:20:00.903]                       }
[13:20:00.903]                       {
[13:20:00.903]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.903]                           FUN = function(jj) {
[13:20:00.903]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.903]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.903]                           })
[13:20:00.903]                       }
[13:20:00.903]                     }, args = future.call.arguments)
[13:20:00.903]                   }
[13:20:00.903]                 }, immediateCondition = function(cond) {
[13:20:00.903]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.903]                   sendCondition(cond)
[13:20:00.903]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.903]                   {
[13:20:00.903]                     inherits <- base::inherits
[13:20:00.903]                     invokeRestart <- base::invokeRestart
[13:20:00.903]                     is.null <- base::is.null
[13:20:00.903]                     muffled <- FALSE
[13:20:00.903]                     if (inherits(cond, "message")) {
[13:20:00.903]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.903]                       if (muffled) 
[13:20:00.903]                         invokeRestart("muffleMessage")
[13:20:00.903]                     }
[13:20:00.903]                     else if (inherits(cond, "warning")) {
[13:20:00.903]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.903]                       if (muffled) 
[13:20:00.903]                         invokeRestart("muffleWarning")
[13:20:00.903]                     }
[13:20:00.903]                     else if (inherits(cond, "condition")) {
[13:20:00.903]                       if (!is.null(pattern)) {
[13:20:00.903]                         computeRestarts <- base::computeRestarts
[13:20:00.903]                         grepl <- base::grepl
[13:20:00.903]                         restarts <- computeRestarts(cond)
[13:20:00.903]                         for (restart in restarts) {
[13:20:00.903]                           name <- restart$name
[13:20:00.903]                           if (is.null(name)) 
[13:20:00.903]                             next
[13:20:00.903]                           if (!grepl(pattern, name)) 
[13:20:00.903]                             next
[13:20:00.903]                           invokeRestart(restart)
[13:20:00.903]                           muffled <- TRUE
[13:20:00.903]                           break
[13:20:00.903]                         }
[13:20:00.903]                       }
[13:20:00.903]                     }
[13:20:00.903]                     invisible(muffled)
[13:20:00.903]                   }
[13:20:00.903]                   muffleCondition(cond)
[13:20:00.903]                 })
[13:20:00.903]             }))
[13:20:00.903]             future::FutureResult(value = ...future.value$value, 
[13:20:00.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.903]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.903]                     ...future.globalenv.names))
[13:20:00.903]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.903]         }, condition = base::local({
[13:20:00.903]             c <- base::c
[13:20:00.903]             inherits <- base::inherits
[13:20:00.903]             invokeRestart <- base::invokeRestart
[13:20:00.903]             length <- base::length
[13:20:00.903]             list <- base::list
[13:20:00.903]             seq.int <- base::seq.int
[13:20:00.903]             signalCondition <- base::signalCondition
[13:20:00.903]             sys.calls <- base::sys.calls
[13:20:00.903]             `[[` <- base::`[[`
[13:20:00.903]             `+` <- base::`+`
[13:20:00.903]             `<<-` <- base::`<<-`
[13:20:00.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.903]                   3L)]
[13:20:00.903]             }
[13:20:00.903]             function(cond) {
[13:20:00.903]                 is_error <- inherits(cond, "error")
[13:20:00.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.903]                   NULL)
[13:20:00.903]                 if (is_error) {
[13:20:00.903]                   sessionInformation <- function() {
[13:20:00.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.903]                       search = base::search(), system = base::Sys.info())
[13:20:00.903]                   }
[13:20:00.903]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.903]                     cond$call), session = sessionInformation(), 
[13:20:00.903]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.903]                   signalCondition(cond)
[13:20:00.903]                 }
[13:20:00.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.903]                 "immediateCondition"))) {
[13:20:00.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.903]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.903]                   if (TRUE && !signal) {
[13:20:00.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.903]                     {
[13:20:00.903]                       inherits <- base::inherits
[13:20:00.903]                       invokeRestart <- base::invokeRestart
[13:20:00.903]                       is.null <- base::is.null
[13:20:00.903]                       muffled <- FALSE
[13:20:00.903]                       if (inherits(cond, "message")) {
[13:20:00.903]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.903]                         if (muffled) 
[13:20:00.903]                           invokeRestart("muffleMessage")
[13:20:00.903]                       }
[13:20:00.903]                       else if (inherits(cond, "warning")) {
[13:20:00.903]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.903]                         if (muffled) 
[13:20:00.903]                           invokeRestart("muffleWarning")
[13:20:00.903]                       }
[13:20:00.903]                       else if (inherits(cond, "condition")) {
[13:20:00.903]                         if (!is.null(pattern)) {
[13:20:00.903]                           computeRestarts <- base::computeRestarts
[13:20:00.903]                           grepl <- base::grepl
[13:20:00.903]                           restarts <- computeRestarts(cond)
[13:20:00.903]                           for (restart in restarts) {
[13:20:00.903]                             name <- restart$name
[13:20:00.903]                             if (is.null(name)) 
[13:20:00.903]                               next
[13:20:00.903]                             if (!grepl(pattern, name)) 
[13:20:00.903]                               next
[13:20:00.903]                             invokeRestart(restart)
[13:20:00.903]                             muffled <- TRUE
[13:20:00.903]                             break
[13:20:00.903]                           }
[13:20:00.903]                         }
[13:20:00.903]                       }
[13:20:00.903]                       invisible(muffled)
[13:20:00.903]                     }
[13:20:00.903]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.903]                   }
[13:20:00.903]                 }
[13:20:00.903]                 else {
[13:20:00.903]                   if (TRUE) {
[13:20:00.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.903]                     {
[13:20:00.903]                       inherits <- base::inherits
[13:20:00.903]                       invokeRestart <- base::invokeRestart
[13:20:00.903]                       is.null <- base::is.null
[13:20:00.903]                       muffled <- FALSE
[13:20:00.903]                       if (inherits(cond, "message")) {
[13:20:00.903]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.903]                         if (muffled) 
[13:20:00.903]                           invokeRestart("muffleMessage")
[13:20:00.903]                       }
[13:20:00.903]                       else if (inherits(cond, "warning")) {
[13:20:00.903]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.903]                         if (muffled) 
[13:20:00.903]                           invokeRestart("muffleWarning")
[13:20:00.903]                       }
[13:20:00.903]                       else if (inherits(cond, "condition")) {
[13:20:00.903]                         if (!is.null(pattern)) {
[13:20:00.903]                           computeRestarts <- base::computeRestarts
[13:20:00.903]                           grepl <- base::grepl
[13:20:00.903]                           restarts <- computeRestarts(cond)
[13:20:00.903]                           for (restart in restarts) {
[13:20:00.903]                             name <- restart$name
[13:20:00.903]                             if (is.null(name)) 
[13:20:00.903]                               next
[13:20:00.903]                             if (!grepl(pattern, name)) 
[13:20:00.903]                               next
[13:20:00.903]                             invokeRestart(restart)
[13:20:00.903]                             muffled <- TRUE
[13:20:00.903]                             break
[13:20:00.903]                           }
[13:20:00.903]                         }
[13:20:00.903]                       }
[13:20:00.903]                       invisible(muffled)
[13:20:00.903]                     }
[13:20:00.903]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.903]                   }
[13:20:00.903]                 }
[13:20:00.903]             }
[13:20:00.903]         }))
[13:20:00.903]     }, error = function(ex) {
[13:20:00.903]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.903]                 ...future.rng), started = ...future.startTime, 
[13:20:00.903]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.903]             version = "1.8"), class = "FutureResult")
[13:20:00.903]     }, finally = {
[13:20:00.903]         if (!identical(...future.workdir, getwd())) 
[13:20:00.903]             setwd(...future.workdir)
[13:20:00.903]         {
[13:20:00.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.903]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.903]             }
[13:20:00.903]             base::options(...future.oldOptions)
[13:20:00.903]             if (.Platform$OS.type == "windows") {
[13:20:00.903]                 old_names <- names(...future.oldEnvVars)
[13:20:00.903]                 envs <- base::Sys.getenv()
[13:20:00.903]                 names <- names(envs)
[13:20:00.903]                 common <- intersect(names, old_names)
[13:20:00.903]                 added <- setdiff(names, old_names)
[13:20:00.903]                 removed <- setdiff(old_names, names)
[13:20:00.903]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.903]                   envs[common]]
[13:20:00.903]                 NAMES <- toupper(changed)
[13:20:00.903]                 args <- list()
[13:20:00.903]                 for (kk in seq_along(NAMES)) {
[13:20:00.903]                   name <- changed[[kk]]
[13:20:00.903]                   NAME <- NAMES[[kk]]
[13:20:00.903]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.903]                     next
[13:20:00.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.903]                 }
[13:20:00.903]                 NAMES <- toupper(added)
[13:20:00.903]                 for (kk in seq_along(NAMES)) {
[13:20:00.903]                   name <- added[[kk]]
[13:20:00.903]                   NAME <- NAMES[[kk]]
[13:20:00.903]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.903]                     next
[13:20:00.903]                   args[[name]] <- ""
[13:20:00.903]                 }
[13:20:00.903]                 NAMES <- toupper(removed)
[13:20:00.903]                 for (kk in seq_along(NAMES)) {
[13:20:00.903]                   name <- removed[[kk]]
[13:20:00.903]                   NAME <- NAMES[[kk]]
[13:20:00.903]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.903]                     next
[13:20:00.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.903]                 }
[13:20:00.903]                 if (length(args) > 0) 
[13:20:00.903]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.903]             }
[13:20:00.903]             else {
[13:20:00.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.903]             }
[13:20:00.903]             {
[13:20:00.903]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.903]                   0L) {
[13:20:00.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.903]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.903]                   base::options(opts)
[13:20:00.903]                 }
[13:20:00.903]                 {
[13:20:00.903]                   {
[13:20:00.903]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.903]                     NULL
[13:20:00.903]                   }
[13:20:00.903]                   options(future.plan = NULL)
[13:20:00.903]                   if (is.na(NA_character_)) 
[13:20:00.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.903]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.903]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.903]                     envir = parent.frame()) 
[13:20:00.903]                   {
[13:20:00.903]                     if (is.function(workers)) 
[13:20:00.903]                       workers <- workers()
[13:20:00.903]                     workers <- structure(as.integer(workers), 
[13:20:00.903]                       class = class(workers))
[13:20:00.903]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.903]                       workers >= 1)
[13:20:00.903]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.903]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.903]                     }
[13:20:00.903]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.903]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.903]                       envir = envir)
[13:20:00.903]                     if (!future$lazy) 
[13:20:00.903]                       future <- run(future)
[13:20:00.903]                     invisible(future)
[13:20:00.903]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.903]                 }
[13:20:00.903]             }
[13:20:00.903]         }
[13:20:00.903]     })
[13:20:00.903]     if (TRUE) {
[13:20:00.903]         base::sink(type = "output", split = FALSE)
[13:20:00.903]         if (TRUE) {
[13:20:00.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.903]         }
[13:20:00.903]         else {
[13:20:00.903]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.903]         }
[13:20:00.903]         base::close(...future.stdout)
[13:20:00.903]         ...future.stdout <- NULL
[13:20:00.903]     }
[13:20:00.903]     ...future.result$conditions <- ...future.conditions
[13:20:00.903]     ...future.result$finished <- base::Sys.time()
[13:20:00.903]     ...future.result
[13:20:00.903] }
[13:20:00.906] Exporting 5 global objects (9.77 KiB) to cluster node #1 ...
[13:20:00.906] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:00.907] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.907] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[13:20:00.907] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[13:20:00.907] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:20:00.907] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.908] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:00.908] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:00.908] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:20:00.908] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.908] Exporting 5 global objects (9.77 KiB) to cluster node #1 ... DONE
[13:20:00.909] MultisessionFuture started
[13:20:00.909] - Launch lazy future ... done
[13:20:00.909] run() for ‘MultisessionFuture’ ... done
[13:20:00.909] Created future:
[13:20:00.909] MultisessionFuture:
[13:20:00.909] Label: ‘future_apply-1’
[13:20:00.909] Expression:
[13:20:00.909] {
[13:20:00.909]     do.call(function(...) {
[13:20:00.909]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.909]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.909]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.909]             on.exit(options(oopts), add = TRUE)
[13:20:00.909]         }
[13:20:00.909]         {
[13:20:00.909]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.909]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.909]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.909]             })
[13:20:00.909]         }
[13:20:00.909]     }, args = future.call.arguments)
[13:20:00.909] }
[13:20:00.909] Lazy evaluation: FALSE
[13:20:00.909] Asynchronous evaluation: TRUE
[13:20:00.909] Local evaluation: TRUE
[13:20:00.909] Environment: R_GlobalEnv
[13:20:00.909] Capture standard output: TRUE
[13:20:00.909] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.909] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.909] Packages: <none>
[13:20:00.909] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.909] Resolved: FALSE
[13:20:00.909] Value: <not collected>
[13:20:00.909] Conditions captured: <none>
[13:20:00.909] Early signaling: FALSE
[13:20:00.909] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.909] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.923] Chunk #1 of 2 ... DONE
[13:20:00.923] Chunk #2 of 2 ...
[13:20:00.924]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:00.924]  - seeds: <none>
[13:20:00.924]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.924] getGlobalsAndPackages() ...
[13:20:00.924] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.924] Resolving globals: FALSE
[13:20:00.924] Tweak future expression to call with '...' arguments ...
[13:20:00.925] {
[13:20:00.925]     do.call(function(...) {
[13:20:00.925]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.925]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.925]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.925]             on.exit(options(oopts), add = TRUE)
[13:20:00.925]         }
[13:20:00.925]         {
[13:20:00.925]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.925]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.925]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.925]             })
[13:20:00.925]         }
[13:20:00.925]     }, args = future.call.arguments)
[13:20:00.925] }
[13:20:00.925] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.925] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:00.925] 
[13:20:00.925] getGlobalsAndPackages() ... DONE
[13:20:00.926] run() for ‘Future’ ...
[13:20:00.926] - state: ‘created’
[13:20:00.926] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.940] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.940] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.941]   - Field: ‘node’
[13:20:00.941]   - Field: ‘label’
[13:20:00.941]   - Field: ‘local’
[13:20:00.941]   - Field: ‘owner’
[13:20:00.941]   - Field: ‘envir’
[13:20:00.941]   - Field: ‘workers’
[13:20:00.941]   - Field: ‘packages’
[13:20:00.941]   - Field: ‘gc’
[13:20:00.941]   - Field: ‘conditions’
[13:20:00.941]   - Field: ‘persistent’
[13:20:00.941]   - Field: ‘expr’
[13:20:00.942]   - Field: ‘uuid’
[13:20:00.942]   - Field: ‘seed’
[13:20:00.942]   - Field: ‘version’
[13:20:00.942]   - Field: ‘result’
[13:20:00.942]   - Field: ‘asynchronous’
[13:20:00.942]   - Field: ‘calls’
[13:20:00.942]   - Field: ‘globals’
[13:20:00.942]   - Field: ‘stdout’
[13:20:00.942]   - Field: ‘earlySignal’
[13:20:00.942]   - Field: ‘lazy’
[13:20:00.942]   - Field: ‘state’
[13:20:00.943] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.943] - Launch lazy future ...
[13:20:00.943] Packages needed by the future expression (n = 0): <none>
[13:20:00.943] Packages needed by future strategies (n = 0): <none>
[13:20:00.943] {
[13:20:00.943]     {
[13:20:00.943]         {
[13:20:00.943]             ...future.startTime <- base::Sys.time()
[13:20:00.943]             {
[13:20:00.943]                 {
[13:20:00.943]                   {
[13:20:00.943]                     {
[13:20:00.943]                       base::local({
[13:20:00.943]                         has_future <- base::requireNamespace("future", 
[13:20:00.943]                           quietly = TRUE)
[13:20:00.943]                         if (has_future) {
[13:20:00.943]                           ns <- base::getNamespace("future")
[13:20:00.943]                           version <- ns[[".package"]][["version"]]
[13:20:00.943]                           if (is.null(version)) 
[13:20:00.943]                             version <- utils::packageVersion("future")
[13:20:00.943]                         }
[13:20:00.943]                         else {
[13:20:00.943]                           version <- NULL
[13:20:00.943]                         }
[13:20:00.943]                         if (!has_future || version < "1.8.0") {
[13:20:00.943]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.943]                             "", base::R.version$version.string), 
[13:20:00.943]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.943]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.943]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.943]                               "release", "version")], collapse = " "), 
[13:20:00.943]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.943]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.943]                             info)
[13:20:00.943]                           info <- base::paste(info, collapse = "; ")
[13:20:00.943]                           if (!has_future) {
[13:20:00.943]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.943]                               info)
[13:20:00.943]                           }
[13:20:00.943]                           else {
[13:20:00.943]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.943]                               info, version)
[13:20:00.943]                           }
[13:20:00.943]                           base::stop(msg)
[13:20:00.943]                         }
[13:20:00.943]                       })
[13:20:00.943]                     }
[13:20:00.943]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.943]                     base::options(mc.cores = 1L)
[13:20:00.943]                   }
[13:20:00.943]                   options(future.plan = NULL)
[13:20:00.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.943]                 }
[13:20:00.943]                 ...future.workdir <- getwd()
[13:20:00.943]             }
[13:20:00.943]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.943]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.943]         }
[13:20:00.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.943]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:00.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.943]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.943]             base::names(...future.oldOptions))
[13:20:00.943]     }
[13:20:00.943]     if (FALSE) {
[13:20:00.943]     }
[13:20:00.943]     else {
[13:20:00.943]         if (TRUE) {
[13:20:00.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.943]                 open = "w")
[13:20:00.943]         }
[13:20:00.943]         else {
[13:20:00.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.943]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.943]         }
[13:20:00.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.943]             base::sink(type = "output", split = FALSE)
[13:20:00.943]             base::close(...future.stdout)
[13:20:00.943]         }, add = TRUE)
[13:20:00.943]     }
[13:20:00.943]     ...future.frame <- base::sys.nframe()
[13:20:00.943]     ...future.conditions <- base::list()
[13:20:00.943]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.943]     if (FALSE) {
[13:20:00.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.943]     }
[13:20:00.943]     ...future.result <- base::tryCatch({
[13:20:00.943]         base::withCallingHandlers({
[13:20:00.943]             ...future.value <- base::withVisible(base::local({
[13:20:00.943]                 ...future.makeSendCondition <- base::local({
[13:20:00.943]                   sendCondition <- NULL
[13:20:00.943]                   function(frame = 1L) {
[13:20:00.943]                     if (is.function(sendCondition)) 
[13:20:00.943]                       return(sendCondition)
[13:20:00.943]                     ns <- getNamespace("parallel")
[13:20:00.943]                     if (exists("sendData", mode = "function", 
[13:20:00.943]                       envir = ns)) {
[13:20:00.943]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.943]                         envir = ns)
[13:20:00.943]                       envir <- sys.frame(frame)
[13:20:00.943]                       master <- NULL
[13:20:00.943]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.943]                         !identical(envir, emptyenv())) {
[13:20:00.943]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.943]                           inherits = FALSE)) {
[13:20:00.943]                           master <- get("master", mode = "list", 
[13:20:00.943]                             envir = envir, inherits = FALSE)
[13:20:00.943]                           if (inherits(master, c("SOCKnode", 
[13:20:00.943]                             "SOCK0node"))) {
[13:20:00.943]                             sendCondition <<- function(cond) {
[13:20:00.943]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.943]                                 success = TRUE)
[13:20:00.943]                               parallel_sendData(master, data)
[13:20:00.943]                             }
[13:20:00.943]                             return(sendCondition)
[13:20:00.943]                           }
[13:20:00.943]                         }
[13:20:00.943]                         frame <- frame + 1L
[13:20:00.943]                         envir <- sys.frame(frame)
[13:20:00.943]                       }
[13:20:00.943]                     }
[13:20:00.943]                     sendCondition <<- function(cond) NULL
[13:20:00.943]                   }
[13:20:00.943]                 })
[13:20:00.943]                 withCallingHandlers({
[13:20:00.943]                   {
[13:20:00.943]                     do.call(function(...) {
[13:20:00.943]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.943]                       if (!identical(...future.globals.maxSize.org, 
[13:20:00.943]                         ...future.globals.maxSize)) {
[13:20:00.943]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.943]                         on.exit(options(oopts), add = TRUE)
[13:20:00.943]                       }
[13:20:00.943]                       {
[13:20:00.943]                         lapply(seq_along(...future.elements_ii), 
[13:20:00.943]                           FUN = function(jj) {
[13:20:00.943]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.943]                             ...future.FUN(...future.X_jj, ...)
[13:20:00.943]                           })
[13:20:00.943]                       }
[13:20:00.943]                     }, args = future.call.arguments)
[13:20:00.943]                   }
[13:20:00.943]                 }, immediateCondition = function(cond) {
[13:20:00.943]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.943]                   sendCondition(cond)
[13:20:00.943]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.943]                   {
[13:20:00.943]                     inherits <- base::inherits
[13:20:00.943]                     invokeRestart <- base::invokeRestart
[13:20:00.943]                     is.null <- base::is.null
[13:20:00.943]                     muffled <- FALSE
[13:20:00.943]                     if (inherits(cond, "message")) {
[13:20:00.943]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.943]                       if (muffled) 
[13:20:00.943]                         invokeRestart("muffleMessage")
[13:20:00.943]                     }
[13:20:00.943]                     else if (inherits(cond, "warning")) {
[13:20:00.943]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.943]                       if (muffled) 
[13:20:00.943]                         invokeRestart("muffleWarning")
[13:20:00.943]                     }
[13:20:00.943]                     else if (inherits(cond, "condition")) {
[13:20:00.943]                       if (!is.null(pattern)) {
[13:20:00.943]                         computeRestarts <- base::computeRestarts
[13:20:00.943]                         grepl <- base::grepl
[13:20:00.943]                         restarts <- computeRestarts(cond)
[13:20:00.943]                         for (restart in restarts) {
[13:20:00.943]                           name <- restart$name
[13:20:00.943]                           if (is.null(name)) 
[13:20:00.943]                             next
[13:20:00.943]                           if (!grepl(pattern, name)) 
[13:20:00.943]                             next
[13:20:00.943]                           invokeRestart(restart)
[13:20:00.943]                           muffled <- TRUE
[13:20:00.943]                           break
[13:20:00.943]                         }
[13:20:00.943]                       }
[13:20:00.943]                     }
[13:20:00.943]                     invisible(muffled)
[13:20:00.943]                   }
[13:20:00.943]                   muffleCondition(cond)
[13:20:00.943]                 })
[13:20:00.943]             }))
[13:20:00.943]             future::FutureResult(value = ...future.value$value, 
[13:20:00.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.943]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.943]                     ...future.globalenv.names))
[13:20:00.943]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.943]         }, condition = base::local({
[13:20:00.943]             c <- base::c
[13:20:00.943]             inherits <- base::inherits
[13:20:00.943]             invokeRestart <- base::invokeRestart
[13:20:00.943]             length <- base::length
[13:20:00.943]             list <- base::list
[13:20:00.943]             seq.int <- base::seq.int
[13:20:00.943]             signalCondition <- base::signalCondition
[13:20:00.943]             sys.calls <- base::sys.calls
[13:20:00.943]             `[[` <- base::`[[`
[13:20:00.943]             `+` <- base::`+`
[13:20:00.943]             `<<-` <- base::`<<-`
[13:20:00.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.943]                   3L)]
[13:20:00.943]             }
[13:20:00.943]             function(cond) {
[13:20:00.943]                 is_error <- inherits(cond, "error")
[13:20:00.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.943]                   NULL)
[13:20:00.943]                 if (is_error) {
[13:20:00.943]                   sessionInformation <- function() {
[13:20:00.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.943]                       search = base::search(), system = base::Sys.info())
[13:20:00.943]                   }
[13:20:00.943]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.943]                     cond$call), session = sessionInformation(), 
[13:20:00.943]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.943]                   signalCondition(cond)
[13:20:00.943]                 }
[13:20:00.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.943]                 "immediateCondition"))) {
[13:20:00.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.943]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.943]                   if (TRUE && !signal) {
[13:20:00.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.943]                     {
[13:20:00.943]                       inherits <- base::inherits
[13:20:00.943]                       invokeRestart <- base::invokeRestart
[13:20:00.943]                       is.null <- base::is.null
[13:20:00.943]                       muffled <- FALSE
[13:20:00.943]                       if (inherits(cond, "message")) {
[13:20:00.943]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.943]                         if (muffled) 
[13:20:00.943]                           invokeRestart("muffleMessage")
[13:20:00.943]                       }
[13:20:00.943]                       else if (inherits(cond, "warning")) {
[13:20:00.943]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.943]                         if (muffled) 
[13:20:00.943]                           invokeRestart("muffleWarning")
[13:20:00.943]                       }
[13:20:00.943]                       else if (inherits(cond, "condition")) {
[13:20:00.943]                         if (!is.null(pattern)) {
[13:20:00.943]                           computeRestarts <- base::computeRestarts
[13:20:00.943]                           grepl <- base::grepl
[13:20:00.943]                           restarts <- computeRestarts(cond)
[13:20:00.943]                           for (restart in restarts) {
[13:20:00.943]                             name <- restart$name
[13:20:00.943]                             if (is.null(name)) 
[13:20:00.943]                               next
[13:20:00.943]                             if (!grepl(pattern, name)) 
[13:20:00.943]                               next
[13:20:00.943]                             invokeRestart(restart)
[13:20:00.943]                             muffled <- TRUE
[13:20:00.943]                             break
[13:20:00.943]                           }
[13:20:00.943]                         }
[13:20:00.943]                       }
[13:20:00.943]                       invisible(muffled)
[13:20:00.943]                     }
[13:20:00.943]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.943]                   }
[13:20:00.943]                 }
[13:20:00.943]                 else {
[13:20:00.943]                   if (TRUE) {
[13:20:00.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.943]                     {
[13:20:00.943]                       inherits <- base::inherits
[13:20:00.943]                       invokeRestart <- base::invokeRestart
[13:20:00.943]                       is.null <- base::is.null
[13:20:00.943]                       muffled <- FALSE
[13:20:00.943]                       if (inherits(cond, "message")) {
[13:20:00.943]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.943]                         if (muffled) 
[13:20:00.943]                           invokeRestart("muffleMessage")
[13:20:00.943]                       }
[13:20:00.943]                       else if (inherits(cond, "warning")) {
[13:20:00.943]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.943]                         if (muffled) 
[13:20:00.943]                           invokeRestart("muffleWarning")
[13:20:00.943]                       }
[13:20:00.943]                       else if (inherits(cond, "condition")) {
[13:20:00.943]                         if (!is.null(pattern)) {
[13:20:00.943]                           computeRestarts <- base::computeRestarts
[13:20:00.943]                           grepl <- base::grepl
[13:20:00.943]                           restarts <- computeRestarts(cond)
[13:20:00.943]                           for (restart in restarts) {
[13:20:00.943]                             name <- restart$name
[13:20:00.943]                             if (is.null(name)) 
[13:20:00.943]                               next
[13:20:00.943]                             if (!grepl(pattern, name)) 
[13:20:00.943]                               next
[13:20:00.943]                             invokeRestart(restart)
[13:20:00.943]                             muffled <- TRUE
[13:20:00.943]                             break
[13:20:00.943]                           }
[13:20:00.943]                         }
[13:20:00.943]                       }
[13:20:00.943]                       invisible(muffled)
[13:20:00.943]                     }
[13:20:00.943]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.943]                   }
[13:20:00.943]                 }
[13:20:00.943]             }
[13:20:00.943]         }))
[13:20:00.943]     }, error = function(ex) {
[13:20:00.943]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.943]                 ...future.rng), started = ...future.startTime, 
[13:20:00.943]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.943]             version = "1.8"), class = "FutureResult")
[13:20:00.943]     }, finally = {
[13:20:00.943]         if (!identical(...future.workdir, getwd())) 
[13:20:00.943]             setwd(...future.workdir)
[13:20:00.943]         {
[13:20:00.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.943]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.943]             }
[13:20:00.943]             base::options(...future.oldOptions)
[13:20:00.943]             if (.Platform$OS.type == "windows") {
[13:20:00.943]                 old_names <- names(...future.oldEnvVars)
[13:20:00.943]                 envs <- base::Sys.getenv()
[13:20:00.943]                 names <- names(envs)
[13:20:00.943]                 common <- intersect(names, old_names)
[13:20:00.943]                 added <- setdiff(names, old_names)
[13:20:00.943]                 removed <- setdiff(old_names, names)
[13:20:00.943]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.943]                   envs[common]]
[13:20:00.943]                 NAMES <- toupper(changed)
[13:20:00.943]                 args <- list()
[13:20:00.943]                 for (kk in seq_along(NAMES)) {
[13:20:00.943]                   name <- changed[[kk]]
[13:20:00.943]                   NAME <- NAMES[[kk]]
[13:20:00.943]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.943]                     next
[13:20:00.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.943]                 }
[13:20:00.943]                 NAMES <- toupper(added)
[13:20:00.943]                 for (kk in seq_along(NAMES)) {
[13:20:00.943]                   name <- added[[kk]]
[13:20:00.943]                   NAME <- NAMES[[kk]]
[13:20:00.943]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.943]                     next
[13:20:00.943]                   args[[name]] <- ""
[13:20:00.943]                 }
[13:20:00.943]                 NAMES <- toupper(removed)
[13:20:00.943]                 for (kk in seq_along(NAMES)) {
[13:20:00.943]                   name <- removed[[kk]]
[13:20:00.943]                   NAME <- NAMES[[kk]]
[13:20:00.943]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.943]                     next
[13:20:00.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.943]                 }
[13:20:00.943]                 if (length(args) > 0) 
[13:20:00.943]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.943]             }
[13:20:00.943]             else {
[13:20:00.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.943]             }
[13:20:00.943]             {
[13:20:00.943]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.943]                   0L) {
[13:20:00.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.943]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.943]                   base::options(opts)
[13:20:00.943]                 }
[13:20:00.943]                 {
[13:20:00.943]                   {
[13:20:00.943]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.943]                     NULL
[13:20:00.943]                   }
[13:20:00.943]                   options(future.plan = NULL)
[13:20:00.943]                   if (is.na(NA_character_)) 
[13:20:00.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.943]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.943]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.943]                     envir = parent.frame()) 
[13:20:00.943]                   {
[13:20:00.943]                     if (is.function(workers)) 
[13:20:00.943]                       workers <- workers()
[13:20:00.943]                     workers <- structure(as.integer(workers), 
[13:20:00.943]                       class = class(workers))
[13:20:00.943]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.943]                       workers >= 1)
[13:20:00.943]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.943]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.943]                     }
[13:20:00.943]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.943]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.943]                       envir = envir)
[13:20:00.943]                     if (!future$lazy) 
[13:20:00.943]                       future <- run(future)
[13:20:00.943]                     invisible(future)
[13:20:00.943]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.943]                 }
[13:20:00.943]             }
[13:20:00.943]         }
[13:20:00.943]     })
[13:20:00.943]     if (TRUE) {
[13:20:00.943]         base::sink(type = "output", split = FALSE)
[13:20:00.943]         if (TRUE) {
[13:20:00.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.943]         }
[13:20:00.943]         else {
[13:20:00.943]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.943]         }
[13:20:00.943]         base::close(...future.stdout)
[13:20:00.943]         ...future.stdout <- NULL
[13:20:00.943]     }
[13:20:00.943]     ...future.result$conditions <- ...future.conditions
[13:20:00.943]     ...future.result$finished <- base::Sys.time()
[13:20:00.943]     ...future.result
[13:20:00.943] }
[13:20:00.947] Exporting 5 global objects (9.77 KiB) to cluster node #2 ...
[13:20:00.947] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:00.947] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.948] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[13:20:00.948] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[13:20:00.948] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:20:00.948] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:20:00.948] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:00.949] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:00.949] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:20:00.949] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:20:00.949] Exporting 5 global objects (9.77 KiB) to cluster node #2 ... DONE
[13:20:00.950] MultisessionFuture started
[13:20:00.950] - Launch lazy future ... done
[13:20:00.950] run() for ‘MultisessionFuture’ ... done
[13:20:00.950] Created future:
[13:20:00.950] MultisessionFuture:
[13:20:00.950] Label: ‘future_apply-2’
[13:20:00.950] Expression:
[13:20:00.950] {
[13:20:00.950]     do.call(function(...) {
[13:20:00.950]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:00.950]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:00.950]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:00.950]             on.exit(options(oopts), add = TRUE)
[13:20:00.950]         }
[13:20:00.950]         {
[13:20:00.950]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:00.950]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:00.950]                 ...future.FUN(...future.X_jj, ...)
[13:20:00.950]             })
[13:20:00.950]         }
[13:20:00.950]     }, args = future.call.arguments)
[13:20:00.950] }
[13:20:00.950] Lazy evaluation: FALSE
[13:20:00.950] Asynchronous evaluation: TRUE
[13:20:00.950] Local evaluation: TRUE
[13:20:00.950] Environment: R_GlobalEnv
[13:20:00.950] Capture standard output: TRUE
[13:20:00.950] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:00.950] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:00.950] Packages: <none>
[13:20:00.950] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:00.950] Resolved: FALSE
[13:20:00.950] Value: <not collected>
[13:20:00.950] Conditions captured: <none>
[13:20:00.950] Early signaling: FALSE
[13:20:00.950] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:00.950] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.962] Chunk #2 of 2 ... DONE
[13:20:00.962] Launching 2 futures (chunks) ... DONE
[13:20:00.962] Resolving 2 futures (chunks) ...
[13:20:00.962] resolve() on list ...
[13:20:00.962]  recursive: 0
[13:20:00.962]  length: 2
[13:20:00.963] 
[13:20:00.963] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.963] - Validating connection of MultisessionFuture
[13:20:00.963] - received message: FutureResult
[13:20:00.964] - Received FutureResult
[13:20:00.964] - Erased future from FutureRegistry
[13:20:00.964] result() for ClusterFuture ...
[13:20:00.964] - result already collected: FutureResult
[13:20:00.964] result() for ClusterFuture ... done
[13:20:00.964] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.964] Future #1
[13:20:00.964] result() for ClusterFuture ...
[13:20:00.964] - result already collected: FutureResult
[13:20:00.964] result() for ClusterFuture ... done
[13:20:00.965] result() for ClusterFuture ...
[13:20:00.965] - result already collected: FutureResult
[13:20:00.965] result() for ClusterFuture ... done
[13:20:00.965] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:00.965] - nx: 2
[13:20:00.965] - relay: TRUE
[13:20:00.965] - stdout: TRUE
[13:20:00.965] - signal: TRUE
[13:20:00.965] - resignal: FALSE
[13:20:00.965] - force: TRUE
[13:20:00.965] - relayed: [n=2] FALSE, FALSE
[13:20:00.965] - queued futures: [n=2] FALSE, FALSE
[13:20:00.966]  - until=1
[13:20:00.966]  - relaying element #1
[13:20:00.966] result() for ClusterFuture ...
[13:20:00.966] - result already collected: FutureResult
[13:20:00.966] result() for ClusterFuture ... done
[13:20:00.966] result() for ClusterFuture ...
[13:20:00.966] - result already collected: FutureResult
[13:20:00.966] result() for ClusterFuture ... done
[13:20:00.966] result() for ClusterFuture ...
[13:20:00.966] - result already collected: FutureResult
[13:20:00.967] result() for ClusterFuture ... done
[13:20:00.967] result() for ClusterFuture ...
[13:20:00.967] - result already collected: FutureResult
[13:20:00.967] result() for ClusterFuture ... done
[13:20:00.967] - relayed: [n=2] TRUE, FALSE
[13:20:00.967] - queued futures: [n=2] TRUE, FALSE
[13:20:00.967] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:00.967]  length: 1 (resolved future 1)
[13:20:00.997] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.997] - Validating connection of MultisessionFuture
[13:20:00.997] - received message: FutureResult
[13:20:00.997] - Received FutureResult
[13:20:00.998] - Erased future from FutureRegistry
[13:20:00.998] result() for ClusterFuture ...
[13:20:00.998] - result already collected: FutureResult
[13:20:00.998] result() for ClusterFuture ... done
[13:20:00.998] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.998] Future #2
[13:20:00.998] result() for ClusterFuture ...
[13:20:00.998] - result already collected: FutureResult
[13:20:00.998] result() for ClusterFuture ... done
[13:20:00.998] result() for ClusterFuture ...
[13:20:00.998] - result already collected: FutureResult
[13:20:00.999] result() for ClusterFuture ... done
[13:20:00.999] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:00.999] - nx: 2
[13:20:00.999] - relay: TRUE
[13:20:00.999] - stdout: TRUE
[13:20:00.999] - signal: TRUE
[13:20:00.999] - resignal: FALSE
[13:20:00.999] - force: TRUE
[13:20:00.999] - relayed: [n=2] TRUE, FALSE
[13:20:00.999] - queued futures: [n=2] TRUE, FALSE
[13:20:00.999]  - until=2
[13:20:01.000]  - relaying element #2
[13:20:01.000] result() for ClusterFuture ...
[13:20:01.000] - result already collected: FutureResult
[13:20:01.000] result() for ClusterFuture ... done
[13:20:01.000] result() for ClusterFuture ...
[13:20:01.000] - result already collected: FutureResult
[13:20:01.000] result() for ClusterFuture ... done
[13:20:01.000] result() for ClusterFuture ...
[13:20:01.000] - result already collected: FutureResult
[13:20:01.000] result() for ClusterFuture ... done
[13:20:01.001] result() for ClusterFuture ...
[13:20:01.001] - result already collected: FutureResult
[13:20:01.001] result() for ClusterFuture ... done
[13:20:01.001] - relayed: [n=2] TRUE, TRUE
[13:20:01.001] - queued futures: [n=2] TRUE, TRUE
[13:20:01.001] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:01.001]  length: 0 (resolved future 2)
[13:20:01.001] Relaying remaining futures
[13:20:01.001] signalConditionsASAP(NULL, pos=0) ...
[13:20:01.001] - nx: 2
[13:20:01.001] - relay: TRUE
[13:20:01.002] - stdout: TRUE
[13:20:01.002] - signal: TRUE
[13:20:01.002] - resignal: FALSE
[13:20:01.002] - force: TRUE
[13:20:01.002] - relayed: [n=2] TRUE, TRUE
[13:20:01.002] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:01.002] - relayed: [n=2] TRUE, TRUE
[13:20:01.002] - queued futures: [n=2] TRUE, TRUE
[13:20:01.002] signalConditionsASAP(NULL, pos=0) ... done
[13:20:01.002] resolve() on list ... DONE
[13:20:01.002] result() for ClusterFuture ...
[13:20:01.003] - result already collected: FutureResult
[13:20:01.003] result() for ClusterFuture ... done
[13:20:01.003] result() for ClusterFuture ...
[13:20:01.003] - result already collected: FutureResult
[13:20:01.003] result() for ClusterFuture ... done
[13:20:01.003] result() for ClusterFuture ...
[13:20:01.003] - result already collected: FutureResult
[13:20:01.003] result() for ClusterFuture ... done
[13:20:01.003] result() for ClusterFuture ...
[13:20:01.003] - result already collected: FutureResult
[13:20:01.003] result() for ClusterFuture ... done
[13:20:01.004]  - Number of value chunks collected: 2
[13:20:01.004] Resolving 2 futures (chunks) ... DONE
[13:20:01.004] Reducing values from 2 chunks ...
[13:20:01.004]  - Number of values collected after concatenation: 2
[13:20:01.004]  - Number of values expected: 2
[13:20:01.004] Reducing values from 2 chunks ... DONE
[13:20:01.004] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[13:20:01.004] getGlobalsAndPackagesXApply() ...
[13:20:01.005]  - future.globals: TRUE
[13:20:01.005] getGlobalsAndPackages() ...
[13:20:01.005] Searching for globals...
[13:20:01.008] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[13:20:01.008] Searching for globals ... DONE
[13:20:01.008] Resolving globals: FALSE
[13:20:01.009] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[13:20:01.009] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[13:20:01.009] - globals: [1] ‘FUN’
[13:20:01.009] 
[13:20:01.009] getGlobalsAndPackages() ... DONE
[13:20:01.009]  - globals found/used: [n=1] ‘FUN’
[13:20:01.010]  - needed namespaces: [n=0] 
[13:20:01.010] Finding globals ... DONE
[13:20:01.010]  - use_args: TRUE
[13:20:01.010]  - Getting '...' globals ...
[13:20:01.010] resolve() on list ...
[13:20:01.010]  recursive: 0
[13:20:01.010]  length: 1
[13:20:01.010]  elements: ‘...’
[13:20:01.011]  length: 0 (resolved future 1)
[13:20:01.011] resolve() on list ... DONE
[13:20:01.011]    - '...' content: [n=0] 
[13:20:01.011] List of 1
[13:20:01.011]  $ ...: list()
[13:20:01.011]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.011]  - attr(*, "where")=List of 1
[13:20:01.011]   ..$ ...:<environment: 0x5559232f9920> 
[13:20:01.011]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.011]  - attr(*, "resolved")= logi TRUE
[13:20:01.011]  - attr(*, "total_size")= num NA
[13:20:01.013]  - Getting '...' globals ... DONE
[13:20:01.014] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:01.014] List of 2
[13:20:01.014]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:20:01.014]  $ ...          : list()
[13:20:01.014]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.014]  - attr(*, "where")=List of 2
[13:20:01.014]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:01.014]   ..$ ...          :<environment: 0x5559232f9920> 
[13:20:01.014]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.014]  - attr(*, "resolved")= logi FALSE
[13:20:01.014]  - attr(*, "total_size")= num 36296
[13:20:01.016] Packages to be attached in all futures: [n=0] 
[13:20:01.016] getGlobalsAndPackagesXApply() ... DONE
[13:20:01.020] future_lapply() ...
[13:20:01.022] Generating random seeds ...
[13:20:01.022] Generating random seed streams for 2 elements ...
[13:20:01.022] Generating random seed streams for 2 elements ... DONE
[13:20:01.022] Generating random seeds ... DONE
[13:20:01.022] Will set RNG state on exit: 10407, 870086122, 1200792357, 1341429402, 198656393, 1459934026, -1095369201
[13:20:01.026] Number of chunks: 2
[13:20:01.026] getGlobalsAndPackagesXApply() ...
[13:20:01.026]  - future.globals: <name-value list> with names ‘list()’
[13:20:01.026]  - use_args: TRUE
[13:20:01.026] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:20:01.026] List of 2
[13:20:01.026]  $ ...          : list()
[13:20:01.026]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.026]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:20:01.026]  - attr(*, "where")=List of 2
[13:20:01.026]   ..$ ...          :<environment: 0x5559232f9920> 
[13:20:01.026]   ..$ ...future.FUN:<environment: namespace:base> 
[13:20:01.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.026]  - attr(*, "resolved")= logi FALSE
[13:20:01.026]  - attr(*, "total_size")= num NA
[13:20:01.030] Packages to be attached in all futures: [n=0] 
[13:20:01.030] getGlobalsAndPackagesXApply() ... DONE
[13:20:01.030] Number of futures (= number of chunks): 2
[13:20:01.030] Launching 2 futures (chunks) ...
[13:20:01.030] Chunk #1 of 2 ...
[13:20:01.030]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:01.031]  - seeds: [1] <seeds>
[13:20:01.031]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.031] getGlobalsAndPackages() ...
[13:20:01.031] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.031] Resolving globals: FALSE
[13:20:01.031] Tweak future expression to call with '...' arguments ...
[13:20:01.031] {
[13:20:01.031]     do.call(function(...) {
[13:20:01.031]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.031]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.031]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.031]             on.exit(options(oopts), add = TRUE)
[13:20:01.031]         }
[13:20:01.031]         {
[13:20:01.031]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.031]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.031]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:20:01.031]                   envir = globalenv(), inherits = FALSE)
[13:20:01.031]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.031]             })
[13:20:01.031]         }
[13:20:01.031]     }, args = future.call.arguments)
[13:20:01.031] }
[13:20:01.032] Tweak future expression to call with '...' arguments ... DONE
[13:20:01.032] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.032] 
[13:20:01.032] getGlobalsAndPackages() ... DONE
[13:20:01.032] run() for ‘Future’ ...
[13:20:01.033] - state: ‘created’
[13:20:01.033] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:01.046] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:01.046] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:01.046]   - Field: ‘node’
[13:20:01.047]   - Field: ‘label’
[13:20:01.047]   - Field: ‘local’
[13:20:01.047]   - Field: ‘owner’
[13:20:01.047]   - Field: ‘envir’
[13:20:01.047]   - Field: ‘workers’
[13:20:01.047]   - Field: ‘packages’
[13:20:01.047]   - Field: ‘gc’
[13:20:01.047]   - Field: ‘conditions’
[13:20:01.047]   - Field: ‘persistent’
[13:20:01.047]   - Field: ‘expr’
[13:20:01.047]   - Field: ‘uuid’
[13:20:01.048]   - Field: ‘seed’
[13:20:01.048]   - Field: ‘version’
[13:20:01.048]   - Field: ‘result’
[13:20:01.048]   - Field: ‘asynchronous’
[13:20:01.048]   - Field: ‘calls’
[13:20:01.048]   - Field: ‘globals’
[13:20:01.048]   - Field: ‘stdout’
[13:20:01.048]   - Field: ‘earlySignal’
[13:20:01.048]   - Field: ‘lazy’
[13:20:01.048]   - Field: ‘state’
[13:20:01.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:01.049] - Launch lazy future ...
[13:20:01.049] Packages needed by the future expression (n = 0): <none>
[13:20:01.049] Packages needed by future strategies (n = 0): <none>
[13:20:01.049] {
[13:20:01.049]     {
[13:20:01.049]         {
[13:20:01.049]             ...future.startTime <- base::Sys.time()
[13:20:01.049]             {
[13:20:01.049]                 {
[13:20:01.049]                   {
[13:20:01.049]                     {
[13:20:01.049]                       base::local({
[13:20:01.049]                         has_future <- base::requireNamespace("future", 
[13:20:01.049]                           quietly = TRUE)
[13:20:01.049]                         if (has_future) {
[13:20:01.049]                           ns <- base::getNamespace("future")
[13:20:01.049]                           version <- ns[[".package"]][["version"]]
[13:20:01.049]                           if (is.null(version)) 
[13:20:01.049]                             version <- utils::packageVersion("future")
[13:20:01.049]                         }
[13:20:01.049]                         else {
[13:20:01.049]                           version <- NULL
[13:20:01.049]                         }
[13:20:01.049]                         if (!has_future || version < "1.8.0") {
[13:20:01.049]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:01.049]                             "", base::R.version$version.string), 
[13:20:01.049]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:01.049]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:01.049]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:01.049]                               "release", "version")], collapse = " "), 
[13:20:01.049]                             hostname = base::Sys.info()[["nodename"]])
[13:20:01.049]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:01.049]                             info)
[13:20:01.049]                           info <- base::paste(info, collapse = "; ")
[13:20:01.049]                           if (!has_future) {
[13:20:01.049]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:01.049]                               info)
[13:20:01.049]                           }
[13:20:01.049]                           else {
[13:20:01.049]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:01.049]                               info, version)
[13:20:01.049]                           }
[13:20:01.049]                           base::stop(msg)
[13:20:01.049]                         }
[13:20:01.049]                       })
[13:20:01.049]                     }
[13:20:01.049]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:01.049]                     base::options(mc.cores = 1L)
[13:20:01.049]                   }
[13:20:01.049]                   options(future.plan = NULL)
[13:20:01.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:01.049]                 }
[13:20:01.049]                 ...future.workdir <- getwd()
[13:20:01.049]             }
[13:20:01.049]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:01.049]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:01.049]         }
[13:20:01.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:01.049]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:01.049]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:01.049]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:01.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:01.049]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:01.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:01.049]             base::names(...future.oldOptions))
[13:20:01.049]     }
[13:20:01.049]     if (FALSE) {
[13:20:01.049]     }
[13:20:01.049]     else {
[13:20:01.049]         if (TRUE) {
[13:20:01.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:01.049]                 open = "w")
[13:20:01.049]         }
[13:20:01.049]         else {
[13:20:01.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:01.049]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:01.049]         }
[13:20:01.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:01.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:01.049]             base::sink(type = "output", split = FALSE)
[13:20:01.049]             base::close(...future.stdout)
[13:20:01.049]         }, add = TRUE)
[13:20:01.049]     }
[13:20:01.049]     ...future.frame <- base::sys.nframe()
[13:20:01.049]     ...future.conditions <- base::list()
[13:20:01.049]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:01.049]     if (FALSE) {
[13:20:01.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:01.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:01.049]     }
[13:20:01.049]     ...future.result <- base::tryCatch({
[13:20:01.049]         base::withCallingHandlers({
[13:20:01.049]             ...future.value <- base::withVisible(base::local({
[13:20:01.049]                 ...future.makeSendCondition <- base::local({
[13:20:01.049]                   sendCondition <- NULL
[13:20:01.049]                   function(frame = 1L) {
[13:20:01.049]                     if (is.function(sendCondition)) 
[13:20:01.049]                       return(sendCondition)
[13:20:01.049]                     ns <- getNamespace("parallel")
[13:20:01.049]                     if (exists("sendData", mode = "function", 
[13:20:01.049]                       envir = ns)) {
[13:20:01.049]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:01.049]                         envir = ns)
[13:20:01.049]                       envir <- sys.frame(frame)
[13:20:01.049]                       master <- NULL
[13:20:01.049]                       while (!identical(envir, .GlobalEnv) && 
[13:20:01.049]                         !identical(envir, emptyenv())) {
[13:20:01.049]                         if (exists("master", mode = "list", envir = envir, 
[13:20:01.049]                           inherits = FALSE)) {
[13:20:01.049]                           master <- get("master", mode = "list", 
[13:20:01.049]                             envir = envir, inherits = FALSE)
[13:20:01.049]                           if (inherits(master, c("SOCKnode", 
[13:20:01.049]                             "SOCK0node"))) {
[13:20:01.049]                             sendCondition <<- function(cond) {
[13:20:01.049]                               data <- list(type = "VALUE", value = cond, 
[13:20:01.049]                                 success = TRUE)
[13:20:01.049]                               parallel_sendData(master, data)
[13:20:01.049]                             }
[13:20:01.049]                             return(sendCondition)
[13:20:01.049]                           }
[13:20:01.049]                         }
[13:20:01.049]                         frame <- frame + 1L
[13:20:01.049]                         envir <- sys.frame(frame)
[13:20:01.049]                       }
[13:20:01.049]                     }
[13:20:01.049]                     sendCondition <<- function(cond) NULL
[13:20:01.049]                   }
[13:20:01.049]                 })
[13:20:01.049]                 withCallingHandlers({
[13:20:01.049]                   {
[13:20:01.049]                     do.call(function(...) {
[13:20:01.049]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.049]                       if (!identical(...future.globals.maxSize.org, 
[13:20:01.049]                         ...future.globals.maxSize)) {
[13:20:01.049]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.049]                         on.exit(options(oopts), add = TRUE)
[13:20:01.049]                       }
[13:20:01.049]                       {
[13:20:01.049]                         lapply(seq_along(...future.elements_ii), 
[13:20:01.049]                           FUN = function(jj) {
[13:20:01.049]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.049]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:20:01.049]                               envir = globalenv(), inherits = FALSE)
[13:20:01.049]                             ...future.FUN(...future.X_jj, ...)
[13:20:01.049]                           })
[13:20:01.049]                       }
[13:20:01.049]                     }, args = future.call.arguments)
[13:20:01.049]                   }
[13:20:01.049]                 }, immediateCondition = function(cond) {
[13:20:01.049]                   sendCondition <- ...future.makeSendCondition()
[13:20:01.049]                   sendCondition(cond)
[13:20:01.049]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.049]                   {
[13:20:01.049]                     inherits <- base::inherits
[13:20:01.049]                     invokeRestart <- base::invokeRestart
[13:20:01.049]                     is.null <- base::is.null
[13:20:01.049]                     muffled <- FALSE
[13:20:01.049]                     if (inherits(cond, "message")) {
[13:20:01.049]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:01.049]                       if (muffled) 
[13:20:01.049]                         invokeRestart("muffleMessage")
[13:20:01.049]                     }
[13:20:01.049]                     else if (inherits(cond, "warning")) {
[13:20:01.049]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:01.049]                       if (muffled) 
[13:20:01.049]                         invokeRestart("muffleWarning")
[13:20:01.049]                     }
[13:20:01.049]                     else if (inherits(cond, "condition")) {
[13:20:01.049]                       if (!is.null(pattern)) {
[13:20:01.049]                         computeRestarts <- base::computeRestarts
[13:20:01.049]                         grepl <- base::grepl
[13:20:01.049]                         restarts <- computeRestarts(cond)
[13:20:01.049]                         for (restart in restarts) {
[13:20:01.049]                           name <- restart$name
[13:20:01.049]                           if (is.null(name)) 
[13:20:01.049]                             next
[13:20:01.049]                           if (!grepl(pattern, name)) 
[13:20:01.049]                             next
[13:20:01.049]                           invokeRestart(restart)
[13:20:01.049]                           muffled <- TRUE
[13:20:01.049]                           break
[13:20:01.049]                         }
[13:20:01.049]                       }
[13:20:01.049]                     }
[13:20:01.049]                     invisible(muffled)
[13:20:01.049]                   }
[13:20:01.049]                   muffleCondition(cond)
[13:20:01.049]                 })
[13:20:01.049]             }))
[13:20:01.049]             future::FutureResult(value = ...future.value$value, 
[13:20:01.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.049]                   ...future.rng), globalenv = if (FALSE) 
[13:20:01.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:01.049]                     ...future.globalenv.names))
[13:20:01.049]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:01.049]         }, condition = base::local({
[13:20:01.049]             c <- base::c
[13:20:01.049]             inherits <- base::inherits
[13:20:01.049]             invokeRestart <- base::invokeRestart
[13:20:01.049]             length <- base::length
[13:20:01.049]             list <- base::list
[13:20:01.049]             seq.int <- base::seq.int
[13:20:01.049]             signalCondition <- base::signalCondition
[13:20:01.049]             sys.calls <- base::sys.calls
[13:20:01.049]             `[[` <- base::`[[`
[13:20:01.049]             `+` <- base::`+`
[13:20:01.049]             `<<-` <- base::`<<-`
[13:20:01.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:01.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:01.049]                   3L)]
[13:20:01.049]             }
[13:20:01.049]             function(cond) {
[13:20:01.049]                 is_error <- inherits(cond, "error")
[13:20:01.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:01.049]                   NULL)
[13:20:01.049]                 if (is_error) {
[13:20:01.049]                   sessionInformation <- function() {
[13:20:01.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:01.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:01.049]                       search = base::search(), system = base::Sys.info())
[13:20:01.049]                   }
[13:20:01.049]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:01.049]                     cond$call), session = sessionInformation(), 
[13:20:01.049]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:01.049]                   signalCondition(cond)
[13:20:01.049]                 }
[13:20:01.049]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:20:01.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:01.049]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:01.049]                   if (TRUE && !signal) {
[13:20:01.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.049]                     {
[13:20:01.049]                       inherits <- base::inherits
[13:20:01.049]                       invokeRestart <- base::invokeRestart
[13:20:01.049]                       is.null <- base::is.null
[13:20:01.049]                       muffled <- FALSE
[13:20:01.049]                       if (inherits(cond, "message")) {
[13:20:01.049]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.049]                         if (muffled) 
[13:20:01.049]                           invokeRestart("muffleMessage")
[13:20:01.049]                       }
[13:20:01.049]                       else if (inherits(cond, "warning")) {
[13:20:01.049]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.049]                         if (muffled) 
[13:20:01.049]                           invokeRestart("muffleWarning")
[13:20:01.049]                       }
[13:20:01.049]                       else if (inherits(cond, "condition")) {
[13:20:01.049]                         if (!is.null(pattern)) {
[13:20:01.049]                           computeRestarts <- base::computeRestarts
[13:20:01.049]                           grepl <- base::grepl
[13:20:01.049]                           restarts <- computeRestarts(cond)
[13:20:01.049]                           for (restart in restarts) {
[13:20:01.049]                             name <- restart$name
[13:20:01.049]                             if (is.null(name)) 
[13:20:01.049]                               next
[13:20:01.049]                             if (!grepl(pattern, name)) 
[13:20:01.049]                               next
[13:20:01.049]                             invokeRestart(restart)
[13:20:01.049]                             muffled <- TRUE
[13:20:01.049]                             break
[13:20:01.049]                           }
[13:20:01.049]                         }
[13:20:01.049]                       }
[13:20:01.049]                       invisible(muffled)
[13:20:01.049]                     }
[13:20:01.049]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.049]                   }
[13:20:01.049]                 }
[13:20:01.049]                 else {
[13:20:01.049]                   if (TRUE) {
[13:20:01.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.049]                     {
[13:20:01.049]                       inherits <- base::inherits
[13:20:01.049]                       invokeRestart <- base::invokeRestart
[13:20:01.049]                       is.null <- base::is.null
[13:20:01.049]                       muffled <- FALSE
[13:20:01.049]                       if (inherits(cond, "message")) {
[13:20:01.049]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.049]                         if (muffled) 
[13:20:01.049]                           invokeRestart("muffleMessage")
[13:20:01.049]                       }
[13:20:01.049]                       else if (inherits(cond, "warning")) {
[13:20:01.049]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.049]                         if (muffled) 
[13:20:01.049]                           invokeRestart("muffleWarning")
[13:20:01.049]                       }
[13:20:01.049]                       else if (inherits(cond, "condition")) {
[13:20:01.049]                         if (!is.null(pattern)) {
[13:20:01.049]                           computeRestarts <- base::computeRestarts
[13:20:01.049]                           grepl <- base::grepl
[13:20:01.049]                           restarts <- computeRestarts(cond)
[13:20:01.049]                           for (restart in restarts) {
[13:20:01.049]                             name <- restart$name
[13:20:01.049]                             if (is.null(name)) 
[13:20:01.049]                               next
[13:20:01.049]                             if (!grepl(pattern, name)) 
[13:20:01.049]                               next
[13:20:01.049]                             invokeRestart(restart)
[13:20:01.049]                             muffled <- TRUE
[13:20:01.049]                             break
[13:20:01.049]                           }
[13:20:01.049]                         }
[13:20:01.049]                       }
[13:20:01.049]                       invisible(muffled)
[13:20:01.049]                     }
[13:20:01.049]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.049]                   }
[13:20:01.049]                 }
[13:20:01.049]             }
[13:20:01.049]         }))
[13:20:01.049]     }, error = function(ex) {
[13:20:01.049]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:01.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.049]                 ...future.rng), started = ...future.startTime, 
[13:20:01.049]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:01.049]             version = "1.8"), class = "FutureResult")
[13:20:01.049]     }, finally = {
[13:20:01.049]         if (!identical(...future.workdir, getwd())) 
[13:20:01.049]             setwd(...future.workdir)
[13:20:01.049]         {
[13:20:01.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:01.049]                 ...future.oldOptions$nwarnings <- NULL
[13:20:01.049]             }
[13:20:01.049]             base::options(...future.oldOptions)
[13:20:01.049]             if (.Platform$OS.type == "windows") {
[13:20:01.049]                 old_names <- names(...future.oldEnvVars)
[13:20:01.049]                 envs <- base::Sys.getenv()
[13:20:01.049]                 names <- names(envs)
[13:20:01.049]                 common <- intersect(names, old_names)
[13:20:01.049]                 added <- setdiff(names, old_names)
[13:20:01.049]                 removed <- setdiff(old_names, names)
[13:20:01.049]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:01.049]                   envs[common]]
[13:20:01.049]                 NAMES <- toupper(changed)
[13:20:01.049]                 args <- list()
[13:20:01.049]                 for (kk in seq_along(NAMES)) {
[13:20:01.049]                   name <- changed[[kk]]
[13:20:01.049]                   NAME <- NAMES[[kk]]
[13:20:01.049]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.049]                     next
[13:20:01.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.049]                 }
[13:20:01.049]                 NAMES <- toupper(added)
[13:20:01.049]                 for (kk in seq_along(NAMES)) {
[13:20:01.049]                   name <- added[[kk]]
[13:20:01.049]                   NAME <- NAMES[[kk]]
[13:20:01.049]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.049]                     next
[13:20:01.049]                   args[[name]] <- ""
[13:20:01.049]                 }
[13:20:01.049]                 NAMES <- toupper(removed)
[13:20:01.049]                 for (kk in seq_along(NAMES)) {
[13:20:01.049]                   name <- removed[[kk]]
[13:20:01.049]                   NAME <- NAMES[[kk]]
[13:20:01.049]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.049]                     next
[13:20:01.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.049]                 }
[13:20:01.049]                 if (length(args) > 0) 
[13:20:01.049]                   base::do.call(base::Sys.setenv, args = args)
[13:20:01.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:01.049]             }
[13:20:01.049]             else {
[13:20:01.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:01.049]             }
[13:20:01.049]             {
[13:20:01.049]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:01.049]                   0L) {
[13:20:01.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:01.049]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:01.049]                   base::options(opts)
[13:20:01.049]                 }
[13:20:01.049]                 {
[13:20:01.049]                   {
[13:20:01.049]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:01.049]                     NULL
[13:20:01.049]                   }
[13:20:01.049]                   options(future.plan = NULL)
[13:20:01.049]                   if (is.na(NA_character_)) 
[13:20:01.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:01.049]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:01.049]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:01.049]                     envir = parent.frame()) 
[13:20:01.049]                   {
[13:20:01.049]                     if (is.function(workers)) 
[13:20:01.049]                       workers <- workers()
[13:20:01.049]                     workers <- structure(as.integer(workers), 
[13:20:01.049]                       class = class(workers))
[13:20:01.049]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:01.049]                       workers >= 1)
[13:20:01.049]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:01.049]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:01.049]                     }
[13:20:01.049]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:01.049]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:01.049]                       envir = envir)
[13:20:01.049]                     if (!future$lazy) 
[13:20:01.049]                       future <- run(future)
[13:20:01.049]                     invisible(future)
[13:20:01.049]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:01.049]                 }
[13:20:01.049]             }
[13:20:01.049]         }
[13:20:01.049]     })
[13:20:01.049]     if (TRUE) {
[13:20:01.049]         base::sink(type = "output", split = FALSE)
[13:20:01.049]         if (TRUE) {
[13:20:01.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:01.049]         }
[13:20:01.049]         else {
[13:20:01.049]             ...future.result["stdout"] <- base::list(NULL)
[13:20:01.049]         }
[13:20:01.049]         base::close(...future.stdout)
[13:20:01.049]         ...future.stdout <- NULL
[13:20:01.049]     }
[13:20:01.049]     ...future.result$conditions <- ...future.conditions
[13:20:01.049]     ...future.result$finished <- base::Sys.time()
[13:20:01.049]     ...future.result
[13:20:01.049] }
[13:20:01.053] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[13:20:01.053] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:01.053] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:01.053] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[13:20:01.096] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[13:20:01.096] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:20:01.097] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:20:01.097] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[13:20:01.097] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[13:20:01.097] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:20:01.098] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:20:01.098] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[13:20:01.098] MultisessionFuture started
[13:20:01.099] - Launch lazy future ... done
[13:20:01.099] run() for ‘MultisessionFuture’ ... done
[13:20:01.099] Created future:
[13:20:01.099] MultisessionFuture:
[13:20:01.099] Label: ‘future_apply-1’
[13:20:01.099] Expression:
[13:20:01.099] {
[13:20:01.099]     do.call(function(...) {
[13:20:01.099]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.099]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.099]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.099]             on.exit(options(oopts), add = TRUE)
[13:20:01.099]         }
[13:20:01.099]         {
[13:20:01.099]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.099]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.099]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:20:01.099]                   envir = globalenv(), inherits = FALSE)
[13:20:01.099]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.099]             })
[13:20:01.099]         }
[13:20:01.099]     }, args = future.call.arguments)
[13:20:01.099] }
[13:20:01.099] Lazy evaluation: FALSE
[13:20:01.099] Asynchronous evaluation: TRUE
[13:20:01.099] Local evaluation: TRUE
[13:20:01.099] Environment: R_GlobalEnv
[13:20:01.099] Capture standard output: TRUE
[13:20:01.099] Capture condition classes: <none>
[13:20:01.099] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:01.099] Packages: <none>
[13:20:01.099] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:20:01.099] Resolved: FALSE
[13:20:01.099] Value: <not collected>
[13:20:01.099] Conditions captured: <none>
[13:20:01.099] Early signaling: FALSE
[13:20:01.099] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:01.099] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:01.111] Chunk #1 of 2 ... DONE
[13:20:01.111] Chunk #2 of 2 ...
[13:20:01.111]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:20:01.111]  - seeds: [1] <seeds>
[13:20:01.111]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.111] getGlobalsAndPackages() ...
[13:20:01.111] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.111] Resolving globals: FALSE
[13:20:01.111] Tweak future expression to call with '...' arguments ...
[13:20:01.112] {
[13:20:01.112]     do.call(function(...) {
[13:20:01.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.112]             on.exit(options(oopts), add = TRUE)
[13:20:01.112]         }
[13:20:01.112]         {
[13:20:01.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.112]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:20:01.112]                   envir = globalenv(), inherits = FALSE)
[13:20:01.112]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.112]             })
[13:20:01.112]         }
[13:20:01.112]     }, args = future.call.arguments)
[13:20:01.112] }
[13:20:01.112] Tweak future expression to call with '...' arguments ... DONE
[13:20:01.112] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.112] 
[13:20:01.113] getGlobalsAndPackages() ... DONE
[13:20:01.113] run() for ‘Future’ ...
[13:20:01.113] - state: ‘created’
[13:20:01.113] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:01.127] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:01.127] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:01.127]   - Field: ‘node’
[13:20:01.128]   - Field: ‘label’
[13:20:01.128]   - Field: ‘local’
[13:20:01.128]   - Field: ‘owner’
[13:20:01.128]   - Field: ‘envir’
[13:20:01.128]   - Field: ‘workers’
[13:20:01.128]   - Field: ‘packages’
[13:20:01.128]   - Field: ‘gc’
[13:20:01.128]   - Field: ‘conditions’
[13:20:01.128]   - Field: ‘persistent’
[13:20:01.129]   - Field: ‘expr’
[13:20:01.129]   - Field: ‘uuid’
[13:20:01.129]   - Field: ‘seed’
[13:20:01.129]   - Field: ‘version’
[13:20:01.129]   - Field: ‘result’
[13:20:01.129]   - Field: ‘asynchronous’
[13:20:01.129]   - Field: ‘calls’
[13:20:01.129]   - Field: ‘globals’
[13:20:01.129]   - Field: ‘stdout’
[13:20:01.129]   - Field: ‘earlySignal’
[13:20:01.129]   - Field: ‘lazy’
[13:20:01.130]   - Field: ‘state’
[13:20:01.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:01.130] - Launch lazy future ...
[13:20:01.130] Packages needed by the future expression (n = 0): <none>
[13:20:01.130] Packages needed by future strategies (n = 0): <none>
[13:20:01.131] {
[13:20:01.131]     {
[13:20:01.131]         {
[13:20:01.131]             ...future.startTime <- base::Sys.time()
[13:20:01.131]             {
[13:20:01.131]                 {
[13:20:01.131]                   {
[13:20:01.131]                     {
[13:20:01.131]                       base::local({
[13:20:01.131]                         has_future <- base::requireNamespace("future", 
[13:20:01.131]                           quietly = TRUE)
[13:20:01.131]                         if (has_future) {
[13:20:01.131]                           ns <- base::getNamespace("future")
[13:20:01.131]                           version <- ns[[".package"]][["version"]]
[13:20:01.131]                           if (is.null(version)) 
[13:20:01.131]                             version <- utils::packageVersion("future")
[13:20:01.131]                         }
[13:20:01.131]                         else {
[13:20:01.131]                           version <- NULL
[13:20:01.131]                         }
[13:20:01.131]                         if (!has_future || version < "1.8.0") {
[13:20:01.131]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:01.131]                             "", base::R.version$version.string), 
[13:20:01.131]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:01.131]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:01.131]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:01.131]                               "release", "version")], collapse = " "), 
[13:20:01.131]                             hostname = base::Sys.info()[["nodename"]])
[13:20:01.131]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:01.131]                             info)
[13:20:01.131]                           info <- base::paste(info, collapse = "; ")
[13:20:01.131]                           if (!has_future) {
[13:20:01.131]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:01.131]                               info)
[13:20:01.131]                           }
[13:20:01.131]                           else {
[13:20:01.131]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:01.131]                               info, version)
[13:20:01.131]                           }
[13:20:01.131]                           base::stop(msg)
[13:20:01.131]                         }
[13:20:01.131]                       })
[13:20:01.131]                     }
[13:20:01.131]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:01.131]                     base::options(mc.cores = 1L)
[13:20:01.131]                   }
[13:20:01.131]                   options(future.plan = NULL)
[13:20:01.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:01.131]                 }
[13:20:01.131]                 ...future.workdir <- getwd()
[13:20:01.131]             }
[13:20:01.131]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:01.131]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:01.131]         }
[13:20:01.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:01.131]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:20:01.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:01.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:01.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:01.131]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:01.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:01.131]             base::names(...future.oldOptions))
[13:20:01.131]     }
[13:20:01.131]     if (FALSE) {
[13:20:01.131]     }
[13:20:01.131]     else {
[13:20:01.131]         if (TRUE) {
[13:20:01.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:01.131]                 open = "w")
[13:20:01.131]         }
[13:20:01.131]         else {
[13:20:01.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:01.131]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:01.131]         }
[13:20:01.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:01.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:01.131]             base::sink(type = "output", split = FALSE)
[13:20:01.131]             base::close(...future.stdout)
[13:20:01.131]         }, add = TRUE)
[13:20:01.131]     }
[13:20:01.131]     ...future.frame <- base::sys.nframe()
[13:20:01.131]     ...future.conditions <- base::list()
[13:20:01.131]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:01.131]     if (FALSE) {
[13:20:01.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:01.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:01.131]     }
[13:20:01.131]     ...future.result <- base::tryCatch({
[13:20:01.131]         base::withCallingHandlers({
[13:20:01.131]             ...future.value <- base::withVisible(base::local({
[13:20:01.131]                 ...future.makeSendCondition <- base::local({
[13:20:01.131]                   sendCondition <- NULL
[13:20:01.131]                   function(frame = 1L) {
[13:20:01.131]                     if (is.function(sendCondition)) 
[13:20:01.131]                       return(sendCondition)
[13:20:01.131]                     ns <- getNamespace("parallel")
[13:20:01.131]                     if (exists("sendData", mode = "function", 
[13:20:01.131]                       envir = ns)) {
[13:20:01.131]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:01.131]                         envir = ns)
[13:20:01.131]                       envir <- sys.frame(frame)
[13:20:01.131]                       master <- NULL
[13:20:01.131]                       while (!identical(envir, .GlobalEnv) && 
[13:20:01.131]                         !identical(envir, emptyenv())) {
[13:20:01.131]                         if (exists("master", mode = "list", envir = envir, 
[13:20:01.131]                           inherits = FALSE)) {
[13:20:01.131]                           master <- get("master", mode = "list", 
[13:20:01.131]                             envir = envir, inherits = FALSE)
[13:20:01.131]                           if (inherits(master, c("SOCKnode", 
[13:20:01.131]                             "SOCK0node"))) {
[13:20:01.131]                             sendCondition <<- function(cond) {
[13:20:01.131]                               data <- list(type = "VALUE", value = cond, 
[13:20:01.131]                                 success = TRUE)
[13:20:01.131]                               parallel_sendData(master, data)
[13:20:01.131]                             }
[13:20:01.131]                             return(sendCondition)
[13:20:01.131]                           }
[13:20:01.131]                         }
[13:20:01.131]                         frame <- frame + 1L
[13:20:01.131]                         envir <- sys.frame(frame)
[13:20:01.131]                       }
[13:20:01.131]                     }
[13:20:01.131]                     sendCondition <<- function(cond) NULL
[13:20:01.131]                   }
[13:20:01.131]                 })
[13:20:01.131]                 withCallingHandlers({
[13:20:01.131]                   {
[13:20:01.131]                     do.call(function(...) {
[13:20:01.131]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.131]                       if (!identical(...future.globals.maxSize.org, 
[13:20:01.131]                         ...future.globals.maxSize)) {
[13:20:01.131]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.131]                         on.exit(options(oopts), add = TRUE)
[13:20:01.131]                       }
[13:20:01.131]                       {
[13:20:01.131]                         lapply(seq_along(...future.elements_ii), 
[13:20:01.131]                           FUN = function(jj) {
[13:20:01.131]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.131]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:20:01.131]                               envir = globalenv(), inherits = FALSE)
[13:20:01.131]                             ...future.FUN(...future.X_jj, ...)
[13:20:01.131]                           })
[13:20:01.131]                       }
[13:20:01.131]                     }, args = future.call.arguments)
[13:20:01.131]                   }
[13:20:01.131]                 }, immediateCondition = function(cond) {
[13:20:01.131]                   sendCondition <- ...future.makeSendCondition()
[13:20:01.131]                   sendCondition(cond)
[13:20:01.131]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.131]                   {
[13:20:01.131]                     inherits <- base::inherits
[13:20:01.131]                     invokeRestart <- base::invokeRestart
[13:20:01.131]                     is.null <- base::is.null
[13:20:01.131]                     muffled <- FALSE
[13:20:01.131]                     if (inherits(cond, "message")) {
[13:20:01.131]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:01.131]                       if (muffled) 
[13:20:01.131]                         invokeRestart("muffleMessage")
[13:20:01.131]                     }
[13:20:01.131]                     else if (inherits(cond, "warning")) {
[13:20:01.131]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:01.131]                       if (muffled) 
[13:20:01.131]                         invokeRestart("muffleWarning")
[13:20:01.131]                     }
[13:20:01.131]                     else if (inherits(cond, "condition")) {
[13:20:01.131]                       if (!is.null(pattern)) {
[13:20:01.131]                         computeRestarts <- base::computeRestarts
[13:20:01.131]                         grepl <- base::grepl
[13:20:01.131]                         restarts <- computeRestarts(cond)
[13:20:01.131]                         for (restart in restarts) {
[13:20:01.131]                           name <- restart$name
[13:20:01.131]                           if (is.null(name)) 
[13:20:01.131]                             next
[13:20:01.131]                           if (!grepl(pattern, name)) 
[13:20:01.131]                             next
[13:20:01.131]                           invokeRestart(restart)
[13:20:01.131]                           muffled <- TRUE
[13:20:01.131]                           break
[13:20:01.131]                         }
[13:20:01.131]                       }
[13:20:01.131]                     }
[13:20:01.131]                     invisible(muffled)
[13:20:01.131]                   }
[13:20:01.131]                   muffleCondition(cond)
[13:20:01.131]                 })
[13:20:01.131]             }))
[13:20:01.131]             future::FutureResult(value = ...future.value$value, 
[13:20:01.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.131]                   ...future.rng), globalenv = if (FALSE) 
[13:20:01.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:01.131]                     ...future.globalenv.names))
[13:20:01.131]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:01.131]         }, condition = base::local({
[13:20:01.131]             c <- base::c
[13:20:01.131]             inherits <- base::inherits
[13:20:01.131]             invokeRestart <- base::invokeRestart
[13:20:01.131]             length <- base::length
[13:20:01.131]             list <- base::list
[13:20:01.131]             seq.int <- base::seq.int
[13:20:01.131]             signalCondition <- base::signalCondition
[13:20:01.131]             sys.calls <- base::sys.calls
[13:20:01.131]             `[[` <- base::`[[`
[13:20:01.131]             `+` <- base::`+`
[13:20:01.131]             `<<-` <- base::`<<-`
[13:20:01.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:01.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:01.131]                   3L)]
[13:20:01.131]             }
[13:20:01.131]             function(cond) {
[13:20:01.131]                 is_error <- inherits(cond, "error")
[13:20:01.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:01.131]                   NULL)
[13:20:01.131]                 if (is_error) {
[13:20:01.131]                   sessionInformation <- function() {
[13:20:01.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:01.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:01.131]                       search = base::search(), system = base::Sys.info())
[13:20:01.131]                   }
[13:20:01.131]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:01.131]                     cond$call), session = sessionInformation(), 
[13:20:01.131]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:01.131]                   signalCondition(cond)
[13:20:01.131]                 }
[13:20:01.131]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:20:01.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:01.131]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:01.131]                   if (TRUE && !signal) {
[13:20:01.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.131]                     {
[13:20:01.131]                       inherits <- base::inherits
[13:20:01.131]                       invokeRestart <- base::invokeRestart
[13:20:01.131]                       is.null <- base::is.null
[13:20:01.131]                       muffled <- FALSE
[13:20:01.131]                       if (inherits(cond, "message")) {
[13:20:01.131]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.131]                         if (muffled) 
[13:20:01.131]                           invokeRestart("muffleMessage")
[13:20:01.131]                       }
[13:20:01.131]                       else if (inherits(cond, "warning")) {
[13:20:01.131]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.131]                         if (muffled) 
[13:20:01.131]                           invokeRestart("muffleWarning")
[13:20:01.131]                       }
[13:20:01.131]                       else if (inherits(cond, "condition")) {
[13:20:01.131]                         if (!is.null(pattern)) {
[13:20:01.131]                           computeRestarts <- base::computeRestarts
[13:20:01.131]                           grepl <- base::grepl
[13:20:01.131]                           restarts <- computeRestarts(cond)
[13:20:01.131]                           for (restart in restarts) {
[13:20:01.131]                             name <- restart$name
[13:20:01.131]                             if (is.null(name)) 
[13:20:01.131]                               next
[13:20:01.131]                             if (!grepl(pattern, name)) 
[13:20:01.131]                               next
[13:20:01.131]                             invokeRestart(restart)
[13:20:01.131]                             muffled <- TRUE
[13:20:01.131]                             break
[13:20:01.131]                           }
[13:20:01.131]                         }
[13:20:01.131]                       }
[13:20:01.131]                       invisible(muffled)
[13:20:01.131]                     }
[13:20:01.131]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.131]                   }
[13:20:01.131]                 }
[13:20:01.131]                 else {
[13:20:01.131]                   if (TRUE) {
[13:20:01.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.131]                     {
[13:20:01.131]                       inherits <- base::inherits
[13:20:01.131]                       invokeRestart <- base::invokeRestart
[13:20:01.131]                       is.null <- base::is.null
[13:20:01.131]                       muffled <- FALSE
[13:20:01.131]                       if (inherits(cond, "message")) {
[13:20:01.131]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.131]                         if (muffled) 
[13:20:01.131]                           invokeRestart("muffleMessage")
[13:20:01.131]                       }
[13:20:01.131]                       else if (inherits(cond, "warning")) {
[13:20:01.131]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.131]                         if (muffled) 
[13:20:01.131]                           invokeRestart("muffleWarning")
[13:20:01.131]                       }
[13:20:01.131]                       else if (inherits(cond, "condition")) {
[13:20:01.131]                         if (!is.null(pattern)) {
[13:20:01.131]                           computeRestarts <- base::computeRestarts
[13:20:01.131]                           grepl <- base::grepl
[13:20:01.131]                           restarts <- computeRestarts(cond)
[13:20:01.131]                           for (restart in restarts) {
[13:20:01.131]                             name <- restart$name
[13:20:01.131]                             if (is.null(name)) 
[13:20:01.131]                               next
[13:20:01.131]                             if (!grepl(pattern, name)) 
[13:20:01.131]                               next
[13:20:01.131]                             invokeRestart(restart)
[13:20:01.131]                             muffled <- TRUE
[13:20:01.131]                             break
[13:20:01.131]                           }
[13:20:01.131]                         }
[13:20:01.131]                       }
[13:20:01.131]                       invisible(muffled)
[13:20:01.131]                     }
[13:20:01.131]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.131]                   }
[13:20:01.131]                 }
[13:20:01.131]             }
[13:20:01.131]         }))
[13:20:01.131]     }, error = function(ex) {
[13:20:01.131]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:01.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.131]                 ...future.rng), started = ...future.startTime, 
[13:20:01.131]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:01.131]             version = "1.8"), class = "FutureResult")
[13:20:01.131]     }, finally = {
[13:20:01.131]         if (!identical(...future.workdir, getwd())) 
[13:20:01.131]             setwd(...future.workdir)
[13:20:01.131]         {
[13:20:01.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:01.131]                 ...future.oldOptions$nwarnings <- NULL
[13:20:01.131]             }
[13:20:01.131]             base::options(...future.oldOptions)
[13:20:01.131]             if (.Platform$OS.type == "windows") {
[13:20:01.131]                 old_names <- names(...future.oldEnvVars)
[13:20:01.131]                 envs <- base::Sys.getenv()
[13:20:01.131]                 names <- names(envs)
[13:20:01.131]                 common <- intersect(names, old_names)
[13:20:01.131]                 added <- setdiff(names, old_names)
[13:20:01.131]                 removed <- setdiff(old_names, names)
[13:20:01.131]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:01.131]                   envs[common]]
[13:20:01.131]                 NAMES <- toupper(changed)
[13:20:01.131]                 args <- list()
[13:20:01.131]                 for (kk in seq_along(NAMES)) {
[13:20:01.131]                   name <- changed[[kk]]
[13:20:01.131]                   NAME <- NAMES[[kk]]
[13:20:01.131]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.131]                     next
[13:20:01.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.131]                 }
[13:20:01.131]                 NAMES <- toupper(added)
[13:20:01.131]                 for (kk in seq_along(NAMES)) {
[13:20:01.131]                   name <- added[[kk]]
[13:20:01.131]                   NAME <- NAMES[[kk]]
[13:20:01.131]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.131]                     next
[13:20:01.131]                   args[[name]] <- ""
[13:20:01.131]                 }
[13:20:01.131]                 NAMES <- toupper(removed)
[13:20:01.131]                 for (kk in seq_along(NAMES)) {
[13:20:01.131]                   name <- removed[[kk]]
[13:20:01.131]                   NAME <- NAMES[[kk]]
[13:20:01.131]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.131]                     next
[13:20:01.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.131]                 }
[13:20:01.131]                 if (length(args) > 0) 
[13:20:01.131]                   base::do.call(base::Sys.setenv, args = args)
[13:20:01.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:01.131]             }
[13:20:01.131]             else {
[13:20:01.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:01.131]             }
[13:20:01.131]             {
[13:20:01.131]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:01.131]                   0L) {
[13:20:01.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:01.131]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:01.131]                   base::options(opts)
[13:20:01.131]                 }
[13:20:01.131]                 {
[13:20:01.131]                   {
[13:20:01.131]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:01.131]                     NULL
[13:20:01.131]                   }
[13:20:01.131]                   options(future.plan = NULL)
[13:20:01.131]                   if (is.na(NA_character_)) 
[13:20:01.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:01.131]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:01.131]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:01.131]                     envir = parent.frame()) 
[13:20:01.131]                   {
[13:20:01.131]                     if (is.function(workers)) 
[13:20:01.131]                       workers <- workers()
[13:20:01.131]                     workers <- structure(as.integer(workers), 
[13:20:01.131]                       class = class(workers))
[13:20:01.131]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:01.131]                       workers >= 1)
[13:20:01.131]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:01.131]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:01.131]                     }
[13:20:01.131]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:01.131]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:01.131]                       envir = envir)
[13:20:01.131]                     if (!future$lazy) 
[13:20:01.131]                       future <- run(future)
[13:20:01.131]                     invisible(future)
[13:20:01.131]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:01.131]                 }
[13:20:01.131]             }
[13:20:01.131]         }
[13:20:01.131]     })
[13:20:01.131]     if (TRUE) {
[13:20:01.131]         base::sink(type = "output", split = FALSE)
[13:20:01.131]         if (TRUE) {
[13:20:01.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:01.131]         }
[13:20:01.131]         else {
[13:20:01.131]             ...future.result["stdout"] <- base::list(NULL)
[13:20:01.131]         }
[13:20:01.131]         base::close(...future.stdout)
[13:20:01.131]         ...future.stdout <- NULL
[13:20:01.131]     }
[13:20:01.131]     ...future.result$conditions <- ...future.conditions
[13:20:01.131]     ...future.result$finished <- base::Sys.time()
[13:20:01.131]     ...future.result
[13:20:01.131] }
[13:20:01.134] Exporting 5 global objects (35.63 KiB) to cluster node #2 ...
[13:20:01.134] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:01.135] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:01.135] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ...
[13:20:01.176] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ... DONE
[13:20:01.177] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:20:01.177] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:20:01.177] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[13:20:01.177] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[13:20:01.178] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:20:01.178] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:20:01.178] Exporting 5 global objects (35.63 KiB) to cluster node #2 ... DONE
[13:20:01.179] MultisessionFuture started
[13:20:01.179] - Launch lazy future ... done
[13:20:01.179] run() for ‘MultisessionFuture’ ... done
[13:20:01.179] Created future:
[13:20:01.179] MultisessionFuture:
[13:20:01.179] Label: ‘future_apply-2’
[13:20:01.179] Expression:
[13:20:01.179] {
[13:20:01.179]     do.call(function(...) {
[13:20:01.179]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.179]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.179]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.179]             on.exit(options(oopts), add = TRUE)
[13:20:01.179]         }
[13:20:01.179]         {
[13:20:01.179]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.179]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.179]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:20:01.179]                   envir = globalenv(), inherits = FALSE)
[13:20:01.179]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.179]             })
[13:20:01.179]         }
[13:20:01.179]     }, args = future.call.arguments)
[13:20:01.179] }
[13:20:01.179] Lazy evaluation: FALSE
[13:20:01.179] Asynchronous evaluation: TRUE
[13:20:01.179] Local evaluation: TRUE
[13:20:01.179] Environment: R_GlobalEnv
[13:20:01.179] Capture standard output: TRUE
[13:20:01.179] Capture condition classes: <none>
[13:20:01.179] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:20:01.179] Packages: <none>
[13:20:01.179] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:20:01.179] Resolved: FALSE
[13:20:01.179] Value: <not collected>
[13:20:01.179] Conditions captured: <none>
[13:20:01.179] Early signaling: FALSE
[13:20:01.179] Owner process: 16b97ac9-6442-d8f1-6ee7-bfaf7020c146
[13:20:01.179] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:01.191] Chunk #2 of 2 ... DONE
[13:20:01.194] Launching 2 futures (chunks) ... DONE
[13:20:01.194] Resolving 2 futures (chunks) ...
[13:20:01.194] resolve() on list ...
[13:20:01.194]  recursive: 0
[13:20:01.194]  length: 2
[13:20:01.194] 
[13:20:01.195] receiveMessageFromWorker() for ClusterFuture ...
[13:20:01.195] - Validating connection of MultisessionFuture
[13:20:01.195] - received message: FutureResult
[13:20:01.195] - Received FutureResult
[13:20:01.195] - Erased future from FutureRegistry
[13:20:01.195] result() for ClusterFuture ...
[13:20:01.195] - result already collected: FutureResult
[13:20:01.196] result() for ClusterFuture ... done
[13:20:01.196] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:01.196] Future #1
[13:20:01.196] result() for ClusterFuture ...
[13:20:01.196] - result already collected: FutureResult
[13:20:01.196] result() for ClusterFuture ... done
[13:20:01.196] result() for ClusterFuture ...
[13:20:01.196] - result already collected: FutureResult
[13:20:01.196] result() for ClusterFuture ... done
[13:20:01.196] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:01.196] - nx: 2
[13:20:01.197] - relay: TRUE
[13:20:01.197] - stdout: TRUE
[13:20:01.197] - signal: TRUE
[13:20:01.197] - resignal: FALSE
[13:20:01.197] - force: TRUE
[13:20:01.197] - relayed: [n=2] FALSE, FALSE
[13:20:01.197] - queued futures: [n=2] FALSE, FALSE
[13:20:01.197]  - until=1
[13:20:01.197]  - relaying element #1
[13:20:01.197] result() for ClusterFuture ...
[13:20:01.197] - result already collected: FutureResult
[13:20:01.197] result() for ClusterFuture ... done
[13:20:01.198] result() for ClusterFuture ...
[13:20:01.198] - result already collected: FutureResult
[13:20:01.198] result() for ClusterFuture ... done
[13:20:01.198] result() for ClusterFuture ...
[13:20:01.198] - result already collected: FutureResult
[13:20:01.198] result() for ClusterFuture ... done
[13:20:01.198] result() for ClusterFuture ...
[13:20:01.198] - result already collected: FutureResult
[13:20:01.198] result() for ClusterFuture ... done
[13:20:01.198] - relayed: [n=2] TRUE, FALSE
[13:20:01.198] - queued futures: [n=2] TRUE, FALSE
[13:20:01.198] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:01.199]  length: 1 (resolved future 1)
[13:20:01.225] receiveMessageFromWorker() for ClusterFuture ...
[13:20:01.225] - Validating connection of MultisessionFuture
[13:20:01.225] - received message: FutureResult
[13:20:01.226] - Received FutureResult
[13:20:01.226] - Erased future from FutureRegistry
[13:20:01.226] result() for ClusterFuture ...
[13:20:01.226] - result already collected: FutureResult
[13:20:01.226] result() for ClusterFuture ... done
[13:20:01.226] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:01.226] Future #2
[13:20:01.226] result() for ClusterFuture ...
[13:20:01.226] - result already collected: FutureResult
[13:20:01.226] result() for ClusterFuture ... done
[13:20:01.226] result() for ClusterFuture ...
[13:20:01.227] - result already collected: FutureResult
[13:20:01.227] result() for ClusterFuture ... done
[13:20:01.227] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:01.227] - nx: 2
[13:20:01.227] - relay: TRUE
[13:20:01.227] - stdout: TRUE
[13:20:01.227] - signal: TRUE
[13:20:01.227] - resignal: FALSE
[13:20:01.227] - force: TRUE
[13:20:01.227] - relayed: [n=2] TRUE, FALSE
[13:20:01.227] - queued futures: [n=2] TRUE, FALSE
[13:20:01.228]  - until=2
[13:20:01.228]  - relaying element #2
[13:20:01.228] result() for ClusterFuture ...
[13:20:01.228] - result already collected: FutureResult
[13:20:01.228] result() for ClusterFuture ... done
[13:20:01.228] result() for ClusterFuture ...
[13:20:01.228] - result already collected: FutureResult
[13:20:01.228] result() for ClusterFuture ... done
[13:20:01.228] result() for ClusterFuture ...
[13:20:01.228] - result already collected: FutureResult
[13:20:01.228] result() for ClusterFuture ... done
[13:20:01.229] result() for ClusterFuture ...
[13:20:01.229] - result already collected: FutureResult
[13:20:01.229] result() for ClusterFuture ... done
[13:20:01.229] - relayed: [n=2] TRUE, TRUE
[13:20:01.229] - queued futures: [n=2] TRUE, TRUE
[13:20:01.229] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:01.229]  length: 0 (resolved future 2)
[13:20:01.229] Relaying remaining futures
[13:20:01.229] signalConditionsASAP(NULL, pos=0) ...
[13:20:01.229] - nx: 2
[13:20:01.229] - relay: TRUE
[13:20:01.230] - stdout: TRUE
[13:20:01.230] - signal: TRUE
[13:20:01.230] - resignal: FALSE
[13:20:01.230] - force: TRUE
[13:20:01.230] - relayed: [n=2] TRUE, TRUE
[13:20:01.230] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:01.230] - relayed: [n=2] TRUE, TRUE
[13:20:01.230] - queued futures: [n=2] TRUE, TRUE
[13:20:01.230] signalConditionsASAP(NULL, pos=0) ... done
[13:20:01.230] resolve() on list ... DONE
[13:20:01.230] result() for ClusterFuture ...
[13:20:01.231] - result already collected: FutureResult
[13:20:01.231] result() for ClusterFuture ... done
[13:20:01.231] result() for ClusterFuture ...
[13:20:01.231] - result already collected: FutureResult
[13:20:01.231] result() for ClusterFuture ... done
[13:20:01.231] result() for ClusterFuture ...
[13:20:01.231] - result already collected: FutureResult
[13:20:01.231] result() for ClusterFuture ... done
[13:20:01.231] result() for ClusterFuture ...
[13:20:01.231] - result already collected: FutureResult
[13:20:01.231] result() for ClusterFuture ... done
[13:20:01.232]  - Number of value chunks collected: 2
[13:20:01.232] Resolving 2 futures (chunks) ... DONE
[13:20:01.232] Reducing values from 2 chunks ...
[13:20:01.232]  - Number of values collected after concatenation: 2
[13:20:01.232]  - Number of values expected: 2
[13:20:01.232] Reducing values from 2 chunks ... DONE
[13:20:01.232] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[13:20:01.232] plan(): Setting new future strategy stack:
[13:20:01.233] List of future strategies:
[13:20:01.233] 1. sequential:
[13:20:01.233]    - args: function (..., envir = parent.frame())
[13:20:01.233]    - tweaked: FALSE
[13:20:01.233]    - call: plan(sequential)
[13:20:01.233] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[13:20:01.235] plan(): Setting new future strategy stack:
[13:20:01.235] List of future strategies:
[13:20:01.235] 1. FutureStrategy:
[13:20:01.235]    - args: function (..., envir = parent.frame())
[13:20:01.235]    - tweaked: FALSE
[13:20:01.235]    - call: future::plan(oplan)
[13:20:01.236] plan(): nbrOfWorkers() = 1
> 
